<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TreeListy - Universal Project Decomposition by geej</title>
    <!-- v1.2 - Switched to Claude Haiku for speed -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            --treeplex-primary: #6366f1;
            --treeplex-primary-dark: #4f46e5;
            --phase-0: #5FA463;
            --phase-0-light: #6FB56E;
            --phase-0-dark: #4A8C4E;
            --phase-1: #3B8FCC;
            --phase-1-light: #4A9DD9;
            --phase-1-dark: #2B7AB8;
            --phase-2: #D68A2E;
            --phase-2-light: #E09940;
            --phase-2-dark: #B8741F;
            --text-primary: #E8EAF0;
            --text-secondary: #9DA3B4;
            --border: #3A3F4D;
            --bg: #1E2128;
            --card-bg: #2A2F3C;
            --card-bg-light: #32374A;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.5);
            --shadow-xl: 0 12px 40px rgba(0,0,0,0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            overflow: auto;
        }

        ::selection {
            background: var(--treeplex-primary);
            color: white;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            background: #252931;
            border-bottom: 1px solid var(--border);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .logo {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .logo-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 24px;
            font-weight: 700;
            color: var(--treeplex-primary);
            letter-spacing: -0.5px;
        }

        .logo-subtitle {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-left: 46px;
        }

        /*         .confidential {
        /*             padding: 4px 12px;
        /*             background: #fff5f5;
        /*             border: 1px solid #ffccc7;
        /*             border-radius: 6px;
        /*             font-size: 11px;
        /*             font-weight: 600;
        /*             color: #d32f2f;
        /*             letter-spacing: 0.5px;
        /*         } */

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .control-section {
            display: flex;
            gap: 6px;
            padding: 0 12px;
            border-right: 1px solid var(--border);
        }

        .control-section:last-child {
            border-right: none;
            padding-right: 0;
        }

        .control-section:first-child {
            padding-left: 0;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: var(--card-bg);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn:hover {
            background: var(--card-bg-light);
            border-color: var(--treeplex-primary);
        }

        .btn-primary {
            background: var(--treeplex-primary);
            color: white;
            border-color: var(--treeplex-primary);
        }

        .btn-primary:hover {
            background: var(--treeplex-primary-dark);
        }
/* Pattern Selector */        .pattern-selector {            position: relative;            display: inline-block;        }        .pattern-select {            padding: 8px 12px;            border: 1px solid var(--border);            background: var(--card-bg);            color: var(--text-primary);            border-radius: 6px;            font-size: 13px;            font-weight: 500;            cursor: pointer;            font-family: inherit;            min-width: 180px;        }        .pattern-select:hover {            background-color: var(--card-bg-light);            border-color: var(--treeplex-primary);        }        .pattern-select:focus {            outline: none;            border-color: var(--treeplex-primary);            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);        }

        /* Pan/Zoom Controls */
        .zoom-controls {
            position: fixed;
            top: 90px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: var(--card-bg);
            padding: 12px;
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border);
        }

        .zoom-btn {
            width: 44px;
            height: 44px;
            border: 1px solid var(--border);
            background: var(--card-bg-light);
            color: var(--text-primary);
            border-radius: 8px;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: inherit;
        }

        .zoom-btn:hover {
            background: var(--treeplex-primary);
            border-color: var(--treeplex-primary);
            color: white;
            transform: scale(1.05);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-level {
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            padding: 8px 0;
            border-top: 1px solid var(--border);
            margin-top: 4px;
        }

        /* Tree Container */
        .tree-container {
            padding: 0;
            overflow: hidden;
            min-height: calc(100vh - 70px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background:
                repeating-linear-gradient(45deg, transparent, transparent 40px, rgba(0, 166, 125, 0.03) 40px, rgba(0, 166, 125, 0.03) 80px),
                repeating-linear-gradient(-45deg, transparent, transparent 40px, rgba(59, 143, 204, 0.02) 40px, rgba(59, 143, 204, 0.02) 80px),
                linear-gradient(180deg, #1A1D24 0%, #1E2128 50%, #1A1D24 100%);
            cursor: grab;
        }

        .tree-container.panning {
            cursor: grabbing;
        }

        .tree-transform-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center center;
            transition: transform 0.2s ease-out;
            min-width: 100%;
            min-height: 100%;
        }

        .tree-container::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 166, 125, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(59, 143, 204, 0.06) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(214, 138, 46, 0.04) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }

        .dependency-svg {
            position: absolute;
            top: -5000px;
            left: -5000px;
            width: 20000px;
            height: 20000px;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .dependency-line {
            fill: none;
            stroke: var(--treeplex-primary);
            stroke-width: 3;
            stroke-dasharray: 8, 4;
            opacity: 0.6;
            transition: all 0.3s;
            animation: dash-flow 20s linear infinite;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
        }

        .dependency-line:hover {
            opacity: 1;
            stroke-width: 4;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25));
        }

        .dependency-line.phase-0 {
            stroke: var(--phase-0-dark);
        }

        .dependency-line.phase-1 {
            stroke: var(--phase-1-dark);
        }

        .dependency-line.phase-2 {
            stroke: var(--phase-2-dark);
        }

        .dependency-line.cross-phase {
            stroke: var(--treeplex-primary-dark);
            opacity: 0.7;
            stroke-width: 3.5;
        }

        @keyframes dash-flow {
            to {
                stroke-dashoffset: -100;
            }
        }

        .tree {
            display: flex;
            flex-direction: row;
            gap: 40px;
            align-items: center;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }

        .tree-level {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 12px;
            padding: 20px;
            border-radius: 12px;
            transition: background 0.3s;
        }

        /* Phase-specific backgrounds - subtle gradients */
        .tree-level:has(.phase-0) {
            background: linear-gradient(180deg, rgba(95, 164, 99, 0.03) 0%, rgba(95, 164, 99, 0.08) 100%);
        }

        .tree-level:has(.phase-1) {
            background: linear-gradient(180deg, rgba(59, 143, 204, 0.03) 0%, rgba(59, 143, 204, 0.08) 100%);
        }

        .tree-level:has(.phase-2) {
            background: linear-gradient(180deg, rgba(214, 138, 46, 0.03) 0%, rgba(214, 138, 46, 0.08) 100%);
        }

        .tree-node {
            background: linear-gradient(145deg, var(--card-bg-light), var(--card-bg));
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: var(--shadow-md), 0 0 0 1px rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            min-width: 280px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .tree-node:hover {
            box-shadow: var(--shadow-lg), 0 0 0 1px rgba(255,255,255,0.1);
            transform: translateX(4px) translateY(-2px);
            border-color: var(--treeplex-primary);
            background: linear-gradient(145deg, #3A3F52, var(--card-bg-light));
        }

        .tree-node::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 16px;
            background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
            pointer-events: none;
        }

        .tree-node.root {
            background: linear-gradient(135deg, #4A5568 0%, #2D3748 100%);
            color: white;
            font-size: 20px;
            font-weight: 600;
            min-width: 240px;
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(255, 255, 255, 0.15);
        }

        .tree-node.root:hover {
            box-shadow: var(--shadow-xl);
            background: linear-gradient(135deg, #556577 0%, #3A4556 100%);
        }

        .tree-node.root .node-subtitle {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.85;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 2px;
        }

        .tree-node.phase {
            border-left: 6px solid;
            min-width: 260px;
            position: relative;
            overflow: hidden;
        }

        .tree-node.phase::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: linear-gradient(180deg, var(--phase-color-light), var(--phase-color-dark));
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
        }

        .tree-node.phase-0 {
            border-left-color: var(--phase-0);
            --phase-color-light: var(--phase-0-light);
            --phase-color-dark: var(--phase-0-dark);
        }

        .tree-node.phase-0:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-0);
        }

        .tree-node.phase-1 {
            border-left-color: var(--phase-1);
            --phase-color-light: var(--phase-1-light);
            --phase-color-dark: var(--phase-1-dark);
        }

        .tree-node.phase-1:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-1);
        }

        .tree-node.phase-2 {
            border-left-color: var(--phase-2);
            --phase-color-light: var(--phase-2-light);
            --phase-color-dark: var(--phase-2-dark);
        }

        .tree-node.phase-2:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-2);
        }

        .tree-node.item {
            min-width: 320px;
            max-width: 360px;
            backdrop-filter: blur(4px);
        }

        /* Subtask container - appears below parent item with animation */
        .subtask-container {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            margin-bottom: 8px;
            padding-left: 10px;
            justify-content: flex-start;
            flex-wrap: wrap;
            max-width: 100%;
            animation: slideDownFade 0.4s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            transform-origin: top center;
        }

        @keyframes slideDownFade {
            0% {
                opacity: 0;
                transform: translateY(-40px) scale(0.95);
                max-height: 0;
                filter: blur(6px) brightness(0.5);
            }
            60% {
                filter: blur(1px) brightness(0.9);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                max-height: 500px;
                filter: blur(0) brightness(1);
            }
        }

        /* Subtask styling - compact visual cards */
        .tree-node.item.subtask {
            min-width: 100px;
            max-width: 100px;
            width: 100px;
            min-height: 85px;
            background: rgba(255, 255, 255, 0.06);
            border-left: 3px solid rgba(0, 166, 125, 0.5);
            border-radius: 6px;
            padding: 10px;
            font-size: 10px;
            margin: 0;
            display: inline-flex;
            flex-direction: column;
            vertical-align: top;
            animation: subtaskReveal 0.35s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            opacity: 0;
            transform: translateY(-20px) scale(0.9);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tree-node.item.subtask:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 166, 125, 0.3);
            border-left-color: rgba(0, 166, 125, 0.8);
        }

        /* Staggered animation for subtasks */
        .tree-node.item.subtask:nth-child(1) { animation-delay: 0.05s; }
        .tree-node.item.subtask:nth-child(2) { animation-delay: 0.1s; }
        .tree-node.item.subtask:nth-child(3) { animation-delay: 0.15s; }
        .tree-node.item.subtask:nth-child(4) { animation-delay: 0.2s; }
        .tree-node.item.subtask:nth-child(5) { animation-delay: 0.25s; }
        .tree-node.item.subtask:nth-child(6) { animation-delay: 0.3s; }

        @keyframes subtaskReveal {
            0% {
                opacity: 0;
                transform: translateY(-20px) scale(0.9);
                filter: blur(4px) brightness(0.6);
            }
            70% {
                transform: translateY(2px) scale(1.01);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                filter: blur(0) brightness(1);
            }
        }


        /* Project management fields styling */
        .pm-field {
            font-size: 8px;
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            line-height: 1.1;
        }

        .pm-field-label {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .pm-field-value {
            font-weight: 600;
        }

        .pm-status {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
        }

        .pm-status.todo { background: rgba(156, 163, 175, 0.3); color: #9CA3AF; }
        .pm-status.inprogress { background: rgba(59, 130, 246, 0.3); color: #3B82F6; }
        .pm-status.completed { background: rgba(16, 185, 129, 0.3); color: #10B981; }
        .pm-status.blocked { background: rgba(239, 68, 68, 0.3); color: #EF4444; }

        .pm-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 2px;
        }

        .pm-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            transition: width 0.3s;
        }

        /* Expand/Collapse toggle for items with subtasks */
        .expand-toggle {
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
            display: inline-block;
        }

        .expand-toggle:hover {
            opacity: 1 !important;
            transform: scale(1.3) rotate(90deg);
        }

        /* Items with subtasks have a pointer cursor */
        .tree-node.item:has(.expand-toggle) {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tree-node.item:has(.expand-toggle):hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 166, 125, 0.2);
        }

        .tree-node.item:has(.expand-toggle):active {
            transform: translateY(0);
            transition: all 0.1s ease;
        }

        /* When item has expanded subtasks, add subtle glow and lift effect */
        .tree-node.item.has-expanded-subtasks {
            box-shadow: 0 0 20px rgba(0, 166, 125, 0.4), 0 6px 16px rgba(0, 0, 0, 0.3);
            border-left-color: rgba(0, 166, 125, 0.9);
            border-left-width: 4px;
            transform: translateY(-2px);
            z-index: 10;
            transition: all 0.3s ease;
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .node-icon {
            font-size: 28px;
            flex-shrink: 0;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
            transition: transform 0.3s;
        }

        .tree-node:hover .node-icon {
            transform: scale(1.1);
        }

        .node-content {
            flex: 1;
        }

        .node-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .node-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .node-cost {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-top: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .tree-node.root .node-cost {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.8));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .expand-toggle {
            font-size: 14px;
            opacity: 0.6;
            transition: transform 0.3s;
            margin-left: auto;
        }

        .tree-node.expanded .expand-toggle {
            transform: rotate(90deg);
        }

        .tree-node.collapsed .expand-toggle {
            transform: rotate(0deg);
        }

        /* Item specific */
        .item-name {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .item-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            border: 1px solid;
        }

        .badge-land {
            background: linear-gradient(135deg, rgba(95, 164, 99, 0.3), rgba(74, 140, 78, 0.2));
            color: #81C784;
            border-color: #4A8C4E;
        }
        .badge-engineering {
            background: linear-gradient(135deg, rgba(59, 143, 204, 0.3), rgba(43, 122, 184, 0.2));
            color: #64B5F6;
            border-color: #2B7AB8;
        }
        .badge-professional {
            background: linear-gradient(135deg, rgba(156, 117, 178, 0.3), rgba(128, 90, 150, 0.2));
            color: #BA68C8;
            border-color: #7B4A92;
        }
        .badge-corporate {
            background: linear-gradient(135deg, rgba(130, 130, 130, 0.3), rgba(100, 100, 100, 0.2));
            color: #B0B0B0;
            border-color: #707070;
        }
        .badge-equipment {
            background: linear-gradient(135deg, rgba(214, 138, 46, 0.3), rgba(184, 116, 31, 0.2));
            color: #FFB74D;
            border-color: #B8741F;
        }
        .badge-infrastructure {
            background: linear-gradient(135deg, rgba(233, 98, 158, 0.3), rgba(200, 70, 130, 0.2));
            color: #F48FB1;
            border-color: #C84682;
        }
        .badge-contingency {
            background: linear-gradient(135deg, rgba(229, 115, 115, 0.3), rgba(198, 80, 80, 0.2));
            color: #EF9A9A;
            border-color: #C65050;
        }

        .item-cost {
            font-size: 15px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Connection Lines */
        .tree-node::before {
            content: '';
            position: absolute;
            left: -40px;
            top: 50%;
            width: 40px;
            height: 2px;
            background: var(--border);
        }

        .tree-level:first-child .tree-node::before {
            display: none;
        }

        /* Same-phase dependency indentation indicator */
        .tree-node.item.has-same-phase-dependency::after {
            content: '';
            position: absolute;
            left: -20px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, transparent, var(--treeplex-primary) 20%, var(--treeplex-primary) 80%, transparent);
            opacity: 0.3;
            border-radius: 2px;
        }

        /* Enhanced visual for deeper dependency levels */
        .tree-node.item.has-same-phase-dependency[data-dependency-level="2"]::after {
            opacity: 0.4;
            width: 3px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="3"]::after {
            opacity: 0.5;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="4"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="5"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="6"]::after {
            opacity: 0.6;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency {
            border-left: 2px solid rgba(0, 166, 125, 0.2);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            right: -450px;
            top: 0;
            width: 450px;
            height: 100vh;
            background: var(--card-bg);
            border-left: 1px solid var(--border);
            box-shadow: -4px 0 12px rgba(0,0,0,0.5);
            transition: right 0.3s;
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        .info-panel.open {
            right: 0;
        }

        .info-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-title {
            font-size: 18px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: var(--bg);
        }

        .info-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .info-section {
            margin-bottom: 24px;
        }

        .info-section h4 {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .info-section p {
            font-size: 14px;
            line-height: 1.6;
        }

        .info-section .value {
            font-size: 20px;
            font-weight: 700;
            color: var(--treeplex-primary);
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            font-size: 18px;
            font-weight: 600;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            line-height: 1.7;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
        }

        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--treeplex-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 40px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            display: none;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            padding: 6px;
            min-width: 180px;
            z-index: 1000;
        }

        .context-item {
            padding: 10px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            color: var(--text-primary);
        }

        .context-item:hover {
            background: var(--card-bg-light);
            color: var(--treeplex-primary);
        }

        .context-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
            background: var(--bg);
            color: var(--text-primary);
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--treeplex-primary);
            box-shadow: 0 0 0 3px rgba(0, 166, 125, 0.2);
            background: var(--card-bg-light);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Splash Screen */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1d24 0%, #2a2f3c 50%, #1a1d24 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.5s ease-in;
        }

        #splash-screen.fade-out {
            animation: fadeOut 0.5s ease-out forwards;
        }

        .splash-logo {
            font-size: 72px;
            margin-bottom: 24px;
            animation: logoFloat 2s ease-in-out infinite;
        }

        .splash-title {
            font-size: 48px;
            font-weight: 700;
            color: var(--treeplex-primary);
            margin-bottom: 8px;
            letter-spacing: -1px;
        }

        .splash-subtitle {
            font-size: 20px;
            color: var(--text-secondary);
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 48px;
        }

        .splash-tagline {
            font-size: 16px;
            color: var(--text-primary);
            font-weight: 400;
            margin-bottom: 32px;
            opacity: 0.8;
        }

        .splash-loader {
            width: 200px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .splash-loader-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--phase-1));
            border-radius: 3px;
            animation: loadProgress 2s ease-in-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        @keyframes logoFloat {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes loadProgress {
            0% {
                width: 0%;
            }
            100% {
                width: 100%;
            }
        }
    </style>
    <!-- SheetJS library for Excel export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <!-- LZ-String library for URL compression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
</head>
<body>
    <!-- TreeListy by geej Splash Screen -->
    <div id="splash-screen">
        <div class="splash-logo">üå≥</div>
        <div class="splash-title">TreeListy</div>
        <div class="splash-subtitle">by geej</div>
        <div class="splash-tagline">From Complexity to Clarity</div>
        <div class="splash-loader">
            <div class="splash-loader-bar"></div>
        </div>
    </div>

    <!-- Header -->
    <div class="header">
        <div style="display: flex; align-items: center; gap: 20px;">
            <div class="logo">
                <div class="logo-title">
                    <span>üå≥</span>
                    <span>TreeListy</span>
                </div>
                <div class="logo-subtitle">by geej</div>
            </div>
            
        </div>
        <div class="controls">
            <div class="control-section">
                <button class="btn" id="save-json-btn" title="Save project as JSON">üíæ Save</button>
                <button class="btn" id="load-json-btn" title="Load project from JSON">üìÇ Load</button>
                <button class="btn" id="share-btn" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);" title="Generate shareable URL">üì§ Share</button>
            </div>

            <div class="control-section">
                <button class="btn" id="excel-export-btn" style="background: linear-gradient(135deg, #1D6F42, #00A67D);" title="Export to Excel">üìä Excel</button>
            </div>

            <div class="control-section">
                <button class="btn" id="expand-btn" title="Expand all phases">‚¨áÔ∏è Expand</button>
                <button class="btn" id="collapse-btn" title="Collapse all phases">‚¨ÜÔ∏è Collapse</button>
            </div>
<div class="control-section pattern-selector">                <select class="pattern-select" id="pattern-select" title="Choose naming pattern">                    <option value="generic" data-desc="Universal: Project ‚Üí Phase ‚Üí Item ‚Üí Task">üìã Generic Project</option>                    <option value="sales" data-desc="Sales: Pipeline ‚Üí Quarter ‚Üí Deal ‚Üí Action">üíº Sales Pipeline</option>                    <option value="thesis" data-desc="Academic: Thesis ‚Üí Chapter ‚Üí Section ‚Üí Point">üéì Academic Writing</option>                    <option value="roadmap" data-desc="Product: Product ‚Üí Quarter ‚Üí Feature ‚Üí Story">üöÄ Product Roadmap</option>                    <option value="book" data-desc="Writing: Book ‚Üí Part ‚Üí Chapter ‚Üí Scene">üìö Book Writing</option>                    <option value="event" data-desc="Events: Event ‚Üí Stage ‚Üí Activity ‚Üí Task">üéâ Event Planning</option>                    <option value="fitness" data-desc="Fitness: Program ‚Üí Phase ‚Üí Workout ‚Üí Exercise">üí™ Fitness Program</option>                    <option value="strategy" data-desc="Business: Strategy ‚Üí Pillar ‚Üí Initiative ‚Üí Action">üìä Strategic Plan</option>                    <option value="course" data-desc="Education: Course ‚Üí Unit ‚Üí Lesson ‚Üí Exercise">üìñ Course Design</option>                    <option value="film" data-desc="Production: Film ‚Üí Phase ‚Üí Scene ‚Üí Shot">üé¨ Film Production</option>                    <option value="philosophy" data-desc="Philosophy: Treatise ‚Üí Book ‚Üí Argument ‚Üí Premise">ü§î Philosophy</option>                    <option value="prompting" data-desc="AI Prompting: Workbook ‚Üí Stage ‚Üí Module ‚Üí Step">üß† AI Prompt Design</option>                    <option value="familytree" data-desc="Genealogy: Family ‚Üí Generation ‚Üí Person ‚Üí Event">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Family Tree</option>                    <option value="custom" data-desc="Custom: Define your own level names">‚úèÔ∏è Custom Names</option>                </select>            </div>

            <div class="control-section">
                <button class="btn" id="analyze-text-btn" title="Analyze text to detect pattern and create tree structure" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; font-weight: 600;">üîç Analyze Text</button>
                <button class="btn" id="wizard-btn" title="AI Wizard will guide you through building your tree" style="background: linear-gradient(135deg, #a855f7, #ec4899); color: white; font-weight: 600;">ü™Ñ AI Wizard</button>
                <button class="btn" id="generate-prompt-btn" title="Generate a complete prompt from your tree structure" style="background: linear-gradient(135deg, #10b981, #059669); color: white; font-weight: 600;">üìù Generate Prompt</button>
            </div>

            <div class="control-section">
                <button class="btn btn-primary" id="ai-btn" title="AI-powered analysis">ü§ñ AI</button>
            </div>

            <div class="control-section">
                <button class="btn" id="api-key-btn" title="Configure your Anthropic API key (optional)">üîë API Key</button>
            </div>

            <div class="control-section">
                <button class="btn" id="how-to-btn" title="How to use TreeListy">üìñ Help</button>
            </div>
        </div>
    </div>

    <!-- Pan/Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" id="zoom-in" title="Zoom In">
            <span>+</span>
        </button>
        <button class="zoom-btn" id="zoom-out" title="Zoom Out">
            <span>‚àí</span>
        </button>
        <button class="zoom-btn" id="zoom-reset" title="Reset View">
            <span>‚ü≤</span>
        </button>
        <div class="zoom-level" id="zoom-level">100%</div>
    </div>

    <!-- Tree -->
    <div class="tree-container" id="tree-container">
        <div class="tree-transform-wrapper" id="tree-transform-wrapper">
            <svg class="dependency-svg" id="dependency-svg"></svg>
            <div class="tree" id="tree-root"></div>
        </div>
    </div>

    <!-- Info Panel -->
    <div class="info-panel" id="info-panel">
        <div class="info-header">
            <div class="info-title" id="info-title">Details</div>
            <button class="close-btn" id="close-info">‚úï</button>
        </div>
        <div class="info-body" id="info-body"></div>
    </div>

    <!-- Context Menu (populated dynamically) -->
    <div class="context-menu" id="context-menu"></div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <div class="modal-header" id="modal-title">AI Analysis</div>
            <div class="modal-body" id="modal-body">
                <div class="spinner"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="modal-close">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="edit-modal">
        <div class="modal-content">
            <div class="modal-header">Edit Item</div>
            <div class="modal-body" id="edit-modal-body"></div>
            <div class="modal-footer">
                <button class="btn" id="edit-cancel">Cancel</button>
                <button class="btn btn-primary" id="edit-save">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Analysis Mode Modal -->
    <div class="modal" id="analysis-modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">üîç Analysis Mode - Convert Text to Tree Structure</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Upload a text file or paste content below. AI will analyze it, detect the best pattern, and convert it into a hierarchical tree structure.
                    </p>
                </div>

                <!-- File Upload Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        üìÅ Upload File (.txt, .md)
                    </label>
                    <div id="file-drop-zone" style="border: 2px dashed var(--border); border-radius: 8px; padding: 32px; text-align: center; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s;">
                        <div style="font-size: 48px; margin-bottom: 12px;">üìÑ</div>
                        <div style="color: var(--text-primary); font-weight: 500; margin-bottom: 4px;">
                            Drop file here or click to browse
                        </div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            Supports .txt and .md files (max 100KB recommended)
                        </div>
                        <input type="file" id="analysis-file-input" accept=".txt,.md" style="display: none;" />
                    </div>
                    <div id="file-name-display" style="margin-top: 8px; color: var(--text-secondary); font-size: 13px; display: none;">
                        Selected: <span id="selected-file-name" style="color: var(--treeplex-primary); font-weight: 500;"></span>
                        <button id="clear-file-btn" style="margin-left: 8px; color: var(--text-secondary); background: none; border: none; cursor: pointer; font-size: 13px;">[Clear]</button>
                    </div>
                </div>

                <div style="text-align: center; margin: 16px 0; color: var(--text-secondary); font-size: 13px; font-weight: 600;">
                    ‚Äî OR ‚Äî
                </div>

                <!-- Paste Text Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        üìù Paste Text
                    </label>
                    <textarea id="analysis-text-input" placeholder="Paste your text content here...

Example:
- Meeting notes
- Project outline
- Research paper
- Strategic plan
- Event agenda
- Course syllabus

The AI will analyze the structure and convert it to a tree."
                        style="width: 100%; min-height: 200px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: 'Inter', monospace; font-size: 13px; resize: vertical;"></textarea>
                    <div id="char-count" style="margin-top: 6px; text-align: right; color: var(--text-secondary); font-size: 12px;">
                        0 characters
                    </div>
                </div>

                <!-- Analysis Mode Selection -->
                <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                    <label style="display: block; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">
                        ‚ö° Analysis Depth
                    </label>
                    <div style="display: flex; gap: 12px;">
                        <label style="flex: 1; display: flex; align-items: flex-start; cursor: pointer; padding: 12px; border: 2px solid var(--border); border-radius: 6px; background: var(--card-bg); transition: all 0.2s;">
                            <input type="radio" name="analysis-mode" value="quick" checked style="margin-top: 3px; margin-right: 10px;" />
                            <div>
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">‚ö° Quick Mode</div>
                                <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                                    Fast pattern detection + basic structure. Recommended for most uses. (~2 API calls, ~$0.01)
                                </div>
                            </div>
                        </label>
                        <label style="flex: 1; display: flex; align-items: flex-start; cursor: pointer; padding: 12px; border: 2px solid var(--border); border-radius: 6px; background: var(--card-bg); transition: all 0.2s;">
                            <input type="radio" name="analysis-mode" value="deep" style="margin-top: 3px; margin-right: 10px;" />
                            <div>
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">üî¨ Deep Mode</div>
                                <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                                    Detailed parsing + field extraction + dependencies. More accurate. (~4-6 API calls, ~$0.03-0.05)
                                </div>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- Warning Display -->
                <div id="analysis-warning" style="display: none; padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px; margin-bottom: 16px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">‚ö†Ô∏è Large File Warning</div>
                    <div id="analysis-warning-text" style="color: var(--text-secondary); font-size: 13px;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="analysis-cancel">Cancel</button>
                <button class="btn btn-primary" id="analysis-start-btn" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">üîç Analyze</button>
            </div>
        </div>
    </div>

    <!-- API Key Configuration Modal -->
    <div class="modal" id="api-key-modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">üîë API Key Configuration</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Analysis Mode requires an Anthropic API key to function. Enter your key below to enable AI-powered text analysis.
                    </p>
                    <div style="padding: 12px 16px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; margin-bottom: 16px;">
                        <div style="color: var(--treeplex-primary); font-weight: 600; margin-bottom: 4px;">üí° How to get an API key:</div>
                        <ol style="color: var(--text-secondary); font-size: 13px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://console.anthropic.com/" target="_blank" style="color: var(--treeplex-primary);">console.anthropic.com</a></li>
                            <li>Sign up or log in to your account</li>
                            <li>Go to API Keys section</li>
                            <li>Create a new API key</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </div>
                </div>

                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                    Anthropic API Key
                </label>
                <input type="password" id="api-key-input" placeholder="sk-ant-..."
                    style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px; margin-bottom: 12px;" />

                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                    <input type="checkbox" id="api-key-show" style="cursor: pointer;" />
                    <label for="api-key-show" style="font-size: 13px; color: var(--text-secondary); cursor: pointer;">Show API key</label>
                </div>

                <div style="padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">üîí Security Note</div>
                    <div style="color: var(--text-secondary); font-size: 13px; line-height: 1.5;">
                        Your API key is stored locally in your browser's session storage and is never sent to any server except Anthropic's API. It will be cleared when you close the browser.
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="api-key-cancel">Cancel</button>
                <button class="btn btn-primary" id="api-key-save" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Save & Continue</button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div class="modal" id="share-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">üì§ Share Your Project</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 15px;">
                        Share this link with anyone! The link contains your entire project data (no server storage).
                    </p>
                    <div style="background: var(--card-bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 15px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="share-url-input" readonly
                                   style="flex: 1; background: var(--card-bg); border: 1px solid var(--border); color: var(--text-primary); padding: 10px; border-radius: 6px; font-family: monospace; font-size: 12px; user-select: all;"
                                   value="">
                            <button class="btn btn-primary" id="copy-share-url" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); white-space: nowrap;">
                                üìã Copy
                            </button>
                        </div>
                    </div>
                    <div id="share-stats" style="display: flex; gap: 20px; font-size: 13px; color: var(--text-secondary);">
                        <div>üìä <span id="share-node-count">0</span> nodes</div>
                        <div>üìè <span id="share-url-length">0</span> characters</div>
                        <div id="share-size-warning" style="display: none; color: #f59e0b;">‚ö†Ô∏è Large project - URL may not work in all apps</div>
                    </div>
                </div>
                <div style="background: var(--card-bg); padding: 15px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                    <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span>‚ÑπÔ∏è</span> How it works
                    </div>
                    <ul style="margin-left: 20px; color: var(--text-secondary); font-size: 14px; line-height: 1.6;">
                        <li>Your data is compressed and embedded in the URL (not stored on any server)</li>
                        <li>Anyone with the link can view and edit their own copy</li>
                        <li>Works best for projects with up to 40-50 nodes</li>
                        <li>For larger projects, use "üíæ Save" to download JSON instead</li>
                    </ul>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="share-close">Close</button>
                <button class="btn btn-primary" id="open-share-url" style="background: linear-gradient(135deg, #3B8FCC, #2B7AB8);">
                    üîó Open in New Tab
                </button>
            </div>
        </div>
    </div>

    <!-- Wizard Modal -->
    <div class="modal" id="wizard-modal" style="display: none;">
        <div class="modal-content" style="max-width: 1200px; max-height: 85vh;">
            <div class="modal-header">
                <span id="wizard-title">ü™Ñ AI Wizard - Building Your Project</span>
            </div>

            <div style="padding: 15px; background: var(--card-bg-light); border-bottom: 1px solid var(--border);">
                <div style="display: flex; gap: 30px; font-size: 14px; margin-bottom: 10px;">
                    <div>üìä Turn: <span id="wizard-question-count" style="color: var(--treeplex-primary); font-weight: 600;">0</span></div>
                    <div>‚úì Fields: <span id="wizard-fields-complete" style="color: var(--treeplex-primary); font-weight: 600;">0</span>/<span id="wizard-fields-total">10</span> complete</div>
                    <div>üìà <span id="wizard-progress-percent" style="color: var(--treeplex-primary); font-weight: 600;">0%</span> complete</div>
                    <div id="wizard-completion" style="display: none; color: #10b981; font-weight: 600;">‚úÖ Ready to Apply!</div>
                </div>
                <!-- Progress Bar -->
                <div style="width: 100%; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden;">
                    <div id="wizard-progress-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--treeplex-primary), #10b981); transition: width 0.5s ease;"></div>
                </div>
            </div>

            <div class="modal-body" style="display: flex; gap: 20px; padding: 20px; height: calc(85vh - 200px); overflow: hidden;">
                <!-- Chat Area -->
                <div style="flex: 1; display: flex; flex-direction: column; border: 1px solid var(--border); border-radius: 8px; background: var(--card-bg);">
                    <div style="padding: 15px; border-bottom: 1px solid var(--border); font-weight: 600; color: var(--treeplex-primary);">
                        üí¨ Conversation
                    </div>
                    <div id="wizard-chat-history" style="flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px;">
                        <!-- Chat messages will appear here -->
                    </div>
                    <div style="padding: 15px; border-top: 1px solid var(--border); display: flex; gap: 10px;">
                        <input type="text" id="wizard-user-input" placeholder="Type your answer here..."
                               style="flex: 1; background: var(--bg); border: 1px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 6px; font-size: 14px;"
                               onkeypress="if(event.key==='Enter') document.getElementById('wizard-send').click()">
                        <button class="btn btn-primary" id="wizard-send" style="background: linear-gradient(135deg, #a855f7, #ec4899); padding: 12px 24px;">
                            Send
                        </button>
                    </div>
                </div>

                <!-- Live Tree Preview -->
                <div style="flex: 1; display: flex; flex-direction: column; border: 1px solid var(--border); border-radius: 8px; background: var(--card-bg);">
                    <div style="padding: 15px; border-bottom: 1px solid var(--border); font-weight: 600; color: var(--treeplex-primary);">
                        üå≥ Live Preview
                    </div>
                    <div id="wizard-tree-preview" style="flex: 1; overflow-y: auto; padding: 20px; font-size: 13px; line-height: 1.8;">
                        <div style="color: var(--text-secondary); text-align: center; margin-top: 40px;">
                            Your tree structure will appear here as we build it together...
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="wizard-cancel">Cancel</button>
                <button class="btn btn-primary" id="wizard-done" style="background: linear-gradient(135deg, #10b981, #059669);">
                    ‚úÖ Finish & Apply
                </button>
            </div>
        </div>
    </div>

    <!-- Generate Prompt Modal -->
    <div class="modal" id="generate-prompt-modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh;">
            <div class="modal-header">
                <span id="generate-prompt-title">üìù Generated Prompt</span>
            </div>

            <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(85vh - 140px);">
                <div style="margin-bottom: 15px; color: var(--text-secondary); font-size: 13px;">
                    This prompt was generated from your tree structure. Copy and paste it to use with AI systems.
                </div>

                <div style="position: relative;">
                    <textarea id="generated-prompt-text" readonly style="
                        width: 100%;
                        min-height: 400px;
                        padding: 15px;
                        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                        font-size: 13px;
                        line-height: 1.6;
                        border: 1px solid var(--border);
                        border-radius: 8px;
                        background: var(--card-bg);
                        color: var(--text-primary);
                        resize: vertical;
                    "></textarea>

                    <button id="copy-prompt-btn" style="
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        padding: 8px 16px;
                        background: var(--treeplex-primary);
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 600;
                    ">üìã Copy</button>
                </div>

                <div id="copy-success-message" style="
                    margin-top: 10px;
                    padding: 10px;
                    background: #10b981;
                    color: white;
                    border-radius: 6px;
                    text-align: center;
                    display: none;
                ">‚úÖ Copied to clipboard!</div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-prompt-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- Hidden file input for JSON upload -->
    <input type="file" id="json-upload-input" accept=".json" style="display: none;" />

    <script>
        console.log('TreeListy - Universal Project Decomposition - Horizontal Layout with Pan/Zoom');

        // =============================================================================
        // PAN & ZOOM SYSTEM
        // =============================================================================

        // Pan/Zoom state
        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startX = 0;
        let startY = 0;

        const MIN_ZOOM = 0.25;  // 25%
        const MAX_ZOOM = 3.0;   // 300%
        const ZOOM_STEP = 0.15; // 15% per click

        // Apply transform to tree
        function applyTransform() {
            const wrapper = document.getElementById('tree-transform-wrapper');
            if (wrapper) {
                wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
                updateZoomDisplay();
            }
        }

        // Update zoom level display
        function updateZoomDisplay() {
            const display = document.getElementById('zoom-level');
            if (display) {
                display.textContent = Math.round(zoomLevel * 100) + '%';
            }
        }

        // Zoom in
        function zoomIn() {
            if (zoomLevel < MAX_ZOOM) {
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
                applyTransform();
            }
        }

        // Zoom out
        function zoomOut() {
            if (zoomLevel > MIN_ZOOM) {
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
                applyTransform();
            }
        }

        // Reset view
        function resetZoom() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            applyTransform();
        }

        // Mouse wheel zoom
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY;

            if (delta < 0) {
                // Scroll up = zoom in
                zoomIn();
            } else {
                // Scroll down = zoom out
                zoomOut();
            }
        }

        // Mouse down - start panning
        function handleMouseDown(e) {
            // Don't pan if clicking on a node or button
            if (e.target.closest('.tree-node') || e.target.closest('button') || e.target.closest('.zoom-controls')) {
                return;
            }

            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;

            const container = document.getElementById('tree-container');
            container.classList.add('panning');
        }

        // Mouse move - pan
        function handleMouseMove(e) {
            if (!isPanning) return;

            panX = e.clientX - startX;
            panY = e.clientY - startY;
            applyTransform();
        }

        // Mouse up - stop panning
        function handleMouseUp(e) {
            if (isPanning) {
                isPanning = false;
                const container = document.getElementById('tree-container');
                container.classList.remove('panning');
            }
        }

        // Initialize pan/zoom after DOM loads
        function initPanZoom() {
            const container = document.getElementById('tree-container');

            // Zoom controls
            document.getElementById('zoom-in').addEventListener('click', zoomIn);
            document.getElementById('zoom-out').addEventListener('click', zoomOut);
            document.getElementById('zoom-reset').addEventListener('click', resetZoom);

            // Mouse wheel
            container.addEventListener('wheel', handleWheel, { passive: false });

            // Mouse drag
            container.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Prevent context menu on drag
            container.addEventListener('contextmenu', (e) => {
                if (isPanning) e.preventDefault();
            });

            console.log('‚úÖ Pan/Zoom initialized');
        }

        // =============================================================================
        // END PAN & ZOOM SYSTEM
        // =============================================================================

        // =============================================================================
        // REAL AI INTEGRATION - Claude by Anthropic (via Netlify Function)
        // =============================================================================

        // API Configuration - Supports both local API key and Netlify serverless function
        const AI_CONFIG = {
            provider: 'anthropic',
            model: 'claude-3-haiku-20240307', // Haiku: 10x faster, 20x cheaper, perfect for JSON tasks
            // Netlify function endpoint (fallback)
            apiEndpoint: 'https://treelisty.netlify.app/.netlify/functions/claude-proxy',
            // Direct Anthropic API endpoint (when using local API key)
            directEndpoint: 'https://api.anthropic.com/v1/messages'
        };

        // Get local API key from session storage
        function getLocalAPIKey() {
            return sessionStorage.getItem('anthropic_api_key');
        }

        // Set local API key in session storage
        function setLocalAPIKey(key) {
            sessionStorage.setItem('anthropic_api_key', key);
        }

        // Clear local API key
        function clearLocalAPIKey() {
            sessionStorage.removeItem('anthropic_api_key');
        }

        function canUseServerlessAI() {
            return Boolean(AI_CONFIG && typeof AI_CONFIG.apiEndpoint === 'string' && AI_CONFIG.apiEndpoint.length > 0);
        }

        function showApiKeyModal(prefillExisting = false) {
            const apiKeyModal = document.getElementById('api-key-modal');
            const input = document.getElementById('api-key-input');
            const existingKey = getLocalAPIKey();

            input.value = prefillExisting && existingKey ? existingKey : '';
            document.getElementById('api-key-show').checked = false;
            apiKeyModal.style.display = 'flex';
        }

        // Call Claude API - supports both local API key and Netlify function
        async function callClaudeAPI(prompt, systemPrompt = '', maxTokens = 1024, useExtendedThinking = false, retryCount = 0) {
            const MAX_RETRIES = 2;
            const localApiKey = getLocalAPIKey();

            const requestData = {
                model: AI_CONFIG.model,
                max_tokens: maxTokens,
                system: systemPrompt || 'You are an expert project analyst specializing in breaking down complex projects into manageable components.',
                messages: [{
                    role: 'user',
                    content: prompt
                }]
            };

            // Use extended thinking for JSON generation to avoid syntax errors
            if (useExtendedThinking) {
                requestData.thinking = {
                    type: "enabled",
                    budget_tokens: 2000
                };
            }

            let response;

            // Use local API key if available (direct call to Anthropic via CORS proxy)
            if (localApiKey) {
                console.log('üîë Using local API key for Anthropic API call (via CORS proxy for browser compatibility)');

                // Try multiple CORS proxies in case one fails
                const corsProxies = [
                    'https://api.allorigins.win/raw?url=',
                    'https://corsproxy.io/?'
                ];

                let lastError = null;

                // Try each proxy
                for (const corsProxy of corsProxies) {
                    try {
                        console.log(`üîÑ Trying CORS proxy: ${corsProxy.includes('allorigins') ? 'AllOrigins' : 'CorsProxy.io'}`);

                        const apiUrl = encodeURIComponent(AI_CONFIG.directEndpoint);

                        response = await fetch(corsProxy + apiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': localApiKey,
                                'anthropic-version': '2023-06-01'
                            },
                            body: JSON.stringify(requestData)
                        });

                        // If we got a response (even if not ok), break and handle it below
                        if (response) {
                            console.log(`‚úÖ Got response from ${corsProxy.includes('allorigins') ? 'AllOrigins' : 'CorsProxy.io'}`);
                            break;
                        }
                    } catch (proxyError) {
                        console.warn(`‚ö†Ô∏è Proxy failed:`, proxyError);
                        lastError = proxyError;
                        continue; // Try next proxy
                    }
                }

                // If all proxies failed, throw the last error
                if (!response && lastError) {
                    throw new Error(`All CORS proxies failed. Last error: ${lastError.message}`);
                }
            } else {
                // Fallback to Netlify function (API key handled server-side)
                console.log('üåê Using Netlify serverless function');
                response = await fetch(AI_CONFIG.apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
            }

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));

                // Log detailed error info for debugging
                console.error('‚ùå AI API Error Details:', {
                    status: response.status,
                    statusText: response.statusText,
                    usingLocalKey: !!localApiKey,
                    error: error
                });

                // Check for common errors
                if (response.status === 0 || !response.status) {
                    throw new Error('Cannot connect to AI service. Please check your internet connection.');
                }
                if (response.status === 401) {
                    if (localApiKey) {
                        clearLocalAPIKey();
                        throw new Error('Invalid API key. Please check your Anthropic API key and try again.');
                    }
                    throw new Error('Authentication failed. Please configure your API key.');
                }
                if (response.status === 404) {
                    throw new Error('Netlify function not found (404). The serverless function may not be deployed.');
                }
                if (response.status === 429) {
                    // Rate limit - retry with exponential backoff
                    if (retryCount < MAX_RETRIES) {
                        const delay = Math.pow(2, retryCount) * 3000; // 3s, 6s
                        console.log(`üîÑ Rate limit hit. Retrying in ${delay/1000} seconds... (attempt ${retryCount + 1}/${MAX_RETRIES})`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return callClaudeAPI(prompt, systemPrompt, maxTokens, useExtendedThinking, retryCount + 1);
                    }
                    throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                }
                if (response.status === 529) {
                    // API overloaded - retry with exponential backoff
                    if (retryCount < MAX_RETRIES) {
                        const delay = Math.pow(2, retryCount) * 2000; // 2s, 4s
                        console.log(`üîÑ API overloaded. Retrying in ${delay/1000} seconds... (attempt ${retryCount + 1}/${MAX_RETRIES})`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return callClaudeAPI(prompt, systemPrompt, maxTokens, useExtendedThinking, retryCount + 1);
                    }
                    throw new Error('Anthropic API is temporarily overloaded. Please wait 10-30 seconds and try again.');
                }
                if (response.status === 500 && error.error?.message?.includes('configuration')) {
                    throw new Error('AI service is not configured. Please set up your API key.');
                }
                if (response.status === 504) {
                    throw new Error('Request timed out. The text might be too long. Try:\n1. Use a shorter text excerpt (first 10-20 paragraphs)\n2. Use Quick Mode instead of Deep Mode\n3. Try again in a moment');
                }
                throw new Error(error.error?.message || `AI Service Error: ${response.status}`);
            }

            const data = await response.json();
            console.log('‚úÖ AI analysis successful');
            console.log('API Response data:', data);

            // Handle response - check if content exists
            if (!data.content || !Array.isArray(data.content) || data.content.length === 0) {
                console.error('Invalid API response structure:', data);
                throw new Error('Invalid response from AI service');
            }

            return data.content[0].text;
        }

        // Generate intelligent project analysis
        async function generateAIAnalysis(item, analysisType = 'item') {
            // Determine if this is a subtask or regular item/phase
            const isSubtask = item.type === 'subtask';

            let systemPrompt = '';
            let userPrompt = '';

            if (isSubtask) {
                // SUBTASK AI: Help articulate task details, steps for success, and recommendations
                systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;

            } else if (analysisType === 'subtask') {
                // Same as isSubtask - this is a fallback if analysisType is explicitly set to 'subtask'
                systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;

            } else if (analysisType === 'item') {
                // PROJECT ITEM AI: Provide detail, context, and accuracy
                systemPrompt = `You are a senior project analyst specializing in project decomposition and planning.
Your expertise includes:
- Capital expenditure planning and budgeting
- Procurement strategy and vendor evaluation
- Project timeline and dependency analysis
- Risk assessment for major infrastructure investments
- Cost optimization and value engineering

Provide concise, accurate insights with detailed context formatted with clear sections and bullet points.`;

                userPrompt = `Analyze this project line item:

**Item:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
${PATTERNS[currentPattern].fields?.cost ? `**Cost:** $${(item.cost || 0).toLocaleString()}\n` : ''}**Description:** ${item.description || 'N/A'}
${PATTERNS[currentPattern].fields?.leadTime ? `**Lead Time:** ${item.leadTime || 'Not specified'}\n` : ''}${PATTERNS[currentPattern].fields?.alternateSource ? `**Alternate Source:** ${item.alternateSource || 'Not specified'}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Context Notes:** ${item.notes || 'None provided'}

Provide a focused analysis covering:
1. **Risk Assessment** - Key procurement and timeline risks with specific examples
2. **Cost Optimization** - Detailed cost-saving strategies and alternative approaches
3. **Procurement Strategy** - Vendor evaluation criteria and negotiation leverage points
4. **Timeline Considerations** - Critical path impacts, lead time concerns, and scheduling
5. **Industry Context** - Benchmarks, standards, or typical ranges for this expense category
6. **Recommendations** - 2-3 actionable next steps with clear rationale

Prioritize accuracy, detail, and contextual information. Use specific numbers and examples where possible.`;

            } else if (analysisType === 'project') {
                // Project-level analysis
                const allItems = getAllProjectItems();
                const totalCost = calculateTotal(capexTree);
                const itemsByPhase = {
                    'Phase 0': allItems.filter(i => i.id?.startsWith('p0')),
                    'Phase 1': allItems.filter(i => i.id?.startsWith('p1')),
                    'Phase 2': allItems.filter(i => i.id?.startsWith('p2'))
                };

                userPrompt = `Analyze this complete project plan for data center project:

**Total Budget:** $${totalCost.toLocaleString()}

**Phase Breakdown:**
${Object.entries(itemsByPhase).map(([phase, items]) => {
    const phaseTotal = items.reduce((sum, i) => sum + (i.cost || 0), 0);
    return `- ${phase}: ${items.length} items, $${phaseTotal.toLocaleString()}`;
}).join('\n')}

${PATTERNS[currentPattern].fields?.cost ? `**Major Line Items (>$1M):**
${allItems.filter(i => i.cost > 1000000).map(i =>
    `- ${i.name}: $${i.cost.toLocaleString()} (${i.itemType})`
).join('\n') || 'None'}

` : ''}**Key Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} depends on ${i.dependencies.length} item(s)`
).join('\n') || 'No dependencies defined'}

Provide an executive-level analysis covering:
1. **Budget Assessment** - Is the allocation realistic for a data center project?
2. **Critical Path** - Key dependencies and timeline bottlenecks
3. **Risk Factors** - Top 3 risks to budget or timeline
4. **Optimization Opportunities** - Potential cost savings or efficiency gains
5. **Strategic Recommendations** - High-level guidance for investors/stakeholders

Format for presentation to executives. Be concise but comprehensive.`;
            }

            return await callClaudeAPI(userPrompt, systemPrompt);
        }

        // Helper to get all items from tree
        function getAllProjectItems(node = capexTree, items = []) {
            if (node.items) items.push(...node.items);
            if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
            return items;
        }

        // =============================================================================
        // END AI INTEGRATION
        // =============================================================================

        // Data - Phases flow chronologically left to right
        let capexTree = {
            id: 'root',
            name: 'My Project',
            type: 'root',
            icon: 'üå≥',
            expanded: true,
            children: [
                {
                    id: 'phase-0',
                    name: 'Phase 0',
                    subtitle: 'Pre-Seed',
                    type: 'phase',
                    phase: '0',
                    icon: 'üå±',
                    expanded: true,
                    items: [
                        {
                            id: 'p0-1762125598237',
                            name: 'New Item',
                            description: 'Enter description',
                            cost: 0,
                            icon: 'üì¶',
                            itemType: 'equipment',
                            type: 'item',
                            dependencies: [],
                            subItems: [
                                {
                                    id: 'p0-1762125598237-sub-1762453827798',
                                    name: 'Task 1',
                                    description: 'Task description',
                                    cost: 0,
                                    icon: 'üìã',
                                    itemType: 'subtask',
                                    type: 'subtask',
                                    dependencies: [],
                                    parentId: 'p0-1762125598237',
                                    pmStatus: 'To Do',
                                    pmAssignee: 'Unassigned',
                                    pmStartDate: '2025-11-06',
                                    pmDueDate: '2025-11-06',
                                    pmProgress: 0,
                                    pmPriority: 'Medium',
                                    pmNotes: '',
                                    pmBlockingIssue: '',
                                    pmNextSteps: '',
                                    pmUpdates: [],
                                    subItems: []
                                },
                                {
                                    id: 'p0-1762125598237-sub-1762453836667',
                                    name: 'Task 2',
                                    description: 'Task description',
                                    cost: 0,
                                    icon: 'üìã',
                                    itemType: 'subtask',
                                    type: 'subtask',
                                    dependencies: [],
                                    parentId: 'p0-1762125598237',
                                    pmStatus: 'To Do',
                                    pmAssignee: 'Unassigned',
                                    pmStartDate: '2025-11-06',
                                    pmDueDate: '2025-11-06',
                                    pmProgress: 0,
                                    pmPriority: 'Medium',
                                    pmNotes: '',
                                    pmBlockingIssue: '',
                                    pmNextSteps: '',
                                    pmUpdates: [],
                                    subItems: []
                                }
                            ],
                            expanded: true
                        }
                    ],
                    children: [
                        {
                            id: 'phase-1',
                            name: 'Phase 1',
                            subtitle: 'Seed',
                            type: 'phase',
                            phase: '1',
                            icon: 'üöÄ',
                            expanded: true,
                            items: [
                                {
                                    id: 'p1-1762125603889',
                                    name: 'New Item',
                                    description: 'Enter description',
                                    cost: 0,
                                    icon: 'üì¶',
                                    itemType: 'equipment',
                                    type: 'item',
                                    dependencies: ['p0-1762125598237'],
                                    subItems: [
                                        {
                                            id: 'p1-1762125603889-sub-1762453866145',
                                            name: 'Task 1',
                                            description: 'Task description',
                                            cost: 0,
                                            icon: 'üìã',
                                            itemType: 'subtask',
                                            type: 'subtask',
                                            dependencies: [],
                                            parentId: 'p1-1762125603889',
                                            pmStatus: 'To Do',
                                            pmAssignee: 'Unassigned',
                                            pmStartDate: '2025-11-06',
                                            pmDueDate: '2025-11-06',
                                            pmProgress: 0,
                                            pmPriority: 'Medium',
                                            pmNotes: '',
                                            pmBlockingIssue: '',
                                            pmNextSteps: '',
                                            pmUpdates: [],
                                            subItems: []
                                        }
                                    ],
                                    expanded: true,
                                    alternateSource: '',
                                    leadTime: '',
                                    notes: ''
                                }
                            ],
                            children: [
                                {
                                    id: 'phase-2',
                                    name: 'Phase 2',
                                    subtitle: 'Build',
                                    type: 'phase',
                                    phase: '2',
                                    icon: 'üè≠',
                                    expanded: true,
                                    items: [
                                        {
                                            id: 'p2-1762125606965',
                                            name: 'New Item',
                                            description: 'Enter description',
                                            cost: 0,
                                            icon: 'üì¶',
                                            itemType: 'equipment',
                                            type: 'item',
                                            dependencies: [],
                                            subItems: [
                                                {
                                                    id: 'p2-1762125606965-sub-1762453851549',
                                                    name: 'Task 1',
                                                    description: 'Task description',
                                                    cost: 0,
                                                    icon: 'üìã',
                                                    itemType: 'subtask',
                                                    type: 'subtask',
                                                    dependencies: [],
                                                    parentId: 'p2-1762125606965',
                                                    pmStatus: 'To Do',
                                                    pmAssignee: 'Unassigned',
                                                    pmStartDate: '2025-11-06',
                                                    pmDueDate: '2025-11-06',
                                                    pmProgress: 0,
                                                    pmPriority: 'Medium',
                                                    pmNotes: '',
                                                    pmBlockingIssue: '',
                                                    pmNextSteps: '',
                                                    pmUpdates: [],
                                                    subItems: []
                                                }
                                            ],
                                            expanded: true
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        };
// TREEPLEXITY PATTERN SELECTOR
// Insert this code into treelisty.html

// ============================================================================
// PATTERN DEFINITIONS
// ============================================================================

const PATTERNS = {
    generic: {
        name: 'Generic Project',
        icon: 'üìã',
        levels: {
            root: 'Project',
            phase: 'Phase',
            item: 'Item',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Seed', 'Seed', 'Build'],
        types: [
            { value: 'land', label: 'Land' },
            { value: 'engineering', label: 'Engineering' },
            { value: 'equipment', label: 'Equipment' },
            { value: 'infrastructure', label: 'Infrastructure' },
            { value: 'corporate', label: 'Corporate' },
            { value: 'professional', label: 'Professional' },
            { value: 'contingency', label: 'Contingency' }
        ],
        description: 'Universal structure for any project',
        fields: {
            cost: { label: 'Cost ($)', type: 'number', step: 1000, helpText: 'üí∞ Budget allocated for this item' },
            alternateSource: { label: 'Alternate Source', type: 'text', placeholder: 'Backup vendor, supplier, or alternative solution...', helpText: 'üì¶ Alternative supplier or backup option for risk mitigation' },
            leadTime: { label: 'Lead Time', type: 'text', placeholder: 'e.g., 12-18 months, 6 weeks, 90 days...', helpText: '‚è±Ô∏è Expected procurement or delivery timeline' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    sales: {
        name: 'Sales Pipeline',
        icon: 'üíº',
        levels: {
            root: 'Pipeline',
            phase: 'Quarter',
            item: 'Deal',
            subtask: 'Action'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'inbound', label: 'Inbound Lead' },
            { value: 'outbound', label: 'Outbound Prospect' },
            { value: 'partnership', label: 'Partnership' },
            { value: 'expansion', label: 'Account Expansion' },
            { value: 'renewal', label: 'Renewal' },
            { value: 'upsell', label: 'Upsell' },
            { value: 'cross-sell', label: 'Cross-sell' },
            { value: 'enterprise', label: 'Enterprise Deal' }
        ],
        description: 'Track sales opportunities through quarters',
        fields: {
            dealValue: { label: 'Deal Value ($)', type: 'number', step: 1000, helpText: 'üí∞ Potential revenue from this deal' },
            expectedCloseDate: { label: 'Expected Close Date', type: 'date', helpText: 'üìÖ Target date to close this deal' },
            leadSource: { label: 'Lead Source', type: 'text', placeholder: 'Inbound, Referral, Cold Outreach...', helpText: 'üìç How did this lead originate?' },
            contactPerson: { label: 'Contact Person', type: 'text', placeholder: 'Primary contact name...', helpText: 'üë§ Main decision maker or champion' },
            stageProbability: { label: 'Stage Probability (%)', type: 'number', min: 0, max: 100, step: 5, helpText: 'üìä Likelihood of closing this deal' },
            competitorInfo: { label: 'Competitor Info', type: 'textarea', placeholder: 'Who else is competing for this deal...', helpText: 'üéØ Other vendors in consideration' },
            includeDependencies: false,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    thesis: {
        name: 'Academic Writing',
        icon: 'üéì',
        levels: {
            root: 'Thesis',
            phase: 'Chapter',
            item: 'Section',
            subtask: 'Point'
        },
        phaseSubtitles: ['Introduction', 'Body', 'Conclusion'],
        types: [
            { value: 'literature-review', label: 'Literature Review' },
            { value: 'methodology', label: 'Methodology' },
            { value: 'analysis', label: 'Analysis' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'theory', label: 'Theoretical Framework' },
            { value: 'evidence', label: 'Evidence' },
            { value: 'argument', label: 'Argument' },
            { value: 'conclusion', label: 'Conclusion' }
        ],
        description: 'Structure academic papers and dissertations',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'üìù Current word count for this section' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'üéØ Goal word count for this section' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: '‚úèÔ∏è Current revision stage' },
            citations: { label: 'Key Citations', type: 'textarea', placeholder: 'List main sources and references...', helpText: 'üìö Important sources for this section' },
            keyArgument: { label: 'Key Argument', type: 'textarea', placeholder: 'Main point of this section...', helpText: 'üí° Central claim or thesis' },
            evidenceType: { label: 'Evidence Type', type: 'select', options: ['Empirical', 'Theoretical', 'Mixed', 'N/A'], helpText: 'üî¨ Nature of supporting evidence' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    roadmap: {
        name: 'Product Roadmap',
        icon: 'üöÄ',
        levels: {
            root: 'Product',
            phase: 'Quarter',
            item: 'Feature',
            subtask: 'Story'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'core-feature', label: 'Core Feature' },
            { value: 'enhancement', label: 'Enhancement' },
            { value: 'bug-fix', label: 'Bug Fix' },
            { value: 'technical-debt', label: 'Technical Debt' },
            { value: 'research', label: 'Research/Spike' },
            { value: 'platform', label: 'Platform' },
            { value: 'integration', label: 'Integration' },
            { value: 'ux', label: 'UX Improvement' }
        ],
        description: 'Plan product features across quarters',
        fields: {
            storyPoints: { label: 'Story Points', type: 'number', min: 0, step: 1, placeholder: '1, 2, 3, 5, 8, 13...', helpText: 'üéØ Effort estimate (Fibonacci scale)' },
            engineeringEstimate: { label: 'Engineering Estimate', type: 'text', placeholder: '2 weeks, 1 sprint, 3 days...', helpText: '‚è±Ô∏è Time estimate from engineering' },
            userImpact: { label: 'User Impact', type: 'select', options: ['High', 'Medium', 'Low'], helpText: 'üë• How many users does this affect?' },
            technicalRisk: { label: 'Technical Risk', type: 'select', options: ['Low', 'Medium', 'High', 'Unknown'], helpText: '‚ö†Ô∏è Complexity and technical uncertainty' },
            featureFlag: { label: 'Feature Flag', type: 'text', placeholder: 'flag_name...', helpText: 'üö© Feature flag for gradual rollout' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    book: {
        name: 'Book Writing',
        icon: 'üìö',
        levels: {
            root: 'Book',
            phase: 'Part',
            item: 'Chapter',
            subtask: 'Scene'
        },
        phaseSubtitles: ['Act I', 'Act II', 'Act III'],
        types: [
            { value: 'narrative', label: 'Narrative' },
            { value: 'dialogue', label: 'Dialogue' },
            { value: 'description', label: 'Description' },
            { value: 'action', label: 'Action' },
            { value: 'reflection', label: 'Reflection' },
            { value: 'transition', label: 'Transition' },
            { value: 'climax', label: 'Climax' },
            { value: 'exposition', label: 'Exposition' }
        ],
        description: 'Organize books into parts, chapters, and scenes',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'üìù Current word count' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'üéØ Goal word count' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: '‚úèÔ∏è Current revision stage' },
            povCharacter: { label: 'POV Character', type: 'text', placeholder: 'Whose perspective...', helpText: 'üë§ Point-of-view character' },
            sceneSetting: { label: 'Scene Setting', type: 'textarea', placeholder: 'Location, time, mood...', helpText: 'üé≠ Where and when this takes place' },
            plotFunction: { label: 'Plot Function', type: 'select', options: ['Setup', 'Conflict', 'Resolution', 'Transition'], helpText: 'üìñ Role in story structure' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    event: {
        name: 'Event Planning',
        icon: 'üéâ',
        levels: {
            root: 'Event',
            phase: 'Stage',
            item: 'Activity',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Event', 'Event Day', 'Post-Event'],
        types: [
            { value: 'logistics', label: 'Logistics' },
            { value: 'catering', label: 'Catering' },
            { value: 'entertainment', label: 'Entertainment' },
            { value: 'venue', label: 'Venue' },
            { value: 'marketing', label: 'Marketing' },
            { value: 'registration', label: 'Registration' },
            { value: 'follow-up', label: 'Follow-up' },
            { value: 'av-tech', label: 'AV/Tech' }
        ],
        description: 'Plan events from prep to execution to follow-up',
        fields: {
            budget: { label: 'Budget ($)', type: 'number', step: 100, helpText: 'üí∞ Budget for this activity' },
            vendor: { label: 'Vendor/Supplier', type: 'text', placeholder: 'Company or person name...', helpText: 'üè¢ External vendor or supplier' },
            bookingDeadline: { label: 'Booking Deadline', type: 'date', helpText: 'üìÖ Last date to book/reserve' },
            guestCount: { label: 'Guest Count', type: 'number', min: 0, placeholder: 'Expected attendees...', helpText: 'üë• Number of expected guests' },
            location: { label: 'Location', type: 'text', placeholder: 'Venue, room, area...', helpText: 'üìç Where this takes place' },
            responsiblePerson: { label: 'Responsible Person', type: 'text', placeholder: 'Team member name...', helpText: 'üë§ Who\'s handling this' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    fitness: {
        name: 'Fitness Program',
        icon: 'üí™',
        levels: {
            root: 'Program',
            phase: 'Phase',
            item: 'Workout',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Foundation', 'Build', 'Peak'],
        types: [
            { value: 'strength', label: 'Strength Training' },
            { value: 'cardio', label: 'Cardio' },
            { value: 'flexibility', label: 'Flexibility' },
            { value: 'recovery', label: 'Recovery' },
            { value: 'nutrition', label: 'Nutrition' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'conditioning', label: 'Conditioning' },
            { value: 'mobility', label: 'Mobility' }
        ],
        description: 'Structure training programs with periodization',
        fields: {
            sets: { label: 'Sets', type: 'number', min: 0, step: 1, placeholder: 'Number of sets...', helpText: 'üî¢ Number of sets' },
            reps: { label: 'Reps', type: 'text', placeholder: '8-12, 10, AMRAP...', helpText: 'üîÅ Repetitions per set' },
            duration: { label: 'Duration', type: 'text', placeholder: '30 minutes, 45 sec...', helpText: '‚è±Ô∏è Time for this exercise/workout' },
            intensity: { label: 'Intensity Level', type: 'select', options: ['Light', 'Moderate', 'High', 'Max'], helpText: 'üî• Effort level' },
            equipment: { label: 'Equipment Needed', type: 'text', placeholder: 'Dumbbells, Barbell, Bodyweight...', helpText: 'üèãÔ∏è Required equipment' },
            formCues: { label: 'Form Cues', type: 'textarea', placeholder: 'Key technique reminders...', helpText: '‚úÖ Important form tips' },
            restPeriod: { label: 'Rest Period', type: 'text', placeholder: '60 sec, 2 min...', helpText: '‚è∏Ô∏è Rest between sets' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    strategy: {
        name: 'Strategic Plan',
        icon: 'üìä',
        levels: {
            root: 'Strategy',
            phase: 'Pillar',
            item: 'Initiative',
            subtask: 'Action'
        },
        phaseSubtitles: ['Planning', 'Execution', 'Review'],
        types: [
            { value: 'market-expansion', label: 'Market Expansion' },
            { value: 'operational', label: 'Operational Excellence' },
            { value: 'financial', label: 'Financial' },
            { value: 'hr', label: 'Human Resources' },
            { value: 'technology', label: 'Technology' },
            { value: 'risk-management', label: 'Risk Management' },
            { value: 'innovation', label: 'Innovation' },
            { value: 'customer', label: 'Customer Experience' }
        ],
        description: 'Organize business strategy into pillars and initiatives',
        fields: {
            investment: { label: 'Investment ($)', type: 'number', step: 10000, helpText: 'üí∞ Capital investment required' },
            keyMetric: { label: 'Key Metric', type: 'text', placeholder: 'What defines success...', helpText: 'üìä Success measurement' },
            targetValue: { label: 'Target Value', type: 'text', placeholder: 'Goal for metric...', helpText: 'üéØ Goal to achieve' },
            responsibleExecutive: { label: 'Responsible Executive', type: 'text', placeholder: 'C-level owner...', helpText: 'üëî Executive sponsor' },
            strategicTheme: { label: 'Strategic Theme', type: 'select', options: ['Growth', 'Efficiency', 'Innovation', 'Transformation', 'Risk Mitigation'], helpText: 'üé≠ Strategic category' },
            riskLevel: { label: 'Risk Level', type: 'select', options: ['Low', 'Medium', 'High'], helpText: '‚ö†Ô∏è Implementation risk' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    course: {
        name: 'Course Design',
        icon: 'üìñ',
        levels: {
            root: 'Course',
            phase: 'Unit',
            item: 'Lesson',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Beginning', 'Middle', 'Advanced'],
        types: [
            { value: 'lecture', label: 'Lecture' },
            { value: 'lab', label: 'Lab/Practical' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'reading', label: 'Reading' },
            { value: 'project', label: 'Project' },
            { value: 'workshop', label: 'Workshop' },
            { value: 'field-work', label: 'Field Work' }
        ],
        description: 'Build educational curricula with units and lessons',
        fields: {
            learningObjectives: { label: 'Learning Objectives', type: 'textarea', placeholder: 'What students will learn...', helpText: 'üéì Expected learning outcomes' },
            duration: { label: 'Duration', type: 'text', placeholder: '50 minutes, 2 hours...', helpText: '‚è±Ô∏è Class time needed' },
            difficultyLevel: { label: 'Difficulty Level', type: 'select', options: ['Beginner', 'Intermediate', 'Advanced'], helpText: 'üìä Complexity level' },
            prerequisites: { label: 'Prerequisites', type: 'textarea', placeholder: 'Prior knowledge needed...', helpText: 'üìã Required background' },
            assessmentType: { label: 'Assessment Type', type: 'select', options: ['Quiz', 'Assignment', 'Project', 'Discussion', 'Exam', 'None'], helpText: '‚úÖ How learning is evaluated' },
            resourcesNeeded: { label: 'Resources Needed', type: 'textarea', placeholder: 'Textbook chapters, videos, materials...', helpText: 'üìö Required materials' },
            homework: { label: 'Homework', type: 'textarea', placeholder: 'Out-of-class work...', helpText: 'üìù Assignments for students' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    film: {
        name: 'Film Production',
        icon: 'üé¨',
        levels: {
            root: 'Film',
            phase: 'Phase',
            item: 'Scene',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Pre-Production', 'Production', 'Post-Production'],
        types: [
            { value: 'pre-production', label: 'Pre-Production' },
            { value: 'production', label: 'Production' },
            { value: 'post-production', label: 'Post-Production' },
            { value: 'vfx', label: 'VFX' },
            { value: 'sound', label: 'Sound Design' },
            { value: 'marketing', label: 'Marketing' },
            { value: 'distribution', label: 'Distribution' },
            { value: 'location', label: 'Location' }
        ],
        description: 'Organize pre-production, production, and post-production',
        fields: {
            budget: { label: 'Budget ($)', type: 'number', step: 1000, helpText: 'üí∞ Budget for this scene/shot' },
            shootDuration: { label: 'Shoot Duration', type: 'text', placeholder: '2 hours, half day...', helpText: '‚è±Ô∏è Time needed to shoot' },
            location: { label: 'Location', type: 'text', placeholder: 'Where to shoot...', helpText: 'üìç Filming location' },
            castRequired: { label: 'Cast Required', type: 'textarea', placeholder: 'Which actors...', helpText: 'üé≠ Actors needed' },
            crewNeeded: { label: 'Crew Needed', type: 'textarea', placeholder: 'Camera, sound, etc...', helpText: 'üë• Crew requirements' },
            equipment: { label: 'Equipment', type: 'textarea', placeholder: 'Camera, lighting, props...', helpText: 'üé• Technical equipment needed' },
            shotType: { label: 'Shot Type', type: 'select', options: ['Wide', 'Medium', 'Close-up', 'POV', 'Over Shoulder', 'Establishing'], helpText: 'üìπ Camera framing' },
            sceneNumber: { label: 'Scene Number', type: 'text', placeholder: 'For continuity...', helpText: 'üé¨ Script scene number' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    philosophy: {
        name: 'Philosophy',
        icon: 'ü§î',
        levels: {
            root: 'Dialogue',
            phase: 'Movement',
            item: 'Claim',
            subtask: 'Support'
        },
        phaseSubtitles: ['Opening Question', 'First Definition', 'Refutation', 'Second Attempt', 'Deeper Inquiry', 'Resolution'],
        types: [
            // Dialectical moves
            { value: 'question', label: '‚ùì Question' },
            { value: 'definition', label: 'üìê Definition' },
            { value: 'refutation', label: '‚ùå Refutation/Elenchus' },
            { value: 'premise', label: 'üìç Premise' },
            { value: 'conclusion', label: '‚úì Conclusion' },
            { value: 'objection', label: '‚ö†Ô∏è Objection' },
            { value: 'response', label: 'üí¨ Response' },
            { value: 'example', label: 'üìñ Example' },
            { value: 'analogy', label: 'üîÑ Analogy' },
            { value: 'distinction', label: '‚öñÔ∏è Distinction' },
            { value: 'paradox', label: 'üåÄ Paradox' },
            { value: 'thought-experiment', label: 'üí≠ Thought Experiment' },
            { value: 'aporia', label: 'ü§∑ Aporia (Impasse)' },
            // Philosophical domains
            { value: 'metaphysical', label: 'üåå Metaphysical' },
            { value: 'epistemological', label: 'üß† Epistemological' },
            { value: 'ethical', label: '‚öñÔ∏è Ethical' },
            { value: 'political', label: 'üèõÔ∏è Political' },
            { value: 'logical', label: 'üî¢ Logical' }
        ],
        description: 'Structure philosophical dialogues, treatises, and arguments with dialectical precision',
        fields: {
            speaker: { label: 'Speaker', type: 'text', placeholder: 'Socrates, Meno, etc...', helpText: 'üó£Ô∏è Who makes this claim or argument' },
            argumentType: { label: 'Argument Type', type: 'select', options: ['Deductive', 'Inductive', 'Abductive', 'Dialectical', 'Reductio ad Absurdum', 'Socratic Elenchus'], helpText: 'üéØ Type of reasoning employed' },
            validity: { label: 'Logical Validity', type: 'select', options: ['Valid', 'Invalid', 'Sound', 'Unsound', 'Uncertain'], helpText: '‚úì Logical soundness' },
            keyTerms: { label: 'Key Terms', type: 'text', placeholder: 'virtue, knowledge, piety...', helpText: 'üìù Central concepts defined or discussed' },
            premise1: { label: 'Premise 1', type: 'textarea', placeholder: 'First premise of argument...', helpText: '1Ô∏è‚É£ First assumption or claim' },
            premise2: { label: 'Premise 2', type: 'textarea', placeholder: 'Second premise...', helpText: '2Ô∏è‚É£ Second assumption or claim' },
            conclusion: { label: 'Conclusion', type: 'textarea', placeholder: 'What follows from premises...', helpText: '‚úì Logical conclusion' },
            objection: { label: 'Objection', type: 'textarea', placeholder: 'Main counterargument...', helpText: '‚ùå Key objection raised' },
            response: { label: 'Response to Objection', type: 'textarea', placeholder: 'How objection is addressed...', helpText: 'üí° Defense or reply to objection' },
            textualReference: { label: 'Textual Reference', type: 'text', placeholder: 'e.g., Meno 70a-72c, Republic 347c...', helpText: 'üìñ Stephanus number or page reference' },
            philosophicalSchool: { label: 'School of Thought', type: 'select', options: ['Pre-Socratic', 'Platonic', 'Aristotelian', 'Stoic', 'Epicurean', 'Skeptic', 'Medieval', 'Rationalist', 'Empiricist', 'Kantian', 'Hegelian', 'Phenomenological', 'Analytic', 'Continental', 'Pragmatist', 'Other'], helpText: 'üèõÔ∏è Philosophical tradition or school' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    prompting: {
        name: 'AI Prompt Design',
        icon: 'üß†',
        levels: {
            root: 'Prompt Workbook',
            phase: 'Stage',
            item: 'Prompt Module',
            subtask: 'Prompt Step'
        },
        phaseSubtitles: ['Research & Requirements', 'Prompt Drafting', 'Testing & Optimization', 'Deployment & Monitoring'],
        types: [
            { value: 'system-persona', label: 'System Persona' },
            { value: 'user-template', label: 'User Prompt Template' },
            { value: 'tool-call', label: 'Tool / Function Call' },
            { value: 'agent-hand-off', label: 'Agent Hand-off' },
            { value: 'evaluator', label: 'Evaluator / Judge' },
            { value: 'safety', label: 'Safety / Guardrail' },
            { value: 'workflow', label: 'Workflow Orchestration' },
            { value: 'test-set', label: 'Test Dataset' }
        ],
        description: 'Design multi-stage prompts, agents, and evaluation harnesses for AI systems',
        fields: {
            useCase: {
                label: 'Use Case',
                type: 'select',
                options: ['Retrieval / RAG', 'Chain-of-Thought', 'Tool Invocation', 'Agent Workflow', 'Evaluation', 'Guardrail', 'Content Generation', 'Summarization'],
                helpText: 'üéØ Primary job this module performs'
            },
            modelTarget: {
                label: 'Target Model',
                type: 'text',
                placeholder: 'Claude 3.5 Sonnet, GPT-4o, internal LLM...',
                helpText: 'üß¨ Which LLM(s) this prompt is tuned for'
            },
            temperature: {
                label: 'Temperature',
                type: 'number',
                min: 0,
                max: 1,
                step: 0.05,
                helpText: 'üî• Generation randomness (0 = deterministic)'
            },
            maxTokens: {
                label: 'Max Tokens',
                type: 'number',
                min: 0,
                step: 50,
                helpText: 'üìè Cap on completion tokens'
            },
            stopSequences: {
                label: 'Stop Sequences',
                type: 'textarea',
                placeholder: '|||, END_PROMPT, </end>',
                helpText: '‚õî Strings that should terminate the response'
            },
            inputs: {
                label: 'Input Variables',
                type: 'textarea',
                placeholder: '{{customer_issue}}, {{context}}, {{tools}}...',
                helpText: 'üß© Required placeholders or dynamic values'
            },
            outputs: {
                label: 'Expected Output',
                type: 'textarea',
                placeholder: 'JSON schema, bulleted plan, structured text...',
                helpText: 'üì§ Desired response structure'
            },
            evaluationCriteria: {
                label: 'Evaluation Criteria',
                type: 'textarea',
                placeholder: 'Clarity, accuracy, latency, formatting...',
                helpText: 'üß™ How success is measured'
            },
            safetyConsiderations: {
                label: 'Safety Considerations',
                type: 'textarea',
                placeholder: 'PII handling, jailbreak risks, bias notes...',
                helpText: 'üõ°Ô∏è Guardrails and mitigations'
            },
            hallucinationRisks: {
                label: 'Hallucination Risks',
                type: 'textarea',
                placeholder: 'Where the model may fabricate',
                helpText: '‚ö†Ô∏è Known failure modes'
            },
            promptExamples: {
                label: 'Prompt Examples',
                type: 'textarea',
                placeholder: 'System/User/Assistant samples...',
                helpText: 'üóÉÔ∏è Reference snippets'
            },
            testStatus: {
                label: 'Test Status',
                type: 'select',
                options: ['Idea', 'Drafted', 'Testing', 'Validated', 'Production'],
                helpText: '‚úÖ Validation stage'
            },
            benchmarks: {
                label: 'Benchmark / Metrics',
                type: 'text',
                placeholder: 'Win rate 72%, latency 1.2s...',
                helpText: 'üìà Quantitative performance'
            },
            agentHandOff: {
                label: 'Agent Hand-off Notes',
                type: 'textarea',
                placeholder: 'How this module hands off to next agent/tool',
                helpText: 'ü§ù Coordination details for multi-agent workflows'
            },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    familytree: {
        name: 'Family Tree',
        icon: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
        levels: {
            root: 'Family',
            phase: 'Generation',
            item: 'Person',
            subtask: 'Event'
        },
        phaseSubtitles: ['Self/Siblings', 'Parents', 'Grandparents', 'Great-Grandparents', 'Great-Great-Grandparents', 'Children', 'Grandchildren', 'Great-Grandchildren'],
        types: [
            { value: 'paternal', label: 'Paternal Line' },
            { value: 'maternal', label: 'Maternal Line' },
            { value: 'spouse', label: 'Spouse' },
            { value: 'biological', label: 'Biological' },
            { value: 'adopted', label: 'Adopted' },
            { value: 'step', label: 'Step-Family' },
            { value: 'foster', label: 'Foster' },
            { value: 'half', label: 'Half-Sibling' }
        ],
        description: 'Build and document your family genealogy',
        fields: {
            fullName: { label: 'Full Name', type: 'text', placeholder: 'First Middle Last...', helpText: 'üë§ Complete name including middle names' },
            maidenName: { label: 'Maiden Name', type: 'text', placeholder: 'Birth surname if different...', helpText: 'üíç Birth surname (if changed after marriage)' },
            gender: { label: 'Gender', type: 'select', options: ['Male', 'Female', 'Other', 'Unknown'], helpText: '‚öß Gender identity' },
            birthDate: { label: 'Birth Date', type: 'date', helpText: 'üéÇ Date of birth' },
            birthPlace: { label: 'Birth Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'üìç Place of birth (city, state, country)' },
            livingStatus: { label: 'Living Status', type: 'select', options: ['Living', 'Deceased', 'Unknown'], helpText: 'üíö Current living status' },
            deathDate: { label: 'Death Date', type: 'date', helpText: 'üïäÔ∏è Date of death (if deceased)' },
            deathPlace: { label: 'Death Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'üìç Place of death (if deceased)' },
            marriageDate: { label: 'Marriage Date', type: 'date', helpText: 'üíí Date of marriage' },
            marriagePlace: { label: 'Marriage Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'üìç Place of marriage ceremony' },
            spouseName: { label: 'Spouse Name', type: 'text', placeholder: 'Name of spouse...', helpText: 'üíë Current or former spouse' },
            occupation: { label: 'Occupation', type: 'text', placeholder: 'Profession or career...', helpText: 'üíº Primary occupation or career' },
            photoURL: { label: 'Photo URL', type: 'text', placeholder: 'https://...', helpText: 'üì∑ Link to portrait or photo' },
            dnaInfo: { label: 'DNA/Genetic Info', type: 'textarea', placeholder: 'Haplogroup, DNA matches, test results...', helpText: 'üß¨ DNA test results, haplogroups, genetic markers' },
            sources: { label: 'Sources/Citations', type: 'textarea', placeholder: 'Documents, certificates, records...', helpText: 'üìÑ Birth certificates, census records, documents' },
            relationshipType: { label: 'Relationship Type', type: 'select', options: ['Biological', 'Adopted', 'Step', 'Foster', 'Half-Sibling', 'Unknown'], helpText: 'üîó Type of family relationship' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    custom: {
        name: 'Custom Names',
        icon: '‚úèÔ∏è',
        levels: {
            root: 'Level 0',
            phase: 'Level 1',
            item: 'Level 2',
            subtask: 'Level 3'
        },
        description: 'Define your own names for all four levels',
        customizable: true
    }
};

// ============================================================================
// PATTERN STATE
// ============================================================================

let currentPattern = 'generic';
let customPatternNames = null;

// ============================================================================
// PATTERN FUNCTIONS
// ============================================================================

function getPatternLabels() {
    console.log('getPatternLabels called, currentPattern:', currentPattern);
    if (currentPattern === 'custom' && customPatternNames) {
        console.log('Returning custom labels:', customPatternNames);
        return customPatternNames;
    }
    const labels = PATTERNS[currentPattern].levels;
    console.log('Returning pattern labels:', labels);
    return labels;
}

function renameNodesForPattern(node, labels) {
    if (!node) return;

    // Collect all possible terms from all patterns for replacement
    const allRootTerms = ['Project', 'Pipeline', 'Thesis', 'Product', 'Book', 'Event', 'Program', 'Strategy', 'Course', 'Film', 'Treatise', 'Family'];
    const allPhaseTerms = ['Phase', 'Quarter', 'Chapter', 'Part', 'Stage', 'Pillar', 'Unit', 'Generation'];
    const allItemTerms = ['Item', 'Deal', 'Section', 'Feature', 'Chapter', 'Activity', 'Workout', 'Initiative', 'Lesson', 'Scene', 'Argument', 'Person'];
    const allSubtaskTerms = ['Task', 'Sub-task', 'Action', 'Point', 'Story', 'Scene', 'Exercise', 'Shot', 'Premise', 'Event'];

    // Rename based on node type - replace ANY pattern term with the new one
    if (node.type === 'root') {
        // Try to replace any root term from any pattern
        for (const term of allRootTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.root);
        }
    } else if (node.type === 'phase') {
        // Try to replace any phase term from any pattern
        for (const term of allPhaseTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.phase);
        }
        // Update phase subtitle based on pattern
        if (PATTERNS[currentPattern].phaseSubtitles && node.phase !== undefined) {
            const phaseIndex = parseInt(node.phase);
            if (!isNaN(phaseIndex) && phaseIndex < PATTERNS[currentPattern].phaseSubtitles.length) {
                node.subtitle = PATTERNS[currentPattern].phaseSubtitles[phaseIndex];
            }
        }
    } else if (node.type === 'item') {
        // Try to replace any item term from any pattern
        for (const term of allItemTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.item);
        }
    } else if (node.type === 'subtask') {
        // Try to replace any subtask term from any pattern
        for (const term of allSubtaskTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.subtask);
        }
    }

    // Recursively process children
    if (node.children) {
        node.children.forEach(child => renameNodesForPattern(child, labels));
    }

    // Process items in phases
    if (node.items) {
        node.items.forEach(item => {
            renameNodesForPattern(item, labels);
            // Process subtasks
            if (item.subItems) {
                item.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
            }
        });
    }

    // Process nested subtasks
    if (node.subItems) {
        node.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
    }
}

function applyPattern(patternKey) {
    console.log('applyPattern called with:', patternKey);
    currentPattern = patternKey;

    if (patternKey === 'custom') {
        showCustomPatternDialog();
    } else {
        // Store in data
        if (!capexTree.pattern) {
            capexTree.pattern = {};
        }
        capexTree.pattern.key = patternKey;
        capexTree.pattern.labels = PATTERNS[patternKey].levels;
        console.log('Pattern applied:', PATTERNS[patternKey].name);
        console.log('New labels:', PATTERNS[patternKey].levels);

        // Auto-rename existing nodes to match pattern
        renameNodesForPattern(capexTree, PATTERNS[patternKey].levels);
        console.log('Nodes renamed to match pattern');

        // Re-render to apply new labels
        render();
    }
}

function showCustomPatternDialog() {
    const pattern = PATTERNS[currentPattern];
    const currentLabels = customPatternNames || pattern.levels;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = `
        <div style="padding: 20px;">
            <h3 style="color: var(--treeplex-primary); margin-bottom: 20px;">Custom Pattern Names</h3>
            <p style="margin-bottom: 20px; color: var(--text-secondary); font-size: 14px;">
                Define your own names for each level of your project structure.
            </p>

            <div style="display: flex; flex-direction: column; gap: 16px;">
                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 0 (Root):
                    </label>
                    <input type="text" id="custom-root" value="${currentLabels.root}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Project, Campaign, Thesis">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 1 (Phase):
                    </label>
                    <input type="text" id="custom-phase" value="${currentLabels.phase}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Phase, Quarter, Chapter">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 2 (Item):
                    </label>
                    <input type="text" id="custom-item" value="${currentLabels.item}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Item, Feature, Section">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 3 (Subtask):
                    </label>
                    <input type="text" id="custom-subtask" value="${currentLabels.subtask}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Task, Story, Point">
                </div>
            </div>

            <div style="display: flex; gap: 12px; margin-top: 24px;">
                <button class="btn btn-primary" onclick="saveCustomPattern()" style="flex: 1;">
                    ‚úì Apply Custom Names
                </button>
                <button class="btn" onclick="closeModal()" style="flex: 1;">
                    Cancel
                </button>
            </div>
        </div>
    `;

    document.getElementById('modal').style.display = 'flex';
}

function saveCustomPattern() {
    const root = document.getElementById('custom-root').value.trim() || 'Level 0';
    const phase = document.getElementById('custom-phase').value.trim() || 'Level 1';
    const item = document.getElementById('custom-item').value.trim() || 'Level 2';
    const subtask = document.getElementById('custom-subtask').value.trim() || 'Level 3';

    customPatternNames = { root, phase, item, subtask };

    // Store in data
    if (!capexTree.pattern) {
        capexTree.pattern = {};
    }
    capexTree.pattern.key = 'custom';
    capexTree.pattern.labels = customPatternNames;

    closeModal();
    render();
}

// ============================================================================
// INITIALIZATION
// ============================================================================


function showPatternDescription() {
    const select = document.getElementById('pattern-select');
    const selectedOption = select.options[select.selectedIndex];
    const desc = selectedOption.getAttribute('data-desc');

    if (desc) {
        select.setAttribute('title', desc);
    }
}

function hidePatternDescription() {
    // Keep title for basic tooltip
}

        // State
        let activeNode = null;

        // Utilities
        function formatCost(cost) {
            if (cost >= 1000000) return '$' + (cost / 1000000).toFixed(1) + 'M';
            if (cost >= 1000) return '$' + (cost / 1000).toFixed(0) + 'k';
            return '$' + cost.toLocaleString();
        }

        // Calculate total including all children (for root node)
        function calculateTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            if (node.children) {
                node.children.forEach(child => {
                    total += calculateTotal(child);
                });
            }
            return total;
        }

        // Calculate only items in this phase (NOT children phases)
        function calculatePhaseTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            return total;
        }

        function findNode(id, node = capexTree) {
            if (node.id === id) return node;
            if (node.children) {
                for (let child of node.children) {
                    const found = findNode(id, child);
                    if (found) return found;
                }
            }
            return null;
        }

        // Render tree - phases flow left to right
        function render() {
            const container = document.getElementById('tree-root');
            container.innerHTML = '';

            const tableEl = document.createElement('div');
            tableEl.className = 'tree';

            // Traverse and build columns
            function buildColumn(node) {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'tree-level';

                // Render current node
                const nodeDiv = document.createElement('div');
                nodeDiv.className = `tree-node ${node.type}`;
                if (node.type === 'phase') nodeDiv.classList.add(`phase-${node.phase}`);
                if (node.expanded) nodeDiv.classList.add('expanded');
                else nodeDiv.classList.add('collapsed');

                nodeDiv.dataset.nodeId = node.id;

                if (node.type === 'root') {
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon}</span>
                            <div class="node-content">
                                <div class="node-title">${node.name}</div>
                                <div class="node-subtitle">by geej</div>
                            </div>
                            ${node.children ? '<span class="expand-toggle">‚ñ∂</span>' : ''}
                        </div>
                    `;
                } else if (node.type === 'phase') {
                    const total = calculatePhaseTotal(node);
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon}</span>
                            <div class="node-content">
                                <div class="node-title">${node.name}</div>
                                <div class="node-subtitle">${node.subtitle}</div>
                                ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<div class="node-cost">${formatCost(total)}</div>` : ''}
                            </div>
                            ${node.items || node.children ? '<span class="expand-toggle">‚ñ∂</span>' : ''}
                        </div>
                    `;
                } else {
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon}</span>
                            <div class="node-content">
                                <div class="item-name">${node.name}</div>
                                <div class="item-description">${node.description}</div>
                                <div class="item-meta">
                                    ${node.itemType ? `<span class="badge badge-${node.itemType}">${node.itemType}</span>` : ''}
                                    ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<span class="item-cost">${formatCost(node.cost)}</span>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }

                nodeDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if ((node.items && node.items.length > 0) || (node.children && node.children.length > 0)) {
                        node.expanded = !node.expanded;
                        render();
                    } else {
                        showInfo(node);
                    }
                });

                nodeDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    activeNode = node;
                    showContextMenu(e.pageX, e.pageY);
                });

                levelDiv.appendChild(nodeDiv);
                tableEl.appendChild(levelDiv);

                // If expanded, show items in next column, then next phase in following column
                if (node.expanded) {
                    // Show items if any
                    if (node.items && node.items.length > 0) {
                        const itemsColumn = document.createElement('div');
                        itemsColumn.className = 'tree-level';

                        // Get all item IDs in this phase to check for same-phase dependencies
                        const phaseItemIds = node.items.map(i => i.id);

                        // Topological sort: order items by dependencies
                        // Items with no same-phase dependencies first, then items that depend on them
                        function topologicalSort(items, phaseIds) {
                            const sorted = [];
                            const visited = new Set();
                            const visiting = new Set();

                            function visit(item) {
                                if (visited.has(item.id)) return;
                                if (visiting.has(item.id)) {
                                    // Circular dependency - just add it
                                    sorted.push(item);
                                    visited.add(item.id);
                                    return;
                                }

                                visiting.add(item.id);

                                // Visit dependencies first (only same-phase dependencies)
                                if (item.dependencies) {
                                    // Handle both array and string formats
                                    const deps = Array.isArray(item.dependencies) ? item.dependencies : [];
                                    deps.forEach(depId => {
                                        if (phaseIds.includes(depId)) {
                                            const depItem = items.find(i => i.id === depId);
                                            if (depItem) {
                                                visit(depItem);
                                            }
                                        }
                                    });
                                }

                                visiting.delete(item.id);
                                visited.add(item.id);
                                sorted.push(item);
                            }

                            items.forEach(item => visit(item));
                            return sorted;
                        }

                        // Calculate dependency depth/level for hierarchical indentation
                        // Returns the depth in the dependency chain (0 = no deps, 1 = direct child, 2 = grandchild, etc.)
                        function calculateDependencyLevel(item, phaseItems, phaseItemIds, visited = new Set()) {
                            // Base case: no same-phase dependencies
                            if (!item.dependencies || item.dependencies.length === 0) {
                                return 0;
                            }

                            const samePhaseDeps = item.dependencies.filter(depId => phaseItemIds.includes(depId));
                            if (samePhaseDeps.length === 0) {
                                return 0;
                            }

                            // Prevent circular dependency infinite loops
                            if (visited.has(item.id)) {
                                return 0;
                            }

                            visited.add(item.id);

                            // Find max depth among all same-phase dependencies
                            let maxLevel = 0;
                            samePhaseDeps.forEach(depId => {
                                const depItem = phaseItems.find(i => i.id === depId);
                                if (depItem) {
                                    const depLevel = calculateDependencyLevel(depItem, phaseItems, phaseItemIds, new Set(visited));
                                    maxLevel = Math.max(maxLevel, depLevel + 1);
                                }
                            });

                            return maxLevel;
                        }

                        const sortedItems = topologicalSort(node.items, phaseItemIds);

                        sortedItems.forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = `tree-node item phase-${node.phase}`;
                            itemDiv.dataset.itemId = item.id; // Add item ID for dependency linking

                            // Calculate dependency depth for hierarchical indentation
                            const dependencyLevel = calculateDependencyLevel(item, node.items, phaseItemIds);

                            // Add multi-level indentation based on dependency depth
                            // Level 0 = no indent, Level 1 = 20px, Level 2 = 40px, Level 3 = 60px, etc.
                            if (dependencyLevel > 0) {
                                itemDiv.classList.add('has-same-phase-dependency');
                                itemDiv.style.marginLeft = `${dependencyLevel * 20}px`;
                                itemDiv.style.position = 'relative';
                                itemDiv.dataset.dependencyLevel = dependencyLevel; // Store for potential visual enhancements
                            }

                            // Add expanded class if item has subtasks and is expanded
                            if (item.subItems && item.subItems.length > 0 && item.expanded) {
                                itemDiv.classList.add('has-expanded-subtasks');
                            }

                            // Add dependency indicator
                            const depInfo = item.dependencies && item.dependencies.length > 0
                                ? `<div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">Depends: ${item.dependencies.join(', ')}</div>`
                                : '';

                            // Check if item has subtasks for expand/collapse indicator
                            const hasSubtasks = item.subItems && item.subItems.length > 0;
                            const expandIndicator = hasSubtasks
                                ? `<span class="expand-toggle" onclick="event.stopPropagation(); window.toggleSubtasks('${item.id}');" style="margin-left: 8px; font-size: 12px; opacity: 0.7; cursor: pointer; user-select: none;">${item.expanded ? '‚ñº' : '‚ñ∂'}</span>`
                                : '';

                            itemDiv.innerHTML = `
                                <div class="node-header">
                                    <span class="node-icon">${item.icon}</span>
                                    <div class="node-content">
                                        <div class="item-name">
                                            ${item.name}
                                            ${expandIndicator}
                                            ${hasSubtasks ? `<span style="font-size: 10px; color: var(--text-secondary); margin-left: 8px;">(${item.subItems.length} tasks)</span>` : ''}
                                        </div>
                                        <div class="item-description">${item.description}</div>
                                        <div class="item-meta">
                                            ${item.itemType ? `<span class="badge badge-${item.itemType}">${item.itemType}</span>` : ''}
                                            ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<span class="item-cost">${formatCost(item.cost)}</span>` : ''}
                                        </div>
                                        ${depInfo}
                                    </div>
                                </div>
                            `;
                            itemDiv.addEventListener('click', (e) => {
                                e.stopPropagation();

                                const panel = document.getElementById('info-panel');
                                const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === item.id;

                                if (isPanelOpen) {
                                    // Second click: Close panel and collapse subtasks
                                    panel.classList.remove('open');
                                    currentOpenItemId = null;
                                    if (hasSubtasks) {
                                        item.expanded = false;
                                        render();
                                    }
                                } else {
                                    // First click: Open panel and expand subtasks
                                    showInfo(item);
                                    if (hasSubtasks) {
                                        item.expanded = true;
                                        render();
                                    }
                                }
                            });

                            itemDiv.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                activeNode = item;
                                showContextMenu(e.pageX, e.pageY);
                            });

                            itemsColumn.appendChild(itemDiv);

                            // RECURSIVE function to render subtasks - keeps same generation on horizontal plane
                            function renderSubtasks(parentItem, containerEl, phaseNum, nestLevel = 0) {
                                if (!parentItem.expanded || !parentItem.subItems || parentItem.subItems.length === 0) {
                                    return;
                                }

                                const subtaskContainer = document.createElement('div');
                                subtaskContainer.className = 'subtask-container';
                                subtaskContainer.style.marginLeft = `${(dependencyLevel + nestLevel) * 20}px`;

                                // Get sub-item IDs for dependency calculations
                                const subItemIds = parentItem.subItems.map(s => s.id);

                                // Sort sub-items by dependencies (topological sort)
                                const sortedSubItems = topologicalSort(parentItem.subItems, subItemIds);

                                // Collect all expanded children that need rendering in next generation
                                const allExpandedGrandchildren = [];

                                // Render all subtasks horizontally first (same generation on same row)
                                sortedSubItems.forEach((subItem, index) => {
                                    const subItemDiv = document.createElement('div');
                                    subItemDiv.className = `tree-node item phase-${phaseNum} subtask`;
                                    subItemDiv.dataset.itemId = subItem.id;

                                    // Ensure subItem has type set
                                    if (!subItem.type) {
                                        subItem.type = 'subtask';
                                    }

                                    // Status color indicator
                                    const statusColors = {
                                        'To Do': '#9CA3AF',
                                        'In Progress': '#3B82F6',
                                        'Completed': '#10B981',
                                        'Done': '#10B981',
                                        'Blocked': '#EF4444'
                                    };
                                    const statusColor = statusColors[subItem.pmStatus] || '#9CA3AF';

                                    // Get initials from assignee name
                                    const getInitials = (name) => {
                                        if (!name || name === 'Unassigned') return '?';
                                        const parts = name.trim().split(' ');
                                        if (parts.length === 1) return parts[0].substring(0, 2).toUpperCase();
                                        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                                    };

                                    // Check if this task has children
                                    const hasChildren = subItem.subItems && subItem.subItems.length > 0;
                                    const chevronIcon = hasChildren ? (subItem.expanded ? '‚ñº' : '‚ñ∂') : '';

                                    subItemDiv.innerHTML = `
                                        <div style="display: flex; flex-direction: column; gap: 6px; width: 100%; height: 100%;">
                                            <!-- Task Title with optional chevron -->
                                            <div style="display: flex; align-items: flex-start; gap: 4px;">
                                                ${chevronIcon ? `<span style="font-size: 8px; color: var(--text-secondary); cursor: pointer; margin-top: 2px;" class="task-chevron">${chevronIcon}</span>` : ''}
                                                <div style="font-size: 11px; font-weight: 600; line-height: 1.2; color: var(--text-primary); flex: 1; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                                                    ${subItem.name}
                                                </div>
                                            </div>

                                            <!-- Visual Indicators Row -->
                                            <div style="display: flex; align-items: center; gap: 6px; margin-top: auto;">
                                                <!-- Status Dot -->
                                                <div style="width: 12px; height: 12px; border-radius: 50%; background: ${statusColor}; box-shadow: 0 0 6px ${statusColor}; flex-shrink: 0;" title="${subItem.pmStatus || 'To Do'}"></div>

                                                <!-- Owner Badge -->
                                                <div style="width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; color: white; flex-shrink: 0;" title="${subItem.pmAssignee || 'Unassigned'}">
                                                    ${getInitials(subItem.pmAssignee)}
                                                </div>

                                                <!-- Progress % -->
                                                <div style="font-size: 11px; font-weight: 700; color: var(--treeplex-primary); margin-left: auto;" title="Progress">
                                                    ${subItem.pmProgress || 0}%
                                                </div>
                                            </div>

                                            <!-- Mini Progress Bar -->
                                            <div style="width: 100%; height: 3px; background: rgba(0, 0, 0, 0.3); border-radius: 2px; overflow: hidden;">
                                                <div style="height: 100%; width: ${subItem.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                                            </div>
                                        </div>
                                    `;

                                    // Click to show info panel AND toggle nested subtasks
                                    subItemDiv.addEventListener('click', (e) => {
                                        e.stopPropagation();

                                        const panel = document.getElementById('info-panel');
                                        const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === subItem.id;

                                        if (isPanelOpen) {
                                            // Second click: Close panel and collapse nested subtasks
                                            panel.classList.remove('open');
                                            currentOpenItemId = null;
                                            if (hasChildren) {
                                                subItem.expanded = false;
                                                render();
                                            }
                                        } else {
                                            // First click: Open panel and expand nested subtasks
                                            showInfo(subItem);
                                            if (hasChildren) {
                                                subItem.expanded = true;
                                                render();
                                            }
                                        }
                                    });

                                    subItemDiv.addEventListener('contextmenu', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        activeNode = subItem;
                                        showContextMenu(e.pageX, e.pageY);
                                    });

                                    subtaskContainer.appendChild(subItemDiv);

                                    // Collect expanded children for next generation
                                    if (subItem.expanded && subItem.subItems && subItem.subItems.length > 0) {
                                        allExpandedGrandchildren.push(subItem);
                                    }
                                });

                                containerEl.appendChild(subtaskContainer);

                                // Now render ALL children of this generation on the NEXT horizontal row below
                                allExpandedGrandchildren.forEach(expandedChild => {
                                    renderSubtasks(expandedChild, containerEl, phaseNum, nestLevel + 1);
                                });
                            }

                            // Initial call to render subtasks
                            renderSubtasks(item, itemsColumn, node.phase, 0);
                        });

                        tableEl.appendChild(itemsColumn);
                    }

                    // Recursively render next phase
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => buildColumn(child));
                    }
                }
            }

            buildColumn(capexTree);
            container.appendChild(tableEl);

            // Draw dependency lines after rendering
            setTimeout(drawDependencyLines, 100);
        }

        // Draw dependency lines using SVG
        function drawDependencyLines() {
            const svg = document.getElementById('dependency-svg');
            const treeEl = document.getElementById('tree-root');
            const wrapperEl = document.getElementById('tree-transform-wrapper');

            // Clear existing lines
            svg.innerHTML = '';

            // Set SVG dimensions to be large enough for panning/zooming
            // Use a fixed large size that the CSS will position correctly
            svg.setAttribute('width', '20000');
            svg.setAttribute('height', '20000');

            // Add arrow marker definitions
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Create markers for each phase color - using darker vibrant colors
            const colors = {
                'phase-0': '#4CAF50',
                'phase-1': '#2196F3',
                'phase-2': '#FB8C00',
                'cross-phase': '#008F6D'
            };

            Object.entries(colors).forEach(([className, color]) => {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', `arrow-${className}`);
                marker.setAttribute('viewBox', '0 0 10 10');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '5');
                marker.setAttribute('markerWidth', '8');
                marker.setAttribute('markerHeight', '8');
                marker.setAttribute('orient', 'auto');

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                path.setAttribute('fill', color);
                path.setAttribute('opacity', '0.8');
                path.setAttribute('filter', 'drop-shadow(0 2px 2px rgba(0,0,0,0.2))');

                marker.appendChild(path);
                defs.appendChild(marker);
            });

            svg.appendChild(defs);

            // Find all items with dependencies
            function getAllItems(node, items = [], phase = null) {
                if (node.phase !== undefined) phase = node.phase;
                if (node.items) {
                    node.items.forEach(item => items.push({ ...item, currentPhase: phase }));
                }
                if (node.children) {
                    node.children.forEach(child => getAllItems(child, items, phase));
                }
                return items;
            }

            const allItems = getAllItems(capexTree);

            // Helper to find item phase
            function findItemPhase(itemId) {
                const item = allItems.find(i => i.id === itemId);
                return item ? item.currentPhase : null;
            }

            // Draw lines for each dependency
            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    const targetEl = document.querySelector(`[data-item-id="${item.id}"]`);
                    if (!targetEl) return;

                    item.dependencies.forEach(depId => {
                        const sourceEl = document.querySelector(`[data-item-id="${depId}"]`);
                        if (!sourceEl) return;

                        // Get positions in tree's local coordinate space (not viewport)
                        // This accounts for the transform by using offsetLeft/Top instead of getBoundingClientRect
                        function getElementPosition(el) {
                            let x = 0;
                            let y = 0;
                            let current = el;

                            // Walk up to the tree root to get cumulative offset
                            while (current && current !== treeEl.parentElement) {
                                x += current.offsetLeft || 0;
                                y += current.offsetTop || 0;
                                current = current.offsetParent;
                            }

                            return { x, y, width: el.offsetWidth, height: el.offsetHeight };
                        }

                        const sourcePos = getElementPosition(sourceEl);
                        const targetPos = getElementPosition(targetEl);

                        // SVG offset constant (matches CSS top/left offset)
                        const SVG_OFFSET = 5000;

                        const x1 = sourcePos.x + sourcePos.width + SVG_OFFSET;
                        const y1 = sourcePos.y + sourcePos.height / 2 + SVG_OFFSET;
                        const x2 = targetPos.x + SVG_OFFSET;
                        const y2 = targetPos.y + targetPos.height / 2 + SVG_OFFSET;

                        // Determine if cross-phase dependency
                        const sourcePhase = findItemPhase(depId);
                        const targetPhase = item.currentPhase;
                        const isCrossPhase = sourcePhase !== targetPhase;

                        // Skip same-phase dependencies - only draw cross-phase arrows
                        if (!isCrossPhase) return;

                        const lineClass = 'cross-phase';

                        // Create curved path (quadratic bezier)
                        const midX = (x1 + x2) / 2;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const d = `M ${x1} ${y1} Q ${midX} ${y1}, ${midX} ${(y1 + y2) / 2} T ${x2} ${y2}`;

                        path.setAttribute('d', d);
                        path.setAttribute('class', `dependency-line ${lineClass}`);
                        path.setAttribute('marker-end', `url(#arrow-${lineClass})`);

                        // Add tooltip
                        const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                        title.textContent = `${depId} ‚Üí ${item.id}${isCrossPhase ? ' (cross-phase)' : ''}`;
                        path.appendChild(title);

                        svg.appendChild(path);
                    });
                }
            });

            // =================================================================
            // DRAW PARENT-CHILD CONNECTORS FOR TASKS (Symmetrical Grey Lines)
            // =================================================================
            // Find all subtasks and draw symmetrical connectors to their parent items
            function getAllSubtasksWithParent(node, subtasks = []) {
                if (node.items) {
                    node.items.forEach(item => {
                        if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                            // Collect parent with all its children for symmetrical layout
                            subtasks.push({
                                parent: item,
                                children: item.subItems
                            });

                            // Recursively handle nested tasks
                            item.subItems.forEach(subtask => {
                                if (subtask.subItems && Array.isArray(subtask.subItems) && subtask.subItems.length > 0) {
                                    subtasks.push({
                                        parent: subtask,
                                        children: subtask.subItems
                                    });
                                }
                            });
                        }
                    });
                }
                if (node.children) {
                    node.children.forEach(child => getAllSubtasksWithParent(child, subtasks));
                }
                return subtasks;
            }

            const allParentChildPairs = getAllSubtasksWithParent(capexTree);

            // Helper to get element position
            function getElementPosition(el) {
                let x = 0;
                let y = 0;
                let current = el;

                while (current && current !== treeEl.parentElement) {
                    x += current.offsetLeft || 0;
                    y += current.offsetTop || 0;
                    current = current.offsetParent;
                }

                return { x, y, width: el.offsetWidth, height: el.offsetHeight };
            }

            const SVG_OFFSET = 5000;

            allParentChildPairs.forEach(({ parent, children }) => {
                const parentEl = document.querySelector(`[data-item-id="${parent.id}"]`);
                if (!parentEl) return;

                const parentPos = getElementPosition(parentEl);

                // Draw symmetrical lines from parent to each child
                children.forEach(child => {
                    const childEl = document.querySelector(`[data-item-id="${child.id}"]`);
                    if (!childEl) return;

                    const childPos = getElementPosition(childEl);

                    // Start from bottom-center of parent
                    const x1 = parentPos.x + parentPos.width / 2 + SVG_OFFSET;
                    const y1 = parentPos.y + parentPos.height + SVG_OFFSET;

                    // End at top-center of child
                    const x2 = childPos.x + childPos.width / 2 + SVG_OFFSET;
                    const y2 = childPos.y + SVG_OFFSET;

                    // Create symmetrical line (no arrow head)
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', 'rgba(128, 128, 128, 0.4)');  // Grey
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('opacity', '0.6');

                    // Add tooltip
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = `${parent.name} ‚Üí ${child.name}`;
                    line.appendChild(title);

                    svg.appendChild(line);
                });
            });
        }


        // Info Panel
        function showInfo(node) {
            const panel = document.getElementById('info-panel');
            const titleElement = document.getElementById('info-title');

            // Enhanced title for subtasks - just the name, prominent
            if (node.type === 'subtask') {
                titleElement.innerHTML = `
                    <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); line-height: 1.3;">
                        ${node.name}
                    </div>
                `;
            } else {
                titleElement.textContent = `${node.icon} ${node.name}`;
            }

            const body = document.getElementById('info-body');

            // Build dependencies section
            let depsHtml = '';
            if (node.dependencies && node.dependencies.length > 0) {
                const depNames = node.dependencies.map(depId => {
                    // Find the dependency item to get its name
                    function findItemById(id, n = capexTree) {
                        if (n.id === id) return n;
                        if (n.items) {
                            const found = n.items.find(i => i.id === id);
                            if (found) return found;
                        }
                        if (n.children) {
                            for (let child of n.children) {
                                const found = findItemById(id, child);
                                if (found) return found;
                            }
                        }
                        return null;
                    }
                    const depItem = findItemById(depId);
                    return depItem ? `${depItem.icon} ${depItem.name}` : depId;
                }).join('<br>');

                depsHtml = `
                    <div class="info-section">
                        <h4>Dependencies</h4>
                        <p style="line-height: 1.8;">${depNames}</p>
                    </div>
                `;
            }

            // Build dependents section (items that depend on this one)
            let dependentsHtml = '';
            if (node.id) {
                function findDependents(nodeId, n = capexTree, dependents = []) {
                    if (n.items) {
                        n.items.forEach(item => {
                            if (item.dependencies && item.dependencies.includes(nodeId)) {
                                dependents.push(item);
                            }
                        });
                    }
                    if (n.children) {
                        n.children.forEach(child => findDependents(nodeId, child, dependents));
                    }
                    return dependents;
                }

                const dependents = findDependents(node.id);
                if (dependents.length > 0) {
                    const depList = dependents.map(d => `${d.icon} ${d.name}`).join('<br>');
                    dependentsHtml = `
                        <div class="info-section">
                            <h4>Required By</h4>
                            <p style="line-height: 1.8;">${depList}</p>
                        </div>
                    `;
                }
            }

            // Build PM Dashboard section for subtasks
            let pmDashboardHtml = '';
            if (node.type === 'subtask') {
                const statusColors = {
                    'To Do': { bg: 'rgba(156, 163, 175, 0.3)', color: '#9CA3AF' },
                    'In Progress': { bg: 'rgba(59, 130, 246, 0.3)', color: '#3B82F6' },
                    'Completed': { bg: 'rgba(16, 185, 129, 0.3)', color: '#10B981' },
                    'Blocked': { bg: 'rgba(239, 68, 68, 0.3)', color: '#EF4444' }
                };
                const statusStyle = statusColors[node.pmStatus] || statusColors['To Do'];

                const priorityEmojis = { 'Low': 'üü¢', 'Medium': 'üü°', 'High': 'üü†', 'Critical': 'üî¥' };
                const priorityEmoji = priorityEmojis[node.pmPriority] || '‚ö™';

                // Calculate days until/since due date
                let dueDateInfo = '';
                if (node.pmDueDate) {
                    const dueDate = new Date(node.pmDueDate);
                    const today = new Date();
                    const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                    if (diffDays < 0) {
                        dueDateInfo = `<span style="color: #EF4444; font-weight: 600;">‚ö†Ô∏è ${Math.abs(diffDays)} days overdue</span>`;
                    } else if (diffDays === 0) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">üìÖ Due today!</span>`;
                    } else if (diffDays <= 3) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">‚è∞ ${diffDays} days left</span>`;
                    } else {
                        dueDateInfo = `<span style="color: var(--text-secondary);">${diffDays} days left</span>`;
                    }
                }

                pmDashboardHtml = `
                    <!-- Status + Progress Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: ${statusStyle.bg}; border-radius: 10px; border: 2px solid ${statusStyle.color};">
                            <div style="font-size: 28px; font-weight: 700; color: ${statusStyle.color};">
                                ${node.pmStatus || 'To Do'}
                            </div>
                        </div>
                        <div style="flex: 1; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); border-radius: 10px; border: 2px solid rgba(0, 166, 125, 0.4); display: flex; flex-direction: column; justify-content: center;">
                            <div style="font-size: 36px; font-weight: 700; color: var(--treeplex-primary); line-height: 1;">${node.pmProgress || 0}%</div>
                            <div style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden; margin-top: 8px;">
                                <div style="height: 100%; width: ${node.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Owner + Priority Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; align-items: center; gap: 12px;">
                            <div style="width: 48px; height: 48px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: 700; color: white; flex-shrink: 0;">
                                ${node.pmAssignee ? node.pmAssignee.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2) : '?'}
                            </div>
                            <div style="font-size: 18px; font-weight: 600;">${node.pmAssignee || 'Unassigned'}</div>
                        </div>
                        <div style="width: 120px; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <div style="font-size: 40px; margin-bottom: 4px;">${priorityEmoji}</div>
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-secondary);">${node.pmPriority || 'Medium'}</div>
                        </div>
                    </div>

                    <!-- Timeline -->
                    <div style="padding: 16px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-around; margin-bottom: 12px;">
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">üìÖ</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmStartDate ? new Date(node.pmStartDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                            <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
                                <div style="height: 2px; flex: 1; background: linear-gradient(90deg, var(--treeplex-primary), transparent);"></div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">üéØ</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmDueDate ? new Date(node.pmDueDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                        </div>
                        ${dueDateInfo ? `<div style="text-align: center; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; font-size: 13px;">${dueDateInfo}</div>` : ''}
                    </div>

                    <!-- Notes -->
                    ${node.pmNotes ? `
                        <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; border-left: 4px solid var(--treeplex-primary); margin-bottom: 16px;">
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary);">${node.pmNotes}</div>
                        </div>
                    ` : ''}

                    <!-- Blocking Issue -->
                    ${node.pmBlockingIssue ? `
                        <div style="padding: 14px; background: rgba(239, 68, 68, 0.15); border-radius: 10px; border-left: 4px solid #EF4444; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">üöß</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #FCA5A5;">${node.pmBlockingIssue}</div>
                        </div>
                    ` : ''}

                    <!-- Next Steps -->
                    ${node.pmNextSteps ? `
                        <div style="padding: 14px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; border-left: 4px solid #3B82F6; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">‚û°Ô∏è</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #93C5FD;">${node.pmNextSteps}</div>
                        </div>
                    ` : ''}

                    <!-- Latest Updates -->
                    ${node.pmUpdates && node.pmUpdates.length > 0 ? `
                        <div style="max-height: 300px; overflow-y: auto;">
                            ${node.pmUpdates.map(update => `
                                <div style="margin-bottom: 10px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 6px;">
                                        üìÖ ${new Date(update.timestamp).toLocaleString('en-US', {month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'})}
                                    </div>
                                    <div style="font-size: 13px; line-height: 1.5; white-space: pre-wrap;">${update.text}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            }

            body.innerHTML = `
                ${pmDashboardHtml}
                <div class="info-section">
                    <h4>ID</h4>
                    <p><code style="background: var(--bg); padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 12px;">${node.id || 'N/A'}</code></p>
                </div>
                ${PATTERNS[currentPattern].fields?.cost ? `
                <div class="info-section">
                    <h4>Cost</h4>
                    <p class="value">${formatCost(node.cost || 0)}</p>
                </div>
                ` : ''}
                <div class="info-section">
                    <h4>Description</h4>
                    <p>${node.description || node.subtitle || 'N/A'}</p>
                </div>
                <div class="info-section">
                    <h4>Type</h4>
                    <p>${node.itemType || node.type || 'N/A'}</p>
                </div>
                ${node.alternateSource ? `
                    <div class="info-section">
                        <h4>Alternate Source</h4>
                        <p style="font-size: 14px; line-height: 1.6;">üì¶ ${node.alternateSource}</p>
                    </div>
                ` : ''}
                ${node.leadTime ? `
                    <div class="info-section">
                        <h4>Lead Time</h4>
                        <p style="font-size: 14px; line-height: 1.6;">‚è±Ô∏è ${node.leadTime}</p>
                    </div>
                ` : ''}
                ${node.notes ? `
                    <div class="info-section">
                        <h4>Context Notes</h4>
                        <p style="background: var(--bg); padding: 12px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary); font-size: 13px; line-height: 1.6; white-space: pre-wrap;">${node.notes}</p>
                    </div>
                ` : ''}
                ${depsHtml}
                ${dependentsHtml}
                ${node.type === 'phase' ? `
                    <div class="info-section">
                        <h4>Phase Total</h4>
                        <p class="value">${formatCost(calculatePhaseTotal(node))}</p>
                    </div>
                ` : ''}
                ${node.type === 'root' ? `
                    <div class="info-section">
                        <h4>Total Cost</h4>
                        <p class="value">${formatCost(calculateTotal(node))}</p>
                    </div>
                ` : ''}
            `;

            panel.classList.add('open');
            currentOpenItemId = node.id;
        }

        // Track which item's panel is currently open
        let currentOpenItemId = null;

        document.getElementById('close-info').addEventListener('click', () => {
            document.getElementById('info-panel').classList.remove('open');
            currentOpenItemId = null;
        });

        // Context Menu
        function showContextMenu(x, y) {
            const menu = document.getElementById('context-menu');
            const labels = getPatternLabels();

            // Build menu dynamically based on node type
            let menuHtml = '';

            if (activeNode.type === 'item') {
                // Item context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.item}</div>
                    <div class="context-item" id="ctx-add-subtask">‚ûï Add ${labels.subtask}</div>
                    <div class="context-item" id="ctx-delete">üóëÔ∏è Delete ${labels.item}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ AI Analysis</div>
                `;
            } else if (activeNode.type === 'subtask') {
                // Subtask context menu (can now have nested subtasks)
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.subtask}</div>
                    <div class="context-item" id="ctx-add-subtask">‚ûï Add Nested ${labels.subtask}</div>
                    <div class="context-item" id="ctx-delete">üóëÔ∏è Delete ${labels.subtask}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ AI Analysis</div>
                `;
            } else if (activeNode.type === 'phase') {
                // Phase context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.phase}</div>
                    <div class="context-item" id="ctx-create">‚ûï Add ${labels.item} to ${activeNode.name}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ AI Analysis</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">üíæ Download JSON</div>
                    <div class="context-item" id="ctx-upload">üìÇ Upload JSON</div>
                `;
            } else if (activeNode.type === 'root') {
                // Root context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.root}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-expand">üìÇ Expand All</div>
                    <div class="context-item" id="ctx-collapse">üìÅ Collapse All</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ ${labels.root} AI Analysis</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">üíæ Download JSON</div>
                    <div class="context-item" id="ctx-upload">üìÇ Upload JSON</div>
                `;
            }

            menu.innerHTML = menuHtml;
            menu.style.display = 'block';

            // Position menu first (to measure dimensions)
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Check if menu goes off screen and adjust position
            const menuRect = menu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            let finalX = x;
            let finalY = y;

            // Adjust horizontal position if menu goes off right edge
            if (menuRect.right > viewportWidth) {
                finalX = viewportWidth - menuRect.width - 10;
            }

            // Adjust vertical position if menu goes off bottom edge
            if (menuRect.bottom > viewportHeight) {
                finalY = viewportHeight - menuRect.height - 10;
            }

            // Ensure menu doesn't go off left edge
            if (finalX < 10) finalX = 10;

            // Ensure menu doesn't go off top edge
            if (finalY < 10) finalY = 10;

            menu.style.left = finalX + 'px';
            menu.style.top = finalY + 'px';

            // Re-attach event listeners
            attachContextMenuListeners();
        }

        function attachContextMenuListeners() {
            const viewBtn = document.getElementById('ctx-view');
            const editBtn = document.getElementById('ctx-edit');
            const createBtn = document.getElementById('ctx-create');
            const addSubtaskBtn = document.getElementById('ctx-add-subtask');
            const deleteBtn = document.getElementById('ctx-delete');
            const aiBtn = document.getElementById('ctx-ai');
            const downloadBtn = document.getElementById('ctx-download');
            const uploadBtn = document.getElementById('ctx-upload');
            const expandBtn = document.getElementById('ctx-expand');
            const collapseBtn = document.getElementById('ctx-collapse');

            if (viewBtn) viewBtn.onclick = handleViewDetails;
            if (editBtn) editBtn.onclick = handleEdit;
            if (createBtn) createBtn.onclick = handleCreate;
            if (addSubtaskBtn) addSubtaskBtn.onclick = handleAddSubtask;
            if (deleteBtn) deleteBtn.onclick = handleDelete;
            if (aiBtn) aiBtn.onclick = handleAI;
            if (downloadBtn) downloadBtn.onclick = handleDownload;
            if (uploadBtn) uploadBtn.onclick = handleUpload;
            if (expandBtn) expandBtn.onclick = handleExpandAll;
            if (collapseBtn) collapseBtn.onclick = handleCollapseAll;
        }

        document.addEventListener('click', () => {
            document.getElementById('context-menu').style.display = 'none';
        });

        // Context menu handlers
        function handleViewDetails() {
            if (activeNode) showInfo(activeNode);
        }

        // Smart Suggestion Engine with Contextual Intelligence
        function generateAISuggestion(fieldType, itemContext) {
            const itemType = itemContext.itemType || 'equipment';
            const phase = itemContext.id ? itemContext.id.split('-')[0] : 'p0';
            const phaseNames = { p0: 'Phase 0 (Pre-Seed)', p1: 'Phase 1 (Seed)', p2: 'Phase 2 (Build)' };
            const phaseName = phaseNames[phase] || 'Unknown Phase';
            const notes = itemContext.notes || '';

            // Get all existing items for contextual analysis
            function getAllProjectItems(node = capexTree, items = []) {
                if (node.items) items.push(...node.items);
                if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
                return items;
            }
            const existingItems = getAllProjectItems();

            // AI suggestion templates based on field type
            const suggestions = {
                name: {
                    land: ['Land Acquisition & Title', 'Site Purchase & Legal', 'Property Option Agreement', 'Land Rights & Easements'],
                    engineering: ['Engineering Design Services', 'Technical Specification Development', 'System Architecture Planning', 'Feasibility Study & Analysis'],
                    equipment: ['Equipment Procurement', 'Hardware Purchase & Installation', 'Capital Equipment Acquisition', 'Technology Infrastructure'],
                    infrastructure: ['Infrastructure Development', 'Site Preparation & Construction', 'Facility Build-Out', 'Utility Infrastructure'],
                    corporate: ['Corporate Administration', 'Business Operations Support', 'Management & Overhead', 'Professional Services'],
                    professional: ['Professional Services Engagement', 'Consulting & Advisory', 'Expert Services Retainer', 'Third-Party Assessment'],
                    contingency: ['Contingency Reserve', 'Risk Mitigation Fund', 'Budget Reserve Allocation', 'Unforeseen Expenses Buffer']
                },
                description: {
                    land: 'Secure land rights and complete legal due diligence including title verification, environmental assessments, and zoning compliance. Critical prerequisite for all site development activities.',
                    engineering: 'Comprehensive engineering design and technical specification development by qualified professionals. Includes peer review, regulatory compliance verification, and documentation for permitting.',
                    equipment: 'Procurement of capital equipment with extended lead times. Requires vendor evaluation, competitive bidding, and early commitment to secure production slots. Includes installation and commissioning.',
                    infrastructure: 'Site infrastructure development including construction, utility tie-ins, and facility preparation. Coordinate permits, weather dependencies, and contractor scheduling.',
                    corporate: 'Corporate administration, legal compliance, insurance, and operational overhead necessary to maintain business operations throughout project timeline.',
                    professional: 'Engagement of specialized consultants and professional services with relevant domain expertise. Deliverables include reports, recommendations, and strategic guidance.',
                    contingency: 'Reserve allocation to address unforeseen expenses, scope changes, and risk mitigation. Recommended range 3-10% of phase budget depending on complexity and uncertainty.'
                },
                cost: {
                    p0: [50000, 100000, 180000, 250000],
                    p1: [500000, 1000000, 1500000, 2000000],
                    p2: [25000000, 50000000, 100000000, 150000000]
                },
                icon: {
                    land: ['üèûÔ∏è', 'üìÑ', 'üó∫Ô∏è', 'üè°'],
                    engineering: ['üìê', 'üîß', '‚öôÔ∏è', 'üî¨'],
                    equipment: ['‚ö°', 'üîã', 'üîå', '‚öôÔ∏è'],
                    infrastructure: ['üè¢', 'üèóÔ∏è', 'üîó', 'üåê'],
                    corporate: ['üíº', 'üìä', 'üèõÔ∏è', 'üìã'],
                    professional: ['üìú', 'üëî', 'üéØ', 'üí°'],
                    contingency: ['üí∞', 'üõ°Ô∏è', '‚öñÔ∏è', 'üìà']
                },
                notes: {
                    land: 'Key considerations: location suitability, regulatory approvals required, environmental impact assessments, title clarity, zoning compliance, access to utilities and infrastructure.',
                    engineering: 'Key considerations: technical feasibility, compliance standards, peer review requirements, timeline for design iterations, regulatory permits needed, documentation standards.',
                    equipment: 'Key considerations: vendor lead times (typically 12-18 months), production capacity, competitive bidding process, installation requirements, commissioning timeline, warranty terms.',
                    infrastructure: 'Key considerations: construction permits, utility coordination, seasonal/weather impacts, contractor availability, site preparation requirements, inspection schedules.',
                    corporate: 'Key considerations: governance compliance, legal oversight, insurance coverage, operational continuity, stakeholder reporting, audit requirements, administrative capacity.',
                    professional: 'Key considerations: consultant qualifications, domain expertise verification, deliverable specifications, success criteria, timeline expectations, budget allocation.',
                    contingency: 'Key considerations: risk assessment, budget buffer percentage (3-10%), scope change provisions, unforeseen expense coverage, approval thresholds for contingency use.'
                },
                alternateSource: {
                    land: ['Local real estate firms', 'Regional land brokers', 'Municipal land auctions', 'Adjacent property owners'],
                    engineering: ['Alternative engineering consultancies', 'In-house engineering team', 'Offshore design firms', 'University research partnerships'],
                    equipment: ['Secondary OEM suppliers', 'Refurbished equipment dealers', 'International manufacturers', 'Lease-to-own providers'],
                    infrastructure: ['Regional contractors', 'Turnkey EPC firms', 'Modular construction vendors', 'Local construction cooperatives'],
                    corporate: ['Alternative service providers', 'Shared services consortium', 'Outsourced business services', 'In-house capability development'],
                    professional: ['Alternative consulting firms', 'Big 4 professional services', 'Boutique specialists', 'Industry veterans/freelancers'],
                    contingency: ['Self-insurance reserves', 'Alternative financing sources', 'Risk pooling arrangements', 'Performance bonds']
                },
                leadTime: {
                    p0: ['2-4 weeks', '30-45 days', '1-2 months', '6-8 weeks'],
                    p1: ['3-6 months', '4-8 months', '90-120 days', '6 months'],
                    p2: ['12-18 months', '18-24 months', '15-20 months', '2 years']
                }
            };

            // Generate suggestion based on field type
            if (fieldType === 'name') {
                const options = suggestions.name[itemType] || suggestions.name.equipment;
                let suggestion = options[Math.floor(Math.random() * options.length)];

                // If notes contain specific keywords, adjust suggestion
                if (notes) {
                    const notesLower = notes.toLowerCase();
                    if (notesLower.includes('turbine') || notesLower.includes('generator')) suggestion = itemType === 'equipment' ? 'Gas Turbine Generator Package' : suggestion;
                    if (notesLower.includes('solar') || notesLower.includes('pv')) suggestion = itemType === 'equipment' ? 'Solar PV Array Installation' : suggestion;
                    if (notesLower.includes('battery') || notesLower.includes('bess')) suggestion = itemType === 'equipment' ? 'Battery Energy Storage System' : suggestion;
                    if (notesLower.includes('pipeline') || notesLower.includes('gas line')) suggestion = itemType === 'engineering' ? 'Pipeline Engineering & Design' : suggestion;
                    if (notesLower.includes('permit') || notesLower.includes('regulatory')) suggestion = itemType === 'professional' ? 'Permitting & Regulatory Services' : suggestion;
                }

                return suggestion;
            } else if (fieldType === 'description') {
                let baseDescription = suggestions.description[itemType] || suggestions.description.equipment;

                // Enhance description with context from notes
                if (notes && notes.length > 20) {
                    baseDescription += ` Additional context: ${notes.substring(0, 150)}${notes.length > 150 ? '...' : ''}`;
                }

                return baseDescription;
            } else if (fieldType === 'cost') {
                // INTELLIGENT COST SUGGESTION: Analyze similar items in project
                const similarItems = existingItems.filter(item =>
                    item.itemType === itemType && item.cost > 0
                );

                let suggestedCost;

                if (similarItems.length > 0) {
                    // Use median cost of similar items for realistic suggestion
                    const costs = similarItems.map(i => i.cost).sort((a, b) => a - b);
                    const median = costs[Math.floor(costs.length / 2)];
                    suggestedCost = median;

                    // Add 10-20% variance to avoid exact duplicates
                    const variance = 0.9 + (Math.random() * 0.2); // 90% to 110%
                    suggestedCost = Math.round(suggestedCost * variance);
                } else {
                    // Fallback to phase-appropriate templates if no similar items exist
                    const phaseKey = phase || 'p1';
                    const costRanges = suggestions.cost[phaseKey] || suggestions.cost.p1;
                    suggestedCost = costRanges[Math.floor(Math.random() * costRanges.length)];
                }

                // Adjust based on context notes
                if (notes) {
                    const notesLower = notes.toLowerCase();
                    if (notesLower.includes('large scale') || notesLower.includes('major')) suggestedCost = Math.round(suggestedCost * 1.5);
                    if (notesLower.includes('small') || notesLower.includes('minimal')) suggestedCost = Math.round(suggestedCost * 0.6);
                    if (notesLower.includes('rush') || notesLower.includes('expedited')) suggestedCost = Math.round(suggestedCost * 1.2);
                }

                return suggestedCost;
            } else if (fieldType === 'icon') {
                const options = suggestions.icon[itemType] || suggestions.icon.equipment;
                return options[Math.floor(Math.random() * options.length)];
            } else if (fieldType === 'notes') {
                return suggestions.notes[itemType] || suggestions.notes.equipment;
            } else if (fieldType === 'alternateSource') {
                const options = suggestions.alternateSource[itemType] || suggestions.alternateSource.equipment;
                let suggestion = options[Math.floor(Math.random() * options.length)];

                // Enhance with context from notes
                if (notes) {
                    const notesLower = notes.toLowerCase();
                    if (notesLower.includes('siemens') || notesLower.includes('ge')) {
                        suggestion = itemType === 'equipment' ? 'Alternative: GE, Siemens Energy, MAN Energy Solutions' : suggestion;
                    }
                    if (notesLower.includes('local') || notesLower.includes('canadian')) {
                        suggestion = 'Canadian suppliers and regional vendors';
                    }
                }

                return suggestion;
            } else if (fieldType === 'leadTime') {
                const phaseKey = phase || 'p1';
                const leadTimeOptions = suggestions.leadTime[phaseKey] || suggestions.leadTime.p1;
                let suggestion = leadTimeOptions[Math.floor(Math.random() * leadTimeOptions.length)];

                // Adjust lead time based on notes keywords
                if (notes) {
                    const notesLower = notes.toLowerCase();
                    if (notesLower.includes('rush') || notesLower.includes('expedited') || notesLower.includes('urgent')) {
                        // Suggest shorter timeframe for urgent items
                        if (phase === 'p2') suggestion = '10-12 months (expedited)';
                        else if (phase === 'p1') suggestion = '2-3 months (expedited)';
                        else suggestion = '2-3 weeks (expedited)';
                    }
                    if (notesLower.includes('custom') || notesLower.includes('bespoke') || notesLower.includes('specialized')) {
                        // Suggest longer timeframe for custom items
                        if (phase === 'p2') suggestion = '24-30 months (custom build)';
                        else if (phase === 'p1') suggestion = '8-12 months (custom)';
                        else suggestion = '3-4 months (custom)';
                    }
                }

                return suggestion;
            }

            return '';
        }

        // Add AI suggestion capability to text fields
        function enableAISuggestionsOnField(fieldElement, fieldType, itemContext) {
            fieldElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Show smart suggestion context menu
                const menu = document.getElementById('context-menu');
                menu.innerHTML = `
                    <div class="context-item" id="ai-suggest-field">üí° Smart Suggest</div>
                    <div class="context-divider"></div>
                    <div class="context-item" style="font-size: 11px; color: var(--text-secondary); cursor: default; padding: 8px 14px;" onmouseover="this.style.background='transparent'">Contextual suggestions based on your project</div>
                `;
                menu.style.display = 'block';

                // Position menu
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';

                // Smart positioning to avoid going off screen
                const menuRect = menu.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                let finalX = e.pageX;
                let finalY = e.pageY;

                if (menuRect.right > viewportWidth) {
                    finalX = viewportWidth - menuRect.width - 10;
                }
                if (menuRect.bottom > viewportHeight) {
                    finalY = viewportHeight - menuRect.height - 10;
                }
                if (finalX < 10) finalX = 10;
                if (finalY < 10) finalY = 10;

                menu.style.left = finalX + 'px';
                menu.style.top = finalY + 'px';

                // Attach AI suggest handler
                const aiSuggestBtn = document.getElementById('ai-suggest-field');
                aiSuggestBtn.onclick = () => {
                    // Get current context including notes field value
                    const currentContext = { ...itemContext };
                    const notesField = document.getElementById('edit-notes');
                    if (notesField) {
                        currentContext.notes = notesField.value;
                    }

                    const suggestion = generateAISuggestion(fieldType, currentContext);
                    fieldElement.value = suggestion;

                    // Trigger input event for any listeners
                    fieldElement.dispatchEvent(new Event('input', { bubbles: true }));

                    // Visual feedback
                    fieldElement.style.transition = 'all 0.3s';
                    fieldElement.style.background = 'rgba(0, 166, 125, 0.15)';
                    setTimeout(() => {
                        fieldElement.style.background = 'var(--bg)';
                    }, 600);

                    menu.style.display = 'none';
                };
            });
        }

        // Helper function to generate dynamic field HTML based on pattern
        function generateFieldHTML(fieldKey, fieldConfig, node) {
            const value = node[fieldKey] || '';
            const fieldId = `edit-${fieldKey}`;

            let inputHTML = '';

            if (fieldConfig.type === 'select') {
                const options = fieldConfig.options.map(opt =>
                    `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`
                ).join('');
                inputHTML = `<select id="${fieldId}">${options}</select>`;
            } else if (fieldConfig.type === 'textarea') {
                inputHTML = `<textarea id="${fieldId}" placeholder="${fieldConfig.placeholder || ''}" style="min-height: 80px;">${value}</textarea>`;
            } else if (fieldConfig.type === 'number') {
                const min = fieldConfig.min !== undefined ? `min="${fieldConfig.min}"` : '';
                const max = fieldConfig.max !== undefined ? `max="${fieldConfig.max}"` : '';
                const step = fieldConfig.step !== undefined ? `step="${fieldConfig.step}"` : '';
                inputHTML = `<input type="number" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" ${min} ${max} ${step} />`;
            } else if (fieldConfig.type === 'date') {
                inputHTML = `<input type="date" id="${fieldId}" value="${value}" />`;
            } else {
                // default to text
                inputHTML = `<input type="text" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" />`;
            }

            return `
                <div class="form-group">
                    <label>${fieldConfig.label} <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                    ${inputHTML}
                    ${fieldConfig.helpText ? `<p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">${fieldConfig.helpText}</p>` : ''}
                </div>
            `;
        }

        function handleEdit() {
            if (!activeNode) return;

            // Simple name editing for root and phase nodes
            if (activeNode.type === 'root' || activeNode.type === 'phase') {
                const labels = getPatternLabels();
                const nodeType = activeNode.type === 'root' ? labels.root : labels.phase;
                const newName = prompt(`Enter new ${nodeType} name:`, activeNode.name);

                if (newName && newName !== activeNode.name) {
                    activeNode.name = newName;
                    render();
                }
                return;
            }

            // Full edit modal for items and subtasks
            if (activeNode.type === 'item' || activeNode.type === 'subtask') {
                const modal = document.getElementById('edit-modal');
                const body = document.getElementById('edit-modal-body');

                // Get all items from all phases for dependency selection
                function getAllItems(node, items = [], phaseName = '') {
                    if (node.phase !== undefined) phaseName = `Phase ${node.phase}`;
                    if (node.items) {
                        node.items.forEach(item => {
                            items.push({ ...item, phaseName });
                        });
                    }
                    if (node.children) {
                        node.children.forEach(child => getAllItems(child, items, phaseName));
                    }
                    return items;
                }

                const allItems = getAllItems(capexTree).filter(item => item.id !== activeNode.id);

                // Build dependency checkboxes
                const currentDeps = activeNode.dependencies || [];
                const depsHtml = allItems.map(item => {
                    const checked = currentDeps.includes(item.id) ? 'checked' : '';
                    return `
                        <label style="display: flex; align-items: center; gap: 10px; padding: 8px 10px; cursor: pointer; font-weight: normal; text-transform: none; letter-spacing: normal; border-radius: 6px; transition: background 0.2s; margin-bottom: 4px;" onmouseover="this.style.background='var(--card-bg-light)'" onmouseout="this.style.background='transparent'">
                            <input type="checkbox" class="dep-checkbox" value="${item.id}" ${checked} style="flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; accent-color: var(--treeplex-primary);" />
                            <span style="flex: 1; display: flex; align-items: center; gap: 8px; font-size: 14px;">
                                <span style="font-size: 18px; flex-shrink: 0;">${item.icon}</span>
                                <span style="flex: 1; color: var(--text-primary);">${item.name}</span>
                                <span style="color: var(--text-secondary); font-size: 11px; padding: 2px 8px; background: var(--card-bg); border-radius: 4px; border: 1px solid var(--border);">${item.phaseName}</span>
                            </span>
                        </label>
                    `;
                }).join('');

                // Get current pattern and its fields configuration
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                // Check if PM tracking should be shown
                const showTracking = fields.includeTracking &&
                                    fields.trackingFor &&
                                    fields.trackingFor.includes(activeNode.type);

                // Build field HTML
                let fieldsHTML = '';

                // 1. PM Tracking Section (conditional)
                if (showTracking) {
                    fieldsHTML += `
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--treeplex-primary);">üéØ Project Management</h3>
                        <div class="form-group">
                            <label>Status</label>
                            <select id="edit-pm-status">
                                <option value="To Do" ${activeNode.pmStatus === 'To Do' ? 'selected' : ''}>To Do</option>
                                <option value="In Progress" ${activeNode.pmStatus === 'In Progress' ? 'selected' : ''}>In Progress</option>
                                <option value="Completed" ${activeNode.pmStatus === 'Completed' ? 'selected' : ''}>Completed</option>
                                <option value="Blocked" ${activeNode.pmStatus === 'Blocked' ? 'selected' : ''}>Blocked</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Assignee / Owner</label>
                            <input type="text" id="edit-pm-assignee" value="${activeNode.pmAssignee || 'Unassigned'}" placeholder="Name or team..." />
                        </div>
                        <div class="form-group">
                            <label>Progress (%)</label>
                            <input type="number" id="edit-pm-progress" value="${activeNode.pmProgress || 0}" min="0" max="100" step="5" />
                        </div>
                        <div class="form-group">
                            <label>Priority</label>
                            <select id="edit-pm-priority">
                                <option value="Low" ${activeNode.pmPriority === 'Low' ? 'selected' : ''}>Low</option>
                                <option value="Medium" ${activeNode.pmPriority === 'Medium' ? 'selected' : ''}>Medium</option>
                                <option value="High" ${activeNode.pmPriority === 'High' ? 'selected' : ''}>High</option>
                                <option value="Critical" ${activeNode.pmPriority === 'Critical' ? 'selected' : ''}>Critical</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Start Date</label>
                            <input type="date" id="edit-pm-start-date" value="${activeNode.pmStartDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>Due Date</label>
                            <input type="date" id="edit-pm-due-date" value="${activeNode.pmDueDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>üöß Blocking Issue <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                            <textarea id="edit-pm-blocking-issue" style="min-height: 60px;" placeholder="What's preventing progress?">${activeNode.pmBlockingIssue || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>‚û°Ô∏è Next Steps <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                            <textarea id="edit-pm-next-steps" style="min-height: 80px;" placeholder="Specific actions needed...">${activeNode.pmNextSteps || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>PM Notes</label>
                            <textarea id="edit-pm-notes" style="min-height: 80px;" placeholder="Task-specific notes, blockers, action items...">${activeNode.pmNotes || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>üìù Latest Updates</label>
                            <div style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 8px; max-height: 200px; overflow-y: auto;">
                                ${activeNode.pmUpdates && activeNode.pmUpdates.length > 0 ? activeNode.pmUpdates.map((update, idx) => `
                                    <div style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border);">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">${new Date(update.timestamp).toLocaleString()}</div>
                                        <div style="font-size: 13px; line-height: 1.5;">${update.text}</div>
                                        <button onclick="window.deleteUpdate(${idx})" style="margin-top: 6px; padding: 2px 8px; font-size: 10px; background: rgba(239, 68, 68, 0.2); border: 1px solid #EF4444; border-radius: 4px; color: #EF4444; cursor: pointer;">Delete</button>
                                    </div>
                                `).join('') : '<p style="color: var(--text-secondary); font-size: 13px; text-align: center; padding: 20px;">No updates yet</p>'}
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <textarea id="edit-pm-new-update" style="flex: 1; min-height: 60px;" placeholder="Add a new update..."></textarea>
                                <button onclick="window.addUpdate()" style="padding: 8px 16px; background: var(--treeplex-primary); border: none; border-radius: 6px; color: white; font-weight: 600; cursor: pointer; white-space: nowrap;">Add Update</button>
                            </div>
                        </div>
                        <hr style="margin: 24px 0; border: none; border-top: 1px solid var(--border);" />
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--text-secondary);">Details</h3>
                    `;
                }

                // 2. Universal Fields (always shown)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Name <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <input type="text" id="edit-name" value="${activeNode.name || ''}" />
                    </div>
                    <div class="form-group">
                        <label>Description <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <textarea id="edit-description">${activeNode.description || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label>Icon <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <input type="text" id="edit-icon" value="${activeNode.icon || ''}" maxlength="2" />
                    </div>
                    <div class="form-group">
                        <label>Type</label>
                        <select id="edit-type">
                            ${PATTERNS[currentPattern].types.map(type =>
                                `<option value="${type.value}" ${activeNode.itemType === type.value ? 'selected' : ''}>${type.label}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;

                // 3. Pattern-Specific Custom Fields (dynamic)
                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }
                    const fieldConfig = fields[fieldKey];
                    fieldsHTML += generateFieldHTML(fieldKey, fieldConfig, activeNode);
                });

                // 4. Notes (universal)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Notes <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <textarea id="edit-notes" style="min-height: 100px;" placeholder="Additional notes...">${activeNode.notes || ''}</textarea>
                    </div>
                `;

                // 5. Dependencies (conditional)
                if (fields.includeDependencies) {
                    fieldsHTML += `
                        <div class="form-group">
                            <label>Dependencies</label>
                            <div style="max-height: 240px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 6px; background: var(--bg);">
                                ${depsHtml || '<p style="color: var(--text-secondary); font-size: 13px; margin: 0; padding: 10px; text-align: center;">No other items available</p>'}
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">‚úì Select prerequisite items that must be completed first</p>
                        </div>
                    `;
                }

                body.innerHTML = fieldsHTML;

                modal.style.display = 'flex';

                // Enable AI suggestions on text fields after modal is displayed
                setTimeout(() => {
                    // Universal fields
                    const nameField = document.getElementById('edit-name');
                    const descField = document.getElementById('edit-description');
                    const iconField = document.getElementById('edit-icon');
                    const notesField = document.getElementById('edit-notes');

                    if (nameField) enableAISuggestionsOnField(nameField, 'name', activeNode);
                    if (descField) enableAISuggestionsOnField(descField, 'description', activeNode);
                    if (iconField) enableAISuggestionsOnField(iconField, 'icon', activeNode);
                    if (notesField) enableAISuggestionsOnField(notesField, 'notes', activeNode);

                    // Pattern-specific fields (dynamic)
                    Object.keys(fields).forEach(fieldKey => {
                        if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                            return;
                        }
                        const fieldElement = document.getElementById(`edit-${fieldKey}`);
                        if (fieldElement) {
                            enableAISuggestionsOnField(fieldElement, fieldKey, activeNode);
                        }
                    });

                    // Enable AI suggestions for PM fields (conditional)
                    if (showTracking) {
                        const pmBlockingIssueField = document.getElementById('edit-pm-blocking-issue');
                        const pmNextStepsField = document.getElementById('edit-pm-next-steps');

                        if (pmBlockingIssueField) enableAISuggestionsOnField(pmBlockingIssueField, 'pmBlockingIssue', activeNode);
                        if (pmNextStepsField) enableAISuggestionsOnField(pmNextStepsField, 'pmNextSteps', activeNode);
                    }
                }, 50);
            }
        }

        function handleCreate() {
            if (activeNode && activeNode.type === 'phase') {
                // Create new item in this phase
                const labels = getPatternLabels();
                const defaultType = PATTERNS[currentPattern].types[0].value;
                const newItem = {
                    id: `p${activeNode.phase}-${Date.now()}`,
                    name: `New ${labels.item}`,
                    description: 'Enter description',
                    cost: 0,
                    icon: 'üì¶',
                    itemType: defaultType,
                    type: 'item',
                    dependencies: []
                };

                if (!activeNode.items) activeNode.items = [];
                activeNode.items.push(newItem);
                activeNode.expanded = true;
                render();
            }
        }

        function handleAddSubtask() {
            // Allow both items AND subtasks to have nested sub-tasks
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask')) {
                const labels = getPatternLabels();
                const isNestedSubtask = activeNode.type === 'subtask';
                const promptLabel = isNestedSubtask ? `nested ${labels.subtask}` : labels.subtask;

                // Prompt for sub-task name
                const subtaskName = prompt(`Enter ${promptLabel} name:`, `New ${isNestedSubtask ? 'Nested ' : ''}${labels.subtask}`);
                if (!subtaskName) return;

                // Get today's date in YYYY-MM-DD format
                const today = new Date().toISOString().split('T')[0];

                // Create new sub-task with PM fields
                const newSubtask = {
                    id: `${activeNode.id}-sub-${Date.now()}`,
                    name: subtaskName,
                    description: 'Task description',
                    cost: 0,
                    icon: 'üìã',
                    itemType: 'subtask',
                    type: 'subtask',
                    dependencies: [],
                    parentId: activeNode.id,
                    // Project Management fields
                    pmStatus: 'To Do',
                    pmAssignee: 'Unassigned',
                    pmStartDate: today,
                    pmDueDate: today,
                    pmProgress: 0,
                    pmPriority: 'Medium',
                    pmNotes: '',
                    pmBlockingIssue: '',
                    pmNextSteps: '',
                    pmUpdates: [],
                    // Initialize subItems for nested support
                    subItems: []
                };

                // Initialize subItems array if it doesn't exist
                if (!activeNode.subItems) activeNode.subItems = [];
                activeNode.subItems.push(newSubtask);

                // Mark parent as expanded to show sub-tasks
                activeNode.expanded = true;

                render();
                document.getElementById('context-menu').style.display = 'none';
            }
        }

        function handleDelete() {
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask')) {
                const itemType = activeNode.type === 'subtask' ? 'sub-task' : 'item';
                if (confirm(`Delete "${activeNode.name}" ${itemType}? This cannot be undone.`)) {
                    if (activeNode.type === 'subtask') {
                        // Remove subtask from its parent item
                        function removeSubtask(subtaskId, node = capexTree) {
                            if (node.items) {
                                for (let item of node.items) {
                                    if (item.subItems) {
                                        const index = item.subItems.findIndex(s => s.id === subtaskId);
                                        if (index !== -1) {
                                            item.subItems.splice(index, 1);
                                            return true;
                                        }
                                    }
                                }
                            }
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeSubtask(subtaskId, child)) return true;
                                }
                            }
                            return false;
                        }
                        removeSubtask(activeNode.id);
                    } else {
                        // Find and remove the item from its parent phase
                        function removeItem(itemId, node = capexTree) {
                            if (node.items) {
                                const index = node.items.findIndex(i => i.id === itemId);
                                if (index !== -1) {
                                    node.items.splice(index, 1);
                                    return true;
                                }
                            }
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeItem(itemId, child)) return true;
                                }
                            }
                            return false;
                        }
                        removeItem(activeNode.id);
                    }
                    render();
                }
            }
        }

        function handleDownload() {
            const jsonStr = JSON.stringify(capexTree, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;

            // Create unique timestamp: YYYY-MM-DD_HHMMSS
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const timestamp = `${year}-${month}-${day}_${hours}${minutes}${seconds}`;

            a.download = `treelisty-project-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function handleUpload() {
            document.getElementById('json-upload-input').click();
        }

        function handleExpandAll() {
            function expandAll(node) {
                if (node.children) {
                    node.expanded = true;
                    node.children.forEach(expandAll);
                }
            }
            expandAll(capexTree);
            render();
        }

        function handleCollapseAll() {
            function collapseAll(node) {
                if (node.children) {
                    node.expanded = false;
                    node.children.forEach(collapseAll);
                }
            }
            capexTree.children.forEach(collapseAll);
            render();
        }

        // Toggle subtasks for a specific item
        window.toggleSubtasks = function(itemId) {
            function findAndToggle(node) {
                if (node.items) {
                    const item = node.items.find(i => i.id === itemId);
                    if (item) {
                        item.expanded = !item.expanded;
                        render();
                        return true;
                    }
                }
                if (node.children) {
                    for (let child of node.children) {
                        if (findAndToggle(child)) return true;
                    }
                }
                return false;
            }
            findAndToggle(capexTree);
        };

        // Add update to current activeNode
        window.addUpdate = function() {
            if (!activeNode) return;
            const updateText = document.getElementById('edit-pm-new-update').value.trim();
            if (!updateText) {
                alert('Please enter an update message');
                return;
            }

            if (!activeNode.pmUpdates) activeNode.pmUpdates = [];
            activeNode.pmUpdates.unshift({
                timestamp: new Date().toISOString(),
                text: updateText
            });

            // Clear the input and re-render the modal
            document.getElementById('edit-pm-new-update').value = '';
            handleEdit(); // Re-render the edit modal to show the new update
        };

        // Delete update from current activeNode
        window.deleteUpdate = function(index) {
            if (!activeNode || !activeNode.pmUpdates) return;
            if (confirm('Delete this update?')) {
                activeNode.pmUpdates.splice(index, 1);
                handleEdit(); // Re-render the edit modal
            }
        };

        async function handleAI() {
            if (activeNode) {
                const modal = document.getElementById('modal');
                const modalBody = document.getElementById('modal-body');

                // Show loading state
                modalBody.innerHTML = `
                    <div style="padding: 40px; text-align: center;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">AI is analyzing ${activeNode.name}...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                `;
                modal.style.display = 'flex';

                try {
                    // Determine analysis type (subtask, item, or project)
                    let analysisType = 'item';
                    if (activeNode.type === 'root') {
                        analysisType = 'project';
                    } else if (activeNode.type === 'subtask') {
                        analysisType = 'subtask';
                    }

                    // Call real AI
                    const aiResponse = await generateAIAnalysis(activeNode, analysisType);

                    // Display AI response with markdown-like formatting
                    modalBody.innerHTML = `
                        <div style="padding: 20px; line-height: 1.8;">
                            <div style="white-space: pre-wrap; font-size: 14px; color: var(--text-primary);">${aiResponse}</div>
                            <div style="margin-top: 24px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ü§ñ Analysis powered by Claude Sonnet ‚Ä¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;

                } catch (error) {
                    // Show error
                    modalBody.innerHTML = `
                        <div style="padding: 30px; text-align: center;">
                            <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                            <h3 style="margin-bottom: 16px; color: var(--text-primary);">AI Analysis Failed</h3>
                            <p style="margin-bottom: 24px; color: var(--text-secondary); line-height: 1.6;">
                                ${error.message}
                            </p>
                            <p style="font-size: 12px; color: var(--text-secondary);">
                                If this problem persists, contact geej support.
                            </p>
                        </div>
                    `;
                }
            }
        }

        // Edit modal save/cancel handlers
        document.getElementById('edit-save').addEventListener('click', () => {
            if (activeNode) {
                // Save universal fields
                activeNode.name = document.getElementById('edit-name').value;
                activeNode.description = document.getElementById('edit-description').value;
                activeNode.icon = document.getElementById('edit-icon').value;
                activeNode.itemType = document.getElementById('edit-type').value;
                activeNode.notes = document.getElementById('edit-notes').value;

                // Save pattern-specific fields dynamically
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    const fieldElement = document.getElementById(`edit-${fieldKey}`);
                    if (fieldElement) {
                        const fieldConfig = fields[fieldKey];
                        if (fieldConfig.type === 'number') {
                            activeNode[fieldKey] = parseInt(fieldElement.value) || 0;
                        } else {
                            activeNode[fieldKey] = fieldElement.value;
                        }
                    }
                });

                // Collect selected dependencies from checkboxes (conditional)
                if (fields.includeDependencies) {
                    const depCheckboxes = document.querySelectorAll('.dep-checkbox');
                    const selectedDeps = [];
                    depCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedDeps.push(checkbox.value);
                        }
                    });
                    activeNode.dependencies = selectedDeps;
                }

                // Save PM fields for subtasks
                if (activeNode.type === 'subtask') {
                    const pmStatus = document.getElementById('edit-pm-status');
                    const pmAssignee = document.getElementById('edit-pm-assignee');
                    const pmStartDate = document.getElementById('edit-pm-start-date');
                    const pmDueDate = document.getElementById('edit-pm-due-date');
                    const pmProgress = document.getElementById('edit-pm-progress');
                    const pmPriority = document.getElementById('edit-pm-priority');
                    const pmNotes = document.getElementById('edit-pm-notes');
                    const pmBlockingIssue = document.getElementById('edit-pm-blocking-issue');
                    const pmNextSteps = document.getElementById('edit-pm-next-steps');

                    if (pmStatus) activeNode.pmStatus = pmStatus.value;
                    if (pmAssignee) activeNode.pmAssignee = pmAssignee.value;
                    if (pmStartDate) activeNode.pmStartDate = pmStartDate.value;
                    if (pmDueDate) activeNode.pmDueDate = pmDueDate.value;
                    if (pmProgress) activeNode.pmProgress = parseInt(pmProgress.value) || 0;
                    if (pmPriority) activeNode.pmPriority = pmPriority.value;
                    if (pmNotes) activeNode.pmNotes = pmNotes.value;
                    if (pmBlockingIssue) activeNode.pmBlockingIssue = pmBlockingIssue.value;
                    if (pmNextSteps) activeNode.pmNextSteps = pmNextSteps.value;
                    // pmUpdates are managed separately via window.addUpdate and window.deleteUpdate
                }

                document.getElementById('edit-modal').style.display = 'none';
                render();
            }
        });

        document.getElementById('edit-cancel').addEventListener('click', () => {
            document.getElementById('edit-modal').style.display = 'none';
        });

        // JSON upload handler
        document.getElementById('json-upload-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        // Validate basic structure
                        if (data.id && data.children) {
                            // Replace the tree data
                            Object.assign(capexTree, data);

                            // Restore pattern if saved
                            if (capexTree.pattern && capexTree.pattern.key) {
                                currentPattern = capexTree.pattern.key;
                                const patternSelect = document.getElementById('pattern-select');
                                if (patternSelect) {
                                    patternSelect.value = currentPattern;
                                }
                                if (currentPattern === 'custom' && capexTree.pattern.labels) {
                                    customPatternNames = capexTree.pattern.labels;
                                }
                            }

                            render();
                            alert('JSON loaded successfully!');
                        } else {
                            alert('Invalid JSON structure. Must have "id" and "children" properties.');
                        }
                    } catch (err) {
                        alert('Error parsing JSON: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
            // Reset input
            e.target.value = '';
        });

        // Controls
        document.getElementById('expand-btn').addEventListener('click', () => {
            function expandAll(node) {
                if (node.children) {
                    node.expanded = true;
                    node.children.forEach(expandAll);
                }
            }
            expandAll(capexTree);
            render();
        });

        document.getElementById('collapse-btn').addEventListener('click', () => {
            function collapseAll(node) {
                if (node.children) {
                    node.expanded = false;
                    node.children.forEach(collapseAll);
                }
            }
            capexTree.children.forEach(collapseAll);
            render();
        });

        // Save and Load JSON buttons in console
        document.getElementById('save-json-btn').addEventListener('click', handleDownload);
        document.getElementById('load-json-btn').addEventListener('click', handleUpload);

        // Share button - Generate shareable URL
        document.getElementById('share-btn').addEventListener('click', () => {
            const shareableURL = generateShareableURL();

            // Show modal with URL
            const modal = document.getElementById('share-modal');
            const urlInput = document.getElementById('share-url-input');
            urlInput.value = shareableURL;

            // Update stats
            const nodeCount = countAllNodes(capexTree);
            document.getElementById('share-node-count').textContent = nodeCount;
            document.getElementById('share-url-length').textContent = shareableURL.length;

            // Show warning if URL is very long (>2000 chars might have issues in some apps)
            const warning = document.getElementById('share-size-warning');
            if (shareableURL.length > 2000) {
                warning.style.display = 'block';
            } else {
                warning.style.display = 'none';
            }

            modal.style.display = 'flex';

            // Select the URL text for easy copying
            setTimeout(() => urlInput.select(), 100);
        });

        // Share modal - Copy button
        document.getElementById('copy-share-url').addEventListener('click', () => {
            const urlInput = document.getElementById('share-url-input');
            urlInput.select();
            document.execCommand('copy');

            // Change button text temporarily
            const btn = document.getElementById('copy-share-url');
            const originalText = btn.textContent;
            btn.textContent = '‚úÖ Copied!';
            btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';

            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
            }, 2000);
        });

        // Share modal - Open in new tab button
        document.getElementById('open-share-url').addEventListener('click', () => {
            const url = document.getElementById('share-url-input').value;
            window.open(url, '_blank');
        });

        // Share modal - Close button
        document.getElementById('share-close').addEventListener('click', () => {
            document.getElementById('share-modal').style.display = 'none';
        });

        // Generate shareable URL with compressed data
        function generateShareableURL() {
            const jsonData = JSON.stringify(capexTree);
            const compressed = LZString.compressToEncodedURIComponent(jsonData);
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?p=${compressed}`;
        }

        // Count all nodes in tree (for stats)
        function countAllNodes(node) {
            let count = 1; // Count this node
            if (node.children) {
                node.children.forEach(child => {
                    if (child.items) {
                        count += child.items.length;
                        child.items.forEach(item => {
                            if (item.subtasks) {
                                count += item.subtasks.length;
                            }
                        });
                    } else {
                        count += countAllNodes(child);
                    }
                });
            }
            return count;
        }

        // =============================================================================
        // AI WIZARD SYSTEM
        // =============================================================================

        // Wizard state
        let wizardState = {
            active: false,
            conversation: [],
            questionsAsked: 0,
            fieldsCompleted: new Set(),
            totalFields: 0,
            awaitingResponse: false,
            workingTree: null,
            patternKey: null
        };

        // Start wizard
        document.getElementById('wizard-btn').addEventListener('click', startWizard);

        async function startWizard() {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            // Reset wizard state
            wizardState = {
                active: true,
                conversation: [],
                questionsAsked: 0,
                fieldsCompleted: new Set(),
                totalFields: 0,
                awaitingResponse: false,
                workingTree: JSON.parse(JSON.stringify(capexTree)), // Deep copy
                patternKey: currentPattern
            };

            // Get pattern info
            const pattern = PATTERNS[currentPattern];
            const patternFields = pattern.fields || {};
            wizardState.totalFields = Object.keys(patternFields).length;

            // Update modal title
            document.getElementById('wizard-title').textContent = `ü™Ñ AI Wizard - Building Your ${pattern.name}`;
            document.getElementById('wizard-fields-total').textContent = wizardState.totalFields;

            // Clear chat and preview
            document.getElementById('wizard-chat-history').innerHTML = '';
            updateWizardPreview();

            // Show modal
            document.getElementById('wizard-modal').style.display = 'flex';

            // Start conversation
            await wizardAsk();
        }

        // Add message to chat
        function addWizardMessage(role, content) {
            const chatHistory = document.getElementById('wizard-chat-history');
            const messageDiv = document.createElement('div');

            if (role === 'ai') {
                messageDiv.style.cssText = `
                    background: linear-gradient(135deg, #a855f7, #ec4899);
                    color: white;
                    padding: 15px;
                    border-radius: 12px;
                    border-bottom-left-radius: 4px;
                    max-width: 80%;
                    align-self: flex-start;
                    line-height: 1.6;
                `;
                messageDiv.textContent = 'üß† ' + content;
            } else {
                messageDiv.style.cssText = `
                    background: var(--treeplex-primary);
                    color: white;
                    padding: 15px;
                    border-radius: 12px;
                    border-bottom-right-radius: 4px;
                    max-width: 80%;
                    align-self: flex-end;
                    line-height: 1.6;
                `;
                messageDiv.textContent = 'üë§ ' + content;
            }

            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        // Ask AI for next question
        async function wizardAsk() {
            if (wizardState.awaitingResponse) return;
            wizardState.awaitingResponse = true;

            // Disable input while waiting
            document.getElementById('wizard-user-input').disabled = true;
            document.getElementById('wizard-send').disabled = true;

            try {
                const systemPrompt = buildWizardSystemPrompt();
                const conversationContext = wizardState.conversation.map(msg =>
                    `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`
                ).join('\n\n');

                const userPrompt = conversationContext ||
                    "Start the wizard conversation. Ask the user what they want to build.";

                console.log('ü™Ñ Wizard asking AI...');
                console.log('ü™Ñ System prompt length:', systemPrompt.length);
                console.log('ü™Ñ User prompt length:', userPrompt.length);

                const response = await callClaudeAPI(userPrompt, systemPrompt, 3000);

                console.log('ü™Ñ AI Raw Response:', response);

                // Try to extract JSON if AI added text before/after
                let jsonStr = response.trim();

                // If response has markdown code blocks, extract JSON from them
                if (jsonStr.includes('```json')) {
                    const match = jsonStr.match(/```json\s*\n([\s\S]*?)\n```/);
                    if (match) {
                        jsonStr = match[1];
                        console.log('ü™Ñ Extracted from ```json block');
                    }
                } else if (jsonStr.includes('```')) {
                    const match = jsonStr.match(/```\s*\n([\s\S]*?)\n```/);
                    if (match) {
                        jsonStr = match[1];
                        console.log('ü™Ñ Extracted from ``` block');
                    }
                }

                // Find the FIRST complete JSON object using proper brace matching
                // This handles cases where AI adds text before/after the JSON
                const firstBrace = jsonStr.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response. AI may not be following instructions.');
                }

                if (firstBrace > 0) {
                    console.log('ü™Ñ Skipping text before JSON:', jsonStr.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonStr.length; i++) {
                    const char = jsonStr[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Incomplete JSON object in AI response (no closing brace found).');
                }

                jsonStr = jsonStr.substring(firstBrace, endPos);

                if (endPos < response.length) {
                    console.log('ü™Ñ Skipping text after JSON:', response.substring(endPos, endPos + 50) + '...');
                }

                console.log('ü™Ñ Extracted JSON (first 200 chars):', jsonStr.substring(0, 200) + '...');
                console.log('ü™Ñ JSON length:', jsonStr.length);

                // Sanitize JSON: Fix control characters in string values
                // This handles cases where AI generates unescaped newlines/tabs in strings
                let parsed;
                try {
                    // First, try parsing as-is
                    parsed = JSON.parse(jsonStr);
                } catch (firstError) {
                    console.warn('ü™Ñ JSON parse failed, attempting sanitization...', firstError.message);

                    // Sanitize by escaping control characters within string values
                    // Strategy: Replace literal newlines/tabs/etc with escaped versions
                    // but only within quoted string values (not in JSON structure)

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonStr.length; i++) {
                        const char = jsonStr[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                // Other control characters - escape as unicode
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonStr = sanitized;
                    console.log('ü™Ñ Sanitized JSON:', jsonStr.substring(0, 200) + '...');

                    // Try parsing again after sanitization
                    parsed = JSON.parse(jsonStr);
                }

                // Validate required fields
                if (!parsed.message) {
                    throw new Error('AI response missing "message" field');
                }

                // Add AI message to conversation history
                wizardState.conversation.push({role: 'assistant', content: parsed.message});
                addWizardMessage('ai', parsed.message);

                // Update tree if provided
                if (parsed.treeUpdate) {
                    console.log('ü™Ñ Applying tree update:', parsed.treeUpdate);
                    mergeTreeUpdate(parsed.treeUpdate);
                    updateWizardPreview();
                }

                // Update progress
                if (parsed.fieldsUpdated && Array.isArray(parsed.fieldsUpdated)) {
                    parsed.fieldsUpdated.forEach(field => wizardState.fieldsCompleted.add(field));
                    document.getElementById('wizard-fields-complete').textContent = wizardState.fieldsCompleted.size;
                }

                // Update progress bar (from AI's progress field 0.0 to 1.0)
                if (parsed.progress !== undefined) {
                    const percentComplete = Math.round(parsed.progress * 100);
                    document.getElementById('wizard-progress-percent').textContent = `${percentComplete}%`;
                    document.getElementById('wizard-progress-bar').style.width = `${percentComplete}%`;
                }

                // Check if done
                if (parsed.done) {
                    document.getElementById('wizard-completion').style.display = 'block';
                    document.getElementById('wizard-progress-bar').style.width = '100%';
                    document.getElementById('wizard-progress-percent').textContent = '100%';
                }

            } catch (error) {
                console.error('ü™Ñ Wizard error details:', {
                    error: error.message,
                    stack: error.stack,
                    conversation: wizardState.conversation
                });

                // Show error message in chat
                const errorMsg = error.message || 'Unknown error occurred';
                addWizardMessage('ai', `I'm having trouble: ${errorMsg}\n\nPlease check:\n1. Is your API key configured? (Settings ‚Üí API Key)\n2. Try refreshing the page\n3. Check browser console for details (F12)`);
            }

            // Re-enable input
            document.getElementById('wizard-user-input').disabled = false;
            document.getElementById('wizard-send').disabled = false;
            document.getElementById('wizard-user-input').focus();
            wizardState.awaitingResponse = false;
        }

        // User sends message
        document.getElementById('wizard-send').addEventListener('click', async () => {
            const input = document.getElementById('wizard-user-input');
            const message = input.value.trim();

            if (!message || wizardState.awaitingResponse) return;

            // Add to conversation
            wizardState.conversation.push({role: 'user', content: message});
            addWizardMessage('user', message);
            wizardState.questionsAsked++;
            document.getElementById('wizard-question-count').textContent = wizardState.questionsAsked;

            // Clear input
            input.value = '';

            // Get AI response
            await wizardAsk();
        });

        // Build system prompt for wizard
        function buildWizardSystemPrompt() {
            const pattern = PATTERNS[wizardState.patternKey];
            const levels = pattern.levels;
            const fields = pattern.fields || {};

            // Build a summary of current tree (not full JSON to save tokens)
            const treeSummary = wizardState.workingTree.name || 'Empty';
            const phaseCount = (wizardState.workingTree.children || []).length;
            const itemCount = (wizardState.workingTree.children || []).reduce((acc, phase) =>
                acc + (phase.items || []).length, 0);

            return `‚ö†Ô∏è CRITICAL OUTPUT FORMAT: You MUST return ONLY a valid JSON object. NO text before the opening {. NO text after the closing }. NO explanations. NO commentary. JUST JSON.

You are an EXPERT INFORMATION EXTRACTION WIZARD building a complete ${pattern.name} project. Extract NECESSARY and SUFFICIENT data in MINIMUM questions.

CURRENT STATE:
- Pattern: ${pattern.name}
- Structure: ${levels.root} ‚Üí ${levels.phase} ‚Üí ${levels.item} ‚Üí ${levels.subtask}
- Fields: ${Object.keys(fields).join(', ') || 'none'}
- Completed Fields: ${Array.from(wizardState.fieldsCompleted).join(', ') || 'none'}
- Tree: ${treeSummary} (${phaseCount} phases, ${itemCount} items)

üéØ CORE MISSION: Extract 100% of required information in ‚â§5 strategic questions

üìä STRATEGIC QUESTIONING FRAMEWORK:

üéØ QUESTIONING ORDER (CRITICAL - Follow this sequence):

**TURN 1 - UNDERSTAND THE GOAL**
First question MUST clarify: "What is this prompt trying to ACHIEVE? What's the exact goal?"
- Example: "What specific problem does this prompt solve?"
- Example: "What output/result should this prompt produce?"
- DO NOT ask about safety, edge cases, or technical details yet
- DO NOT build the tree until you understand the GOAL

**TURN 2 - BUILD MAIN STRUCTURE**
After understanding the goal, propose the main phases/structure:
- "Based on your goal of [X], I'm thinking you need phases: [A, B, C]. Does that cover the main workflow?"
- Build 60-70% of the tree based on the goal
- Ask ONE clarifying question about structure

**TURN 3 - FILL CRITICAL DETAILS**
Add items and subtasks to each phase:
- "I've added [N] items across [M] phases. The biggest gap I see is [X]. Should I add that?"
- Build to 85-90% complete
- Focus on what's MISSING, not refinements

**TURN 4 - VALIDATE & REFINE**
Present near-complete tree and ask about completeness:
- "Does this capture the full workflow for [goal]? Or am I missing critical steps?"
- Now is when you can ask about edge cases, dependencies, special scenarios
- Build to 95%+ complete

**TURN 5 - CLOSE**
Final validation:
- "This looks complete for [goal]. Should I mark it done, or do you want to add/change anything?"
- Set done=true if approved

üö´ PRIORITY ORDER (What to ask when):

1. **THE GOAL** (Turn 1) - "What is this prompt trying to achieve exactly?"
2. **MAIN STRUCTURE** (Turn 2) - "What are the main phases/stages to achieve [goal]?"
3. **KEY ITEMS** (Turn 3) - "What are the critical items in each phase?"
4. **COMPLETENESS** (Turn 4) - "Am I missing any critical steps?"
5. **EDGE CASES/REFINEMENTS** (Turn 4) - "Any special scenarios or dependencies?"
6. **VALIDATION** (Turn 5) - "Does this fully capture everything?"

‚ùå NEVER ask about these BEFORE understanding the goal:
- Safety considerations
- Model parameters (temperature, tokens)
- Edge cases
- Technical implementation details

‚ö° EFFICIENCY TARGETS (UPDATED):
- Turn 1: Ask about GOAL. Build NOTHING until you understand the purpose.
- Turn 2: Build 60-70% of tree based on goal + ask about structure
- Turn 3: Fill to 85-90% + ask about biggest gaps
- Turn 4: Fill to 95%+ + validate completeness
- Turn 5: Set done=true if approved

üîç INFORMATION EXTRACTION TACTICS:
1. **EMBEDDED CONFIRMATION**: "I've added X, Y, Z as defaults. What am I missing?" (validates + extracts gaps)
2. **CONSTRAINT TESTING**: "I see this needs A. Does it also need B or is A sufficient?" (tests boundaries)
3. **DEPENDENCY PROBING**: "X blocks Y. Anything else blocked by X?" (maps critical paths)
4. **COMPLETENESS CHECK**: "I have N items for phase P. Too many/few/just right?" (validates scope)

üìã NECESSARY & SUFFICIENT DATA:
ALWAYS include in treeUpdate:
- Phases (3-6 typical)
- Items per phase (2-5 typical)
- Subtasks for complex items (2-5 steps)
- Dependency info in descriptions (e.g., "After Phase 1 completes...")
- Pattern-specific fields (infer from conversation)

NEVER ask about:
- Formatting preferences
- Nice-to-have details that can be added later
- Information already inferrable from context

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ö†Ô∏è RESPONSE FORMAT - MANDATORY: Return ONLY the JSON below ‚ö†Ô∏è
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

DO NOT write ANY text before or after the JSON.
Your ENTIRE response must be ONLY this JSON object:
{
  "message": "I've built [X phases, Y items]. [State what you added]. The only gap I see is [specific gap]. [Ask ONE strategic follow-up question that maximizes information gain]",
  "treeUpdate": {
    "name": "Project Name",
    "description": "Brief description",
    "children": [
      {
        "name": "Phase 1",
        "subtitle": "Phase subtitle",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Item name",
            "description": "Item description (include dependency notes like 'Requires X to complete first' if order matters)",
            "itemType": "type",
            "subtasks": [
              {"name": "Step 1", "description": "Detail"},
              {"name": "Step 2", "description": "Detail"}
            ]
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["field1", "field2"],
  "progress": 0.7,
  "done": false
}

üéØ CRITICAL RULES:
- Return ONLY JSON, no text before/after
- Turn 1: Build MINIMAL tree (just project name), ask about GOAL
- Turn 2+: Include treeUpdate with 2-4+ new items per turn
- INFER AGGRESSIVELY: Add details based on context, let user correct
- EVERY message must end with ONE strategic follow-up question (unless done=true)
- Follow the QUESTIONING ORDER above (Goal ‚Üí Structure ‚Üí Details ‚Üí Validation)
- Track progress field accurately (0.0 ‚Üí 1.0)
- Set done=true when tree is complete (typically turn 5)

üöÄ FIRST RESPONSE INSTRUCTION:
When user first describes what they want to build:
1. Create minimal tree with just project name and empty description
2. Set progress to 0.1
3. Ask: "What is the exact GOAL of this prompt? What specific output/result should it produce?"

DO NOT build phases, items, or subtasks in Turn 1. Wait to understand the goal first.`;
        }

        // Merge tree update into working tree
        function mergeTreeUpdate(update) {
            if (update.name) wizardState.workingTree.name = update.name;
            if (update.description) wizardState.workingTree.description = update.description;
            if (update.children) {
                // For simplicity, replace children (in production, would do smart merge)
                wizardState.workingTree.children = update.children.map((phase, idx) => ({
                    id: `phase-${idx}`,
                    type: 'phase',
                    phase: idx,
                    name: phase.name || `Phase ${idx}`,
                    subtitle: phase.subtitle || '',
                    icon: 'üìã',
                    expanded: true,
                    items: (phase.items || []).map((item, itemIdx) => ({
                        id: `item-${idx}-${itemIdx}`,
                        type: 'item',
                        name: item.name,
                        description: item.description || '',
                        itemType: item.itemType || 'default',
                        icon: 'üìÑ',
                        expanded: false,
                        ...item, // Include all other fields from AI
                        subtasks: (item.subtasks || []).map((subtask, subIdx) => ({
                            id: `subtask-${idx}-${itemIdx}-${subIdx}`,
                            name: subtask.name,
                            description: subtask.description || '',
                            ...subtask
                        }))
                    }))
                }));
            }
        }

        // Update tree preview
        function updateWizardPreview() {
            const preview = document.getElementById('wizard-tree-preview');
            const tree = wizardState.workingTree;

            let html = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 10px; color: var(--treeplex-primary); border-bottom: 2px solid var(--treeplex-primary); padding-bottom: 8px;">
                ${tree.icon || 'üå≥'} ${tree.name || 'Untitled Project'}
            </div>`;

            if (tree.description) {
                html += `<div style="color: var(--text-secondary); margin-bottom: 20px; font-size: 13px; font-style: italic;">
                    ${tree.description}
                </div>`;
            }

            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    // Phase header with background
                    html += `<div style="margin-bottom: 20px; border-left: 3px solid var(--treeplex-primary); padding-left: 12px;">
                        <div style="font-weight: 600; font-size: 14px; color: var(--treeplex-primary); margin-bottom: 8px;">
                            ${phase.icon || 'üìã'} ${phase.name}
                            ${phase.subtitle ? `<div style="color: var(--text-secondary); font-weight: 400; font-size: 12px; margin-top: 2px;">${phase.subtitle}</div>` : ''}
                        </div>`;

                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            // Item
                            html += `<div style="margin-left: 15px; margin-bottom: 10px; padding: 8px; background: var(--card-bg-light); border-radius: 6px;">
                                <div style="color: var(--text-primary); font-weight: 500; font-size: 13px;">
                                    ${item.icon || 'üìÑ'} ${item.name}
                                </div>`;

                            // Item description
                            if (item.description) {
                                html += `<div style="color: var(--text-secondary); font-size: 11px; margin-top: 4px; margin-left: 20px;">
                                    ${item.description}
                                </div>`;
                            }

                            // Dependencies (if present - for backward compatibility)
                            if (item.dependencies) {
                                // Handle both array and string formats
                                const depText = Array.isArray(item.dependencies)
                                    ? item.dependencies.join(', ')
                                    : item.dependencies;
                                if (depText && depText.length > 0) {
                                    html += `<div style="color: #f59e0b; font-size: 11px; margin-top: 4px; margin-left: 20px;">
                                        ‚ö†Ô∏è Depends on: ${depText}
                                    </div>`;
                                }
                            }

                            // Subtasks
                            if (item.subtasks && item.subtasks.length > 0) {
                                html += `<div style="margin-left: 20px; margin-top: 6px;">`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    html += `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 3px;">
                                        ‚ñ∏ ${subtask.name}${subtask.description ? ': ' + subtask.description : ''}
                                    </div>`;
                                });
                                html += `</div>`;
                            }

                            html += `</div>`; // End item
                        });
                    }

                    html += `</div>`; // End phase
                });
            } else {
                html += `<div style="color: var(--text-secondary); text-align: center; margin-top: 40px; padding: 40px 20px; border: 2px dashed var(--border); border-radius: 8px;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üå±</div>
                    <div>Waiting for conversation to start building the tree...</div>
                </div>`;
            }

            preview.innerHTML = html;
        }

        // Finish wizard
        document.getElementById('wizard-done').addEventListener('click', () => {
            // Apply working tree to main tree
            capexTree = wizardState.workingTree;
            currentPattern = wizardState.patternKey;

            // Close modal
            document.getElementById('wizard-modal').style.display = 'none';

            // Render updated tree
            render();

            console.log('ü™Ñ Wizard complete! Tree applied.');
        });

        // Cancel wizard
        document.getElementById('wizard-cancel').addEventListener('click', () => {
            if (confirm('Are you sure? Your progress will be lost.')) {
                document.getElementById('wizard-modal').style.display = 'none';
            }
        });

        // =============================================================================
        // GENERATE PROMPT SYSTEM
        // =============================================================================

        // Generate Prompt button
        document.getElementById('generate-prompt-btn').addEventListener('click', () => {
            const promptText = generatePromptFromTree();
            document.getElementById('generated-prompt-text').value = promptText;
            document.getElementById('generate-prompt-modal').style.display = 'flex';
        });

        // Close prompt modal
        document.getElementById('close-prompt-modal').addEventListener('click', () => {
            document.getElementById('generate-prompt-modal').style.display = 'none';
        });

        // Copy prompt to clipboard
        document.getElementById('copy-prompt-btn').addEventListener('click', async () => {
            const textArea = document.getElementById('generated-prompt-text');
            try {
                await navigator.clipboard.writeText(textArea.value);
                const successMsg = document.getElementById('copy-success-message');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                textArea.select();
                document.execCommand('copy');
                const successMsg = document.getElementById('copy-success-message');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            }
        });

        // Generate prompt from tree structure
        function generatePromptFromTree() {
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;
            const tree = capexTree;

            let prompt = '';

            // Header based on pattern
            if (currentPattern === 'prompting') {
                prompt += generateAIPromptDesignPrompt(tree, pattern);
            } else {
                prompt += generateGenericPrompt(tree, pattern);
            }

            return prompt;
        }

        // Generate AI Prompt Design specific format
        function generateAIPromptDesignPrompt(tree, pattern) {
            let prompt = `# ${tree.icon || 'üß†'} ${tree.name || 'AI Prompt'}\n\n`;

            if (tree.description) {
                prompt += `${tree.description}\n\n`;
            }

            prompt += `---\n\n`;

            // Add system instructions
            prompt += `You are an expert AI assistant. Follow this structured workflow:\n\n`;

            // Process each stage (phase)
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    prompt += `## Stage ${phaseIdx + 1}: ${phase.name}\n`;
                    if (phase.subtitle) {
                        prompt += `*${phase.subtitle}*\n`;
                    }
                    prompt += `\n`;

                    // Add modules (items)
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            prompt += `### ${itemIdx + 1}. ${item.name}\n`;

                            if (item.description) {
                                prompt += `${item.description}\n`;
                            }

                            // Add pattern-specific fields
                            if (item.useCase) prompt += `- **Use Case**: ${item.useCase}\n`;
                            if (item.modelTarget) prompt += `- **Target Model**: ${item.modelTarget}\n`;
                            if (item.temperature !== undefined) prompt += `- **Temperature**: ${item.temperature}\n`;
                            if (item.maxTokens) prompt += `- **Max Tokens**: ${item.maxTokens}\n`;
                            if (item.inputs) prompt += `- **Inputs**: ${item.inputs}\n`;
                            if (item.outputs) prompt += `- **Expected Output**: ${item.outputs}\n`;

                            // Add steps (subtasks)
                            if (item.subtasks && item.subtasks.length > 0) {
                                prompt += `\nSteps:\n`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    prompt += `${subIdx + 1}. ${subtask.name}`;
                                    if (subtask.description) {
                                        prompt += `: ${subtask.description}`;
                                    }
                                    prompt += `\n`;
                                });
                            }

                            prompt += `\n`;
                        });
                    }

                    prompt += `\n`;
                });
            }

            // Footer
            prompt += `---\n\n`;
            prompt += `Provide your response following this structured format, ensuring each stage is completed thoroughly.\n`;

            return prompt;
        }

        // Generate generic prompt format
        function generateGenericPrompt(tree, pattern) {
            let prompt = `# ${tree.icon || 'üìã'} ${tree.name || 'Project'}\n\n`;

            if (tree.description) {
                prompt += `${tree.description}\n\n`;
            }

            prompt += `---\n\n`;

            // Introduction based on pattern
            const patternIntros = {
                'sales': `You are a sales analyst. Follow this structured sales pipeline analysis:`,
                'thesis': `You are an academic advisor. Follow this thesis structure:`,
                'roadmap': `You are a product manager. Follow this product roadmap:`,
                'book': `You are a writing coach. Follow this book structure:`,
                'event': `You are an event planner. Follow this event plan:`,
                'fitness': `You are a fitness coach. Follow this training program:`,
                'strategy': `You are a business strategist. Follow this strategic plan:`,
                'course': `You are an educator. Follow this course structure:`,
                'film': `You are a film director. Follow this production plan:`,
                'philosophy': `You are a philosophy scholar. Follow this philosophical argument:`,
                'familytree': `You are a genealogist. Follow this family tree structure:`,
                'generic': `Follow this structured workflow:`
            };

            prompt += `${patternIntros[currentPattern] || patternIntros['generic']}\n\n`;

            // Process each phase
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    prompt += `## ${pattern.levels.phase} ${phaseIdx + 1}: ${phase.name}\n`;
                    if (phase.subtitle) {
                        prompt += `*${phase.subtitle}*\n`;
                    }
                    prompt += `\n`;

                    // Add items
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            prompt += `### ${itemIdx + 1}. ${item.name}\n`;

                            if (item.description) {
                                prompt += `${item.description}\n`;
                            }

                            // Add relevant fields based on pattern
                            if (item.dealValue) prompt += `- **Value**: ${formatCost(item.dealValue)}\n`;
                            if (item.probability) prompt += `- **Probability**: ${item.probability}%\n`;
                            if (item.accountExecutive) prompt += `- **Owner**: ${item.accountExecutive}\n`;
                            if (item.dependencies) {
                                const deps = Array.isArray(item.dependencies) ? item.dependencies.join(', ') : item.dependencies;
                                if (deps) prompt += `- **Dependencies**: ${deps}\n`;
                            }

                            // Add subtasks
                            if (item.subtasks && item.subtasks.length > 0) {
                                prompt += `\nAction steps:\n`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    prompt += `${subIdx + 1}. ${subtask.name}`;
                                    if (subtask.description) {
                                        prompt += `: ${subtask.description}`;
                                    }
                                    prompt += `\n`;
                                });
                            }

                            prompt += `\n`;
                        });
                    }

                    prompt += `\n`;
                });
            }

            // Footer
            prompt += `---\n\n`;
            prompt += `Provide a comprehensive response following this structure, addressing each ${pattern.levels.phase.toLowerCase()} and ${pattern.levels.item.toLowerCase()} systematically.\n`;

            return prompt;
        }

        // AI Modal - Overall Project Analysis (Dynamic AI-Generated)
        document.getElementById('ai-btn').addEventListener('click', async () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = '‚ú® AI Project Analysis';

            const totalCost = calculateTotal(capexTree);

            // Count items by phase
            function countItems(node, counts = {p0: 0, p1: 0, p2: 0}) {
                if (node.items && node.phase !== undefined) {
                    counts[`p${node.phase}`] += node.items.length;
                }
                if (node.children) {
                    node.children.forEach(child => countItems(child, counts));
                }
                return counts;
            }

            const itemCounts = countItems(capexTree);

            // Calculate phase costs (items only, not children)
            function getPhaseCost(phaseId) {
                const phase = findNode(phaseId);
                return phase ? calculatePhaseTotal(phase) : 0;
            }

            const phase0Cost = getPhaseCost('phase-0');
            const phase1Cost = getPhaseCost('phase-1');
            const phase2Cost = getPhaseCost('phase-2');

            // Show static summary cards first + loading state for AI analysis
            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, var(--treeplex-primary), #009977); color: white; padding: 24px; border-radius: 12px; margin-bottom: 24px;">
                        <h2 style="margin-bottom: 8px; font-size: 32px;">${formatCost(totalCost)}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Total Project Investment</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-0);">
                            <div style="font-size: 11px; font-weight: 600; color: #2e7d32; margin-bottom: 4px;">PHASE 0 ‚Ä¢ PRE-SEED</div>
                            <div style="font-size: 20px; font-weight: 700; color: #1b5e20; margin-bottom: 4px;">${formatCost(phase0Cost)}</div>
                            <div style="font-size: 12px; color: #2e7d32;">${itemCounts.p0} items</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-1);">
                            <div style="font-size: 11px; font-weight: 600; color: #1565c0; margin-bottom: 4px;">PHASE 1 ‚Ä¢ SEED</div>
                            <div style="font-size: 20px; font-weight: 700; color: #0d47a1; margin-bottom: 4px;">${formatCost(phase1Cost)}</div>
                            <div style="font-size: 12px; color: #1565c0;">${itemCounts.p1} items</div>
                        </div>
                        <div style="background: #fff3e0; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-2);">
                            <div style="font-size: 11px; font-weight: 600; color: #e65100; margin-bottom: 4px;">PHASE 2 ‚Ä¢ BUILD</div>
                            <div style="font-size: 20px; font-weight: 700; color: #bf360c; margin-bottom: 4px;">${formatCost(phase2Cost)}</div>
                            <div style="font-size: 12px; color: #e65100;">${itemCounts.p2} items</div>
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--text-secondary);">CAPITAL STRUCTURE</h4>
                        <p style="font-size: 14px; line-height: 1.6; margin-bottom: 12px; color: var(--text-primary);">
                            The project follows a phased capital deployment strategy with approximately
                            <strong>${((phase0Cost/totalCost)*100).toFixed(1)}%</strong> in Pre-Seed,
                            <strong>${((phase1Cost/totalCost)*100).toFixed(1)}%</strong> in Seed, and
                            <strong>${((phase2Cost/totalCost)*100).toFixed(1)}%</strong> in Build phases.
                        </p>
                        <div style="background: var(--bg); height: 24px; border-radius: 12px; overflow: hidden; display: flex;">
                            <div style="width: ${(phase0Cost/totalCost)*100}%; background: var(--phase-0);"></div>
                            <div style="width: ${(phase1Cost/totalCost)*100}%; background: var(--phase-1);"></div>
                            <div style="width: ${(phase2Cost/totalCost)*100}%; background: var(--phase-2);"></div>
                        </div>
                    </div>

                    <div id="ai-analysis-loading" style="padding: 40px; text-align: center; background: var(--card-bg); border-radius: 12px; margin-top: 20px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary); font-size: 14px;">AI is analyzing your project...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Generating Critical Path, Risk Assessment & Strategic Recommendations</p>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Call AI to generate the analysis sections dynamically
            console.log('ü§ñ Calling AI analysis at:', AI_CONFIG.apiEndpoint);
            try {
                const aiResponse = await generateAIAnalysis(capexTree, 'project');

                // Replace loading with AI-generated content
                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                        <div style="margin-bottom: 20px;">
                            <div id="ai-generated-content" style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                                <div style="white-space: pre-wrap; font-size: 14px; line-height: 1.8; color: var(--text-primary);">${aiResponse}</div>
                            </div>
                            <div style="margin-top: 16px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ü§ñ Analysis powered by Claude Sonnet ‚Ä¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;
                }

            } catch (error) {
                // Fallback to static analysis when AI is unavailable
                console.warn('AI Analysis unavailable, using static fallback:', error.message);

                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">CRITICAL PATH ANALYSIS</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    ‚Ä¢ <strong>Land acquisition</strong> is the primary gating factor for Phase 1 execution<br>
                                    ‚Ä¢ <strong>Turbine PO deposit</strong> (${formatCost(2000000)}) secures manufacturing capacity for Phase 2<br>
                                    ‚Ä¢ <strong>Pipeline FEED</strong> and permitting run in parallel to optimize timeline<br>
                                    ‚Ä¢ Phase 2 equipment procurement has 12-18 month lead times requiring early commitment
                                </p>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">RISK ASSESSMENT</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    <strong style="color: #d32f2f;">High Risk:</strong> Phase 2 represents ${((phase2Cost/totalCost)*100).toFixed(0)}% of total budget concentrated in equipment and infrastructure.<br>
                                    <strong style="color: #f57c00;">Medium Risk:</strong> Regulatory approvals for land, pipeline, and permitting on critical path.<br>
                                    <strong style="color: #388e3c;">Low Risk:</strong> Phase 0 has manageable capital exposure with assignable land options.
                                </p>
                            </div>

                            <div style="background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); padding: 20px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--treeplex-primary); text-transform: uppercase; letter-spacing: 0.5px;">STRATEGIC RECOMMENDATIONS</h4>
                                <ul style="font-size: 14px; line-height: 2; margin: 0; padding-left: 20px; color: var(--text-primary);">
                                    <li>Secure Phase 0 land option immediately to unlock downstream activities</li>
                                    <li>Negotiate payment milestones tied to regulatory approvals</li>
                                    <li>Consider project financing for Phase 2 to preserve equity</li>
                                    <li>Establish vendor relationships early for long-lead equipment items</li>
                                    <li>Build 10-15% contingency buffer beyond stated ${formatCost(310000)} reserves</li>
                                </ul>
                            </div>
                        </div>
                        <div style="margin-top: 16px; padding: 12px; background: rgba(255, 152, 0, 0.1); border-radius: 6px; text-align: center; border: 1px solid rgba(255, 152, 0, 0.3);">
                            <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                ‚ÑπÔ∏è AI Analysis unavailable ‚Ä¢ Showing static analysis ‚Ä¢ Deploy to Netlify for dynamic AI insights
                            </p>
                        </div>
                    </div>
                `;
                }
            }
        });

        document.getElementById('modal-close').addEventListener('click', () => {
            document.getElementById('modal').style.display = 'none';
        });

        // =============================================================================
        // API KEY CONFIGURATION
        // =============================================================================

        // Show/hide API key toggle
        document.getElementById('api-key-show').addEventListener('change', (e) => {
            const input = document.getElementById('api-key-input');
            input.type = e.target.checked ? 'text' : 'password';
        });

        // Cancel API key modal
        document.getElementById('api-key-cancel').addEventListener('click', () => {
            document.getElementById('api-key-modal').style.display = 'none';
        });

        document.getElementById('api-key-btn').addEventListener('click', () => {
            showApiKeyModal(true);
        });

        // Save API key
        document.getElementById('api-key-save').addEventListener('click', () => {
            const apiKey = document.getElementById('api-key-input').value.trim();

            if (!apiKey) {
                alert('Please enter an API key.');
                return;
            }

            if (!apiKey.startsWith('sk-ant-')) {
                alert('Invalid API key format. Anthropic API keys start with "sk-ant-"');
                return;
            }

            // Save to session storage
            setLocalAPIKey(apiKey);

            // Close modal
            document.getElementById('api-key-modal').style.display = 'none';

            // Show success message
            console.log('‚úÖ API key configured successfully');

            // If we came from Analysis Mode, reopen it
            if (window.pendingAnalysisMode) {
                window.pendingAnalysisMode = false;
                document.getElementById('analyze-text-btn').click();
            }
        });

        // Function to check if API key is configured
        function checkAPIKeyConfigured(options = {}) {
            const { forcePrompt = false } = options;
            const localKey = getLocalAPIKey();
            if (localKey) {
                return true;
            }

            if (!forcePrompt && canUseServerlessAI()) {
                console.log('üåê No local API key found. Using Netlify serverless function for AI calls.');
                return true;
            }

            // No local key and serverless unavailable (or prompt requested) - show modal
            showApiKeyModal(false);
            return false;
        }

        // =============================================================================
        // ANALYSIS MODE - TEXT TO TREE CONVERSION
        // =============================================================================

        let analysisText = '';
        let analysisFileName = '';

        // Open Analysis Modal
        document.getElementById('analyze-text-btn').addEventListener('click', () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                window.pendingAnalysisMode = true;
                return;
            }

            const modal = document.getElementById('analysis-modal');
            modal.style.display = 'flex';

            // Reset form
            document.getElementById('analysis-text-input').value = '';
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            document.getElementById('char-count').textContent = '0 characters';
            document.getElementById('analysis-warning').style.display = 'none';
            document.querySelector('input[name="analysis-mode"][value="quick"]').checked = true;
            analysisText = '';
            analysisFileName = '';
        });

        // Close Analysis Modal
        document.getElementById('analysis-cancel').addEventListener('click', () => {
            document.getElementById('analysis-modal').style.display = 'none';
        });

        // File Drop Zone - Click to browse
        const fileDropZone = document.getElementById('file-drop-zone');
        const fileInput = document.getElementById('analysis-file-input');

        fileDropZone.addEventListener('click', () => {
            fileInput.click();
        });

        // File selected via browse
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Drag and Drop handlers
        fileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--treeplex-primary)';
            fileDropZone.style.background = 'rgba(99, 102, 241, 0.05)';
        });

        fileDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';
        });

        fileDropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';

            const file = e.dataTransfer.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Handle file upload
        async function handleAnalysisFile(file) {
            // Check file type
            const validTypes = ['.txt', '.md'];
            const fileName = file.name.toLowerCase();
            const isValid = validTypes.some(type => fileName.endsWith(type));

            if (!isValid) {
                alert('Please upload a .txt or .md file only.');
                return;
            }

            // Show file name
            document.getElementById('selected-file-name').textContent = file.name;
            document.getElementById('file-name-display').style.display = 'block';
            analysisFileName = file.name;

            // Read file content
            const reader = new FileReader();
            reader.onload = (e) => {
                analysisText = e.target.result;

                // Clear text area since we're using file
                document.getElementById('analysis-text-input').value = '';

                // Update character count
                updateCharCount(analysisText.length);

                // Check file size and show warning if needed
                checkFileSize(analysisText.length);
            };
            reader.readAsText(file);
        }

        // Clear file button
        document.getElementById('clear-file-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            analysisText = '';
            analysisFileName = '';
            updateCharCount(0);
            document.getElementById('analysis-warning').style.display = 'none';
        });

        // Text area character count
        const textInput = document.getElementById('analysis-text-input');
        textInput.addEventListener('input', (e) => {
            analysisText = e.target.value;
            updateCharCount(analysisText.length);
            checkFileSize(analysisText.length);

            // Clear file if typing in text area
            if (analysisText.length > 0 && analysisFileName) {
                document.getElementById('analysis-file-input').value = '';
                document.getElementById('file-name-display').style.display = 'none';
                analysisFileName = '';
            }
        });

        function updateCharCount(count) {
            const charCountEl = document.getElementById('char-count');
            const words = count > 0 ? analysisText.trim().split(/\s+/).length : 0;
            charCountEl.textContent = `${count.toLocaleString()} characters (~${words} words)`;

            if (count > 50000) {
                charCountEl.style.color = '#ff9f43';
            } else {
                charCountEl.style.color = 'var(--text-secondary)';
            }
        }

        function checkFileSize(charCount) {
            const warningEl = document.getElementById('analysis-warning');
            const warningText = document.getElementById('analysis-warning-text');

            // Rough token estimate: 1 token ‚âà 4 characters
            const estimatedTokens = Math.ceil(charCount / 4);
            const estimatedWords = Math.ceil(charCount / 5);

            if (charCount > 100000) { // Will be truncated
                warningEl.style.display = 'block';
                warningText.textContent = `‚ö†Ô∏è Text is ${charCount.toLocaleString()} characters (~${estimatedWords.toLocaleString()} words). Will be automatically truncated to 100,000 characters (~25,000 words) to prevent timeouts. Consider pasting a shorter excerpt for best results.`;
            } else if (charCount > 75000) { // Large but ok
                warningEl.style.display = 'block';
                warningText.textContent = `Very large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis may take 15-25 seconds. Quick Mode strongly recommended.`;
            } else if (charCount > 50000) { // Large
                warningEl.style.display = 'block';
                warningText.textContent = `Large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Deep Mode will provide richer analysis but may take 20-30 seconds.`;
            } else if (charCount > 5000) {
                warningEl.style.display = 'block';
                warningText.textContent = `Medium text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis should take 15-30 seconds.`;
            } else {
                warningEl.style.display = 'none';
            }
        }

        // =============================================================================
        // AI PATTERN DETECTION & TEXT-TO-TREE CONVERSION
        // =============================================================================

        // Pattern detection function
        async function detectPattern(text) {
            const prompt = `Analyze the following text and determine the 3 most appropriate TreeListy patterns for organizing it.

AVAILABLE PATTERNS:
1. Generic Project - Universal structure for any project (Project ‚Üí Phase ‚Üí Item ‚Üí Task)
2. Sales Pipeline - Deal tracking across quarters (Pipeline ‚Üí Quarter ‚Üí Deal ‚Üí Action)
3. Academic Writing - Thesis/research paper structure (Thesis ‚Üí Chapter ‚Üí Section ‚Üí Point)
4. Product Roadmap - Feature development timeline (Product ‚Üí Quarter ‚Üí Feature ‚Üí Story)
5. Book Writing - Narrative structure (Book ‚Üí Part ‚Üí Chapter ‚Üí Scene)
6. Event Planning - Event organization and logistics (Event ‚Üí Stage ‚Üí Activity ‚Üí Task)
7. Fitness Program - Workout programs and exercises (Program ‚Üí Phase ‚Üí Workout ‚Üí Exercise)
8. Strategic Plan - Business initiatives and metrics (Strategy ‚Üí Pillar ‚Üí Initiative ‚Üí Action)
9. Course Design - Educational curriculum structure (Course ‚Üí Unit ‚Üí Lesson ‚Üí Exercise)
10. Film Production - Film/video production workflow (Film ‚Üí Phase ‚Üí Scene ‚Üí Shot)
11. Philosophy - Philosophical arguments and treatises (Treatise ‚Üí Book ‚Üí Argument ‚Üí Premise)
12. Family Tree - Genealogical documentation (Family ‚Üí Generation ‚Üí Person ‚Üí Event)

TEXT TO ANALYZE:
${text.substring(0, 5000)}${text.length > 5000 ? '\n\n[... truncated for analysis ...]' : ''}

Respond with ONLY a valid JSON object in this exact format:
{
  "recommendations": [
    {
      "pattern": "pattern-key",
      "patternName": "Pattern Display Name",
      "confidence": 9,
      "reasoning": "Brief explanation of why this pattern fits"
    }
  ]
}

Provide exactly 3 recommendations, ranked by confidence (1-10). Use these pattern keys: generic, sales, thesis, roadmap, book, event, fitness, strategy, course, film, philosophy, familytree`;

            const response = await callClaudeAPI(prompt);

            try {
                // Extract JSON from response
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    return result.recommendations;
                }
            } catch (e) {
                console.error('Failed to parse pattern detection response:', e);
            }

            // Fallback to generic
            return [{
                pattern: 'generic',
                patternName: 'Generic Project',
                confidence: 5,
                reasoning: 'Default fallback pattern'
            }];
        }

        // Helper function to fix common JSON issues
        function repairJSON(jsonText) {
            // SIMPLE APPROACH: Replace all problematic characters with spaces or escaped versions
            // This is more reliable than complex regex matching

            // Replace literal newlines, carriage returns, and tabs with spaces
            // These shouldn't be in JSON strings - Claude should use \n instead
            jsonText = jsonText.replace(/\r\n/g, ' ');
            jsonText = jsonText.replace(/\r/g, ' ');
            jsonText = jsonText.replace(/\n/g, ' ');
            jsonText = jsonText.replace(/\t/g, ' ');

            // Remove other control characters (ASCII 0-31 except space)
            jsonText = jsonText.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');

            // Remove trailing commas before closing brackets/braces (run multiple times to catch nested cases)
            let previousText;
            do {
                previousText = jsonText;
                jsonText = jsonText.replace(/,(\s*[}\]])/g, '$1');
            } while (jsonText !== previousText);

            // Remove comments (// and /* */)
            jsonText = jsonText.replace(/\/\/.*$/gm, '');
            jsonText = jsonText.replace(/\/\*[\s\S]*?\*\//g, '');

            return jsonText;
        }

        // Quick Mode: Basic structure conversion
        async function convertTextToTreeQuick(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;

            const prompt = `Convert this text into a hierarchical project structure using the "${patternConfig.name}" pattern.

PATTERN HIERARCHY:
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}

TEXT:
${text}

INSTRUCTIONS (BE CONCISE TO AVOID TIMEOUT):
1. Identify natural hierarchical structure in the text
2. Create 2-4 phases (${levels.phase}s) - MAXIMUM 4
3. For each phase, create 2-5 items (${levels.item}s) - MAXIMUM 5 per phase
4. For complex items, add 1-3 subtasks (${levels.subtask}s) - MAXIMUM 3 per item
5. Keep descriptions SHORT (under 100 characters)
6. PRIORITIZE SPEED - extract only the most important elements

JSON FORMATTING RULES (CRITICAL - FOLLOW EXACTLY):
- NO trailing commas after the last element in arrays or objects
- NO line breaks or tabs inside string values - use spaces instead
- NO unescaped quotes inside strings
- ONLY plain JSON - no markdown code blocks, no backticks, no explanations
- Start response with { and end with }

CORRECT EXAMPLE (note: NO trailing comma after last item):
{"phases": [{"name": "Test", "items": [{"name": "Item"}]}]}

WRONG (trailing comma):
{"phases": [{"name": "Test", "items": [{"name": "Item"},]}]}

Respond with ONLY valid, parseable JSON:
{
  "projectName": "Extracted or inferred project name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle or description",
      "icon": "üìã",
      "items": [
        {
          "name": "Item name",
          "description": "Brief description",
          "itemType": "type-if-applicable",
          "subtasks": [
            { "name": "Subtask name (optional)" }
          ]
        }
      ]
    }
  ]
}`;

            const response = await callClaudeAPI(prompt, '', 1500, false); // Reduced to avoid Netlify timeout

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the first { and last }
                const firstBrace = jsonText.indexOf('{');
                const lastBrace = jsonText.lastIndexOf('}');

                if (firstBrace !== -1 && lastBrace !== -1) {
                    jsonText = jsonText.substring(firstBrace, lastBrace + 1);
                }

                // Repair common JSON issues
                jsonText = repairJSON(jsonText);

                // Log the extracted JSON for debugging
                console.log('Extracted JSON (Quick):', jsonText.substring(0, 500) + '...');

                return JSON.parse(jsonText);
            } catch (e) {
                console.error('Failed to parse quick conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('üîß Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('‚úÖ JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('‚ùå Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Deep Mode: Detailed parsing with field extraction
        async function convertTextToTreeDeep(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            // Build field hints for AI
            let fieldHints = '';
            if (fields.cost) {
                fieldHints += '\n- Extract any cost/budget/price information as numbers';
            }
            if (fields.dealValue) {
                fieldHints += '\n- Extract deal values and revenue numbers';
            }
            if (fields.wordCount) {
                fieldHints += '\n- Estimate word counts for sections';
            }
            if (fields.storyPoints) {
                fieldHints += '\n- Assign story points (1-13) based on complexity';
            }
            if (fields.includeDependencies) {
                fieldHints += '\n- Identify dependencies between items (what depends on what)';
            }

            // Build pattern-specific field extraction guide
            let patternFieldGuide = '';
            if (pattern === 'philosophy') {
                patternFieldGuide = `
PHILOSOPHY PATTERN - EXTRACT THESE FIELDS FOR EVERY NODE:
- speaker: Who is speaking (e.g., "Socrates", "Callias", "Narrator")
- argumentType: Type of reasoning ("Deductive", "Inductive", "Dialectical", "Socratic Elenchus", "Reductio ad Absurdum")
- validity: Logical soundness ("Valid", "Invalid", "Sound", "Unsound", "Uncertain")
- keyTerms: Central concepts discussed (e.g., "justice, knowledge, virtue")
- premise1: First premise of argument (if applicable)
- premise2: Second premise of argument (if applicable)
- conclusion: Logical conclusion drawn (if applicable)
- objection: Counterargument raised (if applicable)
- response: Reply to objection (if applicable)
- textualReference: Location in text (e.g., "Movement 2, paragraph 3")
- philosophicalSchool: Tradition or school (e.g., "Platonic", "Aristotelian", "Stoic")

ITEM TYPES FOR PHILOSOPHY: Use specific types for each node:
question, definition, refutation, premise, conclusion, objection, response, example, analogy, distinction, paradox, thought-experiment, aporia, metaphysical, epistemological, ethical, political, logical`;
            } else if (pattern === 'sales') {
                patternFieldGuide = `
SALES PATTERN - EXTRACT THESE FIELDS:
- dealValue: Revenue/contract value in numbers
- probability: Win probability (0-100%)
- leadTime: Expected time to close
- dependencies: Prerequisites (other deals, approvals, etc.)`;
            } else if (pattern === 'academic') {
                patternFieldGuide = `
ACADEMIC PATTERN - EXTRACT THESE FIELDS:
- wordCount: Estimated word count for each section
- citations: Number of citations (if mentioned)
- dependencies: Which sections reference or build on others`;
            } else if (pattern === 'software') {
                patternFieldGuide = `
SOFTWARE PATTERN - EXTRACT THESE FIELDS:
- storyPoints: Complexity estimate (1, 2, 3, 5, 8, 13)
- dependencies: Technical dependencies between features/tasks`;
            }

            const prompt = `Convert this text into a detailed hierarchical project structure using the "${patternConfig.name}" pattern.

PATTERN HIERARCHY (4 LEVELS):
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}
${patternFieldGuide}

PATTERN-SPECIFIC FIELDS TO EXTRACT:${fieldHints || '\n- Extract name and description'}

TEXT TO ANALYZE:
${text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
DEEP MODE INSTRUCTIONS - COMPREHENSIVE EXTRACTION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ö†Ô∏è CRITICAL REQUIREMENTS - YOU MUST MEET THESE MINIMUMS:

1. PHASES: Create 3-6 phases (${levels.phase}s)
   ‚Üí Do NOT summarize into fewer phases
   ‚Üí Each major section/movement/chapter = separate phase

2. ITEMS PER PHASE: REQUIRED MINIMUM 3-8 items (${levels.item}s) per phase
   ‚Üí Do NOT create just 1 item per phase
   ‚Üí Extract ALL significant claims/arguments/features/sections
   ‚Üí Each distinct idea/component/argument = separate item

3. SUBTASKS: For complex items, add 1-5 subtasks (${levels.subtask}s)
   ‚Üí Supporting evidence, premises, sub-components
   ‚Üí NOT every item needs subtasks, but complex ones MUST have them

4. DEPTH: Go 3-4 levels deep in the hierarchy
   ‚Üí Phase ‚Üí Item ‚Üí Subtask ‚Üí (nested subtask if needed)
   ‚Üí Do NOT stop at 2 levels

5. FIELD POPULATION: Extract ALL pattern-specific field values
   ‚Üí speaker, argumentType, premise1, conclusion (for philosophy)
   ‚Üí dealValue, probability (for sales)
   ‚Üí wordCount, citations (for academic)
   ‚Üí Do NOT leave fields empty if information is available

6. DEPENDENCIES: Identify ALL logical prerequisites
   ‚Üí Look for: "depends on", "requires", "builds on", "follows from", "assumes", "after"
   ‚Üí Format: ["item-X-Y", "item-Z-W"]
   ‚Üí Map both intra-phase and inter-phase dependencies

7. NODE TYPES: Use specific types from pattern type list
   ‚Üí For philosophy: question, definition, refutation, premise, conclusion, objection, etc.
   ‚Üí Do NOT use generic "claim" for everything

8. DESCRIPTIONS: Write detailed descriptions (100-250 characters)
   ‚Üí Capture nuance, context, and significance
   ‚Üí NOT just repetition of title

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
EXAMPLE OF PROPER DEPTH (Philosophy Pattern)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

If text contains: "Socrates asks: What is justice? Callias replies it is giving each what they are owed. Socrates refutes this with the mad debtor example."

WRONG (too shallow):
{
  "phases": [{
    "name": "Movement 1",
    "items": [{"name": "Discussion of justice"}]
  }]
}

CORRECT (proper depth):
{
  "phases": [{
    "name": "Movement 1",
    "subtitle": "The Initial Inquiry",
    "items": [
      {
        "name": "Opening Question: What is Justice?",
        "itemType": "question",
        "speaker": "Socrates",
        "description": "Socrates initiates inquiry by asking Callias to define justice",
        "keyTerms": "justice, definition",
        "dependencies": []
      },
      {
        "name": "First Definition: Justice as Giving What is Owed",
        "itemType": "definition",
        "speaker": "Callias",
        "description": "Callias proposes justice means giving each person what they are owed",
        "keyTerms": "justice, debt, obligation",
        "dependencies": []
      },
      {
        "name": "Refutation via Mad Debtor Counterexample",
        "itemType": "refutation",
        "speaker": "Socrates",
        "argumentType": "Socratic Elenchus",
        "description": "Socrates refutes Callias's definition using case of returning sword to madman",
        "dependencies": ["item-0-1"],
        "subtasks": [
          {
            "name": "Premise: Returning sword to madman is dangerous",
            "itemType": "premise",
            "premise1": "The madman is owed the sword (per Callias's definition)",
            "conclusion": "But returning it would be unjust (harmful)",
            "description": "Creates contradiction in Callias's definition"
          },
          {
            "name": "Conclusion: Definition is insufficient",
            "itemType": "conclusion",
            "description": "Justice cannot be merely giving what is owed, circumstances matter",
            "dependencies": ["subtask-0-2-0"]
          }
        ]
      }
    ]
  }]
}

See the difference? The CORRECT version:
‚úì Has 3 items (not 1)
‚úì Uses specific item types (question, definition, refutation)
‚úì Populates fields (speaker, argumentType, keyTerms, premises)
‚úì Has subtasks with proper nesting
‚úì Maps dependencies between nodes

THIS IS THE LEVEL OF DETAIL REQUIRED IN DEEP MODE.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FINAL REMINDER
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Deep Mode = COMPREHENSIVE EXTRACTION, not summarization
Extract EVERYTHING with maximum granularity and detail
Aim for 25-40 total nodes for complex texts (Haiku's 4096 token limit)

JSON FORMATTING RULES (CRITICAL - FOLLOW EXACTLY):
- NO trailing commas after the last element in arrays or objects
- NO line breaks or tabs inside string values - use spaces instead
- NO unescaped quotes inside strings
- ONLY plain JSON - no markdown code blocks, no backticks, no explanations
- Start response with { and end with }

CORRECT EXAMPLE (note: NO trailing comma after last item):
{"phases": [{"name": "Test", "items": [{"name": "Item"}]}]}

WRONG (trailing comma):
{"phases": [{"name": "Test", "items": [{"name": "Item"},]}]}

Respond with ONLY valid, parseable JSON:
{
  "projectName": "Extracted or inferred project name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle",
      "icon": "üìã",
      "items": [
        {
          "name": "Item name",
          "description": "Detailed description",
          "itemType": "category",
          "cost": 1000,
          "dependencies": ["item-0-1", "item-1-2"],
          "subtasks": [
            {
              "name": "Subtask name",
              "description": "What needs to be done",
              "dependencies": []
            }
          ],
          "... other pattern-specific fields ...": "values"
        }
      ]
    }
  ]
}`;

            const response = await callClaudeAPI(prompt, '', 4096, false); // Deep Mode: 4096 tokens (Haiku's maximum) for detailed extraction

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the first { and last }
                const firstBrace = jsonText.indexOf('{');
                const lastBrace = jsonText.lastIndexOf('}');

                if (firstBrace !== -1 && lastBrace !== -1) {
                    jsonText = jsonText.substring(firstBrace, lastBrace + 1);
                }

                // Repair common JSON issues
                jsonText = repairJSON(jsonText);

                // Log the extracted JSON for debugging
                console.log('Extracted JSON (Deep):', jsonText.substring(0, 500) + '...');

                return JSON.parse(jsonText);
            } catch (e) {
                console.error('Failed to parse deep conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('üîß Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('‚úÖ JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('‚ùå Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Main Analyze button handler
        document.getElementById('analysis-start-btn').addEventListener('click', async () => {
            // Get text from file or textarea
            const textFromTextarea = document.getElementById('analysis-text-input').value.trim();
            let finalText = analysisText || textFromTextarea;

            if (!finalText) {
                alert('Please upload a file or paste text to analyze.');
                return;
            }

            // Auto-truncate very long texts to prevent timeouts
            const MAX_CHARS = 100000; // ~25,000 words max (Haiku can handle it!)
            let wasTruncated = false;
            if (finalText.length > MAX_CHARS) {
                wasTruncated = true;
                finalText = finalText.substring(0, MAX_CHARS);
                console.warn(`‚ö†Ô∏è Text truncated from ${analysisText.length} to ${MAX_CHARS} characters to prevent timeout`);
            }

            // Get selected mode
            const mode = document.querySelector('input[name="analysis-mode"]:checked').value;

            // Warn if text was truncated
            if (wasTruncated) {
                const proceed = confirm(`‚ö†Ô∏è Your text is very long and has been automatically truncated to ${MAX_CHARS} characters (~${Math.floor(MAX_CHARS/4)} words) to prevent timeouts.\n\nOnly the first portion will be analyzed.\n\nDo you want to continue?`);
                if (!proceed) {
                    return;
                }
            }

            // Close analysis modal and show loading modal
            document.getElementById('analysis-modal').style.display = 'none';
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'üîç Analyzing Text...';
            modal.style.display = 'flex';
            modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 1/3: Detecting optimal pattern...</p>';

            try {
                // Step 1: Detect pattern
                const recommendations = await detectPattern(finalText);

                // Show pattern selection
                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <h3 style="margin-bottom: 16px; color: var(--text-primary);">üìä Recommended Patterns</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px; font-size: 14px;">
                            AI analyzed your text and recommends these patterns. Select one to continue:
                        </p>
                        <div id="pattern-recommendations" style="display: flex; flex-direction: column; gap: 12px;">
                            ${recommendations.map((rec, index) => `
                                <label style="display: flex; align-items: flex-start; padding: 16px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s; background: var(--card-bg);" class="pattern-rec-option" data-pattern="${rec.pattern}">
                                    <input type="radio" name="selected-pattern" value="${rec.pattern}" ${index === 0 ? 'checked' : ''} style="margin-top: 4px; margin-right: 12px;" />
                                    <div style="flex: 1;">
                                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                            <span style="font-weight: 600; color: var(--text-primary); font-size: 15px;">${rec.patternName}</span>
                                            <span style="background: ${rec.confidence >= 8 ? '#4caf50' : rec.confidence >= 6 ? '#ff9f43' : '#666'}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">
                                                ${rec.confidence}/10 confidence
                                            </span>
                                        </div>
                                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                            ${rec.reasoning}
                                        </div>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                        <div style="margin-top: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">
                                Analysis Mode: ${mode === 'quick' ? '‚ö° Quick Mode' : 'üî¨ Deep Mode'}
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary);">
                                ${mode === 'quick' ? 'Fast analysis with basic structure extraction.' : 'Detailed analysis with field extraction and dependencies.'}
                            </div>
                        </div>
                    </div>
                `;

                // Add hover effects to pattern options
                document.querySelectorAll('.pattern-rec-option').forEach(option => {
                    option.addEventListener('mouseenter', () => {
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                    option.addEventListener('mouseleave', () => {
                        const radio = option.querySelector('input[type="radio"]');
                        if (!radio.checked) {
                            option.style.borderColor = 'var(--border)';
                            option.style.background = 'var(--card-bg)';
                        }
                    });
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.pattern-rec-option').forEach(opt => {
                            opt.style.borderColor = 'var(--border)';
                            opt.style.background = 'var(--card-bg)';
                        });
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                });

                // Update modal footer with continue button
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="pattern-select-cancel">Cancel</button>
                    <button class="btn btn-primary" id="pattern-select-continue" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Continue ‚Üí</button>
                `;

                document.getElementById('pattern-select-cancel').addEventListener('click', () => {
                    modal.style.display = 'none';
                });

                document.getElementById('pattern-select-continue').addEventListener('click', async () => {
                    const selectedPattern = document.querySelector('input[name="selected-pattern"]:checked').value;

                    // Step 2: Convert text to tree
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 2/3: Converting text to tree structure...</p>';
                    document.querySelector('#modal .modal-footer').innerHTML = '';

                    try {
                        let treeData;
                        if (mode === 'quick') {
                            treeData = await convertTextToTreeQuick(finalText, selectedPattern);
                        } else {
                            treeData = await convertTextToTreeDeep(finalText, selectedPattern);
                        }

                        // Step 3: Preview and import
                        showAnalysisPreview(treeData, selectedPattern);

                    } catch (error) {
                        modalBody.innerHTML = `
                            <div style="padding: 20px; text-align: center;">
                                <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                                <h3 style="color: #f44336; margin-bottom: 12px;">Analysis Failed</h3>
                                <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                            </div>
                        `;
                        document.querySelector('#modal .modal-footer').innerHTML = `
                            <button class="btn" id="error-close">Close</button>
                            <button class="btn btn-primary" id="error-retry">Try Again</button>
                        `;

                        document.getElementById('error-close').addEventListener('click', () => {
                            modal.style.display = 'none';
                        });

                        document.getElementById('error-retry').addEventListener('click', () => {
                            modal.style.display = 'none';
                            document.getElementById('analyze-text-btn').click();
                        });
                    }
                });

            } catch (error) {
                modalBody.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                        <h3 style="color: #f44336; margin-bottom: 12px;">Pattern Detection Failed</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                    </div>
                `;
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="error-close">Close</button>
                `;

                document.getElementById('error-close').addEventListener('click', () => {
                    modal.style.display = 'none';
                });
            }
        });

        // Show preview before importing
        function showAnalysisPreview(treeData, selectedPattern) {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            document.getElementById('modal-title').textContent = '‚úÖ Analysis Complete - Preview';

            // Count phases and items
            const phaseCount = treeData.phases?.length || 0;
            const itemCount = treeData.phases?.reduce((sum, phase) => sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, #4caf50, #00a67d); color: white; padding: 20px; border-radius: 12px; margin-bottom: 24px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 8px;">‚ú®</div>
                        <h2 style="margin-bottom: 8px; font-size: 24px;">${treeData.projectName || 'Analyzed Project'}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Pattern: ${PATTERNS[selectedPattern].name}</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${phaseCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Phases Detected</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${itemCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Items Created</div>
                        </div>
                    </div>

                    <div style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 16px; background: var(--bg-secondary);">
                        <h4 style="margin-bottom: 12px; color: var(--text-primary);">Structure Preview:</h4>
                        ${treeData.phases?.map((phase, i) => `
                            <div style="margin-bottom: 16px;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px;">
                                    ${phase.icon || 'üìã'} ${phase.name}
                                </div>
                                <div style="margin-left: 20px; font-size: 13px; color: var(--text-secondary);">
                                    ${phase.items?.slice(0, 3).map(item => `‚Ä¢ ${item.name}`).join('<br>')}
                                    ${phase.items?.length > 3 ? `<br>... and ${phase.items.length - 3} more items` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-top: 20px; padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px;">
                        <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">‚ö†Ô∏è Import Warning</div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            Importing will replace your current project. Your current project will be saved as a backup first.
                        </div>
                    </div>
                </div>
            `;

            // Create buttons directly with event listeners attached
            const modalFooter = document.querySelector('#modal .modal-footer');
            if (!modalFooter) {
                console.error('‚ùå Modal footer not found!');
                alert('Error: Modal footer not found. Please refresh the page.');
                return;
            }

            // Clear existing content
            modalFooter.innerHTML = '';

            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => {
                console.log('üö´ Import cancelled');
                modal.style.display = 'none';
            };

            // Create import button
            const importBtn = document.createElement('button');
            importBtn.className = 'btn btn-primary';
            importBtn.style.cssText = 'background: linear-gradient(135deg, #4caf50, #00a67d);';
            importBtn.textContent = 'üì• Import to TreeListy';
            importBtn.onclick = () => {
                console.log('üîÑ Import button clicked!', { hasTreeData: !!treeData, hasPattern: !!selectedPattern });
                try {
                    importAnalyzedTree(treeData, selectedPattern);
                    modal.style.display = 'none';
                } catch (error) {
                    console.error('‚ùå Import failed:', error);
                    alert('Import failed: ' + error.message);
                }
            };

            // Add buttons to footer
            modalFooter.appendChild(cancelBtn);
            modalFooter.appendChild(importBtn);

            console.log('‚úÖ Preview modal ready with import button');
        }

        // Import analyzed tree into TreeListy
        function importAnalyzedTree(treeData, selectedPattern) {
            console.log('üì• Starting import...', { treeData, selectedPattern });

            // Backup current project first
            const backup = JSON.stringify(capexTree, null, 2);
            const backupName = `treelisty_backup_${Date.now()}.json`;
            console.log('üíæ Current project backed up as:', backupName);

            // Switch to selected pattern
            currentPattern = selectedPattern;
            document.getElementById('pattern-select').value = selectedPattern;

            // Convert analyzed data to TreeListy format
            const newTree = {
                type: 'root',
                id: 'root',
                name: treeData.projectName || 'Analyzed Project',
                icon: 'üå≤',
                expanded: true,
                children: treeData.phases?.map((phase, phaseIndex) => ({
                    type: 'phase',
                    id: `phase-${phaseIndex}`,
                    phase: phaseIndex,
                    name: phase.name,
                    subtitle: phase.subtitle || PATTERNS[selectedPattern].phaseSubtitles?.[phaseIndex] || '',
                    icon: phase.icon || 'üìã',
                    expanded: true,
                    cost: 0,
                    items: phase.items?.map((item, itemIndex) => {
                        const itemId = `item-${phaseIndex}-${itemIndex}`;

                        // Build item object with all required fields
                        const itemObj = {
                            type: 'item',
                            id: itemId,
                            name: item.name,
                            description: item.description || '',
                            itemType: item.itemType || '',
                            icon: item.icon || 'üìÑ',
                            cost: item.cost || 0,
                            dependencies: item.dependencies || [],
                            notes: item.notes || '',
                            leadTime: item.leadTime || '',
                            alternateSource: item.alternateSource || '',
                            expanded: false,
                            // Pattern-specific fields
                            dealValue: item.dealValue || 0,
                            wordCount: item.wordCount || 0,
                            storyPoints: item.storyPoints || 0,
                            // Add any other fields from AI
                            ...item
                        };

                        // Add subtasks if they exist (3rd level hierarchy)
                        if (item.subtasks && item.subtasks.length > 0) {
                            itemObj.children = item.subtasks.map((subtask, subtaskIndex) => ({
                                type: 'subtask',
                                id: `subtask-${phaseIndex}-${itemIndex}-${subtaskIndex}`,
                                name: subtask.name || subtask,
                                description: subtask.description || '',
                                icon: subtask.icon || 'üìå',
                                notes: subtask.notes || '',
                                dependencies: subtask.dependencies || [],
                                // Pattern-specific fields
                                ...subtask
                            }));
                        }

                        return itemObj;
                    }) || []
                })) || []
            };

            // Replace current tree
            capexTree = newTree;

            // Render
            render();

            // Count total items and subtasks
            const totalItems = treeData.phases?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0;
            const totalSubtasks = treeData.phases?.reduce((sum, p) =>
                sum + (p.items?.reduce((subSum, item) => subSum + (item.subtasks?.length || 0), 0) || 0), 0) || 0;

            // Show success message
            let message = `‚úÖ Successfully imported!\n\n${treeData.phases?.length || 0} phases and ${totalItems} items`;
            if (totalSubtasks > 0) {
                message += ` and ${totalSubtasks} subtasks`;
            }
            message += ` have been created.\n\nPattern: ${PATTERNS[selectedPattern].name}`;
            alert(message);
        }

        // How to Use button
        document.getElementById('how-to-btn').addEventListener('click', () => {
            const modal = document.getElementById('modal');
            document.getElementById('modal-title').textContent = 'üìñ How to Use TreeListy';
            document.getElementById('modal-body').innerHTML = `
                <div style="padding: 20px; line-height: 1.8;">
                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">üí° What is TreeListy?</h3>
                    <p style="margin-bottom: 20px; font-size: 14px;">
                        <strong>TreeListy</strong> is a universal tool for breaking down any complex project, problem, or process into manageable parts.\n                        Structure your work into phases, track dependencies between components, and analyze your entire plan at a glance.\n                        Use it for software projects, events, research, personal goals, or anything else that benefits from structured thinking! üå≥‚ú®üéØ
                    </p>

                    <h3 style="color: var(--phase-1); margin-bottom: 16px; font-size: 20px;">üöÄ Getting Started</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-1);">
                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>1. Create Items</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Right-click on any Phase ‚Üí "Add Item"</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Fill in Name, Description, Cost, and Lead Time</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>2. Use Smart Suggestions üí°</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Right-click any text field ‚Üí "Smart Suggest"</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Cost suggestions learn from similar items in your project!</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Add Context Notes for even better suggestions</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>3. Set Dependencies</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Edit an item ‚Üí Check boxes in Dependencies section</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Watch dependency arrows appear automatically! üéØ</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>4. Use AI Analysis ü§ñ</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Click any item ‚Üí "ü§ñ AI Analysis" button</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Get intelligent insights powered by Claude Sonnet</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Risk analysis, cost optimization, and procurement strategy</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>5. Save Your Work üíæ</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Click "üíæ Save" button in the toolbar</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Or right-click Root/Phase ‚Üí "Download JSON"</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Filename includes timestamp (treelisty-project-2025-11-02_143025.json)</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>6. Load Saved Projects üìÇ</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Click "üìÇ Load" button in the toolbar</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Or right-click Root/Phase ‚Üí "Upload JSON"</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>7. Export to Excel üìä</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Click "üìä Excel" button in the toolbar</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Get 4-sheet professional workbook with executive summary</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Perfect for sharing with investors and stakeholders!</p>
                    </div>

                    <h3 style="color: var(--phase-2); margin-bottom: 16px; font-size: 20px;">üìä Investor Presentations</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-2);">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy is your secret weapon for investor meetings!</strong> Here's how to wow your audience:
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üéØ Visual Impact</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Expand all phases to show the complete project roadmap<br>
                            ‚Ä¢ Dependency arrows show critical path in real-time<br>
                            ‚Ä¢ Phase colors guide investors through the timeline
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üí∞ Financial Transparency</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Click any item to show detailed cost breakdowns<br>
                            ‚Ä¢ Smart Analysis compares costs to similar items<br>
                            ‚Ä¢ Automatic alerts for cost anomalies (+/- 50% from average)<br>
                            ‚Ä¢ Phase totals show capital deployment strategy
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">‚ö° Risk Management</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Show Alternate Sources for key equipment<br>
                            ‚Ä¢ Lead Times demonstrate realistic planning<br>
                            ‚Ä¢ Dependencies prove you've thought through execution
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üìä Excel Export for Presentations</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Click "üìä Export to Excel" for investor-ready spreadsheets<br>
                            ‚Ä¢ 4 professional sheets: Executive Summary, Details, Dependencies, Cost Analysis<br>
                            ‚Ä¢ Share with board members and stakeholders<br>
                            ‚Ä¢ Auto-formatted with phase colors and totals
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ü§ñ AI-Powered Insights</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Use "ü§ñ AI Analysis" for instant expert analysis<br>
                            ‚Ä¢ Get risk assessments and cost optimization recommendations<br>
                            ‚Ä¢ Claude Sonnet provides strategic procurement insights<br>
                            ‚Ä¢ Perfect for due diligence questions
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üé§ Pro Tip</p>
                        <p style="font-size: 13px; margin-bottom: 8px; font-style: italic; color: var(--treeplex-primary);">
                            During your pitch, use AI Analysis to demonstrate data-driven planning. Export to Excel
                            before the meeting so stakeholders can follow along with printed materials. The combination
                            of live visualization + professional spreadsheets = credibility! üòé
                        </p>
                    </div>

                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">üé® Navigation Tips</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Toolbar buttons (top right)</strong> - Quick access to Save, Load, Excel, and AI</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Click any node</strong> to expand/collapse or view details</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Right-click anywhere</strong> for context menus with quick actions</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Indented items</strong> (shifted right) depend on items above them</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Dependency lines</strong> show cross-phase relationships</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Phase backgrounds</strong> change color (green ‚Üí blue ‚Üí orange)</p>
                        <p style="font-size: 13px;">‚Ä¢ <strong>Hover over items</strong> to see them pop with 3D effects!</p>
                    </div>

                    <div style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.1), rgba(59, 143, 204, 0.1)); border-radius: 8px; text-align: center;">
                        <p style="font-size: 14px; font-weight: 600; color: var(--treeplex-primary); margin-bottom: 8px;">
                            üöÄ Ready to build something amazing?
                        </p>
                        <p style="font-size: 13px; opacity: 0.9;">
                            Close this dialog and start planning your next billion-dollar project!
                        </p>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
        });

        // =============================================================================
        // EXCEL EXPORT - Professional Multi-Sheet Workbook for Investors
        // =============================================================================

        function exportToExcel() {
            // Create a new workbook
            const wb = XLSX.utils.book_new();

            // Collect all items AND subtasks from the tree (proper phase structure)
            const allItems = [];
            const allTasks = []; // Subtasks for separate PM sheet (recursive)

            // RECURSIVE function to collect nested subtasks from multiple data shapes
            function collectSubtasks(parentItem, parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel = 0) {
                const subtaskCandidates = [];
                const seenIds = new Set();

                if (Array.isArray(parentItem.subItems) && parentItem.subItems.length > 0) {
                    parentItem.subItems.forEach((subtask, index) => {
                        const id = subtask.id || `${parentItem.id || 'item'}-sub-${index}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            subtaskCandidates.push({ ...subtask, id });
                        }
                    });
                }

                if (Array.isArray(parentItem.children) && parentItem.children.length > 0) {
                    parentItem.children
                        .filter(child => child.type === 'subtask')
                        .forEach((child, index) => {
                            const id = child.id || `${parentItem.id || 'item'}-child-${index}`;
                            if (!seenIds.has(id)) {
                                seenIds.add(id);
                                subtaskCandidates.push({ ...child, id });
                            }
                        });
                }

                if (Array.isArray(parentItem.subtasks) && parentItem.subtasks.length > 0) {
                    parentItem.subtasks.forEach((entry, index) => {
                        const normalized = typeof entry === 'string'
                            ? { name: entry }
                            : { ...entry };
                        const id = normalized.id || `${parentItem.id || 'item'}-simple-${index}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            subtaskCandidates.push({
                                type: normalized.type || 'subtask',
                                ...normalized,
                                id
                            });
                        }
                    });
                }

                if (subtaskCandidates.length === 0) {
                    return;
                }

                subtaskCandidates.forEach(subtask => {
                    const indent = '  '.repeat(nestLevel); // Indentation for hierarchy
                    allTasks.push({
                        ...subtask,
                        parentItem: parentName,
                        parentItemId: parentItem.id,
                        phaseName: phaseName,
                        phaseSubtitle: phaseSubtitle,
                        phaseNumber: phaseNumber,
                        nestLevel: nestLevel,
                        taskName: indent + (subtask.name || 'Subtask')
                    });

                    // RECURSIVELY collect nested subtasks
                    collectSubtasks(subtask, subtask.name || parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel + 1);
                });
            }

            function collectItems(node) {
                // Collect items from this phase node
                if (node.items && Array.isArray(node.items)) {
                    node.items.forEach(item => {
                        allItems.push({
                            ...item,
                            phaseName: node.name || 'Unknown Phase',
                            phaseSubtitle: node.subtitle || '',
                            phaseNumber: node.phase || '0'
                        });

                        // Collect subtasks recursively for PM tracking
                        collectSubtasks(item, item.name, node.name || 'Unknown Phase', node.subtitle || '', node.phase || '0', 0);
                    });
                }

                // Recursively collect from child phases
                if (node.children && Array.isArray(node.children)) {
                    node.children.forEach(child => {
                        collectItems(child);
                    });
                }
            }
            collectItems(capexTree);

            // Calculate totals
            const totalCost = allItems.reduce((sum, item) => sum + (item.cost || 0), 0);

            // Group by phase dynamically
            const phaseBreakdown = {};
            allItems.forEach(item => {
                const phaseKey = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;
                if (!phaseBreakdown[phaseKey]) {
                    phaseBreakdown[phaseKey] = { total: 0, count: 0, phaseNumber: item.phaseNumber };
                }
                phaseBreakdown[phaseKey].total += (item.cost || 0);
                phaseBreakdown[phaseKey].count++;
            });

            // =================================================================
            // SHEET 1: EXECUTIVE SUMMARY
            // =================================================================
            const resolvePatternName = () => {
                if (capexTree.pattern && capexTree.pattern.key) {
                    if (capexTree.pattern.key === 'custom') {
                        const labels = capexTree.pattern.labels || {};
                        return labels.root ? `Custom (${labels.root})` : 'Custom Pattern';
                    }
                    if (PATTERNS[capexTree.pattern.key]) {
                        return PATTERNS[capexTree.pattern.key].name;
                    }
                }
                if (PATTERNS[currentPattern]) {
                    return PATTERNS[currentPattern].name;
                }
                return 'Generic Project';
            };

            const patternNameForSummary = resolvePatternName();

            const summaryData = [
                ['TREEPLEXITY - PROJECT SUMMARY'],
                ['by geej', '', '', ''],
                [],
                ['Project:', capexTree.name || 'Project Plan'],
                ['Pattern:', patternNameForSummary],
                ['Total Cost:', `$${(totalCost / 1000000).toFixed(2)}M`],
                ['Items Count:', allItems.length],
                ['Report Date:', new Date().toLocaleDateString()],
                [],
                ['INVESTMENT BREAKDOWN BY PHASE'],
                [],
                ['Phase', 'Investment', 'Percentage', 'Items']
            ];

            // Add phase rows dynamically (sorted by phase number)
            Object.entries(phaseBreakdown)
                .sort((a, b) => (a[1].phaseNumber || 0) - (b[1].phaseNumber || 0))
                .forEach(([phaseName, data]) => {
                    const phasePercentage = totalCost > 0 ? `${((data.total / totalCost) * 100).toFixed(1)}%` : '0%';
                    summaryData.push([
                        phaseName,
                        `$${(data.total / 1000000).toFixed(2)}M`,
                        phasePercentage,
                        data.count
                    ]);
                });

            // Add total row
            summaryData.push(['TOTAL', `$${(totalCost / 1000000).toFixed(2)}M`, totalCost > 0 ? '100.0%' : '0%', allItems.length]);

            // Add key metrics
            summaryData.push([]);
            summaryData.push(['KEY METRICS']);
            summaryData.push([]);
            summaryData.push(['Metric', 'Value']);
            summaryData.push(['Average Item Cost', allItems.length > 0 ? `$${(totalCost / allItems.length / 1000).toFixed(0)}K` : '$0']);
            summaryData.push(['Largest Single Item', allItems.length > 0 ? `$${(Math.max(...allItems.map(i => i.cost || 0)) / 1000000).toFixed(2)}M` : '$0']);
            summaryData.push(['Items with Dependencies', allItems.filter(i => i.dependencies && i.dependencies.length > 0).length]);
            summaryData.push(['Items with Alternate Sources', allItems.filter(i => i.alternateSource).length]);

            const ws_summary = XLSX.utils.aoa_to_sheet(summaryData);

            // Set column widths
            ws_summary['!cols'] = [
                { wch: 30 },  // Column A
                { wch: 20 },  // Column B
                { wch: 15 },  // Column C
                { wch: 15 }   // Column D
            ];

            // Add to workbook
            XLSX.utils.book_append_sheet(wb, ws_summary, 'üìä Executive Summary');

            // =================================================================
            // SHEET 2: DETAILED ITEMS
            // =================================================================
            const itemsData = [
                ['DETAILED PROJECT ITEMS'],
                [],
                ['Item Name', 'Phase', 'Type', 'Cost ($M)', 'Lead Time', 'Description', 'Alternate Source', 'Dependencies', 'Notes']
            ];

            allItems.forEach(item => {
                const phaseDisplay = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;
                itemsData.push([
                    item.name || '',
                    phaseDisplay,
                    item.itemType || '',
                    item.cost ? (item.cost / 1000000).toFixed(2) : '0.00',
                    item.leadTime || '',
                    item.description || '',
                    item.alternateSource || '',
                    (item.dependencies || []).length > 0 ? item.dependencies.join(', ') : 'None',
                    item.notes || ''
                ]);
            });

            // Add total row
            itemsData.push([]);
            itemsData.push(['TOTAL', '', '', (totalCost / 1000000).toFixed(2), '', '', '', '', '']);

            const ws_items = XLSX.utils.aoa_to_sheet(itemsData);

            // Set column widths
            ws_items['!cols'] = [
                { wch: 30 },  // Item Name
                { wch: 25 },  // Phase
                { wch: 20 },  // Type
                { wch: 12 },  // Cost
                { wch: 15 },  // Lead Time
                { wch: 40 },  // Description
                { wch: 30 },  // Alternate Source
                { wch: 30 },  // Dependencies
                { wch: 40 }   // Notes
            ];

            XLSX.utils.book_append_sheet(wb, ws_items, 'üìã Detailed Items');

            // =================================================================
            // SHEET 3: DEPENDENCIES MATRIX
            // =================================================================
            const depsData = [
                ['DEPENDENCY MATRIX'],
                [],
                ['Item', 'Depends On', 'Count', 'Critical Path?']
            ];

            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    depsData.push([
                        item.name || '',
                        item.dependencies.join(', '),
                        item.dependencies.length,
                        item.dependencies.length > 2 ? 'Yes' : 'No'
                    ]);
                }
            });

            if (depsData.length === 3) {
                depsData.push(['No dependencies defined yet', '', '', '']);
            }

            const ws_deps = XLSX.utils.aoa_to_sheet(depsData);

            ws_deps['!cols'] = [
                { wch: 35 },
                { wch: 50 },
                { wch: 10 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_deps, 'üîó Dependencies');

            // =================================================================
            // SHEET 4: COST ANALYSIS BY TYPE
            // =================================================================
            const typeBreakdown = {};
            allItems.forEach(item => {
                const type = item.itemType || 'Uncategorized';
                if (!typeBreakdown[type]) {
                    typeBreakdown[type] = { count: 0, total: 0 };
                }
                typeBreakdown[type].count++;
                typeBreakdown[type].total += (item.cost || 0);
            });

            const analysisData = [
                ['COST ANALYSIS BY TYPE'],
                [],
                ['Item Type', 'Count', 'Total Cost ($M)', '% of Total', 'Avg Cost ($K)']
            ];

            Object.entries(typeBreakdown)
                .sort((a, b) => b[1].total - a[1].total)
                .forEach(([type, data]) => {
                    analysisData.push([
                        type,
                        data.count,
                        (data.total / 1000000).toFixed(2),
                        ((data.total / totalCost) * 100).toFixed(1) + '%',
                        (data.total / data.count / 1000).toFixed(0)
                    ]);
                });

            analysisData.push([]);
            analysisData.push(['TOTAL', allItems.length, (totalCost / 1000000).toFixed(2), '100.0%', (totalCost / allItems.length / 1000).toFixed(0)]);

            const ws_analysis = XLSX.utils.aoa_to_sheet(analysisData);

            ws_analysis['!cols'] = [
                { wch: 30 },
                { wch: 10 },
                { wch: 18 },
                { wch: 12 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_analysis, 'üìà Cost Analysis');

            // =================================================================
            // SHEET 5: PROJECT TASKS (PM TRACKING)
            // =================================================================
            const tasksData = [
                ['PROJECT TASKS - EXECUTION TRACKING (HIERARCHICAL)'],
                ['Professional Project Management Dashboard', '', '', '', '', '', '', '', '', '', '', ''],
                [],
                ['Task Name', 'Level', 'Parent Item', 'Phase', 'Status', 'Assignee', 'Progress %', 'Priority', 'Start Date', 'Due Date', 'Blocking Issue', 'Next Steps', 'Latest Updates']
            ];

            // Add task rows
            if (allTasks.length > 0) {
                allTasks.forEach(task => {
                    const phaseDisplay = `${task.phaseName}${task.phaseSubtitle ? ' (' + task.phaseSubtitle + ')' : ''}`;

                    // Format updates as timestamped entries
                    let updatesText = '';
                    if (task.pmUpdates && Array.isArray(task.pmUpdates) && task.pmUpdates.length > 0) {
                        updatesText = task.pmUpdates
                            .map(u => `[${new Date(u.timestamp).toLocaleDateString()}] ${u.text}`)
                            .join(' | ');
                    }

                    tasksData.push([
                        task.taskName || task.name || '',  // Use indented taskName for hierarchy
                        task.nestLevel || 0,
                        task.parentItem || '',
                        phaseDisplay,
                        task.pmStatus || 'To Do',
                        task.pmAssignee || 'Unassigned',
                        task.pmProgress || 0,
                        task.pmPriority || 'Medium',
                        task.pmStartDate || '',
                        task.pmDueDate || '',
                        task.pmBlockingIssue || '',
                        task.pmNextSteps || '',
                        updatesText
                    ]);
                });
            } else {
                tasksData.push(['No tasks created yet', '', '', '', '', '', '', '', '', '', '', '', '']);
            }

            // Add summary metrics
            tasksData.push([]);
            tasksData.push(['TASK SUMMARY METRICS']);
            tasksData.push([]);

            const completedTasks = allTasks.filter(t => t.pmStatus === 'Done').length;
            const inProgressTasks = allTasks.filter(t => t.pmStatus === 'In Progress').length;
            const blockedTasks = allTasks.filter(t => t.pmStatus === 'Blocked').length;
            const avgProgress = allTasks.length > 0 ? (allTasks.reduce((sum, t) => sum + (t.pmProgress || 0), 0) / allTasks.length).toFixed(1) : 0;

            tasksData.push(['Total Tasks', allTasks.length]);
            tasksData.push(['Completed', completedTasks, `${allTasks.length > 0 ? ((completedTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['In Progress', inProgressTasks, `${allTasks.length > 0 ? ((inProgressTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['Blocked', blockedTasks, blockedTasks > 0 ? '‚ö†Ô∏è ATTENTION REQUIRED' : '']);
            tasksData.push(['Average Progress', `${avgProgress}%`]);
            tasksData.push([]);
            tasksData.push(['Status Distribution']);

            // Status breakdown
            const statusCounts = {};
            allTasks.forEach(t => {
                const status = t.pmStatus || 'To Do';
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });

            Object.entries(statusCounts)
                .sort((a, b) => b[1] - a[1])
                .forEach(([status, count]) => {
                    tasksData.push([status, count, `${((count/allTasks.length)*100).toFixed(1)}%`]);
                });

            const ws_tasks = XLSX.utils.aoa_to_sheet(tasksData);

            // Set column widths for professional presentation
            ws_tasks['!cols'] = [
                { wch: 40 },  // Task Name (with indentation)
                { wch: 8 },   // Level
                { wch: 30 },  // Parent Item
                { wch: 25 },  // Phase
                { wch: 15 },  // Status
                { wch: 20 },  // Assignee
                { wch: 12 },  // Progress %
                { wch: 12 },  // Priority
                { wch: 15 },  // Start Date
                { wch: 15 },  // Due Date
                { wch: 35 },  // Blocking Issue
                { wch: 40 },  // Next Steps
                { wch: 60 }   // Latest Updates
            ];

            XLSX.utils.book_append_sheet(wb, ws_tasks, '‚úÖ Project Tasks');

            // =================================================================
            // GENERATE AND DOWNLOAD FILE
            // =================================================================
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `TreeListy-${timestamp}.xlsx`;

            XLSX.writeFile(wb, filename);

            // Show success message
            alert(`‚úÖ Excel export successful!\n\nFile: ${filename}\n\nIncludes:\n‚Ä¢ Executive Summary\n‚Ä¢ Detailed Items (${allItems.length} items)\n‚Ä¢ Dependencies Matrix\n‚Ä¢ Cost Analysis by Type\n‚Ä¢ Project Tasks (${allTasks.length} tasks with PM tracking)\n\nProfessionally formatted and ready for investor presentations! üìä`);
        }

        // Excel Export button handler
        document.getElementById('excel-export-btn').addEventListener('click', exportToExcel);

        // Redraw lines on scroll or resize
        const treeContainer = document.getElementById('tree-container');
        treeContainer.addEventListener('scroll', drawDependencyLines);
        window.addEventListener('resize', drawDependencyLines);

        // Load from shared URL if present
        (function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const compressedData = urlParams.get('p');

            if (compressedData) {
                try {
                    console.log('Loading shared project from URL...');
                    const decompressed = LZString.decompressFromEncodedURIComponent(compressedData);
                    const loadedTree = JSON.parse(decompressed);

                    // Replace capexTree with loaded data
                    capexTree = loadedTree;

                    // Update currentPattern if it's in the loaded data
                    if (capexTree.pattern && capexTree.pattern.key) {
                        currentPattern = capexTree.pattern.key;
                    }

                    console.log('‚úÖ Shared project loaded successfully!');
                    console.log('Project:', capexTree.name || capexTree.title);
                    console.log('Pattern:', currentPattern);

                    // Show a brief success message
                    setTimeout(() => {
                        const toast = document.createElement('div');
                        toast.textContent = '‚úÖ Shared project loaded!';
                        toast.style.cssText = `
                            position: fixed;
                            top: 80px;
                            right: 20px;
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            padding: 15px 25px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-weight: 600;
                            animation: slideIn 0.3s ease-out;
                        `;
                        document.body.appendChild(toast);

                        setTimeout(() => {
                            toast.style.animation = 'slideOut 0.3s ease-in';
                            setTimeout(() => toast.remove(), 300);
                        }, 3000);
                    }, 500);

                } catch (error) {
                    console.error('‚ùå Failed to load shared project:', error);
                    alert('Failed to load shared project. The URL may be corrupted or invalid.');
                }
            }
        })();

        // Initial render
        render();

        // Initialize pattern selector
        const patternSelect = document.getElementById('pattern-select');
        console.log('Pattern selector found:', patternSelect);
        if (patternSelect) {
            // Load saved pattern from data
            if (capexTree.pattern && capexTree.pattern.key) {
                currentPattern = capexTree.pattern.key;
                patternSelect.value = currentPattern;
                console.log('Loaded saved pattern:', currentPattern);
                if (currentPattern === 'custom' && capexTree.pattern.labels) {
                    customPatternNames = capexTree.pattern.labels;
                }
                // Apply pattern labels to existing nodes on load
                const labels = currentPattern === 'custom' && customPatternNames ? customPatternNames : PATTERNS[currentPattern].levels;
                renameNodesForPattern(capexTree, labels);
                console.log('Initial nodes renamed to match saved pattern');
                render(); // Re-render with renamed nodes
            }
            // Handle pattern selection
            patternSelect.addEventListener('change', function() {
                console.log('Pattern selector changed to:', this.value);
                applyPattern(this.value);
            });
            console.log('Pattern selector event listener attached');
        } else {
            console.error('Pattern selector NOT found!');
        }

        // Initialize pan/zoom controls
        initPanZoom();

        // Splash screen auto-dismiss
        setTimeout(() => {
            const splashScreen = document.getElementById('splash-screen');
            if (splashScreen) {
                splashScreen.classList.add('fade-out');
                // Remove from DOM after fade-out animation completes
                setTimeout(() => {
                    splashScreen.remove();
                }, 500); // Match fade-out animation duration
            }
        }, 2000); // Show splash for 2 seconds (matches loader animation)
    </script>
</body>
</html>
<!-- Cache buster: 1762487974 -->
