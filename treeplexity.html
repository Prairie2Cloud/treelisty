<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TreeListy - Universal Project Decomposition by geej</title>
    <!-- v1.1 - Self-healing JSON repair system -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            --treeplex-primary: #6366f1;
            --treeplex-primary-dark: #4f46e5;
            --phase-0: #5FA463;
            --phase-0-light: #6FB56E;
            --phase-0-dark: #4A8C4E;
            --phase-1: #3B8FCC;
            --phase-1-light: #4A9DD9;
            --phase-1-dark: #2B7AB8;
            --phase-2: #D68A2E;
            --phase-2-light: #E09940;
            --phase-2-dark: #B8741F;
            --text-primary: #E8EAF0;
            --text-secondary: #9DA3B4;
            --border: #3A3F4D;
            --bg: #1E2128;
            --card-bg: #2A2F3C;
            --card-bg-light: #32374A;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.5);
            --shadow-xl: 0 12px 40px rgba(0,0,0,0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            overflow: auto;
        }

        ::selection {
            background: var(--treeplex-primary);
            color: white;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            background: #252931;
            border-bottom: 1px solid var(--border);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .logo {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .logo-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 24px;
            font-weight: 700;
            color: var(--treeplex-primary);
            letter-spacing: -0.5px;
        }

        .logo-subtitle {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-left: 46px;
        }

        /*         .confidential {
        /*             padding: 4px 12px;
        /*             background: #fff5f5;
        /*             border: 1px solid #ffccc7;
        /*             border-radius: 6px;
        /*             font-size: 11px;
        /*             font-weight: 600;
        /*             color: #d32f2f;
        /*             letter-spacing: 0.5px;
        /*         } */

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .control-section {
            display: flex;
            gap: 6px;
            padding: 0 12px;
            border-right: 1px solid var(--border);
        }

        .control-section:last-child {
            border-right: none;
            padding-right: 0;
        }

        .control-section:first-child {
            padding-left: 0;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: var(--card-bg);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn:hover {
            background: var(--card-bg-light);
            border-color: var(--treeplex-primary);
        }

        .btn-primary {
            background: var(--treeplex-primary);
            color: white;
            border-color: var(--treeplex-primary);
        }

        .btn-primary:hover {
            background: var(--treeplex-primary-dark);
        }
/* Pattern Selector */        .pattern-selector {            position: relative;            display: inline-block;        }        .pattern-select {            padding: 8px 12px;            border: 1px solid var(--border);            background: var(--card-bg);            color: var(--text-primary);            border-radius: 6px;            font-size: 13px;            font-weight: 500;            cursor: pointer;            font-family: inherit;            min-width: 180px;        }        .pattern-select:hover {            background-color: var(--card-bg-light);            border-color: var(--treeplex-primary);        }        .pattern-select:focus {            outline: none;            border-color: var(--treeplex-primary);            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);        }

        /* Pan/Zoom Controls */
        .zoom-controls {
            position: fixed;
            top: 90px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: var(--card-bg);
            padding: 12px;
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border);
        }

        .zoom-btn {
            width: 44px;
            height: 44px;
            border: 1px solid var(--border);
            background: var(--card-bg-light);
            color: var(--text-primary);
            border-radius: 8px;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: inherit;
        }

        .zoom-btn:hover {
            background: var(--treeplex-primary);
            border-color: var(--treeplex-primary);
            color: white;
            transform: scale(1.05);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-level {
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            padding: 8px 0;
            border-top: 1px solid var(--border);
            margin-top: 4px;
        }

        /* Tree Container */
        .tree-container {
            padding: 0;
            overflow: hidden;
            min-height: calc(100vh - 70px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background:
                repeating-linear-gradient(45deg, transparent, transparent 40px, rgba(0, 166, 125, 0.03) 40px, rgba(0, 166, 125, 0.03) 80px),
                repeating-linear-gradient(-45deg, transparent, transparent 40px, rgba(59, 143, 204, 0.02) 40px, rgba(59, 143, 204, 0.02) 80px),
                linear-gradient(180deg, #1A1D24 0%, #1E2128 50%, #1A1D24 100%);
            cursor: grab;
        }

        .tree-container.panning {
            cursor: grabbing;
        }

        .tree-transform-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center center;
            transition: transform 0.2s ease-out;
            min-width: 100%;
            min-height: 100%;
        }

        .tree-container::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 166, 125, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(59, 143, 204, 0.06) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(214, 138, 46, 0.04) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }

        .dependency-svg {
            position: absolute;
            top: -5000px;
            left: -5000px;
            width: 20000px;
            height: 20000px;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .dependency-line {
            fill: none;
            stroke: var(--treeplex-primary);
            stroke-width: 3;
            stroke-dasharray: 8, 4;
            opacity: 0.6;
            transition: all 0.3s;
            animation: dash-flow 20s linear infinite;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
        }

        .dependency-line:hover {
            opacity: 1;
            stroke-width: 4;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25));
        }

        .dependency-line.phase-0 {
            stroke: var(--phase-0-dark);
        }

        .dependency-line.phase-1 {
            stroke: var(--phase-1-dark);
        }

        .dependency-line.phase-2 {
            stroke: var(--phase-2-dark);
        }

        .dependency-line.cross-phase {
            stroke: var(--treeplex-primary-dark);
            opacity: 0.7;
            stroke-width: 3.5;
        }

        @keyframes dash-flow {
            to {
                stroke-dashoffset: -100;
            }
        }

        .tree {
            display: flex;
            flex-direction: row;
            gap: 40px;
            align-items: center;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }

        .tree-level {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 12px;
            padding: 20px;
            border-radius: 12px;
            transition: background 0.3s;
        }

        /* Phase-specific backgrounds - subtle gradients */
        .tree-level:has(.phase-0) {
            background: linear-gradient(180deg, rgba(95, 164, 99, 0.03) 0%, rgba(95, 164, 99, 0.08) 100%);
        }

        .tree-level:has(.phase-1) {
            background: linear-gradient(180deg, rgba(59, 143, 204, 0.03) 0%, rgba(59, 143, 204, 0.08) 100%);
        }

        .tree-level:has(.phase-2) {
            background: linear-gradient(180deg, rgba(214, 138, 46, 0.03) 0%, rgba(214, 138, 46, 0.08) 100%);
        }

        .tree-node {
            background: linear-gradient(145deg, var(--card-bg-light), var(--card-bg));
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: var(--shadow-md), 0 0 0 1px rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            min-width: 280px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .tree-node:hover {
            box-shadow: var(--shadow-lg), 0 0 0 1px rgba(255,255,255,0.1);
            transform: translateX(4px) translateY(-2px);
            border-color: var(--treeplex-primary);
            background: linear-gradient(145deg, #3A3F52, var(--card-bg-light));
        }

        .tree-node::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 16px;
            background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
            pointer-events: none;
        }

        .tree-node.root {
            background: linear-gradient(135deg, #4A5568 0%, #2D3748 100%);
            color: white;
            font-size: 20px;
            font-weight: 600;
            min-width: 240px;
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(255, 255, 255, 0.15);
        }

        .tree-node.root:hover {
            box-shadow: var(--shadow-xl);
            background: linear-gradient(135deg, #556577 0%, #3A4556 100%);
        }

        .tree-node.root .node-subtitle {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.85;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 2px;
        }

        .tree-node.phase {
            border-left: 6px solid;
            min-width: 260px;
            position: relative;
            overflow: hidden;
        }

        .tree-node.phase::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: linear-gradient(180deg, var(--phase-color-light), var(--phase-color-dark));
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
        }

        .tree-node.phase-0 {
            border-left-color: var(--phase-0);
            --phase-color-light: var(--phase-0-light);
            --phase-color-dark: var(--phase-0-dark);
        }

        .tree-node.phase-0:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-0);
        }

        .tree-node.phase-1 {
            border-left-color: var(--phase-1);
            --phase-color-light: var(--phase-1-light);
            --phase-color-dark: var(--phase-1-dark);
        }

        .tree-node.phase-1:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-1);
        }

        .tree-node.phase-2 {
            border-left-color: var(--phase-2);
            --phase-color-light: var(--phase-2-light);
            --phase-color-dark: var(--phase-2-dark);
        }

        .tree-node.phase-2:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-2);
        }

        .tree-node.item {
            min-width: 320px;
            max-width: 360px;
            backdrop-filter: blur(4px);
        }

        /* Subtask container - appears below parent item with animation */
        .subtask-container {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            margin-bottom: 8px;
            padding-left: 10px;
            justify-content: flex-start;
            flex-wrap: wrap;
            max-width: 100%;
            animation: slideDownFade 0.4s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            transform-origin: top center;
        }

        @keyframes slideDownFade {
            0% {
                opacity: 0;
                transform: translateY(-40px) scale(0.95);
                max-height: 0;
                filter: blur(6px) brightness(0.5);
            }
            60% {
                filter: blur(1px) brightness(0.9);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                max-height: 500px;
                filter: blur(0) brightness(1);
            }
        }

        /* Subtask styling - compact visual cards */
        .tree-node.item.subtask {
            min-width: 100px;
            max-width: 100px;
            width: 100px;
            min-height: 85px;
            background: rgba(255, 255, 255, 0.06);
            border-left: 3px solid rgba(0, 166, 125, 0.5);
            border-radius: 6px;
            padding: 10px;
            font-size: 10px;
            margin: 0;
            display: inline-flex;
            flex-direction: column;
            vertical-align: top;
            animation: subtaskReveal 0.35s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            opacity: 0;
            transform: translateY(-20px) scale(0.9);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tree-node.item.subtask:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 166, 125, 0.3);
            border-left-color: rgba(0, 166, 125, 0.8);
        }

        /* Staggered animation for subtasks */
        .tree-node.item.subtask:nth-child(1) { animation-delay: 0.05s; }
        .tree-node.item.subtask:nth-child(2) { animation-delay: 0.1s; }
        .tree-node.item.subtask:nth-child(3) { animation-delay: 0.15s; }
        .tree-node.item.subtask:nth-child(4) { animation-delay: 0.2s; }
        .tree-node.item.subtask:nth-child(5) { animation-delay: 0.25s; }
        .tree-node.item.subtask:nth-child(6) { animation-delay: 0.3s; }

        @keyframes subtaskReveal {
            0% {
                opacity: 0;
                transform: translateY(-20px) scale(0.9);
                filter: blur(4px) brightness(0.6);
            }
            70% {
                transform: translateY(2px) scale(1.01);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                filter: blur(0) brightness(1);
            }
        }


        /* Project management fields styling */
        .pm-field {
            font-size: 8px;
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            line-height: 1.1;
        }

        .pm-field-label {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .pm-field-value {
            font-weight: 600;
        }

        .pm-status {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
        }

        .pm-status.todo { background: rgba(156, 163, 175, 0.3); color: #9CA3AF; }
        .pm-status.inprogress { background: rgba(59, 130, 246, 0.3); color: #3B82F6; }
        .pm-status.completed { background: rgba(16, 185, 129, 0.3); color: #10B981; }
        .pm-status.blocked { background: rgba(239, 68, 68, 0.3); color: #EF4444; }

        .pm-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 2px;
        }

        .pm-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            transition: width 0.3s;
        }

        /* Expand/Collapse toggle for items with subtasks */
        .expand-toggle {
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
            display: inline-block;
        }

        .expand-toggle:hover {
            opacity: 1 !important;
            transform: scale(1.3) rotate(90deg);
        }

        /* Items with subtasks have a pointer cursor */
        .tree-node.item:has(.expand-toggle) {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tree-node.item:has(.expand-toggle):hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 166, 125, 0.2);
        }

        .tree-node.item:has(.expand-toggle):active {
            transform: translateY(0);
            transition: all 0.1s ease;
        }

        /* When item has expanded subtasks, add subtle glow and lift effect */
        .tree-node.item.has-expanded-subtasks {
            box-shadow: 0 0 20px rgba(0, 166, 125, 0.4), 0 6px 16px rgba(0, 0, 0, 0.3);
            border-left-color: rgba(0, 166, 125, 0.9);
            border-left-width: 4px;
            transform: translateY(-2px);
            z-index: 10;
            transition: all 0.3s ease;
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .node-icon {
            font-size: 28px;
            flex-shrink: 0;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
            transition: transform 0.3s;
        }

        .tree-node:hover .node-icon {
            transform: scale(1.1);
        }

        .node-content {
            flex: 1;
        }

        .node-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .node-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .node-cost {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-top: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .tree-node.root .node-cost {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.8));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .expand-toggle {
            font-size: 14px;
            opacity: 0.6;
            transition: transform 0.3s;
            margin-left: auto;
        }

        .tree-node.expanded .expand-toggle {
            transform: rotate(90deg);
        }

        .tree-node.collapsed .expand-toggle {
            transform: rotate(0deg);
        }

        /* Item specific */
        .item-name {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .item-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            border: 1px solid;
        }

        .badge-land {
            background: linear-gradient(135deg, rgba(95, 164, 99, 0.3), rgba(74, 140, 78, 0.2));
            color: #81C784;
            border-color: #4A8C4E;
        }
        .badge-engineering {
            background: linear-gradient(135deg, rgba(59, 143, 204, 0.3), rgba(43, 122, 184, 0.2));
            color: #64B5F6;
            border-color: #2B7AB8;
        }
        .badge-professional {
            background: linear-gradient(135deg, rgba(156, 117, 178, 0.3), rgba(128, 90, 150, 0.2));
            color: #BA68C8;
            border-color: #7B4A92;
        }
        .badge-corporate {
            background: linear-gradient(135deg, rgba(130, 130, 130, 0.3), rgba(100, 100, 100, 0.2));
            color: #B0B0B0;
            border-color: #707070;
        }
        .badge-equipment {
            background: linear-gradient(135deg, rgba(214, 138, 46, 0.3), rgba(184, 116, 31, 0.2));
            color: #FFB74D;
            border-color: #B8741F;
        }
        .badge-infrastructure {
            background: linear-gradient(135deg, rgba(233, 98, 158, 0.3), rgba(200, 70, 130, 0.2));
            color: #F48FB1;
            border-color: #C84682;
        }
        .badge-contingency {
            background: linear-gradient(135deg, rgba(229, 115, 115, 0.3), rgba(198, 80, 80, 0.2));
            color: #EF9A9A;
            border-color: #C65050;
        }

        .item-cost {
            font-size: 15px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Connection Lines */
        .tree-node::before {
            content: '';
            position: absolute;
            left: -40px;
            top: 50%;
            width: 40px;
            height: 2px;
            background: var(--border);
        }

        .tree-level:first-child .tree-node::before {
            display: none;
        }

        /* Same-phase dependency indentation indicator */
        .tree-node.item.has-same-phase-dependency::after {
            content: '';
            position: absolute;
            left: -20px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, transparent, var(--treeplex-primary) 20%, var(--treeplex-primary) 80%, transparent);
            opacity: 0.3;
            border-radius: 2px;
        }

        /* Enhanced visual for deeper dependency levels */
        .tree-node.item.has-same-phase-dependency[data-dependency-level="2"]::after {
            opacity: 0.4;
            width: 3px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="3"]::after {
            opacity: 0.5;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="4"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="5"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="6"]::after {
            opacity: 0.6;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency {
            border-left: 2px solid rgba(0, 166, 125, 0.2);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            right: -450px;
            top: 0;
            width: 450px;
            height: 100vh;
            background: var(--card-bg);
            border-left: 1px solid var(--border);
            box-shadow: -4px 0 12px rgba(0,0,0,0.5);
            transition: right 0.3s;
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        .info-panel.open {
            right: 0;
        }

        .info-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-title {
            font-size: 18px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: var(--bg);
        }

        .info-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .info-section {
            margin-bottom: 24px;
        }

        .info-section h4 {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .info-section p {
            font-size: 14px;
            line-height: 1.6;
        }

        .info-section .value {
            font-size: 20px;
            font-weight: 700;
            color: var(--treeplex-primary);
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            font-size: 18px;
            font-weight: 600;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            line-height: 1.7;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
        }

        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--treeplex-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 40px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            display: none;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            padding: 6px;
            min-width: 180px;
            z-index: 1000;
        }

        .context-item {
            padding: 10px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            color: var(--text-primary);
        }

        .context-item:hover {
            background: var(--card-bg-light);
            color: var(--treeplex-primary);
        }

        .context-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
            background: var(--bg);
            color: var(--text-primary);
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--treeplex-primary);
            box-shadow: 0 0 0 3px rgba(0, 166, 125, 0.2);
            background: var(--card-bg-light);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Splash Screen */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1d24 0%, #2a2f3c 50%, #1a1d24 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.5s ease-in;
        }

        #splash-screen.fade-out {
            animation: fadeOut 0.5s ease-out forwards;
        }

        .splash-logo {
            font-size: 72px;
            margin-bottom: 24px;
            animation: logoFloat 2s ease-in-out infinite;
        }

        .splash-title {
            font-size: 48px;
            font-weight: 700;
            color: var(--treeplex-primary);
            margin-bottom: 8px;
            letter-spacing: -1px;
        }

        .splash-subtitle {
            font-size: 20px;
            color: var(--text-secondary);
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 48px;
        }

        .splash-tagline {
            font-size: 16px;
            color: var(--text-primary);
            font-weight: 400;
            margin-bottom: 32px;
            opacity: 0.8;
        }

        .splash-loader {
            width: 200px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .splash-loader-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--phase-1));
            border-radius: 3px;
            animation: loadProgress 2s ease-in-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        @keyframes logoFloat {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes loadProgress {
            0% {
                width: 0%;
            }
            100% {
                width: 100%;
            }
        }
    </style>
    <!-- SheetJS library for Excel export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
</head>
<body>
    <!-- TreeListy by geej Splash Screen -->
    <div id="splash-screen">
        <div class="splash-logo">üå≥</div>
        <div class="splash-title">TreeListy</div>
        <div class="splash-subtitle">by geej</div>
        <div class="splash-tagline">From Complexity to Clarity</div>
        <div class="splash-loader">
            <div class="splash-loader-bar"></div>
        </div>
    </div>

    <!-- Header -->
    <div class="header">
        <div style="display: flex; align-items: center; gap: 20px;">
            <div class="logo">
                <div class="logo-title">
                    <span>üå≥</span>
                    <span>TreeListy</span>
                </div>
                <div class="logo-subtitle">by geej</div>
            </div>
            
        </div>
        <div class="controls">
            <div class="control-section">
                <button class="btn" id="save-json-btn" title="Save project as JSON">üíæ Save</button>
                <button class="btn" id="load-json-btn" title="Load project from JSON">üìÇ Load</button>
            </div>

            <div class="control-section">
                <button class="btn" id="excel-export-btn" style="background: linear-gradient(135deg, #1D6F42, #00A67D);" title="Export to Excel">üìä Excel</button>
            </div>

            <div class="control-section">
                <button class="btn" id="expand-btn" title="Expand all phases">‚¨áÔ∏è Expand</button>
                <button class="btn" id="collapse-btn" title="Collapse all phases">‚¨ÜÔ∏è Collapse</button>
            </div>
<div class="control-section pattern-selector">                <select class="pattern-select" id="pattern-select" title="Choose naming pattern">                    <option value="generic" data-desc="Universal: Project ‚Üí Phase ‚Üí Item ‚Üí Task">üìã Generic Project</option>                    <option value="sales" data-desc="Sales: Pipeline ‚Üí Quarter ‚Üí Deal ‚Üí Action">üíº Sales Pipeline</option>                    <option value="thesis" data-desc="Academic: Thesis ‚Üí Chapter ‚Üí Section ‚Üí Point">üéì Academic Writing</option>                    <option value="roadmap" data-desc="Product: Product ‚Üí Quarter ‚Üí Feature ‚Üí Story">üöÄ Product Roadmap</option>                    <option value="book" data-desc="Writing: Book ‚Üí Part ‚Üí Chapter ‚Üí Scene">üìö Book Writing</option>                    <option value="event" data-desc="Events: Event ‚Üí Stage ‚Üí Activity ‚Üí Task">üéâ Event Planning</option>                    <option value="fitness" data-desc="Fitness: Program ‚Üí Phase ‚Üí Workout ‚Üí Exercise">üí™ Fitness Program</option>                    <option value="strategy" data-desc="Business: Strategy ‚Üí Pillar ‚Üí Initiative ‚Üí Action">üìä Strategic Plan</option>                    <option value="course" data-desc="Education: Course ‚Üí Unit ‚Üí Lesson ‚Üí Exercise">üìñ Course Design</option>                    <option value="film" data-desc="Production: Film ‚Üí Phase ‚Üí Scene ‚Üí Shot">üé¨ Film Production</option>                    <option value="philosophy" data-desc="Philosophy: Treatise ‚Üí Book ‚Üí Argument ‚Üí Premise">ü§î Philosophy</option>                    <option value="familytree" data-desc="Genealogy: Family ‚Üí Generation ‚Üí Person ‚Üí Event">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Family Tree</option>                    <option value="custom" data-desc="Custom: Define your own level names">‚úèÔ∏è Custom Names</option>                </select>            </div>

            <div class="control-section">
                <button class="btn" id="analyze-text-btn" title="Analyze text to detect pattern and create tree structure" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; font-weight: 600;">üîç Analyze Text</button>
            </div>

            <div class="control-section">
                <button class="btn btn-primary" id="ai-btn" title="AI-powered analysis">ü§ñ AI</button>
            </div>

            <div class="control-section">
                <button class="btn" id="api-key-btn" title="Configure your Anthropic API key (optional)">üîë API Key</button>
            </div>

            <div class="control-section">
                <button class="btn" id="how-to-btn" title="How to use TreeListy">üìñ Help</button>
            </div>
        </div>
    </div>

    <!-- Pan/Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" id="zoom-in" title="Zoom In">
            <span>+</span>
        </button>
        <button class="zoom-btn" id="zoom-out" title="Zoom Out">
            <span>‚àí</span>
        </button>
        <button class="zoom-btn" id="zoom-reset" title="Reset View">
            <span>‚ü≤</span>
        </button>
        <div class="zoom-level" id="zoom-level">100%</div>
    </div>

    <!-- Tree -->
    <div class="tree-container" id="tree-container">
        <div class="tree-transform-wrapper" id="tree-transform-wrapper">
            <svg class="dependency-svg" id="dependency-svg"></svg>
            <div class="tree" id="tree-root"></div>
        </div>
    </div>

    <!-- Info Panel -->
    <div class="info-panel" id="info-panel">
        <div class="info-header">
            <div class="info-title" id="info-title">Details</div>
            <button class="close-btn" id="close-info">‚úï</button>
        </div>
        <div class="info-body" id="info-body"></div>
    </div>

    <!-- Context Menu (populated dynamically) -->
    <div class="context-menu" id="context-menu"></div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <div class="modal-header" id="modal-title">AI Analysis</div>
            <div class="modal-body" id="modal-body">
                <div class="spinner"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="modal-close">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="edit-modal">
        <div class="modal-content">
            <div class="modal-header">Edit Item</div>
            <div class="modal-body" id="edit-modal-body"></div>
            <div class="modal-footer">
                <button class="btn" id="edit-cancel">Cancel</button>
                <button class="btn btn-primary" id="edit-save">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Analysis Mode Modal -->
    <div class="modal" id="analysis-modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">üîç Analysis Mode - Convert Text to Tree Structure</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Upload a text file or paste content below. AI will analyze it, detect the best pattern, and convert it into a hierarchical tree structure.
                    </p>
                </div>

                <!-- File Upload Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        üìÅ Upload File (.txt, .md)
                    </label>
                    <div id="file-drop-zone" style="border: 2px dashed var(--border); border-radius: 8px; padding: 32px; text-align: center; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s;">
                        <div style="font-size: 48px; margin-bottom: 12px;">üìÑ</div>
                        <div style="color: var(--text-primary); font-weight: 500; margin-bottom: 4px;">
                            Drop file here or click to browse
                        </div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            Supports .txt and .md files (max 100KB recommended)
                        </div>
                        <input type="file" id="analysis-file-input" accept=".txt,.md" style="display: none;" />
                    </div>
                    <div id="file-name-display" style="margin-top: 8px; color: var(--text-secondary); font-size: 13px; display: none;">
                        Selected: <span id="selected-file-name" style="color: var(--treeplex-primary); font-weight: 500;"></span>
                        <button id="clear-file-btn" style="margin-left: 8px; color: var(--text-secondary); background: none; border: none; cursor: pointer; font-size: 13px;">[Clear]</button>
                    </div>
                </div>

                <div style="text-align: center; margin: 16px 0; color: var(--text-secondary); font-size: 13px; font-weight: 600;">
                    ‚Äî OR ‚Äî
                </div>

                <!-- Paste Text Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        üìù Paste Text
                    </label>
                    <textarea id="analysis-text-input" placeholder="Paste your text content here...

Example:
- Meeting notes
- Project outline
- Research paper
- Strategic plan
- Event agenda
- Course syllabus

The AI will analyze the structure and convert it to a tree."
                        style="width: 100%; min-height: 200px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: 'Inter', monospace; font-size: 13px; resize: vertical;"></textarea>
                    <div id="char-count" style="margin-top: 6px; text-align: right; color: var(--text-secondary); font-size: 12px;">
                        0 characters
                    </div>
                </div>

                <!-- Analysis Mode Selection -->
                <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                    <label style="display: block; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">
                        ‚ö° Analysis Depth
                    </label>
                    <div style="display: flex; gap: 12px;">
                        <label style="flex: 1; display: flex; align-items: flex-start; cursor: pointer; padding: 12px; border: 2px solid var(--border); border-radius: 6px; background: var(--card-bg); transition: all 0.2s;">
                            <input type="radio" name="analysis-mode" value="quick" checked style="margin-top: 3px; margin-right: 10px;" />
                            <div>
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">‚ö° Quick Mode</div>
                                <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                                    Fast pattern detection + basic structure. Recommended for most uses. (~2 API calls, ~$0.01)
                                </div>
                            </div>
                        </label>
                        <label style="flex: 1; display: flex; align-items: flex-start; cursor: pointer; padding: 12px; border: 2px solid var(--border); border-radius: 6px; background: var(--card-bg); transition: all 0.2s;">
                            <input type="radio" name="analysis-mode" value="deep" style="margin-top: 3px; margin-right: 10px;" />
                            <div>
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">üî¨ Deep Mode</div>
                                <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                                    Detailed parsing + field extraction + dependencies. More accurate. (~4-6 API calls, ~$0.03-0.05)
                                </div>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- Warning Display -->
                <div id="analysis-warning" style="display: none; padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px; margin-bottom: 16px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">‚ö†Ô∏è Large File Warning</div>
                    <div id="analysis-warning-text" style="color: var(--text-secondary); font-size: 13px;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="analysis-cancel">Cancel</button>
                <button class="btn btn-primary" id="analysis-start-btn" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">üîç Analyze</button>
            </div>
        </div>
    </div>

    <!-- API Key Configuration Modal -->
    <div class="modal" id="api-key-modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">üîë API Key Configuration</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Analysis Mode requires an Anthropic API key to function. Enter your key below to enable AI-powered text analysis.
                    </p>
                    <div style="padding: 12px 16px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; margin-bottom: 16px;">
                        <div style="color: var(--treeplex-primary); font-weight: 600; margin-bottom: 4px;">üí° How to get an API key:</div>
                        <ol style="color: var(--text-secondary); font-size: 13px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://console.anthropic.com/" target="_blank" style="color: var(--treeplex-primary);">console.anthropic.com</a></li>
                            <li>Sign up or log in to your account</li>
                            <li>Go to API Keys section</li>
                            <li>Create a new API key</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </div>
                </div>

                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                    Anthropic API Key
                </label>
                <input type="password" id="api-key-input" placeholder="sk-ant-..."
                    style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px; margin-bottom: 12px;" />

                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                    <input type="checkbox" id="api-key-show" style="cursor: pointer;" />
                    <label for="api-key-show" style="font-size: 13px; color: var(--text-secondary); cursor: pointer;">Show API key</label>
                </div>

                <div style="padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">üîí Security Note</div>
                    <div style="color: var(--text-secondary); font-size: 13px; line-height: 1.5;">
                        Your API key is stored locally in your browser's session storage and is never sent to any server except Anthropic's API. It will be cleared when you close the browser.
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="api-key-cancel">Cancel</button>
                <button class="btn btn-primary" id="api-key-save" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Save & Continue</button>
            </div>
        </div>
    </div>

    <!-- Hidden file input for JSON upload -->
    <input type="file" id="json-upload-input" accept=".json" style="display: none;" />

    <script>
        console.log('TreeListy - Universal Project Decomposition - Horizontal Layout with Pan/Zoom');

        // =============================================================================
        // PAN & ZOOM SYSTEM
        // =============================================================================

        // Pan/Zoom state
        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startX = 0;
        let startY = 0;

        const MIN_ZOOM = 0.25;  // 25%
        const MAX_ZOOM = 3.0;   // 300%
        const ZOOM_STEP = 0.15; // 15% per click

        // Apply transform to tree
        function applyTransform() {
            const wrapper = document.getElementById('tree-transform-wrapper');
            if (wrapper) {
                wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
                updateZoomDisplay();
            }
        }

        // Update zoom level display
        function updateZoomDisplay() {
            const display = document.getElementById('zoom-level');
            if (display) {
                display.textContent = Math.round(zoomLevel * 100) + '%';
            }
        }

        // Zoom in
        function zoomIn() {
            if (zoomLevel < MAX_ZOOM) {
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
                applyTransform();
            }
        }

        // Zoom out
        function zoomOut() {
            if (zoomLevel > MIN_ZOOM) {
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
                applyTransform();
            }
        }

        // Reset view
        function resetZoom() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            applyTransform();
        }

        // Mouse wheel zoom
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY;

            if (delta < 0) {
                // Scroll up = zoom in
                zoomIn();
            } else {
                // Scroll down = zoom out
                zoomOut();
            }
        }

        // Mouse down - start panning
        function handleMouseDown(e) {
            // Don't pan if clicking on a node or button
            if (e.target.closest('.tree-node') || e.target.closest('button') || e.target.closest('.zoom-controls')) {
                return;
            }

            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;

            const container = document.getElementById('tree-container');
            container.classList.add('panning');
        }

        // Mouse move - pan
        function handleMouseMove(e) {
            if (!isPanning) return;

            panX = e.clientX - startX;
            panY = e.clientY - startY;
            applyTransform();
        }

        // Mouse up - stop panning
        function handleMouseUp(e) {
            if (isPanning) {
                isPanning = false;
                const container = document.getElementById('tree-container');
                container.classList.remove('panning');
            }
        }

        // Initialize pan/zoom after DOM loads
        function initPanZoom() {
            const container = document.getElementById('tree-container');

            // Zoom controls
            document.getElementById('zoom-in').addEventListener('click', zoomIn);
            document.getElementById('zoom-out').addEventListener('click', zoomOut);
            document.getElementById('zoom-reset').addEventListener('click', resetZoom);

            // Mouse wheel
            container.addEventListener('wheel', handleWheel, { passive: false });

            // Mouse drag
            container.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Prevent context menu on drag
            container.addEventListener('contextmenu', (e) => {
                if (isPanning) e.preventDefault();
            });

            console.log('‚úÖ Pan/Zoom initialized');
        }

        // =============================================================================
        // END PAN & ZOOM SYSTEM
        // =============================================================================

        // =============================================================================
        // REAL AI INTEGRATION - Claude by Anthropic (via Netlify Function)
        // =============================================================================

        // API Configuration - Supports both local API key and Netlify serverless function
        const AI_CONFIG = {
            provider: 'anthropic',
            model: 'claude-sonnet-4-20250514',
            // Netlify function endpoint (fallback)
            apiEndpoint: 'https://treelisty.netlify.app/.netlify/functions/claude-proxy',
            // Direct Anthropic API endpoint (when using local API key)
            directEndpoint: 'https://api.anthropic.com/v1/messages'
        };

        // Get local API key from session storage
        function getLocalAPIKey() {
            return sessionStorage.getItem('anthropic_api_key');
        }

        // Set local API key in session storage
        function setLocalAPIKey(key) {
            sessionStorage.setItem('anthropic_api_key', key);
        }

        // Clear local API key
        function clearLocalAPIKey() {
            sessionStorage.removeItem('anthropic_api_key');
        }

        function canUseServerlessAI() {
            return Boolean(AI_CONFIG && typeof AI_CONFIG.apiEndpoint === 'string' && AI_CONFIG.apiEndpoint.length > 0);
        }

        function showApiKeyModal(prefillExisting = false) {
            const apiKeyModal = document.getElementById('api-key-modal');
            const input = document.getElementById('api-key-input');
            const existingKey = getLocalAPIKey();

            input.value = prefillExisting && existingKey ? existingKey : '';
            document.getElementById('api-key-show').checked = false;
            apiKeyModal.style.display = 'flex';
        }

        // Call Claude API - supports both local API key and Netlify function
        async function callClaudeAPI(prompt, systemPrompt = '', maxTokens = 1024, useExtendedThinking = false) {
            const localApiKey = getLocalAPIKey();

            const requestData = {
                model: AI_CONFIG.model,
                max_tokens: maxTokens,
                system: systemPrompt || 'You are an expert project analyst specializing in breaking down complex projects into manageable components.',
                messages: [{
                    role: 'user',
                    content: prompt
                }]
            };

            // Use extended thinking for JSON generation to avoid syntax errors
            if (useExtendedThinking) {
                requestData.thinking = {
                    type: "enabled",
                    budget_tokens: 2000
                };
            }

            let response;

            // Use local API key if available (direct call to Anthropic via CORS proxy)
            if (localApiKey) {
                console.log('üîë Using local API key for Anthropic API call (via CORS proxy for browser compatibility)');

                // Try multiple CORS proxies in case one fails
                const corsProxies = [
                    'https://api.allorigins.win/raw?url=',
                    'https://corsproxy.io/?'
                ];

                let lastError = null;

                // Try each proxy
                for (const corsProxy of corsProxies) {
                    try {
                        console.log(`üîÑ Trying CORS proxy: ${corsProxy.includes('allorigins') ? 'AllOrigins' : 'CorsProxy.io'}`);

                        const apiUrl = encodeURIComponent(AI_CONFIG.directEndpoint);

                        response = await fetch(corsProxy + apiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': localApiKey,
                                'anthropic-version': '2023-06-01'
                            },
                            body: JSON.stringify(requestData)
                        });

                        // If we got a response (even if not ok), break and handle it below
                        if (response) {
                            console.log(`‚úÖ Got response from ${corsProxy.includes('allorigins') ? 'AllOrigins' : 'CorsProxy.io'}`);
                            break;
                        }
                    } catch (proxyError) {
                        console.warn(`‚ö†Ô∏è Proxy failed:`, proxyError);
                        lastError = proxyError;
                        continue; // Try next proxy
                    }
                }

                // If all proxies failed, throw the last error
                if (!response && lastError) {
                    throw new Error(`All CORS proxies failed. Last error: ${lastError.message}`);
                }
            } else {
                // Fallback to Netlify function (API key handled server-side)
                console.log('üåê Using Netlify serverless function');
                response = await fetch(AI_CONFIG.apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
            }

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));

                // Log detailed error info for debugging
                console.error('‚ùå AI API Error Details:', {
                    status: response.status,
                    statusText: response.statusText,
                    usingLocalKey: !!localApiKey,
                    error: error
                });

                // Check for common errors
                if (response.status === 0 || !response.status) {
                    throw new Error('Cannot connect to AI service. Please check your internet connection.');
                }
                if (response.status === 401) {
                    if (localApiKey) {
                        clearLocalAPIKey();
                        throw new Error('Invalid API key. Please check your Anthropic API key and try again.');
                    }
                    throw new Error('Authentication failed. Please configure your API key.');
                }
                if (response.status === 404) {
                    throw new Error('Netlify function not found (404). The serverless function may not be deployed.');
                }
                if (response.status === 429) {
                    throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                }
                if (response.status === 500 && error.error?.message?.includes('configuration')) {
                    throw new Error('AI service is not configured. Please set up your API key.');
                }
                if (response.status === 504) {
                    throw new Error('Request timed out. The text might be too long. Try:\n1. Use a shorter text excerpt (first 10-20 paragraphs)\n2. Use Quick Mode instead of Deep Mode\n3. Try again in a moment');
                }
                throw new Error(error.error?.message || `AI Service Error: ${response.status}`);
            }

            const data = await response.json();
            console.log('‚úÖ AI analysis successful');
            return data.content[0].text;
        }

        // Generate intelligent project analysis
        async function generateAIAnalysis(item, analysisType = 'item') {
            // Determine if this is a subtask or regular item/phase
            const isSubtask = item.type === 'subtask';

            let systemPrompt = '';
            let userPrompt = '';

            if (isSubtask) {
                // SUBTASK AI: Help articulate task details, steps for success, and recommendations
                systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;

            } else if (analysisType === 'subtask') {
                // Same as isSubtask - this is a fallback if analysisType is explicitly set to 'subtask'
                systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;

            } else if (analysisType === 'item') {
                // PROJECT ITEM AI: Provide detail, context, and accuracy
                systemPrompt = `You are a senior project analyst specializing in project decomposition and planning.
Your expertise includes:
- Capital expenditure planning and budgeting
- Procurement strategy and vendor evaluation
- Project timeline and dependency analysis
- Risk assessment for major infrastructure investments
- Cost optimization and value engineering

Provide concise, accurate insights with detailed context formatted with clear sections and bullet points.`;

                userPrompt = `Analyze this project line item for data center project:

**Item:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Cost:** $${(item.cost || 0).toLocaleString()}
**Description:** ${item.description || 'N/A'}
**Lead Time:** ${item.leadTime || 'Not specified'}
**Alternate Source:** ${item.alternateSource || 'Not specified'}
**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Context Notes:** ${item.notes || 'None provided'}

Provide a focused analysis covering:
1. **Risk Assessment** - Key procurement and timeline risks with specific examples
2. **Cost Optimization** - Detailed cost-saving strategies and alternative approaches
3. **Procurement Strategy** - Vendor evaluation criteria and negotiation leverage points
4. **Timeline Considerations** - Critical path impacts, lead time concerns, and scheduling
5. **Industry Context** - Benchmarks, standards, or typical ranges for this expense category
6. **Recommendations** - 2-3 actionable next steps with clear rationale

Prioritize accuracy, detail, and contextual information. Use specific numbers and examples where possible.`;

            } else if (analysisType === 'project') {
                // Project-level analysis
                const allItems = getAllProjectItems();
                const totalCost = calculateTotal(capexTree);
                const itemsByPhase = {
                    'Phase 0': allItems.filter(i => i.id?.startsWith('p0')),
                    'Phase 1': allItems.filter(i => i.id?.startsWith('p1')),
                    'Phase 2': allItems.filter(i => i.id?.startsWith('p2'))
                };

                userPrompt = `Analyze this complete project plan for data center project:

**Total Budget:** $${totalCost.toLocaleString()}

**Phase Breakdown:**
${Object.entries(itemsByPhase).map(([phase, items]) => {
    const phaseTotal = items.reduce((sum, i) => sum + (i.cost || 0), 0);
    return `- ${phase}: ${items.length} items, $${phaseTotal.toLocaleString()}`;
}).join('\n')}

**Major Line Items (>$1M):**
${allItems.filter(i => i.cost > 1000000).map(i =>
    `- ${i.name}: $${i.cost.toLocaleString()} (${i.itemType})`
).join('\n') || 'None'}

**Key Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} depends on ${i.dependencies.length} item(s)`
).join('\n') || 'No dependencies defined'}

Provide an executive-level analysis covering:
1. **Budget Assessment** - Is the allocation realistic for a data center project?
2. **Critical Path** - Key dependencies and timeline bottlenecks
3. **Risk Factors** - Top 3 risks to budget or timeline
4. **Optimization Opportunities** - Potential cost savings or efficiency gains
5. **Strategic Recommendations** - High-level guidance for investors/stakeholders

Format for presentation to executives. Be concise but comprehensive.`;
            }

            return await callClaudeAPI(userPrompt, systemPrompt);
        }

        // Helper to get all items from tree
        function getAllProjectItems(node = capexTree, items = []) {
            if (node.items) items.push(...node.items);
            if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
            return items;
        }

        // =============================================================================
        // END AI INTEGRATION
        // =============================================================================

        // Data - Phases flow chronologically left to right
        let capexTree = {
            id: 'root',
            name: 'My Project',
            type: 'root',
            icon: 'üå≥',
            expanded: true,
            children: [
                {
                    id: 'phase-0',
                    name: 'Phase 0',
                    subtitle: 'Pre-Seed',
                    type: 'phase',
                    phase: '0',
                    icon: 'üå±',
                    expanded: true,
                    items: [
                        {
                            id: 'p0-1762125598237',
                            name: 'New Item',
                            description: 'Enter description',
                            cost: 0,
                            icon: 'üì¶',
                            itemType: 'equipment',
                            type: 'item',
                            dependencies: [],
                            subItems: [
                                {
                                    id: 'p0-1762125598237-sub-1762453827798',
                                    name: 'Task 1',
                                    description: 'Task description',
                                    cost: 0,
                                    icon: 'üìã',
                                    itemType: 'subtask',
                                    type: 'subtask',
                                    dependencies: [],
                                    parentId: 'p0-1762125598237',
                                    pmStatus: 'To Do',
                                    pmAssignee: 'Unassigned',
                                    pmStartDate: '2025-11-06',
                                    pmDueDate: '2025-11-06',
                                    pmProgress: 0,
                                    pmPriority: 'Medium',
                                    pmNotes: '',
                                    pmBlockingIssue: '',
                                    pmNextSteps: '',
                                    pmUpdates: [],
                                    subItems: []
                                },
                                {
                                    id: 'p0-1762125598237-sub-1762453836667',
                                    name: 'Task 2',
                                    description: 'Task description',
                                    cost: 0,
                                    icon: 'üìã',
                                    itemType: 'subtask',
                                    type: 'subtask',
                                    dependencies: [],
                                    parentId: 'p0-1762125598237',
                                    pmStatus: 'To Do',
                                    pmAssignee: 'Unassigned',
                                    pmStartDate: '2025-11-06',
                                    pmDueDate: '2025-11-06',
                                    pmProgress: 0,
                                    pmPriority: 'Medium',
                                    pmNotes: '',
                                    pmBlockingIssue: '',
                                    pmNextSteps: '',
                                    pmUpdates: [],
                                    subItems: []
                                }
                            ],
                            expanded: true
                        }
                    ],
                    children: [
                        {
                            id: 'phase-1',
                            name: 'Phase 1',
                            subtitle: 'Seed',
                            type: 'phase',
                            phase: '1',
                            icon: 'üöÄ',
                            expanded: true,
                            items: [
                                {
                                    id: 'p1-1762125603889',
                                    name: 'New Item',
                                    description: 'Enter description',
                                    cost: 0,
                                    icon: 'üì¶',
                                    itemType: 'equipment',
                                    type: 'item',
                                    dependencies: ['p0-1762125598237'],
                                    subItems: [
                                        {
                                            id: 'p1-1762125603889-sub-1762453866145',
                                            name: 'Task 1',
                                            description: 'Task description',
                                            cost: 0,
                                            icon: 'üìã',
                                            itemType: 'subtask',
                                            type: 'subtask',
                                            dependencies: [],
                                            parentId: 'p1-1762125603889',
                                            pmStatus: 'To Do',
                                            pmAssignee: 'Unassigned',
                                            pmStartDate: '2025-11-06',
                                            pmDueDate: '2025-11-06',
                                            pmProgress: 0,
                                            pmPriority: 'Medium',
                                            pmNotes: '',
                                            pmBlockingIssue: '',
                                            pmNextSteps: '',
                                            pmUpdates: [],
                                            subItems: []
                                        }
                                    ],
                                    expanded: true,
                                    alternateSource: '',
                                    leadTime: '',
                                    notes: ''
                                }
                            ],
                            children: [
                                {
                                    id: 'phase-2',
                                    name: 'Phase 2',
                                    subtitle: 'Build',
                                    type: 'phase',
                                    phase: '2',
                                    icon: 'üè≠',
                                    expanded: true,
                                    items: [
                                        {
                                            id: 'p2-1762125606965',
                                            name: 'New Item',
                                            description: 'Enter description',
                                            cost: 0,
                                            icon: 'üì¶',
                                            itemType: 'equipment',
                                            type: 'item',
                                            dependencies: [],
                                            subItems: [
                                                {
                                                    id: 'p2-1762125606965-sub-1762453851549',
                                                    name: 'Task 1',
                                                    description: 'Task description',
                                                    cost: 0,
                                                    icon: 'üìã',
                                                    itemType: 'subtask',
                                                    type: 'subtask',
                                                    dependencies: [],
                                                    parentId: 'p2-1762125606965',
                                                    pmStatus: 'To Do',
                                                    pmAssignee: 'Unassigned',
                                                    pmStartDate: '2025-11-06',
                                                    pmDueDate: '2025-11-06',
                                                    pmProgress: 0,
                                                    pmPriority: 'Medium',
                                                    pmNotes: '',
                                                    pmBlockingIssue: '',
                                                    pmNextSteps: '',
                                                    pmUpdates: [],
                                                    subItems: []
                                                }
                                            ],
                                            expanded: true
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        };
// TREEPLEXITY PATTERN SELECTOR
// Insert this code into treelisty.html

// ============================================================================
// PATTERN DEFINITIONS
// ============================================================================

const PATTERNS = {
    generic: {
        name: 'Generic Project',
        icon: 'üìã',
        levels: {
            root: 'Project',
            phase: 'Phase',
            item: 'Item',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Seed', 'Seed', 'Build'],
        types: [
            { value: 'land', label: 'Land' },
            { value: 'engineering', label: 'Engineering' },
            { value: 'equipment', label: 'Equipment' },
            { value: 'infrastructure', label: 'Infrastructure' },
            { value: 'corporate', label: 'Corporate' },
            { value: 'professional', label: 'Professional' },
            { value: 'contingency', label: 'Contingency' }
        ],
        description: 'Universal structure for any project',
        fields: {
            cost: { label: 'Cost ($)', type: 'number', step: 1000, helpText: 'üí∞ Budget allocated for this item' },
            alternateSource: { label: 'Alternate Source', type: 'text', placeholder: 'Backup vendor, supplier, or alternative solution...', helpText: 'üì¶ Alternative supplier or backup option for risk mitigation' },
            leadTime: { label: 'Lead Time', type: 'text', placeholder: 'e.g., 12-18 months, 6 weeks, 90 days...', helpText: '‚è±Ô∏è Expected procurement or delivery timeline' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    sales: {
        name: 'Sales Pipeline',
        icon: 'üíº',
        levels: {
            root: 'Pipeline',
            phase: 'Quarter',
            item: 'Deal',
            subtask: 'Action'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'inbound', label: 'Inbound Lead' },
            { value: 'outbound', label: 'Outbound Prospect' },
            { value: 'partnership', label: 'Partnership' },
            { value: 'expansion', label: 'Account Expansion' },
            { value: 'renewal', label: 'Renewal' },
            { value: 'upsell', label: 'Upsell' },
            { value: 'cross-sell', label: 'Cross-sell' },
            { value: 'enterprise', label: 'Enterprise Deal' }
        ],
        description: 'Track sales opportunities through quarters',
        fields: {
            dealValue: { label: 'Deal Value ($)', type: 'number', step: 1000, helpText: 'üí∞ Potential revenue from this deal' },
            expectedCloseDate: { label: 'Expected Close Date', type: 'date', helpText: 'üìÖ Target date to close this deal' },
            leadSource: { label: 'Lead Source', type: 'text', placeholder: 'Inbound, Referral, Cold Outreach...', helpText: 'üìç How did this lead originate?' },
            contactPerson: { label: 'Contact Person', type: 'text', placeholder: 'Primary contact name...', helpText: 'üë§ Main decision maker or champion' },
            stageProbability: { label: 'Stage Probability (%)', type: 'number', min: 0, max: 100, step: 5, helpText: 'üìä Likelihood of closing this deal' },
            competitorInfo: { label: 'Competitor Info', type: 'textarea', placeholder: 'Who else is competing for this deal...', helpText: 'üéØ Other vendors in consideration' },
            includeDependencies: false,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    thesis: {
        name: 'Academic Writing',
        icon: 'üéì',
        levels: {
            root: 'Thesis',
            phase: 'Chapter',
            item: 'Section',
            subtask: 'Point'
        },
        phaseSubtitles: ['Introduction', 'Body', 'Conclusion'],
        types: [
            { value: 'literature-review', label: 'Literature Review' },
            { value: 'methodology', label: 'Methodology' },
            { value: 'analysis', label: 'Analysis' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'theory', label: 'Theoretical Framework' },
            { value: 'evidence', label: 'Evidence' },
            { value: 'argument', label: 'Argument' },
            { value: 'conclusion', label: 'Conclusion' }
        ],
        description: 'Structure academic papers and dissertations',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'üìù Current word count for this section' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'üéØ Goal word count for this section' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: '‚úèÔ∏è Current revision stage' },
            citations: { label: 'Key Citations', type: 'textarea', placeholder: 'List main sources and references...', helpText: 'üìö Important sources for this section' },
            keyArgument: { label: 'Key Argument', type: 'textarea', placeholder: 'Main point of this section...', helpText: 'üí° Central claim or thesis' },
            evidenceType: { label: 'Evidence Type', type: 'select', options: ['Empirical', 'Theoretical', 'Mixed', 'N/A'], helpText: 'üî¨ Nature of supporting evidence' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    roadmap: {
        name: 'Product Roadmap',
        icon: 'üöÄ',
        levels: {
            root: 'Product',
            phase: 'Quarter',
            item: 'Feature',
            subtask: 'Story'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'core-feature', label: 'Core Feature' },
            { value: 'enhancement', label: 'Enhancement' },
            { value: 'bug-fix', label: 'Bug Fix' },
            { value: 'technical-debt', label: 'Technical Debt' },
            { value: 'research', label: 'Research/Spike' },
            { value: 'platform', label: 'Platform' },
            { value: 'integration', label: 'Integration' },
            { value: 'ux', label: 'UX Improvement' }
        ],
        description: 'Plan product features across quarters',
        fields: {
            storyPoints: { label: 'Story Points', type: 'number', min: 0, step: 1, placeholder: '1, 2, 3, 5, 8, 13...', helpText: 'üéØ Effort estimate (Fibonacci scale)' },
            engineeringEstimate: { label: 'Engineering Estimate', type: 'text', placeholder: '2 weeks, 1 sprint, 3 days...', helpText: '‚è±Ô∏è Time estimate from engineering' },
            userImpact: { label: 'User Impact', type: 'select', options: ['High', 'Medium', 'Low'], helpText: 'üë• How many users does this affect?' },
            technicalRisk: { label: 'Technical Risk', type: 'select', options: ['Low', 'Medium', 'High', 'Unknown'], helpText: '‚ö†Ô∏è Complexity and technical uncertainty' },
            featureFlag: { label: 'Feature Flag', type: 'text', placeholder: 'flag_name...', helpText: 'üö© Feature flag for gradual rollout' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    book: {
        name: 'Book Writing',
        icon: 'üìö',
        levels: {
            root: 'Book',
            phase: 'Part',
            item: 'Chapter',
            subtask: 'Scene'
        },
        phaseSubtitles: ['Act I', 'Act II', 'Act III'],
        types: [
            { value: 'narrative', label: 'Narrative' },
            { value: 'dialogue', label: 'Dialogue' },
            { value: 'description', label: 'Description' },
            { value: 'action', label: 'Action' },
            { value: 'reflection', label: 'Reflection' },
            { value: 'transition', label: 'Transition' },
            { value: 'climax', label: 'Climax' },
            { value: 'exposition', label: 'Exposition' }
        ],
        description: 'Organize books into parts, chapters, and scenes',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'üìù Current word count' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'üéØ Goal word count' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: '‚úèÔ∏è Current revision stage' },
            povCharacter: { label: 'POV Character', type: 'text', placeholder: 'Whose perspective...', helpText: 'üë§ Point-of-view character' },
            sceneSetting: { label: 'Scene Setting', type: 'textarea', placeholder: 'Location, time, mood...', helpText: 'üé≠ Where and when this takes place' },
            plotFunction: { label: 'Plot Function', type: 'select', options: ['Setup', 'Conflict', 'Resolution', 'Transition'], helpText: 'üìñ Role in story structure' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    event: {
        name: 'Event Planning',
        icon: 'üéâ',
        levels: {
            root: 'Event',
            phase: 'Stage',
            item: 'Activity',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Event', 'Event Day', 'Post-Event'],
        types: [
            { value: 'logistics', label: 'Logistics' },
            { value: 'catering', label: 'Catering' },
            { value: 'entertainment', label: 'Entertainment' },
            { value: 'venue', label: 'Venue' },
            { value: 'marketing', label: 'Marketing' },
            { value: 'registration', label: 'Registration' },
            { value: 'follow-up', label: 'Follow-up' },
            { value: 'av-tech', label: 'AV/Tech' }
        ],
        description: 'Plan events from prep to execution to follow-up',
        fields: {
            budget: { label: 'Budget ($)', type: 'number', step: 100, helpText: 'üí∞ Budget for this activity' },
            vendor: { label: 'Vendor/Supplier', type: 'text', placeholder: 'Company or person name...', helpText: 'üè¢ External vendor or supplier' },
            bookingDeadline: { label: 'Booking Deadline', type: 'date', helpText: 'üìÖ Last date to book/reserve' },
            guestCount: { label: 'Guest Count', type: 'number', min: 0, placeholder: 'Expected attendees...', helpText: 'üë• Number of expected guests' },
            location: { label: 'Location', type: 'text', placeholder: 'Venue, room, area...', helpText: 'üìç Where this takes place' },
            responsiblePerson: { label: 'Responsible Person', type: 'text', placeholder: 'Team member name...', helpText: 'üë§ Who\'s handling this' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    fitness: {
        name: 'Fitness Program',
        icon: 'üí™',
        levels: {
            root: 'Program',
            phase: 'Phase',
            item: 'Workout',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Foundation', 'Build', 'Peak'],
        types: [
            { value: 'strength', label: 'Strength Training' },
            { value: 'cardio', label: 'Cardio' },
            { value: 'flexibility', label: 'Flexibility' },
            { value: 'recovery', label: 'Recovery' },
            { value: 'nutrition', label: 'Nutrition' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'conditioning', label: 'Conditioning' },
            { value: 'mobility', label: 'Mobility' }
        ],
        description: 'Structure training programs with periodization',
        fields: {
            sets: { label: 'Sets', type: 'number', min: 0, step: 1, placeholder: 'Number of sets...', helpText: 'üî¢ Number of sets' },
            reps: { label: 'Reps', type: 'text', placeholder: '8-12, 10, AMRAP...', helpText: 'üîÅ Repetitions per set' },
            duration: { label: 'Duration', type: 'text', placeholder: '30 minutes, 45 sec...', helpText: '‚è±Ô∏è Time for this exercise/workout' },
            intensity: { label: 'Intensity Level', type: 'select', options: ['Light', 'Moderate', 'High', 'Max'], helpText: 'üî• Effort level' },
            equipment: { label: 'Equipment Needed', type: 'text', placeholder: 'Dumbbells, Barbell, Bodyweight...', helpText: 'üèãÔ∏è Required equipment' },
            formCues: { label: 'Form Cues', type: 'textarea', placeholder: 'Key technique reminders...', helpText: '‚úÖ Important form tips' },
            restPeriod: { label: 'Rest Period', type: 'text', placeholder: '60 sec, 2 min...', helpText: '‚è∏Ô∏è Rest between sets' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    strategy: {
        name: 'Strategic Plan',
        icon: 'üìä',
        levels: {
            root: 'Strategy',
            phase: 'Pillar',
            item: 'Initiative',
            subtask: 'Action'
        },
        phaseSubtitles: ['Planning', 'Execution', 'Review'],
        types: [
            { value: 'market-expansion', label: 'Market Expansion' },
            { value: 'operational', label: 'Operational Excellence' },
            { value: 'financial', label: 'Financial' },
            { value: 'hr', label: 'Human Resources' },
            { value: 'technology', label: 'Technology' },
            { value: 'risk-management', label: 'Risk Management' },
            { value: 'innovation', label: 'Innovation' },
            { value: 'customer', label: 'Customer Experience' }
        ],
        description: 'Organize business strategy into pillars and initiatives',
        fields: {
            investment: { label: 'Investment ($)', type: 'number', step: 10000, helpText: 'üí∞ Capital investment required' },
            keyMetric: { label: 'Key Metric', type: 'text', placeholder: 'What defines success...', helpText: 'üìä Success measurement' },
            targetValue: { label: 'Target Value', type: 'text', placeholder: 'Goal for metric...', helpText: 'üéØ Goal to achieve' },
            responsibleExecutive: { label: 'Responsible Executive', type: 'text', placeholder: 'C-level owner...', helpText: 'üëî Executive sponsor' },
            strategicTheme: { label: 'Strategic Theme', type: 'select', options: ['Growth', 'Efficiency', 'Innovation', 'Transformation', 'Risk Mitigation'], helpText: 'üé≠ Strategic category' },
            riskLevel: { label: 'Risk Level', type: 'select', options: ['Low', 'Medium', 'High'], helpText: '‚ö†Ô∏è Implementation risk' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    course: {
        name: 'Course Design',
        icon: 'üìñ',
        levels: {
            root: 'Course',
            phase: 'Unit',
            item: 'Lesson',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Beginning', 'Middle', 'Advanced'],
        types: [
            { value: 'lecture', label: 'Lecture' },
            { value: 'lab', label: 'Lab/Practical' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'reading', label: 'Reading' },
            { value: 'project', label: 'Project' },
            { value: 'workshop', label: 'Workshop' },
            { value: 'field-work', label: 'Field Work' }
        ],
        description: 'Build educational curricula with units and lessons',
        fields: {
            learningObjectives: { label: 'Learning Objectives', type: 'textarea', placeholder: 'What students will learn...', helpText: 'üéì Expected learning outcomes' },
            duration: { label: 'Duration', type: 'text', placeholder: '50 minutes, 2 hours...', helpText: '‚è±Ô∏è Class time needed' },
            difficultyLevel: { label: 'Difficulty Level', type: 'select', options: ['Beginner', 'Intermediate', 'Advanced'], helpText: 'üìä Complexity level' },
            prerequisites: { label: 'Prerequisites', type: 'textarea', placeholder: 'Prior knowledge needed...', helpText: 'üìã Required background' },
            assessmentType: { label: 'Assessment Type', type: 'select', options: ['Quiz', 'Assignment', 'Project', 'Discussion', 'Exam', 'None'], helpText: '‚úÖ How learning is evaluated' },
            resourcesNeeded: { label: 'Resources Needed', type: 'textarea', placeholder: 'Textbook chapters, videos, materials...', helpText: 'üìö Required materials' },
            homework: { label: 'Homework', type: 'textarea', placeholder: 'Out-of-class work...', helpText: 'üìù Assignments for students' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    film: {
        name: 'Film Production',
        icon: 'üé¨',
        levels: {
            root: 'Film',
            phase: 'Phase',
            item: 'Scene',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Pre-Production', 'Production', 'Post-Production'],
        types: [
            { value: 'pre-production', label: 'Pre-Production' },
            { value: 'production', label: 'Production' },
            { value: 'post-production', label: 'Post-Production' },
            { value: 'vfx', label: 'VFX' },
            { value: 'sound', label: 'Sound Design' },
            { value: 'marketing', label: 'Marketing' },
            { value: 'distribution', label: 'Distribution' },
            { value: 'location', label: 'Location' }
        ],
        description: 'Organize pre-production, production, and post-production',
        fields: {
            budget: { label: 'Budget ($)', type: 'number', step: 1000, helpText: 'üí∞ Budget for this scene/shot' },
            shootDuration: { label: 'Shoot Duration', type: 'text', placeholder: '2 hours, half day...', helpText: '‚è±Ô∏è Time needed to shoot' },
            location: { label: 'Location', type: 'text', placeholder: 'Where to shoot...', helpText: 'üìç Filming location' },
            castRequired: { label: 'Cast Required', type: 'textarea', placeholder: 'Which actors...', helpText: 'üé≠ Actors needed' },
            crewNeeded: { label: 'Crew Needed', type: 'textarea', placeholder: 'Camera, sound, etc...', helpText: 'üë• Crew requirements' },
            equipment: { label: 'Equipment', type: 'textarea', placeholder: 'Camera, lighting, props...', helpText: 'üé• Technical equipment needed' },
            shotType: { label: 'Shot Type', type: 'select', options: ['Wide', 'Medium', 'Close-up', 'POV', 'Over Shoulder', 'Establishing'], helpText: 'üìπ Camera framing' },
            sceneNumber: { label: 'Scene Number', type: 'text', placeholder: 'For continuity...', helpText: 'üé¨ Script scene number' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    philosophy: {
        name: 'Philosophy',
        icon: 'ü§î',
        levels: {
            root: 'Treatise',
            phase: 'Book',
            item: 'Argument',
            subtask: 'Premise'
        },
        phaseSubtitles: ['Exposition', 'Dialectic', 'Resolution'],
        types: [
            { value: 'metaphysical', label: 'Metaphysical' },
            { value: 'epistemological', label: 'Epistemological' },
            { value: 'ethical', label: 'Ethical' },
            { value: 'political', label: 'Political' },
            { value: 'logical', label: 'Logical' },
            { value: 'aesthetic', label: 'Aesthetic' },
            { value: 'existential', label: 'Existential' },
            { value: 'phenomenological', label: 'Phenomenological' }
        ],
        description: 'Structure philosophical treatises and arguments',
        fields: {
            philosopher: { label: 'Philosopher', type: 'text', placeholder: 'Who made this argument...', helpText: 'üß† Original thinker' },
            schoolOfThought: { label: 'School of Thought', type: 'text', placeholder: 'Rationalism, Empiricism, etc...', helpText: 'üèõÔ∏è Philosophical tradition' },
            timePeriod: { label: 'Time Period', type: 'select', options: ['Ancient', 'Medieval', 'Early Modern', 'Modern', 'Contemporary'], helpText: 'üìÖ Historical context' },
            primarySource: { label: 'Primary Source', type: 'text', placeholder: 'Original text citation...', helpText: 'üìñ Source text reference' },
            counterargument: { label: 'Counterargument', type: 'textarea', placeholder: 'Main objection...', helpText: '‚ùì Key objection to address' },
            response: { label: 'Response', type: 'textarea', placeholder: 'How argument addresses objection...', helpText: 'üí° Defense or reply' },
            supportingEvidence: { label: 'Supporting Evidence', type: 'textarea', placeholder: 'Logical or empirical support...', helpText: '‚úì Evidence for this claim' },
            logicalForm: { label: 'Logical Form', type: 'select', options: ['Deductive', 'Inductive', 'Abductive', 'Dialectical'], helpText: '‚öñÔ∏è Type of reasoning' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    familytree: {
        name: 'Family Tree',
        icon: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
        levels: {
            root: 'Family',
            phase: 'Generation',
            item: 'Person',
            subtask: 'Event'
        },
        phaseSubtitles: ['Self/Siblings', 'Parents', 'Grandparents', 'Great-Grandparents', 'Great-Great-Grandparents', 'Children', 'Grandchildren', 'Great-Grandchildren'],
        types: [
            { value: 'paternal', label: 'Paternal Line' },
            { value: 'maternal', label: 'Maternal Line' },
            { value: 'spouse', label: 'Spouse' },
            { value: 'biological', label: 'Biological' },
            { value: 'adopted', label: 'Adopted' },
            { value: 'step', label: 'Step-Family' },
            { value: 'foster', label: 'Foster' },
            { value: 'half', label: 'Half-Sibling' }
        ],
        description: 'Build and document your family genealogy',
        fields: {
            fullName: { label: 'Full Name', type: 'text', placeholder: 'First Middle Last...', helpText: 'üë§ Complete name including middle names' },
            maidenName: { label: 'Maiden Name', type: 'text', placeholder: 'Birth surname if different...', helpText: 'üíç Birth surname (if changed after marriage)' },
            gender: { label: 'Gender', type: 'select', options: ['Male', 'Female', 'Other', 'Unknown'], helpText: '‚öß Gender identity' },
            birthDate: { label: 'Birth Date', type: 'date', helpText: 'üéÇ Date of birth' },
            birthPlace: { label: 'Birth Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'üìç Place of birth (city, state, country)' },
            livingStatus: { label: 'Living Status', type: 'select', options: ['Living', 'Deceased', 'Unknown'], helpText: 'üíö Current living status' },
            deathDate: { label: 'Death Date', type: 'date', helpText: 'üïäÔ∏è Date of death (if deceased)' },
            deathPlace: { label: 'Death Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'üìç Place of death (if deceased)' },
            marriageDate: { label: 'Marriage Date', type: 'date', helpText: 'üíí Date of marriage' },
            marriagePlace: { label: 'Marriage Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'üìç Place of marriage ceremony' },
            spouseName: { label: 'Spouse Name', type: 'text', placeholder: 'Name of spouse...', helpText: 'üíë Current or former spouse' },
            occupation: { label: 'Occupation', type: 'text', placeholder: 'Profession or career...', helpText: 'üíº Primary occupation or career' },
            photoURL: { label: 'Photo URL', type: 'text', placeholder: 'https://...', helpText: 'üì∑ Link to portrait or photo' },
            dnaInfo: { label: 'DNA/Genetic Info', type: 'textarea', placeholder: 'Haplogroup, DNA matches, test results...', helpText: 'üß¨ DNA test results, haplogroups, genetic markers' },
            sources: { label: 'Sources/Citations', type: 'textarea', placeholder: 'Documents, certificates, records...', helpText: 'üìÑ Birth certificates, census records, documents' },
            relationshipType: { label: 'Relationship Type', type: 'select', options: ['Biological', 'Adopted', 'Step', 'Foster', 'Half-Sibling', 'Unknown'], helpText: 'üîó Type of family relationship' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    custom: {
        name: 'Custom Names',
        icon: '‚úèÔ∏è',
        levels: {
            root: 'Level 0',
            phase: 'Level 1',
            item: 'Level 2',
            subtask: 'Level 3'
        },
        description: 'Define your own names for all four levels',
        customizable: true
    }
};

// ============================================================================
// PATTERN STATE
// ============================================================================

let currentPattern = 'generic';
let customPatternNames = null;

// ============================================================================
// PATTERN FUNCTIONS
// ============================================================================

function getPatternLabels() {
    console.log('getPatternLabels called, currentPattern:', currentPattern);
    if (currentPattern === 'custom' && customPatternNames) {
        console.log('Returning custom labels:', customPatternNames);
        return customPatternNames;
    }
    const labels = PATTERNS[currentPattern].levels;
    console.log('Returning pattern labels:', labels);
    return labels;
}

function renameNodesForPattern(node, labels) {
    if (!node) return;

    // Collect all possible terms from all patterns for replacement
    const allRootTerms = ['Project', 'Pipeline', 'Thesis', 'Product', 'Book', 'Event', 'Program', 'Strategy', 'Course', 'Film', 'Treatise', 'Family'];
    const allPhaseTerms = ['Phase', 'Quarter', 'Chapter', 'Part', 'Stage', 'Pillar', 'Unit', 'Generation'];
    const allItemTerms = ['Item', 'Deal', 'Section', 'Feature', 'Chapter', 'Activity', 'Workout', 'Initiative', 'Lesson', 'Scene', 'Argument', 'Person'];
    const allSubtaskTerms = ['Task', 'Sub-task', 'Action', 'Point', 'Story', 'Scene', 'Exercise', 'Shot', 'Premise', 'Event'];

    // Rename based on node type - replace ANY pattern term with the new one
    if (node.type === 'root') {
        // Try to replace any root term from any pattern
        for (const term of allRootTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.root);
        }
    } else if (node.type === 'phase') {
        // Try to replace any phase term from any pattern
        for (const term of allPhaseTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.phase);
        }
        // Update phase subtitle based on pattern
        if (PATTERNS[currentPattern].phaseSubtitles && node.phase !== undefined) {
            const phaseIndex = parseInt(node.phase);
            if (!isNaN(phaseIndex) && phaseIndex < PATTERNS[currentPattern].phaseSubtitles.length) {
                node.subtitle = PATTERNS[currentPattern].phaseSubtitles[phaseIndex];
            }
        }
    } else if (node.type === 'item') {
        // Try to replace any item term from any pattern
        for (const term of allItemTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.item);
        }
    } else if (node.type === 'subtask') {
        // Try to replace any subtask term from any pattern
        for (const term of allSubtaskTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.subtask);
        }
    }

    // Recursively process children
    if (node.children) {
        node.children.forEach(child => renameNodesForPattern(child, labels));
    }

    // Process items in phases
    if (node.items) {
        node.items.forEach(item => {
            renameNodesForPattern(item, labels);
            // Process subtasks
            if (item.subItems) {
                item.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
            }
        });
    }

    // Process nested subtasks
    if (node.subItems) {
        node.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
    }
}

function applyPattern(patternKey) {
    console.log('applyPattern called with:', patternKey);
    currentPattern = patternKey;

    if (patternKey === 'custom') {
        showCustomPatternDialog();
    } else {
        // Store in data
        if (!capexTree.pattern) {
            capexTree.pattern = {};
        }
        capexTree.pattern.key = patternKey;
        capexTree.pattern.labels = PATTERNS[patternKey].levels;
        console.log('Pattern applied:', PATTERNS[patternKey].name);
        console.log('New labels:', PATTERNS[patternKey].levels);

        // Auto-rename existing nodes to match pattern
        renameNodesForPattern(capexTree, PATTERNS[patternKey].levels);
        console.log('Nodes renamed to match pattern');

        // Re-render to apply new labels
        render();
    }
}

function showCustomPatternDialog() {
    const pattern = PATTERNS[currentPattern];
    const currentLabels = customPatternNames || pattern.levels;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = `
        <div style="padding: 20px;">
            <h3 style="color: var(--treeplex-primary); margin-bottom: 20px;">Custom Pattern Names</h3>
            <p style="margin-bottom: 20px; color: var(--text-secondary); font-size: 14px;">
                Define your own names for each level of your project structure.
            </p>

            <div style="display: flex; flex-direction: column; gap: 16px;">
                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 0 (Root):
                    </label>
                    <input type="text" id="custom-root" value="${currentLabels.root}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Project, Campaign, Thesis">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 1 (Phase):
                    </label>
                    <input type="text" id="custom-phase" value="${currentLabels.phase}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Phase, Quarter, Chapter">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 2 (Item):
                    </label>
                    <input type="text" id="custom-item" value="${currentLabels.item}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Item, Feature, Section">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 3 (Subtask):
                    </label>
                    <input type="text" id="custom-subtask" value="${currentLabels.subtask}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Task, Story, Point">
                </div>
            </div>

            <div style="display: flex; gap: 12px; margin-top: 24px;">
                <button class="btn btn-primary" onclick="saveCustomPattern()" style="flex: 1;">
                    ‚úì Apply Custom Names
                </button>
                <button class="btn" onclick="closeModal()" style="flex: 1;">
                    Cancel
                </button>
            </div>
        </div>
    `;

    document.getElementById('modal').style.display = 'flex';
}

function saveCustomPattern() {
    const root = document.getElementById('custom-root').value.trim() || 'Level 0';
    const phase = document.getElementById('custom-phase').value.trim() || 'Level 1';
    const item = document.getElementById('custom-item').value.trim() || 'Level 2';
    const subtask = document.getElementById('custom-subtask').value.trim() || 'Level 3';

    customPatternNames = { root, phase, item, subtask };

    // Store in data
    if (!capexTree.pattern) {
        capexTree.pattern = {};
    }
    capexTree.pattern.key = 'custom';
    capexTree.pattern.labels = customPatternNames;

    closeModal();
    render();
}

// ============================================================================
// INITIALIZATION
// ============================================================================


function showPatternDescription() {
    const select = document.getElementById('pattern-select');
    const selectedOption = select.options[select.selectedIndex];
    const desc = selectedOption.getAttribute('data-desc');

    if (desc) {
        select.setAttribute('title', desc);
    }
}

function hidePatternDescription() {
    // Keep title for basic tooltip
}

        // State
        let activeNode = null;

        // Utilities
        function formatCost(cost) {
            if (cost >= 1000000) return '$' + (cost / 1000000).toFixed(1) + 'M';
            if (cost >= 1000) return '$' + (cost / 1000).toFixed(0) + 'k';
            return '$' + cost.toLocaleString();
        }

        // Calculate total including all children (for root node)
        function calculateTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            if (node.children) {
                node.children.forEach(child => {
                    total += calculateTotal(child);
                });
            }
            return total;
        }

        // Calculate only items in this phase (NOT children phases)
        function calculatePhaseTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            return total;
        }

        function findNode(id, node = capexTree) {
            if (node.id === id) return node;
            if (node.children) {
                for (let child of node.children) {
                    const found = findNode(id, child);
                    if (found) return found;
                }
            }
            return null;
        }

        // Render tree - phases flow left to right
        function render() {
            const container = document.getElementById('tree-root');
            container.innerHTML = '';

            const tableEl = document.createElement('div');
            tableEl.className = 'tree';

            // Traverse and build columns
            function buildColumn(node) {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'tree-level';

                // Render current node
                const nodeDiv = document.createElement('div');
                nodeDiv.className = `tree-node ${node.type}`;
                if (node.type === 'phase') nodeDiv.classList.add(`phase-${node.phase}`);
                if (node.expanded) nodeDiv.classList.add('expanded');
                else nodeDiv.classList.add('collapsed');

                nodeDiv.dataset.nodeId = node.id;

                if (node.type === 'root') {
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon}</span>
                            <div class="node-content">
                                <div class="node-title">${node.name}</div>
                                <div class="node-subtitle">by geej</div>
                            </div>
                            ${node.children ? '<span class="expand-toggle">‚ñ∂</span>' : ''}
                        </div>
                    `;
                } else if (node.type === 'phase') {
                    const total = calculatePhaseTotal(node);
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon}</span>
                            <div class="node-content">
                                <div class="node-title">${node.name}</div>
                                <div class="node-subtitle">${node.subtitle}</div>
                                ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<div class="node-cost">${formatCost(total)}</div>` : ''}
                            </div>
                            ${node.items || node.children ? '<span class="expand-toggle">‚ñ∂</span>' : ''}
                        </div>
                    `;
                } else {
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon}</span>
                            <div class="node-content">
                                <div class="item-name">${node.name}</div>
                                <div class="item-description">${node.description}</div>
                                <div class="item-meta">
                                    ${node.itemType ? `<span class="badge badge-${node.itemType}">${node.itemType}</span>` : ''}
                                    ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<span class="item-cost">${formatCost(node.cost)}</span>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }

                nodeDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if ((node.items && node.items.length > 0) || (node.children && node.children.length > 0)) {
                        node.expanded = !node.expanded;
                        render();
                    } else {
                        showInfo(node);
                    }
                });

                nodeDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    activeNode = node;
                    showContextMenu(e.pageX, e.pageY);
                });

                levelDiv.appendChild(nodeDiv);
                tableEl.appendChild(levelDiv);

                // If expanded, show items in next column, then next phase in following column
                if (node.expanded) {
                    // Show items if any
                    if (node.items && node.items.length > 0) {
                        const itemsColumn = document.createElement('div');
                        itemsColumn.className = 'tree-level';

                        // Get all item IDs in this phase to check for same-phase dependencies
                        const phaseItemIds = node.items.map(i => i.id);

                        // Topological sort: order items by dependencies
                        // Items with no same-phase dependencies first, then items that depend on them
                        function topologicalSort(items, phaseIds) {
                            const sorted = [];
                            const visited = new Set();
                            const visiting = new Set();

                            function visit(item) {
                                if (visited.has(item.id)) return;
                                if (visiting.has(item.id)) {
                                    // Circular dependency - just add it
                                    sorted.push(item);
                                    visited.add(item.id);
                                    return;
                                }

                                visiting.add(item.id);

                                // Visit dependencies first (only same-phase dependencies)
                                if (item.dependencies) {
                                    item.dependencies.forEach(depId => {
                                        if (phaseIds.includes(depId)) {
                                            const depItem = items.find(i => i.id === depId);
                                            if (depItem) {
                                                visit(depItem);
                                            }
                                        }
                                    });
                                }

                                visiting.delete(item.id);
                                visited.add(item.id);
                                sorted.push(item);
                            }

                            items.forEach(item => visit(item));
                            return sorted;
                        }

                        // Calculate dependency depth/level for hierarchical indentation
                        // Returns the depth in the dependency chain (0 = no deps, 1 = direct child, 2 = grandchild, etc.)
                        function calculateDependencyLevel(item, phaseItems, phaseItemIds, visited = new Set()) {
                            // Base case: no same-phase dependencies
                            if (!item.dependencies || item.dependencies.length === 0) {
                                return 0;
                            }

                            const samePhaseDeps = item.dependencies.filter(depId => phaseItemIds.includes(depId));
                            if (samePhaseDeps.length === 0) {
                                return 0;
                            }

                            // Prevent circular dependency infinite loops
                            if (visited.has(item.id)) {
                                return 0;
                            }

                            visited.add(item.id);

                            // Find max depth among all same-phase dependencies
                            let maxLevel = 0;
                            samePhaseDeps.forEach(depId => {
                                const depItem = phaseItems.find(i => i.id === depId);
                                if (depItem) {
                                    const depLevel = calculateDependencyLevel(depItem, phaseItems, phaseItemIds, new Set(visited));
                                    maxLevel = Math.max(maxLevel, depLevel + 1);
                                }
                            });

                            return maxLevel;
                        }

                        const sortedItems = topologicalSort(node.items, phaseItemIds);

                        sortedItems.forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = `tree-node item phase-${node.phase}`;
                            itemDiv.dataset.itemId = item.id; // Add item ID for dependency linking

                            // Calculate dependency depth for hierarchical indentation
                            const dependencyLevel = calculateDependencyLevel(item, node.items, phaseItemIds);

                            // Add multi-level indentation based on dependency depth
                            // Level 0 = no indent, Level 1 = 20px, Level 2 = 40px, Level 3 = 60px, etc.
                            if (dependencyLevel > 0) {
                                itemDiv.classList.add('has-same-phase-dependency');
                                itemDiv.style.marginLeft = `${dependencyLevel * 20}px`;
                                itemDiv.style.position = 'relative';
                                itemDiv.dataset.dependencyLevel = dependencyLevel; // Store for potential visual enhancements
                            }

                            // Add expanded class if item has subtasks and is expanded
                            if (item.subItems && item.subItems.length > 0 && item.expanded) {
                                itemDiv.classList.add('has-expanded-subtasks');
                            }

                            // Add dependency indicator
                            const depInfo = item.dependencies && item.dependencies.length > 0
                                ? `<div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">Depends: ${item.dependencies.join(', ')}</div>`
                                : '';

                            // Check if item has subtasks for expand/collapse indicator
                            const hasSubtasks = item.subItems && item.subItems.length > 0;
                            const expandIndicator = hasSubtasks
                                ? `<span class="expand-toggle" onclick="event.stopPropagation(); window.toggleSubtasks('${item.id}');" style="margin-left: 8px; font-size: 12px; opacity: 0.7; cursor: pointer; user-select: none;">${item.expanded ? '‚ñº' : '‚ñ∂'}</span>`
                                : '';

                            itemDiv.innerHTML = `
                                <div class="node-header">
                                    <span class="node-icon">${item.icon}</span>
                                    <div class="node-content">
                                        <div class="item-name">
                                            ${item.name}
                                            ${expandIndicator}
                                            ${hasSubtasks ? `<span style="font-size: 10px; color: var(--text-secondary); margin-left: 8px;">(${item.subItems.length} tasks)</span>` : ''}
                                        </div>
                                        <div class="item-description">${item.description}</div>
                                        <div class="item-meta">
                                            ${item.itemType ? `<span class="badge badge-${item.itemType}">${item.itemType}</span>` : ''}
                                            ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<span class="item-cost">${formatCost(item.cost)}</span>` : ''}
                                        </div>
                                        ${depInfo}
                                    </div>
                                </div>
                            `;
                            itemDiv.addEventListener('click', (e) => {
                                e.stopPropagation();

                                const panel = document.getElementById('info-panel');
                                const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === item.id;

                                if (isPanelOpen) {
                                    // Second click: Close panel and collapse subtasks
                                    panel.classList.remove('open');
                                    currentOpenItemId = null;
                                    if (hasSubtasks) {
                                        item.expanded = false;
                                        render();
                                    }
                                } else {
                                    // First click: Open panel and expand subtasks
                                    showInfo(item);
                                    if (hasSubtasks) {
                                        item.expanded = true;
                                        render();
                                    }
                                }
                            });

                            itemDiv.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                activeNode = item;
                                showContextMenu(e.pageX, e.pageY);
                            });

                            itemsColumn.appendChild(itemDiv);

                            // RECURSIVE function to render subtasks - keeps same generation on horizontal plane
                            function renderSubtasks(parentItem, containerEl, phaseNum, nestLevel = 0) {
                                if (!parentItem.expanded || !parentItem.subItems || parentItem.subItems.length === 0) {
                                    return;
                                }

                                const subtaskContainer = document.createElement('div');
                                subtaskContainer.className = 'subtask-container';
                                subtaskContainer.style.marginLeft = `${(dependencyLevel + nestLevel) * 20}px`;

                                // Get sub-item IDs for dependency calculations
                                const subItemIds = parentItem.subItems.map(s => s.id);

                                // Sort sub-items by dependencies (topological sort)
                                const sortedSubItems = topologicalSort(parentItem.subItems, subItemIds);

                                // Collect all expanded children that need rendering in next generation
                                const allExpandedGrandchildren = [];

                                // Render all subtasks horizontally first (same generation on same row)
                                sortedSubItems.forEach((subItem, index) => {
                                    const subItemDiv = document.createElement('div');
                                    subItemDiv.className = `tree-node item phase-${phaseNum} subtask`;
                                    subItemDiv.dataset.itemId = subItem.id;

                                    // Ensure subItem has type set
                                    if (!subItem.type) {
                                        subItem.type = 'subtask';
                                    }

                                    // Status color indicator
                                    const statusColors = {
                                        'To Do': '#9CA3AF',
                                        'In Progress': '#3B82F6',
                                        'Completed': '#10B981',
                                        'Done': '#10B981',
                                        'Blocked': '#EF4444'
                                    };
                                    const statusColor = statusColors[subItem.pmStatus] || '#9CA3AF';

                                    // Get initials from assignee name
                                    const getInitials = (name) => {
                                        if (!name || name === 'Unassigned') return '?';
                                        const parts = name.trim().split(' ');
                                        if (parts.length === 1) return parts[0].substring(0, 2).toUpperCase();
                                        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                                    };

                                    // Check if this task has children
                                    const hasChildren = subItem.subItems && subItem.subItems.length > 0;
                                    const chevronIcon = hasChildren ? (subItem.expanded ? '‚ñº' : '‚ñ∂') : '';

                                    subItemDiv.innerHTML = `
                                        <div style="display: flex; flex-direction: column; gap: 6px; width: 100%; height: 100%;">
                                            <!-- Task Title with optional chevron -->
                                            <div style="display: flex; align-items: flex-start; gap: 4px;">
                                                ${chevronIcon ? `<span style="font-size: 8px; color: var(--text-secondary); cursor: pointer; margin-top: 2px;" class="task-chevron">${chevronIcon}</span>` : ''}
                                                <div style="font-size: 11px; font-weight: 600; line-height: 1.2; color: var(--text-primary); flex: 1; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                                                    ${subItem.name}
                                                </div>
                                            </div>

                                            <!-- Visual Indicators Row -->
                                            <div style="display: flex; align-items: center; gap: 6px; margin-top: auto;">
                                                <!-- Status Dot -->
                                                <div style="width: 12px; height: 12px; border-radius: 50%; background: ${statusColor}; box-shadow: 0 0 6px ${statusColor}; flex-shrink: 0;" title="${subItem.pmStatus || 'To Do'}"></div>

                                                <!-- Owner Badge -->
                                                <div style="width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; color: white; flex-shrink: 0;" title="${subItem.pmAssignee || 'Unassigned'}">
                                                    ${getInitials(subItem.pmAssignee)}
                                                </div>

                                                <!-- Progress % -->
                                                <div style="font-size: 11px; font-weight: 700; color: var(--treeplex-primary); margin-left: auto;" title="Progress">
                                                    ${subItem.pmProgress || 0}%
                                                </div>
                                            </div>

                                            <!-- Mini Progress Bar -->
                                            <div style="width: 100%; height: 3px; background: rgba(0, 0, 0, 0.3); border-radius: 2px; overflow: hidden;">
                                                <div style="height: 100%; width: ${subItem.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                                            </div>
                                        </div>
                                    `;

                                    // Click to show info panel AND toggle nested subtasks
                                    subItemDiv.addEventListener('click', (e) => {
                                        e.stopPropagation();

                                        const panel = document.getElementById('info-panel');
                                        const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === subItem.id;

                                        if (isPanelOpen) {
                                            // Second click: Close panel and collapse nested subtasks
                                            panel.classList.remove('open');
                                            currentOpenItemId = null;
                                            if (hasChildren) {
                                                subItem.expanded = false;
                                                render();
                                            }
                                        } else {
                                            // First click: Open panel and expand nested subtasks
                                            showInfo(subItem);
                                            if (hasChildren) {
                                                subItem.expanded = true;
                                                render();
                                            }
                                        }
                                    });

                                    subItemDiv.addEventListener('contextmenu', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        activeNode = subItem;
                                        showContextMenu(e.pageX, e.pageY);
                                    });

                                    subtaskContainer.appendChild(subItemDiv);

                                    // Collect expanded children for next generation
                                    if (subItem.expanded && subItem.subItems && subItem.subItems.length > 0) {
                                        allExpandedGrandchildren.push(subItem);
                                    }
                                });

                                containerEl.appendChild(subtaskContainer);

                                // Now render ALL children of this generation on the NEXT horizontal row below
                                allExpandedGrandchildren.forEach(expandedChild => {
                                    renderSubtasks(expandedChild, containerEl, phaseNum, nestLevel + 1);
                                });
                            }

                            // Initial call to render subtasks
                            renderSubtasks(item, itemsColumn, node.phase, 0);
                        });

                        tableEl.appendChild(itemsColumn);
                    }

                    // Recursively render next phase
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => buildColumn(child));
                    }
                }
            }

            buildColumn(capexTree);
            container.appendChild(tableEl);

            // Draw dependency lines after rendering
            setTimeout(drawDependencyLines, 100);
        }

        // Draw dependency lines using SVG
        function drawDependencyLines() {
            const svg = document.getElementById('dependency-svg');
            const treeEl = document.getElementById('tree-root');
            const wrapperEl = document.getElementById('tree-transform-wrapper');

            // Clear existing lines
            svg.innerHTML = '';

            // Set SVG dimensions to be large enough for panning/zooming
            // Use a fixed large size that the CSS will position correctly
            svg.setAttribute('width', '20000');
            svg.setAttribute('height', '20000');

            // Add arrow marker definitions
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Create markers for each phase color - using darker vibrant colors
            const colors = {
                'phase-0': '#4CAF50',
                'phase-1': '#2196F3',
                'phase-2': '#FB8C00',
                'cross-phase': '#008F6D'
            };

            Object.entries(colors).forEach(([className, color]) => {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', `arrow-${className}`);
                marker.setAttribute('viewBox', '0 0 10 10');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '5');
                marker.setAttribute('markerWidth', '8');
                marker.setAttribute('markerHeight', '8');
                marker.setAttribute('orient', 'auto');

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                path.setAttribute('fill', color);
                path.setAttribute('opacity', '0.8');
                path.setAttribute('filter', 'drop-shadow(0 2px 2px rgba(0,0,0,0.2))');

                marker.appendChild(path);
                defs.appendChild(marker);
            });

            svg.appendChild(defs);

            // Find all items with dependencies
            function getAllItems(node, items = [], phase = null) {
                if (node.phase !== undefined) phase = node.phase;
                if (node.items) {
                    node.items.forEach(item => items.push({ ...item, currentPhase: phase }));
                }
                if (node.children) {
                    node.children.forEach(child => getAllItems(child, items, phase));
                }
                return items;
            }

            const allItems = getAllItems(capexTree);

            // Helper to find item phase
            function findItemPhase(itemId) {
                const item = allItems.find(i => i.id === itemId);
                return item ? item.currentPhase : null;
            }

            // Draw lines for each dependency
            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    const targetEl = document.querySelector(`[data-item-id="${item.id}"]`);
                    if (!targetEl) return;

                    item.dependencies.forEach(depId => {
                        const sourceEl = document.querySelector(`[data-item-id="${depId}"]`);
                        if (!sourceEl) return;

                        // Get positions in tree's local coordinate space (not viewport)
                        // This accounts for the transform by using offsetLeft/Top instead of getBoundingClientRect
                        function getElementPosition(el) {
                            let x = 0;
                            let y = 0;
                            let current = el;

                            // Walk up to the tree root to get cumulative offset
                            while (current && current !== treeEl.parentElement) {
                                x += current.offsetLeft || 0;
                                y += current.offsetTop || 0;
                                current = current.offsetParent;
                            }

                            return { x, y, width: el.offsetWidth, height: el.offsetHeight };
                        }

                        const sourcePos = getElementPosition(sourceEl);
                        const targetPos = getElementPosition(targetEl);

                        // SVG offset constant (matches CSS top/left offset)
                        const SVG_OFFSET = 5000;

                        const x1 = sourcePos.x + sourcePos.width + SVG_OFFSET;
                        const y1 = sourcePos.y + sourcePos.height / 2 + SVG_OFFSET;
                        const x2 = targetPos.x + SVG_OFFSET;
                        const y2 = targetPos.y + targetPos.height / 2 + SVG_OFFSET;

                        // Determine if cross-phase dependency
                        const sourcePhase = findItemPhase(depId);
                        const targetPhase = item.currentPhase;
                        const isCrossPhase = sourcePhase !== targetPhase;

                        // Skip same-phase dependencies - only draw cross-phase arrows
                        if (!isCrossPhase) return;

                        const lineClass = 'cross-phase';

                        // Create curved path (quadratic bezier)
                        const midX = (x1 + x2) / 2;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const d = `M ${x1} ${y1} Q ${midX} ${y1}, ${midX} ${(y1 + y2) / 2} T ${x2} ${y2}`;

                        path.setAttribute('d', d);
                        path.setAttribute('class', `dependency-line ${lineClass}`);
                        path.setAttribute('marker-end', `url(#arrow-${lineClass})`);

                        // Add tooltip
                        const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                        title.textContent = `${depId} ‚Üí ${item.id}${isCrossPhase ? ' (cross-phase)' : ''}`;
                        path.appendChild(title);

                        svg.appendChild(path);
                    });
                }
            });

            // =================================================================
            // DRAW PARENT-CHILD CONNECTORS FOR TASKS (Symmetrical Grey Lines)
            // =================================================================
            // Find all subtasks and draw symmetrical connectors to their parent items
            function getAllSubtasksWithParent(node, subtasks = []) {
                if (node.items) {
                    node.items.forEach(item => {
                        if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                            // Collect parent with all its children for symmetrical layout
                            subtasks.push({
                                parent: item,
                                children: item.subItems
                            });

                            // Recursively handle nested tasks
                            item.subItems.forEach(subtask => {
                                if (subtask.subItems && Array.isArray(subtask.subItems) && subtask.subItems.length > 0) {
                                    subtasks.push({
                                        parent: subtask,
                                        children: subtask.subItems
                                    });
                                }
                            });
                        }
                    });
                }
                if (node.children) {
                    node.children.forEach(child => getAllSubtasksWithParent(child, subtasks));
                }
                return subtasks;
            }

            const allParentChildPairs = getAllSubtasksWithParent(capexTree);

            // Helper to get element position
            function getElementPosition(el) {
                let x = 0;
                let y = 0;
                let current = el;

                while (current && current !== treeEl.parentElement) {
                    x += current.offsetLeft || 0;
                    y += current.offsetTop || 0;
                    current = current.offsetParent;
                }

                return { x, y, width: el.offsetWidth, height: el.offsetHeight };
            }

            const SVG_OFFSET = 5000;

            allParentChildPairs.forEach(({ parent, children }) => {
                const parentEl = document.querySelector(`[data-item-id="${parent.id}"]`);
                if (!parentEl) return;

                const parentPos = getElementPosition(parentEl);

                // Draw symmetrical lines from parent to each child
                children.forEach(child => {
                    const childEl = document.querySelector(`[data-item-id="${child.id}"]`);
                    if (!childEl) return;

                    const childPos = getElementPosition(childEl);

                    // Start from bottom-center of parent
                    const x1 = parentPos.x + parentPos.width / 2 + SVG_OFFSET;
                    const y1 = parentPos.y + parentPos.height + SVG_OFFSET;

                    // End at top-center of child
                    const x2 = childPos.x + childPos.width / 2 + SVG_OFFSET;
                    const y2 = childPos.y + SVG_OFFSET;

                    // Create symmetrical line (no arrow head)
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', 'rgba(128, 128, 128, 0.4)');  // Grey
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('opacity', '0.6');

                    // Add tooltip
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = `${parent.name} ‚Üí ${child.name}`;
                    line.appendChild(title);

                    svg.appendChild(line);
                });
            });
        }


        // Info Panel
        function showInfo(node) {
            const panel = document.getElementById('info-panel');
            const titleElement = document.getElementById('info-title');

            // Enhanced title for subtasks - just the name, prominent
            if (node.type === 'subtask') {
                titleElement.innerHTML = `
                    <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); line-height: 1.3;">
                        ${node.name}
                    </div>
                `;
            } else {
                titleElement.textContent = `${node.icon} ${node.name}`;
            }

            const body = document.getElementById('info-body');

            // Build dependencies section
            let depsHtml = '';
            if (node.dependencies && node.dependencies.length > 0) {
                const depNames = node.dependencies.map(depId => {
                    // Find the dependency item to get its name
                    function findItemById(id, n = capexTree) {
                        if (n.id === id) return n;
                        if (n.items) {
                            const found = n.items.find(i => i.id === id);
                            if (found) return found;
                        }
                        if (n.children) {
                            for (let child of n.children) {
                                const found = findItemById(id, child);
                                if (found) return found;
                            }
                        }
                        return null;
                    }
                    const depItem = findItemById(depId);
                    return depItem ? `${depItem.icon} ${depItem.name}` : depId;
                }).join('<br>');

                depsHtml = `
                    <div class="info-section">
                        <h4>Dependencies</h4>
                        <p style="line-height: 1.8;">${depNames}</p>
                    </div>
                `;
            }

            // Build dependents section (items that depend on this one)
            let dependentsHtml = '';
            if (node.id) {
                function findDependents(nodeId, n = capexTree, dependents = []) {
                    if (n.items) {
                        n.items.forEach(item => {
                            if (item.dependencies && item.dependencies.includes(nodeId)) {
                                dependents.push(item);
                            }
                        });
                    }
                    if (n.children) {
                        n.children.forEach(child => findDependents(nodeId, child, dependents));
                    }
                    return dependents;
                }

                const dependents = findDependents(node.id);
                if (dependents.length > 0) {
                    const depList = dependents.map(d => `${d.icon} ${d.name}`).join('<br>');
                    dependentsHtml = `
                        <div class="info-section">
                            <h4>Required By</h4>
                            <p style="line-height: 1.8;">${depList}</p>
                        </div>
                    `;
                }
            }

            // Build PM Dashboard section for subtasks
            let pmDashboardHtml = '';
            if (node.type === 'subtask') {
                const statusColors = {
                    'To Do': { bg: 'rgba(156, 163, 175, 0.3)', color: '#9CA3AF' },
                    'In Progress': { bg: 'rgba(59, 130, 246, 0.3)', color: '#3B82F6' },
                    'Completed': { bg: 'rgba(16, 185, 129, 0.3)', color: '#10B981' },
                    'Blocked': { bg: 'rgba(239, 68, 68, 0.3)', color: '#EF4444' }
                };
                const statusStyle = statusColors[node.pmStatus] || statusColors['To Do'];

                const priorityEmojis = { 'Low': 'üü¢', 'Medium': 'üü°', 'High': 'üü†', 'Critical': 'üî¥' };
                const priorityEmoji = priorityEmojis[node.pmPriority] || '‚ö™';

                // Calculate days until/since due date
                let dueDateInfo = '';
                if (node.pmDueDate) {
                    const dueDate = new Date(node.pmDueDate);
                    const today = new Date();
                    const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                    if (diffDays < 0) {
                        dueDateInfo = `<span style="color: #EF4444; font-weight: 600;">‚ö†Ô∏è ${Math.abs(diffDays)} days overdue</span>`;
                    } else if (diffDays === 0) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">üìÖ Due today!</span>`;
                    } else if (diffDays <= 3) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">‚è∞ ${diffDays} days left</span>`;
                    } else {
                        dueDateInfo = `<span style="color: var(--text-secondary);">${diffDays} days left</span>`;
                    }
                }

                pmDashboardHtml = `
                    <!-- Status + Progress Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: ${statusStyle.bg}; border-radius: 10px; border: 2px solid ${statusStyle.color};">
                            <div style="font-size: 28px; font-weight: 700; color: ${statusStyle.color};">
                                ${node.pmStatus || 'To Do'}
                            </div>
                        </div>
                        <div style="flex: 1; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); border-radius: 10px; border: 2px solid rgba(0, 166, 125, 0.4); display: flex; flex-direction: column; justify-content: center;">
                            <div style="font-size: 36px; font-weight: 700; color: var(--treeplex-primary); line-height: 1;">${node.pmProgress || 0}%</div>
                            <div style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden; margin-top: 8px;">
                                <div style="height: 100%; width: ${node.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Owner + Priority Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; align-items: center; gap: 12px;">
                            <div style="width: 48px; height: 48px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: 700; color: white; flex-shrink: 0;">
                                ${node.pmAssignee ? node.pmAssignee.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2) : '?'}
                            </div>
                            <div style="font-size: 18px; font-weight: 600;">${node.pmAssignee || 'Unassigned'}</div>
                        </div>
                        <div style="width: 120px; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <div style="font-size: 40px; margin-bottom: 4px;">${priorityEmoji}</div>
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-secondary);">${node.pmPriority || 'Medium'}</div>
                        </div>
                    </div>

                    <!-- Timeline -->
                    <div style="padding: 16px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-around; margin-bottom: 12px;">
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">üìÖ</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmStartDate ? new Date(node.pmStartDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                            <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
                                <div style="height: 2px; flex: 1; background: linear-gradient(90deg, var(--treeplex-primary), transparent);"></div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">üéØ</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmDueDate ? new Date(node.pmDueDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                        </div>
                        ${dueDateInfo ? `<div style="text-align: center; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; font-size: 13px;">${dueDateInfo}</div>` : ''}
                    </div>

                    <!-- Notes -->
                    ${node.pmNotes ? `
                        <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; border-left: 4px solid var(--treeplex-primary); margin-bottom: 16px;">
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary);">${node.pmNotes}</div>
                        </div>
                    ` : ''}

                    <!-- Blocking Issue -->
                    ${node.pmBlockingIssue ? `
                        <div style="padding: 14px; background: rgba(239, 68, 68, 0.15); border-radius: 10px; border-left: 4px solid #EF4444; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">üöß</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #FCA5A5;">${node.pmBlockingIssue}</div>
                        </div>
                    ` : ''}

                    <!-- Next Steps -->
                    ${node.pmNextSteps ? `
                        <div style="padding: 14px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; border-left: 4px solid #3B82F6; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">‚û°Ô∏è</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #93C5FD;">${node.pmNextSteps}</div>
                        </div>
                    ` : ''}

                    <!-- Latest Updates -->
                    ${node.pmUpdates && node.pmUpdates.length > 0 ? `
                        <div style="max-height: 300px; overflow-y: auto;">
                            ${node.pmUpdates.map(update => `
                                <div style="margin-bottom: 10px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 6px;">
                                        üìÖ ${new Date(update.timestamp).toLocaleString('en-US', {month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'})}
                                    </div>
                                    <div style="font-size: 13px; line-height: 1.5; white-space: pre-wrap;">${update.text}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            }

            body.innerHTML = `
                ${pmDashboardHtml}
                <div class="info-section">
                    <h4>ID</h4>
                    <p><code style="background: var(--bg); padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 12px;">${node.id || 'N/A'}</code></p>
                </div>
                <div class="info-section">
                    <h4>Cost</h4>
                    <p class="value">${formatCost(node.cost || 0)}</p>
                </div>
                <div class="info-section">
                    <h4>Description</h4>
                    <p>${node.description || node.subtitle || 'N/A'}</p>
                </div>
                <div class="info-section">
                    <h4>Type</h4>
                    <p>${node.itemType || node.type || 'N/A'}</p>
                </div>
                ${node.alternateSource ? `
                    <div class="info-section">
                        <h4>Alternate Source</h4>
                        <p style="font-size: 14px; line-height: 1.6;">üì¶ ${node.alternateSource}</p>
                    </div>
                ` : ''}
                ${node.leadTime ? `
                    <div class="info-section">
                        <h4>Lead Time</h4>
                        <p style="font-size: 14px; line-height: 1.6;">‚è±Ô∏è ${node.leadTime}</p>
                    </div>
                ` : ''}
                ${node.notes ? `
                    <div class="info-section">
                        <h4>Context Notes</h4>
                        <p style="background: var(--bg); padding: 12px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary); font-size: 13px; line-height: 1.6; white-space: pre-wrap;">${node.notes}</p>
                    </div>
                ` : ''}
                ${depsHtml}
                ${dependentsHtml}
                ${node.type === 'phase' ? `
                    <div class="info-section">
                        <h4>Phase Total</h4>
                        <p class="value">${formatCost(calculatePhaseTotal(node))}</p>
                    </div>
                ` : ''}
                ${node.type === 'root' ? `
                    <div class="info-section">
                        <h4>Total Cost</h4>
                        <p class="value">${formatCost(calculateTotal(node))}</p>
                    </div>
                ` : ''}
            `;

            panel.classList.add('open');
            currentOpenItemId = node.id;
        }

        // Track which item's panel is currently open
        let currentOpenItemId = null;

        document.getElementById('close-info').addEventListener('click', () => {
            document.getElementById('info-panel').classList.remove('open');
            currentOpenItemId = null;
        });

        // Context Menu
        function showContextMenu(x, y) {
            const menu = document.getElementById('context-menu');
            const labels = getPatternLabels();

            // Build menu dynamically based on node type
            let menuHtml = '';

            if (activeNode.type === 'item') {
                // Item context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.item}</div>
                    <div class="context-item" id="ctx-add-subtask">‚ûï Add ${labels.subtask}</div>
                    <div class="context-item" id="ctx-delete">üóëÔ∏è Delete ${labels.item}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ AI Analysis</div>
                `;
            } else if (activeNode.type === 'subtask') {
                // Subtask context menu (can now have nested subtasks)
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.subtask}</div>
                    <div class="context-item" id="ctx-add-subtask">‚ûï Add Nested ${labels.subtask}</div>
                    <div class="context-item" id="ctx-delete">üóëÔ∏è Delete ${labels.subtask}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ AI Analysis</div>
                `;
            } else if (activeNode.type === 'phase') {
                // Phase context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.phase}</div>
                    <div class="context-item" id="ctx-create">‚ûï Add ${labels.item} to ${activeNode.name}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ AI Analysis</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">üíæ Download JSON</div>
                    <div class="context-item" id="ctx-upload">üìÇ Upload JSON</div>
                `;
            } else if (activeNode.type === 'root') {
                // Root context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.root}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-expand">üìÇ Expand All</div>
                    <div class="context-item" id="ctx-collapse">üìÅ Collapse All</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ ${labels.root} AI Analysis</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">üíæ Download JSON</div>
                    <div class="context-item" id="ctx-upload">üìÇ Upload JSON</div>
                `;
            }

            menu.innerHTML = menuHtml;
            menu.style.display = 'block';

            // Position menu first (to measure dimensions)
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Check if menu goes off screen and adjust position
            const menuRect = menu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            let finalX = x;
            let finalY = y;

            // Adjust horizontal position if menu goes off right edge
            if (menuRect.right > viewportWidth) {
                finalX = viewportWidth - menuRect.width - 10;
            }

            // Adjust vertical position if menu goes off bottom edge
            if (menuRect.bottom > viewportHeight) {
                finalY = viewportHeight - menuRect.height - 10;
            }

            // Ensure menu doesn't go off left edge
            if (finalX < 10) finalX = 10;

            // Ensure menu doesn't go off top edge
            if (finalY < 10) finalY = 10;

            menu.style.left = finalX + 'px';
            menu.style.top = finalY + 'px';

            // Re-attach event listeners
            attachContextMenuListeners();
        }

        function attachContextMenuListeners() {
            const viewBtn = document.getElementById('ctx-view');
            const editBtn = document.getElementById('ctx-edit');
            const createBtn = document.getElementById('ctx-create');
            const addSubtaskBtn = document.getElementById('ctx-add-subtask');
            const deleteBtn = document.getElementById('ctx-delete');
            const aiBtn = document.getElementById('ctx-ai');
            const downloadBtn = document.getElementById('ctx-download');
            const uploadBtn = document.getElementById('ctx-upload');
            const expandBtn = document.getElementById('ctx-expand');
            const collapseBtn = document.getElementById('ctx-collapse');

            if (viewBtn) viewBtn.onclick = handleViewDetails;
            if (editBtn) editBtn.onclick = handleEdit;
            if (createBtn) createBtn.onclick = handleCreate;
            if (addSubtaskBtn) addSubtaskBtn.onclick = handleAddSubtask;
            if (deleteBtn) deleteBtn.onclick = handleDelete;
            if (aiBtn) aiBtn.onclick = handleAI;
            if (downloadBtn) downloadBtn.onclick = handleDownload;
            if (uploadBtn) uploadBtn.onclick = handleUpload;
            if (expandBtn) expandBtn.onclick = handleExpandAll;
            if (collapseBtn) collapseBtn.onclick = handleCollapseAll;
        }

        document.addEventListener('click', () => {
            document.getElementById('context-menu').style.display = 'none';
        });

        // Context menu handlers
        function handleViewDetails() {
            if (activeNode) showInfo(activeNode);
        }

        // Smart Suggestion Engine with Contextual Intelligence
        function generateAISuggestion(fieldType, itemContext) {
            const itemType = itemContext.itemType || 'equipment';
            const phase = itemContext.id ? itemContext.id.split('-')[0] : 'p0';
            const phaseNames = { p0: 'Phase 0 (Pre-Seed)', p1: 'Phase 1 (Seed)', p2: 'Phase 2 (Build)' };
            const phaseName = phaseNames[phase] || 'Unknown Phase';
            const notes = itemContext.notes || '';

            // Get all existing items for contextual analysis
            function getAllProjectItems(node = capexTree, items = []) {
                if (node.items) items.push(...node.items);
                if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
                return items;
            }
            const existingItems = getAllProjectItems();

            // AI suggestion templates based on field type
            const suggestions = {
                name: {
                    land: ['Land Acquisition & Title', 'Site Purchase & Legal', 'Property Option Agreement', 'Land Rights & Easements'],
                    engineering: ['Engineering Design Services', 'Technical Specification Development', 'System Architecture Planning', 'Feasibility Study & Analysis'],
                    equipment: ['Equipment Procurement', 'Hardware Purchase & Installation', 'Capital Equipment Acquisition', 'Technology Infrastructure'],
                    infrastructure: ['Infrastructure Development', 'Site Preparation & Construction', 'Facility Build-Out', 'Utility Infrastructure'],
                    corporate: ['Corporate Administration', 'Business Operations Support', 'Management & Overhead', 'Professional Services'],
                    professional: ['Professional Services Engagement', 'Consulting & Advisory', 'Expert Services Retainer', 'Third-Party Assessment'],
                    contingency: ['Contingency Reserve', 'Risk Mitigation Fund', 'Budget Reserve Allocation', 'Unforeseen Expenses Buffer']
                },
                description: {
                    land: 'Secure land rights and complete legal due diligence including title verification, environmental assessments, and zoning compliance. Critical prerequisite for all site development activities.',
                    engineering: 'Comprehensive engineering design and technical specification development by qualified professionals. Includes peer review, regulatory compliance verification, and documentation for permitting.',
                    equipment: 'Procurement of capital equipment with extended lead times. Requires vendor evaluation, competitive bidding, and early commitment to secure production slots. Includes installation and commissioning.',
                    infrastructure: 'Site infrastructure development including construction, utility tie-ins, and facility preparation. Coordinate permits, weather dependencies, and contractor scheduling.',
                    corporate: 'Corporate administration, legal compliance, insurance, and operational overhead necessary to maintain business operations throughout project timeline.',
                    professional: 'Engagement of specialized consultants and professional services with relevant domain expertise. Deliverables include reports, recommendations, and strategic guidance.',
                    contingency: 'Reserve allocation to address unforeseen expenses, scope changes, and risk mitigation. Recommended range 3-10% of phase budget depending on complexity and uncertainty.'
                },
                cost: {
                    p0: [50000, 100000, 180000, 250000],
                    p1: [500000, 1000000, 1500000, 2000000],
                    p2: [25000000, 50000000, 100000000, 150000000]
                },
                icon: {
                    land: ['üèûÔ∏è', 'üìÑ', 'üó∫Ô∏è', 'üè°'],
                    engineering: ['üìê', 'üîß', '‚öôÔ∏è', 'üî¨'],
                    equipment: ['‚ö°', 'üîã', 'üîå', '‚öôÔ∏è'],
                    infrastructure: ['üè¢', 'üèóÔ∏è', 'üîó', 'üåê'],
                    corporate: ['üíº', 'üìä', 'üèõÔ∏è', 'üìã'],
                    professional: ['üìú', 'üëî', 'üéØ', 'üí°'],
                    contingency: ['üí∞', 'üõ°Ô∏è', '‚öñÔ∏è', 'üìà']
                },
                notes: {
                    land: 'Key considerations: location suitability, regulatory approvals required, environmental impact assessments, title clarity, zoning compliance, access to utilities and infrastructure.',
                    engineering: 'Key considerations: technical feasibility, compliance standards, peer review requirements, timeline for design iterations, regulatory permits needed, documentation standards.',
                    equipment: 'Key considerations: vendor lead times (typically 12-18 months), production capacity, competitive bidding process, installation requirements, commissioning timeline, warranty terms.',
                    infrastructure: 'Key considerations: construction permits, utility coordination, seasonal/weather impacts, contractor availability, site preparation requirements, inspection schedules.',
                    corporate: 'Key considerations: governance compliance, legal oversight, insurance coverage, operational continuity, stakeholder reporting, audit requirements, administrative capacity.',
                    professional: 'Key considerations: consultant qualifications, domain expertise verification, deliverable specifications, success criteria, timeline expectations, budget allocation.',
                    contingency: 'Key considerations: risk assessment, budget buffer percentage (3-10%), scope change provisions, unforeseen expense coverage, approval thresholds for contingency use.'
                },
                alternateSource: {
                    land: ['Local real estate firms', 'Regional land brokers', 'Municipal land auctions', 'Adjacent property owners'],
                    engineering: ['Alternative engineering consultancies', 'In-house engineering team', 'Offshore design firms', 'University research partnerships'],
                    equipment: ['Secondary OEM suppliers', 'Refurbished equipment dealers', 'International manufacturers', 'Lease-to-own providers'],
                    infrastructure: ['Regional contractors', 'Turnkey EPC firms', 'Modular construction vendors', 'Local construction cooperatives'],
                    corporate: ['Alternative service providers', 'Shared services consortium', 'Outsourced business services', 'In-house capability development'],
                    professional: ['Alternative consulting firms', 'Big 4 professional services', 'Boutique specialists', 'Industry veterans/freelancers'],
                    contingency: ['Self-insurance reserves', 'Alternative financing sources', 'Risk pooling arrangements', 'Performance bonds']
                },
                leadTime: {
                    p0: ['2-4 weeks', '30-45 days', '1-2 months', '6-8 weeks'],
                    p1: ['3-6 months', '4-8 months', '90-120 days', '6 months'],
                    p2: ['12-18 months', '18-24 months', '15-20 months', '2 years']
                }
            };

            // Generate suggestion based on field type
            if (fieldType === 'name') {
                const options = suggestions.name[itemType] || suggestions.name.equipment;
                let suggestion = options[Math.floor(Math.random() * options.length)];

                // If notes contain specific keywords, adjust suggestion
                if (notes) {
                    const notesLower = notes.toLowerCase();
                    if (notesLower.includes('turbine') || notesLower.includes('generator')) suggestion = itemType === 'equipment' ? 'Gas Turbine Generator Package' : suggestion;
                    if (notesLower.includes('solar') || notesLower.includes('pv')) suggestion = itemType === 'equipment' ? 'Solar PV Array Installation' : suggestion;
                    if (notesLower.includes('battery') || notesLower.includes('bess')) suggestion = itemType === 'equipment' ? 'Battery Energy Storage System' : suggestion;
                    if (notesLower.includes('pipeline') || notesLower.includes('gas line')) suggestion = itemType === 'engineering' ? 'Pipeline Engineering & Design' : suggestion;
                    if (notesLower.includes('permit') || notesLower.includes('regulatory')) suggestion = itemType === 'professional' ? 'Permitting & Regulatory Services' : suggestion;
                }

                return suggestion;
            } else if (fieldType === 'description') {
                let baseDescription = suggestions.description[itemType] || suggestions.description.equipment;

                // Enhance description with context from notes
                if (notes && notes.length > 20) {
                    baseDescription += ` Additional context: ${notes.substring(0, 150)}${notes.length > 150 ? '...' : ''}`;
                }

                return baseDescription;
            } else if (fieldType === 'cost') {
                // INTELLIGENT COST SUGGESTION: Analyze similar items in project
                const similarItems = existingItems.filter(item =>
                    item.itemType === itemType && item.cost > 0
                );

                let suggestedCost;

                if (similarItems.length > 0) {
                    // Use median cost of similar items for realistic suggestion
                    const costs = similarItems.map(i => i.cost).sort((a, b) => a - b);
                    const median = costs[Math.floor(costs.length / 2)];
                    suggestedCost = median;

                    // Add 10-20% variance to avoid exact duplicates
                    const variance = 0.9 + (Math.random() * 0.2); // 90% to 110%
                    suggestedCost = Math.round(suggestedCost * variance);
                } else {
                    // Fallback to phase-appropriate templates if no similar items exist
                    const phaseKey = phase || 'p1';
                    const costRanges = suggestions.cost[phaseKey] || suggestions.cost.p1;
                    suggestedCost = costRanges[Math.floor(Math.random() * costRanges.length)];
                }

                // Adjust based on context notes
                if (notes) {
                    const notesLower = notes.toLowerCase();
                    if (notesLower.includes('large scale') || notesLower.includes('major')) suggestedCost = Math.round(suggestedCost * 1.5);
                    if (notesLower.includes('small') || notesLower.includes('minimal')) suggestedCost = Math.round(suggestedCost * 0.6);
                    if (notesLower.includes('rush') || notesLower.includes('expedited')) suggestedCost = Math.round(suggestedCost * 1.2);
                }

                return suggestedCost;
            } else if (fieldType === 'icon') {
                const options = suggestions.icon[itemType] || suggestions.icon.equipment;
                return options[Math.floor(Math.random() * options.length)];
            } else if (fieldType === 'notes') {
                return suggestions.notes[itemType] || suggestions.notes.equipment;
            } else if (fieldType === 'alternateSource') {
                const options = suggestions.alternateSource[itemType] || suggestions.alternateSource.equipment;
                let suggestion = options[Math.floor(Math.random() * options.length)];

                // Enhance with context from notes
                if (notes) {
                    const notesLower = notes.toLowerCase();
                    if (notesLower.includes('siemens') || notesLower.includes('ge')) {
                        suggestion = itemType === 'equipment' ? 'Alternative: GE, Siemens Energy, MAN Energy Solutions' : suggestion;
                    }
                    if (notesLower.includes('local') || notesLower.includes('canadian')) {
                        suggestion = 'Canadian suppliers and regional vendors';
                    }
                }

                return suggestion;
            } else if (fieldType === 'leadTime') {
                const phaseKey = phase || 'p1';
                const leadTimeOptions = suggestions.leadTime[phaseKey] || suggestions.leadTime.p1;
                let suggestion = leadTimeOptions[Math.floor(Math.random() * leadTimeOptions.length)];

                // Adjust lead time based on notes keywords
                if (notes) {
                    const notesLower = notes.toLowerCase();
                    if (notesLower.includes('rush') || notesLower.includes('expedited') || notesLower.includes('urgent')) {
                        // Suggest shorter timeframe for urgent items
                        if (phase === 'p2') suggestion = '10-12 months (expedited)';
                        else if (phase === 'p1') suggestion = '2-3 months (expedited)';
                        else suggestion = '2-3 weeks (expedited)';
                    }
                    if (notesLower.includes('custom') || notesLower.includes('bespoke') || notesLower.includes('specialized')) {
                        // Suggest longer timeframe for custom items
                        if (phase === 'p2') suggestion = '24-30 months (custom build)';
                        else if (phase === 'p1') suggestion = '8-12 months (custom)';
                        else suggestion = '3-4 months (custom)';
                    }
                }

                return suggestion;
            }

            return '';
        }

        // Add AI suggestion capability to text fields
        function enableAISuggestionsOnField(fieldElement, fieldType, itemContext) {
            fieldElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Show smart suggestion context menu
                const menu = document.getElementById('context-menu');
                menu.innerHTML = `
                    <div class="context-item" id="ai-suggest-field">üí° Smart Suggest</div>
                    <div class="context-divider"></div>
                    <div class="context-item" style="font-size: 11px; color: var(--text-secondary); cursor: default; padding: 8px 14px;" onmouseover="this.style.background='transparent'">Contextual suggestions based on your project</div>
                `;
                menu.style.display = 'block';

                // Position menu
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';

                // Smart positioning to avoid going off screen
                const menuRect = menu.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                let finalX = e.pageX;
                let finalY = e.pageY;

                if (menuRect.right > viewportWidth) {
                    finalX = viewportWidth - menuRect.width - 10;
                }
                if (menuRect.bottom > viewportHeight) {
                    finalY = viewportHeight - menuRect.height - 10;
                }
                if (finalX < 10) finalX = 10;
                if (finalY < 10) finalY = 10;

                menu.style.left = finalX + 'px';
                menu.style.top = finalY + 'px';

                // Attach AI suggest handler
                const aiSuggestBtn = document.getElementById('ai-suggest-field');
                aiSuggestBtn.onclick = () => {
                    // Get current context including notes field value
                    const currentContext = { ...itemContext };
                    const notesField = document.getElementById('edit-notes');
                    if (notesField) {
                        currentContext.notes = notesField.value;
                    }

                    const suggestion = generateAISuggestion(fieldType, currentContext);
                    fieldElement.value = suggestion;

                    // Trigger input event for any listeners
                    fieldElement.dispatchEvent(new Event('input', { bubbles: true }));

                    // Visual feedback
                    fieldElement.style.transition = 'all 0.3s';
                    fieldElement.style.background = 'rgba(0, 166, 125, 0.15)';
                    setTimeout(() => {
                        fieldElement.style.background = 'var(--bg)';
                    }, 600);

                    menu.style.display = 'none';
                };
            });
        }

        // Helper function to generate dynamic field HTML based on pattern
        function generateFieldHTML(fieldKey, fieldConfig, node) {
            const value = node[fieldKey] || '';
            const fieldId = `edit-${fieldKey}`;

            let inputHTML = '';

            if (fieldConfig.type === 'select') {
                const options = fieldConfig.options.map(opt =>
                    `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`
                ).join('');
                inputHTML = `<select id="${fieldId}">${options}</select>`;
            } else if (fieldConfig.type === 'textarea') {
                inputHTML = `<textarea id="${fieldId}" placeholder="${fieldConfig.placeholder || ''}" style="min-height: 80px;">${value}</textarea>`;
            } else if (fieldConfig.type === 'number') {
                const min = fieldConfig.min !== undefined ? `min="${fieldConfig.min}"` : '';
                const max = fieldConfig.max !== undefined ? `max="${fieldConfig.max}"` : '';
                const step = fieldConfig.step !== undefined ? `step="${fieldConfig.step}"` : '';
                inputHTML = `<input type="number" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" ${min} ${max} ${step} />`;
            } else if (fieldConfig.type === 'date') {
                inputHTML = `<input type="date" id="${fieldId}" value="${value}" />`;
            } else {
                // default to text
                inputHTML = `<input type="text" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" />`;
            }

            return `
                <div class="form-group">
                    <label>${fieldConfig.label} <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                    ${inputHTML}
                    ${fieldConfig.helpText ? `<p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">${fieldConfig.helpText}</p>` : ''}
                </div>
            `;
        }

        function handleEdit() {
            if (!activeNode) return;

            // Simple name editing for root and phase nodes
            if (activeNode.type === 'root' || activeNode.type === 'phase') {
                const labels = getPatternLabels();
                const nodeType = activeNode.type === 'root' ? labels.root : labels.phase;
                const newName = prompt(`Enter new ${nodeType} name:`, activeNode.name);

                if (newName && newName !== activeNode.name) {
                    activeNode.name = newName;
                    render();
                }
                return;
            }

            // Full edit modal for items and subtasks
            if (activeNode.type === 'item' || activeNode.type === 'subtask') {
                const modal = document.getElementById('edit-modal');
                const body = document.getElementById('edit-modal-body');

                // Get all items from all phases for dependency selection
                function getAllItems(node, items = [], phaseName = '') {
                    if (node.phase !== undefined) phaseName = `Phase ${node.phase}`;
                    if (node.items) {
                        node.items.forEach(item => {
                            items.push({ ...item, phaseName });
                        });
                    }
                    if (node.children) {
                        node.children.forEach(child => getAllItems(child, items, phaseName));
                    }
                    return items;
                }

                const allItems = getAllItems(capexTree).filter(item => item.id !== activeNode.id);

                // Build dependency checkboxes
                const currentDeps = activeNode.dependencies || [];
                const depsHtml = allItems.map(item => {
                    const checked = currentDeps.includes(item.id) ? 'checked' : '';
                    return `
                        <label style="display: flex; align-items: center; gap: 10px; padding: 8px 10px; cursor: pointer; font-weight: normal; text-transform: none; letter-spacing: normal; border-radius: 6px; transition: background 0.2s; margin-bottom: 4px;" onmouseover="this.style.background='var(--card-bg-light)'" onmouseout="this.style.background='transparent'">
                            <input type="checkbox" class="dep-checkbox" value="${item.id}" ${checked} style="flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; accent-color: var(--treeplex-primary);" />
                            <span style="flex: 1; display: flex; align-items: center; gap: 8px; font-size: 14px;">
                                <span style="font-size: 18px; flex-shrink: 0;">${item.icon}</span>
                                <span style="flex: 1; color: var(--text-primary);">${item.name}</span>
                                <span style="color: var(--text-secondary); font-size: 11px; padding: 2px 8px; background: var(--card-bg); border-radius: 4px; border: 1px solid var(--border);">${item.phaseName}</span>
                            </span>
                        </label>
                    `;
                }).join('');

                // Get current pattern and its fields configuration
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                // Check if PM tracking should be shown
                const showTracking = fields.includeTracking &&
                                    fields.trackingFor &&
                                    fields.trackingFor.includes(activeNode.type);

                // Build field HTML
                let fieldsHTML = '';

                // 1. PM Tracking Section (conditional)
                if (showTracking) {
                    fieldsHTML += `
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--treeplex-primary);">üéØ Project Management</h3>
                        <div class="form-group">
                            <label>Status</label>
                            <select id="edit-pm-status">
                                <option value="To Do" ${activeNode.pmStatus === 'To Do' ? 'selected' : ''}>To Do</option>
                                <option value="In Progress" ${activeNode.pmStatus === 'In Progress' ? 'selected' : ''}>In Progress</option>
                                <option value="Completed" ${activeNode.pmStatus === 'Completed' ? 'selected' : ''}>Completed</option>
                                <option value="Blocked" ${activeNode.pmStatus === 'Blocked' ? 'selected' : ''}>Blocked</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Assignee / Owner</label>
                            <input type="text" id="edit-pm-assignee" value="${activeNode.pmAssignee || 'Unassigned'}" placeholder="Name or team..." />
                        </div>
                        <div class="form-group">
                            <label>Progress (%)</label>
                            <input type="number" id="edit-pm-progress" value="${activeNode.pmProgress || 0}" min="0" max="100" step="5" />
                        </div>
                        <div class="form-group">
                            <label>Priority</label>
                            <select id="edit-pm-priority">
                                <option value="Low" ${activeNode.pmPriority === 'Low' ? 'selected' : ''}>Low</option>
                                <option value="Medium" ${activeNode.pmPriority === 'Medium' ? 'selected' : ''}>Medium</option>
                                <option value="High" ${activeNode.pmPriority === 'High' ? 'selected' : ''}>High</option>
                                <option value="Critical" ${activeNode.pmPriority === 'Critical' ? 'selected' : ''}>Critical</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Start Date</label>
                            <input type="date" id="edit-pm-start-date" value="${activeNode.pmStartDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>Due Date</label>
                            <input type="date" id="edit-pm-due-date" value="${activeNode.pmDueDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>üöß Blocking Issue <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                            <textarea id="edit-pm-blocking-issue" style="min-height: 60px;" placeholder="What's preventing progress?">${activeNode.pmBlockingIssue || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>‚û°Ô∏è Next Steps <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                            <textarea id="edit-pm-next-steps" style="min-height: 80px;" placeholder="Specific actions needed...">${activeNode.pmNextSteps || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>PM Notes</label>
                            <textarea id="edit-pm-notes" style="min-height: 80px;" placeholder="Task-specific notes, blockers, action items...">${activeNode.pmNotes || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>üìù Latest Updates</label>
                            <div style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 8px; max-height: 200px; overflow-y: auto;">
                                ${activeNode.pmUpdates && activeNode.pmUpdates.length > 0 ? activeNode.pmUpdates.map((update, idx) => `
                                    <div style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border);">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">${new Date(update.timestamp).toLocaleString()}</div>
                                        <div style="font-size: 13px; line-height: 1.5;">${update.text}</div>
                                        <button onclick="window.deleteUpdate(${idx})" style="margin-top: 6px; padding: 2px 8px; font-size: 10px; background: rgba(239, 68, 68, 0.2); border: 1px solid #EF4444; border-radius: 4px; color: #EF4444; cursor: pointer;">Delete</button>
                                    </div>
                                `).join('') : '<p style="color: var(--text-secondary); font-size: 13px; text-align: center; padding: 20px;">No updates yet</p>'}
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <textarea id="edit-pm-new-update" style="flex: 1; min-height: 60px;" placeholder="Add a new update..."></textarea>
                                <button onclick="window.addUpdate()" style="padding: 8px 16px; background: var(--treeplex-primary); border: none; border-radius: 6px; color: white; font-weight: 600; cursor: pointer; white-space: nowrap;">Add Update</button>
                            </div>
                        </div>
                        <hr style="margin: 24px 0; border: none; border-top: 1px solid var(--border);" />
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--text-secondary);">Details</h3>
                    `;
                }

                // 2. Universal Fields (always shown)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Name <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <input type="text" id="edit-name" value="${activeNode.name || ''}" />
                    </div>
                    <div class="form-group">
                        <label>Description <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <textarea id="edit-description">${activeNode.description || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label>Icon <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <input type="text" id="edit-icon" value="${activeNode.icon || ''}" maxlength="2" />
                    </div>
                    <div class="form-group">
                        <label>Type</label>
                        <select id="edit-type">
                            ${PATTERNS[currentPattern].types.map(type =>
                                `<option value="${type.value}" ${activeNode.itemType === type.value ? 'selected' : ''}>${type.label}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;

                // 3. Pattern-Specific Custom Fields (dynamic)
                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }
                    const fieldConfig = fields[fieldKey];
                    fieldsHTML += generateFieldHTML(fieldKey, fieldConfig, activeNode);
                });

                // 4. Notes (universal)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Notes <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <textarea id="edit-notes" style="min-height: 100px;" placeholder="Additional notes...">${activeNode.notes || ''}</textarea>
                    </div>
                `;

                // 5. Dependencies (conditional)
                if (fields.includeDependencies) {
                    fieldsHTML += `
                        <div class="form-group">
                            <label>Dependencies</label>
                            <div style="max-height: 240px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 6px; background: var(--bg);">
                                ${depsHtml || '<p style="color: var(--text-secondary); font-size: 13px; margin: 0; padding: 10px; text-align: center;">No other items available</p>'}
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">‚úì Select prerequisite items that must be completed first</p>
                        </div>
                    `;
                }

                body.innerHTML = fieldsHTML;

                modal.style.display = 'flex';

                // Enable AI suggestions on text fields after modal is displayed
                setTimeout(() => {
                    // Universal fields
                    const nameField = document.getElementById('edit-name');
                    const descField = document.getElementById('edit-description');
                    const iconField = document.getElementById('edit-icon');
                    const notesField = document.getElementById('edit-notes');

                    if (nameField) enableAISuggestionsOnField(nameField, 'name', activeNode);
                    if (descField) enableAISuggestionsOnField(descField, 'description', activeNode);
                    if (iconField) enableAISuggestionsOnField(iconField, 'icon', activeNode);
                    if (notesField) enableAISuggestionsOnField(notesField, 'notes', activeNode);

                    // Pattern-specific fields (dynamic)
                    Object.keys(fields).forEach(fieldKey => {
                        if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                            return;
                        }
                        const fieldElement = document.getElementById(`edit-${fieldKey}`);
                        if (fieldElement) {
                            enableAISuggestionsOnField(fieldElement, fieldKey, activeNode);
                        }
                    });

                    // Enable AI suggestions for PM fields (conditional)
                    if (showTracking) {
                        const pmBlockingIssueField = document.getElementById('edit-pm-blocking-issue');
                        const pmNextStepsField = document.getElementById('edit-pm-next-steps');

                        if (pmBlockingIssueField) enableAISuggestionsOnField(pmBlockingIssueField, 'pmBlockingIssue', activeNode);
                        if (pmNextStepsField) enableAISuggestionsOnField(pmNextStepsField, 'pmNextSteps', activeNode);
                    }
                }, 50);
            }
        }

        function handleCreate() {
            if (activeNode && activeNode.type === 'phase') {
                // Create new item in this phase
                const labels = getPatternLabels();
                const defaultType = PATTERNS[currentPattern].types[0].value;
                const newItem = {
                    id: `p${activeNode.phase}-${Date.now()}`,
                    name: `New ${labels.item}`,
                    description: 'Enter description',
                    cost: 0,
                    icon: 'üì¶',
                    itemType: defaultType,
                    type: 'item',
                    dependencies: []
                };

                if (!activeNode.items) activeNode.items = [];
                activeNode.items.push(newItem);
                activeNode.expanded = true;
                render();
            }
        }

        function handleAddSubtask() {
            // Allow both items AND subtasks to have nested sub-tasks
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask')) {
                const labels = getPatternLabels();
                const isNestedSubtask = activeNode.type === 'subtask';
                const promptLabel = isNestedSubtask ? `nested ${labels.subtask}` : labels.subtask;

                // Prompt for sub-task name
                const subtaskName = prompt(`Enter ${promptLabel} name:`, `New ${isNestedSubtask ? 'Nested ' : ''}${labels.subtask}`);
                if (!subtaskName) return;

                // Get today's date in YYYY-MM-DD format
                const today = new Date().toISOString().split('T')[0];

                // Create new sub-task with PM fields
                const newSubtask = {
                    id: `${activeNode.id}-sub-${Date.now()}`,
                    name: subtaskName,
                    description: 'Task description',
                    cost: 0,
                    icon: 'üìã',
                    itemType: 'subtask',
                    type: 'subtask',
                    dependencies: [],
                    parentId: activeNode.id,
                    // Project Management fields
                    pmStatus: 'To Do',
                    pmAssignee: 'Unassigned',
                    pmStartDate: today,
                    pmDueDate: today,
                    pmProgress: 0,
                    pmPriority: 'Medium',
                    pmNotes: '',
                    pmBlockingIssue: '',
                    pmNextSteps: '',
                    pmUpdates: [],
                    // Initialize subItems for nested support
                    subItems: []
                };

                // Initialize subItems array if it doesn't exist
                if (!activeNode.subItems) activeNode.subItems = [];
                activeNode.subItems.push(newSubtask);

                // Mark parent as expanded to show sub-tasks
                activeNode.expanded = true;

                render();
                document.getElementById('context-menu').style.display = 'none';
            }
        }

        function handleDelete() {
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask')) {
                const itemType = activeNode.type === 'subtask' ? 'sub-task' : 'item';
                if (confirm(`Delete "${activeNode.name}" ${itemType}? This cannot be undone.`)) {
                    if (activeNode.type === 'subtask') {
                        // Remove subtask from its parent item
                        function removeSubtask(subtaskId, node = capexTree) {
                            if (node.items) {
                                for (let item of node.items) {
                                    if (item.subItems) {
                                        const index = item.subItems.findIndex(s => s.id === subtaskId);
                                        if (index !== -1) {
                                            item.subItems.splice(index, 1);
                                            return true;
                                        }
                                    }
                                }
                            }
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeSubtask(subtaskId, child)) return true;
                                }
                            }
                            return false;
                        }
                        removeSubtask(activeNode.id);
                    } else {
                        // Find and remove the item from its parent phase
                        function removeItem(itemId, node = capexTree) {
                            if (node.items) {
                                const index = node.items.findIndex(i => i.id === itemId);
                                if (index !== -1) {
                                    node.items.splice(index, 1);
                                    return true;
                                }
                            }
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeItem(itemId, child)) return true;
                                }
                            }
                            return false;
                        }
                        removeItem(activeNode.id);
                    }
                    render();
                }
            }
        }

        function handleDownload() {
            const jsonStr = JSON.stringify(capexTree, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;

            // Create unique timestamp: YYYY-MM-DD_HHMMSS
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const timestamp = `${year}-${month}-${day}_${hours}${minutes}${seconds}`;

            a.download = `treelisty-project-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function handleUpload() {
            document.getElementById('json-upload-input').click();
        }

        function handleExpandAll() {
            function expandAll(node) {
                if (node.children) {
                    node.expanded = true;
                    node.children.forEach(expandAll);
                }
            }
            expandAll(capexTree);
            render();
        }

        function handleCollapseAll() {
            function collapseAll(node) {
                if (node.children) {
                    node.expanded = false;
                    node.children.forEach(collapseAll);
                }
            }
            capexTree.children.forEach(collapseAll);
            render();
        }

        // Toggle subtasks for a specific item
        window.toggleSubtasks = function(itemId) {
            function findAndToggle(node) {
                if (node.items) {
                    const item = node.items.find(i => i.id === itemId);
                    if (item) {
                        item.expanded = !item.expanded;
                        render();
                        return true;
                    }
                }
                if (node.children) {
                    for (let child of node.children) {
                        if (findAndToggle(child)) return true;
                    }
                }
                return false;
            }
            findAndToggle(capexTree);
        };

        // Add update to current activeNode
        window.addUpdate = function() {
            if (!activeNode) return;
            const updateText = document.getElementById('edit-pm-new-update').value.trim();
            if (!updateText) {
                alert('Please enter an update message');
                return;
            }

            if (!activeNode.pmUpdates) activeNode.pmUpdates = [];
            activeNode.pmUpdates.unshift({
                timestamp: new Date().toISOString(),
                text: updateText
            });

            // Clear the input and re-render the modal
            document.getElementById('edit-pm-new-update').value = '';
            handleEdit(); // Re-render the edit modal to show the new update
        };

        // Delete update from current activeNode
        window.deleteUpdate = function(index) {
            if (!activeNode || !activeNode.pmUpdates) return;
            if (confirm('Delete this update?')) {
                activeNode.pmUpdates.splice(index, 1);
                handleEdit(); // Re-render the edit modal
            }
        };

        async function handleAI() {
            if (activeNode) {
                const modal = document.getElementById('modal');
                const modalBody = document.getElementById('modal-body');

                // Show loading state
                modalBody.innerHTML = `
                    <div style="padding: 40px; text-align: center;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">AI is analyzing ${activeNode.name}...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                `;
                modal.style.display = 'flex';

                try {
                    // Determine analysis type (subtask, item, or project)
                    let analysisType = 'item';
                    if (activeNode.type === 'root') {
                        analysisType = 'project';
                    } else if (activeNode.type === 'subtask') {
                        analysisType = 'subtask';
                    }

                    // Call real AI
                    const aiResponse = await generateAIAnalysis(activeNode, analysisType);

                    // Display AI response with markdown-like formatting
                    modalBody.innerHTML = `
                        <div style="padding: 20px; line-height: 1.8;">
                            <div style="white-space: pre-wrap; font-size: 14px; color: var(--text-primary);">${aiResponse}</div>
                            <div style="margin-top: 24px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ü§ñ Analysis powered by Claude Sonnet ‚Ä¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;

                } catch (error) {
                    // Show error
                    modalBody.innerHTML = `
                        <div style="padding: 30px; text-align: center;">
                            <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                            <h3 style="margin-bottom: 16px; color: var(--text-primary);">AI Analysis Failed</h3>
                            <p style="margin-bottom: 24px; color: var(--text-secondary); line-height: 1.6;">
                                ${error.message}
                            </p>
                            <p style="font-size: 12px; color: var(--text-secondary);">
                                If this problem persists, contact geej support.
                            </p>
                        </div>
                    `;
                }
            }
        }

        // Edit modal save/cancel handlers
        document.getElementById('edit-save').addEventListener('click', () => {
            if (activeNode) {
                // Save universal fields
                activeNode.name = document.getElementById('edit-name').value;
                activeNode.description = document.getElementById('edit-description').value;
                activeNode.icon = document.getElementById('edit-icon').value;
                activeNode.itemType = document.getElementById('edit-type').value;
                activeNode.notes = document.getElementById('edit-notes').value;

                // Save pattern-specific fields dynamically
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    const fieldElement = document.getElementById(`edit-${fieldKey}`);
                    if (fieldElement) {
                        const fieldConfig = fields[fieldKey];
                        if (fieldConfig.type === 'number') {
                            activeNode[fieldKey] = parseInt(fieldElement.value) || 0;
                        } else {
                            activeNode[fieldKey] = fieldElement.value;
                        }
                    }
                });

                // Collect selected dependencies from checkboxes (conditional)
                if (fields.includeDependencies) {
                    const depCheckboxes = document.querySelectorAll('.dep-checkbox');
                    const selectedDeps = [];
                    depCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedDeps.push(checkbox.value);
                        }
                    });
                    activeNode.dependencies = selectedDeps;
                }

                // Save PM fields for subtasks
                if (activeNode.type === 'subtask') {
                    const pmStatus = document.getElementById('edit-pm-status');
                    const pmAssignee = document.getElementById('edit-pm-assignee');
                    const pmStartDate = document.getElementById('edit-pm-start-date');
                    const pmDueDate = document.getElementById('edit-pm-due-date');
                    const pmProgress = document.getElementById('edit-pm-progress');
                    const pmPriority = document.getElementById('edit-pm-priority');
                    const pmNotes = document.getElementById('edit-pm-notes');
                    const pmBlockingIssue = document.getElementById('edit-pm-blocking-issue');
                    const pmNextSteps = document.getElementById('edit-pm-next-steps');

                    if (pmStatus) activeNode.pmStatus = pmStatus.value;
                    if (pmAssignee) activeNode.pmAssignee = pmAssignee.value;
                    if (pmStartDate) activeNode.pmStartDate = pmStartDate.value;
                    if (pmDueDate) activeNode.pmDueDate = pmDueDate.value;
                    if (pmProgress) activeNode.pmProgress = parseInt(pmProgress.value) || 0;
                    if (pmPriority) activeNode.pmPriority = pmPriority.value;
                    if (pmNotes) activeNode.pmNotes = pmNotes.value;
                    if (pmBlockingIssue) activeNode.pmBlockingIssue = pmBlockingIssue.value;
                    if (pmNextSteps) activeNode.pmNextSteps = pmNextSteps.value;
                    // pmUpdates are managed separately via window.addUpdate and window.deleteUpdate
                }

                document.getElementById('edit-modal').style.display = 'none';
                render();
            }
        });

        document.getElementById('edit-cancel').addEventListener('click', () => {
            document.getElementById('edit-modal').style.display = 'none';
        });

        // JSON upload handler
        document.getElementById('json-upload-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        // Validate basic structure
                        if (data.id && data.children) {
                            // Replace the tree data
                            Object.assign(capexTree, data);

                            // Restore pattern if saved
                            if (capexTree.pattern && capexTree.pattern.key) {
                                currentPattern = capexTree.pattern.key;
                                const patternSelect = document.getElementById('pattern-select');
                                if (patternSelect) {
                                    patternSelect.value = currentPattern;
                                }
                                if (currentPattern === 'custom' && capexTree.pattern.labels) {
                                    customPatternNames = capexTree.pattern.labels;
                                }
                            }

                            render();
                            alert('JSON loaded successfully!');
                        } else {
                            alert('Invalid JSON structure. Must have "id" and "children" properties.');
                        }
                    } catch (err) {
                        alert('Error parsing JSON: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
            // Reset input
            e.target.value = '';
        });

        // Controls
        document.getElementById('expand-btn').addEventListener('click', () => {
            function expandAll(node) {
                if (node.children) {
                    node.expanded = true;
                    node.children.forEach(expandAll);
                }
            }
            expandAll(capexTree);
            render();
        });

        document.getElementById('collapse-btn').addEventListener('click', () => {
            function collapseAll(node) {
                if (node.children) {
                    node.expanded = false;
                    node.children.forEach(collapseAll);
                }
            }
            capexTree.children.forEach(collapseAll);
            render();
        });

        // Save and Load JSON buttons in console
        document.getElementById('save-json-btn').addEventListener('click', handleDownload);
        document.getElementById('load-json-btn').addEventListener('click', handleUpload);

        // AI Modal - Overall Project Analysis (Dynamic AI-Generated)
        document.getElementById('ai-btn').addEventListener('click', async () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = '‚ú® AI Project Analysis';

            const totalCost = calculateTotal(capexTree);

            // Count items by phase
            function countItems(node, counts = {p0: 0, p1: 0, p2: 0}) {
                if (node.items && node.phase !== undefined) {
                    counts[`p${node.phase}`] += node.items.length;
                }
                if (node.children) {
                    node.children.forEach(child => countItems(child, counts));
                }
                return counts;
            }

            const itemCounts = countItems(capexTree);

            // Calculate phase costs (items only, not children)
            function getPhaseCost(phaseId) {
                const phase = findNode(phaseId);
                return phase ? calculatePhaseTotal(phase) : 0;
            }

            const phase0Cost = getPhaseCost('phase-0');
            const phase1Cost = getPhaseCost('phase-1');
            const phase2Cost = getPhaseCost('phase-2');

            // Show static summary cards first + loading state for AI analysis
            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, var(--treeplex-primary), #009977); color: white; padding: 24px; border-radius: 12px; margin-bottom: 24px;">
                        <h2 style="margin-bottom: 8px; font-size: 32px;">${formatCost(totalCost)}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Total Project Investment</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-0);">
                            <div style="font-size: 11px; font-weight: 600; color: #2e7d32; margin-bottom: 4px;">PHASE 0 ‚Ä¢ PRE-SEED</div>
                            <div style="font-size: 20px; font-weight: 700; color: #1b5e20; margin-bottom: 4px;">${formatCost(phase0Cost)}</div>
                            <div style="font-size: 12px; color: #2e7d32;">${itemCounts.p0} items</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-1);">
                            <div style="font-size: 11px; font-weight: 600; color: #1565c0; margin-bottom: 4px;">PHASE 1 ‚Ä¢ SEED</div>
                            <div style="font-size: 20px; font-weight: 700; color: #0d47a1; margin-bottom: 4px;">${formatCost(phase1Cost)}</div>
                            <div style="font-size: 12px; color: #1565c0;">${itemCounts.p1} items</div>
                        </div>
                        <div style="background: #fff3e0; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-2);">
                            <div style="font-size: 11px; font-weight: 600; color: #e65100; margin-bottom: 4px;">PHASE 2 ‚Ä¢ BUILD</div>
                            <div style="font-size: 20px; font-weight: 700; color: #bf360c; margin-bottom: 4px;">${formatCost(phase2Cost)}</div>
                            <div style="font-size: 12px; color: #e65100;">${itemCounts.p2} items</div>
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--text-secondary);">CAPITAL STRUCTURE</h4>
                        <p style="font-size: 14px; line-height: 1.6; margin-bottom: 12px; color: var(--text-primary);">
                            The project follows a phased capital deployment strategy with approximately
                            <strong>${((phase0Cost/totalCost)*100).toFixed(1)}%</strong> in Pre-Seed,
                            <strong>${((phase1Cost/totalCost)*100).toFixed(1)}%</strong> in Seed, and
                            <strong>${((phase2Cost/totalCost)*100).toFixed(1)}%</strong> in Build phases.
                        </p>
                        <div style="background: var(--bg); height: 24px; border-radius: 12px; overflow: hidden; display: flex;">
                            <div style="width: ${(phase0Cost/totalCost)*100}%; background: var(--phase-0);"></div>
                            <div style="width: ${(phase1Cost/totalCost)*100}%; background: var(--phase-1);"></div>
                            <div style="width: ${(phase2Cost/totalCost)*100}%; background: var(--phase-2);"></div>
                        </div>
                    </div>

                    <div id="ai-analysis-loading" style="padding: 40px; text-align: center; background: var(--card-bg); border-radius: 12px; margin-top: 20px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary); font-size: 14px;">AI is analyzing your project...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Generating Critical Path, Risk Assessment & Strategic Recommendations</p>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Call AI to generate the analysis sections dynamically
            console.log('ü§ñ Calling AI analysis at:', AI_CONFIG.apiEndpoint);
            try {
                const aiResponse = await generateAIAnalysis(capexTree, 'project');

                // Replace loading with AI-generated content
                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                        <div style="margin-bottom: 20px;">
                            <div id="ai-generated-content" style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                                <div style="white-space: pre-wrap; font-size: 14px; line-height: 1.8; color: var(--text-primary);">${aiResponse}</div>
                            </div>
                            <div style="margin-top: 16px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ü§ñ Analysis powered by Claude Sonnet ‚Ä¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;
                }

            } catch (error) {
                // Fallback to static analysis when AI is unavailable
                console.warn('AI Analysis unavailable, using static fallback:', error.message);

                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">CRITICAL PATH ANALYSIS</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    ‚Ä¢ <strong>Land acquisition</strong> is the primary gating factor for Phase 1 execution<br>
                                    ‚Ä¢ <strong>Turbine PO deposit</strong> (${formatCost(2000000)}) secures manufacturing capacity for Phase 2<br>
                                    ‚Ä¢ <strong>Pipeline FEED</strong> and permitting run in parallel to optimize timeline<br>
                                    ‚Ä¢ Phase 2 equipment procurement has 12-18 month lead times requiring early commitment
                                </p>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">RISK ASSESSMENT</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    <strong style="color: #d32f2f;">High Risk:</strong> Phase 2 represents ${((phase2Cost/totalCost)*100).toFixed(0)}% of total budget concentrated in equipment and infrastructure.<br>
                                    <strong style="color: #f57c00;">Medium Risk:</strong> Regulatory approvals for land, pipeline, and permitting on critical path.<br>
                                    <strong style="color: #388e3c;">Low Risk:</strong> Phase 0 has manageable capital exposure with assignable land options.
                                </p>
                            </div>

                            <div style="background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); padding: 20px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--treeplex-primary); text-transform: uppercase; letter-spacing: 0.5px;">STRATEGIC RECOMMENDATIONS</h4>
                                <ul style="font-size: 14px; line-height: 2; margin: 0; padding-left: 20px; color: var(--text-primary);">
                                    <li>Secure Phase 0 land option immediately to unlock downstream activities</li>
                                    <li>Negotiate payment milestones tied to regulatory approvals</li>
                                    <li>Consider project financing for Phase 2 to preserve equity</li>
                                    <li>Establish vendor relationships early for long-lead equipment items</li>
                                    <li>Build 10-15% contingency buffer beyond stated ${formatCost(310000)} reserves</li>
                                </ul>
                            </div>
                        </div>
                        <div style="margin-top: 16px; padding: 12px; background: rgba(255, 152, 0, 0.1); border-radius: 6px; text-align: center; border: 1px solid rgba(255, 152, 0, 0.3);">
                            <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                ‚ÑπÔ∏è AI Analysis unavailable ‚Ä¢ Showing static analysis ‚Ä¢ Deploy to Netlify for dynamic AI insights
                            </p>
                        </div>
                    </div>
                `;
                }
            }
        });

        document.getElementById('modal-close').addEventListener('click', () => {
            document.getElementById('modal').style.display = 'none';
        });

        // =============================================================================
        // API KEY CONFIGURATION
        // =============================================================================

        // Show/hide API key toggle
        document.getElementById('api-key-show').addEventListener('change', (e) => {
            const input = document.getElementById('api-key-input');
            input.type = e.target.checked ? 'text' : 'password';
        });

        // Cancel API key modal
        document.getElementById('api-key-cancel').addEventListener('click', () => {
            document.getElementById('api-key-modal').style.display = 'none';
        });

        document.getElementById('api-key-btn').addEventListener('click', () => {
            showApiKeyModal(true);
        });

        // Save API key
        document.getElementById('api-key-save').addEventListener('click', () => {
            const apiKey = document.getElementById('api-key-input').value.trim();

            if (!apiKey) {
                alert('Please enter an API key.');
                return;
            }

            if (!apiKey.startsWith('sk-ant-')) {
                alert('Invalid API key format. Anthropic API keys start with "sk-ant-"');
                return;
            }

            // Save to session storage
            setLocalAPIKey(apiKey);

            // Close modal
            document.getElementById('api-key-modal').style.display = 'none';

            // Show success message
            console.log('‚úÖ API key configured successfully');

            // If we came from Analysis Mode, reopen it
            if (window.pendingAnalysisMode) {
                window.pendingAnalysisMode = false;
                document.getElementById('analyze-text-btn').click();
            }
        });

        // Function to check if API key is configured
        function checkAPIKeyConfigured(options = {}) {
            const { forcePrompt = false } = options;
            const localKey = getLocalAPIKey();
            if (localKey) {
                return true;
            }

            if (!forcePrompt && canUseServerlessAI()) {
                console.log('üåê No local API key found. Using Netlify serverless function for AI calls.');
                return true;
            }

            // No local key and serverless unavailable (or prompt requested) - show modal
            showApiKeyModal(false);
            return false;
        }

        // =============================================================================
        // ANALYSIS MODE - TEXT TO TREE CONVERSION
        // =============================================================================

        let analysisText = '';
        let analysisFileName = '';

        // Open Analysis Modal
        document.getElementById('analyze-text-btn').addEventListener('click', () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                window.pendingAnalysisMode = true;
                return;
            }

            const modal = document.getElementById('analysis-modal');
            modal.style.display = 'flex';

            // Reset form
            document.getElementById('analysis-text-input').value = '';
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            document.getElementById('char-count').textContent = '0 characters';
            document.getElementById('analysis-warning').style.display = 'none';
            document.querySelector('input[name="analysis-mode"][value="quick"]').checked = true;
            analysisText = '';
            analysisFileName = '';
        });

        // Close Analysis Modal
        document.getElementById('analysis-cancel').addEventListener('click', () => {
            document.getElementById('analysis-modal').style.display = 'none';
        });

        // File Drop Zone - Click to browse
        const fileDropZone = document.getElementById('file-drop-zone');
        const fileInput = document.getElementById('analysis-file-input');

        fileDropZone.addEventListener('click', () => {
            fileInput.click();
        });

        // File selected via browse
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Drag and Drop handlers
        fileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--treeplex-primary)';
            fileDropZone.style.background = 'rgba(99, 102, 241, 0.05)';
        });

        fileDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';
        });

        fileDropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';

            const file = e.dataTransfer.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Handle file upload
        async function handleAnalysisFile(file) {
            // Check file type
            const validTypes = ['.txt', '.md'];
            const fileName = file.name.toLowerCase();
            const isValid = validTypes.some(type => fileName.endsWith(type));

            if (!isValid) {
                alert('Please upload a .txt or .md file only.');
                return;
            }

            // Show file name
            document.getElementById('selected-file-name').textContent = file.name;
            document.getElementById('file-name-display').style.display = 'block';
            analysisFileName = file.name;

            // Read file content
            const reader = new FileReader();
            reader.onload = (e) => {
                analysisText = e.target.result;

                // Clear text area since we're using file
                document.getElementById('analysis-text-input').value = '';

                // Update character count
                updateCharCount(analysisText.length);

                // Check file size and show warning if needed
                checkFileSize(analysisText.length);
            };
            reader.readAsText(file);
        }

        // Clear file button
        document.getElementById('clear-file-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            analysisText = '';
            analysisFileName = '';
            updateCharCount(0);
            document.getElementById('analysis-warning').style.display = 'none';
        });

        // Text area character count
        const textInput = document.getElementById('analysis-text-input');
        textInput.addEventListener('input', (e) => {
            analysisText = e.target.value;
            updateCharCount(analysisText.length);
            checkFileSize(analysisText.length);

            // Clear file if typing in text area
            if (analysisText.length > 0 && analysisFileName) {
                document.getElementById('analysis-file-input').value = '';
                document.getElementById('file-name-display').style.display = 'none';
                analysisFileName = '';
            }
        });

        function updateCharCount(count) {
            const charCountEl = document.getElementById('char-count');
            const words = count > 0 ? analysisText.trim().split(/\s+/).length : 0;
            charCountEl.textContent = `${count.toLocaleString()} characters (~${words} words)`;

            if (count > 50000) {
                charCountEl.style.color = '#ff9f43';
            } else {
                charCountEl.style.color = 'var(--text-secondary)';
            }
        }

        function checkFileSize(charCount) {
            const warningEl = document.getElementById('analysis-warning');
            const warningText = document.getElementById('analysis-warning-text');

            // Rough token estimate: 1 token ‚âà 4 characters
            const estimatedTokens = Math.ceil(charCount / 4);
            const estimatedWords = Math.ceil(charCount / 5);

            if (charCount > 15000) { // Will be truncated
                warningEl.style.display = 'block';
                warningText.textContent = `‚ö†Ô∏è Text is ${charCount.toLocaleString()} characters (~${estimatedWords.toLocaleString()} words). Will be automatically truncated to 15,000 characters (~3,750 words) to prevent timeouts. Consider pasting a shorter excerpt for best results.`;
            } else if (charCount > 10000) { // Large but ok
                warningEl.style.display = 'block';
                warningText.textContent = `Large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis may take 30-60 seconds. Quick Mode recommended.`;
            } else if (charCount > 5000) {
                warningEl.style.display = 'block';
                warningText.textContent = `Medium text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis should take 15-30 seconds.`;
            } else {
                warningEl.style.display = 'none';
            }
        }

        // =============================================================================
        // AI PATTERN DETECTION & TEXT-TO-TREE CONVERSION
        // =============================================================================

        // Pattern detection function
        async function detectPattern(text) {
            const prompt = `Analyze the following text and determine the 3 most appropriate TreeListy patterns for organizing it.

AVAILABLE PATTERNS:
1. Generic Project - Universal structure for any project (Project ‚Üí Phase ‚Üí Item ‚Üí Task)
2. Sales Pipeline - Deal tracking across quarters (Pipeline ‚Üí Quarter ‚Üí Deal ‚Üí Action)
3. Academic Writing - Thesis/research paper structure (Thesis ‚Üí Chapter ‚Üí Section ‚Üí Point)
4. Product Roadmap - Feature development timeline (Product ‚Üí Quarter ‚Üí Feature ‚Üí Story)
5. Book Writing - Narrative structure (Book ‚Üí Part ‚Üí Chapter ‚Üí Scene)
6. Event Planning - Event organization and logistics (Event ‚Üí Stage ‚Üí Activity ‚Üí Task)
7. Fitness Program - Workout programs and exercises (Program ‚Üí Phase ‚Üí Workout ‚Üí Exercise)
8. Strategic Plan - Business initiatives and metrics (Strategy ‚Üí Pillar ‚Üí Initiative ‚Üí Action)
9. Course Design - Educational curriculum structure (Course ‚Üí Unit ‚Üí Lesson ‚Üí Exercise)
10. Film Production - Film/video production workflow (Film ‚Üí Phase ‚Üí Scene ‚Üí Shot)
11. Philosophy - Philosophical arguments and treatises (Treatise ‚Üí Book ‚Üí Argument ‚Üí Premise)
12. Family Tree - Genealogical documentation (Family ‚Üí Generation ‚Üí Person ‚Üí Event)

TEXT TO ANALYZE:
${text.substring(0, 5000)}${text.length > 5000 ? '\n\n[... truncated for analysis ...]' : ''}

Respond with ONLY a valid JSON object in this exact format:
{
  "recommendations": [
    {
      "pattern": "pattern-key",
      "patternName": "Pattern Display Name",
      "confidence": 9,
      "reasoning": "Brief explanation of why this pattern fits"
    }
  ]
}

Provide exactly 3 recommendations, ranked by confidence (1-10). Use these pattern keys: generic, sales, thesis, roadmap, book, event, fitness, strategy, course, film, philosophy, familytree`;

            const response = await callClaudeAPI(prompt);

            try {
                // Extract JSON from response
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    return result.recommendations;
                }
            } catch (e) {
                console.error('Failed to parse pattern detection response:', e);
            }

            // Fallback to generic
            return [{
                pattern: 'generic',
                patternName: 'Generic Project',
                confidence: 5,
                reasoning: 'Default fallback pattern'
            }];
        }

        // Helper function to fix common JSON issues
        function repairJSON(jsonText) {
            // First, escape control characters that might appear in string values
            // We need to do this carefully to not break the JSON structure

            // Find all string values and escape control characters within them
            jsonText = jsonText.replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, function(match) {
                // Within each string, escape control characters
                return match
                    .replace(/\n/g, '\\n')
                    .replace(/\r/g, '\\r')
                    .replace(/\t/g, '\\t');
            });

            // Remove trailing commas before closing brackets/braces (run multiple times to catch nested cases)
            let previousText;
            do {
                previousText = jsonText;
                jsonText = jsonText.replace(/,(\s*[}\]])/g, '$1');
            } while (jsonText !== previousText);

            // Remove comments (// and /* */)
            jsonText = jsonText.replace(/\/\/.*$/gm, '');
            jsonText = jsonText.replace(/\/\*[\s\S]*?\*\//g, '');

            return jsonText;
        }

        // Quick Mode: Basic structure conversion
        async function convertTextToTreeQuick(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;

            const prompt = `Convert this text into a hierarchical project structure using the "${patternConfig.name}" pattern.

PATTERN HIERARCHY:
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}

TEXT:
${text}

INSTRUCTIONS:
1. Identify natural hierarchical structure in the text
2. Create 2-5 phases (${levels.phase}s)
3. For each phase, create 2-10 items (${levels.item}s)
4. For each item, optionally create 2-4 subtasks (${levels.subtask}s) if the item is complex
5. Keep it simple - focus on clear structure
6. Extract names and basic descriptions

JSON FORMATTING RULES (CRITICAL - FOLLOW EXACTLY):
- NO trailing commas after the last element in arrays or objects
- NO line breaks or tabs inside string values - use spaces instead
- NO unescaped quotes inside strings
- ONLY plain JSON - no markdown code blocks, no backticks, no explanations
- Start response with { and end with }

CORRECT EXAMPLE (note: NO trailing comma after last item):
{"phases": [{"name": "Test", "items": [{"name": "Item"}]}]}

WRONG (trailing comma):
{"phases": [{"name": "Test", "items": [{"name": "Item"},]}]}

Respond with ONLY valid, parseable JSON:
{
  "projectName": "Extracted or inferred project name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle or description",
      "icon": "üìã",
      "items": [
        {
          "name": "Item name",
          "description": "Brief description",
          "itemType": "type-if-applicable",
          "subtasks": [
            { "name": "Subtask name (optional)" }
          ]
        }
      ]
    }
  ]
}`;

            const response = await callClaudeAPI(prompt, '', 4096, true); // Extended thinking enabled for careful JSON generation

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the first { and last }
                const firstBrace = jsonText.indexOf('{');
                const lastBrace = jsonText.lastIndexOf('}');

                if (firstBrace !== -1 && lastBrace !== -1) {
                    jsonText = jsonText.substring(firstBrace, lastBrace + 1);
                }

                // Repair common JSON issues
                jsonText = repairJSON(jsonText);

                // Log the extracted JSON for debugging
                console.log('Extracted JSON (Quick):', jsonText.substring(0, 500) + '...');

                return JSON.parse(jsonText);
            } catch (e) {
                console.error('Failed to parse quick conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('üîß Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('‚úÖ JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('‚ùå Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Deep Mode: Detailed parsing with field extraction
        async function convertTextToTreeDeep(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            // Build field hints for AI
            let fieldHints = '';
            if (fields.cost) {
                fieldHints += '\n- Extract any cost/budget/price information as numbers';
            }
            if (fields.dealValue) {
                fieldHints += '\n- Extract deal values and revenue numbers';
            }
            if (fields.wordCount) {
                fieldHints += '\n- Estimate word counts for sections';
            }
            if (fields.storyPoints) {
                fieldHints += '\n- Assign story points (1-13) based on complexity';
            }
            if (fields.includeDependencies) {
                fieldHints += '\n- Identify dependencies between items (what depends on what)';
            }

            const prompt = `Convert this text into a detailed hierarchical project structure using the "${patternConfig.name}" pattern.

PATTERN HIERARCHY (3 LEVELS):
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}

PATTERN-SPECIFIC FIELDS TO EXTRACT:${fieldHints || '\n- Extract name and description'}

TEXT:
${text}

INSTRUCTIONS:
1. Analyze the text and identify hierarchical structure
2. Create 3-5 phases (${levels.phase}s) - keep it concise
3. For each phase, create 3-8 items (${levels.item}s)
4. For complex items, optionally add 2-4 subtasks (${levels.subtask}s)
5. Extract pattern-specific field values if clearly stated in text
6. Identify dependencies between items ONLY if explicitly mentioned (format: "item-X-Y")
7. Assign types/categories to items

IMPORTANT: Be concise. Quality over quantity. Focus on the main structure.

JSON FORMATTING RULES (CRITICAL - FOLLOW EXACTLY):
- NO trailing commas after the last element in arrays or objects
- NO line breaks or tabs inside string values - use spaces instead
- NO unescaped quotes inside strings
- ONLY plain JSON - no markdown code blocks, no backticks, no explanations
- Start response with { and end with }

CORRECT EXAMPLE (note: NO trailing comma after last item):
{"phases": [{"name": "Test", "items": [{"name": "Item"}]}]}

WRONG (trailing comma):
{"phases": [{"name": "Test", "items": [{"name": "Item"},]}]}

Respond with ONLY valid, parseable JSON:
{
  "projectName": "Extracted or inferred project name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle",
      "icon": "üìã",
      "items": [
        {
          "name": "Item name",
          "description": "Detailed description",
          "itemType": "category",
          "cost": 1000,
          "dependencies": ["item-0-1", "item-1-2"],
          "subtasks": [
            {
              "name": "Subtask name",
              "description": "What needs to be done",
              "dependencies": []
            }
          ],
          "... other pattern-specific fields ...": "values"
        }
      ]
    }
  ]
}`;

            const response = await callClaudeAPI(prompt, '', 4096, true); // Extended thinking enabled for careful JSON generation

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the first { and last }
                const firstBrace = jsonText.indexOf('{');
                const lastBrace = jsonText.lastIndexOf('}');

                if (firstBrace !== -1 && lastBrace !== -1) {
                    jsonText = jsonText.substring(firstBrace, lastBrace + 1);
                }

                // Repair common JSON issues
                jsonText = repairJSON(jsonText);

                // Log the extracted JSON for debugging
                console.log('Extracted JSON (Deep):', jsonText.substring(0, 500) + '...');

                return JSON.parse(jsonText);
            } catch (e) {
                console.error('Failed to parse deep conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('üîß Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('‚úÖ JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('‚ùå Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Main Analyze button handler
        document.getElementById('analysis-start-btn').addEventListener('click', async () => {
            // Get text from file or textarea
            const textFromTextarea = document.getElementById('analysis-text-input').value.trim();
            let finalText = analysisText || textFromTextarea;

            if (!finalText) {
                alert('Please upload a file or paste text to analyze.');
                return;
            }

            // Auto-truncate very long texts to prevent timeouts
            const MAX_CHARS = 15000; // ~3750 words max
            let wasTruncated = false;
            if (finalText.length > MAX_CHARS) {
                wasTruncated = true;
                finalText = finalText.substring(0, MAX_CHARS);
                console.warn(`‚ö†Ô∏è Text truncated from ${analysisText.length} to ${MAX_CHARS} characters to prevent timeout`);
            }

            // Get selected mode
            const mode = document.querySelector('input[name="analysis-mode"]:checked').value;

            // Warn if text was truncated
            if (wasTruncated) {
                const proceed = confirm(`‚ö†Ô∏è Your text is very long and has been automatically truncated to ${MAX_CHARS} characters (~${Math.floor(MAX_CHARS/4)} words) to prevent timeouts.\n\nOnly the first portion will be analyzed.\n\nDo you want to continue?`);
                if (!proceed) {
                    return;
                }
            }

            // Close analysis modal and show loading modal
            document.getElementById('analysis-modal').style.display = 'none';
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'üîç Analyzing Text...';
            modal.style.display = 'flex';
            modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 1/3: Detecting optimal pattern...</p>';

            try {
                // Step 1: Detect pattern
                const recommendations = await detectPattern(finalText);

                // Show pattern selection
                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <h3 style="margin-bottom: 16px; color: var(--text-primary);">üìä Recommended Patterns</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px; font-size: 14px;">
                            AI analyzed your text and recommends these patterns. Select one to continue:
                        </p>
                        <div id="pattern-recommendations" style="display: flex; flex-direction: column; gap: 12px;">
                            ${recommendations.map((rec, index) => `
                                <label style="display: flex; align-items: flex-start; padding: 16px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s; background: var(--card-bg);" class="pattern-rec-option" data-pattern="${rec.pattern}">
                                    <input type="radio" name="selected-pattern" value="${rec.pattern}" ${index === 0 ? 'checked' : ''} style="margin-top: 4px; margin-right: 12px;" />
                                    <div style="flex: 1;">
                                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                            <span style="font-weight: 600; color: var(--text-primary); font-size: 15px;">${rec.patternName}</span>
                                            <span style="background: ${rec.confidence >= 8 ? '#4caf50' : rec.confidence >= 6 ? '#ff9f43' : '#666'}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">
                                                ${rec.confidence}/10 confidence
                                            </span>
                                        </div>
                                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                            ${rec.reasoning}
                                        </div>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                        <div style="margin-top: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">
                                Analysis Mode: ${mode === 'quick' ? '‚ö° Quick Mode' : 'üî¨ Deep Mode'}
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary);">
                                ${mode === 'quick' ? 'Fast analysis with basic structure extraction.' : 'Detailed analysis with field extraction and dependencies.'}
                            </div>
                        </div>
                    </div>
                `;

                // Add hover effects to pattern options
                document.querySelectorAll('.pattern-rec-option').forEach(option => {
                    option.addEventListener('mouseenter', () => {
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                    option.addEventListener('mouseleave', () => {
                        const radio = option.querySelector('input[type="radio"]');
                        if (!radio.checked) {
                            option.style.borderColor = 'var(--border)';
                            option.style.background = 'var(--card-bg)';
                        }
                    });
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.pattern-rec-option').forEach(opt => {
                            opt.style.borderColor = 'var(--border)';
                            opt.style.background = 'var(--card-bg)';
                        });
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                });

                // Update modal footer with continue button
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="pattern-select-cancel">Cancel</button>
                    <button class="btn btn-primary" id="pattern-select-continue" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Continue ‚Üí</button>
                `;

                document.getElementById('pattern-select-cancel').addEventListener('click', () => {
                    modal.style.display = 'none';
                });

                document.getElementById('pattern-select-continue').addEventListener('click', async () => {
                    const selectedPattern = document.querySelector('input[name="selected-pattern"]:checked').value;

                    // Step 2: Convert text to tree
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 2/3: Converting text to tree structure...</p>';
                    document.querySelector('#modal .modal-footer').innerHTML = '';

                    try {
                        let treeData;
                        if (mode === 'quick') {
                            treeData = await convertTextToTreeQuick(finalText, selectedPattern);
                        } else {
                            treeData = await convertTextToTreeDeep(finalText, selectedPattern);
                        }

                        // Step 3: Preview and import
                        showAnalysisPreview(treeData, selectedPattern);

                    } catch (error) {
                        modalBody.innerHTML = `
                            <div style="padding: 20px; text-align: center;">
                                <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                                <h3 style="color: #f44336; margin-bottom: 12px;">Analysis Failed</h3>
                                <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                            </div>
                        `;
                        document.querySelector('#modal .modal-footer').innerHTML = `
                            <button class="btn" id="error-close">Close</button>
                            <button class="btn btn-primary" id="error-retry">Try Again</button>
                        `;

                        document.getElementById('error-close').addEventListener('click', () => {
                            modal.style.display = 'none';
                        });

                        document.getElementById('error-retry').addEventListener('click', () => {
                            modal.style.display = 'none';
                            document.getElementById('analyze-text-btn').click();
                        });
                    }
                });

            } catch (error) {
                modalBody.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                        <h3 style="color: #f44336; margin-bottom: 12px;">Pattern Detection Failed</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                    </div>
                `;
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="error-close">Close</button>
                `;

                document.getElementById('error-close').addEventListener('click', () => {
                    modal.style.display = 'none';
                });
            }
        });

        // Show preview before importing
        function showAnalysisPreview(treeData, selectedPattern) {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            document.getElementById('modal-title').textContent = '‚úÖ Analysis Complete - Preview';

            // Count phases and items
            const phaseCount = treeData.phases?.length || 0;
            const itemCount = treeData.phases?.reduce((sum, phase) => sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, #4caf50, #00a67d); color: white; padding: 20px; border-radius: 12px; margin-bottom: 24px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 8px;">‚ú®</div>
                        <h2 style="margin-bottom: 8px; font-size: 24px;">${treeData.projectName || 'Analyzed Project'}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Pattern: ${PATTERNS[selectedPattern].name}</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${phaseCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Phases Detected</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${itemCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Items Created</div>
                        </div>
                    </div>

                    <div style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 16px; background: var(--bg-secondary);">
                        <h4 style="margin-bottom: 12px; color: var(--text-primary);">Structure Preview:</h4>
                        ${treeData.phases?.map((phase, i) => `
                            <div style="margin-bottom: 16px;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px;">
                                    ${phase.icon || 'üìã'} ${phase.name}
                                </div>
                                <div style="margin-left: 20px; font-size: 13px; color: var(--text-secondary);">
                                    ${phase.items?.slice(0, 3).map(item => `‚Ä¢ ${item.name}`).join('<br>')}
                                    ${phase.items?.length > 3 ? `<br>... and ${phase.items.length - 3} more items` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-top: 20px; padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px;">
                        <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">‚ö†Ô∏è Import Warning</div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            Importing will replace your current project. Your current project will be saved as a backup first.
                        </div>
                    </div>
                </div>
            `;

            // Create buttons directly with event listeners attached
            const modalFooter = document.querySelector('#modal .modal-footer');
            if (!modalFooter) {
                console.error('‚ùå Modal footer not found!');
                alert('Error: Modal footer not found. Please refresh the page.');
                return;
            }

            // Clear existing content
            modalFooter.innerHTML = '';

            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => {
                console.log('üö´ Import cancelled');
                modal.style.display = 'none';
            };

            // Create import button
            const importBtn = document.createElement('button');
            importBtn.className = 'btn btn-primary';
            importBtn.style.cssText = 'background: linear-gradient(135deg, #4caf50, #00a67d);';
            importBtn.textContent = 'üì• Import to TreeListy';
            importBtn.onclick = () => {
                console.log('üîÑ Import button clicked!', { hasTreeData: !!treeData, hasPattern: !!selectedPattern });
                try {
                    importAnalyzedTree(treeData, selectedPattern);
                    modal.style.display = 'none';
                } catch (error) {
                    console.error('‚ùå Import failed:', error);
                    alert('Import failed: ' + error.message);
                }
            };

            // Add buttons to footer
            modalFooter.appendChild(cancelBtn);
            modalFooter.appendChild(importBtn);

            console.log('‚úÖ Preview modal ready with import button');
        }

        // Import analyzed tree into TreeListy
        function importAnalyzedTree(treeData, selectedPattern) {
            console.log('üì• Starting import...', { treeData, selectedPattern });

            // Backup current project first
            const backup = JSON.stringify(capexTree, null, 2);
            const backupName = `treelisty_backup_${Date.now()}.json`;
            console.log('üíæ Current project backed up as:', backupName);

            // Switch to selected pattern
            currentPattern = selectedPattern;
            document.getElementById('pattern-select').value = selectedPattern;

            // Convert analyzed data to TreeListy format
            const newTree = {
                type: 'root',
                id: 'root',
                name: treeData.projectName || 'Analyzed Project',
                icon: 'üå≤',
                expanded: true,
                children: treeData.phases?.map((phase, phaseIndex) => ({
                    type: 'phase',
                    id: `phase-${phaseIndex}`,
                    phase: phaseIndex,
                    name: phase.name,
                    subtitle: phase.subtitle || PATTERNS[selectedPattern].phaseSubtitles?.[phaseIndex] || '',
                    icon: phase.icon || 'üìã',
                    expanded: true,
                    cost: 0,
                    items: phase.items?.map((item, itemIndex) => {
                        const itemId = `item-${phaseIndex}-${itemIndex}`;

                        // Build item object with all required fields
                        const itemObj = {
                            type: 'item',
                            id: itemId,
                            name: item.name,
                            description: item.description || '',
                            itemType: item.itemType || '',
                            icon: item.icon || 'üìÑ',
                            cost: item.cost || 0,
                            dependencies: item.dependencies || [],
                            notes: item.notes || '',
                            leadTime: item.leadTime || '',
                            alternateSource: item.alternateSource || '',
                            expanded: false,
                            // Pattern-specific fields
                            dealValue: item.dealValue || 0,
                            wordCount: item.wordCount || 0,
                            storyPoints: item.storyPoints || 0,
                            // Add any other fields from AI
                            ...item
                        };

                        // Add subtasks if they exist (3rd level hierarchy)
                        if (item.subtasks && item.subtasks.length > 0) {
                            itemObj.children = item.subtasks.map((subtask, subtaskIndex) => ({
                                type: 'subtask',
                                id: `subtask-${phaseIndex}-${itemIndex}-${subtaskIndex}`,
                                name: subtask.name || subtask,
                                description: subtask.description || '',
                                icon: subtask.icon || 'üìå',
                                notes: subtask.notes || '',
                                dependencies: subtask.dependencies || [],
                                // Pattern-specific fields
                                ...subtask
                            }));
                        }

                        return itemObj;
                    }) || []
                })) || []
            };

            // Replace current tree
            capexTree = newTree;

            // Render
            render();

            // Count total items and subtasks
            const totalItems = treeData.phases?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0;
            const totalSubtasks = treeData.phases?.reduce((sum, p) =>
                sum + (p.items?.reduce((subSum, item) => subSum + (item.subtasks?.length || 0), 0) || 0), 0) || 0;

            // Show success message
            let message = `‚úÖ Successfully imported!\n\n${treeData.phases?.length || 0} phases and ${totalItems} items`;
            if (totalSubtasks > 0) {
                message += ` and ${totalSubtasks} subtasks`;
            }
            message += ` have been created.\n\nPattern: ${PATTERNS[selectedPattern].name}`;
            alert(message);
        }

        // How to Use button
        document.getElementById('how-to-btn').addEventListener('click', () => {
            const modal = document.getElementById('modal');
            document.getElementById('modal-title').textContent = 'üìñ How to Use TreeListy';
            document.getElementById('modal-body').innerHTML = `
                <div style="padding: 20px; line-height: 1.8;">
                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">üí° What is TreeListy?</h3>
                    <p style="margin-bottom: 20px; font-size: 14px;">
                        <strong>TreeListy</strong> is a universal tool for breaking down any complex project, problem, or process into manageable parts.\n                        Structure your work into phases, track dependencies between components, and analyze your entire plan at a glance.\n                        Use it for software projects, events, research, personal goals, or anything else that benefits from structured thinking! üå≥‚ú®üéØ
                    </p>

                    <h3 style="color: var(--phase-1); margin-bottom: 16px; font-size: 20px;">üöÄ Getting Started</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-1);">
                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>1. Create Items</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Right-click on any Phase ‚Üí "Add Item"</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Fill in Name, Description, Cost, and Lead Time</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>2. Use Smart Suggestions üí°</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Right-click any text field ‚Üí "Smart Suggest"</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Cost suggestions learn from similar items in your project!</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Add Context Notes for even better suggestions</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>3. Set Dependencies</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Edit an item ‚Üí Check boxes in Dependencies section</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Watch dependency arrows appear automatically! üéØ</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>4. Use AI Analysis ü§ñ</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Click any item ‚Üí "ü§ñ AI Analysis" button</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Get intelligent insights powered by Claude Sonnet</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Risk analysis, cost optimization, and procurement strategy</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>5. Save Your Work üíæ</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Click "üíæ Save" button in the toolbar</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Or right-click Root/Phase ‚Üí "Download JSON"</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Filename includes timestamp (treelisty-project-2025-11-02_143025.json)</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>6. Load Saved Projects üìÇ</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Click "üìÇ Load" button in the toolbar</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Or right-click Root/Phase ‚Üí "Upload JSON"</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>7. Export to Excel üìä</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Click "üìä Excel" button in the toolbar</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Get 4-sheet professional workbook with executive summary</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Perfect for sharing with investors and stakeholders!</p>
                    </div>

                    <h3 style="color: var(--phase-2); margin-bottom: 16px; font-size: 20px;">üìä Investor Presentations</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-2);">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy is your secret weapon for investor meetings!</strong> Here's how to wow your audience:
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üéØ Visual Impact</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Expand all phases to show the complete project roadmap<br>
                            ‚Ä¢ Dependency arrows show critical path in real-time<br>
                            ‚Ä¢ Phase colors guide investors through the timeline
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üí∞ Financial Transparency</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Click any item to show detailed cost breakdowns<br>
                            ‚Ä¢ Smart Analysis compares costs to similar items<br>
                            ‚Ä¢ Automatic alerts for cost anomalies (+/- 50% from average)<br>
                            ‚Ä¢ Phase totals show capital deployment strategy
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">‚ö° Risk Management</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Show Alternate Sources for key equipment<br>
                            ‚Ä¢ Lead Times demonstrate realistic planning<br>
                            ‚Ä¢ Dependencies prove you've thought through execution
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üìä Excel Export for Presentations</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Click "üìä Export to Excel" for investor-ready spreadsheets<br>
                            ‚Ä¢ 4 professional sheets: Executive Summary, Details, Dependencies, Cost Analysis<br>
                            ‚Ä¢ Share with board members and stakeholders<br>
                            ‚Ä¢ Auto-formatted with phase colors and totals
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ü§ñ AI-Powered Insights</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Use "ü§ñ AI Analysis" for instant expert analysis<br>
                            ‚Ä¢ Get risk assessments and cost optimization recommendations<br>
                            ‚Ä¢ Claude Sonnet provides strategic procurement insights<br>
                            ‚Ä¢ Perfect for due diligence questions
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üé§ Pro Tip</p>
                        <p style="font-size: 13px; margin-bottom: 8px; font-style: italic; color: var(--treeplex-primary);">
                            During your pitch, use AI Analysis to demonstrate data-driven planning. Export to Excel
                            before the meeting so stakeholders can follow along with printed materials. The combination
                            of live visualization + professional spreadsheets = credibility! üòé
                        </p>
                    </div>

                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">üé® Navigation Tips</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Toolbar buttons (top right)</strong> - Quick access to Save, Load, Excel, and AI</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Click any node</strong> to expand/collapse or view details</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Right-click anywhere</strong> for context menus with quick actions</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Indented items</strong> (shifted right) depend on items above them</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Dependency lines</strong> show cross-phase relationships</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Phase backgrounds</strong> change color (green ‚Üí blue ‚Üí orange)</p>
                        <p style="font-size: 13px;">‚Ä¢ <strong>Hover over items</strong> to see them pop with 3D effects!</p>
                    </div>

                    <div style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.1), rgba(59, 143, 204, 0.1)); border-radius: 8px; text-align: center;">
                        <p style="font-size: 14px; font-weight: 600; color: var(--treeplex-primary); margin-bottom: 8px;">
                            üöÄ Ready to build something amazing?
                        </p>
                        <p style="font-size: 13px; opacity: 0.9;">
                            Close this dialog and start planning your next billion-dollar project!
                        </p>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
        });

        // =============================================================================
        // EXCEL EXPORT - Professional Multi-Sheet Workbook for Investors
        // =============================================================================

        function exportToExcel() {
            // Create a new workbook
            const wb = XLSX.utils.book_new();

            // Collect all items AND subtasks from the tree (proper phase structure)
            const allItems = [];
            const allTasks = []; // Subtasks for separate PM sheet (recursive)

            // RECURSIVE function to collect nested subtasks
            function collectSubtasks(parentItem, parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel = 0) {
                if (!parentItem.subItems || !Array.isArray(parentItem.subItems)) {
                    return;
                }

                parentItem.subItems.forEach(subtask => {
                    const indent = '  '.repeat(nestLevel); // Indentation for hierarchy
                    allTasks.push({
                        ...subtask,
                        parentItem: parentName,
                        parentItemId: parentItem.id,
                        phaseName: phaseName,
                        phaseSubtitle: phaseSubtitle,
                        phaseNumber: phaseNumber,
                        nestLevel: nestLevel,
                        taskName: indent + subtask.name  // Indented name for Excel
                    });

                    // RECURSIVELY collect nested subtasks
                    collectSubtasks(subtask, subtask.name, phaseName, phaseSubtitle, phaseNumber, nestLevel + 1);
                });
            }

            function collectItems(node) {
                // Collect items from this phase node
                if (node.items && Array.isArray(node.items)) {
                    node.items.forEach(item => {
                        allItems.push({
                            ...item,
                            phaseName: node.name || 'Unknown Phase',
                            phaseSubtitle: node.subtitle || '',
                            phaseNumber: node.phase || '0'
                        });

                        // Collect subtasks recursively for PM tracking
                        collectSubtasks(item, item.name, node.name || 'Unknown Phase', node.subtitle || '', node.phase || '0', 0);
                    });
                }

                // Recursively collect from child phases
                if (node.children && Array.isArray(node.children)) {
                    node.children.forEach(child => {
                        collectItems(child);
                    });
                }
            }
            collectItems(capexTree);

            // Calculate totals
            const totalCost = allItems.reduce((sum, item) => sum + (item.cost || 0), 0);

            // Group by phase dynamically
            const phaseBreakdown = {};
            allItems.forEach(item => {
                const phaseKey = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;
                if (!phaseBreakdown[phaseKey]) {
                    phaseBreakdown[phaseKey] = { total: 0, count: 0, phaseNumber: item.phaseNumber };
                }
                phaseBreakdown[phaseKey].total += (item.cost || 0);
                phaseBreakdown[phaseKey].count++;
            });

            // =================================================================
            // SHEET 1: EXECUTIVE SUMMARY
            // =================================================================
            const summaryData = [
                ['TREEPLEXITY - PROJECT SUMMARY'],
                ['by geej', '', '', ''],
                [],
                ['Project:', capexTree.name || 'Project Plan'],
                ['Pattern:', capexTree.pattern && capexTree.pattern.key ? PATTERNS[capexTree.pattern.key].name : 'Generic Project'],
                ['Total Cost:', `$${(totalCost / 1000000).toFixed(2)}M`],
                ['Items Count:', allItems.length],
                ['Report Date:', new Date().toLocaleDateString()],
                [],
                ['INVESTMENT BREAKDOWN BY PHASE'],
                [],
                ['Phase', 'Investment', 'Percentage', 'Items']
            ];

            // Add phase rows dynamically (sorted by phase number)
            Object.entries(phaseBreakdown)
                .sort((a, b) => (a[1].phaseNumber || '0').localeCompare(b[1].phaseNumber || '0'))
                .forEach(([phaseName, data]) => {
                    summaryData.push([
                        phaseName,
                        `$${(data.total / 1000000).toFixed(2)}M`,
                        `${((data.total / totalCost) * 100).toFixed(1)}%`,
                        data.count
                    ]);
                });

            // Add total row
            summaryData.push(['TOTAL', `$${(totalCost / 1000000).toFixed(2)}M`, '100.0%', allItems.length]);

            // Add key metrics
            summaryData.push([]);
            summaryData.push(['KEY METRICS']);
            summaryData.push([]);
            summaryData.push(['Metric', 'Value']);
            summaryData.push(['Average Item Cost', allItems.length > 0 ? `$${(totalCost / allItems.length / 1000).toFixed(0)}K` : '$0']);
            summaryData.push(['Largest Single Item', allItems.length > 0 ? `$${(Math.max(...allItems.map(i => i.cost || 0)) / 1000000).toFixed(2)}M` : '$0']);
            summaryData.push(['Items with Dependencies', allItems.filter(i => i.dependencies && i.dependencies.length > 0).length]);
            summaryData.push(['Items with Alternate Sources', allItems.filter(i => i.alternateSource).length]);

            const ws_summary = XLSX.utils.aoa_to_sheet(summaryData);

            // Set column widths
            ws_summary['!cols'] = [
                { wch: 30 },  // Column A
                { wch: 20 },  // Column B
                { wch: 15 },  // Column C
                { wch: 15 }   // Column D
            ];

            // Add to workbook
            XLSX.utils.book_append_sheet(wb, ws_summary, 'üìä Executive Summary');

            // =================================================================
            // SHEET 2: DETAILED ITEMS
            // =================================================================
            const itemsData = [
                ['DETAILED PROJECT ITEMS'],
                [],
                ['Item Name', 'Phase', 'Type', 'Cost ($M)', 'Lead Time', 'Description', 'Alternate Source', 'Dependencies', 'Notes']
            ];

            allItems.forEach(item => {
                const phaseDisplay = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;
                itemsData.push([
                    item.name || '',
                    phaseDisplay,
                    item.itemType || '',
                    item.cost ? (item.cost / 1000000).toFixed(2) : '0.00',
                    item.leadTime || '',
                    item.description || '',
                    item.alternateSource || '',
                    (item.dependencies || []).length > 0 ? item.dependencies.join(', ') : 'None',
                    item.notes || ''
                ]);
            });

            // Add total row
            itemsData.push([]);
            itemsData.push(['TOTAL', '', '', (totalCost / 1000000).toFixed(2), '', '', '', '', '']);

            const ws_items = XLSX.utils.aoa_to_sheet(itemsData);

            // Set column widths
            ws_items['!cols'] = [
                { wch: 30 },  // Item Name
                { wch: 25 },  // Phase
                { wch: 20 },  // Type
                { wch: 12 },  // Cost
                { wch: 15 },  // Lead Time
                { wch: 40 },  // Description
                { wch: 30 },  // Alternate Source
                { wch: 30 },  // Dependencies
                { wch: 40 }   // Notes
            ];

            XLSX.utils.book_append_sheet(wb, ws_items, 'üìã Detailed Items');

            // =================================================================
            // SHEET 3: DEPENDENCIES MATRIX
            // =================================================================
            const depsData = [
                ['DEPENDENCY MATRIX'],
                [],
                ['Item', 'Depends On', 'Count', 'Critical Path?']
            ];

            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    depsData.push([
                        item.name || '',
                        item.dependencies.join(', '),
                        item.dependencies.length,
                        item.dependencies.length > 2 ? 'Yes' : 'No'
                    ]);
                }
            });

            if (depsData.length === 3) {
                depsData.push(['No dependencies defined yet', '', '', '']);
            }

            const ws_deps = XLSX.utils.aoa_to_sheet(depsData);

            ws_deps['!cols'] = [
                { wch: 35 },
                { wch: 50 },
                { wch: 10 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_deps, 'üîó Dependencies');

            // =================================================================
            // SHEET 4: COST ANALYSIS BY TYPE
            // =================================================================
            const typeBreakdown = {};
            allItems.forEach(item => {
                const type = item.itemType || 'Uncategorized';
                if (!typeBreakdown[type]) {
                    typeBreakdown[type] = { count: 0, total: 0 };
                }
                typeBreakdown[type].count++;
                typeBreakdown[type].total += (item.cost || 0);
            });

            const analysisData = [
                ['COST ANALYSIS BY TYPE'],
                [],
                ['Item Type', 'Count', 'Total Cost ($M)', '% of Total', 'Avg Cost ($K)']
            ];

            Object.entries(typeBreakdown)
                .sort((a, b) => b[1].total - a[1].total)
                .forEach(([type, data]) => {
                    analysisData.push([
                        type,
                        data.count,
                        (data.total / 1000000).toFixed(2),
                        ((data.total / totalCost) * 100).toFixed(1) + '%',
                        (data.total / data.count / 1000).toFixed(0)
                    ]);
                });

            analysisData.push([]);
            analysisData.push(['TOTAL', allItems.length, (totalCost / 1000000).toFixed(2), '100.0%', (totalCost / allItems.length / 1000).toFixed(0)]);

            const ws_analysis = XLSX.utils.aoa_to_sheet(analysisData);

            ws_analysis['!cols'] = [
                { wch: 30 },
                { wch: 10 },
                { wch: 18 },
                { wch: 12 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_analysis, 'üìà Cost Analysis');

            // =================================================================
            // SHEET 5: PROJECT TASKS (PM TRACKING)
            // =================================================================
            const tasksData = [
                ['PROJECT TASKS - EXECUTION TRACKING (HIERARCHICAL)'],
                ['Professional Project Management Dashboard', '', '', '', '', '', '', '', '', '', '', ''],
                [],
                ['Task Name', 'Level', 'Parent Item', 'Phase', 'Status', 'Assignee', 'Progress %', 'Priority', 'Start Date', 'Due Date', 'Blocking Issue', 'Next Steps', 'Latest Updates']
            ];

            // Add task rows
            if (allTasks.length > 0) {
                allTasks.forEach(task => {
                    const phaseDisplay = `${task.phaseName}${task.phaseSubtitle ? ' (' + task.phaseSubtitle + ')' : ''}`;

                    // Format updates as timestamped entries
                    let updatesText = '';
                    if (task.pmUpdates && Array.isArray(task.pmUpdates) && task.pmUpdates.length > 0) {
                        updatesText = task.pmUpdates
                            .map(u => `[${new Date(u.timestamp).toLocaleDateString()}] ${u.text}`)
                            .join(' | ');
                    }

                    tasksData.push([
                        task.taskName || task.name || '',  // Use indented taskName for hierarchy
                        task.nestLevel || 0,
                        task.parentItem || '',
                        phaseDisplay,
                        task.pmStatus || 'To Do',
                        task.pmAssignee || 'Unassigned',
                        task.pmProgress || 0,
                        task.pmPriority || 'Medium',
                        task.pmStartDate || '',
                        task.pmDueDate || '',
                        task.pmBlockingIssue || '',
                        task.pmNextSteps || '',
                        updatesText
                    ]);
                });
            } else {
                tasksData.push(['No tasks created yet', '', '', '', '', '', '', '', '', '', '', '', '']);
            }

            // Add summary metrics
            tasksData.push([]);
            tasksData.push(['TASK SUMMARY METRICS']);
            tasksData.push([]);

            const completedTasks = allTasks.filter(t => t.pmStatus === 'Done').length;
            const inProgressTasks = allTasks.filter(t => t.pmStatus === 'In Progress').length;
            const blockedTasks = allTasks.filter(t => t.pmStatus === 'Blocked').length;
            const avgProgress = allTasks.length > 0 ? (allTasks.reduce((sum, t) => sum + (t.pmProgress || 0), 0) / allTasks.length).toFixed(1) : 0;

            tasksData.push(['Total Tasks', allTasks.length]);
            tasksData.push(['Completed', completedTasks, `${allTasks.length > 0 ? ((completedTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['In Progress', inProgressTasks, `${allTasks.length > 0 ? ((inProgressTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['Blocked', blockedTasks, blockedTasks > 0 ? '‚ö†Ô∏è ATTENTION REQUIRED' : '']);
            tasksData.push(['Average Progress', `${avgProgress}%`]);
            tasksData.push([]);
            tasksData.push(['Status Distribution']);

            // Status breakdown
            const statusCounts = {};
            allTasks.forEach(t => {
                const status = t.pmStatus || 'To Do';
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });

            Object.entries(statusCounts)
                .sort((a, b) => b[1] - a[1])
                .forEach(([status, count]) => {
                    tasksData.push([status, count, `${((count/allTasks.length)*100).toFixed(1)}%`]);
                });

            const ws_tasks = XLSX.utils.aoa_to_sheet(tasksData);

            // Set column widths for professional presentation
            ws_tasks['!cols'] = [
                { wch: 40 },  // Task Name (with indentation)
                { wch: 8 },   // Level
                { wch: 30 },  // Parent Item
                { wch: 25 },  // Phase
                { wch: 15 },  // Status
                { wch: 20 },  // Assignee
                { wch: 12 },  // Progress %
                { wch: 12 },  // Priority
                { wch: 15 },  // Start Date
                { wch: 15 },  // Due Date
                { wch: 35 },  // Blocking Issue
                { wch: 40 },  // Next Steps
                { wch: 60 }   // Latest Updates
            ];

            XLSX.utils.book_append_sheet(wb, ws_tasks, '‚úÖ Project Tasks');

            // =================================================================
            // GENERATE AND DOWNLOAD FILE
            // =================================================================
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `TreeListy-${timestamp}.xlsx`;

            XLSX.writeFile(wb, filename);

            // Show success message
            alert(`‚úÖ Excel export successful!\n\nFile: ${filename}\n\nIncludes:\n‚Ä¢ Executive Summary\n‚Ä¢ Detailed Items (${allItems.length} items)\n‚Ä¢ Dependencies Matrix\n‚Ä¢ Cost Analysis by Type\n‚Ä¢ Project Tasks (${allTasks.length} tasks with PM tracking)\n\nProfessionally formatted and ready for investor presentations! üìä`);
        }

        // Excel Export button handler
        document.getElementById('excel-export-btn').addEventListener('click', exportToExcel);

        // Redraw lines on scroll or resize
        const treeContainer = document.getElementById('tree-container');
        treeContainer.addEventListener('scroll', drawDependencyLines);
        window.addEventListener('resize', drawDependencyLines);

        // Initial render
        render();

        // Initialize pattern selector
        const patternSelect = document.getElementById('pattern-select');
        console.log('Pattern selector found:', patternSelect);
        if (patternSelect) {
            // Load saved pattern from data
            if (capexTree.pattern && capexTree.pattern.key) {
                currentPattern = capexTree.pattern.key;
                patternSelect.value = currentPattern;
                console.log('Loaded saved pattern:', currentPattern);
                if (currentPattern === 'custom' && capexTree.pattern.labels) {
                    customPatternNames = capexTree.pattern.labels;
                }
                // Apply pattern labels to existing nodes on load
                const labels = currentPattern === 'custom' && customPatternNames ? customPatternNames : PATTERNS[currentPattern].levels;
                renameNodesForPattern(capexTree, labels);
                console.log('Initial nodes renamed to match saved pattern');
                render(); // Re-render with renamed nodes
            }
            // Handle pattern selection
            patternSelect.addEventListener('change', function() {
                console.log('Pattern selector changed to:', this.value);
                applyPattern(this.value);
            });
            console.log('Pattern selector event listener attached');
        } else {
            console.error('Pattern selector NOT found!');
        }

        // Initialize pan/zoom controls
        initPanZoom();

        // Splash screen auto-dismiss
        setTimeout(() => {
            const splashScreen = document.getElementById('splash-screen');
            if (splashScreen) {
                splashScreen.classList.add('fade-out');
                // Remove from DOM after fade-out animation completes
                setTimeout(() => {
                    splashScreen.remove();
                }, 500); // Match fade-out animation duration
            }
        }, 2000); // Show splash for 2 seconds (matches loader animation)
    </script>
</body>
</html>
<!-- Cache buster: 1762487974 -->
