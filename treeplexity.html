<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TreeListy - Universal Project Decomposition by geej</title>
    <!--
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    TreeListy v2.57.0 | Build 616 | 2025-12-27
    Copyright (c) 2024-2025 Garnet Brown (geej)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Universal Project Decomposition Tool
    - 21 specialized patterns (Generic, CAPEX, Philosophy, LifeTree, Sales, Veo3, Sora2, etc.)
    - AI-powered (Claude, Gemini, ChatGPT) with tunable personas
    - Pattern Translation Engine with shadow data preservation
    - Modern collapsible sidebar UI (icon-based navigation)
    - Smart JSON save with pattern-based filenames
    - LocalStorage auto-save every 2 minutes
    - 50-state undo system
    - PWA-ready (installable on desktop & mobile)

    Changelog (Build 616): GLOBAL CAPABILITIES REGISTRY - Dedicated tree for capabilities (cross-project), auto-categorization, view/browse commands
    Changelog (Build 615): CHROME CAPABILITIES PHASE 1 - Create/list/test capability nodes, TreeBeard commands, modal UI
    Changelog (Build 614): WORK STATUS PANEL - Dashboard for active/completed tasks, API tracking, session stats
    Changelog (Build 613): TOOL-USE API - TreeBeard uses Claude's tool_use for guaranteed structured responses, MCP fallback
    Changelog (Build 612): FAST-PATH EXPANSION - Edge visibility, expand/collapse, layout, search patterns + show_edges/hide_edges commands
    Changelog (Build 611): DIRECT HELP LOADING - Simplified help from iframe to direct tree load with Back button
    Changelog (Build 610): HELP AS TREE + EMBED MODE - URL params ?mode=readonly|embed&tree=help for embedded TreeListy instances
    Changelog (Build 606): TB Canvas Layout Commands - layout_grid, layout_radial + full layout docs for TreeBeard
    Changelog (Build 605): Enhanced version picker - shows ALL browser trees with date, size, items; clickable cards
    Changelog (Build 604): Fast-Path interceptor + dispatch_task - instant commands bypass AI, dispatch tasks to Claude Code
    Changelog (Build 603): TB POWER CONSCIOUSNESS - Claude Code partnership, proactive execution + fix modal footer bug
    Changelog (Build 601): TB command vocabulary - Add Build 600 canvas commands + screen capture to TB prompt
    Changelog (Build 600): TB canvas commands - focus_hyperedge, phase filtering (show/hide/solo), camera focus/zoom/reset
    Changelog (Build 599): Canvas auto-layout for collapsed phases without positions (grid layout)
    Changelog (Build 598): Fix item counting for version comparison (handles all child types)
    Changelog (Build 597): Fix add_child to keep parent focused (enables ADD MULTIPLE CHILDREN)
    Changelog (Build 596): TB COMMAND EXECUTION SEQUENCES - exact step-by-step recipes for add/move/delete
    Changelog (Build 595): TB SHOW YOUR WORK mandatory - after any add/move/delete MUST show tree structure + report changes
    Changelog (Build 594): Intent routing - unknown commands auto-route to correct command (show_overview â†’ project_info)
    Changelog (Build 593): find_command - semantic command discovery by purpose/keyword
    Changelog (Build 592): Command aliases - show_overview, overview, project_overview all map to project_info
    Changelog (Build 591): TB visual feedback - animated highlights for moved nodes, toast notifications, auto-scroll to changes
    Changelog (Build 590): TB FOLLOW-THROUGH - complete actions immediately, don't stop at focus/select
    Changelog (Build 589): TB proactive behavior - CRITICAL capability check, COMPLEX TASKS sequence, ERROR RECOVERY protocol
    Changelog (Build 586): TB self-awareness - whats_new command + prompt to check capabilities before saying "I can't"
    Changelog (Build 585): Dev request UX notifications - toast shows what Claude Code is implementing and when build is ready
    Changelog (Build 584): TB developer channel guidance - TB now knows to use request_dev_help proactively instead of asking user to relay
    Changelog (Build 583): request_dev_help command - TB can request new capabilities directly from Claude Code via MCP
    Changelog (Build 582): rename_node and read_node commands - TB can now rename nodes and read full content
    Changelog (Build 581): delete_empty_nodes command - bulk cleanup of empty containers with preview/confirm safety
    Changelog (Build 580): Fix focus_node to accept names (not just IDs) - enables TB to focus by node name
    Changelog (Build 579): TB tree analysis - list_empty_nodes, show_tree_structure, find_duplicates, node_stats, merge_nodes, search_tree, tag/untag commands
    Changelog (Build 578): Treebeard safe manipulation - preview_node, move_node, duplicate_node, compare_nodes commands
    Changelog (Build 577): Case-insensitive commands - "Undo", "UNDO", "undo" all work now
    Changelog (Build 576): Treebeard add_node/add_child - direct node creation via Treebeard chat, no more "command not found"
    Changelog (Build 575): Atlas Phase-1 Link Resolution - [[node name]] syntax renders as clickable links, navigates to target node
    Changelog (Build 574): Deep Research via Claude Code - dispatch research tasks to Claude Code for web search + tree integration, bypassing fragile local filters
    Changelog (Build 573): Atlas Phase-0 Identity Lockdown - treeId (immutable), nodeGuid (stable), uidOf() helper, link patterns for cross-tree intelligence
    Changelog (Build 572): Fix bbox bug - clear irrelevant image analysis bboxes from structured data imports (URL, JSON)
    Changelog (Build 571): Model selector - choose Gemini 2.5 Flash (faster) or Nano Banana Pro (better colors) for image analysis
    Changelog (Build 570): Gemini 2.5 Flash - upgraded image analysis model for 20% more detail detection
    Changelog (Build 569): Reconstruction Prompt - color, shape, z-index, texture, opacity attributes for visual recreation
    Changelog (Build 568): Image Import UX - IndexedDB storage, compression, Import Image modal with drag-drop/URL/capture
    Changelog (Build 567): Interaction Spine - bidirectional bboxâ†”node selection, hover highlighting, pan-to-bbox, type/confidence filters
    Changelog (Build 566): Fix canvas/3D view refresh - views now auto-update when tree changes
    Changelog (Build 565): Image Analysis - Gemini Vision decomposes images into node trees; Fix email hyperedge query to search body
    Changelog (Build 564): Chrome extension screen awareness - capture_screen, extract_page, list_tabs commands via MCP Bridge
    Changelog (Build 563): New emails hyperedge - auto-create hyperedge grouping new items after Gmail refresh
    Changelog (Build 562): Gmail refresh via MCP Bridge - export script spawned by bridge.js, status feedback in UI
    Changelog (Build 561): Refresh button for Gmail/GDrive trees - appears in header when viewing synced content
    Changelog (Build 560): TreeBeard Gmail commands - archive, trash, star, mark read, reply, forward, triage summary via natural language
    Changelog (Build 559): Email info panel improvements - clear header display (From/To/CC/Subject/Date), thread conversation view with expandable messages
    Changelog (Build 557): Add Gmail debug logging to diagnose timeout issues
    Changelog (Build 556): Direct browserâ†’bridge Gmail sync - handleGmailFromBrowser in bridge.js
    Changelog (Build 555): Fix sendGmailAction to use client.socket.send (client is TreeListyMCPClient)
    Changelog (Build 552): TreeBeard Gmail commands + Send button - batch archive/trash/star, mandatory preview, rate-limited queue
    Changelog (Build 551): Draft Composition - Quick Reply box, Compose modal, IndexedDB draft storage, conflict resolution
    Changelog (Build 550): Gmail Bidirectional Sync - Archive/Trash/Star/Mark Read buttons with 10s undo toast
    Changelog (Build 547): Email reader modal, center-focused canvas zoom, Gmail export v2.0
    Changelog (Build 546): Add retrieve_context RAG handler for MCP-based knowledge retrieval
    Changelog (Build 545): Add refresh_tree command, fix TreeBeard command hallucination validation
    Changelog (Build 543): AI streaming for TreeBeard - progressive token display with "Interpreting..." indicator
    Changelog (Build 542): Add opt-in telemetry system for usage analytics (local-first, privacy-safe)
    Previous (Build 541): Add keyboard shortcut reference panel - press ? to view all shortcuts
    Previous (Build 540): Lazy-load third-party libraries for faster page load (Lighthouse fix)
    Previous (Build 539): Fix MCP node operations - use snake_case params (node_id, parent_id, node_data)
    Previous (Build 538): TreeBeard can now build trees from scratch - focus_root, create_tree, auto-focus on add_child
    Previous (Build 537): 3D and Canvas views now respect expand/collapse state
    Previous (Build 536): Incremental expand/collapse - one level at a time instead of all-at-once
    Previous (Build 535): Fix MCP file open - use client.socket (not ws), add debug logging
    Previous (Build 531): Fix Open File button - now shows for files with filePath (not just fileUrl)
    Previous (Build 530): Fix pattern restore on tree load - filesystem pattern now applied correctly
    Previous (Build 529): Fix PWA localStorage restore - re-render after loading saved tree
    Previous (Build 528): MCP Chrome file opening - open Google Drive files via Claude Chrome when connected
    Previous (Build 527): Direct "open file" command matching - bypasses AI interpretation for instant response
    Previous (Build 526): Enhanced file opening - local paths, Google native format detection, helpful errors
    Previous (Build 525): Fix sync command connection check - use client.isConnected not state.isConnected
    Previous (Build 524): Direct sync command matching - sync gmail/drive/calendar bypass AI interpretation
    Previous (Build 522): Treebeard Research Optimization - Fix hyperedge queries, bullet parsing, research followup
    Previous (Build 521): Fix MCP set_view to click view buttons for proper view switching
    Previous (Build 520): Fix modal close buttons - add .modal-close CSS for proper dismiss
    Previous (Build 519): RAG Phase 1 - Enhanced Document Import with PDF extraction
    Changelog (Build 508): Desktop reader nav + group iteration (hyperedge/dependency chain)
    Changelog (Build 507): Mobile reading mode - prev/next navigation, collapsed initial tree
    Previous (Build 506): Fix undefined icon in tree view - add fallback for items without icons
    Previous (Build 505): Safari voice capture fix - auto-restart on 30s timeout instead of error
    Previous (Build 504): Enhanced Quick Capture - auto-detect pattern, date extraction, fix transcription errors
    Changelog (Build 499): Voice FAB now triggers Quick Capture for conversation/debate recording
    Changelog (Build 498): Fix modal z-index stacking - modals now above mobile header
    Previous (Build 497): Fix mobile modal blocking - reasonable z-index, pointer-events fix
    Previous (Build 491): Mobile UX - Pinch zoom, fullscreen, swipe navigation
    Previous (Build 490): Treebeard PM Assistant Phase 5 - Proactive Nudges
    Previous (Build 489): Tree View selected node highlighting
    Previous (Build 488): Treebeard PM Assistant Phase 4 - Context Injection
    Previous (Build 487): Treebeard PM Assistant Phase 3 - Edit commands
    Previous (Build 486): Treebeard PM Assistant Phase 2 - Analysis commands
    Previous (Build 483): Gantt UX Polish - smooth zoom, Edit Task fix, muted colors
    Previous (Build 471): Fix Gantt not showing MS Project tasks
    Previous (Build 470): Gantt Dark Theme Text Fix
    Previous (Build 468): Gantt View Layout Fixes + Global Dropdown Styling
    Previous (Build 467): Nano Banana Gemini 3 Flash + Historical Styles
    Previous (Build 466): Redesigned Dependency Edit Modal
    Previous (Build 465): Fix Gantt View Switching
    Previous (Build 464): Milestone Dependency Preservation
    Previous (Build 463): MS Project Import Dependency Types
    Previous (Build 462): MS Project Export Dependency Fix
    - Export now preserves typed dependencies (FS/FF/SS/SF)
    - Handles both string IDs and object format dependencies
    - Exports lag values correctly
    - Supports task-a style IDs from MS Project imports
    - Fixed numeric pmDuration handling
    Previous (Build 461): Gantt Keyboard Shortcut
    Previous (Build 460): Gantt Bidirectional Sync & Toolbar
    Previous (Build 459): Gantt Data Conversion & Rendering
    Previous (Build 458): Inline Frappe Gantt Library
    Previous (Build 457): Gantt View Foundation
    Previous (Build 456): Hide Critical Path if no dependencies
    Previous (Build 455): Fix dependency edit modal
    Previous (Build 454): Fix pattern rename for imported JSON
    Previous (Build 453): Fix dependency lines not drawing
    Previous (Build 452): Critical Path Debug Logging
    Previous (Build 451): Fix Critical Path + Typed Dependencies
    Previous (Build 450): Logo with proper background
    Previous (Build 449): âš¡ Critical Path Visualization
    Previous (Build 448): âœï¸ Dependency Edit/Delete UI
    Previous (Build 447): â• Dependency Creation UI
    Previous (Build 446): ğŸ“‹ Typed Dependencies Foundation
    Previous (Build 445): ğŸ”— Enhanced Link System
    Previous (Build 444): âœ¨ Animation Foundation
    Previous (Build 443): ğŸŒ³ Logo Integration
    Previous (Build 442): ğŸ” Treebeard Research Mode (Phase 1)
    - Web search via Gemini's Google Search grounding
    - Auto-detects research intent, pattern-aware prompts
    Previous (Build 441): â„¹ï¸ About TreeListy Modal
    Previous (Build 440): ğŸ“Š Treebeard Tree Analysis Command
    - New tree_analysis command: finds items with most content/children
    - Helps Treebeard understand "research items" means tree analysis
    - Added to command vocabulary and feature guide
    Previous (Build 439): ğŸ¯ Treebeard Global vs Node Commands
    Previous (Build 438): ğŸ”˜ Fix Treebeard Welcome Buttons
    Previous (Build 437): ğŸŒ³ Treebeard Knows His Limits
    Previous (Build 436): ğŸ—ºï¸ Minimap Drag-to-Pan
    Previous (Build 435): ğŸ” Canvas Search + Minimap Navigation
    Previous (Build 434): ğŸ”§ Fix Cloud Share Load
    Previous (Build 433): â˜ï¸ Share Modal UX Overhaul
    Previous (Build 432): ğŸ“š Documentation & Test Maintenance
    Previous (Build 430): âš”ï¸ Defender vs Challenger + Argument Styles
    Previous (Build 429): ğŸ¯ Debate Panel UX (drag, position, add-to-tree fix)
    Previous (Build 425): â˜ï¸ Cloud Share via Firebase Short URLs
    Previous (Build 424): ğŸ“¤ Share URL Size Warnings + Lite Share
    Previous (Build 423): ğŸ› Fix duplicate 'pattern' declaration causing splash freeze
    Previous (Build 421): ğŸ”— Fix Hyperedge Show/Hide in Canvas View
    Previous (Build 420): ğŸ¨ Phase Color Cycling (different color per year)
    Previous (Build 419): ğŸ’¬ Fix Chat Builder Send/Finish Buttons
    Previous (Build 418): ğŸ–±ï¸ Fix Tree Agent Drag/Close Buttons
    Previous (Build 417): ğŸ”— Fix Hyperedge AI Analysis
    Previous (Build 416): ğŸ’¬ Fix Chat Builder Not Opening
    Previous (Build 415): ğŸ”· Shape Hierarchy for Node Types
    Previous (Build 414): ğŸ¬ Share View State with 3D Splash
    - Auto-capture current view state when generating share links
    - Include view type, selected node, expanded nodes, canvas positions, zoom/pan
    - Graceful degradation: full state â†’ trim positions â†’ trim expanded â†’ minimal
    - 1500 byte URL budget for universal compatibility
    - 3-second cinematic 3D orbit splash on shared link open
    - Smooth fade transition from splash to target view

    Previous (Build 413): ğŸ”§ Fix Chat Builder Enhance Existing
    Previous (Build 412): ğŸ“… MS Project XML Import/Export
    Previous (Build 411): ğŸ“– Reader Navigation
    Previous (Build 410): ğŸ” Zoom to Cursor
    Previous (Build 409): ğŸ–±ï¸ Fix Right-Click Context Menu
    Previous (Build 408): ğŸ”— Tree Agent Full Integration
    Previous (Build 407): ğŸ–±ï¸ Draggable Agent Frame
    Previous (Build 406): âœ¨ Visual Node Highlighting
    Previous (Build 405): ğŸ¤– Live Tree Agent Frame (Phase 1)
    Previous (Build 404): ğŸ’¡ Quick/Deep Mode Tooltips
    Previous (Build 403): âš¡ TreeBeard LifeTree Utility Mode
    Previous (Build 402): ğŸ™ï¸ Larry King Biographer Mode in Chat Builder
    Previous (Build 401): ğŸ”˜ Fix Chat Builder multi-choice buttons
    - Settings toggle: "Use Classic Chat Panel" in AI Settings modal
    - Keyboard shortcut: Ctrl+/ (Cmd+/ on Mac) toggles chat
    - Settings persist to localStorage across sessions
    - Smooth transition when switching UI modes
    - Polish: Improved integration with existing keyboard shortcuts

    Previous (Build 395): ğŸŒˆ Visual Feedback System
    Previous (Build 394): ğŸ¯ Context-Aware Action Buttons
    Previous (Build 393): ğŸ¯ Floating Command Frame (New Chat UI)
    Previous (Build 392): ğŸ©º LifeTree Health Check + ğŸ’¬ GPT-5.2 Support
    Previous (Build 391): ğŸ—‘ï¸ Phase Delete Support
    Previous (Build 390): ğŸ¨ Visual Type Distinction for Canvas Nodes
    Previous (Build 389): â™Ÿï¸ Semantic Type Indicators (Chess-like Variations)
    Previous (Build 388): ğŸ”§ Edit Any Depth Node
    - Validates node names before creation - rejects undefined/empty names
    - Extracts name from description if name field missing in JSON
    - New repair_tree command: finds and lets you fix malformed nodes
    - TreeBeard can now say "repair tree" to scan for issues

    Previous (Build 383): ğŸ§  TreeBeard Memory Mining + Real-Time Saves
    Previous (Build 380): ğŸ™ï¸ Larry King Mode Indicator
    Previous (Build 379): ğŸ”§ Fix: Pattern Restored on Page Reload
    Previous (Build 378): ğŸ™ï¸ TreeBeard Tiered Skills + Larry King Biographer
    Previous (Build 377): ğŸ§  TreeBeard Conversation Mode - Natural Language Actions
    Previous (Build 376): ğŸ” Smart Decade Search in find_node
    Previous (Build 375): ğŸŒ³ LifeTree Biographer - Structured Data Gathering
    Previous (Build 374): ğŸŒ³ LifeTree Quick Insight Context
    Previous (Build 373): ğŸ“ Simplified Save/Open Labels
    Previous (Build 372): ğŸ“¦ .treelisty Bundle Export/Import
    Previous (Build 371): ğŸ“ Artifact Side Panel
    Previous (Build 370): ğŸ¤ Voice Capture System
    Previous (Build 369): ğŸ”§ Fix TreeBeard Button - Syntax Error Fix
    Previous (Build 368): ğŸ§  Conversation Mode - Full AI Intelligence
    Previous (Build 367): ğŸ‚ TreeBeard Birthday Method - Proactive Biographer
    Previous (Build 366): ğŸ™ï¸ TreeBeard Biographer Mode (LifeTree)
    Previous (Build 365): ğŸŒ³ LifeTree Pattern - Biographical Timeline
    Previous (Build 364): ğŸ”— Enhanced Hyperedge Info Modal
    Previous (Build 360): ğŸ”§ Fix Syntax Error - Splash Screen Freeze
    Previous (Build 359): ğŸ”§ Fix CORS for Local Version Check
    Previous (Build 358): ğŸ”„ Check for Updates Button
    Previous (Build 357): ğŸ”” Version Check Fix for Local Files
    Previous (Build 355): ğŸŒ³ TreeBeard Phase 1 - Smarter & More Personal
    Previous (Build 354): ğŸŒ³ Multi-Tree Import Option
    Previous (Build 353): ğŸ” Smart Import Wizard

    Previous (Build 352): ğŸ§Š Fix 3D View Mode Switching
    Previous (Build 351): Hero Session Code Display for easier sharing
    Previous (Build 350): Fix mobile menu tap interactions
    Previous (Build 349): ğŸ“± Mobile Menu - Absolute Top Layer
    Previous (Build 348): ğŸ“± Mobile Menu - Force Pointer Events
    Previous (Build 347): ğŸ“± Mobile Menu - Fix Button Taps
    Previous (Build 346): ğŸ“± Mobile Menu - Complete Rewrite
    Previous (Build 339): ğŸ“± Mobile Menu High Contrast
    Previous (Build 338): ğŸ“± Mobile Hamburger Fix
    Previous (Build 337): ğŸ”· Gemini 3 Pro Preview Support
    Previous (Build 336): ğŸ“± File System Mobile UI

    Previous (Build 325): ğŸ“… Meeting Link Collaboration System
    Previous (Build 324): ğŸ™ï¸ Voice Chat UX Improvement
    Previous (Build 323): ğŸ› Bug fixes - version notification, welcome tree
    Previous (Build 318): â±ï¸ Fix Edge Function Timeout - Use Streaming
    Previous (Build 317): ğŸŒ Nano Banana Image Generation
    Previous (Build 316): ğŸ§  Wiser AI Prompts - Context Injection
    Previous (Build 315): ğŸ§  Wiser TreeBeard - Deep Knowledge Injection
    Previous (Build 314): ğŸ“ Fix Tree View Zoom Reset Position
    Previous (Build 307): ğŸ› TreeBeard Context Fix (children vs phases)
    Previous (Build 306): ğŸ¨ UI Z-Index Fix - Chat Bubble Overlap
    Previous (Build 305): ğŸ› TreeBeard Empty Project Bug Fix (wizard)
    Previous (Build 304): ğŸ” Search Result Navigation Fix
    Previous (Build 302): ğŸ› Fix False Update Toast
    Previous (Build 301): ğŸ› Fix 3D Sort Refresh
    Previous (Build 300): ğŸ¯ Sort-Aware 3D Layouts
    Previous (Build 299): ğŸ–±ï¸ 3D Usability - Hover & Interaction
    Previous (Build 298): âœ¨ 3D Title Polish
    Previous (Build 297): ğŸ¯ 3D Quick Wins - Dependencies & View State
    Previous (Build 289): ğŸ–±ï¸ Mouse-Based 3D Fly Mode
    Previous (Build 288): ğŸ› Canvas View Info Panel Fix
    Previous (Build 287): ğŸš€ 3D Fly Mode + Enhanced Navigation
    Previous (Build 285): ğŸ“ Save & Restore View State
    Previous (Build 284): ğŸ’¾ Version Conflict Detection + Unsaved Warning
    Previous (Build 283): ğŸ”— Smart Hyperedge Labels + Fix Deep Dive

    Previous (Build 275): ğŸ”§ Debug Host Chat Box + Improved Logging
    - Auto-close Live Sync modal when first guest connects
    - Floating chat box with API key sharing
    - Session keys for guests that clear on leave

    Previous (Build 267): ğŸ”§ Fix Double Room Creation + Deploy Functions
    - Migrated API key sharing from Watch Mode to Firebase Live Sync modal
    - Removed deprecated Watch Mode

    Previous (Build 263): ğŸ”¥ Fix Firebase Live Sync Room Creation
    - FIX: Changed Firestore collection from 'rooms' to 'syncRooms' to match security rules

    Previous (Build 262): ğŸ‘¥ Dynamic Team Management System
    - NEW: Project Team section in Project Settings - add Host, Collaborators, Contributors
    - NEW: Unique initials system - first letter, adds 2nd if collision, 3rd if needed
    - NEW: Email association for accountability - hover to see email
    - NEW: Color-coded badges: Host (gold), Collaborator (blue), Contributor (green)
    - FIX: Replaced hardcoded Dad/Owen buttons with dynamic team member buttons
    - UX: Team members appear in Edit modal and Watch mode for quick selection

    Previous (Build 261): ğŸ¨ Fix Imagen 4 Image Generation
    - FIX: Updated model IDs to correct Imagen 4 API names
    - Models: imagen-4.0-fast-generate-001, imagen-4.0-generate-001, imagen-4.0-ultra-generate-001

    Previous (Build 260): ğŸ¯ AI Specialist Context
    - NEW: specialistContext field on tree root - domain expertise prompt
    - Edit via Project Settings modal (right-click root â†’ Project Settings)

    Previous (Build 259): ğŸ’¬ TreeBeard Chat Redesign
    - Increased default panel size (440x520 for more chat space)
    - Removed quirky "Hoom, hm..." sayings - cleaner welcome

    Previous (Build 258): ğŸ¤ Voice Input Fix
    - Fixed: Voice button now works (added touch support for mobile)
    - Added interim results - see transcription as you speak

    Previous (Build 257): ğŸ’¾ Local JSON Save During Collaboration
    - "Save JSON" button in Live Sync modal - download current tree anytime
    - "Auto-save on sync" checkbox - automatically download JSON after each remote sync
    - Each collaborator maintains their own local JSON backup
    - Filename includes pattern, project name, and timestamp

    Previous (Build 256): â†©ï¸ Undo Support for Remote Sync + Editor Attribution
    - Remote sync undo-able, "Last edit by" display, setMyDisplayName/setCollaboratorName

    Previous (Build 255): ğŸ® TreeBeard Playground Mode - Test Improved Prompts
    - "improve prompt: X" pattern, action buttons, Playground Mode with model selector

    Previous (Build 254): ğŸ“ Info Panel Redesign + TreeBeard Visual Polish
    - Renamed "TreeListy Assistant" to "TreeBeard" (wise tree guardian)
    - Made the TreeBeard panel draggable by its header
    - Panel is resizable (drag bottom-right corner)
    - Panel position and size saved to localStorage

    Previous (Build 252): ğŸ› Fix splash screen not loading (syntax error in Build 251)
    - Edge Function streaming proxy (netlify/edge-functions/claude-stream.ts)
    - callClaudeStreamingAPI() - SSE streaming with no timeout limit
    - callClaudeEdgeBuffered() - buffered Edge response for compatibility
    - Automatic fallback chain: Edge â†’ Regular Function â†’ Direct API

    Previous (Build 250): ğŸ§­ Conversational Tree Navigation & Editing
    - find_node, Tree traversal, expand/collapse, field editing, ai_enhance_field
    - add_child, delete_node, zoom controls, list_children, node_info
    - Natural language patterns for navigation

    Previous (Build 249): ğŸ¤ Expanded Chat Assistant Commands (35 total)
    - File operations - import_text, load_json, import_excel, share_url, live_sync
    - Search, AI operations, Canvas layouts, Selection commands

    Previous (Build 248): ğŸ’¬ Chat Assistant with Voice Control
    - Floating chat bubble (bottom-right) - click or press Ctrl+/
    - Conversational AI assistant that understands TreeListy context
    - Execute commands via natural language ("switch to canvas", "export excel")
    - Voice input - hold microphone button to speak (Web Speech API)
    - Quick action chips for common operations
    - Context-aware responses (knows current project, pattern, selection)

    Previous (Build 247): ğŸ§  AI-Enhanced System Prompts (+2.6 avg sophistication)
    - IMPROVED: Generic Deep Dive now uses McKinsey RAID methodology
      - SubItem types: risk-factor, dependency, assumption, subtask, constraint, success-metric
      - Critical Path Method and stakeholder impact analysis
    - IMPROVED: Generic persona now Senior Financial Planning Manager (15yr Fortune 500)
      - Monte Carlo risk modeling, EVM, Stage-Gate governance, PMI/COSO frameworks
    - IMPROVED: Strategy Consultant now references named frameworks
      - Porter's Five Forces, McKinsey 7-S, BCG Matrix, Blue Ocean Strategy
      - Thought leaders: Michael Porter, Clayton Christensen, Rita McGrath
    - IMPROVED: Course Designer now uses pedagogical frameworks
      - Bloom's Taxonomy, ADDIE, Gagne's Nine Events, Kirkpatrick evaluation
      - Adult learning theory (Knowles' andragogy), backward design (Wiggins & McTighe)

    Previous (Build 246): ğŸ¨ AI-Optimized Image Style Prompts

    Previous (Build 245): ğŸ“ Enhanced Whiteboard Sketch Style for Image Generation

    Previous (Build 244): ğŸ“· Professional Canvas Export as PNG
    - NEW: Export Canvas view as high-quality PNG image (ğŸ“· button)

    Previous (Build 243): ğŸ¯ Improved CAPEX Pattern Detection in Excel Import
    - FIX: AI prompt now explicitly lists CAPEX pattern detection hints
    - FIX: Budget/Actual/Variance, ROI, Risk/Mitigation columns now trigger CAPEX pattern

    Previous (Build 242): ğŸ“Š AI Multi-Sheet Excel Import
    - NEW: AI analyzes ALL sheets in workbook and suggests import strategy
    - NEW: Strategy options: combine similar, separate phases, skip reference sheets
    - NEW: AI recommends which sheets to import as phases
    - NEW: Automatic column mapping for each sheet during multi-import
    - NEW: Progress indicator during multi-sheet processing
    - NEW: "Pick Sheets Manually" fallback option
    - IMPROVED: Each sheet becomes a phase with AI-suggested names

    Previous (Build 241): ğŸ¤– AI-Powered Excel Import
    - NEW: AI analyzes Excel structure and auto-detects column mappings
    - NEW: AI recommends best pattern based on data content
    - NEW: Simplified import UI with confidence scores
    - NEW: Click-to-adjust mapping cards (no more dropdown walls)

    Previous (Build 239): ğŸ™ï¸ Free Speech - Stream of Consciousness Voice Capture
    - NEW: Free Speech pattern for psychological pattern analysis
    - NEW: Web Speech API integration for voice recording
    - NEW: Nudge system with gentle prompts during silence
    - NEW: Gamification metrics (flow score, authenticity, word count)
    - NEW: Privacy-first architecture (transcript deleted after analysis)
    - NEW: AI analysis finds repetition, contradictions, implicit beliefs
    - NEW: ğŸ™ï¸ Free Speech button in AI Tools sidebar

    Previous (Build 238): ğŸ“¥ Import Text UX Elevation
    - NEW: ğŸ“¥ Import button in header toolbar (prominent placement)
    - NEW: Empty state CTA with "Import Text" and "Chat Builder" buttons
    - IMPROVED: Import Text now discoverable as primary workflow entry point
    - IMPROVED: Empty state guides new users to main input methods

    Previous (Build 237): ğŸ§  Super Hybrid Prompt Engineering Meta-Prompt
    - ENHANCED: Prompt AI uses "Super Hybrid" meta-prompt (A/B tested, 80.2%+ score)
    - NEW: 3-phase approach: Draft â†’ Self-Critique â†’ Refined Output
    - NEW: Expert panel synthesis (Anthropic/OpenAI/Production perspectives)
    - NEW: Specific persona requirement ("senior engineer at Stripe with 8 years" not "expert")
    - NEW: Agent orchestration contracts for multi-agent workflows
    - NEW: Concrete examples required (not placeholders)
    - IMPROVED: Prompt outputs now directly usable (no meta-commentary)

    Previous (Build 236): ğŸ—‘ï¸ Fix delete sync + nested subtask deletion
    - FIX: Delete operations now immediately sync to Firebase collaborators
    - FIX: Nested subtasks (subtasks within subtasks) can now be deleted
    - FIX: Delete triggers auto-save to localStorage
    - FIX: No longer requires 2-second poll interval to detect deletions

    Previous (Build 235): ğŸ”¥ Firebase sync triggers auto-save to localStorage
    - NEW: ğŸ”¥ Firebase integration for real-time collaboration
    - NEW: Anonymous auth (no sign-in required)
    - NEW: "ğŸ”„ Live Sync" button in toolbar
    - NEW: Start/Join live sync session with shareable room ID

    Previous (Build 230): â˜ï¸ Load from Google Drive Button + Recent Files
    - NEW: â˜ï¸ button in toolbar opens "Load from Google Drive" modal
    - NEW: Paste any Google Drive share link or file ID
    - NEW: Recent Shared Trees list (last 8 files, stored locally)
    - NEW: Click any recent file to instantly reload it
    - NEW: Pattern-specific icons in recent files list
    - NEW: Clear button to remove recent files history
    - FIX: Files loaded via ?gdrive= URL also saved to recent list

    Previous (Build 229): ğŸ”— Auto-Sync Sort & Cluster Controls
    - NEW: Sort and Cluster dropdowns now auto-sync by default
    - NEW: Changing Sort automatically updates Canvas Cluster to match
    - NEW: Changing Cluster automatically updates Tree Sort to match
    - NEW: ğŸ”—/ğŸ”“ toggle button to link/unlink the controls
    - UX: Renamed "Default Order" to "Sort By" for clarity
    - UX: Toast notifications show sync status

    Previous (Build 228): ğŸ–±ï¸ View Controls Guide in Help
    - NEW: Comprehensive "View Controls (Tree vs Canvas)" section in Help modal
    - NEW: Clear mouse control differences between Tree and Canvas views
    - NEW: Middle mouse panning highlighted for Canvas users
    - NEW: Tips for users without middle mouse button
    - NEW: Canvas navigation tips (Fit button, hyperedges, box select)

    Previous (Build 227): ğŸ”§ Fix Pattern Detection from Google Drive Links
    - FIX: Pattern selector now properly updates when loading from ?gdrive= URLs
    - FIX: Philosophy, CAPEX, and other patterns correctly detected and displayed
    - FIX: Custom pattern labels preserved from shared files
    - FIX: Sort dropdown and AI button update to match loaded pattern

    Previous (Build 226): â˜ï¸ Google Drive Proxy for CORS-Free Loading
    - NEW: Netlify function gdrive-proxy fetches Google Drive files server-side
    - FIX: ?gdrive=FILE_ID URLs now load reliably (no CORS errors)
    - FIX: Host import from Google Drive uses proxy
    - FIX: Handles Google's virus scan confirmation page automatically
    - Works for both hosts and collaborators clicking email links

    Previous (Build 225): ğŸ–±ï¸ Mouse-Driven Chat Builder with Clickable Choices
    - AI questions now include clickable choice buttons
    - [CHOICE:label] markers auto-convert to purple pill buttons
    - Click to answer - no typing required for most questions

    Previous (Build 224): ğŸ“§ Separate Async vs Live Collaboration
    - "Async Share (Chess by Mail)" - share Google Drive link, collaborators use own keys
    - "Live Session (Share API Keys)" - share your keys for 4 hours

    Previous (Build 223): ğŸ“§ Collab Wizard - Host Import & Email Invitations
    - Hosts can import trees from Google Drive, Dropbox, or direct JSON URLs
    - Email invitation workflow with Send, Copy Text, and Mail App buttons

    Previous (Build 222): ğŸ”‘ Live Collab Sessions - Share API Keys with Collaborators
    - Host shares encrypted API keys with collaborators during live sessions
    - Guests use host's keys automatically - never see the actual keys
    - 4-hour session limit with auto-cleanup
    - Session status tracking (guest count, expiration)
    - Uses Netlify Blobs for secure server-side storage

    Previous (Build 221): ğŸŒ Nano Banana Pro - Google's Best Image Model
    - Uses Gemini's reasoning for smarter image composition
    - Falls back to Imagen 4 if preferred
    Previous (Build 220): âœ¨ AI-Powered Imagen Prompt Crafting
    - 8 visual style presets: Whiteboard, Infographic, Cartoon, Tech, Nature, Minimal, Isometric, Academic
    - "AI Craft Prompt" button uses Gemini to write optimized Imagen 4 prompts
    - Pattern-aware: Uses your tree's context (Philosophy, Sales, etc.) for better prompts
    - Word count indicator (15-25 words = green = ideal length)
    - Follows Imagen 4 best practices: subject first, style keywords, lighting
    - Fun, educational, whiteboard-style default for approachable visuals
    Previous (Build 219): ğŸ” Image Preview Lightbox for Imagen 4
    - Click any generated image to view full-size in lightbox
    - Examine details before choosing which image to attach
    - Download button to save images locally
    - Attach to Node button from preview view
    - Escape key or click outside to close
    - Shows prompt used for each image
    Previous (Build 218): ğŸ¨ Imagen 4 Image Generation + Model Updates
    - NEW: Generate images from selected nodes using Google Imagen 4
    - NEW: Right-click â†’ "Generate Image" in Canvas view
    - NEW: Choose aspect ratio (1:1, 16:9, 9:16, 4:3, 3:4)
    - NEW: Imagen 4 Standard, Fast, and Ultra models
    - NEW: Attach generated images to nodes
    - UPDATED: Gemini models to 2.5-pro and 2.5-flash (stable)
    - UPDATED: OpenAI models: GPT-5, GPT-5-mini, o3, o4-mini
    - UPDATED: Claude Opus 4.5 (claude-opus-4-5-20251101)
    Previous (Build 217): ğŸŒŸ Added Claude Opus 4.5 Model Option
    Previous (Build 216): ğŸ‘¥ Collaboration Section Moved to Prominent Position
    - MOVED: Collaboration section now appears right after Name/Description/Icon
    - UI: New highlighted card design with purple gradient background
    - UI: More compact layout - Contributor field with team member buttons inline
    - UI: Comments textarea in same card for quick access
    - UX: No more scrolling to find collaboration features

    Previous (Build 215): ğŸ¯ User-Refined Canvas Layout for Welcome Tree
    - Applied user's hand-positioned node coordinates
    - More spread-out layout with better visual balance
    - Items positioned to showcase hyperedge connections

    Previous (Build 214): ğŸ¨ Visually Striking Canvas Layout for Welcome Tree
    - NEW: Symmetrical 6-phase radial layout - root at center (700, 450)
    - NEW: 5 colorful hyperedges demonstrating visual groupings:
      â€¢ Dual View System (indigo) - Tree/Canvas connection
      â€¢ AI Creation Pipeline (emerald) - Build â†’ Import â†’ Enhance â†’ Analyze
      â€¢ Collaboration Workflow (amber) - Share â†’ Tag â†’ Comment â†’ Sync
      â€¢ Canvas-Specific Features (pink) - Canvas/Hyperedges/Dependencies
      â€¢ Start Here (violet) - Three paths to begin
    - NEW: Power Features phase expanded by default at top center
    - NEW: Hyperedges item shows "Done" status as proof they work
    - UI: Canvas-first design - visually striking layout showcases hyperedge feature

    Previous (Build 213): ğŸŒ³ Updated Welcome Tree for New Users

    Previous (Build 211): ğŸ‘ï¸ Watch Mode + Google Drive Links ("Chess by Mail")
    - NEW: Watch Mode - poll shared files for real-time sync
    - NEW: ?gdrive=FILE_ID URL parameter - email links that load trees!
    - NEW: ?watch=URL parameter - auto-opens Watch Mode for live sync
    - NEW: File System Access API support for local shared files
    - NEW: Configurable poll intervals (5s/10s/30s/1min)
    - NEW: Auto-detect contributor changes, skip self-saves
    - NEW: Visual sync indicator with pulse animation
    - UI: Watch Mode modal with status panel
    - WORKFLOW: Email Google Drive links to collaborators for async editing

    Previous (Build 210): ğŸ‘¥ Collaboration Comments & Contributor Tags

    Previous (Build 209): ğŸ› Fix Canvas Node Selection Persistence

    Previous (Build 207): ğŸ’° New CAPEX / Angel Pitch Pattern

    Previous (Build 206): ğŸš€ Investor-Ready CFO Persona

    Previous (Build 205): ğŸ’° Fix $0 Display on Non-Cost Nodes

    Previous (Build 199): Fix Merge Deep Copy

    Previous (Build 198): Fix view variable name

    Previous (Build 197): Fix undo function name

    Previous (Build 196): Wrong function name (saveToHistory)

    Previous (Build 193): ğŸ”§ IIFE with DOM Ready Check

    Previous (Build 192): ğŸ’° Hide $0 Cost in Canvas View
    - FIX: Cost badge only shows in canvas if pattern supports cost AND cost > 0

    Previous (Build 191): âœ¨ New "Explore TreeListy" Starter Tree
    - NEW: Self-describing starter tree teaches TreeListy by example
    - NEW: 4 phases: Discover, Create, Enhance, Share

    Previous (Build 190): ğŸ¨ Layout Fix - Edges Panel vs Info Panel

    Previous (Build 189): ğŸ“§ Improved Collaboration Email & Merge UI
    - NEW: "Merge Branch" button in sidebar to paste collaboration URLs
    - NEW: "Copy Email" button copies rich HTML with clickable button

    Previous (Build 188): ğŸ”€ Smart Merge with Project Validation
    - NEW: Detects if wrong project is loaded when merging
    - NEW: Shows expected vs current project name comparison

    Previous (Build 187): ğŸ¤ Complete Collaboration System (Branch & Merge)
    - NEW: ğŸ“¥ ?branch= URL detection and parsing on page load
    - NEW: ğŸ¤ Branch editing mode with purple banner for collaborators
    - NEW: ğŸ“¤ "Share Back" button to send edits to original author
    - NEW: ğŸ”€ Merge modal for accepting incoming collaboration changes

    Previous (Build 186): ğŸ¤ Share for Collaboration UI
    - NEW: ğŸ”‘ getDeviceFingerprint() - Canvas-based device ID for contributor tracking
    - NEW: ğŸ—ºï¸ getAncestryPath(nodeId) - Get breadcrumb path to any node
    - NEW: ğŸ“¦ extractSubtree(nodeIds, hyperedgeId) - Extract nodes for sharing
    - NEW: ğŸ”— generateBranchURL(branch) - Create shareable ?branch= URL
    - NEW: ğŸ“ Size validation - Blocks sharing if subtree > 8KB URL limit
    - FOUNDATION: isBranchMode() check, currentBranch state variable

    Previous (Build 184): ğŸ› Fix New Project Not Updating Canvas
    - FIX: ğŸ› "New Project" now calls renderCanvas() to update canvas view immediately
    - Previously only tree view was updated, canvas stayed on old project

    Previous (Build 183): ğŸ‘ï¸ Hyperedge Hover Dims Unrelated Nodes
    - NEW: ğŸ” Hovering a hyperedge now dims all nodes NOT in that hyperedge (0.25 opacity)
    - NEW: âœ¨ Member nodes get highlighted with purple glow on hover
    - ENHANCED: Smooth 0.3s transition for opacity and glow effects
    - FIX: ğŸ› Fixed dataset.itemId lookup (was using wrong attribute name)

    Previous (Build 181): ğŸ”§ Fix Hyperedge/Connection Clipping on Zoom Out
    - FIX: ğŸ› Hyperedges and connections were clipped to small rectangle on zoom out
    - FIX: canvas-connections SVG now uses 20000x20000px area (like dependency-svg)
    - FIX: Added SVG_OFFSET (5000px) to all drawing coordinates
    - IMPROVED: Hyperedges now render correctly at any zoom level (10%-500%)

    Previous (Build 180): ğŸ”— Hyperedge Visibility Management
    - NEW: ğŸ‘ï¸ Hover dimming - other hyperedges fade when you hover one
    - NEW: ğŸ¯ Focus View button in hyperedge info modal to isolate view
    - NEW: ğŸ”— "Edges" button in canvas toolbar to manage hyperedge visibility
    - NEW: Visibility panel with checkboxes, Show All/Hide All, focus shortcuts
    - ENHANCED: Each hyperedge wrapped in SVG group for better interaction

    Previous (Build 179): ğŸ’Š Capsule Geometry for 2-Node Hyperedges
    - NEW: ğŸ¯ Deep Dive auto-focuses on hyperedge members
    - NEW: Auto-arranges analyzed nodes in clean layout
    - FIX: ğŸ› Hyperedge now clickable

    Previous (Build 176): ğŸ§  AI-Powered Relationship Analysis
    - NEW: ğŸ§  AI analyzes selected nodes and DISCERNS the philosophical relationship
    - NEW: AI generates: relationshipType, dialecticalRelation, argumentativeFlow, conceptualBridge
    - NEW: AI identifies: philosophical tension and potential synthesis

    Previous (Build 175): ğŸ›ï¸ Descriptive Hyperedge Labels
    - NEW: ğŸ›ï¸ Hyperedge labels show dialectical relation type
    - NEW: ğŸ‘† "click to explore relationship" hint below hyperedge label

    Previous (Build 174): ğŸ¨ Hyperedge Visual Enhancement
    - NEW: ğŸ¨ Hyperedge color permeates member nodes (tinted border + glow)
    - NEW: ğŸ“¦ Hyperedge hull includes both selected nodes AND generated subitems (Venn diagram)
    - NEW: ğŸ–±ï¸ Clickable hyperedges - shows philosophy relationship info panel

    Previous (Build 173): ğŸ”— Fix Hyperedge Visualization
    - FIX: ğŸ› Hyperedges not visible after Deep Dive Analysis
    - FIX: Division by zero in padding calculation when nodes overlap
    - FIX: NaN coordinates causing polygon to not render

    Previous (Build 169): ğŸ“ Deep Dive Analysis (Structured Scholar)
    - NEW: Right-click â†’ "Deep Dive Analysis" on any node(s)
    - NEW: Generates 2-4 subItems per node (objections, implications, hidden premises)
    - NEW: Auto-fills missing fields (speaker, keyTerms, textualReference)
    - NEW: Multi-select support - Ctrl+click nodes, then Deep Dive all at once
    - NEW: Auto-creates purple hyperedge linking analyzed nodes
    - NEW: Philosophy-specific prompts using Structured Scholar technique
    - NEW: Generic pattern support for non-philosophy deep dives

    Previous (Build 168): Fix Undefined Text in Tree/Canvas Views
    - FIX: ğŸ› Phase subtitle undefined - Now conditionally rendered
    - FIX: ğŸ› Item/Node icons undefined - Added fallbacks (ğŸ“‹, ğŸ“„, ğŸŒ³)

    Previous (Build 167): Philosophy Structured Scholar Prompt (+4.7% depth)
    - ENHANCED: ğŸ“ Philosophy prompts use "Structured Scholar" technique (93% vs 88% baseline)
    - NEW: Mandatory NAMED secondary sources requirement (e.g., "Vlastos", "Williams")
    - NEW: Standard objections must cite specific philosophers
    - NEW: Expanded itemTypes: implicit-premise, distinction, thought-experiment, objection
    - NEW: Required metadata: tradition, method, keyTerms, interlocutors, secondarySources
    - RESEARCH: Tested 10 meta-prompting techniques; Structured Scholar won

    Changelog (Build 166): Philosophy Pattern Prompt Optimization
    - ENHANCED: ğŸ§  Philosophy pattern prompts optimized based on A/B testing (+10% structural fidelity)
    - NEW: Explicit itemType examples with common error warnings
    - FIX: "Bee analogy = question" misclassification now explicitly corrected
    - IMPROVED: Deep Mode philosophy instructions with full JSON examples

    Previous (Build 165): Cognitive Citadel Foundation
    - NEW: ğŸ›¡ï¸ Migration System - Schema versioning for backward compatibility
    - NEW: ğŸ›¡ï¸ Provenance Stamping - All nodes track origin (user/ai-import/legacy)
    - NEW: ğŸ›¡ï¸ Dialectic Mode - Forces AI to identify assumptions & counter-arguments
    - NEW: Phenomenology array on nodes (future: capture "residue" that doesn't fit structure)
    - NEW: Metrics stub on nodes (future: attention economics tracking)
    - FIX: AI-imported content now properly tagged with provenance

    Previous (Build 164): Model Selector + Latest Model IDs
    - NEW: ğŸ¯ Model Selector Dropdown - Choose specific AI models per call
    - NEW: Claude: Haiku 3 (server), Haiku 3.5, Sonnet 4, Opus 4
    - NEW: Gemini: Flash 2.0, Pro 2.5 Preview
    - NEW: ChatGPT: 4o-mini, GPT-4o, o1 reasoning
    - FIX: Updated Gemini models to latest (2.0-flash stable, 2.5-pro-preview)

    Previous (Build 163): Fix undefined response error + null guard
    - FIX: Added null guard for AI response to prevent "Cannot read properties of undefined"
    - FIX: Better error message when AI returns empty/undefined response
    - INFO: Anthropic intentionally blocks direct browser API calls (no CORS headers)
    - INFO: This is NOT a bug - it's their security architecture requiring server proxy

    Previous (Build 162): AGGRESSIVE Large Tree Handling
    - FIX: ğŸ›‘ Large trees (30+ items) now FORCE treeUpdate: null in enhance mode
    - FIX: Removed instruction to "echo baseline" that was causing 32K responses

    Previous (Build 161): Smart Fallback for Large Trees
    - NEW: ğŸš€ Auto-fallback to fast mode on timeout or response cutoff
    - NEW: Large tree detection (50+ items) - warns about potential timeout
    - NEW: Timeout auto-retry - switches to fast mode and retries automatically

    Previous (Build 160): Wizard Token Optimization + Claude CORS Fix
    - FIX: ğŸª„ Wizard "response cut off" bug - Added STRONG instruction to NOT echo entire tree
    - FIX: ğŸ”„ Claude API routing - Anthropic blocks ALL direct browser calls (CORS policy)
    - INFO: Deep Mode for Claude MUST use Netlify proxy (10s timeout applies)
    - INFO: For unlimited Deep Mode, use Gemini (allows direct browser API calls)

    Previous (Build 158): Based on Gemini code review recommendations
    - FIX: ğŸ› Hyperedges Data Loss Bug - importAnalyzedTree and executeFlexibleImport now initialize hyperedges: []
    - FIX: âš¡ Performance - drawHyperedges now uses O(1) Map lookup instead of O(N) recursive getNodeById
    - NEW: ğŸ“Š Deep Mode Progress UI - Real-time chunk-by-chunk progress bar during semantic analysis
    - NEW: ğŸ”— Hyperedge Management UI - Delete hyperedges from root node info panel (no more JSON editing!)
    - Added window.deleteHyperedge() global handler with undo support

    Previous (Build 157):
    - FIX: ğŸ”‘ API Key Storage Bug - EmbeddingManager now uses correct localStorage key format
    - Fixed: Changed 'openai-api-key' â†’ 'openai_api_key' (underscore format)
    - Fixed: Changed 'gemini-api-key' â†’ 'gemini_api_key' (underscore format)
    - Your saved API keys from Build 155 and earlier are now accessible again!

    Previous (Build 156):
    - NEW: ğŸ§  Semantic Chunking Engine - NLP-powered text segmentation for large documents
    - NEW: SemanticChunker class with cosine similarity and 90th percentile adaptive thresholding
    - NEW: EmbeddingManager service supporting OpenAI text-embedding-3-small & Gemini text-embedding-004
    - NEW: Chunk-by-chunk processing in Quick Mode and Deep Mode (prevents hallucinations on large files)
    - NEW: Visual chunk distribution UI showing detected semantic sections
    - ENHANCED: Automatic structural fallback (Markdown headers â†’ paragraphs â†’ lines) when no embedding provider
    - TECH: Sliding window context buffering, batch API processing (max 20 per batch)
    - TECH: Silent error handling with graceful degradation

    Previous (Build 155):
    - FIX: Cluster-by dropdown scope issue - Moved function to global scope
    - Pattern-specific options now properly populate for Philosophy, Film, Veo3, Sora2, Sales, Roadmap
    - Function now accessible from all pattern switch and file load handlers

    Previous (Build 154):
    - FIX: Cluster-by dropdown now properly dynamic (removed hardcoded HTML)
    - NEW: Philosophy sort options - speaker, argument type, validity, school, claim name
    - NEW: Film sort options - visual style, lighting mood, camera movement, AI platform, duration
    - ENHANCED: Cluster-by and sort dropdowns now fully pattern-aware

    Previous (Build 153):
    - FIX: Pattern-specific clustering - Dropdown now shows relevant fields per pattern
    - Philosophy: argumentType, validity, speaker, philosophicalSchool
    - Film: visualStyle, lightingMood, cameraMovement, aiPlatform
    - Veo3/Sora2: Flow mode, beat type, cameo, physics complexity
    - Sales: leadStage, leadSource, dealSize
    - ENHANCED: Dynamic cluster-by options update on pattern switch and file load

    Previous (Build 152):
    - NEW: Wolfram-style Hyperedges - N-ary relationships (montage, argument, theme, etc.)
    - NEW: Convex Hull Visualization - Hyperedges render as semi-transparent blobs in Canvas View
    - NEW: Multi-select Hyperedge Creation - Ctrl+Click nodes, right-click "Create Hyperedge"
    - NEW: Provenance Stamping - All nodes track creation source (ai-sonnet, ai-gemini, user, etc.)
    - NEW: Root-level Hyperedge Storage - Cross-phase relationships (Film flashbacks, Philosophy refutations)
    - ENHANCED: Graham Scan Algorithm - O(n log n) convex hull computation for hyperedge visualization

    Previous (Build 151):
    - FIX: Smart Suggest for videoPrompt - No more "Okay, buckle up!" conversational fluff
    - NEW: Veo3/Sora2 Smart Suggest - Full field suggestions for new AI video patterns

    Previous (Build 150):
    - NEW: Veo3 (Google) & Sora2 (OpenAI) AI Video Patterns - Platform-specific workflows
    - NEW: Metadata Clustering in Canvas - Group nodes by type, owner, status, cost, or date
    - ENHANCED: Force-Directed Layout - Barnes-Hut O(n log n), collision detection, 500 iterations
    - FIX: Extended Thinking temperature must be 1 (Claude API requirement)

    Previous (Build 148):
    - NEW: Collapsible AI Tools Sidebar - Icon-based left-docked navigation (60px â†’ 260px on hover)
    - NEW: Modern Chat UI - Neutral slate grey for AI, vibrant primary for user (ChatGPT aesthetic)
    - NEW: Typography Improvements - Larger titles (17px), better hierarchy, improved scannability
    - NEW: Zoom controls integrated into sidebar above Settings (fixes layout conflict)
    - ENHANCEMENT: Reclaimed ~200px canvas width when sidebar collapsed
    - FIX: Removed standalone zoom panel that was obstructing AI sidebar

    Previous (Build 147):
    - NEW: Pattern Translation Engine - Convert Generic â†’ Sales (and reverse) with field mapping
    - NEW: Shadow Data Preservation - Original data backed up during translation
    - FIX: Temperature parameter now correctly applied from Creativity slider

    Previous (Build 146):
    - NEW: AI Tuner - Customize AI tone, verbosity, creativity, and custom instructions
    - NEW: Persistent AI personas - Settings saved in tree JSON and travel with file
    - NEW: Live preview in AI Settings modal shows before/after prompt transformation

    Previous (Build 145):
    - NEW: Filesystem pattern "Digital Librarian" AI - Smart Suggest for all file metadata fields
    - COMPLETE: All 15 patterns now have pattern-specific Smart Suggest coverage

    Previous (Build 144):
    - FIX: Canvas View dependency arrows for hidden phases (no more random purple lines)
    - FIX: Philosophy Pattern AI Analysis using correct persona (not generic PM)
    - FIX: Pattern loading from JSON handles both string and object formats

    Previous (Build 143):
    - FIX: CORS protection for ALL AI providers (Gemini, ChatGPT, Claude)
    - FIX: Clear error messages when using Gemini/ChatGPT from local files
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -->

    <!-- PWA Configuration -->
    <link rel="manifest" href="./manifest.json" id="pwa-manifest">
    <script>
        // Remove manifest link on file:// protocol to prevent CORS errors
        if (window.location.protocol === 'file:') {
            document.getElementById('pwa-manifest')?.remove();
        }
    </script>
    <!-- BUILD 328: Single source of truth for version info -->
    <script>
        window.TREELISTY_VERSION = {
            major: '2.57.0',
            build: 616,
            date: '2025-12-27',
            get full() { return `v${this.major} â€¢ Build ${this.build}`; },
            get title() { return `TreeListy v${this.major} | Build ${this.build} | ${this.date}`; }
        };

        // BUILD 610: URL Parameter API for Readonly/Embed Mode
        // Usage: treeplexity.html?mode=readonly&tree=help
        //        treeplexity.html?mode=embed&tree=https://example.com/tree.json
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            const viewMode = urlParams.get('mode'); // 'readonly' | 'embed' | null
            const treeSource = urlParams.get('tree'); // 'help' | 'welcome' | URL | null
            const themeOverride = urlParams.get('theme'); // 'dark' | 'light' | null
            const startExpanded = urlParams.get('expanded') !== 'false';

            window.TREELISTY_MODE = {
                readonly: viewMode === 'readonly' || viewMode === 'embed',
                embed: viewMode === 'embed',
                treeSource: treeSource,
                themeOverride: themeOverride,
                startExpanded: startExpanded
            };

            // Apply body classes immediately for CSS-based hiding
            if (document.body) {
                if (TREELISTY_MODE.readonly) document.body.classList.add('readonly-mode');
                if (TREELISTY_MODE.embed) document.body.classList.add('embed-mode');
            } else {
                document.addEventListener('DOMContentLoaded', () => {
                    if (TREELISTY_MODE.readonly) document.body.classList.add('readonly-mode');
                    if (TREELISTY_MODE.embed) document.body.classList.add('embed-mode');
                });
            }
        })();
    </script>
    <meta name="theme-color" content="#6366f1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TreeListy">
    <link rel="icon" type="image/png" href="./assets/treelisty-icon2.png">
    <link rel="apple-touch-icon" href="./assets/treelisty-icon2.png">
    <meta name="description" content="Visual project management and hierarchical data organization tool with AI-powered insights">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            /* Default Theme */
            --treeplex-primary: #6366f1;
            --treeplex-primary-dark: #4f46e5;
            --phase-0: #5FA463;
            --phase-0-light: #6FB56E;
            --phase-0-dark: #4A8C4E;
            --phase-1: #3B8FCC;
            --phase-1-light: #4A9DD9;
            --phase-1-dark: #2B7AB8;
            --phase-2: #D68A2E;
            --phase-2-light: #E09940;
            --phase-2-dark: #B8741F;
            --text-primary: #E8EAF0;
            --text-secondary: #9DA3B4;
            --border: #3A3F4D;
            --bg: #1E2128;
            --card-bg: #2A2F3C;
            --card-bg-light: #32374A;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.5);
            --shadow-xl: 0 12px 40px rgba(0,0,0,0.6);
        }

        /* ============================================================================
           BUILD 610: READONLY/EMBED MODE STYLES
           Hide editing controls when viewing in readonly or embed mode
           ============================================================================ */

        /* READONLY MODE - Hide editing controls but keep full chrome */
        body.readonly-mode .edit-control,
        body.readonly-mode .save-btn,
        body.readonly-mode .ai-wizard-btn,
        body.readonly-mode [data-action="add"],
        body.readonly-mode [data-action="delete"],
        body.readonly-mode [data-action="edit"],
        body.readonly-mode .add-phase-btn,
        body.readonly-mode .context-menu-item[data-action="edit"],
        body.readonly-mode .context-menu-item[data-action="delete"],
        body.readonly-mode .context-menu-item[data-action="add-child"],
        body.readonly-mode .context-menu-item[data-action="add-sibling"],
        body.readonly-mode .import-btn,
        body.readonly-mode #import-modal,
        body.readonly-mode .paste-mode-container {
            display: none !important;
        }

        /* Readonly mode - show clone button when present */
        body.readonly-mode .clone-to-edit-btn {
            display: inline-flex !important;
        }

        /* EMBED MODE - Minimal chrome for iframes (hides header, sidebar, footer) */
        body.embed-mode .header,
        body.embed-mode .header-container,
        body.embed-mode .sidebar,
        body.embed-mode .sidebar-collapsed,
        body.embed-mode .version-badge,
        body.embed-mode .footer-bar,
        body.embed-mode #how-to-btn,
        body.embed-mode #theme-toggle,
        body.embed-mode .pwa-install-btn,
        body.embed-mode .fullscreen-exit-btn,
        body.embed-mode .mobile-hamburger {
            display: none !important;
        }

        body.embed-mode .main-content {
            margin-left: 0 !important;
            padding-top: 0 !important;
        }

        body.embed-mode .tree-container {
            padding-top: 8px;
        }

        /* Embed mode - compact header with just tree title */
        body.embed-mode .tree-header-bar {
            padding: 8px 16px;
            border-bottom: 1px solid var(--border);
            background: var(--card-bg);
        }

        /* Clone to edit button - only shown in readonly/embed modes */
        .clone-to-edit-btn {
            display: none;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--treeplex-primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .clone-to-edit-btn:hover {
            background: var(--treeplex-primary-dark);
        }

        /* Help modal sizing for embedded TreeListy */
        #modal.help-modal .modal-content {
            max-width: 900px;
            width: 90vw;
        }

        /* BUILD 611: Help Mode - Back Button */
        .help-back-btn {
            position: fixed;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            background: var(--treeplex-primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: all 0.2s;
        }

        .help-back-btn:hover {
            background: var(--treeplex-primary-dark);
            transform: translateX(-50%) scale(1.05);
        }

        /* Help mode indicator */
        body.help-mode .tree-header {
            background: linear-gradient(135deg, var(--treeplex-primary) 0%, var(--phase-1) 100%);
        }

        /* THEME: STEAMPUNK */
        [data-theme="steampunk"] {
            --treeplex-primary: #b8860b;
            --treeplex-primary-dark: #8b6914;
            --phase-0: #cd7f32;
            --phase-0-light: #d4924e;
            --phase-0-dark: #8b5a2b;
            --phase-1: #b87333;
            --phase-1-light: #d4924e;
            --phase-1-dark: #8b4513;
            --phase-2: #daa520;
            --phase-2-light: #ffd700;
            --phase-2-dark: #b8860b;
            --text-primary: #f5deb3;
            --text-secondary: #d2b48c;
            --border: #8b4513;
            --bg: #2b1810;
            --card-bg: #3e2315;
            --card-bg-light: #4a2817;
        }

        /* THEME: POWERPUFF GIRLS */
        [data-theme="powerpuff"] {
            --treeplex-primary: #ff6eb4;
            --treeplex-primary-dark: #ff1493;
            --phase-0: #ff69b4;
            --phase-0-light: #ffb6d9;
            --phase-0-dark: #c71585;
            --phase-1: #87ceeb;
            --phase-1-light: #b0e0e6;
            --phase-1-dark: #4682b4;
            --phase-2: #9acd32;
            --phase-2-light: #c7ea46;
            --phase-2-dark: #6b8e23;
            --text-primary: #2d2d2d;
            --text-secondary: #666666;
            --border: #ffb6d9;
            --bg: #fff0f5;
            --card-bg: #ffffff;
            --card-bg-light: #fffafd;
        }

        /* THEME: TRON */
        [data-theme="tron"] {
            --treeplex-primary: #00ffff;
            --treeplex-primary-dark: #00d4d4;
            --phase-0: #00ffff;
            --phase-0-light: #66ffff;
            --phase-0-dark: #00cccc;
            --phase-1: #00d4ff;
            --phase-1-light: #66e0ff;
            --phase-1-dark: #0099cc;
            --phase-2: #ff6600;
            --phase-2-light: #ff9944;
            --phase-2-dark: #cc5200;
            --text-primary: #e0ffff;
            --text-secondary: #7dd3ff;
            --border: #00ffff;
            --bg: #000000;
            --card-bg: #0a0a0a;
            --card-bg-light: #141414;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            overflow: auto;
        }

        ::selection {
            background: var(--treeplex-primary);
            color: white;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            background: #252931;
            border-bottom: 1px solid var(--border);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 300;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .logo {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-right: 40px;
        }

        .logo-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 24px;
            font-weight: 700;
            color: var(--treeplex-primary);
            letter-spacing: -0.5px;
        }

        .logo-icon {
            height: 32px;
            width: 32px;
            object-fit: contain;
        }

        .logo-subtitle {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-left: 46px;
        }

        /*         .confidential {
        /*             padding: 4px 12px;
        /*             background: #fff5f5;
        /*             border: 1px solid #ffccc7;
        /*             border-radius: 6px;
        /*             font-size: 11px;
        /*             font-weight: 600;
        /*             color: #d32f2f;
        /*             letter-spacing: 0.5px;
        /*         } */

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .control-section {
            display: flex;
            gap: 6px;
            padding: 0 12px;
            border-right: 1px solid var(--border);
        }

        .control-section:last-child {
            border-right: none;
            padding-right: 0;
        }

        .control-section:first-child {
            padding-left: 0;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: var(--card-bg);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn:hover {
            background: var(--card-bg-light);
            border-color: var(--treeplex-primary);
        }

        .btn-primary {
            background: var(--treeplex-primary);
            color: white;
            border-color: var(--treeplex-primary);
        }

        .btn-primary:hover {
            background: var(--treeplex-primary-dark);
        }
/* Pattern Selector */        .pattern-selector {            position: relative;            display: inline-block;        }        .pattern-select {            padding: 8px 12px;            border: 1px solid var(--border);            background: var(--card-bg);            color: var(--text-primary);            border-radius: 6px;            font-size: 13px;            font-weight: 500;            cursor: pointer;            font-family: inherit;            min-width: 180px;        }        .pattern-select:hover {            background-color: var(--card-bg-light);            border-color: var(--treeplex-primary);        }        .pattern-select:focus {            outline: none;            border-color: var(--treeplex-primary);            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);        }

        /* BUILD 468: Global dark theme for all dropdown options */
        select option {
            background: #1a1a2e;
            color: #ffffff;
            padding: 8px;
        }
        select option:hover,
        select option:focus,
        select option:checked {
            background: rgba(99, 102, 241, 0.4);
            color: #ffffff;
        }

        /* Pan/Zoom Controls */
        .zoom-controls {
            position: fixed;
            top: 90px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: var(--card-bg);
            padding: 12px;
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border);
        }

        .zoom-btn {
            width: 44px;
            height: 44px;
            border: 1px solid var(--border);
            background: var(--card-bg-light);
            color: var(--text-primary);
            border-radius: 8px;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: inherit;
        }

        .zoom-btn:hover {
            background: var(--treeplex-primary);
            border-color: var(--treeplex-primary);
            color: white;
            transform: scale(1.05);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-level {
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            padding: 8px 0;
            border-top: 1px solid var(--border);
            margin-top: 4px;
        }

        /* Tree Container */
        .tree-container {
            padding: 0;
            overflow: hidden;
            min-height: calc(100vh - 70px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background:
                repeating-linear-gradient(45deg, transparent, transparent 40px, rgba(0, 166, 125, 0.03) 40px, rgba(0, 166, 125, 0.03) 80px),
                repeating-linear-gradient(-45deg, transparent, transparent 40px, rgba(59, 143, 204, 0.02) 40px, rgba(59, 143, 204, 0.02) 80px),
                linear-gradient(180deg, #1A1D24 0%, #1E2128 50%, #1A1D24 100%);
            cursor: grab;
        }

        .tree-container.panning {
            cursor: grabbing;
        }

        .tree-transform-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: flex-start;  /* BUILD 332: Anchor to top for proper zoom behavior */
            justify-content: flex-start;
            transform-origin: top left;  /* Scale from top-left so zoomed content stays visible */
            transition: transform 0.15s ease-out;  /* BUILD 410: Smooth zoom animation */
            min-width: 100%;
            min-height: 100%;
        }

        .tree-transform-wrapper.panning {
            transition: none;  /* Disable transition during drag for immediate response */
        }

        .tree-container::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 166, 125, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(59, 143, 204, 0.06) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(214, 138, 46, 0.04) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }

        .dependency-svg {
            position: absolute;
            top: -5000px;
            left: -5000px;
            width: 20000px;
            height: 20000px;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .dependency-line {
            fill: none;
            stroke: var(--treeplex-primary);
            stroke-width: 3;
            stroke-dasharray: 8, 4;
            opacity: 0.6;
            transition: all 0.3s;
            animation: dash-flow 20s linear infinite;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
        }

        .dependency-line:hover {
            opacity: 1;
            stroke-width: 4;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25));
        }

        .dependency-line.phase-0 {
            stroke: var(--phase-0-dark);
        }

        .dependency-line.phase-1 {
            stroke: var(--phase-1-dark);
        }

        .dependency-line.phase-2 {
            stroke: var(--phase-2-dark);
        }

        .dependency-line.cross-phase {
            stroke: var(--treeplex-primary-dark);
            opacity: 0.7;
            stroke-width: 3.5;
        }

        @keyframes dash-flow {
            to {
                stroke-dashoffset: -100;
            }
        }

        .tree {
            display: flex;
            flex-direction: row;
            gap: 40px;
            align-items: center;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }

        .tree-level {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 12px;
            padding: 20px;
            border-radius: 12px;
            transition: background 0.3s;
        }

        /* Phase-specific backgrounds - subtle gradients */
        .tree-level:has(.phase-0) {
            background: linear-gradient(180deg, rgba(95, 164, 99, 0.03) 0%, rgba(95, 164, 99, 0.08) 100%);
        }

        .tree-level:has(.phase-1) {
            background: linear-gradient(180deg, rgba(59, 143, 204, 0.03) 0%, rgba(59, 143, 204, 0.08) 100%);
        }

        .tree-level:has(.phase-2) {
            background: linear-gradient(180deg, rgba(214, 138, 46, 0.03) 0%, rgba(214, 138, 46, 0.08) 100%);
        }

        .tree-node {
            background: linear-gradient(145deg, var(--card-bg-light), var(--card-bg));
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: var(--shadow-md), 0 0 0 1px rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            min-width: 280px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .tree-node:hover {
            box-shadow: var(--shadow-lg), 0 0 0 1px rgba(255,255,255,0.1);
            transform: translateX(4px) translateY(-2px);
            border-color: var(--treeplex-primary);
            background: linear-gradient(145deg, #3A3F52, var(--card-bg-light));
        }

        /* BUILD 489: Selected node styling - indicates which node's info panel is open */
        .tree-node.selected {
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.35), 0 0 0 2px var(--treeplex-primary);
            border-color: var(--treeplex-primary);
            background: linear-gradient(145deg, rgba(99, 102, 241, 0.15), rgba(99, 102, 241, 0.05));
            transform: translateX(4px);
            z-index: 20;
        }

        .tree-node.selected::before {
            content: 'â—€';
            position: absolute;
            right: -24px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--treeplex-primary);
            font-size: 14px;
            opacity: 0.8;
        }

        .tree-node::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 16px;
            background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
            pointer-events: none;
        }

        /* BUILD 415: Shape Hierarchy - Root = Hexagon */
        .tree-node.root {
            background: linear-gradient(135deg, #4a4a6a 0%, #3d3d5c 100%);
            color: #d0d0e0;
            font-size: 18px;
            font-weight: 600;
            min-width: 200px;
            box-shadow: 0 4px 20px rgba(74, 74, 106, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            clip-path: polygon(8% 0%, 92% 0%, 100% 50%, 92% 100%, 8% 100%, 0% 50%);
            padding: 24px 36px;
            text-align: center;
        }

        .tree-node.root:hover {
            box-shadow: 0 6px 28px rgba(74, 74, 106, 0.4);
            background: linear-gradient(135deg, #5a5a7a 0%, #4d4d6c 100%);
            transform: translateY(-2px);
        }

        .tree-node.root .node-subtitle {
            font-size: 11px;
            font-weight: 500;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
            color: #a0a0b0;
        }

        /* BUILD 415: Shape Hierarchy - Phase = Rounded Rectangle */
        .tree-node.phase {
            background: linear-gradient(135deg, #3a5a5a 0%, #2d4a4a 100%);
            color: #b8d0d0;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 3px 16px rgba(58, 90, 90, 0.25);
            padding: 16px 20px;
        }

        .tree-node.phase:hover {
            background: linear-gradient(135deg, #4a6a6a 0%, #3d5a5a 100%);
            box-shadow: 0 5px 22px rgba(58, 90, 90, 0.35);
            transform: translateX(3px) translateY(-1px);
        }

        .tree-node.phase .node-title {
            font-weight: 600;
            font-size: 15px;
        }

        /* BUILD 420: Phase Color Cycling - Different muted color per phase/year */
        .tree-node.phase.phase-0 { background: linear-gradient(135deg, #3a5a5a 0%, #2d4a4a 100%); color: #b8d0d0; }
        .tree-node.phase.phase-1 { background: linear-gradient(135deg, #4a4a5f 0%, #3a3a4f 100%); color: #c8c8d8; }
        .tree-node.phase.phase-2 { background: linear-gradient(135deg, #3a4a5f 0%, #2d3a4f 100%); color: #b8c8d8; }
        .tree-node.phase.phase-3 { background: linear-gradient(135deg, #3a5a4a 0%, #2d4a3a 100%); color: #b8d0c0; }
        .tree-node.phase.phase-4 { background: linear-gradient(135deg, #5a4a50 0%, #4a3a40 100%); color: #d8c8cc; }
        .tree-node.phase.phase-5 { background: linear-gradient(135deg, #5a5040 0%, #4a4030 100%); color: #d8d0b8; }
        /* Cycle repeats for 6+ phases */
        .tree-node.phase.phase-6 { background: linear-gradient(135deg, #3a5a5a 0%, #2d4a4a 100%); color: #b8d0d0; }
        .tree-node.phase.phase-7 { background: linear-gradient(135deg, #4a4a5f 0%, #3a3a4f 100%); color: #c8c8d8; }
        .tree-node.phase.phase-8 { background: linear-gradient(135deg, #3a4a5f 0%, #2d3a4f 100%); color: #b8c8d8; }
        .tree-node.phase.phase-9 { background: linear-gradient(135deg, #3a5a4a 0%, #2d4a3a 100%); color: #b8d0c0; }

        /* Hover states for colored phases */
        .tree-node.phase.phase-0:hover { background: linear-gradient(135deg, #4a6a6a 0%, #3d5a5a 100%); }
        .tree-node.phase.phase-1:hover { background: linear-gradient(135deg, #5a5a6f 0%, #4a4a5f 100%); }
        .tree-node.phase.phase-2:hover { background: linear-gradient(135deg, #4a5a6f 0%, #3d4a5f 100%); }
        .tree-node.phase.phase-3:hover { background: linear-gradient(135deg, #4a6a5a 0%, #3d5a4a 100%); }
        .tree-node.phase.phase-4:hover { background: linear-gradient(135deg, #6a5a60 0%, #5a4a50 100%); }
        .tree-node.phase.phase-5:hover { background: linear-gradient(135deg, #6a6050 0%, #5a5040 100%); }
        .tree-node.phase.phase-6:hover { background: linear-gradient(135deg, #4a6a6a 0%, #3d5a5a 100%); }
        .tree-node.phase.phase-7:hover { background: linear-gradient(135deg, #5a5a6f 0%, #4a4a5f 100%); }
        .tree-node.phase.phase-8:hover { background: linear-gradient(135deg, #4a5a6f 0%, #3d4a5f 100%); }
        .tree-node.phase.phase-9:hover { background: linear-gradient(135deg, #4a6a5a 0%, #3d5a4a 100%); }

        /* BUILD 415: Shape Hierarchy - Item = Rectangle (sharp corners) */
        .tree-node.item {
            background: linear-gradient(135deg, #5a4a4f 0%, #4a3a40 100%);
            color: #d8c8cc;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 2px 12px rgba(90, 74, 79, 0.2);
            padding: 14px 18px;
        }

        .tree-node.item:hover {
            background: linear-gradient(135deg, #6a5a5f 0%, #5a4a50 100%);
            box-shadow: 0 4px 18px rgba(90, 74, 79, 0.3);
            transform: translateX(3px) translateY(-1px);
        }

        .tree-node.item .item-name {
            font-weight: 500;
            font-size: 14px;
        }

        /* BUILD 420: Item colors matching parent phase */
        .tree-node.item.phase-0 { background: linear-gradient(135deg, #4a6a6a 0%, #3d5a5a 100%); color: #c8e0e0; }
        .tree-node.item.phase-1 { background: linear-gradient(135deg, #5a5a6f 0%, #4a4a5f 100%); color: #d8d8e8; }
        .tree-node.item.phase-2 { background: linear-gradient(135deg, #4a5a6f 0%, #3d4a5f 100%); color: #c8d8e8; }
        .tree-node.item.phase-3 { background: linear-gradient(135deg, #4a6a5a 0%, #3d5a4a 100%); color: #c8e0d0; }
        .tree-node.item.phase-4 { background: linear-gradient(135deg, #6a5a60 0%, #5a4a50 100%); color: #e8d8dc; }
        .tree-node.item.phase-5 { background: linear-gradient(135deg, #6a6050 0%, #5a5040 100%); color: #e8e0c8; }
        /* Cycle repeats */
        .tree-node.item.phase-6 { background: linear-gradient(135deg, #4a6a6a 0%, #3d5a5a 100%); color: #c8e0e0; }
        .tree-node.item.phase-7 { background: linear-gradient(135deg, #5a5a6f 0%, #4a4a5f 100%); color: #d8d8e8; }
        .tree-node.item.phase-8 { background: linear-gradient(135deg, #4a5a6f 0%, #3d4a5f 100%); color: #c8d8e8; }
        .tree-node.item.phase-9 { background: linear-gradient(135deg, #4a6a5a 0%, #3d5a4a 100%); color: #c8e0d0; }

        /* Hover states for colored items */
        .tree-node.item.phase-0:hover { background: linear-gradient(135deg, #5a7a7a 0%, #4d6a6a 100%); }
        .tree-node.item.phase-1:hover { background: linear-gradient(135deg, #6a6a7f 0%, #5a5a6f 100%); }
        .tree-node.item.phase-2:hover { background: linear-gradient(135deg, #5a6a7f 0%, #4d5a6f 100%); }
        .tree-node.item.phase-3:hover { background: linear-gradient(135deg, #5a7a6a 0%, #4d6a5a 100%); }
        .tree-node.item.phase-4:hover { background: linear-gradient(135deg, #7a6a70 0%, #6a5a60 100%); }
        .tree-node.item.phase-5:hover { background: linear-gradient(135deg, #7a7060 0%, #6a6050 100%); }
        .tree-node.item.phase-6:hover { background: linear-gradient(135deg, #5a7a7a 0%, #4d6a6a 100%); }
        .tree-node.item.phase-7:hover { background: linear-gradient(135deg, #6a6a7f 0%, #5a5a6f 100%); }
        .tree-node.item.phase-8:hover { background: linear-gradient(135deg, #5a6a7f 0%, #4d5a6f 100%); }
        .tree-node.item.phase-9:hover { background: linear-gradient(135deg, #5a7a6a 0%, #4d6a5a 100%); }

        /* BUILD 415: Shape Hierarchy - Subtask = Pill */
        .tree-node.subtask {
            background: linear-gradient(135deg, #3a4a5a 0%, #2d3a4a 100%);
            color: #b0c0d0;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 2px 10px rgba(58, 74, 90, 0.2);
            padding: 10px 18px;
            font-size: 13px;
        }

        .tree-node.subtask:hover {
            background: linear-gradient(135deg, #4a5a6a 0%, #3d4a5a 100%);
            box-shadow: 0 3px 14px rgba(58, 74, 90, 0.3);
            transform: translateX(2px);
        }

        /* BUILD 415: Deep nesting opacity fade for subtasks */
        .tree-node.subtask[data-depth="4"] { opacity: 0.85; }
        .tree-node.subtask[data-depth="5"] { opacity: 0.70; }
        .tree-node.subtask[data-depth="6"] { opacity: 0.55; }
        .tree-node.subtask[data-depth="7"] { opacity: 0.45; }

        /* BUILD 544: Capability Node Card */
        .tree-node.capability {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.15);
        }

        .tree-node.capability:hover {
            border-color: rgba(139, 92, 246, 0.5);
            box-shadow: 0 6px 24px rgba(139, 92, 246, 0.25);
            transform: translateY(-2px);
        }

        .tree-node.capability .node-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .tree-node.capability .capability-icon {
            font-size: 24px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(139, 92, 246, 0.15);
            border-radius: 10px;
        }

        .tree-node.capability .capability-info {
            flex: 1;
        }

        .tree-node.capability .capability-name {
            font-weight: 600;
            font-size: 15px;
            color: #e2e8f0;
            margin-bottom: 4px;
        }

        .tree-node.capability .capability-site {
            font-size: 12px;
            color: #a0aec0;
        }

        .tree-node.capability .capability-goal {
            font-size: 13px;
            color: #cbd5e0;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
        }

        .tree-node.capability .capability-permissions {
            display: flex;
            gap: 6px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .tree-node.capability .permission-badge {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 500;
        }

        .tree-node.capability .permission-badge.allowed {
            background: rgba(72, 187, 120, 0.2);
            color: #68d391;
            border: 1px solid rgba(72, 187, 120, 0.3);
        }

        .tree-node.capability .permission-badge.forbidden {
            background: rgba(245, 101, 101, 0.2);
            color: #fc8181;
            border: 1px solid rgba(245, 101, 101, 0.3);
        }

        .tree-node.capability .capability-status {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 10px;
            font-size: 11px;
        }

        .tree-node.capability .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .tree-node.capability .status-dot.healthy { background: #48bb78; }
        .tree-node.capability .status-dot.degraded { background: #ecc94b; }
        .tree-node.capability .status-dot.broken { background: #f56565; }
        .tree-node.capability .status-dot.untested { background: #a0aec0; }

        .tree-node.capability .capability-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .tree-node.capability .cap-action-btn {
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid rgba(139, 92, 246, 0.3);
            background: rgba(139, 92, 246, 0.1);
            color: #a78bfa;
            cursor: pointer;
            transition: all 0.15s;
        }

        .tree-node.capability .cap-action-btn:hover {
            background: rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.5);
        }

        /* FILESYSTEM PATTERN: Vertical Tree Layout */
        .tree.filesystem-tree {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 20px;
        }

        .tree.filesystem-tree .tree-level {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 0;
            background: none !important;
        }

        .tree.filesystem-tree .tree-node {
            min-width: auto;
            width: 100%;
            max-width: 800px;
            margin: 4px 0;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.15s;
            cursor: pointer;
        }

        .tree.filesystem-tree .tree-node:hover {
            transform: none;
            background: rgba(99, 102, 241, 0.15);
        }

        .tree.filesystem-tree .tree-node.item,
        .tree.filesystem-tree .tree-node.subtask {
            padding: 6px 10px;
            background: transparent;
            border: none;
            box-shadow: none;
        }

        .tree.filesystem-tree .tree-node.item:hover,
        .tree.filesystem-tree .tree-node.subtask:hover {
            background: rgba(255, 255, 255, 0.05);
            box-shadow: none;
        }

        .tree.filesystem-tree .filesystem-indent-0 { margin-left: 0px; }
        .tree.filesystem-tree .filesystem-indent-1 { margin-left: 40px; }
        .tree.filesystem-tree .filesystem-indent-2 { margin-left: 80px; }
        .tree.filesystem-tree .filesystem-indent-3 { margin-left: 120px; }
        .tree.filesystem-tree .filesystem-indent-4 { margin-left: 160px; }
        .tree.filesystem-tree .filesystem-indent-5 { margin-left: 200px; }
        .tree.filesystem-tree .filesystem-indent-6 { margin-left: 240px; }
        .tree.filesystem-tree .filesystem-indent-7 { margin-left: 280px; }
        .tree.filesystem-tree .filesystem-indent-8 { margin-left: 320px; }
        .tree.filesystem-tree .filesystem-indent-9 { margin-left: 360px; }
        .tree.filesystem-tree .filesystem-indent-10 { margin-left: 400px; }

        .tree.filesystem-tree .node-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tree.filesystem-tree .expand-toggle {
            font-size: 14px;
            margin-right: 6px;
            cursor: pointer;
            padding: 2px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 16px;
            user-select: none;
            transition: all 0.2s;
        }

        .tree.filesystem-tree .expand-toggle:hover {
            color: var(--accent-primary);
            transform: scale(1.2);
        }

        .tree.filesystem-tree .node-icon {
            font-size: 16px;
            margin-right: 4px;
        }

        .tree.filesystem-tree .node-title,
        .tree.filesystem-tree .item-name {
            font-size: 13px;
            font-weight: 500;
        }

        .tree.filesystem-tree .node-subtitle,
        .tree.filesystem-tree .item-description {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* ============================================================================
           BUILD 335: HAMBURGER MENU BUTTON
           Hidden on desktop, visible on mobile
           ============================================================================ */
        .mobile-hamburger {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 44px;
            height: 44px;
            padding: 10px;
            background: transparent;
            border: none;
            cursor: pointer;
            gap: 5px;
            margin-left: auto;
        }

        .hamburger-line {
            display: block;
            width: 24px;
            height: 2px;
            background: var(--text);
            border-radius: 2px;
            transition: all 0.3s ease;
        }

        /* Hamburger â†’ X animation when open */
        .mobile-hamburger.open .hamburger-line:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        .mobile-hamburger.open .hamburger-line:nth-child(2) {
            opacity: 0;
        }
        .mobile-hamburger.open .hamburger-line:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* BUILD 491: Mobile Fullscreen Button */
        .mobile-fullscreen-btn {
            display: none;
            width: 40px;
            height: 40px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 20px;
            color: var(--text);
            margin-left: 8px;
        }
        .mobile-fullscreen-btn:hover {
            color: var(--treeplex-primary);
        }

        /* BUILD 491: Fullscreen mode - hide header, maximize content */
        body.mobile-fullscreen .header {
            display: none !important;
        }
        body.mobile-fullscreen #tree-container,
        body.mobile-fullscreen #canvas-container,
        body.mobile-fullscreen #gantt-container,
        body.mobile-fullscreen #three-container {
            height: 100vh !important;
            max-height: 100vh !important;
            top: 0 !important;
            padding-top: 0 !important;
        }
        body.mobile-fullscreen .fullscreen-exit-btn {
            display: block !important;
        }

        /* Floating exit fullscreen button */
        .fullscreen-exit-btn {
            display: none;
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 999999;
            width: 44px;
            height: 44px;
            background: rgba(30, 33, 40, 0.9);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 22px;
            cursor: pointer;
            backdrop-filter: blur(8px);
        }
        .fullscreen-exit-btn:hover {
            background: rgba(99, 102, 241, 0.9);
        }

        /* Mobile menu overlay - catches taps outside menu to close */
        /* z-index MUST be lower than .controls so menu is clickable */
        /* BUILD 497: Reasonable z-index values */
        .mobile-menu-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            /* BUILD 350: Only cover left side, leave menu area clear */
            right: 300px;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 9999; /* Below controls (10000) */
        }
        .mobile-menu-overlay.visible {
            display: block;
        }


        /* ============================================================================
           MOBILE OPTIMIZED VIEW - BUILD 336
           File-system style reading mode with hamburger menu
           ============================================================================ */
        @media screen and (max-width: 768px), (max-device-width: 768px), (pointer: coarse) and (max-width: 1024px) {
            /* CRITICAL: Hide EVERYTHING that's not the tree content */
            html, body {
                overflow-x: hidden !important;
                max-width: 100vw !important;
            }

            /* Show hamburger button on mobile - HIGH CONTRAST */
            .mobile-hamburger {
                display: flex !important;
                background: #6366f1 !important;
                border-radius: 8px !important;
                border: 2px solid #818cf8 !important;
            }

            .mobile-hamburger .hamburger-line {
                background: #ffffff !important;
                width: 20px !important;
                height: 3px !important;
            }

            /* BUILD 491: Show fullscreen button on mobile */
            .mobile-fullscreen-btn {
                display: flex !important;
                align-items: center;
                justify-content: center;
                background: rgba(99, 102, 241, 0.2) !important;
                border-radius: 8px !important;
            }

            /* Show overlay when menu is open - covers LEFT side only (not menu) */
            /* BUILD 497: Reasonable z-index */
            .mobile-menu-overlay.visible {
                display: block !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 300px !important; /* Leave menu area clear */
                bottom: 0 !important;
                background: rgba(0, 0, 0, 0.5) !important;
                z-index: 9999 !important; /* Below menu (10000) */
                touch-action: none !important;
                -webkit-tap-highlight-color: transparent !important;
            }

            /* Logo container: full width on mobile so hamburger pushes to right */
            .header > div:first-child {
                flex: 1 !important;
                width: 100% !important;
            }

            /* Header: Minimal - just logo + hamburger */
            /* iOS: Use position:fixed (not sticky) to avoid stacking context issues */
            .header {
                padding: 8px 12px !important;
                gap: 8px !important;
                min-height: 48px !important;
                max-height: 48px !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 2000 !important; /* Above panels (1000-1001) */
                background: #0f1117 !important; /* Solid background */
            }

            /* Hide logo subtitle on mobile */
            .header .logo-subtitle,
            #save-indicator {
                display: none !important;
            }

            .header .logo-title {
                font-size: 15px !important;
            }

            /* ===== BUILD 491: MOBILE SLIDE-OUT MENU - DARK THEME ===== */

            /* Controls panel: Dark themed slide-out */
            /* BUILD 497: Fix z-index and pointer-events to prevent blocking modals */
            .header .controls {
                display: flex !important;
                flex-direction: column !important;
                flex-wrap: nowrap !important; /* BUILD 502: Prevent column wrapping which hides theme/help */
                position: fixed !important;
                top: 0 !important;
                right: -320px !important;
                width: 300px !important;
                height: 100% !important;
                height: 100dvh !important; /* iOS dynamic viewport */
                background: #1a1d24 !important;
                padding: 56px 10px 180px 10px !important; /* Extra bottom padding to clear FABs */
                gap: 8px !important;
                overflow-y: scroll !important; /* Always show scrollbar hint */
                overflow-x: hidden !important;
                z-index: 10000 !important; /* Reasonable z-index, not max int */
                box-shadow: -4px 0 20px rgba(0,0,0,0.5) !important;
                transition: right 0.25s ease-out, pointer-events 0s 0.25s !important;
                pointer-events: none !important; /* CRITICAL: Don't capture events when closed */
                touch-action: pan-y !important;
                -webkit-overflow-scrolling: touch !important;
                overscroll-behavior: contain !important; /* Prevent scroll chaining */
            }

            /* When menu is open, slide in and enable touch */
            .header .controls.mobile-menu-open {
                right: 0 !important;
                pointer-events: auto !important; /* Enable touch only when open */
                transition: right 0.25s ease-out, pointer-events 0s 0s !important;
            }

            /* All child elements must be visible AND clickable */
            .header .controls > * {
                display: flex !important;
                flex-shrink: 0 !important;
                pointer-events: auto !important;
            }

            /* Control sections - dark cards */
            .header .controls .control-section {
                display: flex !important;
                flex-direction: row !important;
                flex-wrap: wrap !important;
                gap: 6px !important;
                padding: 10px !important;
                background: #252932 !important;
                border: 1px solid #363b47 !important;
                border-radius: 10px !important;
                width: 100% !important;
                box-sizing: border-box !important;
                pointer-events: auto !important;
            }

            /* Buttons - indigo accent on dark (exclude dropdown items and hidden compat buttons) */
            .header .controls .btn:not([style*="display: none"]),
            .header .controls button:not(.dropdown-menu-item):not(.dropdown-menu-trigger):not([style*="display: none"]) {
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                gap: 6px !important;
                background: #4f46e5 !important;
                color: #ffffff !important;
                border: none !important;
                padding: 8px 12px !important;
                font-size: 13px !important;
                font-weight: 500 !important;
                border-radius: 8px !important;
                min-height: 38px !important;
                cursor: pointer !important;
                pointer-events: auto !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: rgba(99,102,241,0.3) !important;
                flex: 1 1 auto !important;
                min-width: 60px !important;
            }

            /* Keep hidden buttons hidden */
            .header .controls #toggle-view-mode,
            .header .controls #toggle-3d-mode {
                display: none !important;
            }

            /* Dropdown triggers - darker */
            .header .controls .dropdown-menu-trigger {
                background: #363b47 !important;
                color: #e2e8f0 !important;
                pointer-events: auto !important;
            }

            /* Selects/dropdowns - dark */
            .header .controls select {
                display: block !important;
                width: 100% !important;
                background: #2a2f3a !important;
                color: #e2e8f0 !important;
                border: 1px solid #4a5568 !important;
                padding: 10px 12px !important;
                font-size: 13px !important;
                font-weight: 500 !important;
                border-radius: 8px !important;
                min-height: 40px !important;
                pointer-events: auto !important;
                touch-action: manipulation !important;
            }

            /* Dropdown menu */
            .header .controls .dropdown-menu {
                pointer-events: auto !important;
                width: 100% !important;
            }

            /* Dropdown menu content - hidden by default, dark themed */
            .header .controls .dropdown-menu-content {
                position: relative !important;
                display: none !important;
                opacity: 0 !important;
                visibility: hidden !important;
                width: 100% !important;
                background: #2a2f3a !important;
                border: 1px solid #4a5568 !important;
                border-radius: 8px !important;
                margin-top: 4px !important;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
                pointer-events: none !important;
            }

            /* BUILD 350: Dropdown content visible when open */
            .header .controls .dropdown-menu-content.open {
                display: block !important;
                opacity: 1 !important;
                visibility: visible !important;
                pointer-events: auto !important;
            }

            /* Dropdown menu items - MUST override button styles */
            .header .controls .dropdown-menu-content .dropdown-menu-item,
            .header .controls button.dropdown-menu-item {
                display: flex !important;
                align-items: center !important;
                justify-content: flex-start !important;
                padding: 12px 16px !important;
                color: #e2e8f0 !important;
                font-size: 14px !important;
                background: #2a2f3a !important;
                border: none !important;
                border-bottom: 1px solid #363b47 !important;
                border-radius: 0 !important;
                min-height: auto !important;
                flex: none !important;
                width: 100% !important;
                pointer-events: auto !important;
                cursor: pointer !important;
            }

            .header .controls .dropdown-menu-content .dropdown-menu-item:active,
            .header .controls button.dropdown-menu-item:active {
                background: #4f46e5 !important;
                color: #ffffff !important;
            }

            /* Labels - light text for dark theme */
            .header .controls label {
                display: flex !important;
                flex-direction: column !important;
                gap: 4px !important;
                color: #9ca3af !important;
                font-size: 12px !important;
                font-weight: 600 !important;
                width: 100% !important;
            }

            /* Hide sort section unless active */
            .header .controls #sort-section {
                display: none !important;
            }

            /* ===== AI TOOLS SIDEBAR: COMPLETELY HIDDEN ===== */
            #ai-tools-panel,
            .ai-tools-panel,
            [id="ai-tools-panel"] {
                display: none !important;
                visibility: hidden !important;
                width: 0 !important;
                height: 0 !important;
                overflow: hidden !important;
                position: absolute !important;
                left: -9999px !important;
            }

            /* ===== MAIN CONTENT: FULL WIDTH ===== */
            .main-content,
            .tree-view-container,
            .canvas-container,
            main,
            [class*="main"] {
                margin-left: 0 !important;
                padding-left: 0 !important;
                width: 100% !important;
                max-width: 100vw !important;
            }

            /* Dropdowns in mobile menu */
            .header .controls .dropdown-menu {
                width: 100% !important;
            }

            /* Hide version on mobile */
            #version-display {
                display: none !important;
            }

            /* ===== FILE SYSTEM STYLE TREE ===== */
            .tree-view-container {
                padding: 0 !important;
                margin: 0 !important;
                overflow-x: hidden !important;
                overflow-y: auto !important;
                width: 100% !important;
                max-width: 100vw !important;
            }

            .tree-container {
                padding: 0 !important;
                margin: 0 !important;
                width: 100% !important;
            }

            .tree {
                display: flex !important;
                flex-direction: column !important;
                gap: 0 !important;
                padding: 4px 8px !important;
                width: 100% !important;
                max-width: 100% !important;
            }

            .tree-level {
                display: flex !important;
                flex-direction: column !important;
                gap: 0 !important;
                padding: 0 !important;
                margin: 0 !important;
                background: transparent !important;
                flex-wrap: nowrap !important;
                width: 100% !important;
            }

            /* ===== FILE SYSTEM NODE STYLING ===== */
            .tree-node {
                min-width: 0 !important;
                width: calc(100% - 4px) !important;
                max-width: none !important;
                margin: 1px 2px !important;
                padding: 10px 12px !important;
                border-radius: 4px !important;
                font-size: 14px !important;
                background: transparent !important;
                border: none !important;
                box-shadow: none !important;
                display: flex !important;
                flex-direction: row !important;
                align-items: center !important;
                gap: 8px !important;
            }

            .tree-node:hover {
                transform: none !important;
                background: rgba(255,255,255,0.05) !important;
            }

            /* BUILD 489: Enhanced selected node styling */
            .tree-node.selected {
                background: rgba(99, 102, 241, 0.2) !important;
                border-left: 4px solid var(--primary) !important;
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25), 0 2px 6px rgba(0, 0, 0, 0.15) !important;
                transform: translateX(2px) !important;
                position: relative !important;
                z-index: 10 !important;
            }

            /* File-system indentation */
            .tree-node.root { margin-left: 0 !important; padding-left: 8px !important; }
            .tree-node.phase { margin-left: 0 !important; padding-left: 8px !important; }
            .tree-node.item { margin-left: 20px !important; padding-left: 8px !important; }
            .tree-node.subtask { margin-left: 40px !important; padding-left: 8px !important; }

            /* Phase: Folder style */
            .tree-node.phase {
                font-weight: 600 !important;
                color: var(--text) !important;
                border-left: 3px solid var(--primary) !important;
                border-left-color: inherit !important;
                margin-top: 8px !important;
                margin-bottom: 2px !important;
            }

            .tree-node.phase::before {
                content: 'ğŸ“' !important;
                display: inline-block !important;
                margin-right: 6px !important;
                font-size: 14px !important;
            }

            /* Item: File style */
            .tree-node.item {
                color: var(--text-secondary) !important;
            }

            .tree-node.item::before {
                content: 'ğŸ“„' !important;
                display: inline-block !important;
                margin-right: 6px !important;
                font-size: 13px !important;
            }

            /* Subtask: Nested file */
            .tree-node.subtask {
                font-size: 13px !important;
                color: var(--text-secondary) !important;
                opacity: 0.85 !important;
            }

            .tree-node.subtask::before {
                content: 'â””â”€' !important;
                display: inline-block !important;
                margin-right: 4px !important;
                font-family: monospace !important;
                color: var(--border) !important;
            }

            /* Node content - single line, truncate */
            .node-title,
            .item-name,
            .tree-node > span:first-of-type {
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                flex: 1 !important;
            }

            /* Hide descriptions on mobile */
            .node-subtitle,
            .item-description,
            .node-description {
                display: none !important;
            }

            /* Hide action buttons - use long-press instead */
            .tree-node .node-actions,
            .tree-node .item-actions,
            .node-buttons,
            .tree-node button:not(.collapse-btn) {
                display: none !important;
            }

            /* Keep collapse button visible */
            .tree-node .collapse-btn {
                padding: 4px !important;
                margin-left: auto !important;
                opacity: 0.6 !important;
            }

            /* Hide complex elements (but NOT views - we have pinch-to-zoom now) */
            .dependency-svg,
            .empty-state-cta,
            .hyperedge-indicator {
                display: none !important;
            }

            /* BUILD 516: Enable all views on mobile with pinch-to-zoom */
            /* Must override with .active class to show when view is selected */
            #canvas-container {
                display: none;
                width: 100% !important;
                height: calc(100vh - 48px) !important;
                height: calc(100dvh - 48px) !important;
            }
            #canvas-container.active {
                display: block !important;
            }

            #view-3d {
                display: none;
                width: 100% !important;
                height: calc(100vh - 48px) !important;
                height: calc(100dvh - 48px) !important;
            }
            #view-3d.active {
                display: block !important;
            }

            #gantt-container {
                width: 100% !important;
                height: calc(100vh - 48px) !important;
                height: calc(100dvh - 48px) !important;
            }

            /* ===== BUILD 493: MOBILE SINGLE-PANE NAVIGATION ===== */
            /* Each screen takes full viewport, one visible at a time */

            /* Info panel: Full screen (not bottom sheet) */
            .info-panel {
                position: fixed !important;
                top: 48px !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100% !important;
                height: calc(100vh - 48px) !important;
                height: calc(100dvh - 48px) !important;
                max-height: none !important;
                border-radius: 0 !important;
                transform: translateX(100%) !important;
                transition: transform 0.3s ease !important;
                z-index: 1000 !important;
                background: #1a1d24 !important; /* Solid dark background */
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch !important;
                pointer-events: none !important; /* iOS: prevent touch intercept when off-screen */
            }

            .info-panel.open {
                transform: translateX(0) !important;
                pointer-events: auto !important; /* Enable touch when visible */
            }

            /* Chat panel: Full screen */
            #chat-assistant-panel,
            .chat-assistant-panel {
                position: fixed !important;
                top: 48px !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100% !important;
                height: calc(100vh - 48px) !important;
                height: calc(100dvh - 48px) !important;
                max-width: none !important;
                border-radius: 0 !important;
                transform: translateX(100%) !important;
                transition: transform 0.3s ease !important;
                z-index: 1001 !important;
                background: #1a1d24 !important; /* Solid dark background */
                pointer-events: none !important; /* iOS: prevent touch intercept when off-screen */
            }

            #chat-assistant-panel.open,
            .chat-assistant-panel.open {
                transform: translateX(0) !important;
                pointer-events: auto !important; /* Enable touch when visible */
            }

            /* Tree view: Full screen base layer */
            .tree-view-container {
                position: fixed !important;
                top: 48px !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                z-index: 1 !important;
            }

            /* Navigation indicator dots */
            .mobile-nav-dots {
                position: fixed !important;
                bottom: 20px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                display: flex !important;
                gap: 8px !important;
                z-index: 2000 !important;
                background: rgba(0,0,0,0.5) !important;
                padding: 8px 16px !important;
                border-radius: 20px !important;
            }

            .mobile-nav-dot {
                width: 8px !important;
                height: 8px !important;
                border-radius: 50% !important;
                background: rgba(255,255,255,0.3) !important;
                transition: all 0.2s ease !important;
            }

            .mobile-nav-dot.active {
                background: #6366f1 !important;
                width: 24px !important;
                border-radius: 4px !important;
            }

            /* Swipe hint indicators */
            .swipe-hint-left,
            .swipe-hint-right {
                position: fixed !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
                width: 4px !important;
                height: 60px !important;
                background: linear-gradient(to bottom, transparent, rgba(99,102,241,0.5), transparent) !important;
                z-index: 999 !important;
                opacity: 0 !important;
                transition: opacity 0.3s ease !important;
                pointer-events: none !important;
            }

            .swipe-hint-left { left: 0 !important; }
            .swipe-hint-right { right: 0 !important; }

            .swipe-hint-left.visible,
            .swipe-hint-right.visible {
                opacity: 1 !important;
            }

            /* 3D View controls - compact on mobile */
            #controls-3d {
                bottom: 10px !important;
                gap: 4px !important;
                padding: 6px !important;
                border-radius: 12px !important;
                flex-wrap: wrap !important;
                max-width: calc(100vw - 20px) !important;
                justify-content: center !important;
            }

            #controls-3d .btn {
                padding: 6px 8px !important;
                font-size: 11px !important;
                min-height: 32px !important;
                flex: 0 1 auto !important;
            }

            /* Hide instruction text on mobile */
            #controls-3d > div[style*="color: #888"] {
                display: none !important;
            }

            /* Gantt toolbar - compact on mobile */
            #gantt-toolbar {
                flex-wrap: wrap !important;
                gap: 4px !important;
                padding: 8px !important;
            }

            #gantt-toolbar .btn,
            #gantt-toolbar button,
            #gantt-toolbar select {
                padding: 6px 8px !important;
                font-size: 11px !important;
                min-height: 32px !important;
            }

            /* Hide Gantt floating zoom on mobile (use toolbar instead) */
            #gantt-floating-zoom {
                display: none !important;
            }

            /* BUILD 517: Canvas toolbar - compact scrollable on mobile */
            #canvas-toolbar {
                top: 52px !important;
                left: 4px !important;
                right: 4px !important;
                transform: none !important;
                width: auto !important;
                max-width: calc(100vw - 8px) !important;
                overflow-x: auto !important;
                overflow-y: hidden !important;
                -webkit-overflow-scrolling: touch !important;
                flex-wrap: nowrap !important;
                padding: 6px 8px !important;
                gap: 4px !important;
                border-radius: 10px !important;
                scrollbar-width: none !important; /* Firefox */
            }
            #canvas-toolbar::-webkit-scrollbar {
                display: none !important; /* Chrome/Safari */
            }
            #canvas-toolbar button,
            #canvas-toolbar select {
                padding: 6px 8px !important;
                font-size: 11px !important;
                min-height: 32px !important;
                white-space: nowrap !important;
                flex-shrink: 0 !important;
            }
            /* Hide labels on mobile toolbar, keep icons */
            #canvas-toolbar #grid-toggle { font-size: 14px !important; padding: 6px !important; }
            #canvas-toolbar #reset-view { font-size: 14px !important; padding: 6px !important; }
            #canvas-toolbar #fit-view { font-size: 14px !important; padding: 6px !important; }
            #canvas-toolbar #critical-path-toggle { font-size: 11px !important; }
            /* Hide toolbar dividers on mobile */
            #canvas-toolbar > div[style*="width: 1px"] {
                display: none !important;
            }

            /* BUILD 517: Canvas minimap - smaller on mobile, bottom-left to avoid FABs */
            #canvas-minimap,
            .canvas-minimap {
                display: block !important; /* Override base mobile hide */
                position: fixed !important; /* Fixed to viewport, not container */
                width: 100px !important;
                height: 75px !important;
                bottom: 20px !important;
                left: 8px !important; /* Left side to avoid FABs */
                right: auto !important;
                opacity: 0.9 !important;
                z-index: 300 !important; /* Above toolbar */
            }
            #canvas-minimap #minimap-canvas,
            .canvas-minimap #minimap-canvas {
                width: 100px !important;
                height: 75px !important;
            }

            /* BUILD 517: Canvas context menu - bottom sheet style */
            #canvas-context-menu {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                top: auto !important;
                max-width: none !important;
                border-radius: 16px 16px 0 0 !important;
                padding: 12px !important;
                max-height: 60vh !important;
                overflow-y: auto !important;
            }
            #canvas-context-menu button {
                width: 100% !important;
                padding: 14px 16px !important;
                font-size: 15px !important;
                text-align: left !important;
                justify-content: flex-start !important;
            }

            /* BUILD 517: Canvas search overlay - full width on mobile */
            #canvas-search-overlay {
                top: 52px !important;
                left: 8px !important;
                right: 8px !important;
                width: auto !important;
                max-width: calc(100vw - 16px) !important;
            }

            /* Touch-friendly tap targets */
            .tree-node,
            .btn,
            .dropdown-menu-item {
                min-height: 44px !important;
            }

            /* Context menu: Bottom sheet */
            .context-menu {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                top: auto !important;
                max-width: none !important;
                border-radius: 16px 16px 0 0 !important;
                padding: 12px !important;
                max-height: 50vh !important;
                overflow-y: auto !important;
                z-index: 10000 !important;
            }

            .context-item {
                padding: 14px 16px !important;
                font-size: 15px !important;
            }

            /* Modals: Full screen */
            .modal-content {
                max-width: 100% !important;
                max-height: 100% !important;
                width: 100% !important;
                height: 100% !important;
                border-radius: 0 !important;
                margin: 0 !important;
            }

            /* TreeBeard chat: Full width bottom sheet */
            #treebeard-chat-panel {
                width: 100% !important;
                right: 0 !important;
                left: 0 !important;
                bottom: 0 !important;
                max-height: 70vh !important;
                border-radius: 16px 16px 0 0 !important;
            }

            /* TreeBeard FAB button */
            #treebeard-fab {
                bottom: 16px !important;
                right: 16px !important;
                width: 52px !important;
                height: 52px !important;
            }
        }

        /* Long-press visual feedback for touch */
        @media (pointer: coarse) {
            .tree-node {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
            }

            .tree-node.long-press-active {
                background: rgba(99, 102, 241, 0.2) !important;
                transform: scale(0.98);
            }
        }

        .tree-node.phase {
            border-left: 6px solid;
            min-width: 260px;
            position: relative;
            overflow: hidden;
        }

        .tree-node.phase::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: linear-gradient(180deg, var(--phase-color-light), var(--phase-color-dark));
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
        }

        .tree-node.phase-0 {
            border-left-color: var(--phase-0);
            --phase-color-light: var(--phase-0-light);
            --phase-color-dark: var(--phase-0-dark);
        }

        .tree-node.phase-0:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-0);
        }

        .tree-node.phase-1 {
            border-left-color: var(--phase-1);
            --phase-color-light: var(--phase-1-light);
            --phase-color-dark: var(--phase-1-dark);
        }

        .tree-node.phase-1:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-1);
        }

        .tree-node.phase-2 {
            border-left-color: var(--phase-2);
            --phase-color-light: var(--phase-2-light);
            --phase-color-dark: var(--phase-2-dark);
        }

        .tree-node.phase-2:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-2);
        }

        .tree-node.item {
            min-width: 320px;
            max-width: 360px;
            backdrop-filter: blur(4px);
        }

        /* Subtask container - appears below parent item with animation */
        .subtask-container {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            margin-bottom: 8px;
            padding-left: 10px;
            justify-content: flex-start;
            flex-wrap: wrap;
            max-width: 100%;
            animation: slideDownFade 0.4s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            transform-origin: top center;
        }

        @keyframes slideDownFade {
            0% {
                opacity: 0;
                transform: translateY(-40px) scale(0.95);
                max-height: 0;
                filter: blur(6px) brightness(0.5);
            }
            60% {
                filter: blur(1px) brightness(0.9);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                max-height: 500px;
                filter: blur(0) brightness(1);
            }
        }

        /* Subtask styling - compact visual cards */
        .tree-node.item.subtask {
            min-width: 100px;
            max-width: 100px;
            width: 100px;
            min-height: 85px;
            background: rgba(255, 255, 255, 0.06);
            border-left: 3px solid rgba(0, 166, 125, 0.5);
            border-radius: 6px;
            padding: 10px;
            font-size: 10px;
            margin: 0;
            display: inline-flex;
            flex-direction: column;
            vertical-align: top;
            animation: subtaskReveal 0.35s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            opacity: 0;
            transform: translateY(-20px) scale(0.9);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tree-node.item.subtask:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 166, 125, 0.3);
            border-left-color: rgba(0, 166, 125, 0.8);
        }

        /* Staggered animation for subtasks */
        .tree-node.item.subtask:nth-child(1) { animation-delay: 0.05s; }
        .tree-node.item.subtask:nth-child(2) { animation-delay: 0.1s; }
        .tree-node.item.subtask:nth-child(3) { animation-delay: 0.15s; }
        .tree-node.item.subtask:nth-child(4) { animation-delay: 0.2s; }
        .tree-node.item.subtask:nth-child(5) { animation-delay: 0.25s; }
        .tree-node.item.subtask:nth-child(6) { animation-delay: 0.3s; }

        @keyframes subtaskReveal {
            0% {
                opacity: 0;
                transform: translateY(-20px) scale(0.9);
                filter: blur(4px) brightness(0.6);
            }
            70% {
                transform: translateY(2px) scale(1.01);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                filter: blur(0) brightness(1);
            }
        }


        /* Project management fields styling */
        .pm-field {
            font-size: 8px;
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            line-height: 1.1;
        }

        .pm-field-label {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .pm-field-value {
            font-weight: 600;
        }

        .pm-status {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
        }

        .pm-status.todo { background: rgba(156, 163, 175, 0.3); color: #9CA3AF; }
        .pm-status.inprogress { background: rgba(59, 130, 246, 0.3); color: #3B82F6; }
        .pm-status.completed { background: rgba(16, 185, 129, 0.3); color: #10B981; }
        .pm-status.blocked { background: rgba(239, 68, 68, 0.3); color: #EF4444; }

        .pm-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 2px;
        }

        .pm-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            transition: width 0.3s;
        }

        /* Expand/Collapse toggle for items with subtasks */
        .expand-toggle {
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
            display: inline-block;
        }

        .expand-toggle:hover {
            opacity: 1 !important;
            transform: scale(1.3) rotate(90deg);
        }

        /* Items with subtasks have a pointer cursor */
        .tree-node.item:has(.expand-toggle) {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tree-node.item:has(.expand-toggle):hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 166, 125, 0.2);
        }

        .tree-node.item:has(.expand-toggle):active {
            transform: translateY(0);
            transition: all 0.1s ease;
        }

        /* When item has expanded subtasks, add subtle glow and lift effect */
        .tree-node.item.has-expanded-subtasks {
            box-shadow: 0 0 20px rgba(0, 166, 125, 0.4), 0 6px 16px rgba(0, 0, 0, 0.3);
            border-left-color: rgba(0, 166, 125, 0.9);
            border-left-width: 4px;
            transform: translateY(-2px);
            z-index: 10;
            transition: all 0.3s ease;
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .node-icon {
            font-size: 28px;
            flex-shrink: 0;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
            transition: transform 0.3s;
        }

        .tree-node:hover .node-icon {
            transform: scale(1.1);
        }

        .node-content {
            flex: 1;
        }

        .node-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .node-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .node-cost {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-top: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .tree-node.root .node-cost {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.8));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .expand-toggle {
            font-size: 14px;
            opacity: 0.6;
            transition: transform 0.3s;
            margin-left: auto;
        }

        .tree-node.expanded .expand-toggle {
            transform: rotate(90deg);
        }

        .tree-node.collapsed .expand-toggle {
            transform: rotate(0deg);
        }

        /* Item specific */
        .item-name {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .item-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            border: 1px solid;
        }

        .badge-land {
            background: linear-gradient(135deg, rgba(95, 164, 99, 0.3), rgba(74, 140, 78, 0.2));
            color: #81C784;
            border-color: #4A8C4E;
        }
        .badge-engineering {
            background: linear-gradient(135deg, rgba(59, 143, 204, 0.3), rgba(43, 122, 184, 0.2));
            color: #64B5F6;
            border-color: #2B7AB8;
        }
        .badge-professional {
            background: linear-gradient(135deg, rgba(156, 117, 178, 0.3), rgba(128, 90, 150, 0.2));
            color: #BA68C8;
            border-color: #7B4A92;
        }
        .badge-corporate {
            background: linear-gradient(135deg, rgba(130, 130, 130, 0.3), rgba(100, 100, 100, 0.2));
            color: #B0B0B0;
            border-color: #707070;
        }
        .badge-equipment {
            background: linear-gradient(135deg, rgba(214, 138, 46, 0.3), rgba(184, 116, 31, 0.2));
            color: #FFB74D;
            border-color: #B8741F;
        }
        .badge-infrastructure {
            background: linear-gradient(135deg, rgba(233, 98, 158, 0.3), rgba(200, 70, 130, 0.2));
            color: #F48FB1;
            border-color: #C84682;
        }
        .badge-contingency {
            background: linear-gradient(135deg, rgba(229, 115, 115, 0.3), rgba(198, 80, 80, 0.2));
            color: #EF9A9A;
            border-color: #C65050;
        }

        /* Contributor badge for collaboration */
        .contributor-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 600;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(99, 102, 241, 0.15));
            color: #a5b4fc;
            border: 1px solid rgba(99, 102, 241, 0.4);
            border-radius: 12px;
            margin-left: 6px;
            cursor: help;
        }

        /* Collab comment indicator */
        .collab-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            font-size: 12px;
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.3), rgba(251, 191, 36, 0.15));
            border: 1px solid rgba(251, 191, 36, 0.4);
            border-radius: 50%;
            margin-left: 4px;
            cursor: help;
            animation: collab-pulse 2s ease-in-out infinite;
        }

        @keyframes collab-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.4); }
            50% { box-shadow: 0 0 0 4px rgba(251, 191, 36, 0); }
        }

        .item-cost {
            font-size: 15px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Connection Lines */
        .tree-node::before {
            content: '';
            position: absolute;
            left: -40px;
            top: 50%;
            width: 40px;
            height: 2px;
            background: var(--border);
        }

        .tree-level:first-child .tree-node::before {
            display: none;
        }

        /* Same-phase dependency indentation indicator */
        .tree-node.item.has-same-phase-dependency::after {
            content: '';
            position: absolute;
            left: -20px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, transparent, var(--treeplex-primary) 20%, var(--treeplex-primary) 80%, transparent);
            opacity: 0.3;
            border-radius: 2px;
        }

        /* Enhanced visual for deeper dependency levels */
        .tree-node.item.has-same-phase-dependency[data-dependency-level="2"]::after {
            opacity: 0.4;
            width: 3px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="3"]::after {
            opacity: 0.5;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="4"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="5"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="6"]::after {
            opacity: 0.6;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency {
            border-left: 2px solid rgba(0, 166, 125, 0.2);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            right: -450px;
            top: 130px; /* BUILD 508: Below full header bar (126px height + margin) */
            width: 450px;
            height: calc(100vh - 130px);
            background: var(--card-bg);
            border-left: 1px solid var(--border);
            box-shadow: -4px 0 12px rgba(0,0,0,0.5);
            transition: right 0.3s;
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        .info-panel.open {
            right: 0;
        }

        /* BUILD 515: Redesigned info panel */
        .info-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg) 100%);
        }

        .info-title {
            font-size: 16px;
            font-weight: 600;
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }

        .close-btn {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.4);
            font-size: 18px;
            cursor: pointer;
            color: #ef4444;
            width: 36px;
            height: 36px;
            min-width: 36px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s;
            margin-left: 12px;
        }

        .close-btn:hover {
            background: rgba(239, 68, 68, 0.25);
            border-color: #ef4444;
            transform: scale(1.05);
        }

        /* BUILD 515: Reader nav row */
        .reader-nav-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 16px;
            background: rgba(99, 102, 241, 0.06);
            border-bottom: 1px solid var(--border);
            gap: 12px;
            flex-wrap: wrap;
        }

        .reader-nav-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .reader-nav-options {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .reader-nav-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.15s;
        }

        .reader-nav-btn:hover:not(:disabled) {
            background: var(--treeplex-primary);
            border-color: var(--treeplex-primary);
            color: white;
        }

        .reader-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .reader-position {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 50px;
            text-align: center;
        }

        .reader-mode-btn {
            background: none;
            border: 1px solid transparent;
            font-size: 16px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.15s;
            opacity: 0.6;
        }

        .reader-mode-btn:hover {
            opacity: 1;
            background: var(--bg);
        }

        .reader-mode-btn.active {
            opacity: 1;
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--treeplex-primary);
        }

        /* BUILD 508: Reader Group Selector */
        .reader-group-select {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            min-width: 70px;
        }

        .reader-group-select:focus {
            outline: none;
            border-color: var(--treeplex-primary);
        }

        /* BUILD 515: TTS button styles */
        .reader-tts-btn {
            background: rgba(16, 185, 129, 0.15) !important;
            border-color: rgba(16, 185, 129, 0.4) !important;
            color: #10b981 !important;
        }

        .reader-tts-btn:hover:not(:disabled) {
            background: rgba(16, 185, 129, 0.25) !important;
            border-color: #10b981 !important;
        }

        /* Read mode: hide edit controls */
        .info-panel.read-mode .info-field input,
        .info-panel.read-mode .info-field textarea,
        .info-panel.read-mode .info-field select,
        .info-panel.read-mode .edit-btn,
        .info-panel.read-mode .delete-btn,
        .info-panel.read-mode .pm-field-group input,
        .info-panel.read-mode .pm-field-group select {
            display: none !important;
        }

        .info-panel.read-mode .info-field-value {
            display: block !important;
        }

        /* Current node highlight in tree */
        .tree-node.reader-current {
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.5), var(--shadow-md) !important;
            animation: readerPulse 2s ease-in-out infinite;
        }

        @keyframes readerPulse {
            0%, 100% { box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.5), var(--shadow-md); }
            50% { box-shadow: 0 0 0 5px rgba(99, 102, 241, 0.3), var(--shadow-md); }
        }

        /* BUILD 507: Mobile Reader Navigation - bigger touch targets */
        @media screen and (max-width: 768px), (pointer: coarse) {
            .reader-nav {
                margin-right: 8px;
                padding-right: 8px;
                gap: 4px;
            }

            .reader-nav-btn {
                width: 44px;
                height: 44px;
                font-size: 18px;
                border-radius: 8px;
                background: var(--treeplex-primary);
                border-color: var(--treeplex-primary);
                color: white;
            }

            .reader-nav-btn:disabled {
                background: var(--bg);
                border-color: var(--border);
                color: var(--text-secondary);
                opacity: 0.4;
            }

            .reader-position {
                font-size: 14px;
                font-weight: 600;
                min-width: 60px;
            }

            .reader-mode-btn {
                font-size: 20px;
                padding: 8px 12px;
            }

            /* BUILD 515: Mobile info panel */
            .info-header {
                padding: 12px 16px;
            }

            .info-title {
                font-size: 15px;
            }

            .close-btn {
                width: 40px;
                height: 40px;
                min-width: 40px;
                font-size: 20px;
            }

            .reader-nav-row {
                padding: 8px 12px;
                gap: 8px;
            }

            .reader-nav-controls {
                gap: 6px;
            }

            .reader-nav-options {
                gap: 4px;
            }

            .reader-nav-btn {
                width: 36px;
                height: 36px;
            }

            .reader-group-select {
                min-width: 60px;
                font-size: 10px;
                padding: 6px 4px;
            }
        }

        .info-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .info-section {
            margin-bottom: 24px;
        }

        .info-section h4 {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .info-section p {
            font-size: 14px;
            line-height: 1.6;
        }

        .info-section .value {
            font-size: 20px;
            font-weight: 700;
            color: var(--treeplex-primary);
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 15000; /* BUILD 498: Above header (2000) and chat bubble (10000) */
        }

        .modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            font-size: 18px;
            font-weight: 600;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            line-height: 1.7;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
        }

        /* Modal close button - positioned in header */
        .modal-close {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            z-index: 1;
        }
        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Make modal-header position relative for absolute close button */
        .modal-header {
            position: relative;
        }

        /* BUILD 541: Keyboard Shortcut Reference Panel */
        .shortcut-category {
            margin-bottom: 24px;
        }

        .shortcut-category-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--treeplex-primary);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .shortcut-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .shortcut-key {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            background: rgba(139, 92, 246, 0.15);
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: var(--treeplex-primary);
            font-size: 13px;
            font-weight: 500;
        }

        .shortcut-desc {
            color: var(--text-primary);
            font-size: 14px;
        }

        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--treeplex-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 40px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            display: none;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            padding: 6px;
            min-width: 180px;
            z-index: 1000;
        }

        .context-item {
            padding: 10px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            color: var(--text-primary);
        }

        .context-item:hover {
            background: var(--card-bg-light);
            color: var(--treeplex-primary);
        }

        .context-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
            background: var(--bg);
            color: var(--text-primary);
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--treeplex-primary);
            box-shadow: 0 0 0 3px rgba(0, 166, 125, 0.2);
            background: var(--card-bg-light);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Splash Screen */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1d24 0%, #2a2f3c 50%, #1a1d24 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.5s ease-in;
        }

        #splash-screen.fade-out {
            animation: fadeOut 0.5s ease-out forwards;
        }

        .splash-logo {
            height: 200px;
            width: 200px;
            margin-bottom: 32px;
            animation: logoFloat 2s ease-in-out infinite, logoGlow 3s ease-in-out infinite;
            filter: drop-shadow(0 0 30px rgba(99, 102, 241, 0.5));
        }

        @keyframes logoGlow {
            0%, 100% { filter: drop-shadow(0 0 30px rgba(99, 102, 241, 0.5)); }
            50% { filter: drop-shadow(0 0 50px rgba(139, 92, 246, 0.8)); }
        }

        .splash-title {
            font-size: 48px;
            font-weight: 700;
            color: var(--treeplex-primary);
            margin-bottom: 8px;
            letter-spacing: -1px;
        }

        .splash-subtitle {
            font-size: 20px;
            color: var(--text-secondary);
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 48px;
        }

        .splash-tagline {
            font-size: 16px;
            color: var(--text-primary);
            font-weight: 400;
            margin-bottom: 32px;
            opacity: 0.8;
        }

        .splash-loader {
            width: 200px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .splash-loader-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--phase-1));
            border-radius: 3px;
            animation: loadProgress 2s ease-in-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        @keyframes logoFloat {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes loadProgress {
            0% {
                width: 0%;
            }
            100% {
                width: 100%;
            }
        }

    /* ===================================================== */
    /* CANVAS VIEW STYLES */
    /* ===================================================== */

    .tree-view-container {
        display: block;
    }

    .tree-view-container.hidden {
        display: none !important;
    }

    .canvas-container {
        display: none;
        position: fixed;
        top: 140px;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        overflow: hidden;
        cursor: grab;
    }

    .canvas-container.active {
        display: block;
    }

    .canvas-container.grabbing {
        cursor: grabbing;
    }

    #canvas {
        width: 100%;
        height: 100%;
        position: relative;
        transform-origin: 0 0;
    }

    .canvas-connections {
        position: absolute;
        top: -5000px;
        left: -5000px;
        width: 20000px;
        height: 20000px;
        pointer-events: none;
        z-index: 1;
        overflow: visible;
    }

    /* Allow pointer events on hyperedge groups and their elements */
    .canvas-connections .hyperedge-group {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections polygon,
    .canvas-connections rect,
    .canvas-connections path.hyperedge-capsule {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections text {
        pointer-events: all;
        cursor: pointer;
    }

    /* Disable on connection lines (but not capsule paths) */
    .canvas-connections path:not(.hyperedge-capsule),
    .canvas-connections line {
        pointer-events: none;
    }

    /* BUILD 445: Animated flowing dashes for dependency links */
    .canvas-connections .animated-link {
        animation: flowingDash 1s linear infinite;
    }

    @keyframes flowingDash {
        to {
            stroke-dashoffset: -20;
        }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce) {
        .canvas-connections .animated-link {
            animation: none;
        }
    }

    .canvas-nodes-layer {
        position: relative;
        z-index: 2;
    }

    .canvas-node {
        position: absolute;
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        min-width: 280px;
        max-width: 320px;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, filter 0.15s ease, opacity 0.25s ease;
        z-index: 10;
    }

    /* BUILD 444: Animation classes for expand/collapse */
    .canvas-node.node-entering {
        opacity: 0;
        transform: scale(0.8);
    }

    .canvas-node.node-visible {
        opacity: 1;
        transform: scale(1);
    }

    /* Respect reduced motion preference */
    @media (prefers-reduced-motion: reduce) {
        .canvas-node {
            transition: none;
        }
        .canvas-node.node-entering {
            opacity: 1;
            transform: none;
        }
    }

    .canvas-node:hover {
        transform: translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }

    /* BUILD 447: Dependency creation visual feedback */
    .canvas-node.dep-source {
        box-shadow: 0 0 0 3px #ff6b6b, 0 0 20px rgba(255, 107, 107, 0.4);
        z-index: 100;
    }

    .canvas-node.dep-target {
        box-shadow: 0 0 0 3px #22c55e, 0 0 20px rgba(34, 197, 94, 0.4);
        z-index: 100;
    }

    .canvas-node.dep-invalid {
        box-shadow: 0 0 0 3px #ef4444, 0 0 20px rgba(239, 68, 68, 0.4);
        z-index: 100;
        opacity: 0.6;
    }

    .canvas-node.dragging {
        cursor: grabbing;
        opacity: 0.9;
        z-index: 1000;
        transform: scale(1.05);
    }

    .canvas-node.selected {
        border-color: var(--treeplex-primary) !important;
        box-shadow:
            0 8px 32px rgba(99, 102, 241, 0.4),
            0 4px 16px rgba(99, 102, 241, 0.3),
            0 0 0 3px rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-2px);
    }

    .canvas-node.selected::before {
        content: 'âœ“';
        position: absolute;
        top: -10px;
        right: -10px;
        background: #6366f1;
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .canvas-node.dragging-group {
        opacity: 0.7;
        box-shadow: 0 0 20px rgba(99, 102, 241, 0.8);
    }

    .phase-zone {
        position: absolute;
        border: 3px dashed;
        border-radius: 20px;
        padding: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .phase-zone-header {
        font-weight: 700;
        font-size: 18px;
        margin-bottom: 12px;
        color: var(--text-primary);
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* Colored phase zones - vibrant colors */
    .phase-0 {
        border-color: #3B82F6;
        background: rgba(59, 130, 246, 0.08);
    }
    .phase-1 {
        border-color: #F59E0B;
        background: rgba(245, 158, 11, 0.08);
    }
    .phase-2 {
        border-color: #10B981;
        background: rgba(16, 185, 129, 0.08);
    }
    .phase-3 {
        border-color: #8B5CF6;
        background: rgba(139, 92, 246, 0.08);
    }
    .phase-4 {
        border-color: #EC4899;
        background: rgba(236, 72, 153, 0.08);
    }
    .phase-5 {
        border-color: #06B6D4;
        background: rgba(6, 182, 212, 0.08);
    }

    /* Grid overlay */
    .canvas-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .canvas-grid.active {
        opacity: 1;
    }

    .canvas-toolbar.active {
        display: flex !important;
    }

    .canvas-toolbar button:hover {
        background: rgba(99, 102, 241, 0.3) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .canvas-toolbar button:active {
        transform: translateY(0);
    }

    .canvas-toolbar select:hover {
        background: rgba(99, 102, 241, 0.25) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
    }

    .canvas-toolbar select option {
        background: #1a1a2e;
        color: #ffffff;
        padding: 10px;
        font-weight: 600;
    }

    .canvas-toolbar select option:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    /* ============================================================================
       AI SETTINGS MODAL - STYLING
       ============================================================================ */

    /* AI Settings Modal - Radio Button Styling */
    .ai-radio-option {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        padding: 12px;
        background: rgba(255,255,255,0.03);
        border: 2px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .ai-radio-option:hover {
        background: rgba(255,255,255,0.06);
        border-color: rgba(99, 102, 241, 0.4);
    }

    .ai-radio-option input[type="radio"] {
        margin-top: 2px;
        cursor: pointer;
    }

    .ai-radio-option input[type="radio"]:checked + .radio-label {
        color: #6366f1;
    }

    .ai-radio-option:has(input[type="radio"]:checked) {
        background: rgba(99, 102, 241, 0.1);
        border-color: #6366f1;
    }

    .radio-label {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .radio-label strong {
        font-size: 13px;
        color: rgba(255,255,255,0.9);
    }

    .radio-label small {
        font-size: 11px;
        color: rgba(255,255,255,0.5);
    }

    /* Creativity Slider */
    #creativity-slider {
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        background: rgba(255,255,255,0.1);
        border-radius: 3px;
        outline: none;
    }

    #creativity-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        background: #6366f1;
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(99, 102, 241, 0.4);
    }

    #creativity-slider::-moz-range-thumb {
        width: 18px;
        height: 18px;
        background: #6366f1;
        border-radius: 50%;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 6px rgba(99, 102, 241, 0.4);
    }

    /* ============================================================================
       UI MODERNIZATION - BUILD 148
       ============================================================================ */

    /* ============================================================================
       DROPDOWN MENU COMPONENT - BUILD 331
       Accessible dropdown menus for toolbar consolidation
       ============================================================================ */
    .dropdown-menu {
        position: relative;
        display: inline-block;
    }

    .dropdown-menu-trigger {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 6px 12px;
        font-size: 13px;
        font-weight: 600;
        color: white;
        background: linear-gradient(135deg, #6366f1, #8b5cf6);
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .dropdown-menu-trigger:hover {
        filter: brightness(1.1);
        transform: translateY(-1px);
    }

    .dropdown-menu-trigger::after {
        content: 'â–¾';
        font-size: 10px;
        margin-left: 2px;
        transition: transform 0.2s ease;
    }

    .dropdown-menu-trigger[aria-expanded="true"]::after {
        transform: rotate(180deg);
    }

    .dropdown-menu-content {
        position: absolute;
        top: calc(100% + 4px);
        left: 0;
        min-width: 200px;
        background: var(--card-bg);
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-8px);
        transition: all 0.2s ease;
    }

    .dropdown-menu-content.open {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
    }

    .dropdown-menu-item {
        display: flex;
        align-items: center;
        gap: 10px;
        width: 100%;
        padding: 10px 14px;
        font-size: 13px;
        color: var(--text-primary);
        background: none;
        border: none;
        cursor: pointer;
        transition: background 0.15s ease;
        text-align: left;
    }

    .dropdown-menu-item:first-child {
        border-radius: 7px 7px 0 0;
    }

    .dropdown-menu-item:last-child {
        border-radius: 0 0 7px 7px;
    }

    .dropdown-menu-item:only-child {
        border-radius: 7px;
    }

    .dropdown-menu-item:hover {
        background: rgba(99, 102, 241, 0.15);
        color: var(--treeplex-primary);
    }

    .dropdown-menu-item:focus {
        outline: none;
        background: rgba(99, 102, 241, 0.2);
        color: var(--treeplex-primary);
    }

    .dropdown-menu-item .item-icon {
        font-size: 16px;
        width: 20px;
        text-align: center;
    }

    .dropdown-menu-item .item-label {
        flex: 1;
    }

    .dropdown-menu-item .item-shortcut {
        font-size: 11px;
        color: var(--text-secondary);
        opacity: 0.7;
    }

    .dropdown-menu-divider {
        height: 1px;
        background: var(--border);
        margin: 4px 0;
    }

    .dropdown-menu-header {
        padding: 8px 14px 4px;
        font-size: 11px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    /* Dropdown variants */
    .dropdown-menu-trigger.btn-green {
        background: linear-gradient(135deg, #059669, #10b981);
    }

    .dropdown-menu-trigger.btn-blue {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
    }

    /* AI TOOLS SIDEBAR - Collapsible Left-Docked */
    #ai-tools-panel {
        position: fixed !important;
        top: 70px !important;
        left: 0 !important;
        bottom: 0 !important;
        width: 60px !important;
        min-width: 60px !important;
        background: #1E2128 !important;
        border-right: 1px solid var(--border) !important;
        border-top: none !important;
        border-bottom: none !important;
        border-left: none !important;
        border-radius: 0 !important;
        padding: 16px 8px !important;
        transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
        overflow: hidden !important;
        z-index: 900 !important;
        display: flex !important;
        flex-direction: column !important;
        gap: 12px !important;
        box-shadow: 4px 0 24px rgba(0,0,0,0.2) !important;
    }

    /* Expand on Hover */
    #ai-tools-panel:hover {
        width: 260px !important;
        background: var(--card-bg) !important;
    }

    /* BUILD 340: HIDE SIDEBAR ON MOBILE - Must come AFTER desktop rules */
    @media screen and (max-width: 768px), (max-device-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #ai-tools-panel {
            display: none !important;
            visibility: hidden !important;
            width: 0 !important;
            height: 0 !important;
            position: absolute !important;
            left: -9999px !important;
            pointer-events: none !important;
        }
    }

    /* Sidebar Buttons */
    #ai-tools-panel .btn {
        justify-content: flex-start !important;
        padding: 10px 12px !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        width: 100% !important;
        background: transparent !important;
        border: 1px solid transparent !important;
        color: var(--text-secondary) !important;
        transition: all 0.2s !important;
    }

    /* Button Icons (Always Visible) */
    #ai-tools-panel .btn::before {
        content: attr(data-icon);
        font-size: 20px;
        min-width: 24px;
        margin-right: 16px;
        text-align: center;
    }

    /* Button Hover State */
    #ai-tools-panel .btn:hover {
        background: rgba(255, 255, 255, 0.05) !important;
        color: var(--text-primary) !important;
        border-color: rgba(255, 255, 255, 0.1) !important;
    }

    /* Active/Primary Button Override */
    #ai-tools-panel .btn.btn-primary {
        background: linear-gradient(135deg, #6366f1, #8b5cf6) !important;
        color: white !important;
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    /* Hide text when collapsed */
    #ai-tools-panel:not(:hover) .btn span {
        opacity: 0;
    }

    #ai-tools-panel .btn span {
        transition: opacity 0.2s;
        opacity: 1;
    }

    /* TYPOGRAPHY IMPROVEMENTS - Better Hierarchy */
    /* Primary Title - Bigger & Bolder */
    .node-title, .item-name {
        font-size: 17px !important;
        font-weight: 700 !important;
        color: #F3F4F6 !important;
        letter-spacing: -0.01em;
        margin-bottom: 6px !important;
        line-height: 1.3;
    }

    /* Subtitle/Description - Receded */
    .node-subtitle, .item-description {
        font-size: 13px !important;
        color: #9CA3AF !important;
        font-weight: 400;
        line-height: 1.5;
    }

    /* Tags/Badges - More refined */
    .badge {
        font-size: 10px !important;
        padding: 3px 8px !important;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-radius: 4px !important;
        font-weight: 700 !important;
    }

    /* Node Cards - Better Depth */
    .tree-node {
        box-shadow:
            0 1px 0 rgba(255,255,255,0.1) inset,
            0 4px 12px rgba(0,0,0,0.4);
    }

    /* ZOOM CONTROLS IN SIDEBAR */
    /* Hide old standalone zoom controls if they exist */
    .zoom-controls {
        display: none !important;
    }

    /* Sidebar zoom controls container */
    .sidebar-zoom-controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 100%;
        padding: 8px 0;
        border-top: 1px solid rgba(255,255,255,0.1);
    }

    /* Zoom level display in sidebar */
    .zoom-level-sidebar {
        text-align: center;
        font-size: 11px;
        color: var(--text-secondary);
        padding: 4px;
        background: rgba(255,255,255,0.03);
        border-radius: 4px;
        font-weight: 600;
    }

    /* Ensure zoom buttons follow sidebar button styling */
    .sidebar-zoom-controls .btn {
        padding: 8px 12px !important;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CHAT ASSISTANT BUBBLE STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Floating bubble button */
    #chat-assistant-bubble {
        position: fixed;
        bottom: 24px;
        right: 24px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #8b5cf6, #6366f1);
        border: none;
        cursor: pointer;
        box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #chat-assistant-bubble:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 28px rgba(99, 102, 241, 0.5);
    }

    #chat-assistant-bubble.active {
        transform: rotate(45deg);
    }

    /* Chat panel - Draggable Floating Frame (TreeBeard) */
    #chat-assistant-panel {
        position: fixed;
        bottom: 96px;
        right: 24px;
        width: 440px;
        min-width: 340px;
        max-width: calc(100vw - 48px);
        height: 520px;
        min-height: 320px;
        max-height: calc(100vh - 100px);
        background: linear-gradient(180deg, rgba(30, 30, 46, 0.98), rgba(24, 24, 38, 0.99));
        border: 2px solid rgba(139, 92, 246, 0.3);
        border-radius: 16px;
        /* Multi-layer shadow for strong floating effect */
        box-shadow:
            0 0 0 1px rgba(139, 92, 246, 0.15),
            0 4px 8px rgba(0, 0, 0, 0.3),
            0 12px 24px rgba(0, 0, 0, 0.4),
            0 24px 48px rgba(0, 0, 0, 0.5),
            0 0 60px rgba(139, 92, 246, 0.08);
        z-index: 9999;
        display: none;
        flex-direction: column;
        overflow: hidden;
        resize: both;
        overflow: auto;
        backdrop-filter: blur(8px);
    }

    #chat-assistant-panel.open {
        display: flex;
        animation: chatSlideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #chat-assistant-panel.dragging {
        opacity: 0.95;
        border-color: rgba(139, 92, 246, 0.5);
        box-shadow:
            0 0 0 2px rgba(139, 92, 246, 0.3),
            0 8px 16px rgba(0, 0, 0, 0.4),
            0 24px 48px rgba(0, 0, 0, 0.5),
            0 32px 64px rgba(0, 0, 0, 0.6),
            0 0 80px rgba(139, 92, 246, 0.15);
        transition: none;
    }

    @keyframes chatSlideUp {
        from {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    /* Chat header - Drag Handle */
    #chat-assistant-header {
        padding: 8px 12px;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.12), rgba(99, 102, 241, 0.12));
        border-bottom: 1px solid var(--border, #3f3f5a);
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: grab;
        user-select: none;
        flex-shrink: 0;
    }

    #chat-assistant-header:active {
        cursor: grabbing;
    }

    #chat-assistant-header h3 {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary, #fff);
        display: flex;
        align-items: center;
        gap: 8px;
        pointer-events: none;
    }

    #chat-assistant-header .header-actions {
        display: flex;
        gap: 4px;
    }

    #chat-assistant-header button {
        background: transparent;
        border: none;
        color: var(--text-secondary, #a0a0a0);
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 14px;
        transition: all 0.2s;
    }

    #chat-assistant-header button:hover {
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-primary, #fff);
    }

    /* Resize handle styling */
    #chat-assistant-panel::-webkit-resizer {
        background: linear-gradient(135deg, transparent 50%, rgba(139, 92, 246, 0.3) 50%);
        border-radius: 0 0 12px 0;
    }

    /* Chat messages area */
    #chat-assistant-messages {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .chat-message {
        max-width: 88%;
        padding: 8px 12px;
        border-radius: 10px;
        font-size: 13px;
        line-height: 1.45;
        word-wrap: break-word;
    }

    .chat-message.user {
        align-self: flex-end;
        background: linear-gradient(135deg, #8b5cf6, #6366f1);
        color: white;
        border-bottom-right-radius: 4px;
    }

    .chat-message.assistant {
        align-self: flex-start;
        background: var(--item-bg, #2a2a3e);
        color: var(--text-primary, #fff);
        border-bottom-left-radius: 4px;
    }

    .chat-message.assistant .action-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 10px;
    }

    .chat-message.assistant .action-btn {
        padding: 6px 12px;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.4);
        border-radius: 6px;
        color: var(--text-primary, #fff);
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .chat-message.assistant .action-btn:hover {
        background: rgba(99, 102, 241, 0.4);
        border-color: rgba(99, 102, 241, 0.6);
    }

    /* BUILD 564: Chat action links */
    .chat-action-link {
        color: var(--treeplex-primary, #8b5cf6);
        text-decoration: none;
        padding: 4px 10px;
        background: rgba(139, 92, 246, 0.15);
        border-radius: 6px;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
        display: inline-block;
        margin-top: 8px;
    }

    .chat-action-link:hover {
        background: rgba(139, 92, 246, 0.3);
        text-decoration: none;
    }

    .chat-message.system {
        align-self: center;
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
        font-size: 12px;
        padding: 6px 12px;
        border-radius: 20px;
    }

    .chat-message.error {
        align-self: center;
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
        font-size: 12px;
        padding: 6px 12px;
        border-radius: 20px;
    }

    /* BUILD 543: Streaming message styles */
    .chat-message.streaming {
        border-left: 2px solid var(--treeplex-primary, #8b5cf6);
    }

    .streaming-indicator {
        color: var(--text-muted, #9ca3af);
        font-style: italic;
    }

    .streaming-cursor {
        display: inline-block;
        color: var(--treeplex-primary, #8b5cf6);
        animation: blink-cursor 0.8s infinite;
        margin-left: 2px;
    }

    @keyframes blink-cursor {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }

    .chat-typing {
        display: flex;
        gap: 4px;
        padding: 12px 16px;
        align-self: flex-start;
    }

    .chat-typing span {
        width: 8px;
        height: 8px;
        background: var(--text-secondary, #a0a0a0);
        border-radius: 50%;
        animation: typingBounce 1.4s ease-in-out infinite;
    }

    .chat-typing span:nth-child(2) { animation-delay: 0.2s; }
    .chat-typing span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typingBounce {
        0%, 60%, 100% { transform: translateY(0); }
        30% { transform: translateY(-6px); }
    }

    /* Chat input area */
    #chat-assistant-input-area {
        padding: 12px 16px;
        border-top: 1px solid var(--border, #3f3f5a);
        display: flex;
        gap: 8px;
        align-items: flex-end;
    }

    #chat-assistant-input {
        flex: 1;
        background: var(--item-bg, #2a2a3e);
        border: 1px solid var(--border, #3f3f5a);
        border-radius: 12px;
        padding: 10px 14px;
        color: var(--text-primary, #fff);
        font-size: 14px;
        resize: none;
        min-height: 20px;
        max-height: 100px;
        font-family: inherit;
    }

    #chat-assistant-input:focus {
        outline: none;
        border-color: #8b5cf6;
    }

    #chat-assistant-input::placeholder {
        color: var(--text-secondary, #a0a0a0);
    }

    #chat-voice-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: var(--item-bg, #2a2a3e);
        border: 1px solid var(--border, #3f3f5a);
        color: var(--text-secondary, #a0a0a0);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        transition: all 0.2s;
    }

    #chat-voice-btn:hover {
        border-color: #8b5cf6;
        color: #8b5cf6;
    }

    #chat-voice-btn.recording {
        background: rgba(239, 68, 68, 0.2);
        border-color: #ef4444;
        color: #ef4444;
        animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }

    #chat-send-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(135deg, #8b5cf6, #6366f1);
        border: none;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        transition: all 0.2s;
    }

    #chat-send-btn:hover {
        transform: scale(1.05);
    }

    #chat-send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }

    /* Quick actions bar */
    #chat-quick-actions {
        padding: 8px 16px;
        border-top: 1px solid var(--border, #3f3f5a);
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
    }

    .quick-action-chip {
        padding: 4px 10px;
        background: rgba(99, 102, 241, 0.15);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 12px;
        color: var(--text-secondary, #a0a0a0);
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .quick-action-chip:hover {
        background: rgba(99, 102, 241, 0.3);
        color: var(--text-primary, #fff);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUILD 393: FLOATING COMMAND FRAME (New Chat UI)
       - Spotlight-style floating frame at top-center
       - Always-visible action buttons
       - Collapsible history
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    #command-frame {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        width: 560px;
        max-width: calc(100vw - 48px);
        background: linear-gradient(180deg, rgba(30, 30, 46, 0.98), rgba(24, 24, 38, 0.99));
        border: 2px solid rgba(139, 92, 246, 0.35);
        border-radius: 16px;
        box-shadow:
            0 0 0 1px rgba(139, 92, 246, 0.15),
            0 8px 32px rgba(0, 0, 0, 0.5),
            0 0 60px rgba(139, 92, 246, 0.1);
        z-index: 9999;
        display: none;
        flex-direction: column;
        overflow: hidden;
        backdrop-filter: blur(12px);
    }

    #command-frame.open {
        display: flex;
        animation: frameSlideDown 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #command-frame.minimized {
        width: 220px;
        top: 16px;
    }

    #command-frame.minimized .command-context-bar,
    #command-frame.minimized .command-actions,
    #command-frame.minimized .command-input-area,
    #command-frame.minimized .command-history {
        display: none;
    }

    @keyframes frameSlideDown {
        from {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    }

    /* BUILD 395: Visual Feedback Animations */
    @keyframes vfPulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }

    @keyframes vfBadgeFloat {
        from {
            opacity: 0;
            transform: translateX(-50%) translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    }

    @keyframes vfLineDash {
        to { stroke-dashoffset: -12; }
    }

    .vf-pulse {
        animation: vfPulse 1s ease-in-out infinite;
    }

    .vf-overlay {
        transition: opacity 0.3s ease-out;
    }

    .vf-badge, .vf-canvas-badge {
        animation: vfBadgeFloat 0.3s ease-out;
    }

    /* Command Frame Header */
    .command-frame-header {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 14px;
        background: rgba(139, 92, 246, 0.08);
        border-bottom: 1px solid rgba(139, 92, 246, 0.2);
        cursor: grab;
        user-select: none;
    }

    .command-frame-header:active { cursor: grabbing; }

    .frame-icon { font-size: 16px; }
    .frame-title {
        font-size: 14px;
        font-weight: 600;
        color: #a5b4fc;
        flex: 1;
    }

    /* Mode Pills */
    .mode-pills {
        display: flex;
        gap: 4px;
        background: rgba(0, 0, 0, 0.25);
        padding: 3px;
        border-radius: 10px;
    }

    .mode-pill {
        padding: 5px 10px;
        border: none;
        border-radius: 8px;
        background: transparent;
        color: #9ca3af;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .mode-pill:hover { color: #e5e7eb; }

    .mode-pill.active {
        background: rgba(139, 92, 246, 0.4);
        color: white;
    }

    .frame-minimize, .frame-close {
        width: 28px;
        height: 28px;
        border: none;
        border-radius: 6px;
        background: transparent;
        color: #9ca3af;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .frame-minimize:hover, .frame-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: white;
    }

    /* Context Bar */
    .command-context-bar {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 14px;
        background: rgba(16, 185, 129, 0.1);
        border-bottom: 1px solid rgba(16, 185, 129, 0.2);
        font-size: 12px;
        color: #10b981;
    }

    .command-context-bar.no-focus {
        background: rgba(107, 114, 128, 0.1);
        border-color: rgba(107, 114, 128, 0.2);
        color: #9ca3af;
    }

    .context-icon { font-size: 14px; }

    .context-text {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .context-action {
        padding: 4px 8px;
        border: none;
        border-radius: 4px;
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
    }

    .context-action:hover { background: rgba(16, 185, 129, 0.3); }

    /* Action Buttons Grid */
    .command-actions {
        padding: 10px 14px;
        border-bottom: 1px solid rgba(139, 92, 246, 0.15);
    }

    .action-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .action-row.secondary-actions {
        margin-top: 8px;
    }

    .action-row.secondary-actions.collapsed {
        display: none;
    }

    .cmd-btn {
        padding: 8px 14px;
        background: rgba(99, 102, 241, 0.15);
        border: 1px solid rgba(99, 102, 241, 0.25);
        border-radius: 10px;
        color: #e5e7eb;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .cmd-btn:hover {
        background: rgba(99, 102, 241, 0.3);
        border-color: rgba(99, 102, 241, 0.4);
        transform: translateY(-1px);
    }

    .cmd-btn:active { transform: translateY(0); }

    .cmd-btn .btn-icon { font-size: 14px; }
    .cmd-btn .btn-label { font-weight: 500; }

    .cmd-btn.highlight {
        background: rgba(16, 185, 129, 0.2);
        border-color: rgba(16, 185, 129, 0.3);
        color: #34d399;
    }

    /* Input Area */
    .command-input-area {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 14px;
    }

    #command-input {
        flex: 1;
        padding: 11px 16px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(139, 92, 246, 0.25);
        border-radius: 12px;
        color: white;
        font-size: 14px;
        outline: none;
        transition: all 0.2s;
    }

    #command-input:focus {
        border-color: rgba(139, 92, 246, 0.5);
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    #command-input::placeholder { color: #6b7280; }

    .command-btn {
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 10px;
        background: rgba(139, 92, 246, 0.2);
        color: #a5b4fc;
        cursor: pointer;
        font-size: 18px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .command-btn:hover {
        background: rgba(139, 92, 246, 0.35);
        color: white;
    }

    .command-btn.primary {
        background: linear-gradient(135deg, #8b5cf6, #6366f1);
        color: white;
    }

    .command-btn.primary:hover {
        transform: scale(1.05);
    }

    /* Collapsible History */
    .command-history {
        border-top: 1px solid rgba(139, 92, 246, 0.15);
    }

    .history-toggle {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 14px;
        cursor: pointer;
        font-size: 12px;
        color: #9ca3af;
        transition: background 0.2s;
    }

    .history-toggle:hover { background: rgba(139, 92, 246, 0.05); }

    .command-history.collapsed .history-messages { display: none; }
    .command-history.collapsed .toggle-icon { transform: rotate(0deg); }
    .command-history:not(.collapsed) .toggle-icon { transform: rotate(180deg); }

    .toggle-icon { transition: transform 0.2s; }

    .history-messages {
        max-height: 180px;
        overflow-y: auto;
        padding: 0 14px 14px;
    }

    .history-msg {
        padding: 8px 12px;
        margin-bottom: 8px;
        border-radius: 10px;
        font-size: 13px;
        line-height: 1.45;
    }

    .history-msg.user {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.4), rgba(99, 102, 241, 0.4));
        color: white;
        margin-left: 25%;
        border-bottom-right-radius: 4px;
    }

    .history-msg.assistant {
        background: rgba(45, 45, 65, 0.8);
        color: #e5e7eb;
        margin-right: 25%;
        border-bottom-left-radius: 4px;
    }

    /* Visual Feedback Overlay */
    .feedback-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9998;
    }

    /* Mobile: Full-screen command frame */
    @media screen and (max-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #command-frame.open {
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            max-width: 100vw;
            height: 100vh;
            transform: none;
            border-radius: 0;
            animation: none;
        }

        .command-frame-header {
            padding-top: max(12px, env(safe-area-inset-top));
        }

        .command-input-area {
            padding-bottom: max(12px, env(safe-area-inset-bottom));
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUILD 405: LIVE TREE AGENT (Chat Builder Redesign)
       - Floating frame for watching tree build in real-time
       - Top-left position, draggable
       - Full chat history with choices
       - Visual node highlighting integration
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    #tree-agent-frame {
        position: fixed;
        top: 80px;
        left: 20px;
        width: 380px;
        max-height: 600px;
        background: linear-gradient(180deg, rgba(30, 30, 46, 0.97), rgba(24, 24, 38, 0.98));
        border: 2px solid rgba(16, 185, 129, 0.35);
        border-radius: 16px;
        box-shadow:
            0 0 0 1px rgba(16, 185, 129, 0.15),
            0 8px 32px rgba(0, 0, 0, 0.5),
            0 0 60px rgba(16, 185, 129, 0.08);
        z-index: 9999;
        display: none;
        flex-direction: column;
        overflow: hidden;
        backdrop-filter: blur(12px);
    }

    #tree-agent-frame.open {
        display: flex;
        animation: agentSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #tree-agent-frame.minimized .agent-body {
        display: none;
    }

    #tree-agent-frame.minimized {
        max-height: 56px;
    }

    @keyframes agentSlideIn {
        from {
            opacity: 0;
            transform: translateX(-20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
    }

    /* Agent Header */
    .agent-header {
        display: flex;
        flex-direction: column;
        padding: 12px 14px;
        background: rgba(16, 185, 129, 0.1);
        border-bottom: 1px solid rgba(16, 185, 129, 0.2);
        cursor: grab;
        user-select: none;
    }

    .agent-header:active { cursor: grabbing; }

    .agent-title-row {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .agent-icon {
        font-size: 18px;
        animation: agentPulse 2s ease-in-out infinite;
    }

    @keyframes agentPulse {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.8; transform: scale(1.05); }
    }

    .agent-title {
        flex: 1;
        font-size: 14px;
        font-weight: 600;
        color: #34d399;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .agent-progress-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 8px;
    }

    .agent-progress-bar {
        flex: 1;
        height: 6px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 3px;
        overflow: hidden;
    }

    .agent-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #10b981, #34d399);
        border-radius: 3px;
        transition: width 0.4s ease-out;
    }

    .agent-progress-text {
        font-size: 12px;
        color: #9ca3af;
        min-width: 36px;
        text-align: right;
    }

    .agent-header-actions {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 4px;
    }

    .agent-btn {
        width: 28px;
        height: 28px;
        border: none;
        border-radius: 6px;
        background: transparent;
        color: #9ca3af;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .agent-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: white;
    }

    /* Agent Body */
    .agent-body {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
    }

    /* Messages Area */
    .agent-messages {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        max-height: 350px;
        min-height: 150px;
    }

    .agent-message {
        padding: 10px 12px;
        margin-bottom: 10px;
        border-radius: 12px;
        font-size: 13px;
        line-height: 1.5;
        animation: msgFadeIn 0.3s ease-out;
    }

    @keyframes msgFadeIn {
        from { opacity: 0; transform: translateY(8px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .agent-message.user {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.4), rgba(139, 92, 246, 0.4));
        color: white;
        margin-left: 20%;
        border-bottom-right-radius: 4px;
    }

    .agent-message.assistant {
        background: rgba(45, 45, 65, 0.8);
        color: #e5e7eb;
        margin-right: 10%;
        border-bottom-left-radius: 4px;
    }

    .agent-message.system {
        background: rgba(16, 185, 129, 0.15);
        border: 1px solid rgba(16, 185, 129, 0.25);
        color: #34d399;
        font-size: 12px;
        text-align: center;
    }

    /* Choices Container */
    .agent-choices {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 0 12px 12px;
    }

    .agent-choice-btn {
        padding: 8px 14px;
        background: rgba(16, 185, 129, 0.15);
        border: 1px solid rgba(16, 185, 129, 0.3);
        border-radius: 20px;
        color: #34d399;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .agent-choice-btn:hover {
        background: rgba(16, 185, 129, 0.3);
        border-color: rgba(16, 185, 129, 0.5);
        transform: translateY(-1px);
    }

    .agent-choice-btn:active {
        transform: translateY(0);
    }

    /* Input Row */
    .agent-input-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        border-top: 1px solid rgba(16, 185, 129, 0.15);
        background: rgba(0, 0, 0, 0.15);
    }

    #agent-input {
        flex: 1;
        padding: 10px 14px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(16, 185, 129, 0.25);
        border-radius: 10px;
        color: white;
        font-size: 13px;
        outline: none;
        transition: all 0.2s;
    }

    #agent-input:focus {
        border-color: rgba(16, 185, 129, 0.5);
        box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
    }

    #agent-input::placeholder { color: #6b7280; }

    .agent-input-btn {
        width: 36px;
        height: 36px;
        border: none;
        border-radius: 8px;
        background: rgba(16, 185, 129, 0.2);
        color: #34d399;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .agent-input-btn:hover {
        background: rgba(16, 185, 129, 0.35);
        color: white;
    }

    .agent-input-btn.primary {
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
    }

    .agent-input-btn.primary:hover {
        transform: scale(1.05);
    }

    /* Footer Actions */
    .agent-footer {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 12px;
        border-top: 1px solid rgba(16, 185, 129, 0.15);
        background: rgba(16, 185, 129, 0.05);
    }

    .agent-action-btn {
        flex: 1;
        padding: 10px 16px;
        border: 1px solid rgba(107, 114, 128, 0.3);
        border-radius: 8px;
        background: transparent;
        color: #9ca3af;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
    }

    .agent-action-btn:hover {
        background: rgba(107, 114, 128, 0.15);
        color: #e5e7eb;
    }

    .agent-action-btn.primary {
        background: linear-gradient(135deg, #10b981, #059669);
        border-color: transparent;
        color: white;
    }

    .agent-action-btn.primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    /* Node Highlight Animations (for tree view integration) */
    .node-new-highlight {
        animation: nodeNewPulse 2s ease-out;
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.6);
    }

    .node-modified-highlight {
        animation: nodeModifiedPulse 2s ease-out;
        box-shadow: 0 0 20px rgba(234, 179, 8, 0.6);
    }

    @keyframes nodeNewPulse {
        0% {
            box-shadow: 0 0 0 rgba(16, 185, 129, 0.8);
            background-color: rgba(16, 185, 129, 0.3);
        }
        50% {
            box-shadow: 0 0 25px rgba(16, 185, 129, 0.6);
        }
        100% {
            box-shadow: 0 0 0 rgba(16, 185, 129, 0);
            background-color: transparent;
        }
    }

    @keyframes nodeModifiedPulse {
        0% {
            box-shadow: 0 0 0 rgba(234, 179, 8, 0.8);
            background-color: rgba(234, 179, 8, 0.2);
        }
        50% {
            box-shadow: 0 0 25px rgba(234, 179, 8, 0.6);
        }
        100% {
            box-shadow: 0 0 0 rgba(234, 179, 8, 0);
            background-color: transparent;
        }
    }

    /* BUILD 591: Moved node highlight - blue pulse */
    .node-moved-highlight {
        animation: nodeMovedPulse 2.5s ease-out;
        box-shadow: 0 0 25px rgba(59, 130, 246, 0.7);
    }

    @keyframes nodeMovedPulse {
        0% {
            box-shadow: 0 0 0 rgba(59, 130, 246, 0.9);
            background-color: rgba(59, 130, 246, 0.3);
            transform: scale(1.02);
        }
        30% {
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.7);
            transform: scale(1);
        }
        100% {
            box-shadow: 0 0 0 rgba(59, 130, 246, 0);
            background-color: transparent;
        }
    }

    /* BUILD 591: Deleted node fade-out */
    .node-deleted-highlight {
        animation: nodeDeletedFade 0.5s ease-out forwards;
    }

    @keyframes nodeDeletedFade {
        0% {
            opacity: 1;
            background-color: rgba(239, 68, 68, 0.3);
        }
        100% {
            opacity: 0;
            transform: translateX(-20px);
            height: 0;
            margin: 0;
            padding: 0;
        }
    }

    /* Mobile Responsive */
    @media screen and (max-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #tree-agent-frame.open {
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            max-width: 100vw;
            height: 100vh;
            max-height: 100vh;
            border-radius: 0;
            animation: none;
        }

        .agent-header {
            padding-top: max(12px, env(safe-area-inset-top));
        }

        .agent-footer {
            padding-bottom: max(10px, env(safe-area-inset-bottom));
        }

        .agent-messages {
            max-height: none;
            flex: 1;
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUILD 427: DEBATE MODE
       - AI vs AI spectator debates
       - Floating debate panel with transcript
       - Insight extraction to tree
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    #debate-panel {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 420px;
        max-height: 500px;
        background: linear-gradient(180deg, rgba(30, 30, 46, 0.97), rgba(24, 24, 38, 0.98));
        border: 2px solid rgba(139, 92, 246, 0.35);
        border-radius: 16px;
        box-shadow:
            0 0 0 1px rgba(139, 92, 246, 0.15),
            0 8px 32px rgba(0, 0, 0, 0.5),
            0 0 60px rgba(139, 92, 246, 0.08);
        z-index: 9999;
        display: none;
        flex-direction: column;
        overflow: hidden;
        backdrop-filter: blur(12px);
    }

    #debate-panel.open {
        display: flex;
        animation: debateSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #debate-panel.minimized .debate-body {
        display: none;
    }

    #debate-panel.minimized {
        max-height: 56px;
    }

    @keyframes debateSlideIn {
        from {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    .debate-header {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(99, 102, 241, 0.1));
        border-bottom: 1px solid rgba(139, 92, 246, 0.2);
        gap: 12px;
        cursor: grab;
        user-select: none;
    }

    .debate-header:active { cursor: grabbing; }

    .debate-title-row {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .debate-icon { font-size: 20px; }

    .debate-title {
        font-weight: 600;
        font-size: 14px;
        color: #a78bfa;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .debate-turn-info {
        font-size: 12px;
        color: var(--text-secondary);
        background: rgba(139, 92, 246, 0.2);
        padding: 4px 10px;
        border-radius: 12px;
    }

    .debate-header-actions {
        display: flex;
        gap: 4px;
    }

    .debate-btn {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        width: 28px;
        height: 28px;
        border-radius: 6px;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .debate-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
    }

    .debate-body {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .debate-transcript {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        max-height: 300px;
        scroll-behavior: smooth;
    }

    .debate-turn {
        padding: 12px;
        border-radius: 8px;
        background: rgba(30, 30, 40, 0.5);
        border-left: 3px solid var(--turn-color, #6366f1);
    }

    .debate-turn.persona-a { --turn-color: #8b5cf6; }
    .debate-turn.persona-b { --turn-color: #f59e0b; }
    .debate-turn.user { --turn-color: #10b981; }

    .debate-turn-header {
        font-size: 12px;
        font-weight: 600;
        color: var(--turn-color);
        margin-bottom: 6px;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .debate-turn-text {
        font-size: 14px;
        line-height: 1.5;
        color: var(--text-primary);
    }

    .debate-turn.loading .debate-turn-text {
        color: var(--text-secondary);
        font-style: italic;
    }

    .debate-input-row {
        display: flex;
        gap: 8px;
        padding: 12px 16px;
        border-top: 1px solid var(--border-color);
    }

    #debate-interject-input {
        flex: 1;
        background: rgba(30, 30, 40, 0.5);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 8px 12px;
        color: var(--text-primary);
        font-size: 13px;
    }

    #debate-interject-input:focus {
        outline: none;
        border-color: rgba(139, 92, 246, 0.5);
    }

    .debate-input-btn {
        background: rgba(139, 92, 246, 0.2);
        border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        color: var(--text-primary);
    }

    .debate-input-btn:hover {
        background: rgba(139, 92, 246, 0.3);
    }

    .debate-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        border-top: 1px solid var(--border-color);
        background: rgba(20, 20, 30, 0.3);
    }

    .debate-footer-left {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .debate-autoplay-toggle {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        color: var(--text-secondary);
        cursor: pointer;
    }

    .debate-autoplay-toggle input {
        cursor: pointer;
    }

    .debate-action-btn {
        padding: 8px 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: rgba(30, 30, 40, 0.5);
        color: var(--text-primary);
        cursor: pointer;
        font-size: 13px;
        transition: all 0.15s ease;
    }

    .debate-action-btn.primary {
        background: linear-gradient(135deg, #6366f1, #8b5cf6);
        border: none;
    }

    .debate-action-btn:hover {
        filter: brightness(1.1);
    }

    .debate-action-btn:disabled,
    .debate-input-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        pointer-events: none;
    }

    /* Debate Setup Modal */
    .debate-setup-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    }

    .debate-setup-modal.open {
        display: flex;
    }

    .debate-setup-content {
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        padding: 24px;
        width: 420px;
        max-width: 90vw;
    }

    .debate-setup-content h3 {
        margin: 0 0 16px 0;
        font-size: 18px;
        color: var(--text-primary);
    }

    .debate-topic-display {
        background: rgba(139, 92, 246, 0.1);
        border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 20px;
        font-size: 14px;
        color: var(--text-primary);
    }

    .debate-persona-row {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 20px;
    }

    .debate-persona-select {
        flex: 1;
    }

    .debate-persona-select label {
        display: block;
        font-size: 12px;
        color: var(--text-secondary);
        margin-bottom: 6px;
    }

    .debate-persona-select select {
        width: 100%;
        padding: 10px;
        background: rgba(30, 30, 40, 0.5);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        color: var(--text-primary);
        font-size: 14px;
    }

    .debate-vs {
        font-weight: 700;
        color: var(--text-secondary);
    }

    .debate-rounds-row {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 20px;
    }

    .debate-rounds-row label {
        font-size: 12px;
        color: var(--text-secondary);
    }

    .debate-rounds-row select {
        padding: 8px 12px;
        background: rgba(30, 30, 40, 0.5);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        color: var(--text-primary);
    }

    .debate-setup-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
    }

    .debate-setup-actions button {
        padding: 10px 20px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: rgba(30, 30, 40, 0.5);
        color: var(--text-primary);
        cursor: pointer;
    }

    .debate-setup-actions button.primary {
        background: linear-gradient(135deg, #6366f1, #8b5cf6);
        border: none;
    }

    /* Debate Insight Selection */
    .debate-insights-selection {
        padding: 8px 0;
    }

    .debate-insight-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        margin-bottom: 8px;
        background: rgba(30, 30, 40, 0.5);
        border-radius: 8px;
        border-left: 3px solid #6366f1;
        cursor: pointer;
        transition: background 0.15s ease;
    }

    .debate-insight-item:hover {
        background: rgba(40, 40, 50, 0.6);
    }

    .debate-insight-item input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
    }

    .debate-insight-item .insight-icon {
        font-size: 16px;
    }

    .debate-insight-item .insight-text {
        flex: 1;
        font-size: 13px;
        color: var(--text-primary);
    }

    /* Mobile Responsive for Debate Panel */
    @media screen and (max-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #debate-panel.open {
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            max-width: 100vw;
            height: 100vh;
            max-height: 100vh;
            border-radius: 0;
            animation: none;
        }

        .debate-transcript {
            max-height: none;
            flex: 1;
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUILD 370: VOICE CAPTURE SYSTEM
       - Mobile full-screen TreeBeard
       - FAB (Floating Action Button) for voice capture
       - Voice capture UI with live transcript
       - Captures section in TreeBeard
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Mobile Full-Screen TreeBeard */
    @media screen and (max-width: 768px), (max-device-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #chat-assistant-panel.open {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            min-width: 100vw !important;
            min-height: 100vh !important;
            border-radius: 0 !important;
            z-index: 10001 !important;
            resize: none !important;
            animation: none !important;
        }

        #chat-assistant-panel.open #chat-assistant-header {
            padding: 16px !important;
            padding-top: max(16px, env(safe-area-inset-top)) !important;
        }

        #chat-assistant-panel.open #chat-assistant-input-area {
            padding: 16px !important;
            padding-bottom: max(16px, env(safe-area-inset-bottom)) !important;
        }

        /* Hide original bubble on mobile when panel is open */
        #chat-assistant-bubble.panel-open {
            display: none !important;
        }
    }

    /* Voice Capture FAB (Floating Action Button) */
    #voice-capture-fab {
        position: fixed;
        bottom: 100px;
        right: 24px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(135deg, #10b981, #059669);
        border: none;
        cursor: pointer;
        box-shadow: 0 4px 20px rgba(16, 185, 129, 0.4);
        z-index: 9998;
        display: none; /* Hidden by default, shown on mobile */
        align-items: center;
        justify-content: center;
        font-size: 28px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #voice-capture-fab:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 28px rgba(16, 185, 129, 0.5);
    }

    #voice-capture-fab:active {
        transform: scale(0.95);
    }

    #voice-capture-fab.recording {
        background: linear-gradient(135deg, #ef4444, #dc2626);
        box-shadow: 0 4px 20px rgba(239, 68, 68, 0.5);
        animation: fabPulse 1.5s ease-in-out infinite;
    }

    #voice-capture-fab .fab-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        min-width: 22px;
        height: 22px;
        background: #ef4444;
        border-radius: 11px;
        color: white;
        font-size: 12px;
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 6px;
        border: 2px solid var(--bg-primary, #0f172a);
    }

    @keyframes fabPulse {
        0%, 100% { box-shadow: 0 4px 20px rgba(239, 68, 68, 0.5); }
        50% { box-shadow: 0 4px 30px rgba(239, 68, 68, 0.8); }
    }

    /* Show FAB on mobile */
    @media screen and (max-width: 768px), (max-device-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #voice-capture-fab {
            display: flex;
        }

        /* Hide FAB when TreeBeard is open, during modals, or 3D view */
        body.treebeard-open #voice-capture-fab,
        body.modal-open #voice-capture-fab,
        body.view-3d-active #voice-capture-fab {
            display: none !important;
        }
    }

    /* Voice Capture Section in TreeBeard */
    #voice-captures-section {
        border-bottom: 1px solid var(--border, #3f3f5a);
        max-height: 200px;
        overflow-y: auto;
    }

    #voice-captures-section.collapsed {
        max-height: 44px;
        overflow: hidden;
    }

    .captures-header {
        padding: 10px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        background: rgba(16, 185, 129, 0.1);
        transition: background 0.2s;
    }

    .captures-header:hover {
        background: rgba(16, 185, 129, 0.15);
    }

    .captures-header h4 {
        margin: 0;
        font-size: 12px;
        font-weight: 600;
        color: #10b981;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .captures-header .capture-count {
        background: #10b981;
        color: white;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 10px;
        font-weight: 700;
    }

    .captures-header .toggle-icon {
        color: var(--text-secondary);
        font-size: 12px;
        transition: transform 0.2s;
    }

    #voice-captures-section.collapsed .toggle-icon {
        transform: rotate(-90deg);
    }

    .captures-list {
        padding: 8px;
    }

    .capture-item {
        background: var(--item-bg, #2a2a3e);
        border: 1px solid var(--border, #3f3f5a);
        border-radius: 8px;
        padding: 10px 12px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .capture-item:hover {
        border-color: #10b981;
        background: rgba(16, 185, 129, 0.1);
    }

    .capture-item:last-child {
        margin-bottom: 0;
    }

    .capture-item .capture-preview {
        font-size: 13px;
        color: var(--text-primary);
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }

    .capture-item.expanded .capture-preview {
        -webkit-line-clamp: unset;
        display: block;
    }

    .capture-item .capture-meta {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 6px;
        font-size: 11px;
        color: var(--text-secondary);
    }

    .capture-item .capture-meta .word-count {
        background: rgba(99, 102, 241, 0.2);
        padding: 2px 6px;
        border-radius: 4px;
        color: #a5b4fc;
    }

    .capture-actions {
        display: none;
        gap: 6px;
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid var(--border, #3f3f5a);
    }

    .capture-item.expanded .capture-actions {
        display: flex;
        flex-wrap: wrap;
    }

    .capture-action-btn {
        padding: 6px 10px;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--text-primary);
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .capture-action-btn:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    .capture-action-btn.delete {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.3);
    }

    .capture-action-btn.delete:hover {
        background: rgba(239, 68, 68, 0.4);
    }

    /* Voice Recording UI in TreeBeard */
    #voice-recording-ui {
        display: none;
        flex-direction: column;
        align-items: center;
        padding: 24px;
        background: linear-gradient(180deg, rgba(16, 185, 129, 0.1), transparent);
        border-bottom: 1px solid var(--border, #3f3f5a);
    }

    #voice-recording-ui.active {
        display: flex;
    }

    .recording-status {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 16px;
    }

    .recording-dot {
        width: 12px;
        height: 12px;
        background: #ef4444;
        border-radius: 50%;
        animation: blink 1s infinite;
    }

    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.4; }
    }

    .recording-duration {
        font-size: 24px;
        font-weight: 700;
        color: #10b981;
        font-family: 'SF Mono', 'Monaco', monospace;
    }

    .live-transcript-area {
        width: 100%;
        min-height: 100px;
        max-height: 200px;
        overflow-y: auto;
        background: var(--item-bg, #2a2a3e);
        border: 1px solid var(--border, #3f3f5a);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 16px;
        font-size: 14px;
        line-height: 1.6;
        color: var(--text-primary);
    }

    .live-transcript-area .interim {
        color: var(--text-secondary);
        font-style: italic;
    }

    .live-transcript-area .final {
        color: var(--text-primary);
    }

    .live-transcript-placeholder {
        color: var(--text-secondary);
        font-style: italic;
        text-align: center;
    }

    .recording-controls {
        display: flex;
        gap: 12px;
    }

    .recording-stop-btn {
        padding: 12px 24px;
        background: linear-gradient(135deg, #10b981, #059669);
        border: none;
        border-radius: 8px;
        color: white;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
    }

    .recording-stop-btn:hover {
        transform: scale(1.02);
    }

    .recording-cancel-btn {
        padding: 12px 24px;
        background: var(--item-bg, #2a2a3e);
        border: 1px solid var(--border, #3f3f5a);
        border-radius: 8px;
        color: var(--text-secondary);
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .recording-cancel-btn:hover {
        border-color: #ef4444;
        color: #ef4444;
    }

    .recording-warning {
        margin-top: 12px;
        padding: 8px 12px;
        background: rgba(245, 158, 11, 0.2);
        border-radius: 6px;
        color: #f59e0b;
        font-size: 12px;
        display: none;
    }

    .recording-warning.show {
        display: block;
    }

    /* Capture Processing Modal in TreeBeard */
    .capture-processing-prompt {
        padding: 16px;
        background: rgba(16, 185, 129, 0.1);
        border-bottom: 1px solid var(--border, #3f3f5a);
    }

    .capture-processing-prompt .prompt-header {
        font-size: 12px;
        color: #10b981;
        font-weight: 600;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .capture-processing-prompt .transcript-preview {
        background: var(--item-bg, #2a2a3e);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 12px;
        font-size: 13px;
        line-height: 1.5;
        max-height: 120px;
        overflow-y: auto;
    }

    .capture-processing-prompt .quick-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 8px;
    }

    .capture-processing-prompt .quick-action {
        padding: 8px 14px;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 8px;
        color: var(--text-primary);
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .capture-processing-prompt .quick-action:hover {
        background: rgba(99, 102, 241, 0.4);
        border-color: rgba(99, 102, 241, 0.5);
    }

    .capture-processing-prompt .instruction-hint {
        font-size: 11px;
        color: var(--text-secondary);
        font-style: italic;
    }

    /* Artifact Badge Indicators */
    .artifact-badge {
        display: inline-flex;
        align-items: center;
        gap: 2px;
        padding: 2px 6px;
        background: rgba(99, 102, 241, 0.2);
        border-radius: 4px;
        font-size: 11px;
        color: #a5b4fc;
        margin-left: 6px;
    }

    /* BUILD 371: Artifact Side Panel */
    #artifact-panel {
        position: fixed;
        top: 60px;
        right: -400px;
        width: 380px;
        height: calc(100vh - 60px);
        background: var(--surface, #1e1e2e);
        border-left: 1px solid var(--border, #3f3f5a);
        z-index: 200;
        display: flex;
        flex-direction: column;
        transition: right 0.3s ease;
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
    }

    #artifact-panel.open {
        right: 0;
    }

    #artifact-panel .panel-header {
        padding: 16px 20px;
        background: var(--header-bg, #16161e);
        border-bottom: 1px solid var(--border, #3f3f5a);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    #artifact-panel .panel-header h3 {
        margin: 0;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    #artifact-panel .panel-header .item-name {
        font-size: 12px;
        color: var(--text-secondary);
        margin-top: 4px;
    }

    #artifact-panel .panel-close {
        background: none;
        border: none;
        color: var(--text-secondary);
        font-size: 20px;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
    }

    #artifact-panel .panel-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
    }

    #artifact-panel .panel-content {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }

    /* Drop zone for artifacts */
    .artifact-drop-zone {
        border: 2px dashed rgba(99, 102, 241, 0.4);
        border-radius: 12px;
        padding: 32px;
        text-align: center;
        margin-bottom: 16px;
        background: rgba(99, 102, 241, 0.05);
        transition: all 0.2s;
        cursor: pointer;
    }

    .artifact-drop-zone:hover,
    .artifact-drop-zone.drag-over {
        border-color: #6366f1;
        background: rgba(99, 102, 241, 0.15);
    }

    .artifact-drop-zone .drop-icon {
        font-size: 32px;
        margin-bottom: 12px;
    }

    .artifact-drop-zone .drop-text {
        font-size: 14px;
        color: var(--text-secondary);
    }

    .artifact-drop-zone .drop-hint {
        font-size: 11px;
        color: var(--text-tertiary);
        margin-top: 8px;
    }

    /* Artifact list */
    .artifact-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .artifact-list-item {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 12px;
        background: var(--item-bg, #2a2a3e);
        border-radius: 8px;
        border: 1px solid var(--border, #3f3f5a);
        transition: all 0.2s;
    }

    .artifact-list-item:hover {
        background: var(--item-hover, #32324a);
    }

    .artifact-list-item .artifact-preview {
        width: 60px;
        height: 60px;
        border-radius: 6px;
        overflow: hidden;
        background: rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }

    .artifact-list-item .artifact-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .artifact-list-item .artifact-preview .placeholder-icon {
        font-size: 24px;
        opacity: 0.5;
    }

    .artifact-list-item .artifact-info {
        flex: 1;
        min-width: 0;
    }

    .artifact-list-item .artifact-name {
        font-size: 13px;
        font-weight: 500;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .artifact-list-item .artifact-meta {
        font-size: 11px;
        color: var(--text-secondary);
        margin-top: 4px;
    }

    .artifact-list-item .artifact-actions {
        display: flex;
        gap: 4px;
        margin-top: 8px;
    }

    .artifact-list-item .artifact-action {
        padding: 4px 8px;
        font-size: 11px;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 4px;
        color: #a5b4fc;
        cursor: pointer;
    }

    .artifact-list-item .artifact-action:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    .artifact-list-item .artifact-action.delete {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.3);
        color: #fca5a5;
    }

    .artifact-list-item .artifact-action.delete:hover {
        background: rgba(239, 68, 68, 0.4);
    }

    /* Empty state */
    .artifact-empty {
        text-align: center;
        padding: 32px;
        color: var(--text-secondary);
    }

    .artifact-empty .empty-icon {
        font-size: 48px;
        opacity: 0.3;
        margin-bottom: 12px;
    }

    /* Item row artifact indicator */
    .item-row .item-artifacts-indicator {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 6px;
        background: rgba(99, 102, 241, 0.15);
        border-radius: 4px;
        font-size: 10px;
        color: #a5b4fc;
        cursor: pointer;
        margin-left: 4px;
    }

    .item-row .item-artifacts-indicator:hover {
        background: rgba(99, 102, 241, 0.3);
    }

    /* Mobile adjustments for artifact panel */
    @media screen and (max-width: 768px) {
        #artifact-panel {
            width: 100vw;
            right: -100vw;
        }

        #artifact-panel.open {
            right: 0;
        }
    }

    </style>
    <!-- BUILD 540: Third-party libraries now lazy-loaded for faster page load -->
    <!-- SheetJS library for Excel export - LAZY LOADED -->
    <!-- <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script> -->
    <!-- LZ-String library for URL compression - LAZY LOADED -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script> -->
    <!-- html2canvas for Canvas export as image - LAZY LOADED -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script> -->
    <!-- JSZip for .treelisty bundle export/import - LAZY LOADED -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script> -->
    <!-- BUILD 494: FullCalendar for Calendar View - LAZY LOADED -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js"></script> -->
    <!-- Google API Client Library for OAuth and Drive API -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <!-- Firebase SDK (modular CDN) -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, updateDoc, onSnapshot, serverTimestamp, getDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBU_n37rTiae2oM95ZS3Ojkg7UvhZmkCRo",
            authDomain: "treelisty.firebaseapp.com",
            projectId: "treelisty",
            storageBucket: "treelisty.firebasestorage.app",
            messagingSenderId: "281763482612",
            appId: "1:281763482612:web:72de0c4f347fe48fc147a1"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Expose to global scope for use in main script
        window.firebaseApp = app;
        window.firebaseAuth = auth;
        window.firebaseDb = db;
        window.firebaseSignInAnonymously = signInAnonymously;
        window.firebaseOnAuthStateChanged = onAuthStateChanged;
        window.firebaseDoc = doc;
        window.firebaseSetDoc = setDoc;
        window.firebaseOnSnapshot = onSnapshot;
        window.firebaseServerTimestamp = serverTimestamp;
        window.firebaseGetDoc = getDoc;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseReady = true;

        console.log('ğŸ”¥ Firebase initialized');
    </script>
</head>
<body>
    <!-- TreeListy by geej Splash Screen -->
    <div id="splash-screen">
        <img src="./assets/treelisty-icon2.png" alt="TreeListy" class="splash-logo">
        <div class="splash-title">TreeListy</div>
        <div class="splash-subtitle">by geej</div>
        <div class="splash-tagline">From Complexity to Clarity</div>
        <div class="splash-loader">
            <div class="splash-loader-bar"></div>
        </div>
    </div>

    <!-- BUILD 335: Mobile Menu Overlay (click to close) -->
    <div id="mobile-menu-overlay" class="mobile-menu-overlay"></div>

    <!-- BUILD 493: Mobile Navigation Dots -->
    <div id="mobile-nav-dots" class="mobile-nav-dots" style="display: none;">
        <div class="mobile-nav-dot active" data-screen="tree" title="Tree View"></div>
        <div class="mobile-nav-dot" data-screen="info" title="Info Panel"></div>
        <div class="mobile-nav-dot" data-screen="chat" title="Treebeard Chat"></div>
    </div>
    <div id="swipe-hint-left" class="swipe-hint-left"></div>
    <div id="swipe-hint-right" class="swipe-hint-right"></div>

    <!-- BUILD 491: Exit Fullscreen Button (shown only in fullscreen mode) -->
    <button id="fullscreen-exit-btn" class="fullscreen-exit-btn" aria-label="Exit fullscreen">âœ•</button>

    <!-- Header -->
    <div class="header">
        <div style="display: flex; align-items: center; gap: 20px;">
            <div class="logo">
                <div class="logo-title">
                    <img src="./assets/treelisty-icon2.png" alt="TreeListy" class="logo-icon">
                    <span>TreeListy</span>
                </div>
                <div class="logo-subtitle">by geej</div>
            </div>

            <!-- Save Indicator -->
            <div id="save-indicator" style="font-size: 12px; color: #9DA3B4; margin-left: 12px; white-space: nowrap;">
                â— Unsaved changes
            </div>

            <!-- BUILD 610: Clone to Edit Button (only visible in readonly/embed mode) -->
            <button id="clone-to-edit-btn" class="clone-to-edit-btn" onclick="cloneTreeForEditing()" title="Open a copy of this tree for editing">
                âœï¸ Clone to Edit
            </button>

            <!-- BUILD 561: Refresh Button for Gmail/GDrive Trees -->
            <button id="tree-refresh-btn" onclick="refreshCurrentTree()" style="display: none; padding: 6px 12px; background: linear-gradient(135deg, #3b82f6, #1d4ed8); border: none; border-radius: 8px; color: white; font-size: 12px; font-weight: 600; cursor: pointer; white-space: nowrap; margin-left: 8px;" title="Refresh from source">
                <span id="tree-refresh-icon">ğŸ”„</span> <span id="tree-refresh-label">Refresh</span>
            </button>

            <!-- BUILD 491: Mobile Fullscreen Toggle -->
            <button id="mobile-fullscreen-btn" class="mobile-fullscreen-btn" aria-label="Toggle fullscreen" title="Toggle fullscreen">
                <span class="fullscreen-icon">â›¶</span>
            </button>

            <!-- BUILD 335: Mobile Hamburger Menu Button -->
            <button id="mobile-menu-btn" class="mobile-hamburger" aria-label="Open menu" aria-expanded="false">
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
            </button>

        </div>
        <div class="controls" style="flex-wrap: wrap; gap: 8px;">
            <!-- BUILD 333: View Selector Dropdown - Shows current state -->
            <div class="control-section" style="margin-right: 4px;">
                <div class="dropdown-menu" id="view-dropdown">
                    <button class="dropdown-menu-trigger" id="view-dropdown-btn" aria-expanded="false" aria-haspopup="true" title="Switch view mode">
                        <span id="current-view-icon">ğŸŒ²</span>
                        <span id="current-view-text">Tree</span>
                    </button>
                    <div class="dropdown-menu-content" role="menu" aria-label="View options">
                        <button class="dropdown-menu-item" role="menuitem" id="view-tree-btn" data-view="tree">
                            <span class="item-icon">ğŸŒ²</span>
                            <span class="item-label">Tree View</span>
                            <span class="item-shortcut" id="tree-check">âœ“</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="view-canvas-btn" data-view="canvas">
                            <span class="item-icon">ğŸ¨</span>
                            <span class="item-label">Canvas View</span>
                            <span class="item-shortcut" id="canvas-check" style="opacity: 0;">âœ“</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="view-3d-btn" data-view="3d">
                            <span class="item-icon">ğŸ§Š</span>
                            <span class="item-label">3D Navigator</span>
                            <span class="item-shortcut" id="3d-check" style="opacity: 0;">âœ“</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="view-gantt-btn" data-view="gantt">
                            <span class="item-icon">ğŸ“Š</span>
                            <span class="item-label">Gantt Chart</span>
                            <span class="item-shortcut" id="gantt-check" style="opacity: 0;">âœ“</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="view-calendar-btn" data-view="calendar">
                            <span class="item-icon">ğŸ“…</span>
                            <span class="item-label">Calendar</span>
                            <span class="item-shortcut" id="calendar-check" style="opacity: 0;">âœ“</span>
                        </button>
                        <div class="dropdown-menu-divider"></div>
                        <button class="dropdown-menu-item" role="menuitem" id="export-canvas-btn" style="display: none;">
                            <span class="item-icon">ğŸ“·</span>
                            <span class="item-label">Export as PNG</span>
                        </button>
                    </div>
                </div>
                <!-- Hidden buttons for backwards compatibility with existing JS -->
                <button class="btn" id="toggle-view-mode" style="display: none;">
                    <span id="view-mode-icon">ğŸ¨</span>
                    <span id="view-mode-text">Canvas</span>
                </button>
                <button class="btn" id="toggle-3d-mode" style="display: none;">ğŸ§Š 3D</button>
            </div>

            <!-- BUILD 331: Consolidated Open/Save Dropdowns -->
            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="new-project-btn" style="background: linear-gradient(135deg, #059669, #10b981); padding: 6px 10px; font-size: 13px;" title="Start a new project">ğŸ†•</button>

                <!-- Open Dropdown -->
                <div class="dropdown-menu" id="open-dropdown">
                    <button class="dropdown-menu-trigger" id="open-dropdown-btn" aria-expanded="false" aria-haspopup="true" title="Open project from various sources">
                        <span>ğŸ“‚ Open</span>
                    </button>
                    <div class="dropdown-menu-content" role="menu" aria-label="Open options">
                        <button class="dropdown-menu-item" role="menuitem" id="load-json-btn">
                            <span class="item-icon">ğŸ“„</span>
                            <span class="item-label">Open Saved Tree</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="load-gdrive-btn">
                            <span class="item-icon">â˜ï¸</span>
                            <span class="item-label">From Google Drive</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="excel-import-btn">
                            <span class="item-icon">ğŸ“Š</span>
                            <span class="item-label">From Excel (.xlsx)</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="msproject-import-btn">
                            <span class="item-icon">ğŸ“…</span>
                            <span class="item-label">From MS Project (.xml)</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="image-import-btn">
                            <span class="item-icon">ğŸ–¼ï¸</span>
                            <span class="item-label">Import Image...</span>
                        </button>
                        <div class="dropdown-menu-divider"></div>
                        <button class="dropdown-menu-item" role="menuitem" id="import-text-header-btn">
                            <span class="item-icon">ğŸ“</span>
                            <span class="item-label">Import Text (AI)</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="refresh-drive-btn" style="display: none;">
                            <span class="item-icon">ğŸ”„</span>
                            <span class="item-label">Refresh from Drive</span>
                        </button>
                    </div>
                </div>
                <input type="file" id="excel-upload-input" accept=".xlsx,.xls" style="display: none;">
                <input type="file" id="msproject-upload-input" accept=".xml" style="display: none;">
                <input type="file" id="image-upload-input" accept=".png,.jpg,.jpeg,.gif,.webp,image/*" style="display: none;">

                <!-- Save Dropdown -->
                <div class="dropdown-menu" id="save-dropdown">
                    <button class="dropdown-menu-trigger btn-green" id="save-dropdown-btn" aria-expanded="false" aria-haspopup="true" title="Save or export project">
                        <span>ğŸ’¾ Save</span>
                    </button>
                    <div class="dropdown-menu-content" role="menu" aria-label="Save options">
                        <button class="dropdown-menu-item" role="menuitem" id="save-json-btn">
                            <span class="item-icon">ğŸ“„</span>
                            <span class="item-label">Save Tree</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="save-bundle-btn" onclick="window.exportTreelistyBundle()">
                            <span class="item-icon">ğŸ“¦</span>
                            <span class="item-label">Save Tree + Attachments</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="excel-export-btn">
                            <span class="item-icon">ğŸ“Š</span>
                            <span class="item-label">Export to Excel</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="msproject-export-btn">
                            <span class="item-icon">ğŸ“…</span>
                            <span class="item-label">Export to MS Project (.xml)</span>
                        </button>
                        <div class="dropdown-menu-divider"></div>
                        <button class="dropdown-menu-item" role="menuitem" id="share-btn">
                            <span class="item-icon">ğŸ”—</span>
                            <span class="item-label">Share as URL</span>
                        </button>
                    </div>
                </div>

                <button class="btn" id="live-sync-btn" onclick="document.getElementById('live-sync-modal').style.display='flex'; window.initFirebaseAuthIfNeeded && window.initFirebaseAuthIfNeeded();" style="background: linear-gradient(135deg, #f97316, #ea580c); padding: 6px 10px; font-size: 13px;" title="ğŸ”¥ Firebase Live Sync">ğŸ”„ Live</button>
                <button class="btn" id="mcp-bridge-btn" onclick="window.showMCPConnectModal && window.showMCPConnectModal();" style="background: linear-gradient(135deg, #6b7280, #4b5563); padding: 6px 10px; font-size: 13px;" title="Connect to Claude Code">ğŸ¤– Claude</button>
                <button class="btn" id="work-status-btn" onclick="window.showWorkStatusModal && window.showWorkStatusModal();" style="background: linear-gradient(135deg, #6b7280, #4b5563); padding: 6px 10px; font-size: 13px; position: relative;" title="Work Status - Active Tasks & Inbox">
                    ğŸ“¥ Inbox
                    <span id="work-status-badge" style="position: absolute; top: -6px; right: -6px; background: #3b82f6; color: white; font-size: 10px; min-width: 16px; height: 16px; border-radius: 50%; display: none; align-items: center; justify-content: center; font-weight: 600;">0</span>
                </button>
                <button class="btn" id="inbox-btn" onclick="window.showInboxModal && window.showInboxModal();" style="background: linear-gradient(135deg, #8b5cf6, #7c3aed); padding: 6px 10px; font-size: 13px; position: relative; display: none;" title="Agent Inbox - Proposed Changes">
                    ğŸ“¥ Inbox
                    <span id="inbox-badge" style="position: absolute; top: -6px; right: -6px; background: #ef4444; color: white; font-size: 10px; min-width: 16px; height: 16px; border-radius: 50%; display: none; align-items: center; justify-content: center; font-weight: 600;">0</span>
                </button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="undo-btn" title="Undo last action" disabled style="opacity: 0.5; padding: 6px 10px; font-size: 13px;">â†©ï¸</button>
                <button class="btn" id="expand-btn" title="Expand all" style="padding: 6px 10px; font-size: 13px;">â¬‡ï¸</button>
                <button class="btn" id="collapse-btn" title="Collapse all" style="padding: 6px 10px; font-size: 13px;">â¬†ï¸</button>
                <button class="btn" id="search-btn" style="background: linear-gradient(135deg, #3b82f6, #2563eb); padding: 6px 10px; font-size: 13px;" title="Search all fields">ğŸ”</button>
            </div>

            <!-- BUILD 543: Simplified pattern selector with recommended patterns first -->
            <div class="control-section pattern-selector" style="margin-right: 4px;">
                <select class="pattern-select" id="pattern-select" title="Choose naming pattern" style="padding: 6px 10px; font-size: 13px; min-width: 140px;">
                    <optgroup label="â­ Recommended">
                        <option value="generic" data-desc="Universal: Project â†’ Phase â†’ Item â†’ Task">ğŸ“‹ Generic Project</option>
                        <option value="roadmap" data-desc="Product: Product â†’ Quarter â†’ Feature â†’ Story">ğŸš€ Product Roadmap</option>
                        <option value="thesis" data-desc="Academic: Thesis â†’ Chapter â†’ Section â†’ Point">ğŸ“ Academic Writing</option>
                    </optgroup>
                    <optgroup label="ğŸ“‚ All Patterns">
                        <option value="sales" data-desc="Sales: Pipeline â†’ Quarter â†’ Deal â†’ Action">ğŸ’¼ Sales Pipeline</option>
                        <option value="book" data-desc="Writing: Book â†’ Part â†’ Chapter â†’ Scene">ğŸ“š Book Writing</option>
                        <option value="event" data-desc="Events: Event â†’ Stage â†’ Activity â†’ Task">ğŸ‰ Event Planning</option>
                        <option value="fitness" data-desc="Fitness: Program â†’ Phase â†’ Workout â†’ Exercise">ğŸ’ª Fitness Program</option>
                        <option value="strategy" data-desc="Business: Strategy â†’ Pillar â†’ Initiative â†’ Action">ğŸ“Š Strategic Plan</option>
                        <option value="course" data-desc="Education: Course â†’ Unit â†’ Lesson â†’ Exercise">ğŸ“– Course Design</option>
                        <option value="film" data-desc="Production: Film â†’ Phase â†’ Scene â†’ Shot">ğŸ¬ Film Production</option>
                        <option value="veo3" data-desc="Veo3: Project â†’ Sequence â†’ Scene â†’ Shot/Frame">ğŸ¥ Veo3 (Google)</option>
                        <option value="sora2" data-desc="Sora2: Project â†’ Sequence â†’ Beat â†’ Shot/Remix">ğŸ¬ Sora2 (OpenAI)</option>
                        <option value="philosophy" data-desc="Philosophy: Treatise â†’ Book â†’ Argument â†’ Premise">ğŸ¤” Philosophy</option>
                        <option value="prompting" data-desc="AI Prompting: Workbook â†’ Stage â†’ Module â†’ Step">ğŸ§  AI Prompt Design</option>
                        <option value="familytree" data-desc="Genealogy: Family â†’ Generation â†’ Person â†’ Event">ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Family Tree</option>
                        <option value="lifetree" data-desc="Biography: Life â†’ Decade â†’ Event â†’ Detail">ğŸŒ³ LifeTree (Biography)</option>
                        <option value="dialogue" data-desc="Rhetoric: Conversation â†’ Speaker â†’ Statement â†’ Point">ğŸ’¬ Dialogue & Rhetoric</option>
                        <option value="gmail" data-desc="Email: Inbox/Campaign â†’ Label/Stage â†’ Thread â†’ Message">ğŸ“§ Email Workflow</option>
                        <option value="filesystem" data-desc="File System: Drive â†’ Folder â†’ File/Folder (Unlimited Depth)">ğŸ’¾ File System</option>
                        <option value="capex" data-desc="Investor: Project â†’ Funding Phase â†’ Investment â†’ Deliverable">ğŸ’° CAPEX / Angel Pitch</option>
                        <option value="custom" data-desc="Custom: Define your own level names">âœï¸ Custom Names</option>
                    </optgroup>
                </select>
            </div>

            <div class="control-section" id="sort-section" style="display: none; margin-right: 4px;">
                <label for="pattern-sort-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>ğŸ“‹</span>
                    <select id="pattern-sort-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 120px; font-size: 12px;" title="Sort tree items by specific metrics. When linked (ğŸ”—), also clusters Canvas view.">
                        <option value="">Sort By</option>
                    </select>
                </label>
                <button class="btn" id="sort-cluster-link-btn" style="padding: 4px 8px; font-size: 12px; opacity: 0.8;" title="Click to unlink Sort from Canvas Cluster. When linked, changing Sort also changes Canvas clustering.">ğŸ”—</button>
                <button class="btn" id="reset-sort-btn" style="display: none; padding: 4px 8px; font-size: 12px;" title="Reset to default order">â†º</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="api-key-btn" title="Configure your Anthropic API key" style="padding: 6px 10px; font-size: 13px;">ğŸ”‘</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <label for="unified-ai-mode-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>ğŸ¤–</span>
                    <select id="unified-ai-mode-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 160px; font-size: 12px;" title="Choose AI provider and model">
                        <optgroup label="ğŸ†“ Server (Free - 200/hr)">
                            <option value="server-haiku" title="Fast & cheap - Claude 3 Haiku">âš¡ Haiku 3</option>
                            <option value="server-sonnet" selected title="Best reasoning - Claude Sonnet 4">ğŸ§  Sonnet 4</option>
                        </optgroup>
                        <optgroup label="ğŸ”‘ Claude (Your Key)">
                            <option value="user-haiku" title="Fast - Claude 3.5 Haiku">âš¡ Haiku 3.5</option>
                            <option value="user-sonnet" title="Best reasoning - Claude Sonnet 4">ğŸ§  Sonnet 4</option>
                            <option value="user-opus" title="Most capable - Claude Opus 4">ğŸ‘‘ Opus 4</option>
                            <option value="user-opus45" title="Frontier - Claude Opus 4.5">ğŸŒŸ Opus 4.5</option>
                        </optgroup>
                        <optgroup label="ğŸ”· Gemini (Your Key)">
                            <option value="user-gemini-flash" title="Fast - Gemini 2.5 Flash (Stable)">âš¡ Flash 2.5</option>
                            <option value="user-gemini-pro" title="Best reasoning - Gemini 2.5 Pro (Stable)">ğŸ§  Pro 2.5</option>
                            <option value="user-gemini-3-pro" title="Frontier - Gemini 3 Pro Preview (Nov 2025)">ğŸŒŸ Pro 3 Preview</option>
                        </optgroup>
                        <optgroup label="ğŸ’¬ OpenAI (Your Key)">
                            <option value="user-gpt52-pro" title="Most Accurate - GPT-5.2 Pro (Dec 2025)">ğŸ‘‘ GPT-5.2 Pro</option>
                            <option value="user-gpt52" title="Flagship - GPT-5.2 (Dec 2025)">ğŸŒŸ GPT-5.2</option>
                            <option value="user-gpt52-chat" title="ChatGPT Model - GPT-5.2 Chat">ğŸ’¬ GPT-5.2 Chat</option>
                            <option value="user-gpt5-mini" title="Fast - GPT-5 Mini">âš¡ GPT-5 mini</option>
                            <option value="user-o4-mini" title="Fast reasoning - o4-mini">ğŸ”® o4-mini</option>
                            <option value="user-o3" title="Best reasoning - o3">ğŸ”® o3</option>
                            <option value="user-gpt5" title="Previous Gen - GPT-5">ğŸ§  GPT-5</option>
                            <option value="user-gpt4o" title="Legacy - GPT-4o">ğŸ“¦ GPT-4o</option>
                        </optgroup>
                        <optgroup label="Disable">
                            <option value="off">âŒ Off</option>
                        </optgroup>
                    </select>
                </label>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <label for="theme-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>ğŸ¨</span>
                    <select id="theme-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 100px; font-size: 12px;" title="Choose visual theme">
                        <option value="default">ğŸŒ™ Default</option>
                        <option value="steampunk">âš™ï¸ Steampunk</option>
                        <option value="powerpuff">ğŸ’— Powerpuff</option>
                        <option value="tron">ğŸ’  Tron</option>
                    </select>
                </label>
            </div>

            <div class="control-section" style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                <button class="btn" id="how-to-btn" title="How to use TreeListy" style="padding: 8px 16px; font-size: 14px; display: flex; align-items: center; gap: 6px;">â“ <span>Help</span></button>
                <div id="version-display" style="font-size: 10px; color: var(--text-secondary); opacity: 0.7; white-space: nowrap;">
                    <!-- Populated by TREELISTY_VERSION -->
                </div>
            </div>
        </div>
    </div>

    <!-- Tree View Container -->
    <div class="tree-view-container">

    <!-- Empty State CTA (shown when tree is default/empty) -->
    <!-- BUILD 538: Added close button -->
    <div id="empty-state-cta" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 10; padding: 40px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 16px; max-width: 500px;">
        <button id="empty-state-close-btn" style="position: absolute; top: 12px; right: 12px; background: transparent; border: none; color: var(--text-secondary); font-size: 20px; cursor: pointer; padding: 4px 8px; border-radius: 4px; opacity: 0.7; transition: opacity 0.2s;" title="Close (Esc)">âœ•</button>
        <div style="font-size: 48px; margin-bottom: 16px;">ğŸš€</div>
        <h2 style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">Get Started</h2>
        <p style="font-size: 14px; color: var(--text-secondary); margin-bottom: 24px; line-height: 1.6;">
            Paste any text, document, or prompt and AI will structure it into a tree for you.
        </p>
        <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
            <button class="btn" id="empty-state-import-btn" style="background: linear-gradient(135deg, #8b5cf6, #6366f1); padding: 12px 24px; font-size: 15px; font-weight: 600; color: white; border-radius: 8px;">
                ğŸ“¥ Import Text
            </button>
            <button class="btn" id="empty-state-chat-btn" style="background: linear-gradient(135deg, #10b981, #059669); padding: 12px 24px; font-size: 15px; font-weight: 600; color: white; border-radius: 8px;">
                ğŸ’¬ Chat Builder
            </button>
        </div>
        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 16px; opacity: 0.7;">
            Or use the sidebar tools on the left â†’
        </p>
    </div>

    <!-- Tree -->
    <div class="tree-container" id="tree-container">
        <div class="tree-transform-wrapper" id="tree-transform-wrapper">
            <svg class="dependency-svg" id="dependency-svg"></svg>
            <div class="tree" id="tree-root"></div>
        </div>
    </div>

    </div><!-- /tree-view-container -->

    <!-- Info Panel - BUILD 515: Redesigned layout -->
    <div class="info-panel" id="info-panel">
        <div class="info-header">
            <div class="info-title" id="info-title">Details</div>
            <button class="close-btn" id="close-info">âœ•</button>
        </div>
        <!-- BUILD 515: Reader nav in its own row -->
        <div class="reader-nav-row" id="reader-nav" style="display: none;">
            <div class="reader-nav-controls">
                <button class="reader-nav-btn" id="reader-prev" title="Previous node (â†)">â—€</button>
                <span class="reader-position" id="reader-position">1 of 1</span>
                <button class="reader-nav-btn" id="reader-next" title="Next node (â†’)">â–¶</button>
            </div>
            <div class="reader-nav-options">
                <select class="reader-group-select" id="reader-group-select" title="Iterate through...">
                    <option value="all">ğŸŒ³ All</option>
                    <option value="hyperedge">ğŸ”— Group</option>
                    <option value="dependencies">â›“ï¸ Deps</option>
                </select>
                <button class="reader-nav-btn reader-tts-btn" id="reader-speak" title="Read aloud">ğŸ”Š</button>
                <button class="reader-nav-btn reader-tts-btn" id="reader-play" title="Auto-play all">â–¶ï¸</button>
                <button class="reader-mode-btn" id="reader-mode-toggle" title="Toggle read mode">ğŸ“–</button>
            </div>
        </div>
        <div class="info-body" id="info-body"></div>
    </div>

    <!-- Context Menu (populated dynamically) -->
    <div class="context-menu" id="context-menu"></div>

    <!-- AI Tools Sidebar (Collapsible) -->
    <div id="ai-tools-panel">
        <button class="btn" data-icon="ğŸ“¥" id="analyze-text-btn" title="Convert text/files into tree structure"><span>Import Text</span></button>
        <button class="btn" data-icon="ğŸ”€" id="merge-branch-btn" title="Paste a collaboration URL to merge changes"><span>Merge Branch</span></button>
        <button class="btn" data-icon="ğŸ™ï¸" id="freespeech-btn" onclick="openFreeSpeechModal()" title="Voice capture with psychological pattern analysis"><span>Free Speech</span></button>
        <button class="btn" data-icon="ğŸ’¬" id="wizard-btn" title="Build and edit tree via chat"><span>Chat Builder</span></button>
        <button class="btn" data-icon="ğŸ©º" id="ai-review-btn" title="Check for logic gaps and missing fields"><span>Check Quality</span></button>
        <button class="btn" data-icon="âœ¨" id="auto-enhance-btn" title="Auto-fill details and add subtasks"><span>Smart Expand</span></button>
        <button class="btn" data-icon="ğŸ“¤" id="generate-prompt-btn" title="Export tree as text for other LLMs"><span>Export Prompt</span></button>
        <button class="btn btn-primary" data-icon="ğŸ¤–" id="ai-btn" title="Run pattern-specific analysis"><span>AI Analysis</span></button>

        <div style="flex: 1;"></div>

        <!-- Zoom Controls in Sidebar -->
        <div class="sidebar-zoom-controls">
            <button class="btn" data-icon="+" id="zoom-in" title="Zoom In"><span>Zoom In</span></button>
            <button class="btn" data-icon="âˆ’" id="zoom-out" title="Zoom Out"><span>Zoom Out</span></button>
            <button class="btn" data-icon="âŸ²" id="zoom-reset" title="Reset Zoom"><span>Reset Zoom</span></button>
            <div class="zoom-level-sidebar" id="zoom-level">100%</div>
        </div>

        <button class="btn" data-icon="âš™ï¸" id="ai-settings-btn" title="AI Settings"><span>AI Settings</span></button>
    </div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <div class="modal-header" id="modal-title">Quick Insight</div>
            <div class="modal-body" id="modal-body">
                <div class="spinner"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="modal-close">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="edit-modal">
        <div class="modal-content">
            <div class="modal-header">Edit Item</div>
            <div class="modal-body" id="edit-modal-body"></div>
            <div class="modal-footer">
                <button class="btn" id="edit-cancel">Cancel</button>
                <button class="btn btn-primary" id="edit-save">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Project Settings Modal (Build 260) -->
    <div class="modal" id="project-settings-modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">âš™ï¸ Project Settings</div>
            <div class="modal-body">
                <div class="form-group">
                    <label style="font-weight: 600; margin-bottom: 8px; display: block;">Project Name</label>
                    <input type="text" id="project-name-input" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--item-bg); color: var(--text-primary); font-size: 16px;" />
                </div>

                <div class="form-group" style="margin-top: 20px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: block;">Project Description</label>
                    <textarea id="project-description-input" rows="2" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--item-bg); color: var(--text-primary); font-size: 14px; resize: vertical;" placeholder="Brief description of the project..."></textarea>
                </div>

                <div class="form-group" style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(99, 102, 241, 0.05)); border: 2px solid rgba(139, 92, 246, 0.3); border-radius: 12px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 20px;">ğŸ¯</span>
                        AI Specialist Context
                    </label>
                    <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; line-height: 1.5;">
                        Make the AI an expert in your tree's specific domain. This context is injected into all AI prompts for this project.
                    </p>
                    <textarea id="project-specialist-context" rows="4" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--item-bg); color: var(--text-primary); font-size: 14px; resize: vertical; line-height: 1.5;" placeholder="e.g., Expert in French existentialism, particularly Sartre's 'Being and Nothingness', Camus' absurdism, and de Beauvoir's feminist existentialism. Deep knowledge of 20th century continental philosophy."></textarea>
                    <div style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">
                        <strong>Examples:</strong>
                        <ul style="margin: 6px 0 0 16px; padding: 0; line-height: 1.6;">
                            <li>Philosophy: "Specialist in Hegelian dialectics and phenomenology"</li>
                            <li>Sales: "Expert in enterprise SaaS sales to Fortune 500 CFOs"</li>
                            <li>Film: "Cinematographer specializing in noir lighting and Hitchcock techniques"</li>
                        </ul>
                    </div>
                </div>

                <!-- Build 262: Team Management -->
                <div class="form-group" style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(99, 102, 241, 0.05)); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 12px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 20px;">ğŸ‘¥</span>
                        Project Team
                    </label>
                    <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; line-height: 1.5;">
                        Add team members to track contributions. Each person gets a unique badge (initials) for accountability.
                    </p>

                    <!-- Host Section -->
                    <div style="margin-bottom: 16px;">
                        <div style="font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">ğŸ‘‘ Host (Owner)</div>
                        <div id="project-host-display" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 8px;">
                            <span id="host-badge" style="width: 28px; height: 28px; background: linear-gradient(135deg, #ffc107, #ff9800); color: #000; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 11px;"></span>
                            <span id="host-name" style="flex: 1;"></span>
                            <span id="host-email" style="font-size: 11px; color: var(--text-secondary);"></span>
                        </div>
                    </div>

                    <!-- Add New Member -->
                    <div style="margin-bottom: 16px; padding: 12px; background: var(--bg); border-radius: 8px; border: 1px dashed var(--border);">
                        <div style="font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">â• Add Team Member</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <input type="text" id="new-member-name" placeholder="Name" style="flex: 1; min-width: 120px; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--item-bg); color: var(--text-primary); font-size: 13px;" />
                            <input type="email" id="new-member-email" placeholder="Email" style="flex: 2; min-width: 180px; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--item-bg); color: var(--text-primary); font-size: 13px;" />
                            <select id="new-member-role" style="padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--item-bg); color: var(--text-primary); font-size: 13px;">
                                <option value="contributor">Contributor</option>
                                <option value="collaborator">Collaborator</option>
                            </select>
                            <button type="button" onclick="addTeamMember()" style="padding: 8px 16px; background: var(--treeplex-primary); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500;">Add</button>
                        </div>
                        <div style="margin-top: 8px; font-size: 11px; color: var(--text-secondary);">
                            <strong>Contributor:</strong> Can edit assigned items â€¢ <strong>Collaborator:</strong> Full edit access
                        </div>
                    </div>

                    <!-- Team List -->
                    <div id="project-team-list" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- Dynamically populated -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="project-settings-cancel">Cancel</button>
                <button class="btn btn-primary" id="project-settings-save">ğŸ’¾ Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Analysis Mode Modal -->
    <div class="modal" id="analysis-modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">ğŸ” Analysis Mode - Convert Text to Tree Structure</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Upload a text file or paste content below. AI will analyze it, detect the best pattern, and convert it into a hierarchical tree structure.
                    </p>
                </div>

                <!-- Analysis Mode Selection (moved to top) -->
                <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                    <div id="current-ai-mode-display" style="padding: 16px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 8px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <div style="font-weight: 600; color: var(--text-primary);">
                                AI Mode: <span id="analyze-mode-label">âš¡ Quick</span>
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                Change mode in header
                            </div>
                        </div>
                        <div id="analyze-mode-description" style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                            Fast pattern detection + basic structure. Recommended for most uses.
                        </div>
                        <div style="margin-top: 12px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                            <strong style="color: var(--text-primary);">ğŸ’¡ Tip:</strong> Change AI mode in the header (ğŸ¤– AI Mode dropdown) to switch between Quick, Deep, or Off.
                        </div>
                    </div>
                </div>

                <!-- Source Type Selection (RAG Phase 1) -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">
                        ğŸ“ Source Type
                    </label>
                    <div id="source-type-selector" style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button type="button" class="source-type-btn active" data-source="text" style="flex: 1; min-width: 100px; padding: 12px 16px; border: 2px solid var(--treeplex-primary); background: rgba(99, 102, 241, 0.15); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ“ Text/File
                        </button>
                        <button type="button" class="source-type-btn" data-source="pdf" style="flex: 1; min-width: 100px; padding: 12px 16px; border: 2px solid var(--border); background: transparent; color: var(--text-secondary); border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ“„ PDF
                        </button>
                        <button type="button" class="source-type-btn" data-source="url" style="flex: 1; min-width: 100px; padding: 12px 16px; border: 2px solid var(--border); background: transparent; color: var(--text-secondary); border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸŒ URL
                        </button>
                    </div>
                </div>

                <!-- Pattern Selection -->
                <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        ğŸ“ Pattern Selection
                    </label>
                    <select id="analysis-pattern-select" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: #1a1a2e; color: #ffffff; font-size: 14px; cursor: pointer;">
                        <option value="auto" style="background: #1a1a2e; color: #ffffff;">ğŸ¤– Auto-detect (AI chooses best pattern)</option>
                        <option value="generic" style="background: #1a1a2e; color: #ffffff;">ğŸ“¦ Generic Project - Universal structure</option>
                        <option value="sales" style="background: #1a1a2e; color: #ffffff;">ğŸ’¼ Sales Pipeline - Deal tracking</option>
                        <option value="thesis" style="background: #1a1a2e; color: #ffffff;">ğŸ“š Academic Writing - Research papers</option>
                        <option value="roadmap" style="background: #1a1a2e; color: #ffffff;">ğŸ—ºï¸ Product Roadmap - Feature timeline</option>
                        <option value="book" style="background: #1a1a2e; color: #ffffff;">ğŸ“– Book Writing - Narrative structure</option>
                        <option value="event" style="background: #1a1a2e; color: #ffffff;">ğŸ‰ Event Planning - Event logistics</option>
                        <option value="fitness" style="background: #1a1a2e; color: #ffffff;">ğŸ’ª Fitness Program - Workout plans</option>
                        <option value="strategy" style="background: #1a1a2e; color: #ffffff;">ğŸ¯ Strategic Plan - Business initiatives</option>
                        <option value="course" style="background: #1a1a2e; color: #ffffff;">ğŸ“ Course Design - Curriculum structure</option>
                        <option value="film" style="background: #1a1a2e; color: #ffffff;">ğŸ¬ Film Production - Video workflow</option>
                        <option value="veo3" style="background: #1a1a2e; color: #ffffff;">ğŸ¥ Veo3 (Google) - Ingredient/Frame-based video</option>
                        <option value="sora2" style="background: #1a1a2e; color: #ffffff;">ğŸ¬ Sora2 (OpenAI) - Cameo/Beat-based video</option>
                        <option value="philosophy" style="background: #1a1a2e; color: #ffffff;">ğŸ¤” Philosophy - Arguments & treatises</option>
                        <option value="prompting" style="background: #1a1a2e; color: #ffffff;">ğŸ§  Prompt Engineering - AI prompts</option>
                        <option value="familytree" style="background: #1a1a2e; color: #ffffff;">ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Family Tree - Genealogy</option>
                        <option value="lifetree" style="background: #1a1a2e; color: #ffffff;">ğŸŒ³ LifeTree - Biographical timeline</option>
                        <option value="dialogue" style="background: #1a1a2e; color: #ffffff;">ğŸ’¬ Dialogue & Rhetoric - Debate analysis</option>
                        <option value="capex" style="background: #1a1a2e; color: #ffffff;">ğŸ’° CAPEX / Angel Pitch - Investor-ready</option>
                        <option value="filesystem" style="background: #1a1a2e; color: #ffffff;">ğŸ’¾ File System - File organization</option>
                        <option value="knowledge-base" style="background: #1a1a2e; color: #ffffff;">ğŸ“š Knowledge Base - RAG document corpus</option>
                    </select>
                    <div style="margin-top: 8px; padding: 10px; background: rgba(99, 102, 241, 0.1); border-radius: 4px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                        <strong style="color: var(--text-primary);">ğŸ’¡ Tip:</strong> Auto-detect lets AI analyze your text and recommend the best pattern. Or choose a specific pattern if you know what structure you want.
                    </div>
                </div>

                <!-- TEXT/FILE SOURCE SECTION -->
                <div id="source-text-section">
                    <!-- File Upload Section -->
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                            ğŸ“ Upload File (.txt, .md)
                        </label>
                        <div id="file-drop-zone" style="border: 2px dashed var(--border); border-radius: 8px; padding: 32px; text-align: center; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s;">
                            <div style="font-size: 48px; margin-bottom: 12px;">ğŸ“„</div>
                            <div style="color: var(--text-primary); font-weight: 500; margin-bottom: 4px;">
                                Drop file here or click to browse
                            </div>
                            <div style="color: var(--text-secondary); font-size: 13px;">
                                Supports .txt and .md files (max 100KB recommended)
                            </div>
                            <input type="file" id="analysis-file-input" accept=".txt,.md" style="display: none;" />
                        </div>
                        <div id="file-name-display" style="margin-top: 8px; color: var(--text-secondary); font-size: 13px; display: none;">
                            Selected: <span id="selected-file-name" style="color: var(--treeplex-primary); font-weight: 500;"></span>
                            <button id="clear-file-btn" style="margin-left: 8px; color: var(--text-secondary); background: none; border: none; cursor: pointer; font-size: 13px;">[Clear]</button>
                        </div>
                    </div>

                    <div style="text-align: center; margin: 16px 0; color: var(--text-secondary); font-size: 13px; font-weight: 600;">
                        â€” OR â€”
                    </div>

                    <!-- Paste Text Section -->
                    <div style="margin-bottom: 24px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <label style="font-weight: 600; color: var(--text-primary);">
                                ğŸ“ Paste Text
                            </label>
                            <!-- BUILD 511: Voice input for paste field -->
                            <button id="import-voice-btn" onclick="toggleImportVoiceCapture()" style="display: flex; align-items: center; gap: 6px; padding: 6px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.4); border-radius: 6px; color: #ef4444; font-size: 12px; cursor: pointer; transition: all 0.2s;" title="Click to speak - voice will be transcribed to text">
                                ğŸ¤ Voice
                            </button>
                        </div>
                        <textarea id="analysis-text-input" placeholder="Paste your text content here...

Example:
- Meeting notes
- Project outline
- Research paper
- Strategic plan
- Event agenda
- Course syllabus

The AI will analyze the structure and convert it to a tree."
                            style="width: 100%; min-height: 200px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: 'Inter', monospace; font-size: 13px; resize: vertical;"></textarea>
                        <div id="char-count" style="margin-top: 6px; text-align: right; color: var(--text-secondary); font-size: 12px;">
                            0 characters
                        </div>
                    </div>
                </div>

                <!-- PDF SOURCE SECTION -->
                <div id="source-pdf-section" style="display: none;">
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                            ğŸ“„ Upload PDF Document
                        </label>
                        <div id="pdf-drop-zone" style="border: 2px dashed var(--border); border-radius: 8px; padding: 32px; text-align: center; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s;">
                            <div style="font-size: 48px; margin-bottom: 12px;">ğŸ“„</div>
                            <div style="color: var(--text-primary); font-weight: 500; margin-bottom: 4px;">
                                Drop PDF here or click to browse
                            </div>
                            <div style="color: var(--text-secondary); font-size: 13px;">
                                Text will be extracted using pdf.js (max 10MB)
                            </div>
                            <input type="file" id="pdf-file-input" accept=".pdf" style="display: none;" />
                        </div>
                        <div id="pdf-name-display" style="margin-top: 8px; color: var(--text-secondary); font-size: 13px; display: none;">
                            Selected: <span id="selected-pdf-name" style="color: var(--treeplex-primary); font-weight: 500;"></span>
                            <button id="clear-pdf-btn" style="margin-left: 8px; color: var(--text-secondary); background: none; border: none; cursor: pointer; font-size: 13px;">[Clear]</button>
                        </div>
                        <!-- PDF extraction progress -->
                        <div id="pdf-extraction-progress" style="display: none; margin-top: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <div class="spinner" style="width: 16px; height: 16px; border: 2px solid var(--border); border-top-color: var(--treeplex-primary); border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                <span id="pdf-extraction-status" style="color: var(--text-primary); font-size: 13px;">Extracting text...</span>
                            </div>
                            <div style="height: 4px; background: var(--border); border-radius: 2px; overflow: hidden;">
                                <div id="pdf-extraction-bar" style="height: 100%; background: var(--treeplex-primary); width: 0%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                        <!-- Extracted text preview -->
                        <div id="pdf-text-preview" style="display: none; margin-top: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                                ğŸ“ Extracted Text Preview
                            </label>
                            <textarea id="pdf-extracted-text" readonly style="width: 100%; min-height: 150px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); font-family: 'Inter', monospace; font-size: 13px; resize: vertical;"></textarea>
                            <div id="pdf-char-count" style="margin-top: 6px; text-align: right; color: var(--text-secondary); font-size: 12px;">
                                0 characters extracted
                            </div>
                        </div>
                    </div>
                </div>

                <!-- URL SOURCE SECTION -->
                <div id="source-url-section" style="display: none;">
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                            ğŸŒ Import from URL
                        </label>
                        <div style="display: flex; gap: 8px;">
                            <input type="url" id="url-input" placeholder="https://example.com/article" style="flex: 1; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 14px;" />
                            <button id="fetch-url-btn" style="padding: 12px 20px; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; white-space: nowrap;">
                                Fetch
                            </button>
                        </div>
                        <div style="margin-top: 8px; padding: 10px; background: rgba(99, 102, 241, 0.1); border-radius: 4px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                            <strong style="color: var(--text-primary);">ğŸ’¡ Tip:</strong> Paste any web page URL. We'll extract the main content and convert it to a tree structure.
                        </div>
                        <!-- URL fetch progress -->
                        <div id="url-fetch-progress" style="display: none; margin-top: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div class="spinner" style="width: 16px; height: 16px; border: 2px solid var(--border); border-top-color: var(--treeplex-primary); border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                <span id="url-fetch-status" style="color: var(--text-primary); font-size: 13px;">Fetching page content...</span>
                            </div>
                        </div>
                        <!-- Fetched content preview -->
                        <div id="url-text-preview" style="display: none; margin-top: 16px;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                <label style="font-weight: 600; color: var(--text-primary);">
                                    ğŸ“ Fetched Content
                                </label>
                                <span id="url-source-info" style="font-size: 12px; color: var(--text-secondary);"></span>
                            </div>
                            <textarea id="url-fetched-text" readonly style="width: 100%; min-height: 150px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); font-family: 'Inter', monospace; font-size: 13px; resize: vertical;"></textarea>
                            <div id="url-char-count" style="margin-top: 6px; text-align: right; color: var(--text-secondary); font-size: 12px;">
                                0 characters fetched
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Warning Display -->
                <div id="analysis-warning" style="display: none; padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px; margin-bottom: 16px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">âš ï¸ Large File Warning</div>
                    <div id="analysis-warning-text" style="color: var(--text-secondary); font-size: 13px;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="analysis-cancel">Cancel</button>
                <button class="btn btn-primary" id="analysis-start-btn" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">ğŸ” Analyze</button>
            </div>
        </div>
    </div>

    <!-- API Key Configuration Modal -->
    <div class="modal" id="api-key-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">ğŸ”‘ AI Provider Configuration</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Configure your AI provider and API keys. You can use Claude, Gemini, ChatGPT, or all three.
                    </p>
                </div>

                <!-- Provider Selection -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        Primary AI Provider
                    </label>
                    <select id="provider-select" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 14px; cursor: pointer;">
                        <option value="anthropic">ğŸ¤– Anthropic Claude (Sonnet 4) - Best reasoning</option>
                        <option value="gemini">ğŸ”· Google Gemini (2.0 Flash) - Fast & cost-effective</option>
                        <option value="openai">ğŸ’¬ OpenAI ChatGPT (GPT-4o) - Versatile & popular</option>
                    </select>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 6px; line-height: 1.4;">
                        <strong>Cost comparison:</strong> Claude ~$3/1M input, $15/1M output | Gemini Free tier, then ~$0.075/1M | ChatGPT ~$2.50/1M input, $10/1M output
                    </div>
                </div>

                <!-- Claude API Key Section -->
                <div id="claude-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(99, 102, 241, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">ğŸ¤– Anthropic Claude API Key</div>
                        <div id="claude-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: var(--treeplex-primary); font-size: 13px; font-weight: 500;">ğŸ’¡ How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://console.anthropic.com/" target="_blank" style="color: var(--treeplex-primary);">console.anthropic.com</a></li>
                            <li>Sign up or log in to your account</li>
                            <li>Go to API Keys section</li>
                            <li>Create a new API key</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="claude-api-key-input" placeholder="sk-ant-..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <!-- Gemini API Key Section -->
                <div id="gemini-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(66, 133, 244, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">ğŸ”· Google Gemini API Key</div>
                        <div id="gemini-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: #4285f4; font-size: 13px; font-weight: 500;">ğŸ’¡ How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: #4285f4;">aistudio.google.com/app/apikey</a></li>
                            <li>Sign in with your Google account</li>
                            <li>Create a new API key</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="gemini-api-key-input" placeholder="AIzaSy..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <!-- OpenAI API Key Section -->
                <div id="openai-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(16, 163, 127, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">ğŸ’¬ OpenAI ChatGPT API Key</div>
                        <div id="openai-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: #10a37f; font-size: 13px; font-weight: 500;">ğŸ’¡ How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #10a37f;">platform.openai.com/api-keys</a></li>
                            <li>Sign up or log in to your account</li>
                            <li>Click "Create new secret key"</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="openai-api-key-input" placeholder="sk-proj-..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                    <input type="checkbox" id="api-key-show" style="cursor: pointer;" />
                    <label for="api-key-show" style="font-size: 13px; color: var(--text-secondary); cursor: pointer;">Show API keys</label>
                </div>

                <div style="padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">ğŸ”’ Security & Storage</div>
                    <div style="color: var(--text-secondary); font-size: 12px; line-height: 1.5;">
                        Your API keys are stored locally in your browser's localStorage and persist across sessions. Keys are never sent to any server except the respective AI provider's API (Anthropic, Google, or OpenAI).
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="api-key-cancel">Cancel</button>
                <button class="btn" id="api-key-clear" style="margin-right: auto; background: rgba(239, 68, 68, 0.1); color: #ef4444;">ğŸ—‘ï¸ Clear All Keys</button>
                <button class="btn btn-primary" id="api-key-save" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Save & Continue</button>
            </div>
        </div>
    </div>

    <!-- AI Settings Modal -->
    <div id="ai-settings-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid rgba(255,255,255,0.1);">
                <h2 style="margin: 0; font-size: 22px; display: flex; align-items: center; gap: 10px;">
                    <span>âš™ï¸</span> AI Settings
                    <span style="font-size: 13px; font-weight: 400; color: rgba(255,255,255,0.5); margin-left: 10px;">Tune Your AI Persona</span>
                </h2>
                <button onclick="closeAISettingsModal()" style="background: none; border: none; color: rgba(255,255,255,0.6); font-size: 28px; cursor: pointer; padding: 0; line-height: 1;">&times;</button>
            </div>

            <!-- Tone Section -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ğŸ­ Tone & Persona
                </label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="neutral" checked>
                        <span class="radio-label">
                            <strong>âš–ï¸ Neutral</strong>
                            <small>Professional, balanced, objective</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="critical">
                        <span class="radio-label">
                            <strong>ğŸ” Critical</strong>
                            <small>Red team, skeptical, finds flaws</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="enthusiastic">
                        <span class="radio-label">
                            <strong>ğŸš€ Enthusiastic</strong>
                            <small>Encouraging, optimistic, opportunity-focused</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="socratic">
                        <span class="radio-label">
                            <strong>â“ Socratic</strong>
                            <small>Asks questions, guides discovery</small>
                        </span>
                    </label>
                </div>
            </div>

            <!-- Verbosity Section -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ğŸ“ Output Style
                </label>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-verbosity" value="concise" checked>
                        <span class="radio-label">
                            <strong>âš¡ Concise</strong>
                            <small>Brief, bullet points</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-verbosity" value="balanced">
                        <span class="radio-label">
                            <strong>ğŸ“Š Balanced</strong>
                            <small>Clear paragraphs</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-verbosity" value="verbose">
                        <span class="radio-label">
                            <strong>ğŸ“š Verbose</strong>
                            <small>Detailed, thorough</small>
                        </span>
                    </label>
                </div>
            </div>

            <!-- Creativity Slider -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ğŸŒ¡ï¸ Creativity Level
                    <span id="creativity-value" style="color: #6366f1; margin-left: 8px;">0.5</span>
                </label>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <span style="font-size: 12px; color: rgba(255,255,255,0.5);">Consistent</span>
                    <input type="range" id="creativity-slider" min="0" max="100" value="50" style="flex: 1;">
                    <span style="font-size: 12px; color: rgba(255,255,255,0.5);">Creative</span>
                </div>
                <p style="font-size: 12px; color: rgba(255,255,255,0.4); margin-top: 8px; margin-bottom: 0;">
                    Lower values (0.0-0.3): Deterministic, factual tasks. Higher values (0.7-1.0): Creative writing, brainstorming.
                </p>
            </div>

            <!-- Custom Instructions -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    âœï¸ Custom Instructions <span style="font-weight: 400; color: rgba(255,255,255,0.5);">(Optional Override)</span>
                </label>
                <textarea id="custom-instructions" rows="4" style="width: 100%; padding: 12px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-family: 'SF Mono', Monaco, monospace; font-size: 13px; resize: vertical;" placeholder="Examples:
â€¢ 'Always include code examples in TypeScript'
â€¢ 'Assume I'm a beginner - explain concepts simply'
â€¢ 'Be extremely detailed about security implications'
â€¢ 'Focus on cost optimization strategies'"></textarea>
                <p style="font-size: 12px; color: rgba(255,255,255,0.4); margin-top: 8px; margin-bottom: 0;">
                    ğŸ’¡ These instructions override all other settings. The AI will prioritize this guidance above all else.
                </p>
            </div>

            <!-- Dialectic Mode Toggle (Cognitive Citadel) -->
            <div style="margin-bottom: 25px; padding: 15px; background: rgba(220, 38, 38, 0.1); border: 1px solid rgba(220, 38, 38, 0.3); border-radius: 8px;">
                <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
                    <input type="checkbox" id="ai-dialectic-mode" style="width: 18px; height: 18px; accent-color: #EF4444; margin-top: 2px;">
                    <div>
                        <strong style="color: #EF4444;">ğŸ›¡ï¸ Dialectic Mode</strong>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-top: 4px;">
                            Forces AI to identify assumptions and counter-arguments <em>before</em> helping.
                            Breaks the agreement echo chamber.
                        </div>
                    </div>
                </label>
            </div>

            <!-- BUILD 396: Chat UI Style Toggle -->
            <div style="margin-bottom: 25px; padding: 15px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px;">
                <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
                    <input type="checkbox" id="use-classic-chat" style="width: 18px; height: 18px; accent-color: #6366f1; margin-top: 2px;">
                    <div>
                        <strong style="color: #a5b4fc;">ğŸ’¬ Use Classic Chat Panel</strong>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-top: 4px;">
                            Switch to the traditional slide-out panel instead of the new floating command frame.
                            <br><span style="color: rgba(255,255,255,0.5);">Keyboard shortcut: Ctrl+/ or Cmd+/</span>
                        </div>
                    </div>
                </label>
            </div>

            <!-- BUILD 488: Treebeard Proactive Hints Toggle -->
            <div style="margin-bottom: 25px; padding: 15px; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px;">
                <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
                    <input type="checkbox" id="treebeard-proactive-hints" checked style="width: 18px; height: 18px; accent-color: #10b981; margin-top: 2px;">
                    <div>
                        <strong style="color: #6ee7b7;">ğŸŒ² TreeBeard Proactive Hints</strong>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-top: 4px;">
                            TreeBeard will notice schedule issues (overdue tasks, critical path risks) and gently nudge you.
                            <br><span style="color: rgba(255,255,255,0.5);">Only in Deep Mode with schedule data present.</span>
                        </div>
                    </div>
                </label>
            </div>

            <!-- Live Preview -->
            <div style="margin-bottom: 25px; padding: 15px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ğŸ‘ï¸ Live Preview
                </label>
                <div style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
                    <strong>Before (Base Prompt):</strong>
                </div>
                <div style="padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: rgba(255,255,255,0.5); margin-bottom: 12px;">
                    You are an expert project manager specializing in breaking down complex tasks...
                </div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
                    <strong>After (With Your Settings):</strong>
                </div>
                <div id="preview-after" style="padding: 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: rgba(255,255,255,0.8); white-space: pre-wrap;">You are an expert project manager specializing in breaking down complex tasks...</div>
            </div>

            <!-- BUILD 542: Telemetry Settings -->
            <div style="margin-bottom: 25px; padding: 15px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ğŸ“Š Usage Analytics
                </label>
                <div style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 12px;">
                    <input type="checkbox" id="telemetry-enabled" onchange="TELEMETRY.setConsent(this.checked); updateTelemetryStatus();" style="width: 18px; height: 18px; accent-color: #6366f1; margin-top: 2px;">
                    <div>
                        <strong style="color: #a5b4fc;">Help improve TreeListy</strong>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-top: 4px;">
                            Share anonymous usage data (commands, views, errors) to help us improve.
                            <br><span style="color: rgba(255,255,255,0.5);">No personal data. Stored locally in your browser.</span>
                        </div>
                    </div>
                </div>
                <div id="telemetry-status" style="font-size: 12px; color: rgba(255,255,255,0.5); padding: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; margin-bottom: 10px;">
                    <!-- Populated by updateTelemetryStatus() -->
                </div>
                <div style="display: flex; gap: 8px;">
                    <button onclick="exportTelemetryData()" class="btn" style="padding: 6px 12px; font-size: 12px; background: rgba(255,255,255,0.05);">
                        ğŸ“¥ Export My Data
                    </button>
                    <button onclick="deleteTelemetryData()" class="btn" style="padding: 6px 12px; font-size: 12px; background: rgba(239, 68, 68, 0.2); color: #fca5a5;">
                        ğŸ—‘ï¸ Delete All Data
                    </button>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; gap: 10px; justify-content: flex-end; padding-top: 15px; border-top: 2px solid rgba(255,255,255,0.1);">
                <button onclick="resetAISettings()" class="btn" style="padding: 10px 20px; background: rgba(255,255,255,0.05);">
                    ğŸ”„ Reset to Defaults
                </button>
                <button onclick="closeAISettingsModal()" class="btn" style="padding: 10px 20px;">
                    Cancel
                </button>
                <button onclick="saveAISettings()" class="btn btn-primary" style="padding: 10px 20px; background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);">
                    ğŸ’¾ Save Settings
                </button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div class="modal" id="share-modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">ğŸ“¤ Share Your Project</div>
            <div class="modal-body">
                <!-- Cloud Share - Primary Option -->
                <div id="cloud-share-section" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1)); padding: 20px; border-radius: 12px; border: 2px solid rgba(16, 185, 129, 0.4); margin-bottom: 20px;">
                    <div style="font-weight: 600; font-size: 16px; margin-bottom: 10px; display: flex; align-items: center; gap: 10px; color: #10b981;">
                        <span>â˜ï¸</span> Cloud Share
                        <span style="background: #10b981; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 500;">RECOMMENDED</span>
                    </div>
                    <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 15px; line-height: 1.5;">
                        Creates a short link that works everywhere - email, Slack, Teams, SMS. No size limits.
                    </p>
                    <button id="cloud-share-btn" style="padding: 12px 24px; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 8px; color: white; font-size: 15px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 10px; width: 100%; justify-content: center;">
                        <span>â˜ï¸</span> Generate Cloud Link
                    </button>
                    <div id="cloud-share-result" style="display: none; margin-top: 15px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="cloud-share-url" readonly
                                   style="flex: 1; background: var(--card-bg); border: 2px solid #10b981; color: var(--text-primary); padding: 12px; border-radius: 8px; font-family: monospace; font-size: 14px;">
                            <button id="copy-cloud-url" style="padding: 12px 20px; background: #10b981; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; white-space: nowrap;">
                                ğŸ“‹ Copy
                            </button>
                        </div>
                        <div style="margin-top: 10px; font-size: 13px; color: #10b981; display: flex; align-items: center; gap: 6px;">
                            âœ… Ready to share - works in any app!
                        </div>
                    </div>
                    <div id="cloud-share-error" style="display: none; margin-top: 12px; padding: 12px; background: rgba(239, 68, 68, 0.1); border: 1px solid #ef4444; border-radius: 8px;">
                        <div style="color: #ef4444; font-size: 13px;" id="cloud-share-error-msg"></div>
                    </div>
                </div>

                <!-- URL Share - Secondary Option (Collapsible) -->
                <details style="background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border);">
                    <summary style="padding: 15px; cursor: pointer; color: var(--text-secondary); font-size: 14px; display: flex; align-items: center; gap: 8px;">
                        <span>ğŸ”—</span> Advanced: URL Share (offline, no server)
                    </summary>
                    <div style="padding: 0 15px 15px 15px;">
                        <p style="color: var(--text-secondary); font-size: 12px; margin-bottom: 12px; line-height: 1.5;">
                            Embeds data directly in the URL. Works offline but may break in email for large projects.
                        </p>
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                            <input type="text" id="share-url-input" readonly
                                   style="flex: 1; background: var(--card-bg); border: 1px solid var(--border); color: var(--text-primary); padding: 10px; border-radius: 6px; font-family: monospace; font-size: 11px; user-select: all;"
                                   value="">
                            <button class="btn" id="copy-share-url" style="white-space: nowrap; padding: 10px 14px;">
                                ğŸ“‹ Copy
                            </button>
                        </div>
                        <div id="share-stats" style="display: flex; flex-wrap: wrap; gap: 12px; font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                            <div>ğŸ“Š <span id="share-node-count">0</span> nodes</div>
                            <div>ğŸ“ <span id="share-url-length">0</span> chars</div>
                        </div>
                        <div id="share-size-warning" style="display: none; background: rgba(245, 158, 11, 0.15); border: 1px solid #f59e0b; border-radius: 6px; padding: 10px; margin-top: 10px;">
                            <div style="color: #f59e0b; font-size: 12px; line-height: 1.4;">
                                âš ï¸ URL may be too long for email. Use Cloud Share above instead.
                            </div>
                            <button id="share-lite-btn" style="margin-top: 8px; padding: 6px 12px; background: linear-gradient(135deg, #f59e0b, #d97706); border: none; border-radius: 4px; color: white; font-size: 12px; cursor: pointer;">
                                ğŸ—œï¸ Try Lite URL
                            </button>
                        </div>
                        <div id="share-critical-warning" style="display: none; background: rgba(239, 68, 68, 0.15); border: 1px solid #ef4444; border-radius: 6px; padding: 10px; margin-top: 10px;">
                            <div style="color: #ef4444; font-size: 12px; line-height: 1.4;">
                                ğŸš« URL too large (<span id="share-url-kb">0</span> KB). Please use Cloud Share above.
                            </div>
                            <button id="share-lite-btn-critical" style="margin-top: 8px; padding: 6px 12px; background: linear-gradient(135deg, #ef4444, #dc2626); border: none; border-radius: 4px; color: white; font-size: 12px; cursor: pointer;">
                                ğŸ—œï¸ Try Lite URL
                            </button>
                        </div>
                    </div>
                </details>
            </div>
            <div class="modal-footer">
                <button class="btn" id="share-close">Close</button>
                <button class="btn" id="open-share-url" style="display: none;">
                    ğŸ”— Open URL in Tab
                </button>
            </div>
        </div>
    </div>

    <!-- BUILD 541: Keyboard Shortcut Reference Modal -->
    <div class="modal" id="keyboard-shortcut-modal" style="display: none;">
        <div class="modal-content" style="max-width: 650px;">
            <div class="modal-header">
                <span>Keyboard Shortcuts</span>
                <button class="modal-close" onclick="document.getElementById('keyboard-shortcut-modal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px 24px;">
                <!-- Global -->
                <div class="shortcut-category">
                    <div class="shortcut-category-title">Global</div>
                    <div class="shortcut-row"><span class="shortcut-desc">Undo</span><span class="shortcut-key">Ctrl+Z</span></div>
                    <div class="shortcut-row"><span class="shortcut-desc">Save to file</span><span class="shortcut-key">Ctrl+S</span></div>
                    <div class="shortcut-row"><span class="shortcut-desc">Toggle TreeBeard chat</span><span class="shortcut-key">Ctrl+/</span></div>
                    <div class="shortcut-row"><span class="shortcut-desc">Toggle Gantt view</span><span class="shortcut-key">G</span></div>
                    <div class="shortcut-row"><span class="shortcut-desc">Show this help</span><span class="shortcut-key">?</span></div>
                </div>
                <!-- Tree View -->
                <div class="shortcut-category">
                    <div class="shortcut-category-title">Tree View</div>
                    <div class="shortcut-row"><span class="shortcut-desc">Navigate up/down</span><span class="shortcut-key">j / k</span></div>
                    <div class="shortcut-row"><span class="shortcut-desc">Collapse/Expand</span><span class="shortcut-key">h / l</span></div>
                    <div class="shortcut-row"><span class="shortcut-desc">Edit node</span><span class="shortcut-key">Enter</span></div>
                    <div class="shortcut-row"><span class="shortcut-desc">Indent node</span><span class="shortcut-key">Tab</span></div>
                </div>
                <!-- Canvas View -->
                <div class="shortcut-category">
                    <div class="shortcut-category-title">Canvas View</div>
                    <div class="shortcut-row"><span class="shortcut-desc">Search nodes</span><span class="shortcut-key">Ctrl+F</span></div>
                    <div class="shortcut-row"><span class="shortcut-desc">Select all</span><span class="shortcut-key">Ctrl+A</span></div>
                    <div class="shortcut-row"><span class="shortcut-desc">Pan canvas</span><span class="shortcut-key">Space + drag</span></div>
                </div>
                <!-- Reader Navigation -->
                <div class="shortcut-category">
                    <div class="shortcut-category-title">Reader Navigation</div>
                    <div class="shortcut-row"><span class="shortcut-desc">Previous node</span><span class="shortcut-key">&larr;</span></div>
                    <div class="shortcut-row"><span class="shortcut-desc">Next node</span><span class="shortcut-key">&rarr;</span></div>
                </div>
                <!-- General -->
                <div class="shortcut-category" style="margin-bottom: 0;">
                    <div class="shortcut-category-title">General</div>
                    <div class="shortcut-row"><span class="shortcut-desc">Close modal/menu</span><span class="shortcut-key">Esc</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- BUILD 547: Email Reader Modal -->
    <div class="modal" id="email-reader-modal" style="display: none;">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh; display: flex; flex-direction: column;">
            <div class="modal-header" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">
                <span id="email-reader-title">ğŸ“§ Email</span>
                <button class="modal-close" onclick="closeEmailReaderModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 0; flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                <!-- Email Header -->
                <div id="email-reader-header" style="padding: 16px 20px; border-bottom: 1px solid var(--border); background: var(--bg-secondary);">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <div style="font-size: 18px; font-weight: 600; color: var(--text-primary); line-height: 1.3;" id="email-reader-subject">Subject Line</div>
                        <div style="font-size: 12px; color: var(--text-secondary); white-space: nowrap; margin-left: 16px;" id="email-reader-date">Dec 22, 2025</div>
                    </div>
                    <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">
                        <strong>From:</strong> <span id="email-reader-from">sender@example.com</span>
                    </div>
                    <div style="font-size: 13px; color: var(--text-secondary);">
                        <strong>To:</strong> <span id="email-reader-to">recipient@example.com</span>
                    </div>
                    <div id="email-reader-cc-row" style="font-size: 13px; color: var(--text-secondary); display: none;">
                        <strong>CC:</strong> <span id="email-reader-cc"></span>
                    </div>
                </div>
                <!-- Email Body -->
                <div id="email-reader-body" style="flex: 1; overflow-y: auto; padding: 20px; font-size: 14px; line-height: 1.7; color: var(--text-primary); white-space: pre-wrap;">
                    Email content will appear here...
                </div>
                <!-- Attachments (if any) -->
                <div id="email-reader-attachments" style="padding: 12px 20px; border-top: 1px solid var(--border); background: var(--bg-secondary); display: none;">
                    <div style="font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">ğŸ“ Attachments</div>
                    <div id="email-reader-attachment-list" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                </div>
                <!-- Thread Navigation (if multiple messages) -->
                <div id="email-reader-thread-nav" style="padding: 12px 20px; border-top: 1px solid var(--border); display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <button class="btn" id="email-reader-prev" onclick="emailReaderPrev()" style="padding: 6px 12px;">â† Previous</button>
                        <span id="email-reader-thread-info" style="font-size: 13px; color: var(--text-secondary);">Message 1 of 3</span>
                        <button class="btn" id="email-reader-next" onclick="emailReaderNext()" style="padding: 6px 12px;">Next â†’</button>
                    </div>
                </div>
            </div>
            <!-- Action Buttons -->
            <div style="padding: 12px 20px; border-top: 1px solid var(--border); display: flex; gap: 8px; justify-content: flex-end; background: var(--bg-secondary); flex-wrap: wrap;">
                <button class="btn" onclick="emailReaderReply()" style="background: rgba(16, 185, 129, 0.15); border-color: #10b981;">
                    â†©ï¸ Reply
                </button>
                <button class="btn" onclick="emailReaderForward()" style="background: rgba(59, 130, 246, 0.15); border-color: #3b82f6;">
                    â¡ï¸ Forward
                </button>
                <button class="btn" onclick="emailReaderOpenInGmail()" style="background: rgba(139, 92, 246, 0.1); border-color: var(--treeplex-primary);">
                    ğŸ”— Open in Gmail
                </button>
                <button class="btn" onclick="closeEmailReaderModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- BUILD 551: Email Compose Modal -->
    <div class="modal" id="compose-modal" style="display: none;">
        <div class="modal-content" style="max-width: 700px; max-height: 85vh; display: flex; flex-direction: column;">
            <div class="modal-header" style="background: linear-gradient(135deg, #8b5cf6, #6366f1);">
                <span id="compose-modal-title">âœï¸ Compose Draft</span>
                <button class="modal-close" onclick="closeComposeModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px; flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 16px;">
                <!-- Hidden fields for context -->
                <input type="hidden" id="compose-node-id" value="">
                <input type="hidden" id="compose-thread-id" value="">
                <input type="hidden" id="compose-draft-id" value="">
                <input type="hidden" id="compose-history-id" value="">

                <!-- To Field -->
                <div style="display: flex; align-items: center; gap: 12px;">
                    <label style="font-size: 13px; font-weight: 500; color: var(--text-secondary); width: 60px;">To:</label>
                    <input type="email" id="compose-to" placeholder="recipient@example.com" style="flex: 1; padding: 10px 14px; background: rgba(0,0,0,0.3); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                </div>

                <!-- CC Field (collapsible) -->
                <div id="compose-cc-row" style="display: none; align-items: center; gap: 12px;">
                    <label style="font-size: 13px; font-weight: 500; color: var(--text-secondary); width: 60px;">Cc:</label>
                    <input type="text" id="compose-cc" placeholder="cc@example.com" style="flex: 1; padding: 10px 14px; background: rgba(0,0,0,0.3); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                </div>

                <!-- BCC Field (collapsible) -->
                <div id="compose-bcc-row" style="display: none; align-items: center; gap: 12px;">
                    <label style="font-size: 13px; font-weight: 500; color: var(--text-secondary); width: 60px;">Bcc:</label>
                    <input type="text" id="compose-bcc" placeholder="bcc@example.com" style="flex: 1; padding: 10px 14px; background: rgba(0,0,0,0.3); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                </div>

                <!-- CC/BCC Toggle -->
                <div style="display: flex; gap: 12px; margin-left: 72px;">
                    <button onclick="document.getElementById('compose-cc-row').style.display = document.getElementById('compose-cc-row').style.display === 'none' ? 'flex' : 'none'" style="font-size: 11px; color: var(--text-secondary); background: none; border: none; cursor: pointer; text-decoration: underline;">+ Cc</button>
                    <button onclick="document.getElementById('compose-bcc-row').style.display = document.getElementById('compose-bcc-row').style.display === 'none' ? 'flex' : 'none'" style="font-size: 11px; color: var(--text-secondary); background: none; border: none; cursor: pointer; text-decoration: underline;">+ Bcc</button>
                </div>

                <!-- Subject Field -->
                <div style="display: flex; align-items: center; gap: 12px;">
                    <label style="font-size: 13px; font-weight: 500; color: var(--text-secondary); width: 60px;">Subject:</label>
                    <input type="text" id="compose-subject" placeholder="Re: " style="flex: 1; padding: 10px 14px; background: rgba(0,0,0,0.3); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                </div>

                <!-- Body -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <textarea id="compose-body" placeholder="Write your message..." style="flex: 1; min-height: 200px; padding: 14px; background: rgba(0,0,0,0.3); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; line-height: 1.6; resize: vertical; font-family: inherit;" oninput="composeAutoSave()"></textarea>
                </div>

                <!-- Draft Status -->
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: rgba(139, 92, 246, 0.08); border-radius: 8px; border: 1px solid rgba(139, 92, 246, 0.2);">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span id="compose-status-icon" style="font-size: 14px;">ğŸ’¾</span>
                        <span id="compose-status-text" style="font-size: 12px; color: var(--text-secondary);">Local draft (auto-saved)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label style="font-size: 11px; color: var(--text-secondary);">
                            <input type="checkbox" id="compose-keep-local" checked style="margin-right: 4px;">
                            Keep local copy
                        </label>
                    </div>
                </div>
            </div>

            <!-- Action Buttons (BUILD 552: Added Send button with confirmation) -->
            <div style="padding: 16px 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: flex-end; background: var(--bg-secondary);">
                <button class="btn" onclick="discardDraft()" style="background: rgba(239, 68, 68, 0.1); border-color: #ef4444; color: #ef4444;">
                    ğŸ—‘ï¸ Discard
                </button>
                <button class="btn" onclick="saveDraftToGmailFromModal()" style="background: rgba(139, 92, 246, 0.2); border-color: #8b5cf6; color: #8b5cf6;">
                    â˜ï¸ Save Draft
                </button>
                <button class="btn" onclick="showSendConfirmModal()" style="background: rgba(16, 185, 129, 0.2); border-color: #10b981; color: #10b981; font-weight: 500;">
                    ğŸ“¤ Send
                </button>
            </div>
        </div>
    </div>

    <!-- BUILD 551: Draft Conflict Resolution Modal -->
    <div class="modal" id="draft-conflict-modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #f59e0b, #ef4444);">
                <span>âš ï¸ Draft Conflict</span>
                <button class="modal-close" onclick="closeDraftConflictModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 24px;">
                <p style="font-size: 15px; line-height: 1.6; margin-bottom: 20px;">
                    This draft was modified in Gmail since you last loaded it.
                </p>
                <div style="background: rgba(239, 68, 68, 0.1); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                    <p style="font-weight: 600; margin: 0 0 8px 0; font-size: 13px; color: #ef4444;">Gmail version (newer)</p>
                    <div id="conflict-gmail-preview" style="font-size: 13px; color: var(--text-secondary); max-height: 100px; overflow-y: auto; white-space: pre-wrap;"></div>
                </div>
                <div style="background: rgba(139, 92, 246, 0.1); border-radius: 8px; padding: 16px;">
                    <p style="font-weight: 600; margin: 0 0 8px 0; font-size: 13px; color: #8b5cf6;">Your version</p>
                    <div id="conflict-local-preview" style="font-size: 13px; color: var(--text-secondary); max-height: 100px; overflow-y: auto; white-space: pre-wrap;"></div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 12px; justify-content: flex-end; padding: 16px 24px; border-top: 1px solid rgba(255,255,255,0.1);">
                <button class="btn" onclick="resolveConflict('discard')" style="background: rgba(100,100,100,0.2);">Keep Gmail</button>
                <button class="btn" onclick="resolveConflict('overwrite')" style="background: rgba(139, 92, 246, 0.2); border-color: #8b5cf6;">Keep Mine</button>
            </div>
        </div>
    </div>

    <!-- BUILD 552: Batch Gmail Preview Modal -->
    <div class="modal" id="batch-preview-modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px; max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header" id="batch-preview-header" style="background: linear-gradient(135deg, #3b82f6, #6366f1);">
                <span id="batch-preview-title">ğŸ“§ Batch Action Preview</span>
                <button class="modal-close" onclick="closeBatchPreviewModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px; flex: 1; overflow-y: auto;">
                <div id="batch-preview-summary" style="padding: 16px; background: rgba(59, 130, 246, 0.1); border-radius: 8px; margin-bottom: 16px;">
                    <!-- Summary goes here -->
                </div>
                <div style="font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">
                    Preview (showing up to 10):
                </div>
                <div id="batch-preview-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 300px; overflow-y: auto;">
                    <!-- Email list goes here -->
                </div>
                <div id="batch-preview-more" style="margin-top: 12px; font-size: 12px; color: var(--text-secondary); font-style: italic;">
                    <!-- "and X more..." -->
                </div>
            </div>
            <div style="padding: 16px 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between; background: var(--bg-secondary);">
                <div id="batch-progress" style="display: none; align-items: center; gap: 8px;">
                    <div style="width: 150px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                        <div id="batch-progress-bar" style="width: 0%; height: 100%; background: #3b82f6; transition: width 0.3s;"></div>
                    </div>
                    <span id="batch-progress-text" style="font-size: 11px; color: var(--text-secondary);">0/0</span>
                </div>
                <div style="display: flex; gap: 12px; margin-left: auto;">
                    <button class="btn" onclick="closeBatchPreviewModal()">Cancel</button>
                    <button id="batch-confirm-btn" class="btn" onclick="executeBatchAction()" style="background: rgba(59, 130, 246, 0.2); border-color: #3b82f6; color: #3b82f6; font-weight: 500;">
                        Confirm
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- BUILD 552: Send Confirmation Modal -->
    <div class="modal" id="send-confirm-modal" style="display: none;">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #10b981, #059669);">
                <span>ğŸ“¤ Confirm Send</span>
                <button class="modal-close" onclick="closeSendConfirmModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 24px;">
                <p style="font-size: 15px; line-height: 1.6; margin-bottom: 16px;">
                    Ready to send this email?
                </p>
                <div style="background: rgba(16, 185, 129, 0.1); border-radius: 8px; padding: 16px;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <span style="font-size: 12px; font-weight: 500; color: var(--text-secondary);">To:</span>
                        <span id="send-confirm-to" style="font-size: 14px; color: var(--text-primary);"></span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 12px; font-weight: 500; color: var(--text-secondary);">Subject:</span>
                        <span id="send-confirm-subject" style="font-size: 14px; color: var(--text-primary);"></span>
                    </div>
                </div>
                <p style="font-size: 12px; color: var(--text-secondary); margin-top: 16px; font-style: italic;">
                    âš ï¸ This will send the email immediately via Gmail.
                </p>
            </div>
            <div class="modal-footer" style="display: flex; gap: 12px; justify-content: flex-end; padding: 16px 24px; border-top: 1px solid rgba(255,255,255,0.1);">
                <button class="btn" onclick="closeSendConfirmModal()">Cancel</button>
                <button class="btn" onclick="confirmSendDraft()" style="background: rgba(16, 185, 129, 0.2); border-color: #10b981; color: #10b981; font-weight: 500;">
                    Send Now
                </button>
            </div>
        </div>
    </div>

    <!-- BUILD 542: Telemetry Consent Modal -->
    <div class="modal" id="telemetry-consent-modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">
                <span>ğŸ“Š Help Improve TreeListy</span>
            </div>
            <div class="modal-body" style="padding: 24px;">
                <p style="font-size: 15px; line-height: 1.6; margin-bottom: 20px;">
                    Would you like to share anonymous usage data to help us improve TreeListy?
                </p>
                <div style="background: rgba(99, 102, 241, 0.1); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                    <p style="font-weight: 600; margin: 0 0 12px 0; font-size: 14px;">What we collect:</p>
                    <ul style="margin: 0; padding-left: 20px; font-size: 13px; color: rgba(255,255,255,0.8);">
                        <li>Commands used (e.g., "add_child", "view_gantt")</li>
                        <li>Views visited (Tree, Canvas, Gantt, etc.)</li>
                        <li>Keyboard shortcuts used</li>
                        <li>Error types encountered</li>
                    </ul>
                </div>
                <div style="background: rgba(16, 185, 129, 0.1); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                    <p style="font-weight: 600; margin: 0 0 12px 0; font-size: 14px;">What we DON'T collect:</p>
                    <ul style="margin: 0; padding-left: 20px; font-size: 13px; color: rgba(255,255,255,0.8);">
                        <li>Your tree content or names</li>
                        <li>Personal information</li>
                        <li>API keys or credentials</li>
                        <li>Anything sent to external servers</li>
                    </ul>
                </div>
                <p style="font-size: 13px; color: rgba(255,255,255,0.6); margin-bottom: 0;">
                    Data stays in your browser. You can delete it anytime from Settings.
                </p>
            </div>
            <div class="modal-footer" style="display: flex; gap: 12px; justify-content: flex-end; padding: 16px 24px; border-top: 1px solid rgba(255,255,255,0.1);">
                <button class="btn" onclick="TELEMETRY.setConsent(false); document.getElementById('telemetry-consent-modal').style.display='none';" style="background: rgba(255,255,255,0.1);">
                    No Thanks
                </button>
                <button class="btn btn-primary" onclick="TELEMETRY.setConsent(true); document.getElementById('telemetry-consent-modal').style.display='none'; showToast('ğŸ“Š Telemetry enabled. Thank you!', 'success');" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">
                    Yes, Help Improve
                </button>
            </div>
        </div>
    </div>

    <!-- Share Branch Modal (Collaboration) -->
    <div class="modal" id="share-branch-modal" style="display: none;">
        <div class="modal-content" style="max-width: 750px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #10b981, #059669); color: white;">
                ğŸ¤ Share for Collaboration
            </div>
            <div class="modal-body" id="share-branch-body">
                <!-- Populated dynamically by showShareBranchModal() -->
            </div>
            <div class="modal-footer">
                <button class="btn" id="share-branch-close">Close</button>
                <button class="btn" id="share-branch-copy" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">
                    ğŸ“‹ Copy URL
                </button>
                <button class="btn" id="share-branch-copy-email" style="background: linear-gradient(135deg, #f59e0b, #d97706);">
                    ğŸ“§ Copy Email
                </button>
                <button class="btn btn-primary" id="share-branch-email" style="background: linear-gradient(135deg, #10b981, #059669);">
                    âœ‰ï¸ Open Email App
                </button>
            </div>
        </div>
    </div>

    <!-- Merge Branch Modal (Collaboration - receiving edited branches) -->
    <div class="modal" id="merge-branch-modal" style="display: none;">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white;">
                ğŸ”€ Merge Collaboration Changes
            </div>
            <div class="modal-body" id="merge-branch-body">
                <!-- Populated dynamically by showMergeBranchModal() -->
            </div>
            <div class="modal-footer">
                <button class="btn" id="merge-branch-cancel">Cancel</button>
                <button class="btn btn-primary" id="merge-branch-accept" style="background: linear-gradient(135deg, #10b981, #059669);">
                    âœ… Accept & Merge Changes
                </button>
            </div>
        </div>
    </div>

    <!-- Branch Editing Banner (shown when editing a shared branch) -->
    <div id="branch-edit-banner" style="display: none; position: fixed; top: 60px; left: 0; right: 0; z-index: 1000; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; padding: 12px 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);">
        <div style="display: flex; align-items: center; justify-content: space-between; max-width: 1400px; margin: 0 auto;">
            <div style="display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px;">ğŸ¤</span>
                <div>
                    <div style="font-weight: 600; font-size: 14px;">Editing Shared Branch</div>
                    <div id="branch-edit-info" style="font-size: 12px; opacity: 0.9;">From: Project Name</div>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="branch-share-back-btn" class="btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);">
                    ğŸ“¤ Share Back
                </button>
                <button id="branch-exit-btn" class="btn" style="background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);">
                    âœ– Exit
                </button>
            </div>
        </div>
    </div>

    <!-- Paste Branch URL Modal -->
    <div class="modal" id="paste-branch-modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white;">
                ğŸ”€ Merge Collaboration Branch
            </div>
            <div class="modal-body">
                <p style="color: var(--text-secondary); margin-bottom: 16px;">
                    Paste a collaboration URL you received from a collaborator to merge their changes into your project.
                </p>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Branch URL:</label>
                    <textarea id="paste-branch-url-input"
                              placeholder="Paste the full URL here (starts with https://treelisty.netlify.app?branch=...)"
                              style="width: 100%; height: 120px; background: var(--card-bg); border: 2px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 6px; font-family: monospace; font-size: 11px; resize: vertical;"></textarea>
                </div>
                <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 12px; border-radius: 6px; border-left: 3px solid #6366f1;">
                    <p style="color: var(--text-secondary); font-size: 12px; margin: 0;">
                        <strong>Tip:</strong> Make sure your original project is loaded before merging. The system will check if the projects match.
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="paste-branch-cancel">Cancel</button>
                <button class="btn btn-primary" id="paste-branch-merge" style="background: linear-gradient(135deg, #10b981, #059669);">
                    ğŸ”€ Parse & Merge
                </button>
            </div>
        </div>
    </div>

    <!-- Free Speech Recording Modal -->
    <div class="modal" id="freespeech-modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%); border: 1px solid rgba(99, 102, 241, 0.3);">
            <div class="modal-header" style="border-bottom: 1px solid rgba(99, 102, 241, 0.2);">
                <h3 style="color: #e2e8f0;">ğŸ™ï¸ Free Speech Session</h3>
                <button class="modal-close" onclick="closeFreeSpeechModal()">&times;</button>
            </div>
            <div class="modal-body" id="freespeech-modal-body" style="padding: 24px; text-align: center;">
                <!-- IDLE State -->
                <div id="freespeech-idle" style="display: block;">
                    <div style="font-size: 64px; margin-bottom: 16px;">ğŸ™ï¸</div>
                    <h4 style="color: #e2e8f0; margin-bottom: 12px;">Speak Without Thinking</h4>
                    <p style="color: #94a3b8; font-size: 14px; line-height: 1.6; margin-bottom: 24px;">
                        Let your thoughts flow freely. No judgment, no editing.<br>
                        AI will find surprising patterns in your words.
                    </p>
                    <div style="background: rgba(99, 102, 241, 0.1); padding: 16px; border-radius: 12px; margin-bottom: 24px; border: 1px solid rgba(99, 102, 241, 0.2);">
                        <div style="font-size: 12px; color: #94a3b8; text-align: left;">
                            <div style="margin-bottom: 8px;">âœ¨ <strong>Tips for best results:</strong></div>
                            <div style="margin-left: 16px;">â€¢ Speak as if thinking out loud</div>
                            <div style="margin-left: 16px;">â€¢ Don't censor yourself</div>
                            <div style="margin-left: 16px;">â€¢ Silences are okay - take your time</div>
                            <div style="margin-left: 16px;">â€¢ Your words are private until analyzed</div>
                        </div>
                    </div>
                    <button onclick="startFreeSpeechWarmup()" style="width: 100%; padding: 16px 24px; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; border: none; border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                        ğŸ¤ Begin Recording
                    </button>
                </div>

                <!-- WARMUP State (3-second countdown) -->
                <div id="freespeech-warmup" style="display: none;">
                    <div id="freespeech-countdown" style="font-size: 120px; color: #6366f1; font-weight: bold; animation: pulse 1s infinite;">3</div>
                    <p style="color: #94a3b8; font-size: 16px;">Take a breath...</p>
                </div>

                <!-- RECORDING State -->
                <div id="freespeech-recording" style="display: none;">
                    <!-- Breathing Circle Visualization -->
                    <div id="freespeech-visualizer" style="width: 200px; height: 200px; margin: 0 auto 24px; position: relative;">
                        <div id="freespeech-circle" style="width: 100%; height: 100%; border-radius: 50%; background: radial-gradient(circle, rgba(99, 102, 241, 0.4) 0%, rgba(99, 102, 241, 0.1) 70%, transparent 100%); animation: breathe 4s ease-in-out infinite;"></div>
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 48px;">ğŸ™ï¸</div>
                    </div>

                    <!-- Nudge Display (shows gentle prompts) -->
                    <div id="freespeech-nudge" style="min-height: 32px; font-size: 18px; color: #94a3b8; font-style: italic; margin-bottom: 24px;"></div>

                    <!-- Recording Status -->
                    <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 24px;">
                        <div style="width: 12px; height: 12px; background: #ef4444; border-radius: 50%; animation: blink 1s infinite;"></div>
                        <span style="color: #ef4444; font-weight: 600;">Recording...</span>
                    </div>

                    <button onclick="stopFreeSpeechRecording()" style="width: 100%; padding: 16px 24px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer;">
                        âœ“ I'm Done
                    </button>
                </div>

                <!-- PROCESSING State -->
                <div id="freespeech-processing" style="display: none;">
                    <div style="font-size: 64px; margin-bottom: 16px; animation: spin 2s linear infinite;">ğŸ”®</div>
                    <h4 style="color: #e2e8f0; margin-bottom: 12px;">Finding Hidden Patterns...</h4>
                    <p style="color: #94a3b8; font-size: 14px;">AI is analyzing your stream of consciousness</p>
                    <div style="margin-top: 24px;">
                        <div style="height: 4px; background: rgba(99, 102, 241, 0.2); border-radius: 2px; overflow: hidden;">
                            <div id="freespeech-progress" style="height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6); width: 0%; transition: width 0.5s ease;"></div>
                        </div>
                    </div>
                </div>

                <!-- ERROR State -->
                <div id="freespeech-error" style="display: none;">
                    <div style="font-size: 64px; margin-bottom: 16px;">âš ï¸</div>
                    <h4 style="color: #ef4444; margin-bottom: 12px;">Recording Issue</h4>
                    <p id="freespeech-error-message" style="color: #94a3b8; font-size: 14px; margin-bottom: 24px;">Speech recognition is not supported in this browser.</p>
                    <button onclick="resetFreeSpeechModal()" style="padding: 12px 24px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); cursor: pointer;">
                        Try Again
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Free Speech CSS Animations -->
    <style>
        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.15); opacity: 1; }
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        #freespeech-modal .modal-content {
            animation: fadeInScale 0.3s ease-out;
        }
        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>

    <!-- BUILD 469: Quick Capture Mode (Full-screen overlay for ?capture=1) -->
    <div id="quick-capture-overlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #1a1a2e; z-index: 10000; flex-direction: column; align-items: center; justify-content: center;">
        <!-- Recording State -->
        <div id="qc-recording" style="display: flex; flex-direction: column; align-items: center; width: 100%; padding: 20px;">
            <!-- Waveform visualization -->
            <div id="qc-waveform" style="width: 80%; max-width: 400px; height: 100px; margin-bottom: 24px; display: flex; align-items: center; justify-content: center; gap: 3px;">
                <!-- Bars generated by JS -->
            </div>
            <!-- Timer -->
            <div id="qc-timer" style="font-size: 48px; font-weight: 300; color: #ffffff; font-family: 'SF Mono', Monaco, monospace; margin-bottom: 40px;">00:00</div>
            <!-- Done button -->
            <button id="qc-done-btn" style="padding: 20px 60px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 16px; font-size: 20px; font-weight: 600; cursor: pointer; margin-bottom: 20px;">
                Done
            </button>
            <!-- Cancel link -->
            <button id="qc-cancel-btn" style="background: none; border: none; color: #64748b; font-size: 14px; cursor: pointer; padding: 10px;">
                Cancel
            </button>
        </div>
        <!-- Processing State -->
        <div id="qc-processing" style="display: none; flex-direction: column; align-items: center;">
            <div style="width: 40px; height: 40px; border: 3px solid rgba(99, 102, 241, 0.3); border-top-color: #6366f1; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;"></div>
            <div style="color: #94a3b8; font-size: 16px;">Processing...</div>
            <div style="width: 200px; height: 3px; background: rgba(99, 102, 241, 0.2); border-radius: 2px; margin-top: 16px; overflow: hidden;">
                <div id="qc-progress-bar" style="width: 0%; height: 100%; background: #6366f1; transition: width 0.3s;"></div>
            </div>
        </div>
        <!-- Error State -->
        <div id="qc-error" style="display: none; flex-direction: column; align-items: center; text-align: center; padding: 20px;">
            <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
            <div id="qc-error-message" style="color: #f87171; font-size: 16px; margin-bottom: 24px;">An error occurred</div>
            <button id="qc-retry-btn" style="padding: 12px 32px; background: #6366f1; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
                Try Again
            </button>
        </div>
    </div>

    <!-- BUILD 568: Image Import Modal -->
    <div class="modal" id="image-import-modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px; background: var(--bg-secondary); border: 1px solid var(--border);">
            <div class="modal-header" style="border-bottom: 1px solid var(--border);">
                <h3 style="color: var(--text); margin: 0; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 24px;">ğŸ–¼ï¸</span> Import Image for Analysis
                </h3>
                <button class="modal-close" onclick="hideImageImportModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 24px;">
                <!-- Drop Zone -->
                <div id="image-drop-zone" style="border: 2px dashed var(--border); border-radius: 12px; padding: 40px 20px; text-align: center; cursor: pointer; transition: all 0.2s; margin-bottom: 20px; background: var(--bg);">
                    <div style="font-size: 48px; margin-bottom: 12px;">ğŸ“·</div>
                    <div style="color: var(--text); font-size: 16px; font-weight: 500; margin-bottom: 8px;">
                        Drop image here or click to browse
                    </div>
                    <div style="color: var(--text-secondary); font-size: 13px;">
                        PNG, JPEG, WebP, GIF (max 20MB)
                    </div>
                </div>

                <!-- URL Input -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: var(--text-secondary); font-size: 13px; margin-bottom: 6px;">
                        Or paste image URL:
                    </label>
                    <input type="text" id="image-url-input" placeholder="https://example.com/image.png"
                           style="width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); color: var(--text); font-size: 14px;">
                </div>

                <!-- Chrome Extension Capture -->
                <div id="image-capture-section" style="margin-bottom: 20px; display: none;">
                    <button onclick="captureScreenForImport()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span style="font-size: 18px;">ğŸ“¸</span> Capture Current Tab
                    </button>
                    <div style="color: var(--text-secondary); font-size: 12px; text-align: center; margin-top: 6px;">
                        Uses Chrome extension to capture visible tab
                    </div>
                </div>

                <!-- Preview -->
                <div id="image-preview-container" style="display: none; margin-bottom: 20px; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; background: #000;">
                    <img id="image-preview" style="max-width: 100%; max-height: 300px; display: block; margin: 0 auto;">
                    <div id="image-preview-info" style="padding: 10px; background: var(--bg-secondary); font-size: 12px; color: var(--text-secondary); display: flex; justify-content: space-between;">
                        <span id="image-preview-dims">0 x 0</span>
                        <span id="image-preview-size">0 KB</span>
                    </div>
                </div>

                <!-- Import Mode -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: var(--text-secondary); font-size: 13px; margin-bottom: 8px;">
                        Import mode:
                    </label>
                    <div style="display: flex; gap: 12px;">
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; color: var(--text);">
                            <input type="radio" name="image-import-mode" value="replace" checked style="accent-color: #6366f1;">
                            Replace current tree
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; color: var(--text);">
                            <input type="radio" name="image-import-mode" value="append">
                            Add as child of selected
                        </label>
                    </div>
                </div>

                <!-- Analysis Model Selection -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: var(--text-secondary); font-size: 13px; margin-bottom: 8px;">
                        Analysis model:
                    </label>
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; color: var(--text);">
                            <input type="radio" name="image-analysis-model" value="gemini-2.5-flash" checked style="accent-color: #6366f1;">
                            âš¡ Gemini 2.5 Flash <span style="color: var(--text-secondary); font-size: 11px;">(faster)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; color: var(--text);">
                            <input type="radio" name="image-analysis-model" value="gemini-3-pro-image-preview" style="accent-color: #6366f1;">
                            ğŸŒ Nano Banana Pro <span style="color: var(--text-secondary); font-size: 11px;">(better colors)</span>
                        </label>
                    </div>
                    <div style="color: var(--text-secondary); font-size: 11px; margin-top: 6px;">
                        Nano Banana Pro extracts more accurate colors for reconstruction
                    </div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button onclick="hideImageImportModal()" style="padding: 10px 20px; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 8px; font-size: 14px; cursor: pointer;">
                        Cancel
                    </button>
                    <button id="image-analyze-btn" onclick="analyzeImportedImage()" disabled style="padding: 10px 24px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; opacity: 0.5;">
                        ğŸ” Analyze with Gemini
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Wizard Modal -->
    <div class="modal" id="wizard-modal" style="display: none; justify-content: flex-end; background: transparent; pointer-events: none;">
        <div class="modal-content" style="width: 550px; max-width: 90vw; height: 100vh; max-height: 100vh; margin: 0; border-radius: 0; animation: slideInRight 0.3s ease-out; pointer-events: auto; box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);">
            <style>
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                    }
                    to {
                        transform: translateX(0);
                    }
                }
        
    /* ===================================================== */
    /* CANVAS VIEW STYLES */
    /* ===================================================== */

    .tree-view-container {
        display: block;
    }

    .tree-view-container.hidden {
        display: none !important;
    }

    .canvas-container {
        display: none;
        position: fixed;
        top: 140px;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        overflow: hidden;
        cursor: grab;
    }

    .canvas-container.active {
        display: block;
    }

    .canvas-container.grabbing {
        cursor: grabbing;
    }

    #canvas {
        width: 100%;
        height: 100%;
        position: relative;
        transform-origin: 0 0;
    }

    .canvas-connections {
        position: absolute;
        top: -5000px;
        left: -5000px;
        width: 20000px;
        height: 20000px;
        pointer-events: none;
        z-index: 1;
        overflow: visible;
    }

    /* Allow pointer events on hyperedge groups and their elements */
    .canvas-connections .hyperedge-group {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections polygon,
    .canvas-connections rect,
    .canvas-connections path.hyperedge-capsule {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections text {
        pointer-events: all;
        cursor: pointer;
    }

    /* Disable on connection lines (but not capsule paths) */
    .canvas-connections path:not(.hyperedge-capsule),
    .canvas-connections line {
        pointer-events: none;
    }

    /* BUILD 445: Animated flowing dashes for dependency links */
    .canvas-connections .animated-link {
        animation: flowingDash 1s linear infinite;
    }

    @keyframes flowingDash {
        to {
            stroke-dashoffset: -20;
        }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce) {
        .canvas-connections .animated-link {
            animation: none;
        }
    }

    .canvas-nodes-layer {
        position: relative;
        z-index: 2;
    }

    .canvas-node {
        position: absolute;
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        min-width: 280px;
        max-width: 320px;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, filter 0.15s ease, opacity 0.25s ease;
        z-index: 10;
    }

    /* BUILD 444: Animation classes for expand/collapse */
    .canvas-node.node-entering {
        opacity: 0;
        transform: scale(0.8);
    }

    .canvas-node.node-visible {
        opacity: 1;
        transform: scale(1);
    }

    /* Respect reduced motion preference */
    @media (prefers-reduced-motion: reduce) {
        .canvas-node {
            transition: none;
        }
        .canvas-node.node-entering {
            opacity: 1;
            transform: none;
        }
    }

    .canvas-node:hover {
        transform: translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }

    /* BUILD 447: Dependency creation visual feedback */
    .canvas-node.dep-source {
        box-shadow: 0 0 0 3px #ff6b6b, 0 0 20px rgba(255, 107, 107, 0.4);
        z-index: 100;
    }

    .canvas-node.dep-target {
        box-shadow: 0 0 0 3px #22c55e, 0 0 20px rgba(34, 197, 94, 0.4);
        z-index: 100;
    }

    .canvas-node.dep-invalid {
        box-shadow: 0 0 0 3px #ef4444, 0 0 20px rgba(239, 68, 68, 0.4);
        z-index: 100;
        opacity: 0.6;
    }

    .canvas-node.dragging {
        cursor: grabbing;
        opacity: 0.9;
        z-index: 1000;
        transform: scale(1.05);
    }

    .canvas-node.selected {
        border-color: var(--treeplex-primary) !important;
        box-shadow:
            0 8px 32px rgba(99, 102, 241, 0.4),
            0 4px 16px rgba(99, 102, 241, 0.3),
            0 0 0 3px rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-2px);
    }

    .canvas-node.selected::before {
        content: 'âœ“';
        position: absolute;
        top: -10px;
        right: -10px;
        background: #6366f1;
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .canvas-node.dragging-group {
        opacity: 0.7;
        box-shadow: 0 0 20px rgba(99, 102, 241, 0.8);
    }

    .phase-zone {
        position: absolute;
        border: 3px dashed;
        border-radius: 20px;
        padding: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .phase-zone-header {
        font-weight: 700;
        font-size: 18px;
        margin-bottom: 12px;
        color: var(--text-primary);
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* Colored phase zones - vibrant colors */
    .phase-0 {
        border-color: #3B82F6;
        background: rgba(59, 130, 246, 0.08);
    }
    .phase-1 {
        border-color: #F59E0B;
        background: rgba(245, 158, 11, 0.08);
    }
    .phase-2 {
        border-color: #10B981;
        background: rgba(16, 185, 129, 0.08);
    }
    .phase-3 {
        border-color: #8B5CF6;
        background: rgba(139, 92, 246, 0.08);
    }
    .phase-4 {
        border-color: #EC4899;
        background: rgba(236, 72, 153, 0.08);
    }
    .phase-5 {
        border-color: #06B6D4;
        background: rgba(6, 182, 212, 0.08);
    }

    /* Grid overlay */
    .canvas-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .canvas-grid.active {
        opacity: 1;
    }

    .canvas-toolbar.active {
        display: flex !important;
    }

    .canvas-toolbar button:hover {
        background: rgba(99, 102, 241, 0.3) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .canvas-toolbar button:active {
        transform: translateY(0);
    }

    .canvas-toolbar select:hover {
        background: rgba(99, 102, 241, 0.25) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
    }

    .canvas-toolbar select option {
        background: #1a1a2e;
        color: #ffffff;
        padding: 10px;
        font-weight: 600;
    }

    .canvas-toolbar select option:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUILD 435: Canvas Search Overlay
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .canvas-search-overlay {
        position: absolute;
        top: 70px;
        right: 20px;
        z-index: 250;
        background: rgba(20, 20, 30, 0.98);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(99, 102, 241, 0.3);
        border-radius: 12px;
        padding: 12px;
        min-width: 320px;
        max-width: 400px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    .canvas-search-box {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .canvas-search-overlay input {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 8px;
        background: rgba(30, 30, 40, 0.8);
        color: var(--text-primary);
        font-size: 14px;
        outline: none;
    }

    .canvas-search-overlay input:focus {
        border-color: rgba(99, 102, 241, 0.6);
    }

    .canvas-search-count {
        font-size: 12px;
        color: var(--text-secondary);
        white-space: nowrap;
    }

    .canvas-search-nav,
    .canvas-search-close {
        padding: 6px 10px;
        border: none;
        border-radius: 6px;
        background: rgba(99, 102, 241, 0.2);
        color: var(--text-primary);
        cursor: pointer;
        font-size: 12px;
        transition: background 0.2s;
    }

    .canvas-search-nav:hover,
    .canvas-search-close:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    .canvas-search-nav:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }

    .canvas-search-results {
        max-height: 200px;
        overflow-y: auto;
        margin-top: 8px;
    }

    .canvas-search-result {
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        color: var(--text-primary);
        display: flex;
        align-items: center;
        gap: 8px;
        transition: background 0.15s;
    }

    .canvas-search-result:hover {
        background: rgba(99, 102, 241, 0.2);
    }

    .canvas-search-result.active {
        background: rgba(99, 102, 241, 0.3);
        border-left: 3px solid var(--accent-primary, #6366f1);
    }

    .canvas-search-result-icon {
        font-size: 16px;
    }

    .canvas-search-result-name {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .canvas-search-result-phase {
        font-size: 11px;
        color: var(--text-secondary);
    }

    /* Highlight ring on searched node */
    .canvas-node.search-highlight {
        box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.6), 0 0 20px rgba(99, 102, 241, 0.4) !important;
        animation: search-pulse 0.5s ease-out;
    }

    @keyframes search-pulse {
        0% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUILD 435: Canvas Minimap
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .canvas-minimap {
        position: absolute;
        bottom: 20px;
        left: 280px; /* Clear the left sidebar (~260px) */
        width: 200px;
        height: 150px;
        background: rgba(20, 20, 30, 0.95);
        border: 2px solid rgba(99, 102, 241, 0.3);
        border-radius: 8px;
        overflow: hidden;
        z-index: 200;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        transition: border-color 0.2s;
    }

    .canvas-minimap:hover {
        border-color: rgba(99, 102, 241, 0.5);
    }

    #minimap-canvas {
        width: 100%;
        height: 100%;
    }

    .minimap-viewport {
        position: absolute;
        border: 2px solid rgba(99, 102, 241, 0.8);
        background: rgba(99, 102, 241, 0.1);
        pointer-events: auto;  /* BUILD 436: Enable drag interaction */
        transition: all 0.1s ease;
        cursor: grab;
    }

    .minimap-viewport:active,
    .minimap-viewport.dragging {
        cursor: grabbing;
    }

    .canvas-minimap.dragging {
        user-select: none;
    }

    /* Hide minimap on small screens */
    @media (max-width: 768px) {
        .canvas-minimap {
            display: none;
        }
        .canvas-search-overlay {
            right: 10px;
            left: 10px;
            min-width: auto;
            max-width: none;
        }
    }

    </style>
            <div class="modal-header">
                <span id="wizard-title">ğŸª„ AI Wizard - Building Your Project</span>
            </div>

            <div style="padding: 15px; background: var(--card-bg-light); border-bottom: 1px solid var(--border);">
                <div style="display: flex; gap: 30px; font-size: 14px; margin-bottom: 10px;">
                    <div>ğŸ“Š Turn: <span id="wizard-question-count" style="color: var(--treeplex-primary); font-weight: 600;">0</span></div>
                    <div>âœ“ Fields: <span id="wizard-fields-complete" style="color: var(--treeplex-primary); font-weight: 600;">0</span>/<span id="wizard-fields-total">10</span> complete</div>
                    <div>ğŸ“ˆ <span id="wizard-progress-percent" style="color: var(--treeplex-primary); font-weight: 600;">0%</span> complete</div>
                    <div id="wizard-completion" style="display: none; color: #10b981; font-weight: 600;">âœ… Ready to Apply!</div>
                </div>
                <!-- Progress Bar -->
                <div style="width: 100%; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden;">
                    <div id="wizard-progress-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--treeplex-primary), #10b981); transition: width 0.5s ease;"></div>
                </div>
            </div>

            <div class="modal-body" style="display: flex; flex-direction: column; padding: 0; height: calc(100vh - 200px); overflow: hidden;">
                <!-- Tip Banner -->
                <div style="padding: 12px 20px; background: linear-gradient(135deg, rgba(163, 85, 247, 0.1), rgba(236, 72, 153, 0.1)); border-bottom: 1px solid var(--border);">
                    <div style="font-size: 12px; color: var(--text-primary); display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 16px;">ğŸ’¡</span>
                        <span>Watch your tree update in real-time on the left as we build it together!</span>
                    </div>
                </div>

                <!-- Chat Area -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <div id="wizard-chat-history" style="flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px;">
                        <!-- Chat messages will appear here -->
                    </div>
                    <div style="padding: 15px 20px; border-top: 1px solid var(--border); display: flex; gap: 10px; background: var(--bg-secondary);">
                        <input type="text" id="wizard-user-input" placeholder="Type your answer here..."
                               style="flex: 1; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 6px; font-size: 14px;"
                               onkeypress="if(event.key==='Enter') document.getElementById('wizard-send').click()">
                        <button class="btn btn-primary" id="wizard-send" style="background: linear-gradient(135deg, #a855f7, #ec4899); padding: 12px 24px; white-space: nowrap;">
                            Send
                        </button>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="wizard-cancel">Cancel</button>
                <button class="btn" id="wizard-auto-enhance" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; font-weight: 600;" title="Automatically run AI Review then enhance your tree">
                    ğŸ”„ Auto-Enhance
                </button>
                <button class="btn btn-primary" id="wizard-done" style="background: linear-gradient(135deg, #10b981, #059669);">
                    âœ… Finish & Apply
                </button>
            </div>
        </div>
    </div>

    <!-- Generate Prompt Modal -->
    <div class="modal" id="generate-prompt-modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh;">
            <div class="modal-header">
                <span id="generate-prompt-title">ğŸ“ Generated Prompt</span>
            </div>

            <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(85vh - 140px);">
                <div style="margin-bottom: 15px; color: var(--text-secondary); font-size: 13px;">
                    This prompt was generated from your tree structure. Copy and paste it to use with AI systems.
                </div>

                <div style="position: relative;">
                    <textarea id="generated-prompt-text" readonly style="
                        width: 100%;
                        min-height: 400px;
                        padding: 15px;
                        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                        font-size: 13px;
                        line-height: 1.6;
                        border: 1px solid var(--border);
                        border-radius: 8px;
                        background: var(--card-bg);
                        color: var(--text-primary);
                        resize: vertical;
                    "></textarea>

                    <button id="copy-prompt-btn" style="
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        padding: 8px 16px;
                        background: var(--treeplex-primary);
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 600;
                    ">ğŸ“‹ Copy</button>
                </div>

                <div id="copy-success-message" style="
                    margin-top: 10px;
                    padding: 10px;
                    background: #10b981;
                    color: white;
                    border-radius: 6px;
                    text-align: center;
                    display: none;
                ">âœ… Copied to clipboard!</div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-prompt-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- AI Review Modal -->
    <div class="modal" id="ai-review-modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh;">
            <div class="modal-header">
                <span>ğŸ”¬ AI Review & Enhance</span>
            </div>

            <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 140px);">
                <!-- Status area -->
                <div id="ai-review-status" style="margin-bottom: 20px;">
                    <div style="padding: 15px; background: rgba(99, 102, 241, 0.1); border-left: 3px solid #6366f1; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">ğŸ¤– AI is analyzing your tree...</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            Checking for completeness, redundancies, logical flow, and pattern alignment.
                        </div>
                    </div>
                </div>

                <!-- Results area (hidden initially) -->
                <div id="ai-review-results" style="display: none;">
                    <!-- Summary section -->
                    <div style="margin-bottom: 24px; padding: 16px; background: var(--card-bg-light); border-radius: 8px;">
                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: var(--text-primary);">ğŸ“Š Analysis Summary</h3>
                        <div id="ai-review-summary"></div>
                    </div>

                    <!-- Suggestions section -->
                    <div style="margin-bottom: 24px;">
                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: var(--text-primary);">âœ¨ Suggested Improvements</h3>
                        <div id="ai-review-suggestions"></div>
                    </div>

                    <!-- Actions section -->
                    <div style="padding: 16px; background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">ğŸ¯ Next Steps</div>
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
                            Review the suggestions above. You can manually apply changes to your tree, or let AI enhance specific areas.
                        </div>
                        <button class="btn" id="ai-review-again" style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white;">
                            ğŸ”„ Re-analyze
                        </button>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-ai-review-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- Search Modal -->
    <div class="modal" id="search-modal" style="display: none;">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh;">
            <div class="modal-header">
                <span>ğŸ” Search Tree</span>
            </div>

            <div class="modal-body" style="padding: 20px;">
                <!-- Search input -->
                <div style="margin-bottom: 20px;">
                    <input type="text" id="search-input" placeholder="Search all fields (name, description, notes, etc.)..."
                        style="width: 100%; padding: 12px 16px; font-size: 15px; border: 2px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); outline: none; transition: border-color 0.2s;">
                    <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                        ğŸ’¡ Tip: Search is case-insensitive and searches all fields in all nodes
                    </div>
                </div>

                <!-- Search results -->
                <div id="search-results-container" style="max-height: calc(90vh - 260px); overflow-y: auto;">
                    <div id="search-results-empty" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                        <div style="font-size: 48px; margin-bottom: 12px;">ğŸ”</div>
                        <div style="font-size: 14px;">Enter a search term to find nodes</div>
                    </div>
                    <div id="search-results" style="display: none;"></div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-search-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- PWA Onboarding Modal -->
    <div class="modal" id="pwa-onboarding-modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <span>ğŸŒ³ Welcome to TreeListy!</span>
            </div>

            <div class="modal-body" style="padding: 30px;">
                <!-- Success checkmark -->
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 64px;">âœ…</div>
                    <h2 style="margin: 16px 0 8px; color: var(--text-primary); font-size: 22px;">Tree Loaded Successfully!</h2>
                    <p style="color: var(--text-secondary); font-size: 14px; margin: 0;">You can now explore this project</p>
                </div>

                <!-- Divider -->
                <div style="height: 1px; background: var(--border); margin: 24px 0;"></div>

                <!-- Install prompt -->
                <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); border: 2px solid var(--treeplex-primary); border-radius: 12px; padding: 24px; margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">
                        <div style="font-size: 40px;">ğŸ’¾</div>
                        <div>
                            <h3 style="margin: 0 0 4px; color: var(--text-primary); font-size: 18px;">Want to work with .treelisty files?</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: 13px;">Install TreeListy to open files with a double-click!</p>
                        </div>
                    </div>

                    <div style="background: var(--card-bg); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">âœ¨ Benefits:</div>
                        <ul style="margin: 0; padding-left: 20px; color: var(--text-primary); font-size: 14px; line-height: 1.8;">
                            <li>Open <code style="background: var(--bg); padding: 2px 6px; border-radius: 4px; font-family: monospace;">.treelisty</code> files with a double-click</li>
                            <li>Works offline after installation</li>
                            <li>Access from your app menu/desktop</li>
                            <li>Faster loading and better performance</li>
                        </ul>
                    </div>

                    <!-- Universal Install button - ALWAYS shown -->
                    <button class="btn" id="pwa-install-btn" style="width: 100%; background: linear-gradient(135deg, #6366f1, #8b5cf6); padding: 16px; font-size: 16px; font-weight: 600;">
                        ğŸ“¥ Install TreeListy
                    </button>

                    <!-- Instructions (shown after clicking if manual install needed) -->
                    <div id="pwa-manual-instructions" style="display: none; margin-top: 16px; padding: 16px; background: var(--card-bg-light); border-radius: 8px; border: 2px solid var(--treeplex-primary);">
                        <div style="font-size: 15px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">
                            ğŸ“ Follow these steps:
                        </div>
                        <ol style="margin: 0; padding-left: 24px; color: var(--text-primary); font-size: 14px; line-height: 2;">
                            <li>Look at the <strong>address bar</strong> (top of browser)</li>
                            <li>Find the <strong>install icon</strong> on the right side:
                                <span style="background: var(--bg); padding: 4px 8px; border-radius: 4px; margin-left: 8px;">ğŸ“¥</span> or
                                <span style="background: var(--bg); padding: 4px 8px; border-radius: 4px; margin-left: 4px;">âŠ•</span>
                            </li>
                            <li>Click the icon and select <strong>"Install"</strong></li>
                        </ol>
                        <div style="margin-top: 16px; padding: 12px; background: rgba(234, 179, 8, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                            ğŸ’¡ Don't see the icon? Close this modal and look for it. Still missing? You might need to use Chrome or Edge browser.
                        </div>
                    </div>
                </div>

                <!-- Skip option -->
                <div style="text-align: center;">
                    <button class="btn" id="pwa-skip-btn" style="background: var(--card-bg); color: var(--text-secondary); padding: 10px 20px; font-size: 13px;">
                        Maybe Later
                    </button>
                    <div style="margin-top: 8px; font-size: 11px; color: var(--text-secondary);">
                        You can always install later from the Help menu
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load from Google Drive Modal -->
    <div class="modal" id="load-gdrive-modal" style="display: none;">
        <div class="modal-content" style="max-width: 550px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #4285f4, #34a853);">
                <span>â˜ï¸ Load from Google Drive</span>
                <button class="modal-close" id="load-gdrive-close">&times;</button>
            </div>
            <div class="modal-body" style="padding: 24px;">
                <!-- URL Input Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        Paste Google Drive Share Link
                    </label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="gdrive-url-input" placeholder="https://drive.google.com/file/d/..."
                            style="flex: 1; padding: 12px 16px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                        <button class="btn" id="gdrive-load-btn" style="background: linear-gradient(135deg, #4285f4, #34a853); padding: 12px 20px; font-weight: 600;">
                            Load
                        </button>
                    </div>
                    <p style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                        Supports: drive.google.com share links or file IDs
                    </p>
                </div>

                <!-- Recent Files Section -->
                <div id="recent-gdrive-section" style="display: none;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <label style="font-size: 14px; font-weight: 600; color: var(--text-primary);">
                            ğŸ“‹ Recent Shared Trees
                        </label>
                        <button class="btn" id="clear-recent-gdrive" style="padding: 4px 10px; font-size: 11px; background: var(--card-bg);">
                            Clear
                        </button>
                    </div>
                    <div id="recent-gdrive-list" style="max-height: 200px; overflow-y: auto;">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Help text -->
                <div style="margin-top: 20px; padding: 16px; background: rgba(66, 133, 244, 0.1); border-radius: 8px; border-left: 3px solid #4285f4;">
                    <p style="margin: 0 0 8px; font-size: 13px; font-weight: 600; color: var(--text-primary);">ğŸ’¡ How to share a TreeListy file:</p>
                    <ol style="margin: 0; padding-left: 20px; font-size: 12px; color: var(--text-secondary); line-height: 1.8;">
                        <li>Save your project as JSON (ğŸ’¾ button)</li>
                        <li>Upload to Google Drive</li>
                        <li>Right-click â†’ Share â†’ "Anyone with the link"</li>
                        <li>Copy link and paste here!</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase Live Sync Modal -->
    <div class="modal" id="live-sync-modal" style="display: none;">
        <div class="modal-content" style="max-width: 520px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #f97316, #ea580c);">
                <span>ğŸ”„ Live Collaboration</span>
                <button class="modal-close" id="live-sync-close" onclick="document.getElementById('live-sync-modal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <!-- NOT CONNECTED STATE -->
                <div id="sync-start-section">
                    <div style="text-align: center; padding: 20px 0;">
                        <div style="font-size: 48px; margin-bottom: 12px;">ğŸ¤</div>
                        <h3 style="margin: 0 0 8px; color: var(--text-primary);">Start Collaborating</h3>
                        <p style="margin: 0 0 20px; font-size: 13px; color: var(--text-secondary);">
                            Work together in real-time with instant sync
                        </p>

                        <button class="btn" id="create-sync-room-btn" onclick="window.createFirebaseSyncRoom()" style="width: 100%; padding: 16px; background: linear-gradient(135deg, #10b981, #059669); font-weight: 600; font-size: 15px; margin-bottom: 12px;">
                            ğŸš€ Start Live Session
                        </button>

                        <!-- BUILD 325: Schedule Meeting Button -->
                        <button class="btn" onclick="window.closeMeetingModal(); window.showMeetingModal(); document.getElementById('live-sync-modal').style.display='none';" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #6366f1, #8b5cf6); font-weight: 600; font-size: 14px; margin-bottom: 16px;">
                            ğŸ“… Schedule Meeting Link
                        </button>

                        <div style="display: flex; align-items: center; gap: 12px; margin: 16px 0;">
                            <div style="flex: 1; height: 1px; background: var(--border);"></div>
                            <span style="font-size: 11px; color: var(--text-secondary);">or join existing</span>
                            <div style="flex: 1; height: 1px; background: var(--border);"></div>
                        </div>

                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="join-room-id" placeholder="Room code (e.g. ABC123)"
                                style="flex: 1; padding: 12px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; font-family: monospace; text-transform: uppercase;">
                            <button class="btn" id="join-sync-room-btn" onclick="window.joinFirebaseSyncRoom(document.getElementById('join-room-id').value)" style="padding: 12px 20px; background: linear-gradient(135deg, #6366f1, #8b5cf6); font-weight: 600;">
                                Join
                            </button>
                        </div>
                    </div>
                </div>

                <!-- CONNECTED STATE -->
                <div id="sync-active-section" style="display: none;">
                    <!-- BUILD 351: Hero Code Display - Easy to read and share -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.15)); padding: 20px; border-radius: 12px; border: 2px solid rgba(16, 185, 129, 0.4); margin-bottom: 16px;">
                        <!-- Status indicator -->
                        <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">
                            <div style="width: 10px; height: 10px; background: #10b981; border-radius: 50%; animation: watchPulse 2s ease-in-out infinite;"></div>
                            <span style="font-weight: 600; color: #10b981; font-size: 14px;">Live Session Active</span>
                        </div>

                        <!-- HERO CODE - Large, centered, easy to read aloud -->
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-secondary); margin-bottom: 8px;">Share this code</div>
                            <div id="active-room-id-display" style="font-family: 'SF Mono', 'Consolas', monospace; font-size: 36px; font-weight: 800; letter-spacing: 8px; color: var(--text-primary); background: var(--bg); padding: 16px 24px; border-radius: 12px; border: 2px dashed var(--border); display: inline-block; min-width: 200px; cursor: pointer;" onclick="window.copySessionCode()" title="Click to copy code">--</div>
                            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">Click code to copy</div>
                        </div>

                        <!-- Quick share buttons -->
                        <div style="display: flex; gap: 8px; justify-content: center; margin-bottom: 16px;">
                            <button class="btn" onclick="window.copySessionCode()" style="padding: 10px 16px; background: linear-gradient(135deg, #10b981, #059669); font-weight: 600;" title="Copy just the code">
                                ğŸ“‹ Copy Code
                            </button>
                            <button class="btn" onclick="window.copySyncInviteLink()" style="padding: 10px 16px; background: linear-gradient(135deg, #6366f1, #8b5cf6);" title="Copy full invite link">
                                ğŸ”— Copy Link
                            </button>
                            <button class="btn" onclick="window.emailSyncInvite()" style="padding: 10px 16px; background: linear-gradient(135deg, #f59e0b, #d97706);" title="Email invite">
                                ğŸ“§ Email
                            </button>
                        </div>

                        <!-- Full link (collapsed by default) -->
                        <details style="margin-top: 8px;">
                            <summary style="font-size: 11px; color: var(--text-secondary); cursor: pointer; text-align: center;">Show full invite link</summary>
                            <div style="margin-top: 8px;">
                                <input type="text" id="sync-invite-link" readonly
                                    style="width: 100%; padding: 10px; background: var(--bg); border: 2px solid var(--border); border-radius: 6px; font-family: monospace; font-size: 11px; color: var(--text-primary); box-sizing: border-box;">
                            </div>
                        </details>
                    </div>

                    <!-- Connected Collaborators -->
                    <div style="background: var(--card-bg); padding: 14px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 12px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                            <span style="font-weight: 600; font-size: 13px;">ğŸ‘¥ Connected</span>
                            <span id="sync-user-count" style="font-size: 12px; color: var(--text-secondary);">1 user</span>
                        </div>
                        <div id="sync-collaborators-list" style="display: flex; flex-wrap: wrap; gap: 8px;">
                            <!-- Collaborators will be populated here -->
                            <div class="collab-badge" style="display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 20px; font-size: 12px; font-weight: 600; color: white;">
                                <span>ğŸ‘‘</span> You (Host)
                            </div>
                        </div>
                    </div>

                    <!-- BUILD 272: Team Chat removed from modal - now in floating chat window -->
                    <!-- BUILD 281: API Key Sharing UI removed - guests enter keys manually -->

                    <!-- Actions -->
                    <div style="display: flex; gap: 8px;">
                        <button class="btn" onclick="window.saveCollabJSON()" style="flex: 1; padding: 10px; background: var(--card-bg); border: 1px solid var(--border);" title="Download current tree as JSON">
                            ğŸ’¾ Save Local Copy
                        </button>
                        <button class="btn" id="leave-sync-room-btn" onclick="window.leaveFirebaseSyncRoom()" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #ef4444, #dc2626); font-weight: 600;">
                            â¹ï¸ Leave Session
                        </button>
                    </div>
                </div>

                <!-- Hidden elements for backwards compatibility -->
                <div style="display: none;">
                    <div id="sync-status-section"></div>
                    <div id="sync-status-indicator"></div>
                    <div id="sync-status-text"></div>
                    <div id="sync-user-id"><span id="sync-user-id-value"></span></div>
                    <input type="text" id="active-room-id">
                    <div id="sync-last-update"></div>
                    <div id="sync-last-editor-row"><span id="sync-last-editor"></span></div>
                    <div id="api-session-start"></div>
                    <div id="api-session-active"></div>
                    <div id="api-session-expires-at"></div>
                    <div id="api-session-guest-count"></div>
                    <input id="api-session-share-link">
                    <div id="api-guest-session"></div>
                    <div id="api-guest-host-name"></div>
                    <div id="api-guest-expires"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- MCP Bridge Connection Modal -->
    <div class="modal" id="mcp-connect-modal" style="display: none;">
        <div class="modal-content" style="max-width: 520px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #8b5cf6, #6366f1);">
                <span>ğŸ¤– Claude Code Bridge</span>
                <button class="modal-close" onclick="document.getElementById('mcp-connect-modal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <!-- NOT CONNECTED STATE -->
                <div id="mcp-start-section">
                    <div style="text-align: center; padding: 16px 0 20px;">
                        <div style="font-size: 48px; margin-bottom: 12px;">ğŸ”—</div>
                        <h3 style="margin: 0 0 8px; color: var(--text-primary);">Connect to Claude Code</h3>
                        <p style="margin: 0 0 16px; font-size: 13px; color: var(--text-secondary);">
                            Let Claude Code read and modify your tree via MCP
                        </p>
                    </div>

                    <!-- Setup Instructions -->
                    <details style="margin-bottom: 20px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                        <summary style="padding: 12px 16px; cursor: pointer; font-weight: 600; color: var(--text-primary); display: flex; align-items: center; gap: 8px;">
                            <span>ğŸ“‹</span> First-time setup (one-time)
                        </summary>
                        <div style="padding: 0 16px 16px;">
                            <p style="font-size: 13px; color: var(--text-secondary); margin: 8px 0 12px;">
                                Add to Claude Code's MCP settings:
                            </p>
                            <div style="position: relative;">
                                <pre id="mcp-setup-code" style="background: #1a1a2e; padding: 14px; border-radius: 6px; font-size: 12px; overflow-x: auto; color: #e2e8f0; margin: 0; line-height: 1.6;">{
  "mcpServers": {
    "treelisty": {
      "command": "npx",
      "args": ["treelisty-mcp-bridge"]
    }
  }
}</pre>
                                <button onclick="navigator.clipboard.writeText(document.getElementById('mcp-setup-code').textContent); showToast('Copied to clipboard!', 'success');" style="position: absolute; top: 8px; right: 8px; background: rgba(255,255,255,0.1); border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 11px; color: #a0aec0;">
                                    ğŸ“‹ Copy
                                </button>
                            </div>
                            <p style="font-size: 12px; color: var(--text-secondary); margin: 12px 0 0;">
                                Or run: <code style="background: rgba(139, 92, 246, 0.2); padding: 2px 6px; border-radius: 4px;">/mcp add treelisty npx treelisty-mcp-bridge</code>
                            </p>
                        </div>
                    </details>

                    <!-- Connection Form -->
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(99, 102, 241, 0.05)); padding: 20px; border-radius: 12px; border: 2px solid rgba(139, 92, 246, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 16px; display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 18px;">ğŸ”Œ</span>
                            Enter connection details
                        </div>
                        <div style="margin-bottom: 14px;">
                            <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">Port (from bridge output)</label>
                            <input type="number" id="mcp-port-input" placeholder="e.g., 52341"
                                style="width: 100%; padding: 12px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 16px; font-family: monospace; box-sizing: border-box;">
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">Token (from bridge output)</label>
                            <input type="text" id="mcp-token-input" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
                                style="width: 100%; padding: 12px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; font-family: monospace; box-sizing: border-box;">
                        </div>
                        <button id="mcp-connect-btn" onclick="window.connectMCPFromModal()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #8b5cf6, #6366f1); color: white; border: none; border-radius: 8px; font-weight: 600; font-size: 15px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ”— Connect
                        </button>
                    </div>

                    <div style="margin-top: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 8px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                        <strong style="color: var(--text-primary);">ğŸ’¡ Auto-Connect:</strong> TreeListy auto-connects on page load using defaults (port 3456, token "treelisty-local"). If Claude Code is running with the bridge, you're already connected!
                    </div>
                </div>

                <!-- CONNECTED STATE -->
                <div id="mcp-connected-section" style="display: none;">
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.15)); padding: 24px; border-radius: 12px; border: 2px solid rgba(16, 185, 129, 0.4); margin-bottom: 20px; text-align: center;">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 12px;">
                            <div style="width: 12px; height: 12px; background: #10b981; border-radius: 50%; animation: watchPulse 2s ease-in-out infinite;"></div>
                            <span style="font-weight: 700; color: #10b981; font-size: 18px;">Connected to Claude Code</span>
                        </div>
                        <p style="margin: 0; font-size: 13px; color: var(--text-secondary);">
                            Claude Code can now read and modify your tree
                        </p>
                    </div>

                    <!-- Connection Info -->
                    <div style="background: var(--card-bg); padding: 16px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 16px;">
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 16px; font-size: 13px;">
                            <span style="color: var(--text-secondary);">Port:</span>
                            <span id="mcp-connected-port" style="font-family: monospace; color: var(--text-primary);">--</span>
                            <span style="color: var(--text-secondary);">Tab ID:</span>
                            <span id="mcp-connected-tabid" style="font-family: monospace; color: var(--text-primary); font-size: 11px;">--</span>
                        </div>
                    </div>

                    <!-- Activity Log -->
                    <details style="margin-bottom: 16px;">
                        <summary style="padding: 10px; cursor: pointer; font-weight: 600; color: var(--text-secondary); font-size: 13px; display: flex; align-items: center; gap: 6px;">
                            <span>ğŸ“‹</span> Recent Activity
                        </summary>
                        <div id="mcp-activity-log" style="max-height: 150px; overflow-y: auto; padding: 8px; background: var(--bg); border-radius: 6px; font-size: 11px; font-family: monospace; margin-top: 8px;">
                            <div style="color: var(--text-secondary);">No activity yet...</div>
                        </div>
                    </details>

                    <button onclick="window.disconnectMCPFromModal()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 8px; font-weight: 600; font-size: 14px; cursor: pointer;">
                        â¹ï¸ Disconnect
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- BUILD 614: Work Status Panel -->
    <div class="modal" id="work-status-modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px; max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header" style="background: linear-gradient(135deg, #3b82f6, #2563eb);">
                <span>âš¡ Work Status</span>
                <button class="modal-close" onclick="document.getElementById('work-status-modal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body" style="flex: 1; overflow-y: auto; padding: 20px;">
                <!-- Active Tasks -->
                <div style="margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: var(--text-primary); font-size: 14px; display: flex; align-items: center; gap: 8px;">
                        ğŸ”„ Active
                    </h4>
                    <div id="work-status-active-list">
                        <div style="color: var(--text-secondary); font-style: italic; padding: 12px;">No active tasks</div>
                    </div>
                </div>

                <!-- Completed & Inbox -->
                <div style="margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: var(--text-primary); font-size: 14px; display: flex; align-items: center; gap: 8px;">
                        âœ… Recent Activity
                    </h4>
                    <div id="work-status-completed-list">
                        <div style="color: var(--text-secondary); font-style: italic; padding: 12px;">No recent activity</div>
                    </div>
                </div>

                <!-- Session Stats -->
                <div style="padding: 12px; background: var(--bg); border-radius: 8px; font-size: 12px; color: var(--text-secondary);">
                    <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">ğŸ“Š Session Stats</div>
                    <div id="work-status-stats">
                        API Calls: 0 â€¢ Tokens: ~0k â€¢ Tasks: 0 â€¢ Avg: 0s
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- BUILD 615: Create Capability Modal -->
    <div class="modal" id="create-capability-modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #8b5cf6, #6d28d9);">
                <span>ğŸ” Create Capability</span>
                <button class="modal-close" onclick="document.getElementById('create-capability-modal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <p style="color: var(--text-secondary); font-size: 13px; margin: 0 0 20px 0;">
                    Define what Claude can do on a website using your existing browser session.
                </p>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; color: var(--text-primary); font-size: 13px; font-weight: 500; margin-bottom: 6px;">Capability Name</label>
                    <input type="text" id="cap-name" placeholder="e.g., Chase Balance" style="width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                </div>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; color: var(--text-primary); font-size: 13px; font-weight: 500; margin-bottom: 6px;">Website Domain</label>
                    <input type="text" id="cap-site" placeholder="e.g., chase.com" style="width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                </div>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; color: var(--text-primary); font-size: 13px; font-weight: 500; margin-bottom: 6px;">Goal (What to Accomplish)</label>
                    <input type="text" id="cap-goal" placeholder="e.g., Read checking account balance" style="width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                </div>

                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: var(--text-primary); font-size: 13px; font-weight: 500; margin-bottom: 8px;">Permissions (Phase 1: Read-Only)</label>
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 6px; color: var(--text-secondary); font-size: 13px;">
                            <input type="checkbox" id="cap-perm-read" checked disabled style="accent-color: #8b5cf6;">
                            Read (required)
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; color: var(--text-secondary); font-size: 13px;">
                            <input type="checkbox" id="cap-perm-navigate" checked disabled style="accent-color: #8b5cf6;">
                            Navigate (required)
                        </label>
                    </div>
                    <p style="color: var(--text-secondary); font-size: 11px; margin: 8px 0 0 0;">
                        âš ï¸ Phase 1 is read-only. Write permissions (fill_form, submit) coming in Phase 2.
                    </p>
                </div>

                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: var(--text-primary); font-size: 13px; font-weight: 500; margin-bottom: 6px;">Example Phrases (optional)</label>
                    <input type="text" id="cap-examples" placeholder="e.g., check my balance, bank balance, chase account" style="width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                    <p style="color: var(--text-secondary); font-size: 11px; margin: 4px 0 0 0;">
                        Comma-separated phrases that should trigger this capability
                    </p>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 12px; justify-content: flex-end; padding: 16px 20px; border-top: 1px solid var(--border);">
                <button class="btn" onclick="document.getElementById('create-capability-modal').style.display='none'" style="background: var(--bg);">Cancel</button>
                <button class="btn" onclick="submitCreateCapability()" style="background: linear-gradient(135deg, #8b5cf6, #6d28d9);">Create Capability</button>
            </div>
        </div>
    </div>

    <!-- BUILD 522: Agent Inbox Modal -->
    <div class="modal" id="inbox-modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px; max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header" style="background: linear-gradient(135deg, #8b5cf6, #7c3aed);">
                <span>ğŸ“¥ Agent Inbox</span>
                <button class="modal-close" onclick="document.getElementById('inbox-modal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body" style="flex: 1; overflow-y: auto; padding: 20px;">
                <!-- Active Tasks -->
                <div id="inbox-active-tasks" style="display: none; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: var(--text-primary); font-size: 14px; display: flex; align-items: center; gap: 8px;">
                        <div class="spinner" style="width: 14px; height: 14px; border-width: 2px;"></div>
                        Claude Code is working...
                    </h4>
                    <div id="inbox-active-list" style="background: var(--bg); padding: 12px; border-radius: 8px; font-size: 13px;">
                        <!-- Active task progress shown here -->
                    </div>
                </div>

                <!-- Proposed Operations -->
                <div id="inbox-proposed-ops">
                    <h4 style="margin: 0 0 12px 0; color: var(--text-primary); font-size: 14px;">Proposed Changes</h4>
                    <div id="inbox-items-list">
                        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                            <div style="font-size: 32px; margin-bottom: 12px;">ğŸ“­</div>
                            <p style="margin: 0;">No proposed changes</p>
                            <p style="margin: 8px 0 0 0; font-size: 12px;">When Claude Code completes tasks, proposed changes will appear here for your review.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- BUILD 268: Floating Collab Chat Box -->
    <!-- BUILD 272: Made draggable, removed onclick (handled in JS) -->
    <div id="floating-collab-chat" style="display: none; position: fixed; bottom: 20px; right: 20px; width: 320px; background: var(--card-bg); border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); border: 1px solid var(--border); z-index: 9999; overflow: hidden; font-family: inherit;">
        <!-- Header (draggable + click to toggle) -->
        <div id="floating-chat-header" style="cursor: move; padding: 12px 14px; background: linear-gradient(135deg, #f97316, #ea580c); display: flex; align-items: center; justify-content: space-between; user-select: none;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 8px; height: 8px; background: #10b981; border-radius: 50%; animation: watchPulse 2s ease-in-out infinite;"></div>
                <span style="font-weight: 600; color: white; font-size: 13px;">ğŸ”„ Live Session</span>
                <span id="floating-user-count" style="background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 10px; font-size: 11px; color: white;">1</span>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
                <span id="floating-unread-badge" style="display: none; background: #ef4444; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: 600;">0</span>
                <span id="floating-chat-toggle" style="color: white; font-size: 16px;">â–¼</span>
            </div>
        </div>
        <!-- Body (collapsible) -->
        <div id="floating-chat-body" style="max-height: 350px; overflow: hidden; transition: max-height 0.3s ease;">
            <!-- Collaborators -->
            <div style="padding: 10px 12px; border-bottom: 1px solid var(--border);">
                <div id="floating-collab-list" style="display: flex; flex-wrap: wrap; gap: 6px;">
                    <!-- Badges will be populated here -->
                </div>
            </div>
            <!-- Chat Messages -->
            <div id="floating-chat-messages" style="height: 160px; overflow-y: auto; padding: 10px 12px; background: var(--bg);">
                <div style="color: var(--text-secondary); text-align: center; padding: 50px 0; font-size: 12px;">No messages yet</div>
            </div>
            <!-- Chat Input -->
            <div style="padding: 10px 12px; border-top: 1px solid var(--border); display: flex; gap: 6px;">
                <input type="text" id="floating-chat-input" placeholder="Type a message..."
                    style="flex: 1; padding: 8px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 12px;"
                    onkeypress="if(event.key==='Enter') window.sendFloatingChatMessage()">
                <button onclick="window.sendFloatingChatMessage()" style="padding: 8px 12px; background: linear-gradient(135deg, #6366f1, #8b5cf6); border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600; font-size: 12px;">Send</button>
            </div>
            <!-- Session Controls -->
            <div style="padding: 8px 12px; border-top: 1px solid var(--border); display: flex; gap: 6px;">
                <!-- BUILD 322: Jitsi Voice Chat Button -->
                <button id="voice-chat-btn" onclick="window.startVoiceChat()" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 11px; font-weight: 600;" title="Start voice chat with collaborators">ğŸ™ï¸ Voice</button>
                <button onclick="document.getElementById('live-sync-modal').style.display='flex'" style="flex: 1; padding: 8px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); cursor: pointer; font-size: 11px;">âš™ï¸</button>
                <button onclick="window.leaveFirebaseSyncRoom()" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #ef4444, #dc2626); border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 11px; font-weight: 600;">Leave</button>
            </div>
        </div>
    </div>

    <!-- BUILD 325: Meeting Link Modal -->
    <div class="modal" id="meeting-link-modal" style="display: none;">
        <div class="modal-content" style="max-width: 480px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">
                <span>ğŸ“… Schedule Meeting Link</span>
                <button class="modal-close" onclick="window.closeMeetingModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <!-- Create Meeting Section -->
                <div id="meeting-create-section">
                    <div style="text-align: center; padding: 10px 0 20px;">
                        <div style="font-size: 40px; margin-bottom: 8px;">ğŸ“…</div>
                        <p style="margin: 0; font-size: 13px; color: var(--text-secondary);">
                            Create a meeting link to share via calendar invite.<br>
                            Guests get the full tree even before you arrive.
                        </p>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-size: 12px; font-weight: 600;">Meeting Name</label>
                        <input type="text" id="meeting-name-input" placeholder="e.g., CAPEX Review with Erwin"
                            style="width: 100%; padding: 12px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; box-sizing: border-box;">
                    </div>

                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-size: 12px; font-weight: 600;">Scheduled Time (optional)</label>
                        <input type="datetime-local" id="meeting-time-input"
                            style="width: 100%; padding: 12px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; box-sizing: border-box;">
                    </div>

                    <div style="margin-bottom: 20px; padding: 12px; background: var(--bg); border-radius: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer; font-size: 13px;">
                            <input type="checkbox" id="meeting-allow-edits" checked style="width: 16px; height: 16px;">
                            Allow guests to edit before I arrive
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer; font-size: 13px;">
                            <input type="checkbox" id="meeting-voice-prompt" checked style="width: 16px; height: 16px;">
                            Prompt for voice chat when ready
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px;">
                            <input type="checkbox" id="meeting-auto-backup" checked style="width: 16px; height: 16px;">
                            Auto-backup tree every 5 minutes
                        </label>
                    </div>

                    <button class="btn" onclick="window.createScheduledMeeting()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #6366f1, #8b5cf6); font-weight: 600; font-size: 15px;">
                        ğŸ”— Generate Meeting Link
                    </button>
                </div>

                <!-- Generated Link Section -->
                <div id="meeting-generated-section" style="display: none;">
                    <div style="text-align: center; padding: 20px 0;">
                        <div style="font-size: 48px; margin-bottom: 12px;">âœ…</div>
                        <h3 style="margin: 0 0 8px; color: var(--text-primary);">Meeting Link Ready!</h3>
                        <p style="margin: 0 0 20px; font-size: 13px; color: var(--text-secondary);">
                            Add this link to your Google Calendar invite
                        </p>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-size: 12px; font-weight: 600;">Meeting Link</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="meeting-link-url" readonly
                                style="flex: 1; padding: 12px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; font-family: monospace; font-size: 11px; color: var(--text-primary);">
                            <button class="btn" onclick="window.copyMeetingLink()" style="padding: 12px 16px; background: linear-gradient(135deg, #10b981, #059669);" title="Copy link">ğŸ“‹</button>
                        </div>
                    </div>

                    <div style="padding: 14px; background: rgba(99, 102, 241, 0.1); border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3); margin-bottom: 16px;">
                        <p style="margin: 0; font-size: 12px; color: var(--text-secondary);">
                            <strong style="color: var(--text-primary);">How it works:</strong><br>
                            1. Guests click the link â†’ tree loads instantly<br>
                            2. They can start editing while waiting for you<br>
                            3. When you click the link â†’ live session activates<br>
                            4. Everyone syncs automatically + voice prompt appears
                        </p>
                    </div>

                    <div style="display: flex; gap: 8px;">
                        <button class="btn" onclick="window.closeMeetingModal(); document.getElementById('live-sync-modal').style.display='flex';" style="flex: 1; padding: 12px; background: var(--card-bg); border: 1px solid var(--border);">
                            View Session
                        </button>
                        <button class="btn" onclick="window.closeMeetingModal()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #6366f1, #8b5cf6);">
                            Done
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- BUILD 325: Waiting Room Banner -->
    <div id="waiting-room-banner" style="display: none; position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; padding: 12px 20px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
        <div style="max-width: 1200px; margin: 0 auto; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px;">
            <div style="display: flex; align-items: center; gap: 12px;">
                <div style="font-size: 24px; animation: pulse 2s ease-in-out infinite;">â³</div>
                <div>
                    <div id="waiting-status" style="font-weight: 600; font-size: 14px;">Waiting for host to start the meeting...</div>
                    <div id="waiting-message" style="font-size: 12px; opacity: 0.9;">You can start editing - changes will sync when host arrives.</div>
                </div>
                <span id="waiting-timer" style="font-family: monospace; font-size: 13px; opacity: 0.8;"></span>
            </div>
            <div style="display: flex; gap: 8px;">
                <button onclick="window.downloadMeetingBackup('manual')" style="padding: 8px 14px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; color: white; cursor: pointer; font-size: 12px; font-weight: 600;">ğŸ’¾ Save Backup</button>
                <button onclick="window.location.href=window.location.pathname" style="padding: 8px 14px; background: rgba(239,68,68,0.8); border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 12px; font-weight: 600;">Leave</button>
            </div>
        </div>
    </div>

    <!-- BUILD 325: Voice Prompt Toast -->
    <div id="voice-prompt-toast" style="display: none; position: fixed; bottom: 100px; right: 20px; background: linear-gradient(135deg, #10b981, #059669); padding: 16px 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); z-index: 10001; color: white; max-width: 280px;">
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
            <span style="font-size: 24px;">ğŸ™ï¸</span>
            <div>
                <div style="font-weight: 600; font-size: 14px;">Ready for voice chat?</div>
                <div style="font-size: 12px; opacity: 0.9;">Host has joined the session</div>
            </div>
        </div>
        <div style="display: flex; gap: 8px;">
            <button onclick="window.acceptVoicePrompt()" style="flex: 1; padding: 10px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; color: white; cursor: pointer; font-weight: 600; font-size: 13px;">Join Voice</button>
            <button onclick="window.dismissVoicePrompt()" style="flex: 1; padding: 10px; background: transparent; border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; color: white; cursor: pointer; font-size: 13px;">Not now</button>
        </div>
    </div>

    <style>
        /* BUILD 325: Voice prompt animations */
        #voice-prompt-toast.slide-in {
            animation: slideInRight 0.3s ease-out;
        }
        #voice-prompt-toast.slide-out {
            animation: slideOutRight 0.3s ease-out;
        }
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>

    <!-- Hidden file input for JSON upload -->
    <input type="file" id="json-upload-input" accept=".json,.treelisty" style="display: none;" />

    <script>
        console.log('TreeListy - Universal Project Decomposition - Horizontal Layout with Pan/Zoom');

        // =============================================================================
        // LAZY LIBRARY LOADER - Load third-party libraries on-demand (Build 540)
        // =============================================================================
        const lazyLibraries = {
            xlsx: {
                url: 'https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js',
                loaded: false,
                check: () => typeof XLSX !== 'undefined'
            },
            lzstring: {
                url: 'https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js',
                loaded: false,
                check: () => typeof LZString !== 'undefined'
            },
            html2canvas: {
                url: 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js',
                loaded: false,
                check: () => typeof html2canvas !== 'undefined'
            },
            jszip: {
                url: 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js',
                loaded: false,
                check: () => typeof JSZip !== 'undefined'
            },
            fullcalendar: {
                url: 'https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js',
                loaded: false,
                check: () => typeof FullCalendar !== 'undefined'
            },
            threejs: {
                url: 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
                loaded: false,
                check: () => typeof THREE !== 'undefined'
            },
            orbitcontrols: {
                url: 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js',
                loaded: false,
                check: () => typeof THREE !== 'undefined' && typeof THREE.OrbitControls !== 'undefined'
            }
        };

        async function loadLibrary(name) {
            const lib = lazyLibraries[name];
            if (!lib) {
                console.error(`Unknown library: ${name}`);
                return Promise.reject(new Error(`Unknown library: ${name}`));
            }

            // Already loaded check
            if (lib.loaded || lib.check()) {
                lib.loaded = true;
                return Promise.resolve();
            }

            console.log(`[LazyLoad] Loading ${name}...`);

            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = lib.url;
                script.onload = () => {
                    lib.loaded = true;
                    console.log(`[LazyLoad] ${name} loaded successfully`);
                    resolve();
                };
                script.onerror = (e) => {
                    console.error(`[LazyLoad] Failed to load ${name}:`, e);
                    reject(new Error(`Failed to load ${name}`));
                };
                document.head.appendChild(script);
            });
        }

        // Helper to show loading indicator
        function showLibraryLoading(message) {
            showToast(message || 'Loading required library...', 'info');
        }

        // =============================================================================
        // SEMANTIC CHUNKING ENGINE (NLP + Vector Search)
        // =============================================================================

        /**
         * EmbeddingManager - Abstraction layer for embeddings from multiple providers
         */
        class EmbeddingManager {
            /**
             * Check if any embedding provider is available
             */
            static hasProvider() {
                const openaiKey = localStorage.getItem('openai_api_key');
                const geminiKey = localStorage.getItem('gemini_api_key');
                return !!(openaiKey || geminiKey);
            }

            /**
             * Get embeddings for an array of texts
             * @param {string[]} texts - Array of text strings to embed
             * @returns {Promise<number[][]>} Array of embedding vectors
             */
            static async getEmbeddings(texts) {
                if (!texts || texts.length === 0) {
                    throw new Error('No texts provided for embedding');
                }

                const openaiKey = localStorage.getItem('openai_api_key');
                const geminiKey = localStorage.getItem('gemini_api_key');

                // Try OpenAI first
                if (openaiKey) {
                    console.log(`ğŸ”¢ Getting embeddings from OpenAI (${texts.length} texts)`);
                    return await this._getOpenAIEmbeddings(texts, openaiKey);
                }

                // Fallback to Gemini
                if (geminiKey) {
                    console.log(`ğŸ”¢ Getting embeddings from Gemini (${texts.length} texts)`);
                    return await this._getGeminiEmbeddings(texts, geminiKey);
                }

                // No provider available
                console.warn('âš ï¸ No embedding provider available (OpenAI or Gemini API key required)');
                return null;
            }

            /**
             * OpenAI text-embedding-3-small
             */
            static async _getOpenAIEmbeddings(texts, apiKey) {
                const BATCH_SIZE = 20; // OpenAI limit
                const batches = [];

                for (let i = 0; i < texts.length; i += BATCH_SIZE) {
                    batches.push(texts.slice(i, i + BATCH_SIZE));
                }

                const allEmbeddings = [];

                for (const batch of batches) {
                    try {
                        const response = await fetch('https://api.openai.com/v1/embeddings', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                input: batch,
                                model: 'text-embedding-3-small'
                            })
                        });

                        if (!response.ok) {
                            const error = await response.text();
                            throw new Error(`OpenAI API error: ${error}`);
                        }

                        const data = await response.json();
                        const embeddings = data.data.map(item => item.embedding);
                        allEmbeddings.push(...embeddings);

                    } catch (error) {
                        console.error('OpenAI embedding error:', error);
                        throw error;
                    }
                }

                return allEmbeddings;
            }

            /**
             * Gemini text-embedding-004
             */
            static async _getGeminiEmbeddings(texts, apiKey) {
                const BATCH_SIZE = 20; // Conservative batch size
                const batches = [];

                for (let i = 0; i < texts.length; i += BATCH_SIZE) {
                    batches.push(texts.slice(i, i + BATCH_SIZE));
                }

                const allEmbeddings = [];

                for (const batch of batches) {
                    try {
                        // Gemini requires individual calls per text
                        const batchEmbeddings = await Promise.all(
                            batch.map(async (text) => {
                                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${apiKey}`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        content: {
                                            parts: [{ text: text }]
                                        }
                                    })
                                });

                                if (!response.ok) {
                                    const error = await response.text();
                                    throw new Error(`Gemini API error: ${error}`);
                                }

                                const data = await response.json();
                                return data.embedding.values;
                            })
                        );

                        allEmbeddings.push(...batchEmbeddings);

                    } catch (error) {
                        console.error('Gemini embedding error:', error);
                        throw error;
                    }
                }

                return allEmbeddings;
            }
        }

        /**
         * SemanticChunker - Rigorous semantic chunking with embedding-based breakpoints
         */
        class SemanticChunker {
            constructor() {
                this.DEFAULT_THRESHOLD = 0.7;
                this.PERCENTILE_THRESHOLD = 90;
            }

            /**
             * Calculate cosine similarity between two vectors
             * @param {number[]} vecA - First vector
             * @param {number[]} vecB - Second vector
             * @returns {number} Cosine similarity (0-1)
             */
            cosineSimilarity(vecA, vecB) {
                if (!vecA || !vecB || vecA.length !== vecB.length) {
                    throw new Error('Vectors must have same length');
                }

                let dotProduct = 0;
                let magnitudeA = 0;
                let magnitudeB = 0;

                for (let i = 0; i < vecA.length; i++) {
                    dotProduct += vecA[i] * vecB[i];
                    magnitudeA += vecA[i] * vecA[i];
                    magnitudeB += vecB[i] * vecB[i];
                }

                magnitudeA = Math.sqrt(magnitudeA);
                magnitudeB = Math.sqrt(magnitudeB);

                if (magnitudeA === 0 || magnitudeB === 0) {
                    return 0;
                }

                return dotProduct / (magnitudeA * magnitudeB);
            }

            /**
             * Calculate breakpoint threshold using percentile method
             * @param {number[]} distances - Array of cosine distances
             * @returns {number} Threshold value
             */
            calculateBreakpointThreshold(distances) {
                if (!distances || distances.length === 0) {
                    return this.DEFAULT_THRESHOLD;
                }

                // Sort distances
                const sorted = [...distances].sort((a, b) => a - b);

                // Find 90th percentile
                const index = Math.floor(sorted.length * (this.PERCENTILE_THRESHOLD / 100));
                const threshold = sorted[Math.min(index, sorted.length - 1)];

                console.log(`ğŸ“Š Calculated breakpoint threshold: ${threshold.toFixed(3)} (90th percentile)`);

                return threshold;
            }

            /**
             * Split text into sentences using robust regex
             * @param {string} text - Input text
             * @returns {string[]} Array of sentences
             */
            splitIntoSentences(text) {
                if (!text) return [];

                // Split on sentence boundaries (., !, ?) followed by whitespace and capital letter
                // or newline, but preserve acronyms (e.g., U.S.A.)
                const sentences = text
                    .replace(/([.!?])\s+(?=[A-Z])/g, '$1|SPLIT|')
                    .replace(/\n+/g, '|SPLIT|')
                    .split('|SPLIT|')
                    .map(s => s.trim())
                    .filter(s => s.length > 0);

                console.log(`âœ‚ï¸ Split into ${sentences.length} sentences`);
                return sentences;
            }

            /**
             * Structural fallback split (when embeddings unavailable)
             * @param {string} text - Input text
             * @returns {Array<{text: string, start: number, end: number}>} Array of chunks
             */
            structuralSplit(text) {
                console.log('ğŸ“ Using structural split (fallback mode)');

                const chunks = [];
                let currentChunk = '';
                let start = 0;

                // Split by Markdown headers first
                const headerRegex = /^(#{1,6})\s+(.+)$/gm;
                const parts = text.split(headerRegex);

                if (parts.length > 1) {
                    // Has headers - use them as boundaries
                    for (let i = 0; i < parts.length; i += 3) {
                        const content = parts[i] || '';
                        const headerLevel = parts[i + 1];
                        const headerText = parts[i + 2];

                        if (content.trim()) {
                            chunks.push({
                                text: content.trim(),
                                start: start,
                                end: start + content.length
                            });
                            start += content.length;
                        }

                        if (headerLevel && headerText) {
                            const header = `${headerLevel} ${headerText}`;
                            chunks.push({
                                text: header.trim(),
                                start: start,
                                end: start + header.length
                            });
                            start += header.length;
                        }
                    }
                } else {
                    // No headers - split by paragraphs
                    const paragraphs = text.split(/\n\n+/);

                    for (const para of paragraphs) {
                        if (para.trim()) {
                            chunks.push({
                                text: para.trim(),
                                start: start,
                                end: start + para.length
                            });
                            start += para.length;
                        }
                    }
                }

                // If still no chunks, split by lines
                if (chunks.length === 0) {
                    const lines = text.split(/\n/);
                    for (const line of lines) {
                        if (line.trim()) {
                            chunks.push({
                                text: line.trim(),
                                start: start,
                                end: start + line.length
                            });
                            start += line.length;
                        }
                    }
                }

                console.log(`âœ… Structural split: ${chunks.length} chunks`);
                return chunks;
            }

            /**
             * Core embedding-based chunking algorithm
             * @param {string} text - Input text
             * @returns {Promise<Array<{text: string, start: number, end: number}>>} Array of semantic chunks
             */
            async chunkByEmbedding(text) {
                console.log('ğŸ§  Starting embedding-based semantic chunking...');

                try {
                    // Step 1: Split into sentences
                    const sentences = this.splitIntoSentences(text);

                    if (sentences.length === 0) {
                        console.warn('âš ï¸ No sentences found');
                        return [{ text: text, start: 0, end: text.length }];
                    }

                    if (sentences.length === 1) {
                        console.log('Single sentence - no chunking needed');
                        return [{ text: text, start: 0, end: text.length }];
                    }

                    // Step 2: Create sliding window combinations (sentence + prev + next)
                    const windowedSentences = sentences.map((sentence, i) => {
                        const prev = i > 0 ? sentences[i - 1] : '';
                        const next = i < sentences.length - 1 ? sentences[i + 1] : '';
                        return `${prev} ${sentence} ${next}`.trim();
                    });

                    // Step 3: Get embeddings
                    console.log(`ğŸ“Š Getting embeddings for ${windowedSentences.length} windowed sentences...`);
                    const embeddings = await EmbeddingManager.getEmbeddings(windowedSentences);

                    if (!embeddings) {
                        console.warn('âš ï¸ Embeddings unavailable, falling back to structural split');
                        return this.structuralSplit(text);
                    }

                    // Step 4: Calculate cosine distances between adjacent sentences
                    const distances = [];
                    for (let i = 0; i < embeddings.length - 1; i++) {
                        const similarity = this.cosineSimilarity(embeddings[i], embeddings[i + 1]);
                        const distance = 1 - similarity; // Convert similarity to distance
                        distances.push(distance);
                    }

                    // Step 5: Calculate adaptive threshold
                    const threshold = this.calculateBreakpointThreshold(distances);

                    // Step 6: Identify breakpoints where distance > threshold
                    const breakpoints = [0]; // Start with first sentence
                    for (let i = 0; i < distances.length; i++) {
                        if (distances[i] > threshold) {
                            breakpoints.push(i + 1);
                            console.log(`ğŸ“ Breakpoint at sentence ${i + 1} (distance: ${distances[i].toFixed(3)})`);
                        }
                    }
                    breakpoints.push(sentences.length); // End with last sentence

                    // Step 7: Merge sentences between breakpoints into chunks
                    const chunks = [];
                    let charIndex = 0;

                    for (let i = 0; i < breakpoints.length - 1; i++) {
                        const startIdx = breakpoints[i];
                        const endIdx = breakpoints[i + 1];
                        const chunkSentences = sentences.slice(startIdx, endIdx);
                        const chunkText = chunkSentences.join(' ');

                        chunks.push({
                            text: chunkText,
                            start: charIndex,
                            end: charIndex + chunkText.length
                        });

                        charIndex += chunkText.length + 1; // +1 for space
                    }

                    console.log(`âœ… Semantic chunking complete: ${chunks.length} chunks (from ${sentences.length} sentences)`);
                    return chunks;

                } catch (error) {
                    console.error('âŒ Embedding-based chunking failed:', error);
                    console.log('Falling back to structural split');
                    return this.structuralSplit(text);
                }
            }
        }

        // =============================================================================
        // PAN & ZOOM SYSTEM
        // =============================================================================

        // Pan/Zoom state
        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startX = 0;
        let startY = 0;

        const MIN_ZOOM = 0.25;  // 25%
        const MAX_ZOOM = 3.0;   // 300%
        const ZOOM_STEP = 0.15; // 15% per click

        // Apply transform to tree
        function applyTransform() {
            const wrapper = document.getElementById('tree-transform-wrapper');
            if (wrapper) {
                wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
                updateZoomDisplay();
            }
        }

        // Update zoom level display
        function updateZoomDisplay() {
            const display = document.getElementById('zoom-level');
            if (display) {
                display.textContent = Math.round(zoomLevel * 100) + '%';
            }
        }

        // Zoom in
        function zoomIn() {
            if (zoomLevel < MAX_ZOOM) {
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
                applyTransform();
            }
        }

        // Zoom out
        function zoomOut() {
            if (zoomLevel > MIN_ZOOM) {
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
                applyTransform();
            }
        }

        // Reset view
        function resetZoom() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            applyTransform();
        }

        // Mouse wheel zoom - BUILD 410: Zoom toward cursor position
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY;

            // Get container and mouse position
            const container = document.getElementById('tree-container');
            const rect = container.getBoundingClientRect();

            // Mouse position relative to container
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Calculate the point in content space (before zoom)
            // This is where the mouse is pointing in the actual content
            const contentX = (mouseX - panX) / zoomLevel;
            const contentY = (mouseY - panY) / zoomLevel;

            // Apply zoom
            const oldZoom = zoomLevel;
            if (delta < 0) {
                // Scroll up = zoom in
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
            } else {
                // Scroll down = zoom out
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
            }

            // Adjust pan so the same content point stays under the cursor
            // New screen position of content point = contentX * newZoom + newPanX
            // We want this to equal mouseX, so: newPanX = mouseX - contentX * newZoom
            panX = mouseX - contentX * zoomLevel;
            panY = mouseY - contentY * zoomLevel;

            applyTransform();
        }

        // Mouse down - start panning
        function handleMouseDown(e) {
            // Don't pan if clicking on a node or button
            if (e.target.closest('.tree-node') || e.target.closest('button') || e.target.closest('.zoom-controls')) {
                return;
            }

            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;

            const container = document.getElementById('tree-container');
            const wrapper = document.getElementById('tree-transform-wrapper');
            container.classList.add('panning');
            if (wrapper) wrapper.classList.add('panning');  // BUILD 410: Disable transition during drag
        }

        // Mouse move - pan
        function handleMouseMove(e) {
            if (!isPanning) return;

            panX = e.clientX - startX;
            panY = e.clientY - startY;
            applyTransform();
        }

        // Mouse up - stop panning
        function handleMouseUp(e) {
            if (isPanning) {
                isPanning = false;
                const container = document.getElementById('tree-container');
                const wrapper = document.getElementById('tree-transform-wrapper');
                container.classList.remove('panning');
                if (wrapper) wrapper.classList.remove('panning');  // BUILD 410: Re-enable transition
            }
        }

        // Initialize pan/zoom after DOM loads
        function initPanZoom() {
            const container = document.getElementById('tree-container');

            // Zoom controls
            document.getElementById('zoom-in').addEventListener('click', zoomIn);
            document.getElementById('zoom-out').addEventListener('click', zoomOut);
            document.getElementById('zoom-reset').addEventListener('click', resetZoom);

            // Mouse wheel
            container.addEventListener('wheel', handleWheel, { passive: false });

            // Mouse drag
            container.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // BUILD 491: Pinch-to-zoom for mobile Tree View
            let treeTouchState = { initialDistance: 0, initialZoom: 1, isPinching: false, lastTouchX: 0, lastTouchY: 0 };

            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    treeTouchState.initialDistance = Math.hypot(dx, dy);
                    treeTouchState.initialZoom = zoomLevel;
                    treeTouchState.isPinching = true;
                } else if (e.touches.length === 1) {
                    // Single finger - check if not on a node (for panning)
                    if (!e.target.closest('.tree-node, button')) {
                        treeTouchState.lastTouchX = e.touches[0].clientX;
                        treeTouchState.lastTouchY = e.touches[0].clientY;
                        treeTouchState.isPinching = false;
                    }
                }
            }, { passive: false });

            container.addEventListener('touchmove', (e) => {
                if (treeTouchState.isPinching && e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const currentDistance = Math.hypot(dx, dy);
                    const scale = currentDistance / treeTouchState.initialDistance;
                    zoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, treeTouchState.initialZoom * scale));
                    applyTransform();
                } else if (e.touches.length === 1 && !treeTouchState.isPinching && !e.target.closest('.tree-node, button')) {
                    // Single finger pan
                    const deltaX = e.touches[0].clientX - treeTouchState.lastTouchX;
                    const deltaY = e.touches[0].clientY - treeTouchState.lastTouchY;
                    panX += deltaX;
                    panY += deltaY;
                    treeTouchState.lastTouchX = e.touches[0].clientX;
                    treeTouchState.lastTouchY = e.touches[0].clientY;
                    applyTransform();
                }
            }, { passive: false });

            container.addEventListener('touchend', () => {
                treeTouchState.isPinching = false;
            });

            // Prevent context menu on drag
            container.addEventListener('contextmenu', (e) => {
                if (isPanning) e.preventDefault();
            });

            console.log('âœ… Pan/Zoom initialized (with mobile pinch support)');
        }

        // =============================================================================
        // END PAN & ZOOM SYSTEM
        // =============================================================================

        // =============================================================================
        // AI TUNER - PERSONA PERSISTENCE
        // =============================================================================

        // Helper to get AI config with safe defaults
        function getAIConfig() {
            const defaults = {
                tone: 'neutral',        // neutral, critical, enthusiastic, socratic
                verbosity: 'concise',   // concise, balanced, verbose
                creativity: 0.5,        // 0.0 to 1.0 (maps to temperature)
                dialecticMode: false,   // Cognitive Citadel: force counter-arguments
                customInstructions: ''  // User override
            };

            // Merge saved config if it exists
            return { ...defaults, ...(capexTree.aiConfig || {}) };
        }

        // Apply persona tuning to system prompts
        function applyPersonaTuning(baseSystemPrompt) {
            const config = getAIConfig();
            let tuning = "";

            // 1. Tone Injection
            if (config.tone === 'critical') {
                tuning += "ROLE ADAPTATION: You are a ruthless Red Team critic. Challenge assumptions. Find flaws. Do not be polite.\n";
            } else if (config.tone === 'socratic') {
                tuning += "ROLE ADAPTATION: Do not give answers directly. Ask probing questions to guide the user to discover the solution themselves.\n";
            } else if (config.tone === 'enthusiastic') {
                tuning += "ROLE ADAPTATION: Be high-energy and encouraging. Focus on opportunities and 'yes, and' thinking. Use energizing language.\n";
            }
            // neutral = no injection

            // 2. Verbosity Injection
            if (config.verbosity === 'concise') {
                tuning += "OUTPUT STYLE: Be extremely brief. Use telegraphic style. No fluff. Bullet points preferred.\n";
            } else if (config.verbosity === 'verbose') {
                tuning += "OUTPUT STYLE: Be thorough and detailed. Explain reasoning fully. Provide comprehensive analysis with examples.\n";
            }
            // balanced = no injection

            // 3. DIALECTIC MODE (Cognitive Citadel)
            if (config.dialecticMode) {
                tuning += `
ğŸ›¡ï¸ DIALECTIC MODE ACTIVE:
Before responding to the user's request, you MUST:
1. Identify 2 hidden assumptions in their request
2. Generate 1 strong counter-argument or alternative perspective
3. Note 1 potential blind spot they may have

Present these briefly as "**ğŸ›¡ï¸ Considerations:**" (4-5 lines max), then proceed with the requested task.
Do not ask permissionâ€”just provide the critique, then help.
`;
            }

            // 4. User Override (HIGHEST PRIORITY)
            if (config.customInstructions && config.customInstructions.trim()) {
                tuning += `\nUSER PRIORITY INSTRUCTION: ${config.customInstructions.trim()}\n`;
            }

            // BUILD 260: Append specialist context to the BASE prompt (not prepend)
            // This makes it a natural extension of the persona, not a competing directive
            let enhancedBasePrompt = baseSystemPrompt;
            if (capexTree.specialistContext && capexTree.specialistContext.trim()) {
                enhancedBasePrompt += `\n\nFor this specific project, you have additional specialized expertise: ${capexTree.specialistContext.trim()}`;
            }

            // Prepend tuning to the enhanced base prompt
            if (tuning) {
                return `${tuning}\n${enhancedBasePrompt}`;
            }
            return enhancedBasePrompt;
        }

        // Open Project Settings Modal (Build 260, updated Build 262)
        function openProjectSettingsModal() {
            const modal = document.getElementById('project-settings-modal');

            // Populate fields with current values
            document.getElementById('project-name-input').value = capexTree.name || '';
            document.getElementById('project-description-input').value = capexTree.description || '';
            document.getElementById('project-specialist-context').value = capexTree.specialistContext || '';

            // Build 262: Render team displays
            renderHostDisplay();
            renderTeamList();

            modal.classList.add('open');

            // Focus on first field
            setTimeout(() => document.getElementById('project-name-input').focus(), 100);
        }

        // Save Project Settings (Build 260)
        function saveProjectSettings() {
            const newName = document.getElementById('project-name-input').value.trim();
            const newDescription = document.getElementById('project-description-input').value.trim();
            const newSpecialistContext = document.getElementById('project-specialist-context').value.trim();

            // Save state for undo
            saveState('Edit project settings');

            // Update tree root
            if (newName) capexTree.name = newName;
            capexTree.description = newDescription;
            capexTree.specialistContext = newSpecialistContext;

            // Close modal and re-render
            document.getElementById('project-settings-modal').classList.remove('open');
            render();

            // Show toast
            const hasSpecialist = newSpecialistContext ? ' with AI specialist context' : '';
            showToast(`Project settings saved${hasSpecialist}`, 'success');
        }

        // ==================== Build 262: Team Management ====================

        // Generate unique initials for a name, avoiding collisions with existing initials
        function generateUniqueInitials(name, existingInitials = []) {
            if (!name || !name.trim()) return '?';
            const cleanName = name.trim().toUpperCase();

            // Start with first letter
            let initials = cleanName.charAt(0);

            // If collision, add second letter
            if (existingInitials.includes(initials)) {
                initials = cleanName.substring(0, 2);
            }

            // If still collision, add third letter or number
            let counter = 1;
            while (existingInitials.includes(initials) && counter < 10) {
                if (cleanName.length > 2) {
                    initials = cleanName.substring(0, 3);
                } else {
                    initials = cleanName.charAt(0) + counter;
                }
                counter++;
            }

            return initials;
        }

        // Get all team members (host + collaborators + contributors)
        function getProjectTeam() {
            if (!capexTree.team) {
                capexTree.team = {
                    host: null,
                    collaborators: [],
                    contributors: []
                };
            }
            return capexTree.team;
        }

        // Recalculate all initials to ensure uniqueness
        function recalculateTeamInitials() {
            const team = getProjectTeam();
            const usedInitials = [];

            // Host first
            if (team.host) {
                team.host.initials = generateUniqueInitials(team.host.name, usedInitials);
                usedInitials.push(team.host.initials);
            }

            // Then collaborators
            for (const member of team.collaborators) {
                member.initials = generateUniqueInitials(member.name, usedInitials);
                usedInitials.push(member.initials);
            }

            // Then contributors
            for (const member of team.contributors) {
                member.initials = generateUniqueInitials(member.name, usedInitials);
                usedInitials.push(member.initials);
            }
        }

        // Add a new team member
        function addTeamMember() {
            const nameInput = document.getElementById('new-member-name');
            const emailInput = document.getElementById('new-member-email');
            const roleSelect = document.getElementById('new-member-role');

            const name = nameInput.value.trim();
            const email = emailInput.value.trim();
            const role = roleSelect.value;

            if (!name) {
                showToast('Please enter a name', 'error');
                nameInput.focus();
                return;
            }

            if (!email || !email.includes('@')) {
                showToast('Please enter a valid email', 'error');
                emailInput.focus();
                return;
            }

            const team = getProjectTeam();

            // Check for duplicate email
            const allMembers = [team.host, ...team.collaborators, ...team.contributors].filter(Boolean);
            if (allMembers.some(m => m.email.toLowerCase() === email.toLowerCase())) {
                showToast('This email is already on the team', 'error');
                return;
            }

            // Create new member
            const newMember = { name, email, initials: '' };

            if (role === 'collaborator') {
                team.collaborators.push(newMember);
            } else {
                team.contributors.push(newMember);
            }

            // Recalculate all initials
            recalculateTeamInitials();

            // Clear inputs
            nameInput.value = '';
            emailInput.value = '';

            // Re-render team list
            renderTeamList();

            showToast(`${name} added as ${role}`, 'success');
        }

        // Remove a team member
        function removeTeamMember(email, role) {
            const team = getProjectTeam();

            if (role === 'collaborator') {
                team.collaborators = team.collaborators.filter(m => m.email !== email);
            } else {
                team.contributors = team.contributors.filter(m => m.email !== email);
            }

            // Recalculate initials after removal
            recalculateTeamInitials();
            renderTeamList();

            showToast('Team member removed', 'success');
        }

        // Set the project host
        function setProjectHost() {
            const name = prompt('Enter host name:');
            if (!name || !name.trim()) return;

            const email = prompt('Enter host email:');
            if (!email || !email.includes('@')) {
                showToast('Please enter a valid email', 'error');
                return;
            }

            const team = getProjectTeam();
            team.host = { name: name.trim(), email: email.trim(), initials: '' };

            recalculateTeamInitials();
            renderTeamList();
            renderHostDisplay();

            showToast('Project host set', 'success');
        }

        // Render the host display in project settings
        function renderHostDisplay() {
            const team = getProjectTeam();
            const hostBadge = document.getElementById('host-badge');
            const hostName = document.getElementById('host-name');
            const hostEmail = document.getElementById('host-email');

            if (!hostBadge || !hostName || !hostEmail) return;

            if (team.host) {
                hostBadge.textContent = team.host.initials || '?';
                hostName.textContent = team.host.name;
                hostEmail.textContent = team.host.email;
            } else {
                hostBadge.textContent = '?';
                hostName.innerHTML = '<span style="color: var(--text-secondary); font-style: italic;">No host set</span> <button onclick="setProjectHost()" style="margin-left: 8px; padding: 4px 8px; background: var(--treeplex-primary); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Set Host</button>';
                hostEmail.textContent = '';
            }
        }

        // Render the team list in project settings
        function renderTeamList() {
            const team = getProjectTeam();
            const container = document.getElementById('project-team-list');
            if (!container) return;

            let html = '';

            // Collaborators
            if (team.collaborators.length > 0) {
                html += '<div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">ğŸ¤ Collaborators</div>';
                for (const member of team.collaborators) {
                    html += renderTeamMemberRow(member, 'collaborator');
                }
            }

            // Contributors
            if (team.contributors.length > 0) {
                html += '<div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); margin-top: 12px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">âœï¸ Contributors</div>';
                for (const member of team.contributors) {
                    html += renderTeamMemberRow(member, 'contributor');
                }
            }

            if (!html) {
                html = '<div style="text-align: center; padding: 16px; color: var(--text-secondary); font-size: 13px;">No team members yet. Add some above!</div>';
            }

            container.innerHTML = html;
        }

        // Render a single team member row
        function renderTeamMemberRow(member, role) {
            const badgeColor = role === 'collaborator' ?
                'linear-gradient(135deg, #3b82f6, #6366f1)' :
                'linear-gradient(135deg, #10b981, #059669)';

            return `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--item-bg); border: 1px solid var(--border); border-radius: 8px;">
                    <span style="width: 28px; height: 28px; background: ${badgeColor}; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 11px;" title="${member.email}">${member.initials}</span>
                    <span style="flex: 1; font-size: 14px;">${member.name}</span>
                    <span style="font-size: 11px; color: var(--text-secondary);">${member.email}</span>
                    <button onclick="removeTeamMember('${member.email}', '${role}')" style="padding: 4px 8px; background: transparent; border: 1px solid var(--border); border-radius: 4px; cursor: pointer; color: var(--text-secondary); font-size: 11px;" title="Remove">âœ•</button>
                </div>
            `;
        }

        // Get all team members as a flat array for contributor buttons
        function getAllTeamMembers() {
            const team = getProjectTeam();
            const members = [];

            if (team.host) members.push({ ...team.host, role: 'host' });
            team.collaborators.forEach(m => members.push({ ...m, role: 'collaborator' }));
            team.contributors.forEach(m => members.push({ ...m, role: 'contributor' }));

            return members;
        }

        // Generate contributor buttons HTML for the edit modal
        function generateContributorButtons() {
            const members = getAllTeamMembers();

            if (members.length === 0) {
                return '<span style="font-size: 11px; color: var(--text-secondary);">Add team members in Project Settings</span>';
            }

            return members.map(member => {
                const bgColor = member.role === 'host' ? 'linear-gradient(135deg, #ffc107, #ff9800)' :
                               member.role === 'collaborator' ? 'linear-gradient(135deg, #3b82f6, #6366f1)' :
                               'linear-gradient(135deg, #10b981, #059669)';
                const textColor = member.role === 'host' ? '#000' : 'white';

                return `<button type="button" onclick="document.getElementById('edit-contributor').value='${member.name}'" style="padding: 6px 12px; background: ${bgColor}; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; color: ${textColor}; font-weight: 500;" title="${member.email}">${member.initials}</button>`;
            }).join('');
        }

        // Populate watch mode team member buttons
        function populateWatchModeTeamButtons() {
            const container = document.getElementById('watch-name-container');
            if (!container) return;

            const members = getAllTeamMembers();
            const inputField = document.getElementById('watch-collaborator-name');

            // Clear existing buttons (keep only the input)
            const existingButtons = container.querySelectorAll('button');
            existingButtons.forEach(btn => btn.remove());

            // Add team member buttons
            members.forEach(member => {
                const bgColor = member.role === 'host' ? 'linear-gradient(135deg, #ffc107, #ff9800)' :
                               member.role === 'collaborator' ? 'linear-gradient(135deg, #3b82f6, #6366f1)' :
                               'linear-gradient(135deg, #10b981, #059669)';
                const textColor = member.role === 'host' ? '#000' : 'white';

                const btn = document.createElement('button');
                btn.type = 'button';
                btn.textContent = member.initials;
                btn.title = `${member.name} (${member.email})`;
                btn.style.cssText = `padding: 10px 16px; background: ${bgColor}; border: none; border-radius: 6px; cursor: pointer; color: ${textColor}; font-weight: bold; font-size: 12px;`;
                btn.onclick = () => {
                    if (inputField) inputField.value = member.name;
                };
                container.appendChild(btn);
            });

            // If no team members, show hint
            if (members.length === 0) {
                const hint = document.createElement('span');
                hint.style.cssText = 'font-size: 11px; color: var(--text-secondary); padding: 10px;';
                hint.textContent = 'Add team in Project Settings';
                container.appendChild(hint);
            }
        }

        // ==================== End Build 262 ====================

        // BUILD 328: Populate version display from single source of truth
        document.addEventListener('DOMContentLoaded', () => {
            const versionEl = document.getElementById('version-display');
            if (versionEl && window.TREELISTY_VERSION) {
                versionEl.textContent = window.TREELISTY_VERSION.full;
                versionEl.title = window.TREELISTY_VERSION.title;
            }
        });

        // BUILD 331: Dropdown Menu System with ARIA support
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize all dropdown menus
            document.querySelectorAll('.dropdown-menu').forEach(dropdown => {
                const trigger = dropdown.querySelector('.dropdown-menu-trigger');
                const content = dropdown.querySelector('.dropdown-menu-content');
                const items = dropdown.querySelectorAll('.dropdown-menu-item');

                if (!trigger || !content) return;

                // Toggle dropdown on trigger click
                trigger.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isOpen = content.classList.contains('open');

                    // Close all other dropdowns first
                    document.querySelectorAll('.dropdown-menu-content.open').forEach(d => {
                        d.classList.remove('open');
                        d.parentElement.querySelector('.dropdown-menu-trigger')?.setAttribute('aria-expanded', 'false');
                    });

                    // Toggle this dropdown
                    if (!isOpen) {
                        content.classList.add('open');
                        trigger.setAttribute('aria-expanded', 'true');
                        // Focus first item for keyboard nav
                        items[0]?.focus();
                    } else {
                        content.classList.remove('open');
                        trigger.setAttribute('aria-expanded', 'false');
                    }
                });

                // Keyboard navigation within dropdown
                content.addEventListener('keydown', (e) => {
                    const currentIndex = Array.from(items).indexOf(document.activeElement);

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        const nextIndex = (currentIndex + 1) % items.length;
                        items[nextIndex]?.focus();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        const prevIndex = (currentIndex - 1 + items.length) % items.length;
                        items[prevIndex]?.focus();
                    } else if (e.key === 'Escape') {
                        content.classList.remove('open');
                        trigger.setAttribute('aria-expanded', 'false');
                        trigger.focus();
                    } else if (e.key === 'Tab') {
                        // Allow tab to close dropdown and move focus naturally
                        content.classList.remove('open');
                        trigger.setAttribute('aria-expanded', 'false');
                    }
                });

                // Close dropdown when clicking menu items (after their handler runs)
                items.forEach(item => {
                    item.addEventListener('click', () => {
                        setTimeout(() => {
                            content.classList.remove('open');
                            trigger.setAttribute('aria-expanded', 'false');
                        }, 50);
                    });
                });
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.dropdown-menu')) {
                    document.querySelectorAll('.dropdown-menu-content.open').forEach(d => {
                        d.classList.remove('open');
                        d.parentElement.querySelector('.dropdown-menu-trigger')?.setAttribute('aria-expanded', 'false');
                    });
                }
            });

            // Close dropdowns on Escape key (global)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    document.querySelectorAll('.dropdown-menu-content.open').forEach(d => {
                        d.classList.remove('open');
                        d.parentElement.querySelector('.dropdown-menu-trigger')?.setAttribute('aria-expanded', 'false');
                    });
                }
            });
        });

        // BUILD 333: View Selector Dropdown - handles view switching
        document.addEventListener('DOMContentLoaded', () => {
            const viewIcons = { tree: 'ğŸŒ²', canvas: 'ğŸ¨', '3d': 'ğŸ§Š', gantt: 'ğŸ“Š', calendar: 'ğŸ“…' };
            const viewLabels = { tree: 'Tree', canvas: 'Canvas', '3d': '3D', gantt: 'Gantt', calendar: 'Calendar' };

            function updateViewDropdown(newView) {
                // Update trigger button to show current state
                const icon = document.getElementById('current-view-icon');
                const text = document.getElementById('current-view-text');
                if (icon) icon.textContent = viewIcons[newView] || 'ğŸŒ²';
                if (text) text.textContent = viewLabels[newView] || 'Tree';

                // Update checkmarks
                document.getElementById('tree-check').style.opacity = newView === 'tree' ? '1' : '0';
                document.getElementById('canvas-check').style.opacity = newView === 'canvas' ? '1' : '0';
                document.getElementById('3d-check').style.opacity = newView === '3d' ? '1' : '0';
                document.getElementById('gantt-check').style.opacity = newView === 'gantt' ? '1' : '0';
                document.getElementById('calendar-check').style.opacity = newView === 'calendar' ? '1' : '0';

                // Show/hide export option based on view
                const exportBtn = document.getElementById('export-canvas-btn');
                if (exportBtn) {
                    exportBtn.style.display = (newView === 'canvas') ? 'flex' : 'none';
                }
            }

            // Helper: Close Gantt view if active
            function closeGanttViewIfActive() {
                const viewGantt = document.getElementById('view-gantt');
                const toolbar = document.getElementById('gantt-toolbar');
                if (viewGantt && viewGantt.classList.contains('active')) {
                    viewGantt.classList.remove('active');
                    if (toolbar) toolbar.classList.remove('active');
                    return true;  // Was in Gantt view
                }
                return false;
            }

            // BUILD 494: Helper: Close Calendar view if active
            function closeCalendarViewIfActive() {
                const viewCalendar = document.getElementById('view-calendar');
                if (viewCalendar && viewCalendar.classList.contains('active')) {
                    viewCalendar.classList.remove('active');
                    return true;  // Was in Calendar view
                }
                return false;
            }

            // Tree View button
            document.getElementById('view-tree-btn')?.addEventListener('click', () => {
                if (typeof viewMode !== 'undefined' && viewMode !== 'tree') {
                    // Close Gantt view if active
                    if (viewMode === 'gantt') {
                        closeGanttViewIfActive();
                        const treeView = document.querySelector('.tree-view-container');
                        if (treeView) treeView.classList.remove('hidden');
                        viewMode = 'tree';
                        render();
                    } else if (viewMode === 'calendar') {
                        // BUILD 494: Close Calendar view
                        closeCalendarViewIfActive();
                        const treeView = document.querySelector('.tree-view-container');
                        if (treeView) treeView.classList.remove('hidden');
                        viewMode = 'tree';
                        render();
                    } else if (viewMode === 'canvas') {
                        // Call function directly (button may be hidden on mobile)
                        if (typeof toggleViewMode === 'function') toggleViewMode();
                    } else if (viewMode === '3d') {
                        if (typeof toggle3DView === 'function') toggle3DView();
                    }
                }
                updateViewDropdown('tree');
            });

            // Canvas View button
            document.getElementById('view-canvas-btn')?.addEventListener('click', () => {
                if (typeof viewMode !== 'undefined') {
                    // Close Gantt view if active
                    if (viewMode === 'gantt') {
                        closeGanttViewIfActive();
                        const treeView = document.querySelector('.tree-view-container');
                        if (treeView) treeView.classList.remove('hidden');
                        viewMode = 'tree';
                        // Now switch to canvas
                        if (typeof toggleViewMode === 'function') toggleViewMode();
                    } else if (viewMode === 'calendar') {
                        // BUILD 494: Close Calendar view then switch to canvas
                        closeCalendarViewIfActive();
                        const treeView = document.querySelector('.tree-view-container');
                        if (treeView) treeView.classList.remove('hidden');
                        viewMode = 'tree';
                        if (typeof toggleViewMode === 'function') toggleViewMode();
                    } else if (viewMode === 'tree') {
                        // Call function directly (button may be hidden on mobile)
                        if (typeof toggleViewMode === 'function') toggleViewMode();
                    } else if (viewMode === '3d') {
                        if (typeof toggle3DView === 'function') toggle3DView();
                        // After exiting 3D, we're in tree, so toggle again to go to canvas
                        setTimeout(() => {
                            if (typeof toggleViewMode === 'function') toggleViewMode();
                        }, 100);
                    }
                }
                updateViewDropdown('canvas');
            });

            // 3D View button
            document.getElementById('view-3d-btn')?.addEventListener('click', () => {
                if (typeof viewMode !== 'undefined' && viewMode !== '3d') {
                    // Close Gantt view if active
                    if (viewMode === 'gantt') {
                        closeGanttViewIfActive();
                        const treeView = document.querySelector('.tree-view-container');
                        if (treeView) treeView.classList.remove('hidden');
                        viewMode = 'tree';
                    }
                    // BUILD 494: Close Calendar view if active
                    if (viewMode === 'calendar') {
                        closeCalendarViewIfActive();
                        const treeView = document.querySelector('.tree-view-container');
                        if (treeView) treeView.classList.remove('hidden');
                        viewMode = 'tree';
                    }
                    // Call function directly (button may be hidden on mobile)
                    if (typeof toggle3DView === 'function') toggle3DView();
                }
                updateViewDropdown('3d');
            });

            // BUILD 457: Gantt View button
            document.getElementById('view-gantt-btn')?.addEventListener('click', () => {
                if (typeof viewMode !== 'undefined' && viewMode !== 'gantt') {
                    // BUILD 494: Close Calendar view if active
                    if (viewMode === 'calendar') {
                        closeCalendarViewIfActive();
                        const treeView = document.querySelector('.tree-view-container');
                        if (treeView) treeView.classList.remove('hidden');
                        viewMode = 'tree';
                    }
                    if (typeof toggleGanttView === 'function') {
                        toggleGanttView();
                    } else {
                        console.warn('Gantt view not yet implemented');
                        showToast('Gantt view coming soon!', 'info');
                    }
                }
                updateViewDropdown('gantt');
            });

            // BUILD 494: Calendar View button
            document.getElementById('view-calendar-btn')?.addEventListener('click', () => {
                if (typeof viewMode !== 'undefined' && viewMode !== 'calendar') {
                    if (typeof toggleCalendarView === 'function') {
                        toggleCalendarView();
                    } else {
                        console.warn('Calendar view not yet implemented');
                        showToast('Calendar view coming soon!', 'info');
                    }
                }
                updateViewDropdown('calendar');
            });

            // Expose update function globally so existing view toggle code can call it
            window.updateViewDropdown = updateViewDropdown;

            // Initialize based on current viewMode
            setTimeout(() => {
                if (typeof viewMode !== 'undefined') {
                    updateViewDropdown(viewMode);
                }
            }, 100);
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 414: SHARE VIEW STATE - Capture & restore view state for shared links
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Capture current view state for sharing
         * Returns object with current view type, canvas positions, expanded nodes, etc.
         */
        function captureViewState() {
            const state = {
                v: typeof viewMode !== 'undefined' ? viewMode : 'tree', // view type
                t: Date.now() // timestamp
            };

            // Capture selected node
            if (typeof activeNode !== 'undefined' && activeNode?.id) {
                state.s = activeNode.id; // selected
            }

            // Capture expanded nodes (tree view)
            const expandedNodes = [];
            document.querySelectorAll('.tree-node.expanded').forEach(node => {
                const nodeId = node.dataset?.id || node.querySelector('[data-id]')?.dataset?.id;
                if (nodeId) expandedNodes.push(nodeId);
            });
            if (expandedNodes.length > 0 && expandedNodes.length <= 50) {
                state.e = expandedNodes; // expanded
            }

            // Capture canvas positions if in canvas view
            if (state.v === 'canvas' && typeof canvasNodes !== 'undefined') {
                const positions = {};
                canvasNodes.forEach(({ data, element }) => {
                    if (data?.id && element) {
                        const rect = element.getBoundingClientRect();
                        const container = document.getElementById('canvas-container');
                        if (container) {
                            const containerRect = container.getBoundingClientRect();
                            positions[data.id] = {
                                x: Math.round(rect.left - containerRect.left),
                                y: Math.round(rect.top - containerRect.top)
                            };
                        }
                    }
                });
                if (Object.keys(positions).length > 0) {
                    state.p = positions; // positions
                }
            }

            // Capture canvas zoom/pan
            const canvasContainer = document.getElementById('canvas-container');
            if (canvasContainer) {
                const transform = canvasContainer.style.transform;
                if (transform) {
                    const scaleMatch = transform.match(/scale\(([\d.]+)\)/);
                    const translateMatch = transform.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
                    if (scaleMatch) state.z = parseFloat(scaleMatch[1]); // zoom
                    if (translateMatch) {
                        state.px = parseInt(translateMatch[1]); // pan x
                        state.py = parseInt(translateMatch[2]); // pan y
                    }
                }
            }

            return state;
        }
        window.captureViewState = captureViewState;

        /**
         * Encode view state with graceful degradation
         * Budget: 1500 bytes max for universal URL compatibility
         */
        function encodeViewState(state, budget = 1500) {
            // Priority levels for degradation
            // P0: view type, timestamp (~20 bytes) - never cut
            // P1: selected node (~30 bytes) - never cut
            // P2: zoom/pan (~20 bytes) - never cut
            // P3: expanded nodes (~10 bytes each) - cap at 20 if needed
            // P4: canvas positions (~15 bytes each) - first to cut

            let encoded = '';
            let currentState = { ...state };

            // Try full state first
            try {
                encoded = btoa(JSON.stringify(currentState));
                if (encoded.length <= budget) {
                    return encoded;
                }
            } catch (e) {
                console.warn('View state encoding failed:', e);
            }

            // Degradation step 1: Remove canvas positions
            if (currentState.p) {
                delete currentState.p;
                encoded = btoa(JSON.stringify(currentState));
                if (encoded.length <= budget) {
                    console.log('ğŸ“¦ View state: dropped canvas positions to fit budget');
                    return encoded;
                }
            }

            // Degradation step 2: Cap expanded nodes to 20
            if (currentState.e && currentState.e.length > 20) {
                currentState.e = currentState.e.slice(0, 20);
                encoded = btoa(JSON.stringify(currentState));
                if (encoded.length <= budget) {
                    console.log('ğŸ“¦ View state: capped expanded nodes to 20');
                    return encoded;
                }
            }

            // Degradation step 3: Remove expanded nodes entirely
            if (currentState.e) {
                delete currentState.e;
                encoded = btoa(JSON.stringify(currentState));
                if (encoded.length <= budget) {
                    console.log('ğŸ“¦ View state: dropped expanded nodes to fit budget');
                    return encoded;
                }
            }

            // Minimal state: just view type and selected
            const minimal = { v: state.v };
            if (state.s) minimal.s = state.s;
            encoded = btoa(JSON.stringify(minimal));
            console.log('ğŸ“¦ View state: using minimal (view + selection only)');
            return encoded;
        }
        window.encodeViewState = encodeViewState;

        /**
         * Decode view state from URL parameter
         */
        function decodeViewState(encoded) {
            if (!encoded) return null;
            try {
                return JSON.parse(atob(encoded));
            } catch (e) {
                console.warn('Failed to decode view state:', e);
                return null;
            }
        }
        window.decodeViewState = decodeViewState;

        /**
         * Generate share URL with current view state
         */
        function generateShareURL(baseParams = {}) {
            const state = captureViewState();
            const encoded = encodeViewState(state);

            let url = `${window.location.origin}${window.location.pathname}`;
            const params = [];

            // Add base params (room, session, etc.)
            Object.entries(baseParams).forEach(([key, value]) => {
                if (value) params.push(`${key}=${encodeURIComponent(value)}`);
            });

            // Add view state
            if (encoded) {
                params.push(`vs=${encoded}`);
            }

            // Add splash flag for shared links
            params.push('splash=1');

            if (params.length > 0) {
                url += '?' + params.join('&');
            }

            return url;
        }
        window.generateShareURL = generateShareURL;

        /**
         * Restore view state from decoded state object
         */
        async function restoreViewState(state) {
            if (!state) return;

            console.log('ğŸ¬ Restoring view state:', state);

            // Restore view type
            if (state.v && state.v !== 'tree') {
                if (state.v === 'canvas') {
                    document.getElementById('view-canvas-btn')?.click();
                } else if (state.v === '3d') {
                    document.getElementById('view-3d-btn')?.click();
                }
                // Wait for view transition
                await new Promise(r => setTimeout(r, 300));
            }

            // Restore expanded nodes
            if (state.e && Array.isArray(state.e)) {
                state.e.forEach(nodeId => {
                    const node = document.querySelector(`.tree-node[data-id="${nodeId}"]`);
                    if (node && !node.classList.contains('expanded')) {
                        const toggle = node.querySelector('.expand-toggle');
                        if (toggle) toggle.click();
                    }
                });
            }

            // Restore selected node
            if (state.s) {
                setTimeout(() => {
                    const node = document.querySelector(`.tree-node[data-id="${state.s}"]`);
                    if (node) {
                        node.click();
                        node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }

            // Restore canvas zoom/pan
            if (state.z || state.px || state.py) {
                const container = document.getElementById('canvas-container');
                if (container) {
                    const zoom = state.z || 1;
                    const px = state.px || 0;
                    const py = state.py || 0;
                    container.style.transform = `translate(${px}px, ${py}px) scale(${zoom})`;
                }
            }
        }
        window.restoreViewState = restoreViewState;

        /**
         * Play 3D cinematic splash animation (3 seconds)
         * Slow orbit around the tree before transitioning to target view
         */
        async function play3DSplash(onComplete) {
            console.log('ğŸ¬ Starting 3D cinematic splash...');

            // Switch to 3D view
            document.getElementById('view-3d-btn')?.click();
            await new Promise(r => setTimeout(r, 500)); // Wait for 3D to initialize

            // Get Three.js camera and controls
            const view3D = document.getElementById('view-3d');
            if (!view3D || !window.camera || !window.controls) {
                console.warn('3D view not available for splash');
                if (onComplete) onComplete();
                return;
            }

            // Disable user controls during animation
            if (window.controls) {
                window.controls.enabled = false;
            }

            // Cinematic orbit animation
            const startTime = Date.now();
            const duration = 3000; // 3 seconds
            const startAngle = 0;
            const endAngle = Math.PI * 0.75; // 135 degrees
            const radius = 1200;
            const height = 500;

            function animateOrbit() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease-in-out curve
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                const angle = startAngle + (endAngle - startAngle) * eased;

                // Update camera position (orbit)
                window.camera.position.x = Math.cos(angle) * radius;
                window.camera.position.z = Math.sin(angle) * radius;
                window.camera.position.y = height + Math.sin(progress * Math.PI) * 200; // Slight vertical arc
                window.camera.lookAt(0, 100, 0);

                if (progress < 1) {
                    requestAnimationFrame(animateOrbit);
                } else {
                    // Animation complete
                    console.log('ğŸ¬ Splash animation complete');
                    if (window.controls) {
                        window.controls.enabled = true;
                    }
                    if (onComplete) {
                        // Fade transition
                        view3D.style.transition = 'opacity 0.5s ease';
                        view3D.style.opacity = '0';
                        setTimeout(() => {
                            view3D.style.opacity = '1';
                            view3D.style.transition = '';
                            onComplete();
                        }, 500);
                    }
                }
            }

            requestAnimationFrame(animateOrbit);
        }
        window.play3DSplash = play3DSplash;

        /**
         * Handle shared link with view state on page load
         */
        function handleSharedViewState() {
            const urlParams = new URLSearchParams(window.location.search);
            const viewStateParam = urlParams.get('vs');
            const splashParam = urlParams.get('splash');

            if (!viewStateParam) return;

            const state = decodeViewState(viewStateParam);
            if (!state) return;

            console.log('ğŸ”— Shared link detected with view state:', state);

            // Wait for tree to load
            setTimeout(() => {
                if (splashParam === '1') {
                    // Play splash then restore view
                    play3DSplash(() => {
                        restoreViewState(state);
                    });
                } else {
                    // Restore view directly
                    restoreViewState(state);
                }
            }, 1000); // Give tree time to render
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(handleSharedViewState, 1500);
        });

        // BUILD 334: Mobile Detection & Touch Support
        document.addEventListener('DOMContentLoaded', () => {
            // Detect mobile device
            const isMobile = window.matchMedia('(max-width: 768px)').matches;
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

            if (isMobile) {
                console.log('ğŸ“± Mobile device detected - compact view enabled');
                document.body.classList.add('mobile-view');
                // BUILD 492: All views now enabled on mobile with pinch-to-zoom
                // Canvas, 3D, and Gantt views all work with touch gestures
            }

            // Long-press context menu for touch devices
            if (isTouchDevice) {
                let longPressTimer = null;
                let longPressTarget = null;

                document.addEventListener('touchstart', (e) => {
                    const node = e.target.closest('.tree-node');
                    if (!node) return;

                    longPressTarget = node;
                    node.classList.add('long-press-active');

                    longPressTimer = setTimeout(() => {
                        // Trigger context menu
                        node.classList.remove('long-press-active');

                        // Create a synthetic right-click event at touch position
                        const touch = e.touches[0];
                        const contextEvent = new MouseEvent('contextmenu', {
                            bubbles: true,
                            cancelable: true,
                            clientX: touch.clientX,
                            clientY: touch.clientY
                        });
                        node.dispatchEvent(contextEvent);

                        // Vibrate feedback if available
                        if (navigator.vibrate) navigator.vibrate(50);
                    }, 500); // 500ms long press
                }, { passive: true });

                document.addEventListener('touchend', () => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                    if (longPressTarget) {
                        longPressTarget.classList.remove('long-press-active');
                        longPressTarget = null;
                    }
                });

                document.addEventListener('touchmove', () => {
                    // Cancel long press if finger moves
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                    if (longPressTarget) {
                        longPressTarget.classList.remove('long-press-active');
                        longPressTarget = null;
                    }
                }, { passive: true });

                console.log('ğŸ‘† Touch device - long-press for context menu enabled');
            }

            // BUILD 335: Hamburger Menu Toggle
            const hamburgerBtn = document.getElementById('mobile-menu-btn');
            const controlsMenu = document.querySelector('.header .controls');
            const menuOverlay = document.getElementById('mobile-menu-overlay');

            function openMobileMenu() {
                hamburgerBtn?.classList.add('open');
                controlsMenu?.classList.add('mobile-menu-open');
                menuOverlay?.classList.add('visible');
                hamburgerBtn?.setAttribute('aria-expanded', 'true');
                document.body.style.overflow = 'hidden'; // Prevent scroll
                document.body.style.touchAction = 'none'; // Block touch on body
            }

            function closeMobileMenu() {
                hamburgerBtn?.classList.remove('open');
                controlsMenu?.classList.remove('mobile-menu-open');
                menuOverlay?.classList.remove('visible');
                hamburgerBtn?.setAttribute('aria-expanded', 'false');
                document.body.style.overflow = '';
                document.body.style.touchAction = '';
            }

            // BUILD 492: Prevent touch events from passing through overlay to tree
            if (menuOverlay) {
                menuOverlay.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    closeMobileMenu(); // Close on tap
                }, { passive: false });
                menuOverlay.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });
            }

            // BUILD 492: Ensure menu scroll works but doesn't pass through
            if (controlsMenu) {
                controlsMenu.addEventListener('touchmove', (e) => {
                    e.stopPropagation(); // Don't prevent - allow scrolling
                }, { passive: true });
            }

            if (hamburgerBtn) {
                hamburgerBtn.addEventListener('click', () => {
                    const isOpen = hamburgerBtn.classList.contains('open');
                    if (isOpen) {
                        closeMobileMenu();
                    } else {
                        openMobileMenu();
                    }
                });
            }

            // Close menu when clicking overlay
            if (menuOverlay) {
                menuOverlay.addEventListener('click', closeMobileMenu);
            }

            // Close menu when clicking action items (NOT dropdown triggers)
            // Only close for items that perform an action, not for opening submenus
            controlsMenu?.querySelectorAll('.dropdown-menu-item').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Delay close to allow button action to complete
                    setTimeout(closeMobileMenu, 150);
                });
            });

            // For regular buttons, only close if they're action buttons (not dropdown triggers)
            controlsMenu?.querySelectorAll('.btn:not(.dropdown-menu-trigger)').forEach(btn => {
                btn.addEventListener('click', () => {
                    setTimeout(closeMobileMenu, 150);
                });
            });

            // BUILD 491: Mobile Fullscreen Mode Toggle
            const fullscreenBtn = document.getElementById('mobile-fullscreen-btn');
            const fullscreenExitBtn = document.getElementById('fullscreen-exit-btn');

            function toggleMobileFullscreen() {
                const isFullscreen = document.body.classList.contains('mobile-fullscreen');
                if (isFullscreen) {
                    document.body.classList.remove('mobile-fullscreen');
                    // Try to exit native fullscreen if it was used
                    if (document.fullscreenElement) {
                        document.exitFullscreen?.();
                    }
                } else {
                    document.body.classList.add('mobile-fullscreen');
                    closeMobileMenu(); // Close menu if open
                    // Try native fullscreen for best experience
                    document.documentElement.requestFullscreen?.().catch(() => {
                        // Native fullscreen failed, soft fullscreen still works
                    });
                }
            }

            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', toggleMobileFullscreen);
            }
            if (fullscreenExitBtn) {
                fullscreenExitBtn.addEventListener('click', toggleMobileFullscreen);
            }

            // Listen for native fullscreen exit (Escape key, etc.)
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    document.body.classList.remove('mobile-fullscreen');
                }
            });

            // BUILD 493: Mobile Single-Pane Navigation (Tree â†” Info â†” Chat)
            // Full-screen panels with swipe navigation
            if ('ontouchstart' in window && window.innerWidth <= 768) {
                let swipeState = { startX: 0, startY: 0, isSwipe: false };
                const SWIPE_THRESHOLD = 80;
                const SWIPE_VERTICAL_LIMIT = 50;
                const SCREENS = ['tree', 'info', 'chat'];

                // Show navigation dots on mobile
                const navDots = document.getElementById('mobile-nav-dots');
                if (navDots) navDots.style.display = 'flex';

                // Get current screen: 0=tree, 1=info, 2=chat
                function getMobileScreen() {
                    const infoPanel = document.getElementById('info-panel');
                    const chatPanel = document.getElementById('chat-assistant-panel') || document.getElementById('command-frame');
                    if (chatPanel?.classList.contains('open')) return 2;
                    if (infoPanel?.classList.contains('open')) return 1;
                    return 0;
                }

                // Set current screen with animations
                function setMobileScreen(screenIndex) {
                    const infoPanel = document.getElementById('info-panel');
                    const chatPanel = document.getElementById('chat-assistant-panel') || document.getElementById('command-frame');

                    // Close all panels first
                    infoPanel?.classList.remove('open');
                    if (typeof chatState !== 'undefined' && chatState.isOpen) {
                        if (typeof toggleChatPanel === 'function') toggleChatPanel();
                    }

                    // Open target panel
                    if (screenIndex === 1) {
                        infoPanel?.classList.add('open');
                    } else if (screenIndex === 2) {
                        if (typeof chatState !== 'undefined' && !chatState.isOpen) {
                            if (typeof toggleChatPanel === 'function') toggleChatPanel();
                        }
                    }

                    // Update navigation dots
                    updateNavDots(screenIndex);
                    updateSwipeHints(screenIndex);
                }

                // Update nav dots UI
                function updateNavDots(activeIndex) {
                    const dots = document.querySelectorAll('.mobile-nav-dot');
                    dots.forEach((dot, i) => {
                        dot.classList.toggle('active', i === activeIndex);
                    });
                }

                // Update swipe hint indicators
                function updateSwipeHints(screenIndex) {
                    const leftHint = document.getElementById('swipe-hint-left');
                    const rightHint = document.getElementById('swipe-hint-right');

                    // Show left hint if can go back (not on tree)
                    leftHint?.classList.toggle('visible', screenIndex > 0);
                    // Show right hint if can go forward (not on chat)
                    rightHint?.classList.toggle('visible', screenIndex < 2);
                }

                // Nav dot click handler
                document.querySelectorAll('.mobile-nav-dot').forEach((dot, i) => {
                    dot.addEventListener('click', () => setMobileScreen(i));
                });

                // Swipe gesture handlers
                document.addEventListener('touchstart', (e) => {
                    const touchX = e.touches[0].clientX;
                    const touchY = e.touches[0].clientY;
                    const screenWidth = window.innerWidth;
                    const EDGE_ZONE = 50;

                    const isEdgeSwipe = touchX < EDGE_ZONE || touchX > screenWidth - EDGE_ZONE;

                    if (!isEdgeSwipe && e.target.closest('.modal, .dropdown-menu-content, .mobile-menu-open')) {
                        swipeState.isSwipe = false;
                        return;
                    }

                    swipeState.startX = touchX;
                    swipeState.startY = touchY;
                    swipeState.isSwipe = true;
                }, { passive: true });

                document.addEventListener('touchend', (e) => {
                    if (!swipeState.isSwipe) return;
                    swipeState.isSwipe = false;

                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const deltaX = endX - swipeState.startX;
                    const deltaY = endY - swipeState.startY;

                    if (Math.abs(deltaY) > SWIPE_VERTICAL_LIMIT) return;

                    const currentScreen = getMobileScreen();

                    if (deltaX < -SWIPE_THRESHOLD && currentScreen < 2) {
                        // Swipe left â†’ next screen
                        setMobileScreen(currentScreen + 1);
                    } else if (deltaX > SWIPE_THRESHOLD && currentScreen > 0) {
                        // Swipe right â†’ previous screen
                        setMobileScreen(currentScreen - 1);
                    }
                }, { passive: true });

                // Initialize hints for tree view
                updateSwipeHints(0);

                // Expose for external use
                window.setMobileScreen = setMobileScreen;
                window.getMobileScreen = getMobileScreen;

                console.log('ğŸ“± Mobile single-pane navigation enabled (Tree â†” Info â†” Chat)');
            }

        });

        // Initialize Project Settings Modal listeners
        document.addEventListener('DOMContentLoaded', () => {
            const cancelBtn = document.getElementById('project-settings-cancel');
            const saveBtn = document.getElementById('project-settings-save');

            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => {
                    document.getElementById('project-settings-modal').classList.remove('open');
                });
            }

            if (saveBtn) {
                saveBtn.addEventListener('click', saveProjectSettings);
            }

            // Close on background click
            const modal = document.getElementById('project-settings-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('open');
                    }
                });
            }
        });

        // Open AI Settings Modal
        function openAISettingsModal() {
            const modal = document.getElementById('ai-settings-modal');
            const config = getAIConfig();

            // Load current settings
            document.querySelector(`input[name="ai-tone"][value="${config.tone}"]`).checked = true;
            document.querySelector(`input[name="ai-verbosity"][value="${config.verbosity}"]`).checked = true;

            const creativityValue = Math.round(config.creativity * 100);
            document.getElementById('creativity-slider').value = creativityValue;
            document.getElementById('creativity-value').textContent = config.creativity.toFixed(1);

            document.getElementById('custom-instructions').value = config.customInstructions;
            
            // Load Dialectic Mode (Cognitive Citadel)
            document.getElementById('ai-dialectic-mode').checked = config.dialecticMode || false;

            // BUILD 396: Load Chat UI preference
            document.getElementById('use-classic-chat').checked = !window.useNewChatUI;

            // BUILD 488: Load Treebeard proactive hints preference
            const proactiveHints = localStorage.getItem('treebeardProactiveHints') !== 'false'; // Default true
            document.getElementById('treebeard-proactive-hints').checked = proactiveHints;

            // Update preview
            updateAIPreview();

            // BUILD 542: Update telemetry status
            updateTelemetryStatus();

            modal.style.display = 'flex';
        }

        // Close AI Settings Modal
        function closeAISettingsModal() {
            document.getElementById('ai-settings-modal').style.display = 'none';
        }

        // Update Live Preview
        function updateAIPreview() {
            const tone = document.querySelector('input[name="ai-tone"]:checked').value;
            const verbosity = document.querySelector('input[name="ai-verbosity"]:checked').value;
            const creativity = document.getElementById('creativity-slider').value / 100;
            const customInstructions = document.getElementById('custom-instructions').value;
            const dialecticMode = document.getElementById('ai-dialectic-mode').checked;

            // Build preview tuning
            let tuning = "";

            if (tone === 'critical') {
                tuning += "ROLE ADAPTATION: You are a ruthless Red Team critic. Challenge assumptions. Find flaws. Do not be polite.\n";
            } else if (tone === 'socratic') {
                tuning += "ROLE ADAPTATION: Do not give answers directly. Ask probing questions to guide the user to discover the solution themselves.\n";
            } else if (tone === 'enthusiastic') {
                tuning += "ROLE ADAPTATION: Be high-energy and encouraging. Focus on opportunities and 'yes, and' thinking. Use energizing language.\n";
            }

            if (verbosity === 'concise') {
                tuning += "OUTPUT STYLE: Be extremely brief. Use telegraphic style. No fluff. Bullet points preferred.\n";
            } else if (verbosity === 'verbose') {
                tuning += "OUTPUT STYLE: Be thorough and detailed. Explain reasoning fully. Provide comprehensive analysis with examples.\n";
            }

            if (dialecticMode) {
                tuning += "ğŸ›¡ï¸ DIALECTIC MODE: Identify assumptions and counter-arguments before helping.\n";
            }

            if (customInstructions.trim()) {
                tuning += `\nUSER PRIORITY INSTRUCTION: ${customInstructions.trim()}\n`;
            }

            const basePrompt = "You are an expert project manager specializing in breaking down complex tasks...";
            const finalPrompt = tuning ? `${tuning}\n${basePrompt}` : basePrompt;

            document.getElementById('preview-after').textContent = finalPrompt;
        }

        // Save AI Settings
        function saveAISettings() {
            const tone = document.querySelector('input[name="ai-tone"]:checked').value;
            const verbosity = document.querySelector('input[name="ai-verbosity"]:checked').value;
            const creativity = document.getElementById('creativity-slider').value / 100;
            const customInstructions = document.getElementById('custom-instructions').value;
            const dialecticMode = document.getElementById('ai-dialectic-mode').checked;

            // BUILD 396: Save Chat UI preference
            const useClassic = document.getElementById('use-classic-chat').checked;
            window.useNewChatUI = !useClassic;
            localStorage.setItem('useNewChatUI', String(!useClassic));

            // BUILD 488: Save Treebeard proactive hints preference
            const proactiveHints = document.getElementById('treebeard-proactive-hints').checked;
            localStorage.setItem('treebeardProactiveHints', String(proactiveHints));

            // Close any open chat panels if switching UI mode
            if (typeof chatState !== 'undefined' && chatState.isOpen) {
                if (typeof toggleChatPanel === 'function') toggleChatPanel();
            }

            // Save to tree
            capexTree.aiConfig = {
                tone,
                verbosity,
                creativity,
                dialecticMode,
                customInstructions
            };

            // Persist to localStorage
            if (typeof treeManager !== 'undefined') { treeManager.markAsChanged(); }

            console.log('âœ… AI Settings saved:', capexTree.aiConfig);

            // Show toast notification
            const uiMode = window.useNewChatUI ? 'Command Frame' : 'Classic Panel';
            showToast(`âœ… AI Settings Saved - Chat UI: ${uiMode}`);

            closeAISettingsModal();
        }

        // Reset to Defaults
        function resetAISettings() {
            document.querySelector('input[name="ai-tone"][value="neutral"]').checked = true;
            document.querySelector('input[name="ai-verbosity"][value="concise"]').checked = true;
            document.getElementById('creativity-slider').value = 50;
            document.getElementById('creativity-value').textContent = '0.5';
            document.getElementById('custom-instructions').value = '';
            document.getElementById('ai-dialectic-mode').checked = false;

            updateAIPreview();
        }

        // BUILD 542: Telemetry UI Functions
        function updateTelemetryStatus() {
            const statusEl = document.getElementById('telemetry-status');
            const checkbox = document.getElementById('telemetry-enabled');
            if (!statusEl) return;

            checkbox.checked = TELEMETRY.hasConsent();

            if (TELEMETRY.hasConsent()) {
                const summary = TELEMETRY.getSummary();
                const shortcutRate = TELEMETRY.getShortcutDiscoveryRate();
                statusEl.innerHTML = `
                    <div style="color: #6ee7b7;">âœ… Telemetry enabled</div>
                    <div style="margin-top: 6px;">
                        ğŸ“Š ${summary.totalEvents} events tracked across ${summary.sessionCount} sessions
                        <br>âŒ¨ï¸ Shortcut usage: ${shortcutRate}% of interactions
                    </div>
                `;
            } else {
                statusEl.innerHTML = `
                    <div style="color: rgba(255,255,255,0.5);">ğŸ“Š Telemetry disabled - no data being collected</div>
                `;
            }
        }

        function exportTelemetryData() {
            const data = TELEMETRY.exportData();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `treelisty-telemetry-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('ğŸ“¥ Telemetry data exported', 'success');
        }

        function deleteTelemetryData() {
            if (confirm('Are you sure you want to delete all telemetry data? This cannot be undone.')) {
                TELEMETRY.deleteAllData();
                updateTelemetryStatus();
                showToast('ğŸ—‘ï¸ All telemetry data deleted', 'success');
            }
        }

        // Event Listeners for AI Settings Modal
        window.addEventListener('DOMContentLoaded', () => {
            // AI Settings button
            const aiSettingsBtn = document.getElementById('ai-settings-btn');
            if (aiSettingsBtn) {
                aiSettingsBtn.addEventListener('click', openAISettingsModal);
            }

            // Tone radio buttons
            const toneRadios = document.querySelectorAll('input[name="ai-tone"]');
            toneRadios.forEach(radio => {
                radio.addEventListener('change', updateAIPreview);
            });

            // Verbosity radio buttons
            const verbosityRadios = document.querySelectorAll('input[name="ai-verbosity"]');
            verbosityRadios.forEach(radio => {
                radio.addEventListener('change', updateAIPreview);
            });

            // Creativity slider
            const slider = document.getElementById('creativity-slider');
            if (slider) {
                slider.addEventListener('input', (e) => {
                    const value = (e.target.value / 100).toFixed(1);
                    document.getElementById('creativity-value').textContent = value;
                    updateAIPreview();
                });
            }

            // Custom instructions
            const customInstructions = document.getElementById('custom-instructions');
            if (customInstructions) {
                customInstructions.addEventListener('input', updateAIPreview);
            }

            // Dialectic Mode checkbox (Cognitive Citadel)
            const dialecticCheckbox = document.getElementById('ai-dialectic-mode');
            if (dialecticCheckbox) {
                dialecticCheckbox.addEventListener('change', updateAIPreview);
            }

            // Pattern selector - handle pattern switching with translation
            const patternSelect = document.getElementById('pattern-select');
            if (patternSelect) {
                patternSelect.addEventListener('change', (e) => {
                    const oldPattern = currentPattern;
                    const newPattern = e.target.value;

                    // Check if a translation rule exists
                    const ruleKey = `${oldPattern}->${newPattern}`;
                    if (TRANSLATION_RULES[ruleKey]) {
                        const patternNames = {
                            generic: 'Generic Project',
                            sales: 'Sales Pipeline',
                            thesis: 'Academic Writing',
                            roadmap: 'Product Roadmap',
                            book: 'Book Writing',
                            film: 'Film Production',
                            veo3: 'Veo3 (Google)',
                            sora2: 'Sora2 (OpenAI)',
                            prompting: 'AI Prompt Design',
                            gmail: 'Gmail Threads',
                            eventplanning: 'Event Planning',
                            fitness: 'Fitness Program',
                            strategy: 'Strategy Consulting',
                            coursedesign: 'Course Design',
                            familytree: 'Family Tree',
                            philosophy: 'Philosophy Dialogue',
                            rhetoric: 'Rhetoric Analysis',
                            filesystem: 'Filesystem',
                            capex: 'CAPEX / Angel Pitch'
                        };

                        const confirmTranslation = confirm(
                            `âœ¨ Translate data from ${patternNames[oldPattern] || oldPattern} to ${patternNames[newPattern] || newPattern}?\n\n` +
                            `This will intelligently map fields (e.g., Cost â†’ Deal Value).\n\n` +
                            `Your original data will be preserved in shadow storage and can be restored.`
                        );

                        if (confirmTranslation) {
                            // Save state for undo
                            saveState(`Pattern Switch: ${oldPattern} â†’ ${newPattern}`);

                            // Apply translation
                            translateTree(oldPattern, newPattern);

                            // Update current pattern
                            currentPattern = newPattern;

                            // Re-render
                            render();

                            // Update cluster-by options for new pattern
                            if (typeof updateClusterByOptions === 'function') {
                                updateClusterByOptions();
                            }

                            showToast('âœ… Data translated successfully', `Fields mapped from ${patternNames[oldPattern]} to ${patternNames[newPattern]}`);
                        } else {
                            // User cancelled - revert dropdown
                            e.target.value = oldPattern;
                        }
                    } else {
                        // No translation rule - just switch pattern
                        saveState(`Pattern Switch: ${oldPattern} â†’ ${newPattern}`);
                        currentPattern = newPattern;
                        render();

                        // Update cluster-by options for new pattern
                        if (typeof updateClusterByOptions === 'function') {
                            updateClusterByOptions();
                        }
                    }
                });
            }
        });

        // =============================================================================
        // END AI TUNER
        // =============================================================================

        // =============================================================================
        // PATTERN TRANSLATION ENGINE - Shadow Data Preservation
        // =============================================================================

        // Translation rules: Map fields from one pattern to another
        const TRANSLATION_RULES = {
            'generic->sales': (item) => {
                const updates = {};

                // 1. Map Cost â†’ Deal Value
                if (item.cost !== undefined && item.cost !== null) {
                    updates.dealValue = item.cost;
                }

                // 2. Map Status â†’ Stage Probability (Heuristic)
                if (item.pmStatus) {
                    if (item.pmStatus === 'Done' || item.pmStatus === 'Completed') {
                        updates.stageProbability = 100;
                    } else if (item.pmStatus === 'In Progress') {
                        updates.stageProbability = 60;
                    } else {
                        updates.stageProbability = 10;
                    }
                }

                // 3. Map Lead Time â†’ Notes (preserve as context)
                if (item.leadTime) {
                    updates.notes = (item.notes || '') + `\n[Original Lead Time: ${item.leadTime}]`;
                }

                // 4. Map Owner Email â†’ Contact Person
                if (item.pmOwnerEmail) {
                    updates.contactPerson = item.pmOwnerEmail;
                }

                // 5. Map Description
                if (item.description) {
                    updates.description = item.description;
                }

                return updates;
            },

            'sales->generic': (item) => {
                const updates = {};

                // Reverse mapping: Sales â†’ Generic
                if (item.dealValue !== undefined && item.dealValue !== null) {
                    updates.cost = item.dealValue;
                }

                if (item.stageProbability !== undefined) {
                    if (item.stageProbability >= 90) {
                        updates.pmStatus = 'Done';
                    } else if (item.stageProbability >= 50) {
                        updates.pmStatus = 'In Progress';
                    } else {
                        updates.pmStatus = 'Not Started';
                    }
                }

                if (item.contactPerson) {
                    updates.pmOwnerEmail = item.contactPerson;
                }

                return updates;
            }
        };

        // Recursively translate a node and its children
        function translateNode(node, fromPattern, toPattern) {
            const ruleKey = `${fromPattern}->${toPattern}`;
            const translator = TRANSLATION_RULES[ruleKey];

            if (!translator) {
                console.log(`âš ï¸ No translation rule for ${ruleKey}`);
                return; // No rule exists
            }

            // 1. Initialize shadow storage if missing
            if (!node.shadowData) {
                node.shadowData = {};
            }

            // 2. Backup current pattern data (only fields being translated)
            if (!node.shadowData[fromPattern]) {
                node.shadowData[fromPattern] = {};
                // Store only fields that will be changed
                const updates = translator(node);
                Object.keys(updates).forEach(key => {
                    if (node[key] !== undefined) {
                        node.shadowData[fromPattern][key] = node[key];
                    }
                });
            }

            // 3. Apply translation updates
            const updates = translator(node);
            Object.assign(node, updates);

            console.log(`âœ… Translated node: ${node.name}`, updates);

            // 4. Process children recursively
            if (node.items) {
                node.items.forEach(child => translateNode(child, fromPattern, toPattern));
            }
            if (node.children) {
                node.children.forEach(child => translateNode(child, fromPattern, toPattern));
            }
            if (node.subItems) {
                node.subItems.forEach(child => translateNode(child, fromPattern, toPattern));
            }
        }

        // Translate entire tree
        function translateTree(fromPattern, toPattern) {
            console.log(`ğŸ”„ Starting tree translation: ${fromPattern} â†’ ${toPattern}`);

            // Start from root's children (phases)
            if (capexTree.children) {
                capexTree.children.forEach(phase => {
                    translateNode(phase, fromPattern, toPattern);
                });
            }

            console.log(`âœ… Tree translation complete`);
        }

        // =============================================================================
        // END PATTERN TRANSLATION ENGINE
        // =============================================================================

        // =============================================================================
        // REAL AI INTEGRATION - Claude by Anthropic (via Netlify Function)
        // =============================================================================

        // API Configuration - Supports both local API key and Netlify serverless function
        const AI_CONFIG = {
            provider: 'anthropic',
            get model() {
                // Dynamic model selection - user can choose Haiku (fast) or Sonnet (best)
                return getClaudeModelId();
            },
            // Netlify function endpoint (fallback)
            apiEndpoint: 'https://treelisty.netlify.app/.netlify/functions/claude-proxy',
            // Direct Anthropic API endpoint (when using local API key)
            directEndpoint: 'https://api.anthropic.com/v1/messages'
        };

        // Multi-provider API key management
        function getLocalAPIKey(provider = 'anthropic') {
            return localStorage.getItem(`${provider}_api_key`);
        }

        function setLocalAPIKey(key, provider = 'anthropic') {
            localStorage.setItem(`${provider}_api_key`, key);
        }

        function clearLocalAPIKey(provider = 'anthropic') {
            localStorage.removeItem(`${provider}_api_key`);
        }

        // Get AI provider preference
        function getAIProvider() {
            return localStorage.getItem('ai_provider') || 'anthropic';
        }

        function setAIProvider(provider) {
            localStorage.setItem('ai_provider', provider);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 542: TELEMETRY SYSTEM (Opt-in, Privacy-Safe, Local-First)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Part of v1.4 "Truth Engine" initiative. Enables validation of hypotheses
        // like "shortcut discovery <20%" and "intent accuracy ~70%".
        //
        // Privacy contract:
        // - Opt-in only (explicit consent required)
        // - No PII collected
        // - Local-first (localStorage)
        // - Clear "delete all data" option
        // - Anonymous session IDs only
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const TELEMETRY = {
            VERSION: '1.0',
            STORAGE_KEY: 'treelisty_telemetry',
            CONSENT_KEY: 'treelisty_telemetry_consent',
            SESSION_KEY: 'treelisty_session_id',
            MAX_EVENTS: 1000, // Keep last 1000 events to prevent storage bloat

            // Event types we track
            EVENTS: {
                COMMAND_INVOKED: 'command_invoked',
                VIEW_SWITCHED: 'view_switched',
                ERROR_OCCURRED: 'error_occurred',
                SHORTCUT_USED: 'shortcut_used',
                PATTERN_SELECTED: 'pattern_selected',
                SESSION_START: 'session_start',
                FIRST_TREE_CREATED: 'first_tree_created',
                AI_RESPONSE: 'ai_response',
                FEATURE_DISCOVERED: 'feature_discovered'
            },

            // Check if user has consented to telemetry
            hasConsent() {
                return localStorage.getItem(this.CONSENT_KEY) === 'true';
            },

            // Set consent status
            setConsent(consented) {
                localStorage.setItem(this.CONSENT_KEY, consented ? 'true' : 'false');
                if (consented) {
                    this.track(this.EVENTS.SESSION_START, { consent_given: true });
                }
            },

            // Get or create anonymous session ID
            getSessionId() {
                let sessionId = sessionStorage.getItem(this.SESSION_KEY);
                if (!sessionId) {
                    sessionId = 'sess_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
                    sessionStorage.setItem(this.SESSION_KEY, sessionId);
                }
                return sessionId;
            },

            // Core tracking function
            track(eventType, data = {}) {
                if (!this.hasConsent()) return;

                const event = {
                    type: eventType,
                    timestamp: new Date().toISOString(),
                    session: this.getSessionId(),
                    build: TREELISTY_VERSION?.build || 0,
                    view: typeof viewMode !== 'undefined' ? viewMode : 'unknown',
                    pattern: capexTree?.pattern?.key || 'unknown',
                    ...data
                };

                // Get existing events
                const events = this.getEvents();
                events.push(event);

                // Trim to max events
                if (events.length > this.MAX_EVENTS) {
                    events.splice(0, events.length - this.MAX_EVENTS);
                }

                // Save back
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(events));

                // Debug logging (can be disabled)
                if (localStorage.getItem('telemetry_debug') === 'true') {
                    console.log('ğŸ“Š Telemetry:', eventType, data);
                }
            },

            // Get all stored events
            getEvents() {
                try {
                    return JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '[]');
                } catch {
                    return [];
                }
            },

            // Get summary statistics
            getSummary() {
                const events = this.getEvents();
                const summary = {
                    totalEvents: events.length,
                    byType: {},
                    commandUsage: {},
                    shortcutUsage: {},
                    viewUsage: {},
                    errorTypes: {},
                    sessions: new Set(),
                    firstEvent: events[0]?.timestamp,
                    lastEvent: events[events.length - 1]?.timestamp
                };

                events.forEach(e => {
                    // Count by type
                    summary.byType[e.type] = (summary.byType[e.type] || 0) + 1;

                    // Track sessions
                    if (e.session) summary.sessions.add(e.session);

                    // Command usage
                    if (e.type === this.EVENTS.COMMAND_INVOKED && e.command) {
                        summary.commandUsage[e.command] = (summary.commandUsage[e.command] || 0) + 1;
                    }

                    // Shortcut usage
                    if (e.type === this.EVENTS.SHORTCUT_USED && e.key) {
                        summary.shortcutUsage[e.key] = (summary.shortcutUsage[e.key] || 0) + 1;
                    }

                    // View usage
                    if (e.type === this.EVENTS.VIEW_SWITCHED && e.to) {
                        summary.viewUsage[e.to] = (summary.viewUsage[e.to] || 0) + 1;
                    }

                    // Error types
                    if (e.type === this.EVENTS.ERROR_OCCURRED && e.errorType) {
                        summary.errorTypes[e.errorType] = (summary.errorTypes[e.errorType] || 0) + 1;
                    }
                });

                summary.sessionCount = summary.sessions.size;
                delete summary.sessions; // Don't expose set

                return summary;
            },

            // Get top N commands
            getTopCommands(n = 10) {
                const summary = this.getSummary();
                return Object.entries(summary.commandUsage)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, n);
            },

            // Get shortcut discovery rate
            getShortcutDiscoveryRate() {
                const events = this.getEvents();
                const shortcutEvents = events.filter(e => e.type === this.EVENTS.SHORTCUT_USED).length;
                const commandEvents = events.filter(e => e.type === this.EVENTS.COMMAND_INVOKED).length;
                const total = shortcutEvents + commandEvents;
                return total > 0 ? (shortcutEvents / total * 100).toFixed(1) : 0;
            },

            // Delete all telemetry data
            deleteAllData() {
                localStorage.removeItem(this.STORAGE_KEY);
                localStorage.removeItem(this.CONSENT_KEY);
                sessionStorage.removeItem(this.SESSION_KEY);
                console.log('ğŸ—‘ï¸ All telemetry data deleted');
            },

            // Export data as JSON (for user transparency)
            exportData() {
                return {
                    version: this.VERSION,
                    exportedAt: new Date().toISOString(),
                    consent: this.hasConsent(),
                    events: this.getEvents(),
                    summary: this.getSummary()
                };
            },

            // Show consent modal
            showConsentModal() {
                const modal = document.getElementById('telemetry-consent-modal');
                if (modal) modal.style.display = 'flex';
            },

            // Check if should prompt for consent (first time user)
            shouldPromptConsent() {
                return localStorage.getItem(this.CONSENT_KEY) === null;
            }
        };

        // Convenience tracking functions
        function trackCommand(command, success = true, context = {}) {
            TELEMETRY.track(TELEMETRY.EVENTS.COMMAND_INVOKED, {
                command,
                success,
                ...context
            });
        }

        function trackShortcut(key, action) {
            TELEMETRY.track(TELEMETRY.EVENTS.SHORTCUT_USED, { key, action });
        }

        function trackViewSwitch(from, to) {
            TELEMETRY.track(TELEMETRY.EVENTS.VIEW_SWITCHED, { from, to });
        }

        function trackError(errorType, message, context = {}) {
            TELEMETRY.track(TELEMETRY.EVENTS.ERROR_OCCURRED, {
                errorType,
                message: message?.substring(0, 200), // Truncate for privacy
                ...context
            });
        }

        function trackAIResponse(success, duration, mode = 'quick') {
            TELEMETRY.track(TELEMETRY.EVENTS.AI_RESPONSE, {
                success,
                duration,
                mode
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // OPTIMIZED MODEL SELECTION FOR IMPORT/APPEND (A/B tested results)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Based on extensive A/B testing comparing Claude Sonnet, Opus, Gemini Flash,
        // Gemini Pro, and GPT-4o across CAPEX and Philosophy patterns.
        //
        // Results showed +13.9% improvement using pattern-specific models vs single model
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const OPTIMIZED_IMPORT_MODELS = {
            // Philosophy patterns: Claude Opus excels at scholarly analysis, cross-references
            philosophy: {
                provider: 'anthropic',
                model: 'claude-opus-4-20250514',
                name: 'Claude Opus 4',
                score: 90,
                strengths: ['Scholarly citations', 'Argument structure', 'Technical terminology']
            },
            // CAPEX/business patterns: Claude Sonnet best for structured data, costs, vendors
            capex: {
                provider: 'anthropic',
                model: 'claude-sonnet-4-20250514',
                name: 'Claude Sonnet 4',
                score: 98,
                strengths: ['Cost extraction', 'Vendor tracking', 'Dependency detection']
            },
            generic: {
                provider: 'anthropic',
                model: 'claude-sonnet-4-20250514',
                name: 'Claude Sonnet 4',
                score: 95,
                strengths: ['General structure', 'Balanced performance']
            },
            sales: {
                provider: 'anthropic',
                model: 'claude-sonnet-4-20250514',
                name: 'Claude Sonnet 4',
                score: 96,
                strengths: ['Deal tracking', 'Pipeline structure', 'Contact management']
            },
            thesis: {
                provider: 'anthropic',
                model: 'claude-opus-4-20250514',
                name: 'Claude Opus 4',
                score: 89,
                strengths: ['Academic structure', 'Citation handling', 'Argument flow']
            },
            // Default for patterns not specifically tested
            default: {
                provider: 'anthropic',
                model: 'claude-sonnet-4-20250514',
                name: 'Claude Sonnet 4',
                score: 90,
                strengths: ['General purpose', 'Good balance of speed and quality']
            }
        };

        /**
         * Get the optimized model for importing/appending based on pattern
         * Returns the model config from A/B testing results
         */
        function getOptimizedImportModel(pattern) {
            // Check if user has the required API key for the optimized model
            const config = OPTIMIZED_IMPORT_MODELS[pattern] || OPTIMIZED_IMPORT_MODELS.default;

            // If Opus is recommended but user doesn't have Anthropic key, fall back
            if (config.model.includes('opus') && !getLocalAPIKey('anthropic')) {
                console.log(`âš ï¸ Opus recommended for ${pattern} but no API key - using Sonnet via proxy`);
                return OPTIMIZED_IMPORT_MODELS.default;
            }

            console.log(`ğŸ¯ Optimized model for ${pattern}: ${config.name} (${config.score}% accuracy)`);
            return config;
        }

        // Get redundancy mode preference
        function getRedundancyMode() {
            return localStorage.getItem('ai_redundancy_mode') === 'true';
        }

        function setRedundancyMode(enabled) {
            localStorage.setItem('ai_redundancy_mode', enabled.toString());
        }

        // Unified AI Mode management (combines provider, model, and processing mode)
        function getUnifiedAIMode() {
            return localStorage.getItem('unified_ai_mode') || 'server-sonnet';
        }

        function setUnifiedAIMode(mode) {
            localStorage.setItem('unified_ai_mode', mode);
            console.log(`âœ… Unified AI mode set to: ${mode}`);

            // Update the dropdown
            const select = document.getElementById('unified-ai-mode-select');
            if (select) {
                select.value = mode;
            }
        }

        // Parse unified mode into components
        function parseUnifiedMode(mode = null) {
            const unifiedMode = mode || getUnifiedAIMode();

            if (unifiedMode === 'off') {
                return {
                    enabled: false,
                    provider: null,
                    model: null,
                    mode: 'off',
                    requiresKey: false,
                    description: 'AI features disabled'
                };
            }

            // Model definitions - all available models with their API IDs and metadata
            const MODEL_DEFINITIONS = {
                // Claude models (server = uses our Netlify proxy key, user = user's key)
                'server-haiku': {
                    provider: 'anthropic',
                    model: 'haiku',
                    modelId: 'claude-3-haiku-20240307',
                    useServerKey: true,
                    description: 'Fast & cheap - 200 req/hr limit'
                },
                'server-sonnet': {
                    provider: 'anthropic',
                    model: 'sonnet',
                    modelId: 'claude-sonnet-4-20250514',
                    useServerKey: true,
                    description: 'Best reasoning - 200 req/hr limit'
                },
                'user-haiku': {
                    provider: 'anthropic',
                    model: 'haiku',
                    modelId: 'claude-3-5-haiku-20241022',
                    useServerKey: false,
                    description: 'Fast - Claude 3.5 Haiku (~$1/1M in, $5/1M out)'
                },
                'user-sonnet': {
                    provider: 'anthropic',
                    model: 'sonnet',
                    modelId: 'claude-sonnet-4-20250514',
                    useServerKey: false,
                    description: 'Best reasoning (~$3/1M in, $15/1M out)'
                },
                'user-opus': {
                    provider: 'anthropic',
                    model: 'opus',
                    modelId: 'claude-opus-4-20250514',
                    useServerKey: false,
                    description: 'Most capable (~$15/1M in, $75/1M out)'
                },
                'user-opus45': {
                    provider: 'anthropic',
                    model: 'opus45',
                    modelId: 'claude-opus-4-5-20251101',
                    useServerKey: false,
                    description: 'Frontier model (~$15/1M in, $75/1M out)'
                },
                // Gemini models (always user key, direct API = no timeout!)
                'user-gemini-flash': {
                    provider: 'gemini',
                    model: 'gemini-flash',
                    modelId: 'gemini-2.5-flash',
                    useServerKey: false,
                    description: 'Fast - Gemini 2.5 Flash (Stable)'
                },
                'user-gemini-pro': {
                    provider: 'gemini',
                    model: 'gemini-pro',
                    modelId: 'gemini-2.5-pro',
                    useServerKey: false,
                    description: 'Best reasoning - Gemini 2.5 Pro (Stable)'
                },
                'user-gemini-3-pro': {
                    provider: 'gemini',
                    model: 'gemini-3-pro',
                    modelId: 'gemini-3-pro-preview',
                    useServerKey: false,
                    description: 'Frontier - Gemini 3 Pro Preview (Nov 2025)'
                },
                // Legacy: user-gemini maps to flash
                'user-gemini': {
                    provider: 'gemini',
                    model: 'gemini-flash',
                    modelId: 'gemini-2.5-flash',
                    useServerKey: false,
                    description: 'Gemini 2.5 Flash'
                },
                // OpenAI models (always user key, direct API = no timeout!)
                // BUILD 392: Added GPT-5.2 models (released Dec 11, 2025)
                'user-gpt52-pro': {
                    provider: 'openai',
                    model: 'gpt-5.2-pro',
                    modelId: 'gpt-5.2-pro',
                    useServerKey: false,
                    description: 'Most Accurate - GPT-5.2 Pro (Dec 2025)'
                },
                'user-gpt52': {
                    provider: 'openai',
                    model: 'gpt-5.2',
                    modelId: 'gpt-5.2',
                    useServerKey: false,
                    description: 'Flagship - GPT-5.2 (Dec 2025)'
                },
                'user-gpt52-chat': {
                    provider: 'openai',
                    model: 'gpt-5.2-chat-latest',
                    modelId: 'gpt-5.2-chat-latest',
                    useServerKey: false,
                    description: 'ChatGPT Model - GPT-5.2 Chat'
                },
                'user-gpt5': {
                    provider: 'openai',
                    model: 'gpt-5',
                    modelId: 'gpt-5',
                    useServerKey: false,
                    description: 'Previous Gen - GPT-5 (Aug 2025)'
                },
                'user-gpt5-mini': {
                    provider: 'openai',
                    model: 'gpt-5-mini',
                    modelId: 'gpt-5-mini',
                    useServerKey: false,
                    description: 'Fast - GPT-5 Mini'
                },
                'user-o3': {
                    provider: 'openai',
                    model: 'o3',
                    modelId: 'o3',
                    useServerKey: false,
                    description: 'Best reasoning - o3'
                },
                'user-o4-mini': {
                    provider: 'openai',
                    model: 'o4-mini',
                    modelId: 'o4-mini',
                    useServerKey: false,
                    description: 'Fast reasoning - o4-mini'
                },
                'user-gpt4o': {
                    provider: 'openai',
                    model: 'gpt-4o',
                    modelId: 'gpt-4o',
                    useServerKey: false,
                    description: 'Legacy - GPT-4o'
                },
                // Legacy mappings
                'user-gpt4o-mini': {
                    provider: 'openai',
                    model: 'gpt-5-mini',
                    modelId: 'gpt-5-mini',
                    useServerKey: false,
                    description: 'Redirects to GPT-5 Mini'
                },
                'user-o1': {
                    provider: 'openai',
                    model: 'o3',
                    modelId: 'o3',
                    useServerKey: false,
                    description: 'Redirects to o3'
                },
                'user-chatgpt': {
                    provider: 'openai',
                    model: 'gpt-5.2-chat-latest',
                    modelId: 'gpt-5.2-chat-latest',
                    useServerKey: false,
                    description: 'GPT-5.2 Chat (Latest)'
                }
            };

            const modelDef = MODEL_DEFINITIONS[unifiedMode];

            if (!modelDef) {
                console.warn(`Unknown AI mode: ${unifiedMode}, falling back to server-sonnet`);
                return parseUnifiedMode('server-sonnet');
            }

            // Determine processing mode: server key = quick (10s limit), user key = deep (no limit for Gemini/ChatGPT)
            const processingMode = modelDef.useServerKey ? 'quick' : 'deep';

            return {
                enabled: true,
                provider: modelDef.provider,
                model: modelDef.model,
                modelId: modelDef.modelId,
                mode: processingMode,
                useServerKey: modelDef.useServerKey,
                requiresKey: !modelDef.useServerKey,
                description: modelDef.description
            };
        }

        // Legacy compatibility functions (for existing code)
        function getGlobalAIMode() {
            const parsed = parseUnifiedMode();
            return parsed.enabled ? parsed.mode : 'off';
        }

        function getAIProvider() {
            const parsed = parseUnifiedMode();
            return parsed.provider || 'anthropic';
        }

        function getClaudeModelId() {
            const parsed = parseUnifiedMode();
            return parsed.modelId || 'claude-sonnet-4-20250514';
        }

        function canUseServerlessAI() {
            return Boolean(AI_CONFIG && typeof AI_CONFIG.apiEndpoint === 'string' && AI_CONFIG.apiEndpoint.length > 0);
        }

        function showApiKeyModal(prefillExisting = false) {
            const apiKeyModal = document.getElementById('api-key-modal');
            const claudeInput = document.getElementById('claude-api-key-input');
            const geminiInput = document.getElementById('gemini-api-key-input');
            const openaiInput = document.getElementById('openai-api-key-input');
            const providerSelect = document.getElementById('provider-select');

            // Load existing keys
            const claudeKey = getLocalAPIKey('anthropic');
            const geminiKey = getLocalAPIKey('gemini');
            const openaiKey = getLocalAPIKey('openai');
            const currentProvider = getAIProvider();

            // Prefill keys if requested
            claudeInput.value = prefillExisting && claudeKey ? claudeKey : '';
            geminiInput.value = prefillExisting && geminiKey ? geminiKey : '';
            openaiInput.value = prefillExisting && openaiKey ? openaiKey : '';

            // Set provider dropdown
            providerSelect.value = currentProvider;

            // Update status badges
            updateKeyStatusBadges();

            // Reset show checkbox
            document.getElementById('api-key-show').checked = false;

            apiKeyModal.style.display = 'flex';
        }

        function updateKeyStatusBadges() {
            const claudeStatus = document.getElementById('claude-key-status');
            const geminiStatus = document.getElementById('gemini-key-status');
            const openaiStatus = document.getElementById('openai-key-status');

            const claudeKey = getLocalAPIKey('anthropic');
            const geminiKey = getLocalAPIKey('gemini');
            const openaiKey = getLocalAPIKey('openai');

            if (claudeKey) {
                claudeStatus.textContent = 'âœ“ Saved';
                claudeStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                claudeStatus.style.color = '#22c55e';
            } else {
                claudeStatus.textContent = 'Not saved';
                claudeStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                claudeStatus.style.color = '#9ca3af';
            }

            if (geminiKey) {
                geminiStatus.textContent = 'âœ“ Saved';
                geminiStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                geminiStatus.style.color = '#22c55e';
            } else {
                geminiStatus.textContent = 'Not saved';
                geminiStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                geminiStatus.style.color = '#9ca3af';
            }

            if (openaiKey) {
                openaiStatus.textContent = 'âœ“ Saved';
                openaiStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                openaiStatus.style.color = '#22c55e';
            } else {
                openaiStatus.textContent = 'Not saved';
                openaiStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                openaiStatus.style.color = '#9ca3af';
            }
        }

        // Helper: Direct API call to Anthropic (bypasses Netlify, no timeout limit)
        async function callClaudeDirectAPI(requestData, apiKey) {
            console.log('ğŸš€ Direct API: Calling Anthropic Claude directly (no Netlify timeout)');

            try {
                const response = await fetch(AI_CONFIG.directEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    throw new Error(error.error?.message || `Claude API error: ${response.status}`);
                }

                return response;
            } catch (error) {
                // CORS errors show as "Failed to fetch" or TypeError
                if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
                    console.error('âŒ CORS Error: Browser blocked direct API call to api.anthropic.com');
                    throw new Error('Failed to fetch'); // Re-throw for upstream handling
                }
                throw error;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 251: Edge Function Streaming API (No Timeout!)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Call Claude via Edge Function with streaming (SSE)
         * This bypasses Netlify's 10-second timeout by using Edge Functions
         * which have no timeout for streaming responses.
         *
         * @param {object} requestData - The Anthropic API request body
         * @param {string|null} userApiKey - Optional user API key
         * @param {function|null} onDelta - Optional callback for streaming deltas
         * @returns {Promise<string>} The complete response text
         */
        async function callClaudeStreamingAPI(requestData, userApiKey = null, onDelta = null) {
            const STREAMING_ENDPOINT = '/api/claude-stream';

            console.log('ğŸŒŠ Streaming: Using Edge Function (no timeout limit)');

            // Check if we're on deployed site (Edge Functions only work deployed)
            const isLocalFile = window.location.protocol === 'file:';
            if (isLocalFile) {
                throw new Error('STREAMING_NOT_AVAILABLE_LOCAL');
            }

            const requestBody = {
                ...requestData,
                userApiKey: userApiKey || undefined,
                stream: true, // Tell Edge Function we want streaming
            };

            try {
                const response = await fetch(STREAMING_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('âŒ Streaming API error:', response.status, errorText);
                    throw new Error(`Streaming API error: ${response.status}`);
                }

                // Read SSE stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let fullText = '';

                while (true) {
                    const { done, value } = await reader.read();

                    if (done) {
                        break;
                    }

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete SSE events
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);

                            if (data === '[DONE]') {
                                continue;
                            }

                            try {
                                const event = JSON.parse(data);

                                if (event.type === 'delta' && event.text) {
                                    fullText = event.accumulated || (fullText + event.text);

                                    // Call delta callback if provided (for UI updates)
                                    if (onDelta && typeof onDelta === 'function') {
                                        onDelta(event.text, fullText);
                                    }
                                }

                                if (event.type === 'message_complete') {
                                    fullText = event.content || fullText;
                                    console.log('âœ… Streaming complete:', {
                                        tokens: event.usage,
                                        model: event.model
                                    });
                                }

                                if (event.type === 'thinking_start') {
                                    console.log('ğŸ§  Extended Thinking started...');
                                }

                                if (event.error) {
                                    throw new Error(event.error);
                                }
                            } catch (parseError) {
                                if (parseError.message !== 'Unexpected end of JSON input') {
                                    console.warn('SSE parse error:', parseError);
                                }
                            }
                        }
                    }
                }

                return fullText;

            } catch (error) {
                console.error('âŒ Streaming failed:', error);
                throw error;
            }
        }

        /**
         * Call Claude via Edge Function (buffered mode - no streaming UI)
         * Still uses Edge Function for no timeout, but returns complete response
         */
        async function callClaudeEdgeBuffered(requestData, userApiKey = null) {
            const STREAMING_ENDPOINT = '/api/claude-stream';

            console.log('ğŸ“¦ Edge Buffered: Using Edge Function without streaming');

            const requestBody = {
                ...requestData,
                userApiKey: userApiKey || undefined,
                stream: false, // Tell Edge Function to buffer response
            };

            const response = await fetch(STREAMING_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Edge API error: ${response.status}`);
            }

            return response;
        }

        /**
         * Optimized API call for Import/Append operations
         * Uses pattern-specific models from A/B testing for best results
         * Automatically handles streaming via Edge Function for no timeout
         */
        async function callOptimizedImportAPI(prompt, systemPrompt, maxTokens, pattern) {
            const modelConfig = getOptimizedImportModel(pattern);
            const apiKey = getLocalAPIKey('anthropic');
            const isLocalFile = window.location.protocol === 'file:';

            console.log(`ğŸ¯ Optimized Import: Using ${modelConfig.name} for ${pattern} pattern`);

            // Build request data with optimized model
            const requestData = {
                model: modelConfig.model,
                max_tokens: maxTokens,
                system: systemPrompt,
                messages: [{ role: 'user', content: prompt }]
            };

            // Use streaming Edge Function for no timeout
            if (!isLocalFile) {
                try {
                    console.log('ğŸŒŠ Using Edge Function streaming for optimized import...');
                    const result = await callClaudeStreamingAPI(
                        { ...requestData, userApiKey: apiKey },
                        apiKey,
                        null // no delta callback needed
                    );
                    console.log(`âœ… Optimized import complete via Edge Function`);
                    return result;
                } catch (edgeError) {
                    console.warn('âš ï¸ Edge Function failed, trying fallback:', edgeError.message);
                }
            }

            // Fallback to regular API if Edge Function unavailable
            const response = await fetch(AI_CONFIG.apiEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    ...requestData,
                    userApiKey: apiKey
                })
            });

            if (!response.ok) {
                throw new Error(`Import API error: ${response.status}`);
            }

            const data = await response.json();
            return data.content?.[0]?.text || '';
        }

        // Helper: Direct API call to Google Gemini
        async function callGeminiDirectAPI(prompt, systemPrompt, maxTokens, apiKey) {
            console.log('ğŸš€ Direct API: Calling Google Gemini directly');

            // Enhanced default prompt with TreeListy context for Gemini
            const geminiDefaultPrompt = `You are an expert project analyst within TreeListy, a hierarchical project decomposition tool.

TREELISTY CONTEXT:
- 4-level hierarchy: Root â†’ Phases (children) â†’ Items (items) â†’ Subtasks (subItems)
- 21 patterns: generic, philosophy, sales, thesis, roadmap, book, event, fitness, strategy, course, prompting, film, veo3, sora2, dialogue, familytree, filesystem, gmail, freespeech, lifetree, custom
- Each pattern has unique fields for domain-specific data`;

            const effectiveSystemPrompt = systemPrompt || geminiDefaultPrompt;

            // Gemini API format is different from Claude
            const geminiRequest = {
                contents: [{
                    parts: [{
                        text: (effectiveSystemPrompt ? effectiveSystemPrompt + '\n\n' : '') + prompt
                    }]
                }],
                generationConfig: {
                    maxOutputTokens: maxTokens,
                    temperature: 0.7
                }
            };

            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(geminiRequest)
                }
            );

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `Gemini API error: ${response.status}`);
            }

            const data = await response.json();

            // Convert Gemini response format to Claude-like format for consistency
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                throw new Error('Invalid Gemini response structure');
            }

            return {
                json: async () => ({
                    content: [{
                        text: data.candidates[0].content.parts[0].text
                    }]
                }),
                ok: true
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 565: IMAGE ANALYSIS - Gemini Vision for object decomposition
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Prompt for Gemini to analyze images and return hierarchical object structure
         * with bounding boxes in 0-1000 normalized coordinates
         */
        const IMAGE_ANALYSIS_PROMPT = `Analyze this image and identify all distinct objects, elements, and regions.

Return a hierarchical JSON structure that groups objects into logical categories.

CRITICAL: Return ONLY valid JSON, no markdown code blocks or extra text.

For EACH detected object include:
1. name: Brief descriptive name
2. description: What is this object and its context/purpose
3. itemType: One of "primary" | "secondary" | "background" | "text" | "ui-element"
4. _bbox: Bounding box in Gemini's format { yMin, xMin, yMax, xMax } with values 0-1000
5. _confidence: Detection confidence 0.0 to 1.0
6. _detectedLabel: Original detection label

RECONSTRUCTION ATTRIBUTES (for visual recreation):
7. _color: Primary color as CSS color name or hex code (e.g., "skyblue", "#4682B4")
8. _shape: Basic shape type: "rectangle" | "circle" | "oval" | "triangle" | "polygon" | "irregular"
9. _zIndex: Layer order (0 = furthest back, higher = closer to foreground)
10. _texture: Optional texture hint: "solid" | "gradient" | "striped" | "patterned" | "photo"
11. _opacity: Transparency 0.0-1.0 (default 1.0 if fully opaque)

IMPORTANT BOUNDING BOX FORMAT:
- Use 0-1000 normalized coordinates (not pixels)
- yMin = top edge, yMax = bottom edge
- xMin = left edge, xMax = right edge
- Example: An object in top-left quadrant: { yMin: 50, xMin: 50, yMax: 300, xMax: 400 }

Return this exact JSON structure:
{
    "projectName": "Image Analysis: [2-4 word description]",
    "phases": [
        {
            "name": "Category Name",
            "icon": "[emoji]",
            "items": [
                {
                    "name": "Object Name",
                    "description": "What this is and its role in the image",
                    "itemType": "primary",
                    "_bbox": { "yMin": 100, "xMin": 200, "yMax": 400, "xMax": 500 },
                    "_confidence": 0.95,
                    "_detectedLabel": "person",
                    "_color": "#4682B4",
                    "_shape": "rectangle",
                    "_zIndex": 5,
                    "_texture": "solid",
                    "_opacity": 1.0,
                    "subItems": []
                }
            ]
        }
    ]
}

GROUPING RULES:
- Group related objects into phases (e.g., "People", "Furniture", "UI Elements", "Text", "Background")
- Use appropriate emojis for categories
- Create subItems for objects that are parts of larger objects
- Order phases by visual importance (foreground first)

DETAIL LEVELS BY CONTENT TYPE:
- FACES/PEOPLE: Detect individual facial features (eyes, nose, mouth, ears, hair, eyebrows) as subItems of the person. Each feature should have its own bbox.
- UI SCREENSHOTS: Detect each button, input, label, icon as separate items with bboxes.
- LANDSCAPES: Detect major regions (sky, mountains, water, vegetation) and notable objects within them.
- ROOMS/INTERIORS: Detect furniture, decorations, architectural features as items.
- DOCUMENTS: Detect headings, paragraphs, images, diagrams as separate items.

Be thorough - detect ALL visible objects, text, UI elements, and distinct regions.
For faces, ALWAYS include subItems for: eyes, nose, mouth, and other visible facial features.`;

        // =============================================================================
        // BUILD 568: IndexedDB Image Store
        // Stores source images separately to prevent tree JSON bloat
        // =============================================================================

        const IMAGE_DB_NAME = 'TreeListyImages';
        const IMAGE_DB_VERSION = 1;
        const IMAGE_STORE_NAME = 'images';
        let imageDB = null;

        /**
         * Initialize IndexedDB for image storage
         */
        async function initImageDB() {
            return new Promise((resolve, reject) => {
                if (imageDB) {
                    resolve(imageDB);
                    return;
                }

                const request = indexedDB.open(IMAGE_DB_NAME, IMAGE_DB_VERSION);

                request.onerror = () => {
                    console.warn('[Images] IndexedDB not available');
                    resolve(null);
                };

                request.onsuccess = (event) => {
                    imageDB = event.target.result;
                    console.log('[Images] IndexedDB initialized');
                    resolve(imageDB);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(IMAGE_STORE_NAME)) {
                        const store = db.createObjectStore(IMAGE_STORE_NAME, { keyPath: 'id' });
                        store.createIndex('hash', 'hash', { unique: false });
                        store.createIndex('createdAt', 'createdAt', { unique: false });
                    }
                };
            });
        }

        /**
         * Generate hash for image deduplication
         */
        async function hashImageData(dataUrl) {
            const base64 = dataUrl.split(',')[1] || dataUrl;
            const encoder = new TextEncoder();
            const data = encoder.encode(base64.substring(0, 10000)); // Hash first 10KB for speed
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 16);
        }

        /**
         * Compress image to WebP with max dimensions
         * @param {string} dataUrl - Original image data URL
         * @param {number} maxDimension - Max width or height (default 2048)
         * @param {number} quality - WebP quality 0-1 (default 0.8)
         * @returns {Promise<{dataUrl: string, dimensions: {width: number, height: number}}>}
         */
        async function compressImage(dataUrl, maxDimension = 2048, quality = 0.8) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    let { width, height } = img;

                    // Scale down if needed
                    if (width > maxDimension || height > maxDimension) {
                        const scale = maxDimension / Math.max(width, height);
                        width = Math.round(width * scale);
                        height = Math.round(height * scale);
                    }

                    // Draw to canvas and export as WebP
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // Try WebP first, fall back to JPEG if not supported
                    let compressedUrl = canvas.toDataURL('image/webp', quality);
                    if (!compressedUrl.startsWith('data:image/webp')) {
                        compressedUrl = canvas.toDataURL('image/jpeg', quality);
                    }

                    const originalSize = dataUrl.length;
                    const compressedSize = compressedUrl.length;
                    console.log(`[Images] Compressed: ${Math.round(originalSize/1024)}KB â†’ ${Math.round(compressedSize/1024)}KB (${Math.round(compressedSize/originalSize*100)}%)`);

                    resolve({
                        dataUrl: compressedUrl,
                        dimensions: { width, height },
                        originalDimensions: { width: img.naturalWidth, height: img.naturalHeight }
                    });
                };
                img.onerror = reject;
                img.src = dataUrl;
            });
        }

        /**
         * Save image to IndexedDB store
         * @param {string} dataUrl - Image data URL (will be compressed)
         * @returns {Promise<{id: string, hash: string, dimensions: object}>} - Image reference
         */
        async function saveImageToStore(dataUrl) {
            await initImageDB();

            // Compress image first
            const compressed = await compressImage(dataUrl);
            const hash = await hashImageData(compressed.dataUrl);

            // Check for existing image with same hash
            if (imageDB) {
                const existing = await new Promise((resolve) => {
                    const tx = imageDB.transaction(IMAGE_STORE_NAME, 'readonly');
                    const store = tx.objectStore(IMAGE_STORE_NAME);
                    const index = store.index('hash');
                    const request = index.get(hash);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                });

                if (existing) {
                    console.log('[Images] Reusing existing image with hash:', hash);
                    return {
                        id: existing.id,
                        hash: existing.hash,
                        dimensions: existing.dimensions
                    };
                }
            }

            const imageId = `img-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const imageData = {
                id: imageId,
                hash: hash,
                dataUrl: compressed.dataUrl,
                dimensions: compressed.dimensions,
                originalDimensions: compressed.originalDimensions,
                createdAt: Date.now(),
                size: compressed.dataUrl.length
            };

            if (imageDB) {
                await new Promise((resolve, reject) => {
                    const tx = imageDB.transaction(IMAGE_STORE_NAME, 'readwrite');
                    const store = tx.objectStore(IMAGE_STORE_NAME);
                    const request = store.put(imageData);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
                console.log('[Images] Saved to IndexedDB:', imageId, `(${Math.round(imageData.size/1024)}KB)`);
            } else {
                // Fallback: store in localStorage (limited size)
                try {
                    localStorage.setItem(`treelisty-image-${imageId}`, JSON.stringify(imageData));
                    console.log('[Images] Saved to localStorage:', imageId);
                } catch (e) {
                    console.warn('[Images] Storage failed:', e);
                }
            }

            return {
                id: imageId,
                hash: hash,
                dimensions: compressed.dimensions
            };
        }

        /**
         * Get image from IndexedDB store
         * @param {string} imageId - Image ID
         * @returns {Promise<string|null>} - Image data URL or null
         */
        async function getImageFromStore(imageId) {
            await initImageDB();

            if (imageDB) {
                return new Promise((resolve) => {
                    const tx = imageDB.transaction(IMAGE_STORE_NAME, 'readonly');
                    const store = tx.objectStore(IMAGE_STORE_NAME);
                    const request = store.get(imageId);
                    request.onsuccess = () => {
                        const result = request.result;
                        resolve(result ? result.dataUrl : null);
                    };
                    request.onerror = () => resolve(null);
                });
            } else {
                // localStorage fallback
                const data = localStorage.getItem(`treelisty-image-${imageId}`);
                if (data) {
                    try {
                        return JSON.parse(data).dataUrl;
                    } catch (e) {
                        return null;
                    }
                }
                return null;
            }
        }

        /**
         * Delete image from store
         */
        async function deleteImageFromStore(imageId) {
            await initImageDB();

            if (imageDB) {
                return new Promise((resolve) => {
                    const tx = imageDB.transaction(IMAGE_STORE_NAME, 'readwrite');
                    const store = tx.objectStore(IMAGE_STORE_NAME);
                    const request = store.delete(imageId);
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => resolve(false);
                });
            } else {
                localStorage.removeItem(`treelisty-image-${imageId}`);
                return true;
            }
        }

        // =============================================================================
        // END IMAGE STORE
        // =============================================================================

        /**
         * Call Gemini Vision API with an image for analysis
         * @param {string} imageDataUrl - Base64 data URL of the image
         * @param {string} prompt - Analysis prompt
         * @param {string} apiKey - Gemini API key
         * @param {string} modelId - Model to use (default: gemini-2.5-flash)
         * @returns {Promise<string>} - Raw text response from Gemini
         */
        async function callGeminiVisionAPI(imageDataUrl, prompt, apiKey, modelId = 'gemini-2.5-flash') {
            console.log(`ğŸ” Vision API: Calling ${modelId} with image`);

            // Extract base64 and media type from data URL
            const matches = imageDataUrl.match(/^data:([^;]+);base64,(.+)$/);
            if (!matches) {
                throw new Error('Invalid image data format - expected data URL');
            }
            const mediaType = matches[1];
            const base64Data = matches[2];

            const geminiRequest = {
                contents: [{
                    parts: [
                        {
                            inline_data: {
                                mime_type: mediaType,
                                data: base64Data
                            }
                        },
                        {
                            text: prompt
                        }
                    ]
                }],
                generationConfig: {
                    maxOutputTokens: 8192,
                    temperature: 0.2  // Lower for consistent structured output
                }
            };

            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(geminiRequest)
                }
            );

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `Gemini Vision API error: ${response.status}`);
            }

            const data = await response.json();

            if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                throw new Error('Invalid Gemini Vision response structure');
            }

            return data.candidates[0].content.parts[0].text;
        }

        /**
         * Analyze an image and import as TreeListy tree
         * @param {string} imageDataUrl - Base64 data URL of the image
         * @returns {Promise<object>} - Analysis result
         */
        async function analyzeImageForTree(imageDataUrl) {
            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) {
                throw new Error('Gemini API key required. Set it in Settings â†’ API Keys.');
            }

            // Get selected model from UI (default to gemini-2.5-flash)
            const modelRadio = document.querySelector('input[name="image-analysis-model"]:checked');
            const modelId = modelRadio?.value || 'gemini-2.5-flash';
            const modelName = modelId === 'gemini-3-pro-image-preview' ? 'Nano Banana Pro' : 'Gemini 2.5 Flash';

            console.log(`ğŸ–¼ï¸ Starting image analysis with ${modelName} (${modelId})...`);

            // BUILD 614: Track as active task
            const taskId = 'img_' + Date.now();
            workStatusAddActive({
                id: taskId,
                type: 'image_analysis',
                title: 'Analyzing image...',
                provider: modelName,
                cancellable: false
            });
            updateWorkStatusUI();

            const responseText = await callGeminiVisionAPI(imageDataUrl, IMAGE_ANALYSIS_PROMPT, apiKey, modelId);

            // BUILD 614: Track completion and API usage
            workStatusComplete(taskId, true);
            workStatusTrackAPI(modelName, 2000, 0.001); // Estimate tokens/cost
            updateWorkStatusUI();

            // Parse JSON from response (handle potential markdown wrapping)
            let jsonStr = responseText.trim();

            // Remove markdown code blocks if present
            const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)```/);
            if (jsonMatch) {
                jsonStr = jsonMatch[1].trim();
            }

            let geminiResult;
            try {
                geminiResult = JSON.parse(jsonStr);
            } catch (parseErr) {
                console.error('Failed to parse Gemini response:', jsonStr);
                throw new Error('Failed to parse image analysis response as JSON');
            }

            // Convert Gemini format { projectName, phases: [{ items }] } to TreeListy format { name, children }
            function convertToTreeListyFormat(gemini) {
                const tree = {
                    id: 'img-root-' + Date.now(),
                    name: gemini.projectName || 'Image Analysis',
                    description: 'AI-detected objects and elements',
                    children: []
                };

                // Convert phases to children
                (gemini.phases || []).forEach((phase, phaseIdx) => {
                    const phaseNode = {
                        id: 'phase-' + phaseIdx + '-' + Date.now(),
                        name: phase.name || `Category ${phaseIdx + 1}`,
                        description: phase.description || '',
                        icon: phase.icon,
                        children: []
                    };

                    // Convert items to children
                    (phase.items || []).forEach((item, itemIdx) => {
                        const itemNode = {
                            id: 'item-' + phaseIdx + '-' + itemIdx + '-' + Date.now(),
                            name: item.name || `Object ${itemIdx + 1}`,
                            description: item.description || '',
                            itemType: item.itemType,
                            _bbox: item._bbox,
                            _confidence: item._confidence,
                            _objectType: item._detectedLabel || item.itemType,
                            _color: item._color,
                            _shape: item._shape,
                            _zIndex: item._zIndex,
                            _texture: item._texture,
                            _opacity: item._opacity,
                            children: []
                        };

                        // Convert subItems if present
                        (item.subItems || []).forEach((sub, subIdx) => {
                            itemNode.children.push({
                                id: 'sub-' + phaseIdx + '-' + itemIdx + '-' + subIdx + '-' + Date.now(),
                                name: sub.name || `Part ${subIdx + 1}`,
                                description: sub.description || '',
                                _bbox: sub._bbox,
                                _confidence: sub._confidence,
                                _objectType: sub._detectedLabel || sub.itemType,
                                _color: sub._color,
                                _shape: sub._shape,
                                _zIndex: sub._zIndex,
                                _texture: sub._texture,
                                _opacity: sub._opacity,
                                children: []
                            });
                        });

                        phaseNode.children.push(itemNode);
                    });

                    tree.children.push(phaseNode);
                });

                return tree;
            }

            const analysisResult = convertToTreeListyFormat(geminiResult);

            // Get image dimensions
            const img = new Image();
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = imageDataUrl;
            });

            // BUILD 568: Save image to IndexedDB instead of embedding in tree
            const imageRef = await saveImageToStore(imageDataUrl);

            // Store image reference (not the full base64)
            analysisResult._imageAnalysis = {
                imageRef: imageRef,  // { id, hash, dimensions }
                imageDimensions: imageRef.dimensions || {
                    width: img.naturalWidth,
                    height: img.naturalHeight
                },
                analysisTimestamp: new Date().toISOString(),
                modelUsed: modelId,
                modelName: modelName,
                showOverlays: true
            };

            console.log('âœ… Image analysis complete:', {
                phases: analysisResult.phases?.length,
                dimensions: analysisResult._imageAnalysis.imageDimensions
            });

            return analysisResult;
        }

        /**
         * Import image analysis as a new tree, replacing current tree
         * @param {string} imageDataUrl - Base64 data URL of the image
         */
        async function importImageAnalysisTree(imageDataUrl) {
            try {
                // Get selected model for toast message
                const modelRadio = document.querySelector('input[name="image-analysis-model"]:checked');
                const modelId = modelRadio?.value || 'gemini-2.5-flash';
                const modelEmoji = modelId === 'gemini-3-pro-image-preview' ? 'ğŸŒ' : 'âš¡';
                const modelLabel = modelId === 'gemini-3-pro-image-preview' ? 'Nano Banana Pro' : 'Gemini 2.5 Flash';
                showToast(`${modelEmoji} Analyzing image with ${modelLabel}...`, 'info');

                // Analyze the image
                const analysisResult = await analyzeImageForTree(imageDataUrl);

                // Count objects for toast
                let objectCount = 0;
                analysisResult.phases?.forEach(phase => {
                    objectCount += phase.items?.length || 0;
                    phase.items?.forEach(item => {
                        objectCount += item.subItems?.length || 0;
                    });
                });

                // Save current state for undo
                saveState('Before image analysis import');

                // Create new tree structure
                const newTree = {
                    type: 'root',
                    id: 'root',
                    name: analysisResult.projectName || 'Image Analysis',
                    icon: 'ğŸ–¼ï¸',
                    expanded: true,
                    hyperedges: [],
                    _imageAnalysis: analysisResult._imageAnalysis,
                    children: (analysisResult.phases || []).map((phase, phaseIdx) => ({
                        type: 'phase',
                        id: `phase-${phaseIdx}`,
                        phase: phaseIdx,
                        name: phase.name || `Category ${phaseIdx + 1}`,
                        icon: phase.icon || 'ğŸ“¦',
                        expanded: true,
                        items: (phase.items || []).map((item, itemIdx) => ({
                            id: `item-${phaseIdx}-${itemIdx}`,
                            name: item.name || 'Unknown Object',
                            description: item.description || '',
                            itemType: item.itemType || 'secondary',
                            _bbox: item._bbox || null,
                            _confidence: item._confidence || 0,
                            _detectedLabel: item._detectedLabel || '',
                            expanded: true,
                            subItems: (item.subItems || []).map((sub, subIdx) => ({
                                id: `subitem-${phaseIdx}-${itemIdx}-${subIdx}`,
                                name: sub.name || 'Detail',
                                description: sub.description || '',
                                _bbox: sub._bbox || null,
                                _confidence: sub._confidence || 0
                            }))
                        }))
                    }))
                };

                // Replace current tree
                capexTree = newTree;

                // Position nodes based on bounding boxes
                positionNodesFromBboxes();

                // Switch to canvas view and render
                // Set viewMode directly since switchView doesn't exist
                viewMode = 'canvas';
                document.getElementById('view-mode-icon').textContent = 'ğŸ“Š';
                document.getElementById('view-mode-text').textContent = 'Tree View';
                document.querySelector('.tree-view-container').classList.add('hidden');
                document.getElementById('canvas-container').classList.add('active');
                const toolbar = document.getElementById('canvas-toolbar');
                if (toolbar) toolbar.classList.add('active');

                renderCanvas();
                render();

                showToast(`ğŸ‰ Detected ${objectCount} objects! View in Canvas mode.`, 'success');

                return analysisResult;

            } catch (err) {
                console.error('Image analysis failed:', err);
                showToast(`âŒ Analysis failed: ${err.message}`, 'error');
                throw err;
            }
        }

        /**
         * Position canvas nodes based on their bounding box locations
         * Nodes are placed to the right of the image, Y-aligned with their bbox centers
         */
        function positionNodesFromBboxes() {
            const imageData = capexTree._imageAnalysis;
            if (!imageData?.imageDimensions) return;

            const imgDims = imageData.imageDimensions;
            // Scale image to 1000px width in canvas
            const imgScale = 1000 / imgDims.width;
            const scaledImgHeight = imgDims.height * imgScale;

            // Node area starts to the right of the image with a gap
            const nodeAreaOffsetX = 1000 + 150; // 1000px image + 150px gap

            let nodeIndex = 0;

            capexTree.children?.forEach((phase, phaseIdx) => {
                // Position phase header
                phase.canvasX = nodeAreaOffsetX;
                phase.canvasY = 50 + phaseIdx * 400;

                phase.items?.forEach((item, itemIdx) => {
                    if (item._bbox) {
                        // Y-align with bbox center
                        const bboxCenterY = ((item._bbox.yMin + item._bbox.yMax) / 2 / 1000) * imgDims.height * imgScale;
                        item.canvasX = nodeAreaOffsetX + 50;
                        item.canvasY = Math.max(50, bboxCenterY - 60); // Offset to center node on bbox
                    } else {
                        // Default positioning
                        item.canvasX = nodeAreaOffsetX + 50;
                        item.canvasY = phase.canvasY + 80 + itemIdx * 140;
                    }

                    // Position subitems
                    item.subItems?.forEach((sub, subIdx) => {
                        sub.canvasX = item.canvasX + 350;
                        sub.canvasY = item.canvasY + subIdx * 100;
                    });

                    nodeIndex++;
                });
            });

            console.log('ğŸ“ Positioned nodes from bounding boxes');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 442: TREEBEARD RESEARCH MODE - Web search via Gemini
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Detect if user message is a research request
         * Returns { isResearch: boolean, query: string } or null
         */
        function detectResearchIntent(message) {
            const lower = message.toLowerCase().trim();

            // BUILD 574: Check for EXPLICIT research keywords FIRST
            // These should ALWAYS trigger research, even if TreeListy terms are present
            // This fixes the bug where "research X and add to tree" was blocked
            const explicitResearchPatterns = [
                /^(?:please\s+)?research\s+(.+)/i,
                /^(?:please\s+)?look\s+up\s+(.+)/i,
                /^(?:please\s+)?find\s+(?:information\s+)?(?:about\s+)?(.+)/i,
                /^(?:please\s+)?get\s+(?:info|information)\s+(?:on|about)\s+(.+)/i,
                /^(?:can you\s+)?(?:research|look up)\s+(.+)/i
            ];

            for (const pattern of explicitResearchPatterns) {
                const match = lower.match(pattern);
                if (match) {
                    // Extract the query, removing TreeListy integration phrases
                    let query = match[1].trim();
                    // Remove phrases like "and add to tree", "and integrate", etc.
                    query = query.replace(/\s+and\s+(?:add|integrate|put|place|insert).*$/i, '').trim();
                    console.log('ğŸ”¬ Explicit research keyword detected:', query);
                    return { isResearch: true, query: query, useDeepResearch: true };
                }
            }

            // BUILD 522: TreeListy-specific terms should NOT trigger web research
            // (Only checked AFTER explicit research keywords)
            // These queries should be handled by tree analysis, not web search
            const treelistyTerms = [
                'hyperedge', 'hyperedges',
                'node', 'nodes',
                'phase', 'phases',
                'item', 'items',
                'subitem', 'subitems',
                'tree', 'branch', 'branches',
                'dependency', 'dependencies',
                'canvas', 'gantt', 'calendar',
                'pattern', 'patterns'
            ];

            // If query contains TreeListy terms (without explicit research keyword), skip
            if (treelistyTerms.some(term => lower.includes(term))) {
                console.log('ğŸŒ³ TreeListy term detected, skipping web research:', message);
                return null; // Let it fall through to normal command/conversation handling
            }

            // Other research patterns (implicit)
            const researchPatterns = [
                /^search\s+(?:for\s+)?(.+)/i,
                /^what\s+(?:is|are|was|were)\s+(.+)\??/i,
                /^who\s+(?:is|are|was|were)\s+(.+)\??/i,
                /^when\s+(?:did|was|were|is)\s+(.+)\??/i,
                /^where\s+(?:is|are|was|were)\s+(.+)\??/i,
                /^how\s+(?:much|many|do|does|did|can|could)\s+(.+)\??/i,
                /^tell\s+me\s+about\s+(.+)/i
            ];

            for (const pattern of researchPatterns) {
                const match = lower.match(pattern);
                if (match) {
                    return { isResearch: true, query: match[1].trim() };
                }
            }

            // Check for question words that suggest external knowledge needed
            const questionIndicators = ['competitors', 'pricing', 'market', 'statistics', 'recent', 'latest', 'current', 'today', 'news'];
            const hasIndicator = questionIndicators.some(ind => lower.includes(ind));
            const isQuestion = lower.endsWith('?') || lower.startsWith('what') || lower.startsWith('who') || lower.startsWith('how');

            if (hasIndicator && isQuestion) {
                return { isResearch: true, query: message };
            }

            return null;
        }

        /**
         * Get pattern-aware research prompt
         */
        function getResearchPrompt(query, pattern) {
            const patternFocus = {
                generic: 'General web search - summarize key findings with sources.',
                capex: 'Focus on: costs, vendors, lead times, risks, market data, ROI considerations.',
                philosophy: 'Focus on: scholarly sources, author citations, counter-arguments, historical context.',
                sales: 'Focus on: company info, funding rounds, decision makers, competitors, market position.',
                lifetree: 'Focus on: biographical facts, dates, locations, relationships, source verification.',
                film: 'Focus on: visual references, technique breakdowns, production examples, style analysis.',
                veo3: 'Focus on: video generation examples, prompt techniques, style references.',
                sora2: 'Focus on: video generation examples, prompt techniques, style references.',
                thesis: 'Focus on: academic papers, citations, methodology comparisons, peer-reviewed sources.',
                roadmap: 'Focus on: industry trends, competitor timelines, technical feasibility.',
                book: 'Focus on: narrative techniques, genre conventions, comparable works.',
                dialogue: 'Focus on: debate positions, rhetorical strategies, counterarguments.'
            };

            const focus = patternFocus[pattern] || patternFocus.generic;

            return `You are a research assistant with web search capabilities.

USER QUERY: ${query}

RESEARCH FOCUS (${pattern} pattern): ${focus}

INSTRUCTIONS:
1. Search the web for current, relevant information
2. Synthesize findings from multiple sources
3. Cite your sources with URLs when available
4. Structure your response clearly

RESPONSE FORMAT:
Start with a brief summary, then provide detailed findings.
End with a "Sources:" section listing the URLs you found.

If you suggest items that could be added to the user's tree, format them as:
SUGGESTED NODES:
- Name: [node name]
  Description: [brief description]`;
        }

        /**
         * Call Gemini API with Google Search grounding enabled
         */
        async function callGeminiWithSearch(query, pattern) {
            const apiKey = localStorage.getItem('gemini_api_key');

            if (!apiKey) {
                return {
                    success: false,
                    error: 'ğŸ”‘ Research requires a Gemini API key.\n\nGemini has built-in Google Search. Add your key in Settings (ğŸ”‘ button).',
                    needsKey: true
                };
            }

            // Check CORS (local file won't work)
            if (window.location.protocol === 'file:') {
                return {
                    success: false,
                    error: 'ğŸŒ Research requires web deployment.\n\nGemini API is blocked from local files (CORS). Deploy to Netlify or use a web server.',
                    needsDeployment: true
                };
            }

            const researchPrompt = getResearchPrompt(query, pattern);

            console.log('ğŸ” Starting research with Gemini + Google Search...');

            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{ text: researchPrompt }]
                            }],
                            tools: [{
                                google_search: {}
                            }],
                            generationConfig: {
                                maxOutputTokens: 4096,
                                temperature: 0.7
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    throw new Error(error.error?.message || `Gemini API error: ${response.status}`);
                }

                const data = await response.json();

                if (!data.candidates || !data.candidates[0]?.content?.parts) {
                    throw new Error('Invalid Gemini response structure');
                }

                // Extract text from response
                const textParts = data.candidates[0].content.parts
                    .filter(p => p.text)
                    .map(p => p.text)
                    .join('\n');

                // Extract grounding metadata if available
                const groundingMetadata = data.candidates[0].groundingMetadata;
                const searchEntries = groundingMetadata?.groundingChunks || [];

                console.log('âœ… Research complete:', { textLength: textParts.length, sources: searchEntries.length });

                return {
                    success: true,
                    text: textParts,
                    sources: searchEntries,
                    groundingMetadata
                };

            } catch (error) {
                console.error('âŒ Research error:', error);
                return {
                    success: false,
                    error: `Research failed: ${error.message}`
                };
            }
        }

        /**
         * Handle a research request from Treebeard
         * Returns formatted response for chat
         */
        async function handleResearchRequest(query) {
            const pattern = typeof currentPattern !== 'undefined' ? currentPattern : 'generic';

            // Update UI to show research is happening
            const result = await callGeminiWithSearch(query, pattern);

            if (!result.success) {
                return {
                    message: result.error,
                    buttons: result.needsKey ? [
                        { label: 'ğŸ”‘ Open Settings', action: 'open_settings' }
                    ] : []
                };
            }

            // Format response with sources
            let response = `ğŸ” **Research Results**\n\n${result.text}`;

            // Add sources section if we have grounding data
            if (result.sources && result.sources.length > 0) {
                response += '\n\n---\n**Sources:**\n';
                result.sources.slice(0, 5).forEach((source, i) => {
                    const title = source.web?.title || `Source ${i + 1}`;
                    const uri = source.web?.uri || '';
                    response += `${i + 1}. [${title}](${uri})\n`;
                });
            }

            // Parse suggested nodes from response
            const suggestedNodes = parseResearchSuggestedNodes(result.text);

            // Add action buttons
            const buttons = [];
            if (suggestedNodes.length > 0) {
                buttons.push({ label: `â• Add ${suggestedNodes.length} nodes to tree`, action: `add_research_nodes:${JSON.stringify(suggestedNodes)}` });
            }
            buttons.push({ label: 'ğŸ”„ Research more', action: 'research_followup' });

            return {
                message: response,
                buttons,
                suggestedNodes
            };
        }

        /**
         * Parse suggested nodes from research response text
         * BUILD 522: Updated to handle both - and * bullet formats from different AI models
         */
        function parseResearchSuggestedNodes(text) {
            const nodes = [];
            const suggestedSection = text.match(/SUGGESTED NODES:([\s\S]*?)(?:Sources:|$)/i);

            if (suggestedSection) {
                const lines = suggestedSection[1].split('\n');
                let currentNode = null;

                for (const line of lines) {
                    // BUILD 522: Handle both - and * bullet formats (Gemini uses *, Claude uses -)
                    const nameMatch = line.match(/^[-*]?\s*Name:\s*(.+)/i);
                    const descMatch = line.match(/^[-*]?\s*Description:\s*(.+)/i);

                    if (nameMatch) {
                        if (currentNode) nodes.push(currentNode);
                        currentNode = { name: nameMatch[1].trim(), description: '' };
                    } else if (descMatch && currentNode) {
                        currentNode.description = descMatch[1].trim();
                    }
                }
                if (currentNode) nodes.push(currentNode);
            }

            console.log(`ğŸ“ Parsed ${nodes.length} suggested nodes from research response`);
            return nodes;
        }

        // Helper: Direct API call to OpenAI ChatGPT
        async function callOpenAIDirectAPI(prompt, systemPrompt, maxTokens, apiKey) {
            console.log('ğŸš€ Direct API: Calling OpenAI ChatGPT directly');

            // OpenAI API format
            // Enhanced default prompt with TreeListy context for OpenAI
            const openaiDefaultPrompt = `You are an expert project analyst within TreeListy, a hierarchical project decomposition tool.

TREELISTY CONTEXT:
- 4-level hierarchy: Root â†’ Phases (children) â†’ Items (items) â†’ Subtasks (subItems)
- 21 patterns: generic, philosophy, sales, thesis, roadmap, book, event, fitness, strategy, course, prompting, film, veo3, sora2, dialogue, familytree, filesystem, gmail, freespeech, lifetree, custom
- Each pattern has unique fields for domain-specific data`;

            const openaiRequest = {
                model: 'gpt-4o', // Using GPT-4o (latest optimized model)
                max_tokens: maxTokens,
                temperature: 0.7,
                messages: [
                    {
                        role: 'system',
                        content: systemPrompt || openaiDefaultPrompt
                    },
                    {
                        role: 'user',
                        content: prompt
                    }
                ]
            };

            const response = await fetch(
                'https://api.openai.com/v1/chat/completions',
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(openaiRequest)
                }
            );

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `OpenAI API error: ${response.status}`);
            }

            const data = await response.json();

            // Convert OpenAI response format to Claude-like format for consistency
            if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                throw new Error('Invalid OpenAI response structure');
            }

            return {
                json: async () => ({
                    content: [{
                        text: data.choices[0].message.content
                    }]
                }),
                ok: true
            };
        }

        // Unified AI API caller - supports multiple providers (Claude, Gemini, OpenAI)
        async function callClaudeAPI(prompt, systemPrompt = '', maxTokens = 1024, useExtendedThinking = false, retryCount = 0) {
            const MAX_RETRIES = 2;
            const provider = getAIProvider();

            // Apply AI Tuner persona settings to system prompt
            systemPrompt = applyPersonaTuning(systemPrompt);

            // Debug logging for Deep Mode routing
            if (useExtendedThinking) {
                console.log('ğŸ” Deep Mode requested:', { provider, useExtendedThinking, hasLocalKey: !!getLocalAPIKey('anthropic') });
            }

            // If Gemini is selected and user has Gemini key, use Gemini directly
            if (provider === 'gemini') {
                const geminiKey = getLocalAPIKey('gemini');
                if (geminiKey) {
                    // Check if running from local file - CORS will block Gemini API
                    const isLocalFile = window.location.protocol === 'file:';
                    if (isLocalFile) {
                        console.error('âŒ Gemini API blocked - running from local file');
                        console.warn('ğŸ’¡ Gemini requires web server deployment to avoid CORS');
                        console.warn('âœ… Solution 1: Deploy to Netlify/Vercel for Gemini support');
                        console.warn('âœ… Solution 2: Use Claude (has proxy fallback for local files)');
                        throw new Error(`Gemini API requires web server deployment (CORS policy).\n\nğŸ’¡ Solutions:\n1. Deploy to Netlify/Vercel - full Gemini support\n2. Use Claude provider - works from local files via proxy\n3. Open in web server (not file://)\n\nğŸ” Running from: ${window.location.protocol}\nâœ… Claude has proxy fallback, Gemini requires deployment`);
                    }

                    console.log('ğŸ”· Using Google Gemini');
                    try {
                        const response = await callGeminiDirectAPI(prompt, systemPrompt, maxTokens, geminiKey);
                        const data = await response.json();
                        return data.content[0].text;
                    } catch (error) {
                        console.error('âŒ Gemini API error:', error);
                        throw new Error(`Gemini error: ${error.message}`);
                    }
                } else {
                    // Gemini selected but no key - show helpful error
                    throw new Error('Gemini API key not found. Please add your Gemini API key (ğŸ”‘ button) or switch to Claude.');
                }
            }

            // If OpenAI is selected and user has OpenAI key, use OpenAI directly
            if (provider === 'openai') {
                const openaiKey = getLocalAPIKey('openai');
                if (openaiKey) {
                    // Check if running from local file - CORS will block OpenAI API
                    const isLocalFile = window.location.protocol === 'file:';
                    if (isLocalFile) {
                        console.error('âŒ ChatGPT API blocked - running from local file');
                        console.warn('ğŸ’¡ ChatGPT requires web server deployment to avoid CORS');
                        console.warn('âœ… Solution 1: Deploy to Netlify/Vercel for ChatGPT support');
                        console.warn('âœ… Solution 2: Use Claude (has proxy fallback for local files)');
                        throw new Error(`ChatGPT API requires web server deployment (CORS policy).\n\nğŸ’¡ Solutions:\n1. Deploy to Netlify/Vercel - full ChatGPT support\n2. Use Claude provider - works from local files via proxy\n3. Open in web server (not file://)\n\nğŸ” Running from: ${window.location.protocol}\nâœ… Claude has proxy fallback, ChatGPT requires deployment`);
                    }

                    console.log('ğŸ’¬ Using OpenAI ChatGPT');
                    try {
                        const response = await callOpenAIDirectAPI(prompt, systemPrompt, maxTokens, openaiKey);
                        const data = await response.json();
                        return data.content[0].text;
                    } catch (error) {
                        console.error('âŒ OpenAI API error:', error);
                        throw new Error(`OpenAI error: ${error.message}`);
                    }
                } else {
                    // OpenAI selected but no key - show helpful error
                    throw new Error('OpenAI API key not found. Please add your OpenAI API key (ğŸ”‘ button) or switch to Claude.');
                }
            }

            // Otherwise, use Claude (existing logic below)
            const localApiKey = getLocalAPIKey('anthropic'); // Get Claude key for Claude logic

            // ENFORCE: Deep Mode requires user API key (consistent with Gemini/ChatGPT)
            if (useExtendedThinking && !localApiKey) {
                throw new Error(`ğŸ§  Deep Mode requires your own API key to avoid Netlify's 10-second timeout.\n\nâœ… Solutions:\n1. Add your Anthropic API key (ğŸ”‘ button) - enables Deep Mode with Extended Thinking\n2. Switch to âš¡ Fast Mode - works with server API key\n\nğŸ’¡ Deep Mode uses Extended Thinking (5000 token reasoning budget) which can take 15-30 seconds - too slow for Netlify's free tier limit.\n\nGemini and ChatGPT also require user API keys for the same reason.`);
            }

            // Apply AI Tuner persona settings to system prompt
            const aiConfig = getAIConfig(); // Get AI config for temperature
            // Enhanced default prompt with TreeListy context
            const defaultSystemPrompt = `You are an expert project analyst specializing in breaking down complex projects into manageable components within TreeListy.

TREELISTY CONTEXT:
- TreeListy uses a 4-level hierarchy: Root â†’ Phases (children) â†’ Items (items) â†’ Subtasks (subItems)
- 21 specialized patterns available: generic, philosophy, sales, thesis, roadmap, book, event, fitness, strategy, course, prompting, film, veo3, sora2, dialogue, familytree, filesystem, gmail, freespeech, lifetree, custom
- Each pattern has unique fields (e.g., philosophy has speaker, premises, objections; sales has dealValue, probability, closeDate)
- Output JSON must match this structure for proper integration into the tree`;
            const finalSystemPrompt = applyPersonaTuning(systemPrompt || defaultSystemPrompt);

            const requestData = {
                model: AI_CONFIG.model,
                max_tokens: maxTokens,
                temperature: aiConfig.creativity, // âœ… INJECTED: Maps slider (0.0-1.0) to API temperature
                system: finalSystemPrompt,
                messages: [{
                    role: 'user',
                    content: prompt
                }]
            };

            // Use extended thinking for JSON generation to avoid syntax errors
            if (useExtendedThinking) {
                requestData.thinking = {
                    type: "enabled",
                    budget_tokens: 5000  // Increased from 2000 for Deep Mode (more reasoning time)
                };
                // CRITICAL: Temperature MUST be 1 when thinking is enabled
                // https://docs.claude.com/en/docs/build-with-claude/extended-thinking#important-considerations-when-using-extended-thinking
                requestData.temperature = 1;
            }

            let response;

            // CRITICAL: Deep Mode with user key MUST use direct API (never Netlify)
            // Gemini and ChatGPT always use direct API, Sonnet must too

            // Auto-detect local file access (file:// protocol)
            const isLocalFile = window.location.protocol === 'file:';

            if (useExtendedThinking && localApiKey) {
                // Check if running from local file - CORS will block direct API
                if (isLocalFile) {
                    console.warn('âš ï¸ Deep Mode requested but running from local file');
                    console.warn('ğŸ”„ Auto-switching to Fast Mode (Netlify proxy) to avoid CORS');
                    console.warn('ğŸ’¡ Deploy to web server for full Deep Mode support');

                    // Show user-facing info message about the auto-switch
                    console.info('â„¹ï¸ Running from local file - using Fast Mode instead of Deep Mode to avoid CORS errors');
                    console.info('âœ… Fast Mode still works great from local files via Netlify proxy');

                    // Fall through to Fast Mode (Netlify proxy) below
                    // This will work from local files but has 10s timeout limit
                } else {
                    // Running from deployed web server
                    // IMPORTANT: Anthropic's API does NOT allow direct browser calls (CORS blocked)
                    // We MUST use Netlify proxy, but Extended Thinking often exceeds 10s timeout
                    console.warn('âš ï¸ Deep Mode: Anthropic API blocks direct browser calls (CORS policy)');
                    console.warn('ğŸ”„ Using Netlify proxy with Extended Thinking - may timeout on complex requests');
                    console.warn('ğŸ’¡ For guaranteed Deep Mode: Use Gemini (allows direct API) or upgrade to Netlify Pro');

                    // Keep Extended Thinking enabled - let it try via Netlify
                    // User will get timeout error if it takes >10s, but smaller requests may work
                    // Fall through to Netlify proxy below
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 251: Prioritize Edge Function Streaming (No Timeout!)
            // Fallback chain: Edge Stream â†’ Edge Buffered â†’ Regular Function
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Try Edge Function STREAMING first (no timeout - returns headers immediately)
            // CRITICAL: Buffered mode times out at 40s because headers aren't returned until done
            // Streaming mode returns headers immediately, so can run indefinitely
            if (!isLocalFile) {
                try {
                    console.log('ğŸŒŠ Using Edge Function streaming (no timeout limit)...');
                    const result = await callClaudeStreamingAPI(requestData, localApiKey, null);
                    console.log('âœ… Edge Function streaming success!');
                    return result;
                } catch (edgeError) {
                    // Edge Function failed - fall back to regular function
                    console.warn('âš ï¸ Edge Function streaming failed, falling back to regular function:', edgeError.message);
                    // Continue to fallback below
                }
            }

            // Fallback: Regular Netlify Function (has 10s timeout)
            console.log('ğŸ“¦ Using regular Netlify function (10s timeout limit)');
            if (requestData.thinking) {
                console.log('ğŸ§  Deep Mode: Extended Thinking enabled');
                console.log('âš ï¸ Complex requests may timeout on free tier');
            }
            console.log(localApiKey ? 'ğŸ”‘ Using your API key' : 'ğŸŒ Using server API key');

            // Check if we're a guest using host's session keys
            const sessionToken = window.getCollabSessionToken?.() || null;

            const netlifyRequestBody = {
                ...requestData,
                userApiKey: localApiKey || undefined,
                sessionToken: sessionToken || undefined
            };

            if (sessionToken) {
                const hostName = window.getCollabHostName?.() || 'Host';
                console.log(`ğŸŸï¸ Using ${hostName}'s API keys via live session`);
            }

            // Timeout for regular function (Netlify has 10s limit)
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 25000);

            try {
                response = await fetch(AI_CONFIG.apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(netlifyRequestBody),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
            } catch (fetchError) {
                clearTimeout(timeoutId);

                // Handle timeout
                if (fetchError.name === 'AbortError' && localApiKey) {
                    if (isLocalFile) {
                        console.warn('âš ï¸ Netlify timeout. Trying direct API...');
                        try {
                            response = await callClaudeDirectAPI(requestData, localApiKey);
                            console.log('âœ… Direct API fallback successful!');
                        } catch (directError) {
                            console.error('âŒ Direct API fallback failed:', directError);
                            throw new Error(`Netlify timeout AND direct API failed.\n\nâœ… Solutions:\n1. Run via local server: python -m http.server 8000\n2. Use deployed site: https://treelisty.netlify.app\n3. Use âš¡ Fast Mode (Haiku) - faster`);
                        }
                    } else {
                        // From deployed site but Edge Function also failed
                        throw new Error(`â±ï¸ Request timeout (Netlify 10-second limit exceeded)

âŒ Claude API doesn't support CORS - cannot bypass Netlify from browser

This happened because:
â€¢ Your request took longer than 10 seconds
â€¢ Netlify free tier has 10-second function timeout
â€¢ Claude's API blocks direct browser calls (CORS policy)
â€¢ Unlike Gemini/ChatGPT, Claude requires a proxy server

âœ… Solutions:
1. Use server-sonnet or server-haiku (Fast Mode) - usually completes in <10s
2. Reduce your request size - fewer nodes, shorter text
3. Self-host with backend that has no timeout limits

ğŸ’¡ The Chat Builder works best with Fast Mode on Netlify.`);
                    }
                } else if (fetchError.name === 'AbortError') {
                    // Timeout but no user API key - can't fallback
                    throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nAdd your API key (ğŸ”‘ button) to bypass Netlify timeout.\n\nOr use âš¡ Fast Mode (Haiku) - faster and works everywhere.`);
                } else {
                    throw fetchError;
                }

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));

                    // Log detailed error info for debugging
                    console.error('âŒ AI API Error Details:', {
                        status: response.status,
                        statusText: response.statusText,
                        usingLocalKey: !!localApiKey,
                        error: error
                    });

                    // Check for common errors
                    if (response.status === 0 || !response.status) {
                        throw new Error('Cannot connect to AI service. Please check your internet connection.');
                    }
                    if (response.status === 401) {
                        if (localApiKey) {
                            clearLocalAPIKey();
                            throw new Error('Invalid API key. Please check your Anthropic API key and try again.');
                        }
                        throw new Error('Authentication failed. Please configure your API key.');
                    }
                    if (response.status === 404) {
                        throw new Error('Netlify function not found (404). The serverless function may not be deployed.');
                    }
                    if (response.status === 504) {
                        // Gateway timeout from Netlify
                        if (localApiKey) {
                            // Fallback to direct API if user has key
                            console.warn('âš ï¸ Netlify 504 timeout. Falling back to direct API...');
                            try {
                                response = await callClaudeDirectAPI(requestData, localApiKey);
                                console.log('âœ… Direct API fallback successful after 504!');
                                // Exit error handling - response is now successful
                            } catch (directError) {
                                console.error('âŒ Direct API fallback failed:', directError);

                                // Check if this is a CORS error
                                if (directError.message === 'Failed to fetch' || directError.name === 'TypeError') {
                                    throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nDirect API fallback blocked by browser (CORS - you're running from file://).\n\nâœ… Solutions:\n1. Run via local server: python -m http.server 8000\n2. Use deployed site: https://treelisty.netlify.app\n3. Use âš¡ Fast Mode (Haiku) - faster and works everywhere\n\nğŸ’¡ Sonnet is powerful but slow - works best on deployed sites or with local server.`);
                                }

                                throw new Error(`Netlify 504 timeout AND direct API failed. Error: ${directError.message}`);
                            }
                        } else {
                            throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nAdd your API key (ğŸ”‘ button) to bypass Netlify timeout.\n\nOr use âš¡ Fast Mode (Haiku) - faster and works everywhere.`);
                        }
                    }

                    // If response is now ok (after fallback), skip remaining error checks
                    if (response.ok) {
                        // Continue to response parsing below
                    } else if (response.status === 429) {
                        // Rate limit - retry with exponential backoff
                        if (retryCount < MAX_RETRIES) {
                            const delay = Math.pow(2, retryCount) * 3000; // 3s, 6s
                            console.log(`ğŸ”„ Rate limit hit. Retrying in ${delay/1000} seconds... (attempt ${retryCount + 1}/${MAX_RETRIES})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callClaudeAPI(prompt, systemPrompt, maxTokens, useExtendedThinking, retryCount + 1);
                        }
                        throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                    } else if (response.status === 529) {
                        // API overloaded - retry with exponential backoff
                        if (retryCount < MAX_RETRIES) {
                            const delay = Math.pow(2, retryCount) * 2000; // 2s, 4s
                            console.log(`ğŸ”„ API overloaded. Retrying in ${delay/1000} seconds... (attempt ${retryCount + 1}/${MAX_RETRIES})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callClaudeAPI(prompt, systemPrompt, maxTokens, useExtendedThinking, retryCount + 1);
                        }
                        throw new Error('Anthropic API is temporarily overloaded. Please wait 10-30 seconds and try again.');
                    } else if (response.status === 500 && error.error?.message?.includes('configuration')) {
                        throw new Error('AI service is not configured. Please set up your API key.');
                    } else {
                        // Generic error
                        throw new Error(error.error?.message || `AI Service Error: ${response.status}`);
                    }
                }
            } // End of Fast Mode (Netlify) path

            // Common response handling (works for both Deep Mode direct API and Fast Mode Netlify)
            const data = await response.json();
            console.log('âœ… AI analysis successful');
            console.log('API Response data:', data);

            // Handle response - check if content exists
            if (!data.content || !Array.isArray(data.content) || data.content.length === 0) {
                console.error('Invalid API response structure:', data);
                throw new Error('Invalid response from AI service');
            }

            return data.content[0].text;
        }

        // Generate intelligent project analysis
        async function generateAIAnalysis(item, analysisType = 'item') {
            // Determine if this is a subtask or regular item/phase
            const isSubtask = item.type === 'subtask';

            let systemPrompt = '';
            let userPrompt = '';

            if (isSubtask) {
                // SUBTASK AI: Pattern-aware analysis for subtasks
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;

                // Pattern-specific subtask analysis
                if (currentPattern === 'philosophy') {
                    systemPrompt = `You are a philosophy professor specializing in philosophical argumentation and dialectical reasoning.`;

                    userPrompt = `Analyze this philosophical ${levels.subtask.toLowerCase()}:

**${levels.subtask}:** ${item.name}
**Description:** ${item.description || 'N/A'}
${item.textualReference ? `**Textual Reference:** ${item.textualReference}\n` : ''}${item.notes ? `**Notes:** ${item.notes}\n` : ''}
Provide philosophical analysis covering:
1. **Argumentative Function** - How does this support strengthen the parent claim?
2. **Logical Structure** - Is the reasoning valid? Are there gaps?
3. **Evidence Quality** - How strong is the supporting evidence or reasoning?
4. **Objections** - What counter-arguments might challenge this support?
5. **Recommendations** - How to strengthen this supporting argument`;

                } else {
                    // Generic PM analysis for non-philosophy patterns
                    systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                    userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;
                }

            } else if (analysisType === 'subtask') {
                // Fallback - same as isSubtask, pattern-aware
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;

                if (currentPattern === 'philosophy') {
                    systemPrompt = `You are a philosophy professor specializing in philosophical argumentation and dialectical reasoning.`;

                    userPrompt = `Analyze this philosophical ${levels.subtask.toLowerCase()}:

**${levels.subtask}:** ${item.name}
**Description:** ${item.description || 'N/A'}
${item.textualReference ? `**Textual Reference:** ${item.textualReference}\n` : ''}${item.notes ? `**Notes:** ${item.notes}\n` : ''}
Provide philosophical analysis covering:
1. **Argumentative Function** - How does this support strengthen the parent claim?
2. **Logical Structure** - Is the reasoning valid? Are there gaps?
3. **Evidence Quality** - How strong is the supporting evidence or reasoning?
4. **Objections** - What counter-arguments might challenge this support?
5. **Recommendations** - How to strengthen this supporting argument`;

                } else {
                    systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                    userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;
                }

            } else if (analysisType === 'item') {
                // PROJECT ITEM AI: Pattern-aware analysis
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;

                // Pattern-specific system prompts and analysis
                if (currentPattern === 'philosophy') {
                    systemPrompt = `You are a philosophy professor specializing in classical and contemporary philosophical arguments, dialectical reasoning, and philosophical methodology.`;

                    userPrompt = `Analyze this philosophical ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.speaker ? `**Speaker/Philosopher:** ${item.speaker}\n` : ''}${item.argumentType ? `**Argument Type:** ${item.argumentType}\n` : ''}${item.premise1 ? `**Premise 1:** ${item.premise1}\n` : ''}${item.premise2 ? `**Premise 2:** ${item.premise2}\n` : ''}${item.conclusion ? `**Conclusion:** ${item.conclusion}\n` : ''}${item.keyTerms ? `**Key Terms:** ${item.keyTerms}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a philosophical analysis covering:
1. **Logical Validity** - Is the argument structure sound? Are the premises valid?
2. **Dialectical Strength** - How does this argument engage with opposing views?
3. **Conceptual Clarity** - Are key terms well-defined? Any ambiguities?
4. **Objections to Consider** - What counter-arguments should be addressed?
5. **Historical/Textual Context** - Relevant philosophical traditions or sources
6. **Recommendations** - How to strengthen this argument or explore it further`;

                } else if (currentPattern === 'sales') {
                    systemPrompt = `You are a sales strategist with 20 years of enterprise B2B experience, specializing in deal progression, competitive positioning, and revenue forecasting.`;

                    userPrompt = `Analyze this sales ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.dealValue ? `**Deal Value:** $${(item.dealValue || 0).toLocaleString()}\n` : ''}${item.expectedCloseDate ? `**Expected Close:** ${new Date(item.expectedCloseDate).toLocaleDateString()}\n` : ''}${item.leadSource ? `**Lead Source:** ${item.leadSource}\n` : ''}${item.contactPerson ? `**Contact:** ${item.contactPerson}\n` : ''}${item.stageProbability ? `**Close Probability:** ${item.stageProbability}%\n` : ''}${item.competitorInfo ? `**Competitive Intel:** ${item.competitorInfo}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a sales analysis covering:
1. **Deal Health** - Is this deal progressing appropriately for its stage?
2. **Competitive Positioning** - How to differentiate from competitors?
3. **Next Steps** - Specific actions to advance this deal (meetings, demos, proposals)
4. **Risk Factors** - What could derail this opportunity?
5. **Close Strategy** - Recommended approach to accelerate close
6. **Upsell/Cross-sell** - Opportunities to expand deal value`;

                } else if (currentPattern === 'thesis') {
                    systemPrompt = `You are an academic advisor helping graduate students structure rigorous research, with expertise in thesis development, argumentation, and scholarly writing.`;

                    userPrompt = `Analyze this academic ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.wordCount ? `**Current Words:** ${item.wordCount}\n` : ''}${item.targetWordCount ? `**Target Words:** ${item.targetWordCount}\n` : ''}${item.keyCitations ? `**Key Citations:** ${item.keyCitations}\n` : ''}${item.keyArgument ? `**Main Argument:** ${item.keyArgument}\n` : ''}${item.evidenceType ? `**Evidence Type:** ${item.evidenceType}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide an academic analysis covering:
1. **Argument Strength** - Is the thesis argument clear and defensible?
2. **Evidence Quality** - Is the evidence sufficient and appropriate?
3. **Citation Coverage** - Are key sources adequately referenced?
4. **Structural Coherence** - Does this fit logically within the overall thesis?
5. **Scholarly Rigor** - Areas to strengthen academic quality
6. **Recommendations** - Specific next steps for development`;

                } else if (currentPattern === 'roadmap') {
                    systemPrompt = `You are a product manager experienced in agile development, feature prioritization, and engineering execution strategy.`;

                    userPrompt = `Analyze this product ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.storyPoints ? `**Story Points:** ${item.storyPoints}\n` : ''}${item.userImpact ? `**User Impact:** ${item.userImpact}\n` : ''}${item.technicalRisk ? `**Technical Risk:** ${item.technicalRisk}\n` : ''}${item.engineeringEstimate ? `**Engineering Estimate:** ${item.engineeringEstimate}\n` : ''}${item.featureFlag ? `**Feature Flag:** ${item.featureFlag}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a product analysis covering:
1. **User Value** - Does this feature deliver clear user benefit?
2. **Technical Feasibility** - Are the story points and risk assessment realistic?
3. **Prioritization** - Where should this rank given impact vs effort?
4. **Dependencies** - Are upstream features properly identified?
5. **Implementation Strategy** - Recommended approach (MVP, feature flag, phased rollout)
6. **Success Metrics** - How to measure if this feature succeeds`;

                } else if (currentPattern === 'prompting') {
                    systemPrompt = `You are an AI/ML engineer expert in prompt engineering for Claude and GPT-4, specializing in system design, agent workflows, and prompt optimization.`;

                    userPrompt = `Analyze this prompt ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.systemPrompt ? `**System Prompt:** ${item.systemPrompt.substring(0, 200)}${item.systemPrompt.length > 200 ? '...' : ''}\n` : ''}${item.userPromptTemplate ? `**User Template:** ${item.userPromptTemplate.substring(0, 200)}${item.userPromptTemplate.length > 200 ? '...' : ''}\n` : ''}${item.modelTarget ? `**Model:** ${item.modelTarget}\n` : ''}${item.temperature ? `**Temperature:** ${item.temperature}\n` : ''}${item.maxTokens ? `**Max Tokens:** ${item.maxTokens}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a prompt engineering analysis covering:
1. **Prompt Quality** - Is the system/user prompt clear and well-structured?
2. **Best Practices** - OpenAI/Anthropic recommendations being followed?
3. **Few-Shot Examples** - Are examples sufficient and high-quality?
4. **Chain-of-Thought** - Should CoT be added for better reasoning?
5. **Edge Cases** - What failure modes should be addressed?
6. **Optimization** - How to improve accuracy, cost, or latency`;

                } else if (currentPattern === 'book') {
                    systemPrompt = `You are a professional fiction editor and writing coach, specializing in narrative structure, character development, and storytelling craft.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.wordCount ? `**Current Words:** ${item.wordCount}\n` : ''}${item.targetWordCount ? `**Target Words:** ${item.targetWordCount}\n` : ''}${item.plotPoints ? `**Plot Points:** ${item.plotPoints}\n` : ''}${item.characterArcs ? `**Character Arcs:** ${item.characterArcs}\n` : ''}${item.pacing ? `**Pacing:** ${item.pacing}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a narrative analysis covering:
1. **Story Structure** - Does this chapter serve the overall narrative arc?
2. **Character Development** - Are character arcs progressing appropriately?
3. **Pacing** - Is the rhythm and tension appropriate for this section?
4. **Plot Points** - Are key story beats landing effectively?
5. **Scene Craft** - Suggestions for strengthening individual scenes
6. **Recommendations** - Specific revisions to improve this chapter`;

                } else if (currentPattern === 'film') {
                    systemPrompt = `You are a cinematographer and film director specializing in AI video production (Sora, Veo, Runway Gen-3), with expertise in visual storytelling, camera work, and production planning.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.aiPlatform ? `**AI Platform:** ${item.aiPlatform}\n` : ''}${item.videoPrompt ? `**Video Prompt:** ${item.videoPrompt.substring(0, 200)}${item.videoPrompt.length > 200 ? '...' : ''}\n` : ''}${item.visualStyle ? `**Visual Style:** ${item.visualStyle}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.cameraMovement ? `**Camera Movement:** ${item.cameraMovement}\n` : ''}${item.lightingMood ? `**Lighting:** ${item.lightingMood}\n` : ''}${item.motionIntensity ? `**Motion Intensity:** ${item.motionIntensity}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a production analysis covering:
1. **Prompt Quality** - Is the video prompt detailed enough for Sora/Veo?
2. **Visual Cohesion** - Does this scene match the project's visual style?
3. **Camera & Lighting** - Are technical specs appropriate for the mood?
4. **Production Feasibility** - Can current AI platforms deliver this vision?
5. **Sequence Flow** - How does this scene connect to dependencies?
6. **Optimization** - How to improve prompt for better AI generation`;

                } else if (currentPattern === 'course') {
                    systemPrompt = `You are a senior instructional designer with 12+ years of experience and an M.Ed. in Curriculum & Instruction. Your expertise includes ADDIE and SAM methodologies, backward design (Wiggins & McTighe), Bloom's Taxonomy, Gagne's Nine Events of Instruction, adult learning theory (Knowles' andragogy), and Kirkpatrick's Four-Level Training Evaluation Model. You apply evidence-based pedagogical frameworks to optimize learning outcomes.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.learningObjectives ? `**Learning Objectives:** ${item.learningObjectives}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.difficultyLevel ? `**Difficulty:** ${item.difficultyLevel}\n` : ''}${item.prerequisites ? `**Prerequisites:** ${item.prerequisites}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a pedagogical analysis covering:
1. **Learning Objectives** - Are objectives SMART and mapped to Bloom's Taxonomy levels? (Remember/Understand/Apply/Analyze/Evaluate/Create)
2. **Content Structure** - Does it follow Gagne's Nine Events of Instruction?
3. **Difficulty Progression** - Is scaffolding appropriate for the prerequisite sequence?
4. **Assessment Design** - Are assessments formative, summative, or authentic? Do they align with objectives?
5. **Learning Modalities** - Does it address visual, auditory, kinesthetic, and multimodal learners?
6. **Recommendations** - How to improve learning outcomes using evidence-based practices`;

                } else if (currentPattern === 'fitness') {
                    systemPrompt = `You are a certified personal trainer and exercise physiologist with expertise in program design, exercise science, progressive overload, and injury prevention.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.targetMuscleGroups ? `**Target Muscles:** ${item.targetMuscleGroups}\n` : ''}${item.sets ? `**Sets:** ${item.sets}\n` : ''}${item.reps ? `**Reps:** ${item.reps}\n` : ''}${item.restTime ? `**Rest:** ${item.restTime}\n` : ''}${item.intensity ? `**Intensity:** ${item.intensity}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a fitness analysis covering:
1. **Exercise Selection** - Are exercises appropriate for the training goal?
2. **Volume & Intensity** - Are sets, reps, and intensity optimized for progression?
3. **Progressive Overload** - Is the program structured for strength/endurance gains?
4. **Injury Prevention** - Are there any form cues or mobility prerequisites needed?
5. **Recovery** - Is rest time and workout spacing appropriate?
6. **Recommendations** - How to optimize this workout for better results`;

                } else if (currentPattern === 'event') {
                    systemPrompt = `You are a professional event planner with experience in corporate events, weddings, and large-scale conferences, specializing in logistics, vendor coordination, and timeline management.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.venue ? `**Venue:** ${item.venue}\n` : ''}${item.attendeeCount ? `**Attendees:** ${item.attendeeCount}\n` : ''}${item.startTime ? `**Start Time:** ${item.startTime}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.vendor ? `**Vendor:** ${item.vendor}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide an event planning analysis covering:
1. **Timeline Feasibility** - Is the activity appropriately scheduled and paced?
2. **Logistics** - Are venue, equipment, and vendor requirements clear?
3. **Guest Experience** - How does this contribute to attendee satisfaction?
4. **Dependencies** - Are setup/breakdown and sequential activities properly coordinated?
5. **Contingency Planning** - What backup plans are needed for this activity?
6. **Recommendations** - How to improve execution and guest experience`;

                } else if (currentPattern === 'strategy') {
                    systemPrompt = `You are a senior business strategy consultant with 12+ years of experience leading Fortune 500 transformations. Your expertise spans classical strategic frameworks (Porter's Five Forces, SWOT, McKinsey 7-S Model, BCG Growth-Share Matrix), modern innovation theory (Clayton Christensen's disruption framework, Blue Ocean Strategy), and performance management systems (OKRs, Balanced Scorecard, Jobs-to-be-Done methodology). Your analytical approach integrates quantitative business metrics with qualitative market dynamics, drawing from the strategic thinking of Michael Porter, Andy Grove, and Rita McGrath.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.kpi ? `**KPI:** ${item.kpi}\n` : ''}${item.targetValue ? `**Target:** ${item.targetValue}\n` : ''}${item.currentValue ? `**Current:** ${item.currentValue}\n` : ''}${item.owner ? `**Owner:** ${item.owner}\n` : ''}${item.timeframe ? `**Timeframe:** ${item.timeframe}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a strategic analysis covering:
1. **Strategic Alignment** - Does this initiative support the overall strategic pillar?
2. **KPI Quality** - Are metrics measurable, achievable, and meaningful?
3. **Resource Requirements** - What capabilities or investments are needed?
4. **Dependencies** - Are prerequisite initiatives or decisions identified?
5. **Risk Assessment** - What could prevent success and how to mitigate?
6. **Recommendations** - How to maximize strategic impact`;

                } else if (currentPattern === 'familytree') {
                    systemPrompt = `You are a professional genealogist and family historian specializing in genealogical research, family tree documentation, and historical record analysis.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.birthDate ? `**Birth:** ${item.birthDate}\n` : ''}${item.deathDate ? `**Death:** ${item.deathDate}\n` : ''}${item.birthPlace ? `**Birth Place:** ${item.birthPlace}\n` : ''}${item.occupation ? `**Occupation:** ${item.occupation}\n` : ''}${item.spouse ? `**Spouse:** ${item.spouse}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a genealogical analysis covering:
1. **Record Completeness** - Are key vital records (birth, death, marriage) documented?
2. **Source Quality** - Are sources reliable and properly cited?
3. **Relationship Verification** - Are family connections well-supported by evidence?
4. **Research Gaps** - What additional records or information should be sought?
5. **Conflicting Data** - Are there any inconsistencies to resolve?
6. **Recommendations** - Next steps for strengthening this family branch documentation`;

                } else if (currentPattern === 'lifetree') {
                    // BUILD 374: LifeTree biographical event analysis
                    const subjectName = capexTree?.name?.replace(/^.*?['']s?\s*Life(tree)?$/i, '').trim() ||
                                       capexTree?.name?.replace(/\s*Life(tree)?$/i, '').trim() ||
                                       'the subject';

                    systemPrompt = `You are a compassionate oral historian and biographer helping document ${subjectName}'s life story. You specialize in:
- Helping people capture and preserve meaningful memories
- Asking thoughtful follow-up questions to enrich stories
- Providing historical and cultural context for time periods
- Connecting individual experiences to broader family narratives

Be warm, curious, and respectful. This is someone's precious life story.`;

                    userPrompt = `Help me understand and enrich this life event for ${subjectName}:

**Event:** ${item.name}
**When:** ${item.eventDate || item.description || 'Unknown time period'}
${item.location ? `**Where:** ${item.location}\n` : ''}${item.people ? `**Who was involved:** ${item.people}\n` : ''}${item.emotion ? `**Feeling/Tone:** ${item.emotion}\n` : ''}${item.source ? `**Remembered by:** ${item.source}\n` : ''}${item.confidence ? `**Certainty:** ${item.confidence}\n` : ''}${item.description ? `**Description:** ${item.description}\n` : ''}${item.notes ? `**Notes:** ${item.notes}\n` : ''}

Please provide:
1. **Historical Context** - What was happening in the world/community during this time that might relate to this event?
2. **Questions to Explore** - 2-3 thoughtful follow-up questions that could enrich this memory
3. **Connections** - How might this event connect to other life stages or family patterns?
4. **Details to Capture** - What sensory details, emotions, or specifics would make this memory more vivid?
5. **Preservation Notes** - Any documents, photos, or artifacts that might help verify or illustrate this event`;

                } else if (currentPattern === 'dialogue') {
                    systemPrompt = `You are a rhetoric and argumentation expert specializing in debate analysis, logical fallacies, persuasive communication, and interpersonal psychology. Your expertise includes classical rhetoric (Aristotle, Cicero), modern argumentation theory, and political theater analysis.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Speaker:** ${item.speaker || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.verbatimQuote ? `**Verbatim Quote:** "${item.verbatimQuote}"\n` : ''}${item.rhetoricalDevice ? `**Rhetorical Device:** ${item.rhetoricalDevice}\n` : ''}${item.logicalStructure ? `**Logical Structure:** ${item.logicalStructure}\n` : ''}${item.fallaciesPresent ? `**Fallacies Identified:** ${item.fallaciesPresent}\n` : ''}${item.hiddenMotivation ? `**Hidden Motivation:** ${item.hiddenMotivation}\n` : ''}${item.emotionalTone ? `**Emotional Tone:** ${item.emotionalTone}\n` : ''}${item.evidenceQuality ? `**Evidence Quality:** ${item.evidenceQuality}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a rhetorical analysis covering:
1. **Argument Strength** - Evaluate the logical validity and persuasive power of this statement
2. **Rhetorical Techniques** - What persuasive devices are employed? How effective are they?
3. **Logical Fallacies** - Identify any fallacies (ad hominem, straw man, false dichotomy, etc.) and their impact
4. **Hidden Motivations** - What unstated goals or biases might be driving this argument?
5. **Counterargument Strategy** - What would be the most effective rebuttal or opposing position?
6. **Evidence Assessment** - How strong is the supporting evidence? What's missing?
7. **Recommendations** - How could this argument be strengthened or how should an opponent respond?`;

                } else if (currentPattern === 'filesystem') {
                    systemPrompt = `You are "LibrarianAI" for TreeListy.

Your job is to manage and enrich a **single filesystem** (one TreeListy tree) without ever directly deleting or renaming anything. You operate only by updating node metadata and proposing non-destructive actions.

Given a list of nodes (files and folders) with:
- node_id, path, is_folder
- basic metadata (size, timestamps, mime/type hints)
- existing AI fields (if any)

Do the following for **this filesystem only**:

1. **Enrich metadata for each node**
   - Infer and/or update:
     - summary_short: 1â€“2 line human-readable description.
     - tags: topical keywords.
     - project_guess: likely project or collection name (string).
     - status: one of draft | working | final | archive_candidate.
     - sensitivity_level: low | medium | high (e.g. legal/financial/personal = high).
     - lifecycle_stage: active | stale | historical | junk_candidate.
     - ai_confidence: 0â€“1 float for your overall judgment.
   - Never invent impossible details; base everything on filenames, paths, and any provided content/metadata.

2. **Detect redundancy and clusters**
   - Group near-duplicate or strongly related files into clusters.
   - For each node, set:
     - cluster_id: stable ID shared by similar files, or null.
     - canonical_id: the node_id of the best representative in that cluster, or equal to its own node_id if it is canonical.
   - Prefer canonical files that are more recent, more complete, and more likely to be in the correct folder.

3. **Assess data quality**
   - For each node, compute:
     - data_quality_score: 0â€“100, based on naming clarity, location, redundancy, and completeness.
   - Higher scores = clearer, better placed, non-redundant, and likely still useful.

4. **Propose safe actions only**
   - Do **not** delete, rename, or move anything directly.
   - Instead, populate an ai_actions_pending list per node with suggested operations, for example:
     - {"action": "move", "target_folder": "...", "reason": "...", "confidence": 0.82}
     - {"action": "archive", "reason": "...", "confidence": 0.76}
   - Be conservative: when in doubt, lower confidence and prefer suggestion over aggressive cleanup.

Act as a cautious, explainable librarian: improve structure and clarity, reduce redundancy, and surface suggestions, but never take irreversible or destructive actions yourself.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'File'}
**Path:** ${item.filePath || 'N/A'}
${item.isFolder ? `**Is Folder:** Yes\n` : ''}${item.fileSize ? `**Size:** ${(item.fileSize / 1024).toFixed(1)} KB\n` : ''}${item.fileExtension ? `**Extension:** ${item.fileExtension}\n` : ''}${item.dateModified ? `**Modified:** ${new Date(item.dateModified).toLocaleDateString()}\n` : ''}${item.dateCreated ? `**Created:** ${new Date(item.dateCreated).toLocaleDateString()}\n` : ''}${item.fileOwner ? `**Owner:** ${item.fileOwner}\n` : ''}${item.mimeType ? `**MIME Type:** ${item.mimeType}\n` : ''}**Description:** ${item.description || 'None'}
**Notes:** ${item.notes || 'None'}

Provide a LibrarianAI analysis covering:
1. **Metadata Enrichment** - Suggest summary_short, tags, project_guess, status, sensitivity_level, lifecycle_stage, ai_confidence
2. **Redundancy Detection** - Is this part of a cluster? Suggest cluster_id and canonical_id if similar files exist
3. **Data Quality Score** - Rate 0-100 based on naming clarity, location appropriateness, redundancy, and usefulness
4. **Proposed Actions** - Suggest safe, non-destructive actions (move, archive, tag) with confidence scores
5. **Organization Insights** - How does this fit within the overall filesystem structure?
6. **Recommendations** - Conservative suggestions to improve organization without destructive changes`;

                } else {
                    // Generic/default pattern - Senior financial planning perspective
                    systemPrompt = `You are a senior financial planning manager with 15 years of experience in enterprise project finance, specializing in budget optimization, risk quantification, and resource allocation for Fortune 500 digital transformation initiatives. Your expertise spans Monte Carlo risk modeling, Earned Value Management (EVM), and Stage-Gate financial governance following PMI and COSO frameworks. You excel at translating complex project financials into executive-ready insights, identifying cost optimization opportunities, and creating data-driven contingency plans.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${pattern.fields?.cost ? `**Cost:** $${(item.cost || 0).toLocaleString()}\n` : ''}${pattern.fields?.leadTime ? `**Lead Time:** ${item.leadTime || 'Not specified'}\n` : ''}${pattern.fields?.alternateSource ? `**Alternate Source:** ${item.alternateSource || 'Not specified'}\n` : ''}${item.pmRAGStatus ? `**RAG Status:** ${item.pmRAGStatus}\n` : ''}${item.pmOwnerEmail ? `**Owner:** ${item.pmOwnerEmail}\n` : ''}${item.pmEstimatedHours ? `**Estimated Hours:** ${item.pmEstimatedHours}h\n` : ''}${item.pmActualHours ? `**Actual Hours:** ${item.pmActualHours}h\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None provided'}

From a PM and CFO perspective, provide analysis covering:
1. **Financial Health** - Budget status, cost drivers, burn rate concerns, ROI considerations
2. **Risk Assessment** - Financial risks, schedule risks, resource constraints, mitigation strategies
3. **Time & Resource Management** - Timeline realism, resource allocation efficiency, critical path impacts
4. **Vendor & Procurement** - Supplier reliability, alternate source evaluation, contract considerations
5. **Stakeholder & Governance** - Approval gates, change management, reporting requirements
6. **Strategic Recommendations** - 2-3 actionable steps to improve delivery, reduce cost, or mitigate risk`;
                }

            } else if (analysisType === 'project') {
                // Project-level analysis (PATTERN-AWARE)
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;
                const allItems = getAllProjectItems();

                // Build phase breakdown
                const phaseBreakdown = capexTree.children?.map((phase, idx) => {
                    const phaseItems = allItems.filter(i => i.id?.startsWith(`p${idx}`));
                    let phaseLine = `- ${phase.name}`;

                    if (phase.subtitle) phaseLine += ` (${phase.subtitle})`;
                    phaseLine += `: ${phaseItems.length} ${levels.item.toLowerCase()}s`;

                    if (pattern.fields?.cost) {
                        const phaseTotal = phaseItems.reduce((sum, i) => sum + (i.cost || 0), 0);
                        phaseLine += `, $${phaseTotal.toLocaleString()}`;
                    }

                    return phaseLine;
                }).join('\n') || 'No phases defined';

                // Pattern-specific prompts
                if (currentPattern === 'book') {
                    systemPrompt = `You are a literary consultant specializing in narrative structure and book development. Provide insights on story structure, pacing, character development, and writing best practices.`;

                    userPrompt = `Analyze this book writing project:

**Title:** ${capexTree.name}
**Pattern:** Book Writing

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Story Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} builds on ${i.dependencies.length} previous element(s)`
).join('\n')}

` : ''}Provide an executive summary for this book project covering:
1. **Narrative Structure Assessment** - Is the part/chapter breakdown balanced and logical?
2. **Story Flow** - Comment on pacing and progression based on dependencies
3. **Development Recommendations** - Suggestions for strengthening the narrative structure
4. **Potential Issues** - Any structural concerns or gaps in the story arc
5. **Next Steps** - Actionable recommendations for the author

Focus on narrative structure and storytelling best practices.`;

                } else if (currentPattern === 'prompting') {
                    systemPrompt = `You are a prompt engineering expert specializing in LLM workflows, agent design, and AI system architecture. Provide insights on prompt structure, agent orchestration, and best practices.`;

                    userPrompt = `Analyze this AI prompt design project:

**Prompt Workbook:** ${capexTree.name}
**Pattern:** AI Prompt Design

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Agent Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} requires ${i.dependencies.length} upstream component(s)`
).join('\n')}

` : ''}Provide an executive summary for this prompt engineering project covering:
1. **Architecture Assessment** - Is the stage/module breakdown logical for an AI workflow?
2. **Agent Orchestration** - Comment on dependencies and data flow between modules
3. **Prompt Engineering Best Practices** - Recommendations for improving prompt quality
4. **Potential Issues** - Any architectural concerns or missing components
5. **Next Steps** - Actionable recommendations for the prompt engineer

Focus on prompt engineering and agent design best practices.`;

                } else if (pattern.fields?.cost) {
                    // Financial patterns (generic, sales, roadmap, etc.)
                    systemPrompt = `You are a senior project analyst specializing in project planning, budgeting, and execution strategy. Provide insights on project structure, resource allocation, and execution best practices.`;

                    const totalCost = calculateTotal(capexTree);

                    userPrompt = `Analyze this ${pattern.name.toLowerCase()} project:

**Project:** ${capexTree.name}
**Pattern:** ${pattern.name}
**Total Budget:** $${totalCost.toLocaleString()}

**${levels.phase} Breakdown:**
${phaseBreakdown}

${allItems.filter(i => i.cost > 1000000).length > 0 ? `**Major Line Items (>$1M):**
${allItems.filter(i => i.cost > 1000000).map(i =>
    `- ${i.name}: $${i.cost.toLocaleString()}${i.itemType ? ` (${i.itemType})` : ''}`
).join('\n')}

` : ''}${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Key Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} depends on ${i.dependencies.length} item(s)`
).join('\n')}

` : ''}Provide an executive-level analysis covering:
1. **Budget Assessment** - Is the allocation realistic for this type of project?
2. **Critical Path** - Key dependencies and timeline bottlenecks
3. **Risk Factors** - Top 3 risks to budget or timeline
4. **Optimization Opportunities** - Potential cost savings or efficiency gains
5. **Strategic Recommendations** - High-level guidance for stakeholders

Format for presentation to executives. Be concise but comprehensive.`;

                } else {
                    // Non-financial patterns (philosophy, thesis, etc.)
                    systemPrompt = `You are an expert consultant specializing in structured thinking and project organization. Provide insights on project structure, logical flow, and development best practices.`;

                    userPrompt = `Analyze this ${pattern.name.toLowerCase()} project:

**Project:** ${capexTree.name}
**Pattern:** ${pattern.name}

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Logical Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} builds on ${i.dependencies.length} previous element(s)`
).join('\n')}

` : ''}Provide an executive summary covering:
1. **Structure Assessment** - Is the ${levels.phase.toLowerCase()}/${levels.item.toLowerCase()} breakdown logical and well-organized?
2. **Logical Flow** - Comment on progression and dependencies between elements
3. **Development Recommendations** - Suggestions for strengthening the structure
4. **Potential Issues** - Any structural concerns or gaps in coverage
5. **Next Steps** - Actionable recommendations for the author/creator

Focus on logical structure and content organization best practices.`;
                }
            }

            return await callClaudeAPI(userPrompt, systemPrompt);
        }

        // Helper to get all items from tree
        function getAllProjectItems(node = capexTree, items = []) {
            if (node.items) items.push(...node.items);
            if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
            return items;
        }

        // =============================================================================
        // END AI INTEGRATION
        // =============================================================================

        // Data - "Welcome to TreeListy" starter tree - visually striking canvas layout with 5 hyperedges
        let capexTree = {
            id: 'root',
            treeId: 'tree_welcome01', // Atlas: Immutable tree identifier
            nodeGuid: 'n_root0001', // Atlas: Stable node identifier
            schemaVersion: 2, // Atlas Identity Lockdown
            name: 'Welcome to TreeListy',
            type: 'root',
            icon: 'ğŸŒ³',
            expanded: true,
            description: 'Your ideas deserve structure. TreeListy transforms thoughts into organized, actionable trees. This guide walks you through everything - try clicking around!',
            canvasX: 700,
            canvasY: 450,
            hyperedges: [
                {
                    id: 'edge-dual-views',
                    name: 'Dual View System',
                    nodeIds: ['item-tree-view', 'item-canvas-view'],
                    edgeType: 'relates',
                    color: '#6366f1',
                    description: 'Same data, two perspectives - Tree View for editing, Canvas View for visualization'
                },
                {
                    id: 'edge-ai-pipeline',
                    name: 'AI Creation Pipeline',
                    nodeIds: ['item-chat-builder', 'item-import-text', 'item-smart-expand', 'item-deep-dive'],
                    edgeType: 'sequence',
                    color: '#10b981',
                    description: 'Build â†’ Import â†’ Enhance â†’ Analyze: AI assists at every stage'
                },
                {
                    id: 'edge-collab-flow',
                    name: 'Collaboration Workflow',
                    nodeIds: ['item-share-url', 'item-contributor-tags', 'item-collab-comments', 'item-watch-mode'],
                    edgeType: 'relates',
                    color: '#f59e0b',
                    description: 'Share â†’ Tag edits â†’ Comment â†’ Sync: Complete collaboration toolkit'
                },
                {
                    id: 'edge-canvas-features',
                    name: 'Canvas-Specific Features',
                    nodeIds: ['item-canvas-view', 'item-hyperedges', 'item-dependencies'],
                    edgeType: 'relates',
                    color: '#ec4899',
                    description: 'Visual features that shine in Canvas View - drag nodes, see connections, create hyperedges'
                },
                {
                    id: 'edge-getting-started',
                    name: 'Start Here',
                    nodeIds: ['item-new-tree', 'item-import-existing', 'item-chat-builder'],
                    edgeType: 'relates',
                    color: '#8b5cf6',
                    description: 'Three paths to begin: Start fresh, import existing work, or let AI build it'
                }
            ],
            pattern: { key: 'generic' },
            children: [
                {
                    id: 'phase-getting-started',
                    name: 'Getting Started',
                    subtitle: 'Your first 2 minutes',
                    description: 'The essentials to get you productive right away. Each item below teaches a core concept.',
                    type: 'phase',
                    icon: 'ğŸš€',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 250,
                    canvasY: 180,
                    items: [
                        {
                            id: 'item-tree-view',
                            name: 'Tree View',
                            description: "You're looking at it! A structured outline where you can expand/collapse sections. Click the arrows (â–¶) to toggle. Great for detailed editing and data entry.",
                            type: 'item',
                            icon: 'ğŸ“‹',
                            expanded: true,
                            canvasX: 83.47,
                            canvasY: -48.39,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'Done',
                            pmProgress: 100,
                            pmPriority: 'High',
                            subtasks: [
                                {
                                    id: 'sub-expand',
                                    name: 'Click arrows to expand/collapse',
                                    description: 'Try it now - click the â–¶ next to any phase or item',
                                    type: 'subtask',
                                    pmStatus: 'Done',
                                    pmProgress: 100
                                },
                                {
                                    id: 'sub-click-edit',
                                    name: 'Click any node to see details',
                                    description: 'The detail panel appears on the right with all fields',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                }
                            ]
                        },
                        {
                            id: 'item-canvas-view',
                            name: 'Canvas View',
                            description: "You're seeing it now! Drag nodes anywhere. Zoom with scroll wheel. See colored lines connecting related nodes - those are hyperedges. Try the layout dropdown for different arrangements.",
                            type: 'item',
                            icon: 'ğŸ¨',
                            expanded: true,
                            canvasX: -81.94,
                            canvasY: 177.20,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: [
                                {
                                    id: 'sub-drag',
                                    name: 'Drag nodes to rearrange',
                                    description: 'Click and drag any node to move it freely on the canvas',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                },
                                {
                                    id: 'sub-layouts',
                                    name: 'Try different layouts',
                                    description: 'Use the layout dropdown for Timeline, Radial, Force-Directed views',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                }
                            ]
                        },
                        {
                            id: 'item-right-click',
                            name: 'Right-Click Menu',
                            description: 'Right-click any node for a menu of actions: Add Child, Edit, Duplicate, Delete, Share Branch, and more. This is how you build and modify your tree.',
                            type: 'item',
                            icon: 'ğŸ–±ï¸',
                            expanded: false,
                            canvasX: 80,
                            canvasY: 360,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            subtasks: []
                        }
                    ]
                },
                {
                    id: 'phase-ai-features',
                    name: 'AI Superpowers',
                    subtitle: 'Let AI do the heavy lifting',
                    description: "TreeListy's AI features help you think, organize, and create faster. All powered by Claude, Gemini, or ChatGPT - you choose.",
                    type: 'phase',
                    icon: 'ğŸ¤–',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 250,
                    canvasY: 720,
                    items: [
                        {
                            id: 'item-chat-builder',
                            name: 'Chat Builder (Live Tree Agent)',
                            description: "Click 'ğŸ’¬ Chat Builder' in the sidebar. A floating Tree Agent frame appears - describe your project in plain English while watching the tree grow in real-time! Nodes pulse green when added, yellow when modified. Drag the frame anywhere, or double-click to reset position.",
                            type: 'item',
                            icon: 'ğŸ’¬',
                            expanded: true,
                            canvasX: 80,
                            canvasY: 580,
                            cost: 0,
                            leadTime: 2,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: [
                                {
                                    id: 'sub-chat-example',
                                    name: "Example: 'Plan a weekend trip to Portland'",
                                    description: 'AI will ask clarifying questions, then build a complete tree',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                },
                                {
                                    id: 'sub-tree-agent',
                                    name: 'Live Tree Agent Features',
                                    description: 'Draggable frame, visual node highlights, progress bar, voice input, minimize/close controls',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                }
                            ]
                        },
                        {
                            id: 'item-import-text',
                            name: 'Import Text',
                            description: "Click 'ğŸ“¥ Import Text' to paste any document, outline, or notes. AI extracts the structure automatically. Quick Mode for simple docs, Deep Mode for complex analysis.",
                            type: 'item',
                            icon: 'ğŸ“¥',
                            expanded: true,
                            canvasX: -282.04,
                            canvasY: 710.75,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: [
                                {
                                    id: 'sub-quick-mode',
                                    name: 'Quick Mode: Fast extraction',
                                    description: 'For meeting notes, simple outlines, straightforward documents',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                },
                                {
                                    id: 'sub-deep-mode',
                                    name: 'Deep Mode: Extended thinking',
                                    description: 'For academic papers, complex arguments, detailed analysis',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                }
                            ]
                        },
                        {
                            id: 'item-smart-expand',
                            name: 'Smart Expand',
                            description: "Click 'âœ¨ Smart Expand' to have AI enrich your existing tree. It adds subtasks, fills descriptions, and suggests missing pieces - without deleting your work.",
                            type: 'item',
                            icon: 'âœ¨',
                            expanded: false,
                            canvasX: 80,
                            canvasY: 860,
                            cost: 0,
                            leadTime: 2,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            subtasks: []
                        },
                        {
                            id: 'item-deep-dive',
                            name: 'Deep Dive Analysis',
                            description: "Select any node, right-click â†’ 'Deep Dive'. AI performs scholarly analysis: key concepts, implications, related ideas, counterarguments. Perfect for research.",
                            type: 'item',
                            icon: 'ğŸ”¬',
                            expanded: false,
                            canvasX: 250,
                            canvasY: 900,
                            cost: 0,
                            leadTime: 3,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            subtasks: []
                        }
                    ]
                },
                {
                    id: 'phase-patterns',
                    name: '21 Specialized Patterns',
                    subtitle: 'Purpose-built templates',
                    description: 'TreeListy adapts to your domain. Each pattern has custom fields, AI personas, and workflows optimized for that use case.',
                    type: 'phase',
                    icon: 'ğŸ¯',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 1150,
                    canvasY: 180,
                    items: [
                        {
                            id: 'item-pattern-selector',
                            name: 'Change Pattern',
                            description: "Click the pattern dropdown in the header (shows 'Generic Project' by default). Switch patterns anytime - your data is preserved and mapped to new fields.",
                            type: 'item',
                            icon: 'ğŸ”„',
                            expanded: true,
                            canvasX: 1341.98,
                            canvasY: -84.25,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: []
                        },
                        {
                            id: 'item-patterns-list',
                            name: 'Available Patterns',
                            description: 'Generic Project, Philosophy, Sales Pipeline, Academic Thesis, Product Roadmap, Book Writing, Event Planning, Fitness Program, Strategic Plan, Course Design, AI Video (Sora/Veo), Family Tree, Dialogue & Rhetoric, Gmail Workflow, File System, CAPEX/Angel Pitch, and more.',
                            type: 'item',
                            icon: 'ğŸ“š',
                            expanded: true,
                            canvasX: 1345.45,
                            canvasY: 59.22,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'In Progress',
                            pmProgress: 50,
                            pmPriority: 'Medium',
                            subtasks: [
                                {
                                    id: 'sub-philosophy',
                                    name: 'Philosophy: Arguments, premises, dialectics',
                                    description: 'Perfect for analyzing debates, building arguments, Socratic dialogue',
                                    type: 'subtask',
                                    pmStatus: 'Done',
                                    pmProgress: 100
                                },
                                {
                                    id: 'sub-sales',
                                    name: 'Sales: Deals, probability, contacts',
                                    description: 'Track your pipeline with deal values, close dates, and win probability',
                                    type: 'subtask',
                                    pmStatus: 'Done',
                                    pmProgress: 100
                                },
                                {
                                    id: 'sub-video',
                                    name: 'AI Video: Sora/Veo production prompts',
                                    description: 'Generate camera movements, lighting, and video prompts for AI video tools',
                                    type: 'subtask',
                                    pmStatus: 'Done',
                                    pmProgress: 100
                                }
                            ]
                        }
                    ]
                },
                {
                    id: 'phase-collaboration',
                    name: 'Collaboration',
                    subtitle: 'Work together',
                    description: 'Share trees with teammates, track who edited what, and sync changes in real-time or asynchronously.',
                    type: 'phase',
                    icon: 'ğŸ‘¥',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 1150,
                    canvasY: 720,
                    items: [
                        {
                            id: 'item-share-url',
                            name: 'Share via URL',
                            description: "Click 'Share' in header â†’ Copy link â†’ Anyone can open your exact tree instantly. No account needed. The entire tree is encoded in the URL.",
                            type: 'item',
                            icon: 'ğŸ”—',
                            expanded: false,
                            canvasX: 1568.69,
                            canvasY: 504.82,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: []
                        },
                        {
                            id: 'item-contributor-tags',
                            name: 'Contributor Tags',
                            description: "Edit any node â†’ scroll to 'Collaboration' section â†’ set your name. Your edits show a ğŸ‘¤ badge so collaborators know who changed what.",
                            type: 'item',
                            icon: 'ğŸ‘¤',
                            expanded: false,
                            canvasX: 1095.60,
                            canvasY: 697.69,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            contributor: 'TreeListy Team',
                            contributorTimestamp: '2024-12-01T12:00:00Z',
                            subtasks: []
                        },
                        {
                            id: 'item-collab-comments',
                            name: 'Collaboration Comments',
                            description: "Leave notes for teammates in the 'Collaboration Comments' field. Nodes with comments show a pulsing ğŸ’¬ indicator so they're easy to spot.",
                            type: 'item',
                            icon: 'ğŸ’¬',
                            expanded: false,
                            canvasX: 1540.93,
                            canvasY: 863.95,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            collabComments: 'This is an example comment! You can use this field to ask questions, leave feedback, or coordinate with collaborators.',
                            subtasks: []
                        },
                        {
                            id: 'item-live-sync',
                            name: 'Live Sync + Voice Chat',
                            description: "Click 'ğŸ”„ Live Sync' button â†’ Create or Join a room with 6-character ID. Multiple users edit simultaneously! Use the ğŸ™ï¸ Voice button for hands-free Jitsi voice chat.",
                            type: 'item',
                            icon: 'ğŸ”„',
                            expanded: false,
                            canvasX: 1150,
                            canvasY: 900,
                            cost: 0,
                            leadTime: 2,
                            pmStatus: 'To Do',
                            pmPriority: 'Low',
                            subtasks: []
                        }
                    ]
                },
                {
                    id: 'phase-advanced',
                    name: 'Power Features',
                    subtitle: 'Canvas-specific tools',
                    description: "These features shine in Canvas View - visual connections, dependencies, and project tracking.",
                    type: 'phase',
                    icon: 'âš¡',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 700,
                    canvasY: 180,
                    items: [
                        {
                            id: 'item-hyperedges',
                            name: 'Hyperedges',
                            description: "The colored lines connecting nodes in this view! Click the hyperedge panel (bottom-right) to create your own. Group related concepts across phases with visual connections.",
                            type: 'item',
                            icon: 'ğŸ”—',
                            expanded: false,
                            canvasX: 526.87,
                            canvasY: -88.80,
                            cost: 0,
                            leadTime: 2,
                            pmStatus: 'Done',
                            pmProgress: 100,
                            pmPriority: 'High',
                            subtasks: []
                        },
                        {
                            id: 'item-dependencies',
                            name: 'Dependencies',
                            description: "Link items that must complete before others can start. Edit an item â†’ Dependencies field â†’ select prerequisites. Dependencies show as arrows between nodes.",
                            type: 'item',
                            icon: 'â†—ï¸',
                            expanded: false,
                            canvasX: 825.71,
                            canvasY: 74.29,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            dependencies: ['item-right-click'],
                            subtasks: []
                        },
                        {
                            id: 'item-pm-tracking',
                            name: 'Project Tracking',
                            description: "Each item has status (To Do, In Progress, Done), assignee, due date, priority, and progress percentage. This node shows example values - check the detail panel!",
                            type: 'item',
                            icon: 'ğŸ“Š',
                            expanded: false,
                            canvasX: 1152.84,
                            canvasY: 293.02,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'In Progress',
                            pmProgress: 75,
                            pmAssignee: 'You',
                            pmPriority: 'High',
                            pmDueDate: '2025-12-31',
                            subtasks: []
                        },
                        {
                            id: 'item-export',
                            name: 'Export Options',
                            description: 'File menu â†’ Export as Excel (4-sheet workbook), JSON (for backup/sharing), or generate AI prompts from your tree structure.',
                            type: 'item',
                            icon: 'ğŸ“¤',
                            expanded: false,
                            canvasX: 731.35,
                            canvasY: 312.64,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'Low',
                            subtasks: []
                        }
                    ]
                },
                {
                    id: 'phase-next-steps',
                    name: 'Your Next Steps',
                    subtitle: 'Start creating',
                    description: 'Ready to build your own tree? Here are some ways to begin.',
                    type: 'phase',
                    icon: 'ğŸ¯',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 700,
                    canvasY: 720,
                    items: [
                        {
                            id: 'item-new-tree',
                            name: 'Start Fresh',
                            description: 'File menu â†’ New Tree. Choose a pattern that fits your project. Then use Chat Builder or just start adding phases manually.',
                            type: 'item',
                            icon: 'ğŸ†•',
                            expanded: false,
                            canvasX: 550,
                            canvasY: 850,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: []
                        },
                        {
                            id: 'item-import-existing',
                            name: 'Import Existing Work',
                            description: 'Have notes, docs, or outlines? Use Import Text to convert them into a structured tree. AI handles the organization.',
                            type: 'item',
                            icon: 'ğŸ“„',
                            expanded: false,
                            canvasX: 711.57,
                            canvasY: 664.93,
                            cost: 0,
                            leadTime: 2,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: []
                        },
                        {
                            id: 'item-save-work',
                            name: 'Save Your Work',
                            description: 'TreeListy auto-saves to your browser, but also save as JSON (File â†’ Save) for backup. You can reload it anytime, on any device.',
                            type: 'item',
                            icon: 'ğŸ’¾',
                            expanded: false,
                            canvasX: 941.38,
                            canvasY: 491.43,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: []
                        }
                    ]
                }
            ]
        };

        // =====================================================================
        // CANVAS VIEW INTEGRATION
        // =====================================================================

        let viewMode = 'tree';
        let canvasNodes = [];
        let canvasPan = { x: 0, y: 0 };
        let canvasZoom = 1;
        let isPanningCanvas = false;
        let isDraggingCanvasNode = false;
        let draggedCanvasNode = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let panStartX = 0;
        let panStartY = 0;
        let maxExpandedDepth = Infinity;  // Track how deep we're currently showing
        let gridEnabled = false;
        const gridSize = 40;  // Grid snap size
        let clusterByField = '';  // Track which metadata field to cluster by (itemType, owner, etc.)
        let sortClusterLinked = true;  // Auto-sync Sort and Cluster dropdowns

        // Multi-selection state
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionEnd = { x: 0, y: 0 };
        let selectedNodes = [];
        let isDraggingSelection = false;
        let selectionDragStart = { x: 0, y: 0 };

        // BUILD 447: Dependency creation state (Shift+drag)
        let isCreatingDependency = false;
        let depSourceNode = null;
        let depDragEndX = 0;
        let depDragEndY = 0;
        let depSnapTarget = null;

        // BUILD 330: Space key for Mac-friendly panning
        let isSpacePressed = false;

        // =====================================================================
        // BUILD 444: ANIMATION MANAGER - Smooth transitions for Canvas View
        // =====================================================================
        const animationManager = {
            active: [],                     // Currently running animations
            defaultDuration: 300,           // ms
            defaultEasing: 'easeOutCubic',

            // Check if user prefers reduced motion
            prefersReducedMotion() {
                return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            },

            // Queue an animation (cancels existing animation on same target)
            animate(targetId, fromProps, toProps, options = {}) {
                // Skip animation if user prefers reduced motion
                if (this.prefersReducedMotion()) {
                    this.applyFinalState(targetId, toProps);
                    if (options.onComplete) options.onComplete();
                    return;
                }

                // Cancel any existing animation for this target
                this.active = this.active.filter(a => a.targetId !== targetId);

                this.active.push({
                    targetId,
                    fromProps,
                    toProps,
                    startTime: performance.now(),
                    duration: options.duration || this.defaultDuration,
                    easing: options.easing || this.defaultEasing,
                    onComplete: options.onComplete,
                    onUpdate: options.onUpdate
                });

                if (this.active.length === 1) {
                    requestAnimationFrame(ts => this.tick(ts));
                }
            },

            // Animation loop - called every frame
            tick(timestamp) {
                if (this.active.length === 0) return;

                const completed = [];

                this.active.forEach(anim => {
                    const elapsed = timestamp - anim.startTime;
                    const progress = Math.min(elapsed / anim.duration, 1);
                    const easedProgress = this.ease(progress, anim.easing);

                    // Interpolate each property
                    Object.keys(anim.toProps).forEach(prop => {
                        const from = anim.fromProps[prop];
                        const to = anim.toProps[prop];
                        const current = from + (to - from) * easedProgress;
                        this.applyProperty(anim.targetId, prop, current);
                    });

                    // Call onUpdate if provided
                    if (anim.onUpdate) anim.onUpdate(easedProgress);

                    // Check if complete
                    if (progress >= 1) {
                        completed.push(anim);
                    }
                });

                // Remove completed animations and fire callbacks
                completed.forEach(anim => {
                    // Ensure final state is exact
                    this.applyFinalState(anim.targetId, anim.toProps);
                    if (anim.onComplete) anim.onComplete();
                });
                this.active = this.active.filter(a => !completed.includes(a));

                // Re-render canvas once per frame (batch all animations)
                // But skip if only viewport animations are running (they use updateCanvasTransform via onUpdate)
                const hasNodeAnimations = this.active.some(a => a.targetId !== 'viewport');
                if (hasNodeAnimations && typeof renderCanvas === 'function' && viewMode === 'canvas') {
                    renderCanvas();
                }

                // Continue animation loop if more animations active
                if (this.active.length > 0) {
                    requestAnimationFrame(ts => this.tick(ts));
                }
            },

            // Easing functions
            ease(t, type) {
                switch (type) {
                    case 'linear':
                        return t;
                    case 'easeOutCubic':
                        return 1 - Math.pow(1 - t, 3);
                    case 'easeInCubic':
                        return t * t * t;
                    case 'easeInOutCubic':
                        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                    case 'easeOutQuad':
                        return 1 - (1 - t) * (1 - t);
                    case 'easeInOutQuad':
                        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    case 'easeOutBack':
                        const c1 = 1.70158;
                        const c3 = c1 + 1;
                        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
                    case 'easeOutElastic':
                        if (t === 0 || t === 1) return t;
                        return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI) / 3) + 1;
                    default:
                        return t;
                }
            },

            // Apply a single property to a target
            applyProperty(targetId, prop, value) {
                // Special case: viewport properties
                if (targetId === 'viewport') {
                    if (prop === 'panX') canvasPan.x = value;
                    else if (prop === 'panY') canvasPan.y = value;
                    else if (prop === 'zoom') canvasZoom = value;
                    return;
                }

                // Find node by ID and set property
                const node = this.findNodeById(targetId);
                if (node) {
                    node[prop] = value;
                }
            },

            // Apply final state (ensures exact values, no floating point drift)
            applyFinalState(targetId, toProps) {
                if (targetId === 'viewport') {
                    if ('panX' in toProps) canvasPan.x = toProps.panX;
                    if ('panY' in toProps) canvasPan.y = toProps.panY;
                    if ('zoom' in toProps) canvasZoom = toProps.zoom;
                    return;
                }

                const node = this.findNodeById(targetId);
                if (node) {
                    Object.assign(node, toProps);
                }
            },

            // Find node by ID in the tree (cached for performance)
            findNodeById(nodeId) {
                // Use existing findNodeById if available
                if (typeof window.findNodeById === 'function') {
                    return window.findNodeById(nodeId);
                }

                // Fallback: search tree
                function searchTree(nodes) {
                    for (const node of nodes) {
                        if (node.id === nodeId) return node;
                        const children = node.subItems || node.children || node.items || [];
                        const found = searchTree(children);
                        if (found) return found;
                    }
                    return null;
                }

                // Search phases and their items
                for (const phase of (capexTree?.children || [])) {
                    if (phase.id === nodeId) return phase;
                    const items = phase.items || phase.children || phase.subItems || [];
                    const found = searchTree(items);
                    if (found) return found;
                }
                return null;
            },

            // Cancel all animations for a target
            cancel(targetId) {
                this.active = this.active.filter(a => a.targetId !== targetId);
            },

            // Cancel all animations
            cancelAll() {
                this.active = [];
            },

            // Check if any animations are running
            isAnimating() {
                return this.active.length > 0;
            },

            // Check if a specific target is animating
            isTargetAnimating(targetId) {
                return this.active.some(a => a.targetId === targetId);
            }
        };

        // Expose to window for debugging and external access
        window.animationManager = animationManager;

        // BUILD 444: Helper to animate canvas expand/collapse
        function animateCanvasExpandCollapse(item, isExpanding) {
            // Skip animation if reduced motion preferred
            if (animationManager.prefersReducedMotion()) {
                item.expanded = isExpanding;
                renderCanvas();
                return;
            }

            // Get children IDs that will appear/disappear
            const childList = item.subItems || item.children || [];
            const childIds = new Set();
            function collectChildIds(nodes) {
                nodes.forEach(n => {
                    if (n.id) childIds.add(n.id);
                    const children = n.subItems || n.children || [];
                    collectChildIds(children);
                });
            }
            collectChildIds(childList);

            if (isExpanding) {
                // EXPANDING: Set expanded, render, then animate in
                item.expanded = true;
                renderCanvas();

                // Add entering class to new child nodes, then trigger animation
                requestAnimationFrame(() => {
                    const newNodes = document.querySelectorAll('.canvas-node');
                    newNodes.forEach(nodeEl => {
                        const nodeId = nodeEl.dataset.itemId;
                        if (childIds.has(nodeId)) {
                            nodeEl.classList.add('node-entering');
                            // Force reflow, then add visible class
                            nodeEl.offsetHeight;
                            requestAnimationFrame(() => {
                                nodeEl.classList.remove('node-entering');
                                nodeEl.classList.add('node-visible');
                            });
                        }
                    });
                });
            } else {
                // COLLAPSING: Animate out, then set collapsed and re-render
                const nodesToAnimate = document.querySelectorAll('.canvas-node');
                const toFadeOut = [];

                nodesToAnimate.forEach(nodeEl => {
                    const nodeId = nodeEl.dataset.itemId;
                    if (childIds.has(nodeId)) {
                        toFadeOut.push(nodeEl);
                        nodeEl.style.opacity = '0';
                        nodeEl.style.transform = 'scale(0.8)';
                    }
                });

                // After animation completes, update state and re-render
                setTimeout(() => {
                    item.expanded = false;
                    renderCanvas();
                }, 250);
            }
        }

        // Expose for use in click handlers
        window.animateCanvasExpandCollapse = animateCanvasExpandCollapse;

        // Expose capexTree to window for Firebase sync (IIFE scope bridge)
        Object.defineProperty(window, 'capexTree', {
            get: function() { return capexTree; },
            set: function(value) { capexTree = value; },
            configurable: true
        });

        // Expose render functions to window for Firebase sync
        // These will be defined later, so we use a lazy getter pattern
        window.getTreeRenderer = function() { return typeof render === 'function' ? render : null; };
        window.getCanvasRenderer = function() { return typeof renderCanvas === 'function' ? renderCanvas : null; };

        /**
         * Get hyperedge membership for a node ID
         * Returns the hyperedge object if node is a member, null otherwise
         */
        function getNodeHyperedge(nodeId) {
            const hyperedges = capexTree.hyperedges || [];
            for (const he of hyperedges) {
                if (he.nodeIds && he.nodeIds.includes(nodeId)) {
                    return he;
                }
            }
            return null;
        }

        /**
         * Generate a unique color for a Deep Dive hyperedge based on index
         * Uses a palette of visually distinct, pleasant colors
         */
        const HYPEREDGE_COLOR_PALETTE = [
            { h: 270, s: 70, l: 60 },  // Purple (default analysis)
            { h: 200, s: 80, l: 55 },  // Blue
            { h: 160, s: 70, l: 45 },  // Teal
            { h: 340, s: 75, l: 60 },  // Pink
            { h: 30, s: 85, l: 55 },   // Orange
            { h: 280, s: 65, l: 65 },  // Violet
            { h: 180, s: 60, l: 45 },  // Cyan
            { h: 0, s: 70, l: 60 },    // Red
            { h: 45, s: 80, l: 50 },   // Gold
            { h: 220, s: 75, l: 60 },  // Royal Blue
            { h: 300, s: 60, l: 55 },  // Magenta
            { h: 140, s: 65, l: 45 },  // Green
        ];

        function generateHyperedgeColor(index) {
            const palette = HYPEREDGE_COLOR_PALETTE;
            const color = palette[index % palette.length];
            const { h, s, l } = color;

            return {
                fill: `hsla(${h}, ${s}%, ${l}%, 0.25)`,
                border: `hsla(${h}, ${s}%, ${l}%, 0.8)`,
                glow: `hsla(${h}, ${s}%, ${l}%, 0.5)`,
                solid: `hsl(${h}, ${s}%, ${l}%)`,
                hsl: { h, s, l }
            };
        }

        /**
         * Get hyperedge color - uses custom color if set, else type-based or generated
         */
        function getHyperedgeColor(hyperedge) {
            // If hyperedge has a custom color (check multiple locations)
            const customColor = hyperedge?.metadata?.color || hyperedge?.color;
            if (customColor) {
                // Handle both object format {fill, border, glow} and string format "#rrggbb"
                if (typeof customColor === 'string') {
                    // Convert hex color to RGBA variants
                    const hex = customColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    return {
                        fill: `rgba(${r}, ${g}, ${b}, 0.25)`,
                        border: `rgba(${r}, ${g}, ${b}, 0.9)`,
                        glow: `rgba(${r}, ${g}, ${b}, 0.5)`,
                        solid: customColor
                    };
                } else {
                    // Object format
                    return {
                        fill: customColor.fill || customColor,
                        border: customColor.border || customColor,
                        glow: customColor.glow || customColor,
                        solid: customColor.solid || customColor.border || customColor
                    };
                }
            }

            const typeColors = {
                'montage': { fill: 'rgba(251, 146, 60, 0.25)', border: 'rgba(251, 146, 60, 0.8)', glow: 'rgba(251, 146, 60, 0.4)', solid: '#fb923c' },
                'argument': { fill: 'rgba(59, 130, 246, 0.25)', border: 'rgba(59, 130, 246, 0.8)', glow: 'rgba(59, 130, 246, 0.4)', solid: '#3b82f6' },
                'theme': { fill: 'rgba(168, 85, 247, 0.25)', border: 'rgba(168, 85, 247, 0.8)', glow: 'rgba(168, 85, 247, 0.4)', solid: '#a855f7' },
                'dependency-cluster': { fill: 'rgba(34, 197, 94, 0.25)', border: 'rgba(34, 197, 94, 0.8)', glow: 'rgba(34, 197, 94, 0.4)', solid: '#22c55e' },
                'analysis': { fill: 'rgba(139, 92, 246, 0.25)', border: 'rgba(139, 92, 246, 0.8)', glow: 'rgba(139, 92, 246, 0.5)', solid: '#8b5cf6' },
                'default': { fill: 'rgba(156, 163, 175, 0.25)', border: 'rgba(156, 163, 175, 0.8)', glow: 'rgba(156, 163, 175, 0.4)', solid: '#9ca3af' }
            };
            return typeColors[hyperedge?.type] || typeColors.default;
        }

        // Track which hyperedge is being focused (null = show all)
        let focusedHyperedgeId = null;

        /**
         * Focus canvas view on a specific hyperedge
         * - Hides all nodes not in the hyperedge
         * - Auto-arranges member nodes in a clean layout
         * - Centers the view on the hyperedge
         */
        function focusOnHyperedge(hyperedgeId) {
            const hyperedge = (capexTree.hyperedges || []).find(h => h.id === hyperedgeId);
            if (!hyperedge) {
                console.warn('Hyperedge not found:', hyperedgeId);
                return;
            }

            console.log('ğŸ¯ Focusing on hyperedge:', hyperedge.label);
            focusedHyperedgeId = hyperedgeId;

            // Get all nodes that belong to this hyperedge
            const memberIds = new Set(hyperedge.nodeIds || []);

            // Find actual node objects and arrange them
            const memberNodes = [];
            function findNodes(node) {
                if (memberIds.has(node.id)) {
                    memberNodes.push(node);
                }
                // Check subitems
                if (node.subItems) {
                    node.subItems.forEach(sub => findNodes(sub));
                }
                if (node.children) {
                    node.children.forEach(child => findNodes(child));
                }
            }

            // Search through all phases
            capexTree.children.forEach(phase => {
                const nodeList = phase.items || phase.children || phase.subItems || [];
                nodeList.forEach(item => findNodes(item));
            });

            console.log(`ğŸ¯ Found ${memberNodes.length} member nodes`);

            // Separate parent nodes from subitems
            const parentNodes = memberNodes.filter(n => !n.id.startsWith('subitem-'));
            const subitemNodes = memberNodes.filter(n => n.id.startsWith('subitem-'));

            // Calculate layout dimensions
            const canvasContainer = document.getElementById('canvas-container');
            const containerWidth = canvasContainer?.offsetWidth || 1200;
            const containerHeight = canvasContainer?.offsetHeight || 800;

            // Layout parameters
            const nodeWidth = 320;
            const nodeHeight = 150;
            const padding = 80;
            const centerX = containerWidth / 2;
            const centerY = containerHeight / 2;

            // Arrange parent nodes in a row at the top
            const parentStartX = centerX - ((parentNodes.length * (nodeWidth + padding)) / 2) + padding / 2;
            parentNodes.forEach((node, idx) => {
                node.canvasX = parentStartX + idx * (nodeWidth + padding);
                node.canvasY = 100;
                node.expanded = true; // Ensure expanded to show subitems
            });

            // Arrange subitems below their parents or in a grid
            if (subitemNodes.length > 0) {
                // Try to position subitems below their parent
                subitemNodes.forEach((subitem, idx) => {
                    // Find parent by checking which parent's subItems contains this subitem
                    let parentNode = null;
                    for (const parent of parentNodes) {
                        if (parent.subItems && parent.subItems.some(s => s.id === subitem.id)) {
                            parentNode = parent;
                            break;
                        }
                    }

                    if (parentNode) {
                        // Position below parent
                        const siblingIdx = parentNode.subItems.findIndex(s => s.id === subitem.id);
                        subitem.canvasX = parentNode.canvasX + 50 + (siblingIdx % 2) * 180;
                        subitem.canvasY = parentNode.canvasY + nodeHeight + 60 + Math.floor(siblingIdx / 2) * (nodeHeight + 40);
                    } else {
                        // No parent found, arrange in grid below
                        const cols = Math.ceil(Math.sqrt(subitemNodes.length));
                        const row = Math.floor(idx / cols);
                        const col = idx % cols;
                        subitem.canvasX = centerX - (cols * (nodeWidth + padding) / 2) + col * (nodeWidth + padding);
                        subitem.canvasY = 350 + row * (nodeHeight + 60);
                    }
                });
            }

            // Re-render canvas with focus filter active
            renderCanvasWithFocus(memberIds);

            // Center the view
            canvasPan = { x: 50, y: 50 };
            canvasZoom = 0.9;
            updateCanvasTransform();

            // Show "exit focus" button
            showFocusModeIndicator(hyperedge);
        }

        /**
         * Exit focus mode and show all nodes
         */
        function exitFocusMode() {
            console.log('ğŸ¯ Exiting focus mode');
            focusedHyperedgeId = null;
            hideFocusModeIndicator();
            renderCanvas();
        }

        /**
         * Render canvas showing only focused nodes (or all if no focus)
         */
        function renderCanvasWithFocus(memberIds) {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('canvas-connections');

            if (!canvas || !svg) {
                console.error('Canvas elements not found');
                return;
            }

            // Clear existing content
            canvas.querySelectorAll('.canvas-node').forEach(n => n.remove());
            svg.innerHTML = '';
            canvasNodes = [];

            // Render only member nodes
            capexTree.children.forEach((phase, phaseIdx) => {
                if (phase.showInCanvas === false) return;

                const nodeList = phase.items || phase.children || phase.subItems || [];
                nodeList.forEach((item) => {
                    renderFocusedNodeAndDescendants(item, phase, null, 0, memberIds);
                });
            });

            // Draw connections and hyperedges
            drawConnections();
            updateCanvasTransform();
        }

        /**
         * Recursively render nodes, but only if they're in the focus set
         */
        function renderFocusedNodeAndDescendants(node, phase, parentNode, nestingLevel, memberIds) {
            // Only render if this node is in the focus set
            if (!memberIds.has(node.id)) {
                // But still check children in case they're members
                const childList = node.subItems || node.children || [];
                childList.forEach(child => {
                    renderFocusedNodeAndDescendants(child, phase, node, nestingLevel + 1, memberIds);
                });
                return;
            }

            // Check if parent is collapsed
            if (parentNode && parentNode.expanded === false) {
                return;
            }

            // Render this node
            renderCanvasNode(node, phase, parentNode, nestingLevel);

            // Recursively render children that are also members
            const childList = node.subItems || node.children || [];
            if (childList.length > 0 && node.expanded !== false) {
                childList.forEach((child, childIdx) => {
                    renderFocusedNodeAndDescendants(child, phase, node, nestingLevel + 1, memberIds);
                });
            }
        }

        /**
         * Show focus mode indicator with exit button
         */
        function showFocusModeIndicator(hyperedge) {
            // Remove existing indicator
            hideFocusModeIndicator();

            const indicator = document.createElement('div');
            indicator.id = 'focus-mode-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(139, 92, 246, 0.95);
                color: white;
                padding: 12px 24px;
                border-radius: 30px;
                display: flex;
                align-items: center;
                gap: 16px;
                z-index: 1000;
                box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);
                font-size: 14px;
            `;
            indicator.innerHTML = `
                <span>ğŸ¯ Focused: <strong>${getHyperedgeDisplayLabel(hyperedge)}</strong></span>
                <button onclick="exitFocusMode()" style="
                    background: rgba(255,255,255,0.2);
                    border: 1px solid rgba(255,255,255,0.3);
                    color: white;
                    padding: 6px 12px;
                    border-radius: 15px;
                    cursor: pointer;
                    font-size: 12px;
                ">âœ• Show All</button>
            `;

            document.body.appendChild(indicator);
        }

        /**
         * Hide focus mode indicator
         */
        function hideFocusModeIndicator() {
            const indicator = document.getElementById('focus-mode-indicator');
            if (indicator) {
                indicator.remove();
            }
        }

        // Track which hyperedges are hidden
        let hiddenHyperedges = new Set();

        /**
         * Toggle hyperedge visibility panel
         * BUILD 361: Enhanced with suggestions and aggregates
         */
        function toggleHyperedgePanel() {
            const existing = document.getElementById('hyperedge-visibility-panel');
            if (existing) {
                existing.remove();
                return;
            }

            // Detect suggestions on panel open
            detectSuggestedHyperedges();

            const hyperedges = capexTree.hyperedges || [];
            const suggestions = suggestedHyperedges || [];

            // Always allow panel to open - show empty state with Query option
            const isEmpty = hyperedges.length === 0 && suggestions.length === 0;

            // Check if info panel is open to adjust position
            const infoPanel = document.getElementById('info-panel');
            const infoPanelOpen = infoPanel && infoPanel.classList.contains('open');
            const rightOffset = infoPanelOpen ? 470 : 20; // 450px panel + 20px margin

            const panel = document.createElement('div');
            panel.id = 'hyperedge-visibility-panel';
            panel.style.cssText = `
                position: fixed;
                top: 120px;
                right: ${rightOffset}px;
                width: 320px;
                max-height: 500px;
                background: var(--surface-elevated);
                border: 1px solid var(--border-color);
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                z-index: 999;
                overflow: hidden;
                transition: right 0.3s;
            `;

            const header = document.createElement('div');
            header.style.cssText = `
                padding: 16px;
                border-bottom: 1px solid var(--border-color);
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;
            header.innerHTML = `
                <span style="font-weight: 600; color: var(--text-primary);">ğŸ”— Hyperedges (${hyperedges.length})</span>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button onclick="showQueryBuilderModal()" title="Create by Query"
                        style="background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.3); padding: 4px 8px; border-radius: 4px; color: #6366f1; cursor: pointer; font-size: 12px;">
                        ğŸ” Query
                    </button>
                    <button onclick="document.getElementById('hyperedge-visibility-panel').remove()"
                        style="background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 18px;">âœ•</button>
                </div>
            `;

            const list = document.createElement('div');
            list.style.cssText = `
                max-height: 380px;
                overflow-y: auto;
                padding: 8px;
            `;

            // BUILD 361: Suggestions section
            if (suggestions.length > 0) {
                const suggestionsHeader = document.createElement('div');
                suggestionsHeader.style.cssText = `
                    padding: 8px 12px;
                    margin-bottom: 8px;
                    background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.1));
                    border: 1px dashed rgba(251, 191, 36, 0.4);
                    border-radius: 8px;
                `;
                suggestionsHeader.innerHTML = `
                    <div style="font-size: 12px; font-weight: 600; color: #fbbf24; margin-bottom: 8px;">
                        ğŸ’¡ Suggested Groupings (${suggestions.length})
                    </div>
                `;

                suggestions.forEach(s => {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.style.cssText = `
                        padding: 8px 10px;
                        margin-bottom: 6px;
                        background: rgba(251, 191, 36, 0.05);
                        border: 1px solid rgba(251, 191, 36, 0.2);
                        border-radius: 6px;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    `;
                    suggestionItem.innerHTML = `
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-size: 12px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${s.label}
                            </div>
                            <div style="font-size: 10px; color: var(--text-secondary);">
                                ${s.nodeIds?.length || 0} nodes â€¢ ${s.description || ''}
                            </div>
                        </div>
                        <button onclick="event.stopPropagation(); acceptSuggestion('${s.id}'); toggleHyperedgePanel(); toggleHyperedgePanel();"
                            title="Create this hyperedge"
                            style="background: rgba(34, 197, 94, 0.2); border: 1px solid rgba(34, 197, 94, 0.3); padding: 4px 8px; border-radius: 4px; color: #22c55e; cursor: pointer; font-size: 11px;">
                            âœ“
                        </button>
                        <button onclick="event.stopPropagation(); dismissSuggestion('${s.id}'); this.closest('div').parentElement.remove();"
                            title="Dismiss suggestion"
                            style="background: rgba(239, 68, 68, 0.1); border: none; padding: 4px 6px; border-radius: 4px; color: #ef4444; cursor: pointer; font-size: 10px;">
                            âœ•
                        </button>
                    `;
                    suggestionsHeader.appendChild(suggestionItem);
                });

                list.appendChild(suggestionsHeader);
            }

            // BUILD 361: Empty state with helpful guidance
            if (isEmpty) {
                const emptyState = document.createElement('div');
                emptyState.style.cssText = `
                    padding: 24px 16px;
                    text-align: center;
                `;
                emptyState.innerHTML = `
                    <div style="font-size: 40px; margin-bottom: 12px; opacity: 0.6;">ğŸ”—</div>
                    <div style="font-size: 14px; color: var(--text-primary); margin-bottom: 8px;">
                        No hyperedges yet
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 16px; line-height: 1.5;">
                        Hyperedges group related nodes across your tree.<br>
                        Create one using the Query button above!
                    </div>
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 12px;">Try queries like:</div>
                    <div style="display: flex; flex-direction: column; gap: 6px; font-size: 11px;">
                        <code style="background: rgba(99, 102, 241, 0.1); padding: 6px 10px; border-radius: 4px; color: #818cf8;">
                            "show items over $500K"
                        </code>
                        <code style="background: rgba(99, 102, 241, 0.1); padding: 6px 10px; border-radius: 4px; color: #818cf8;">
                            "find blocked items"
                        </code>
                        <code style="background: rgba(99, 102, 241, 0.1); padding: 6px 10px; border-radius: 4px; color: #818cf8;">
                            "group by status"
                        </code>
                    </div>
                `;
                list.appendChild(emptyState);
            }

            // Existing hyperedges with aggregates
            if (hyperedges.length > 0) {
                const existingHeader = document.createElement('div');
                existingHeader.style.cssText = `
                    font-size: 11px;
                    color: var(--text-secondary);
                    padding: 4px 8px;
                    margin-top: ${suggestions.length > 0 ? '8px' : '0'};
                `;
                existingHeader.textContent = 'Your Hyperedges';
                list.appendChild(existingHeader);
            }

            hyperedges.forEach(he => {
                const colorObj = getHyperedgeColor(he);
                const isHidden = hiddenHyperedges.has(he.id);
                const aggregates = calculateHyperedgeAggregates(he);
                const aggregateStr = formatHyperedgeAggregates(aggregates);

                const item = document.createElement('div');
                item.style.cssText = `
                    padding: 10px 12px;
                    margin-bottom: 6px;
                    background: ${isHidden ? 'rgba(0,0,0,0.2)' : 'rgba(139, 92, 246, 0.1)'};
                    border: 1px solid ${isHidden ? 'var(--border-color)' : colorObj.border};
                    border-left: 3px solid ${colorObj.solid || '#8B5CF6'};
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    transition: all 0.2s;
                    opacity: ${isHidden ? '0.5' : '1'};
                `;
                item.innerHTML = `
                    <input type="checkbox" ${isHidden ? '' : 'checked'}
                        onchange="toggleHyperedgeVisibility('${he.id}')"
                        style="width: 18px; height: 18px; cursor: pointer; accent-color: ${colorObj.solid || '#8B5CF6'};">
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-size: 13px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${getHyperedgeDisplayLabel(he)}
                        </div>
                        <div style="font-size: 11px; color: var(--text-secondary);">
                            ${he.nodeIds?.length || 0} nodes${aggregateStr ? ' â€¢ ' + aggregateStr : ''}
                        </div>
                    </div>
                    <button onclick="event.stopPropagation(); focusOnHyperedge('${he.id}'); document.getElementById('hyperedge-visibility-panel').remove();"
                        style="background: rgba(139, 92, 246, 0.2); border: none; padding: 4px 8px; border-radius: 4px; color: #8B5CF6; cursor: pointer; font-size: 11px;">
                        ğŸ¯
                    </button>
                `;
                list.appendChild(item);
            });

            const footer = document.createElement('div');
            footer.style.cssText = `
                padding: 12px 16px;
                border-top: 1px solid var(--border-color);
                display: flex;
                gap: 8px;
            `;
            footer.innerHTML = `
                <button onclick="showAllHyperedges()"
                    style="flex: 1; padding: 8px; background: rgba(34, 197, 94, 0.2); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 6px; color: #22C55E; cursor: pointer; font-size: 12px;">
                    Show All
                </button>
                <button onclick="hideAllHyperedges()"
                    style="flex: 1; padding: 8px; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 6px; color: #EF4444; cursor: pointer; font-size: 12px;">
                    Hide All
                </button>
            `;

            panel.appendChild(header);
            panel.appendChild(list);
            panel.appendChild(footer);
            document.body.appendChild(panel);
        }

        /**
         * Toggle visibility of a specific hyperedge
         */
        function toggleHyperedgeVisibility(hyperedgeId) {
            if (hiddenHyperedges.has(hyperedgeId)) {
                hiddenHyperedges.delete(hyperedgeId);
            } else {
                hiddenHyperedges.add(hyperedgeId);
            }
            renderCanvas();
            // Refresh the panel
            const panel = document.getElementById('hyperedge-visibility-panel');
            if (panel) {
                panel.remove();
                toggleHyperedgePanel();
            }
        }

        /**
         * Show all hyperedges
         */
        function showAllHyperedges() {
            hiddenHyperedges.clear();
            renderCanvas();
            const panel = document.getElementById('hyperedge-visibility-panel');
            if (panel) {
                panel.remove();
                toggleHyperedgePanel();
            }
        }

        /**
         * Hide all hyperedges
         */
        function hideAllHyperedges() {
            (capexTree.hyperedges || []).forEach(he => {
                hiddenHyperedges.add(he.id);
            });
            renderCanvas();
            const panel = document.getElementById('hyperedge-visibility-panel');
            if (panel) {
                panel.remove();
                toggleHyperedgePanel();
            }
        }

        function toggleViewMode() {
            viewMode = viewMode === 'tree' ? 'canvas' : 'tree';

            if (viewMode === 'canvas') {
                console.log('ğŸ¨ Switching to Canvas View');
                document.getElementById('view-mode-icon').textContent = 'ğŸ“Š';
                document.getElementById('view-mode-text').textContent = 'Tree View';
                document.querySelector('.tree-view-container').classList.add('hidden');
                document.getElementById('canvas-container').classList.add('active');
                // BUILD 494: Close Calendar view if open
                const viewCalendar = document.getElementById('view-calendar');
                if (viewCalendar) viewCalendar.classList.remove('active');

                const toolbar = document.getElementById('canvas-toolbar');
                if (toolbar) {
                    toolbar.classList.add('active');
                    console.log('âœ… Canvas toolbar activated');
                } else {
                    console.error('âŒ Canvas toolbar not found!');
                }

                // Migrate coordinates if needed
                const firstPhase = capexTree.children[0];
                const firstItem = firstPhase?.items?.[0] || firstPhase?.children?.[0];
                if (!firstItem?.canvasX) {
                    migrateToCanvasCoordinates();
                } else {
                    // Even if coordinates exist, ensure expanded state is initialized
                    capexTree.children.forEach(phase => {
                        const nodeList = phase.items || phase.children || phase.subItems || [];
                        nodeList.forEach(item => {
                            initializeExpandedState(item);
                        });
                    });
                }

                // Initialize arrow markers first time
                initializeArrowMarkers();

                renderCanvas();
                updateZoomDisplay();

                // BUILD 435: Initialize search and minimap
                if (typeof initCanvasSearch === 'function') initCanvasSearch();
                if (typeof initMinimap === 'function') initMinimap();

                console.log('âœ… Canvas View ready');

                // Show one-time canvas tips for new users
                if (!localStorage.getItem('treelisty-canvas-tips-seen')) {
                    localStorage.setItem('treelisty-canvas-tips-seen', 'true');
                    setTimeout(() => {
                        showToast('ğŸ–±ï¸ Canvas Tips: Wheel to zoom, Space+drag to pan (or middle-click), Left-drag nodes to move. Click â“ for more!', 'info', 8000);
                    }, 500);
                }

                // Show export button in Canvas view
                const exportBtn = document.getElementById('export-canvas-btn');
                if (exportBtn) exportBtn.style.display = 'inline-flex';

                // BUILD 333: Update view dropdown to show current state
                if (window.updateViewDropdown) window.updateViewDropdown('canvas');
            } else {
                console.log('ğŸ“Š Switching to Tree View');
                document.getElementById('view-mode-icon').textContent = 'ğŸ¨';
                document.getElementById('view-mode-text').textContent = 'Canvas View';
                document.querySelector('.tree-view-container').classList.remove('hidden');
                document.getElementById('canvas-container').classList.remove('active');

                const toolbar = document.getElementById('canvas-toolbar');
                if (toolbar) {
                    toolbar.classList.remove('active');
                }

                // Hide export button in Tree view
                const exportBtn = document.getElementById('export-canvas-btn');
                if (exportBtn) exportBtn.style.display = 'none';

                // BUILD 333: Update view dropdown to show current state
                if (window.updateViewDropdown) window.updateViewDropdown('tree');

                render();
                console.log('âœ… Tree View ready');
            }
        }

        // =============================================================================
        // CANVAS EXPORT AS IMAGE (Build 244)
        // Professional PNG export with title, metadata, and branding
        // =============================================================================

        async function exportCanvasAsImage() {
            // Lazy load html2canvas library
            try {
                await loadLibrary('html2canvas');
            } catch (e) {
                showToast('Failed to load image export library. Please try again.', 'error');
                console.error('html2canvas load error:', e);
                return;
            }

            const canvasContainer = document.getElementById('canvas-container');
            const canvas = document.getElementById('canvas');

            if (!canvasContainer || !canvasContainer.classList.contains('active')) {
                showToast('âš ï¸ Switch to Canvas view first', 'warning');
                return;
            }

            showToast('ğŸ“· Preparing high-quality export...', 'info', 2000);

            try {
                // Get all node positions to calculate bounds
                const nodes = canvas.querySelectorAll('.canvas-node');
                if (nodes.length === 0) {
                    showToast('âš ï¸ No nodes to export', 'warning');
                    return;
                }

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                nodes.forEach(node => {
                    const rect = node.getBoundingClientRect();
                    const x = parseFloat(node.style.left) || 0;
                    const y = parseFloat(node.style.top) || 0;
                    const width = node.offsetWidth;
                    const height = node.offsetHeight;

                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x + width);
                    maxY = Math.max(maxY, y + height);
                });

                // Add generous padding
                const padding = 80;
                const headerHeight = 100;
                const footerHeight = 60;

                const contentWidth = maxX - minX + (padding * 2);
                const contentHeight = maxY - minY + (padding * 2) + headerHeight + footerHeight;

                // Create export container
                const exportContainer = document.createElement('div');
                exportContainer.id = 'export-container';
                exportContainer.style.cssText = `
                    position: fixed;
                    left: -99999px;
                    top: 0;
                    width: ${contentWidth}px;
                    height: ${contentHeight}px;
                    background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%);
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                    overflow: hidden;
                `;

                // Add subtle grid pattern
                const gridPattern = document.createElement('div');
                gridPattern.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background-image:
                        linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
                    background-size: 40px 40px;
                    pointer-events: none;
                `;
                exportContainer.appendChild(gridPattern);

                // Create header with project info
                const header = document.createElement('div');
                const patternDef = PATTERNS[currentPattern] || PATTERNS.generic;
                const totalItems = countAllItems(capexTree);
                const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });

                header.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    height: ${headerHeight}px;
                    padding: 20px 30px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border-bottom: 1px solid rgba(255,255,255,0.1);
                    background: linear-gradient(180deg, rgba(0,0,0,0.3) 0%, transparent 100%);
                `;

                header.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 16px;">
                        <div style="font-size: 28px; font-weight: 700; color: #ffffff; letter-spacing: -0.5px;">
                            ${capexTree.name || 'Untitled Project'}
                        </div>
                        <div style="
                            background: linear-gradient(135deg, #00A67D, #1D6F42);
                            padding: 4px 12px;
                            border-radius: 20px;
                            font-size: 12px;
                            font-weight: 600;
                            color: white;
                            text-transform: uppercase;
                            letter-spacing: 0.5px;
                        ">
                            ${patternDef.icon} ${patternDef.name}
                        </div>
                    </div>
                    <div style="text-align: right; color: rgba(255,255,255,0.6); font-size: 13px;">
                        <div style="font-weight: 600; color: rgba(255,255,255,0.8);">${totalItems} items</div>
                        <div>${dateStr}</div>
                    </div>
                `;
                exportContainer.appendChild(header);

                // Clone canvas content
                const canvasClone = canvas.cloneNode(true);
                canvasClone.style.cssText = `
                    position: absolute;
                    top: ${headerHeight + padding - minY}px;
                    left: ${padding - minX}px;
                    transform: none;
                `;
                exportContainer.appendChild(canvasClone);

                // Clone SVG connections
                const svgOriginal = document.getElementById('canvas-connections');
                if (svgOriginal) {
                    const svgClone = svgOriginal.cloneNode(true);
                    svgClone.style.cssText = `
                        position: absolute;
                        top: ${headerHeight + padding - minY - 5000}px;
                        left: ${padding - minX - 5000}px;
                        width: 20000px;
                        height: 20000px;
                        pointer-events: none;
                    `;
                    exportContainer.appendChild(svgClone);
                }

                // Create footer with branding
                const footer = document.createElement('div');
                footer.style.cssText = `
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    height: ${footerHeight}px;
                    padding: 15px 30px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border-top: 1px solid rgba(255,255,255,0.1);
                    background: linear-gradient(0deg, rgba(0,0,0,0.3) 0%, transparent 100%);
                `;

                footer.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 18px;">ğŸŒ³</span>
                        <span style="
                            font-size: 14px;
                            font-weight: 600;
                            color: rgba(255,255,255,0.7);
                            letter-spacing: 1px;
                        ">TreeListy</span>
                        <span style="
                            font-size: 11px;
                            color: rgba(255,255,255,0.4);
                            margin-left: 8px;
                        ">treelisty.netlify.app</span>
                    </div>
                    <div style="
                        font-size: 11px;
                        color: rgba(255,255,255,0.4);
                    ">
                        Exported ${new Date().toLocaleTimeString()}
                    </div>
                `;
                exportContainer.appendChild(footer);

                // Add to DOM
                document.body.appendChild(exportContainer);

                // Use html2canvas to capture
                const exportCanvas = await html2canvas(exportContainer, {
                    backgroundColor: null,
                    scale: 2, // 2x for retina quality
                    useCORS: true,
                    allowTaint: true,
                    logging: false
                });

                // Remove export container
                document.body.removeChild(exportContainer);

                // Convert to blob and download
                exportCanvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const safeName = (capexTree.name || 'treelisty-canvas')
                        .toLowerCase()
                        .replace(/[^a-z0-9]+/g, '-')
                        .replace(/^-|-$/g, '');
                    link.download = `${safeName}-${new Date().toISOString().slice(0,10)}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);

                    showToast('âœ… Canvas exported as PNG!', 'success');
                }, 'image/png', 1.0);

            } catch (error) {
                console.error('Canvas export error:', error);
                showToast('âŒ Export failed: ' + error.message, 'error');
            }
        }

        // Helper to count all items recursively
        function countAllItems(tree) {
            let count = 0;
            function countNode(node) {
                count++;
                const children = node.subItems || node.children || node.items || [];
                children.forEach(countNode);
            }
            if (tree.children) {
                tree.children.forEach(phase => {
                    const items = phase.items || phase.children || phase.subItems || [];
                    items.forEach(countNode);
                });
            }
            return count;
        }

        function migrateToCanvasCoordinates() {
            let xOffset = 200;
            const ySpacing = 180;

            capexTree.children.forEach((phase, phaseIdx) => {
                let yOffset = 100;
                // Support both 'items' (standard) and 'children' (filesystem pattern)
                const nodeList = phase.items || phase.children || phase.subItems || [];
                nodeList.forEach((item) => {
                    item.canvasX = xOffset + 50;
                    item.canvasY = yOffset;
                    yOffset += ySpacing;

                    // Ensure all items with subItems have expanded state initialized
                    initializeExpandedState(item);
                });
                xOffset += 400;
            });
        }

        // Clear all canvas coordinates recursively to force re-positioning
        function clearCanvasCoordinates(node) {
            delete node.canvasX;
            delete node.canvasY;

            // Recursively clear for all child types
            const childList = node.items || node.children || node.subItems || [];
            childList.forEach(child => clearCanvasCoordinates(child));
        }

        // Recursively initialize expanded state for all items with children
        function initializeExpandedState(item) {
            // Support both 'subItems' (standard) and 'children' (filesystem pattern)
            const childList = item.subItems || item.children || [];
            if (childList.length > 0) {
                // Default to expanded if not explicitly set
                if (item.expanded === undefined) {
                    item.expanded = true;
                    console.log('Initializing expanded=true for:', item.name);
                }

                // Recursively initialize for all descendants
                childList.forEach(child => {
                    initializeExpandedState(child);
                });
            }
        }

        // Listen for Firebase sync updates
        window.addEventListener('treelisty-sync-update', (e) => {
            console.log('ğŸ”¥ Received sync update event, re-rendering...');
            // Always re-render tree view
            render();
            // Check if canvas view is active and render it too
            const canvasContainer = document.getElementById('canvas-container');
            if (canvasContainer && canvasContainer.classList.contains('active')) {
                renderCanvas();
            }
            // Mark as changed so auto-save will persist the synced data
            if (typeof treeManager !== 'undefined' && treeManager.markAsChanged) {
                treeManager.markAsChanged();
                console.log('ğŸ”¥ Marked tree as changed for auto-save');
            }
        });

        function renderCanvas() {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('canvas-connections');

            // Clear existing content
            canvas.querySelectorAll('.canvas-node').forEach(n => n.remove());
            svg.innerHTML = '';
            canvasNodes = [];

            // BUILD 536: Render all nodes recursively, respecting expanded state
            // If root is collapsed, only show root node
            if (capexTree.expanded === false) {
                // Root is collapsed - render only root node
                renderCanvasNode(capexTree, null, null, 0);
            } else {
                capexTree.children.forEach((phase, phaseIdx) => {
                    // Check if phase is visible in Canvas View (default: true)
                    if (phase.showInCanvas === false) {
                        return; // Skip this phase
                    }

                    // BUILD 536: Check if phase is collapsed
                    if (phase.expanded === false) {
                        // BUILD 599: Auto-position collapsed phase nodes if no position set
                        if (phase.canvasX === undefined || phase.canvasY === undefined) {
                            // Grid layout: 2 columns, 250px spacing
                            const col = phaseIdx % 2;
                            const row = Math.floor(phaseIdx / 2);
                            phase.canvasX = phase.canvasX !== undefined ? phase.canvasX : (50 + col * 500);
                            phase.canvasY = phase.canvasY !== undefined ? phase.canvasY : (50 + row * 250);
                        }
                        // Phase is collapsed - render phase node but not its children
                        renderCanvasNode(phase, null, capexTree, 0);
                        return;
                    }

                    // Support 'items' (standard), 'children' (filesystem), and 'subItems' (philosophy)
                    const nodeList = phase.items || phase.children || phase.subItems || [];
                    nodeList.forEach((item, itemIdx) => {
                        // Preserve existing positions for root items to prevent jumping
                        // Only set initial position if not already set
                        if (!item.canvasX || !item.canvasY) {
                            item.canvasX = item.canvasX || 50;
                            item.canvasY = item.canvasY || (50 + itemIdx * 180);
                        }
                        renderNodeAndDescendants(item, phase, null, 0);
                    });
                });
            }

            // Draw connection lines after all nodes are positioned
            drawConnections();
            // BUILD 421: Draw hyperedges after connections (was missing, causing show/hide bug)
            drawHyperedges();

            // BUILD 565: Render image analysis overlays if present
            if (capexTree._imageAnalysis) {
                renderCanvasBackgroundImage();
                drawBoundingBoxes();
                // Show image analysis toolbar controls
                const imgControls = document.getElementById('image-analysis-controls');
                if (imgControls) imgControls.style.display = 'flex';
                // BUILD 567: Populate type filter dropdown
                populateBboxTypeFilter();
            } else {
                // Hide image analysis toolbar controls
                const imgControls = document.getElementById('image-analysis-controls');
                if (imgControls) imgControls.style.display = 'none';
                // Hide background image if no analysis
                const bgContainer = document.getElementById('canvas-background-image');
                if (bgContainer) bgContainer.style.display = 'none';
            }

            updateCanvasTransform();
            // BUILD 435: Update minimap after rendering
            if (typeof updateMinimap === 'function') updateMinimap();
            // BUILD 456: Show/hide Critical Path button based on dependencies
            if (typeof updateCriticalPathVisibility === 'function') updateCriticalPathVisibility();
        }

        // Recursive function to render a node and all its descendants
        function renderNodeAndDescendants(node, phase, parentNode, nestingLevel) {
            // Check if parent is collapsed - if so, don't render this node
            if (parentNode && parentNode.expanded === false) {
                return;  // Parent is collapsed, skip this node
            }

            // Render this node with hierarchical depth
            renderCanvasNode(node, phase, parentNode, nestingLevel);

            // Recursively render all descendants only if this node is expanded (or has no explicit state)
            // Support both 'subItems' (standard) and 'children' (filesystem pattern)
            const childList = node.subItems || node.children || [];
            if (childList.length > 0) {
                // Default to expanded if not set
                if (node.expanded === undefined) {
                    node.expanded = true;
                }

                childList.forEach((child, childIdx) => {
                    // Auto-position children based on nesting level
                    if (!child.canvasX) {
                        // Each nesting level moves further right
                        child.canvasX = (node.canvasX || 0) + 350;
                        child.canvasY = (node.canvasY || 0) + (childIdx * 120);
                    }

                    // Recursively render this child and its descendants
                    renderNodeAndDescendants(child, phase, node, nestingLevel + 1);
                });
            }
        }

        // =============================================================================
        // CONVEX HULL COMPUTATION (Graham Scan Algorithm)
        // =============================================================================

        /**
         * Compute convex hull using Graham scan algorithm
         * @param {Array} points - Array of {x, y} points
         * @returns {Array} Points forming the convex hull in counter-clockwise order
         */
        function computeConvexHull(points) {
            if (points.length < 3) return points;

            // Sort points by y-coordinate (bottom to top), then x-coordinate (left to right)
            const sorted = [...points].sort((a, b) => {
                if (a.y !== b.y) return a.y - b.y;
                return a.x - b.x;
            });

            // Helper: Compute cross product of vectors OA and OB
            const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

            // Build lower hull
            const lower = [];
            for (const p of sorted) {
                while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                    lower.pop();
                }
                lower.push(p);
            }

            // Build upper hull
            const upper = [];
            for (let i = sorted.length - 1; i >= 0; i--) {
                const p = sorted[i];
                while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                    upper.pop();
                }
                upper.push(p);
            }

            // Remove last point of each half because it's repeated
            lower.pop();
            upper.pop();

            return lower.concat(upper);
        }

        /**
         * Create a capsule/pill SVG path connecting two points
         * Used for 2-node hyperedges where convex hull fails
         */
        function createCapsulePath(p1, p2, radius) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.hypot(dx, dy);

            // If points overlap, create a circle
            if (dist < 1) {
                return `M ${p1.x - radius} ${p1.y}
                        a ${radius} ${radius} 0 1 0 ${radius * 2} 0
                        a ${radius} ${radius} 0 1 0 ${-radius * 2} 0 Z`;
            }

            // Normalize direction vector
            const nx = dx / dist;
            const ny = dy / dist;

            // Perpendicular vector scaled by radius
            const px = -ny * radius;
            const py = nx * radius;

            // Four corners of the capsule body
            const c1 = { x: p1.x + px, y: p1.y + py };
            const c2 = { x: p1.x - px, y: p1.y - py };
            const c3 = { x: p2.x - px, y: p2.y - py };
            const c4 = { x: p2.x + px, y: p2.y + py };

            // SVG path: straight sides + semicircle end caps
            return `M ${c1.x} ${c1.y}
                    L ${c4.x} ${c4.y}
                    A ${radius} ${radius} 0 0 1 ${c3.x} ${c3.y}
                    L ${c2.x} ${c2.y}
                    A ${radius} ${radius} 0 0 1 ${c1.x} ${c1.y} Z`;
        }

        // =============================================================================
        // HYPEREDGE VISUALIZATION
        // =============================================================================

        /**
         * BUILD 283: Get a display label for a hyperedge
         * If no label exists, derive a concise one from description (<5 words)
         */
        function getHyperedgeDisplayLabel(hyperedge) {
            // If name exists (used by welcome tree and older hyperedges), use it
            if (hyperedge.name && hyperedge.name.trim()) {
                return hyperedge.name;
            }

            // If label exists and is meaningful, use it
            if (hyperedge.label && hyperedge.label.trim() && hyperedge.label !== 'Unnamed Hyperedge') {
                return hyperedge.label;
            }

            // Try to derive from description
            if (hyperedge.description && hyperedge.description.trim()) {
                const desc = hyperedge.description.trim();
                // Take first sentence or up to 50 chars
                let concise = desc.split(/[.!?]/)[0].trim();
                if (concise.length > 50) {
                    // Take first ~5 words
                    const words = concise.split(/\s+/).slice(0, 5);
                    concise = words.join(' ');
                    if (concise.length < desc.length) concise += '...';
                }
                return concise || 'Relationship';
            }

            // Fallback based on type
            if (hyperedge.type) {
                const typeLabels = {
                    'analysis': 'Deep Dive Analysis',
                    'dependency-cluster': 'Dependency Cluster',
                    'montage': 'Montage',
                    'argument': 'Argument',
                    'theme': 'Theme'
                };
                return typeLabels[hyperedge.type] || `${hyperedge.type} Relationship`;
            }

            return 'Relationship';
        }

        /**
         * BUILD 361: Calculate aggregates for a hyperedge's member nodes
         * Returns pattern-aware metrics (cost, progress, lead time, etc.)
         * Called live on render for dynamic updates
         */
        function calculateHyperedgeAggregates(hyperedge) {
            const nodeIds = hyperedge.nodeIds || [];
            const nodes = nodeIds.map(id => getNodeById(id)).filter(Boolean);

            if (nodes.length === 0) {
                return { count: 0 };
            }

            const pattern = capexTree.pattern?.key || 'generic';

            // Helper functions
            const sum = arr => arr.reduce((a, b) => a + b, 0);
            const avg = arr => arr.length > 0 ? sum(arr) / arr.length : 0;
            const countBy = (arr, key) => arr.reduce((acc, item) => {
                const val = item[key] || 'Unknown';
                acc[val] = (acc[val] || 0) + 1;
                return acc;
            }, {});

            // Universal aggregates (all patterns)
            const aggregates = {
                count: nodes.length,
                avgProgress: Math.round(avg(nodes.map(n => n.pmProgress || 0))),
                statusCounts: countBy(nodes, 'pmStatus'),
                priorityCounts: countBy(nodes, 'pmPriority')
            };

            // Cost aggregates (CAPEX, Sales, Generic patterns)
            if (['capex', 'generic', 'sales'].includes(pattern)) {
                const costs = nodes.map(n => n.cost || n.dealValue || 0).filter(c => c > 0);
                if (costs.length > 0) {
                    aggregates.totalCost = sum(costs);
                    aggregates.avgCost = Math.round(avg(costs));
                    aggregates.maxCost = Math.max(...costs);
                    aggregates.minCost = Math.min(...costs);
                    aggregates.costNodeCount = costs.length;
                }
            }

            // Lead time aggregates (CAPEX pattern)
            if (pattern === 'capex') {
                const leadTimes = nodes.map(n => n.leadTime || 0).filter(lt => lt > 0);
                if (leadTimes.length > 0) {
                    aggregates.totalLeadTime = sum(leadTimes);
                    aggregates.maxLeadTime = Math.max(...leadTimes);
                    aggregates.avgLeadTime = Math.round(avg(leadTimes));
                }
            }

            // Sales-specific aggregates
            if (pattern === 'sales') {
                const probabilities = nodes.map(n => n.probability || 0).filter(p => p > 0);
                if (probabilities.length > 0) {
                    aggregates.avgProbability = Math.round(avg(probabilities));
                }
                aggregates.stageCounts = countBy(nodes, 'dealStage');
            }

            // Assignee aggregates (all patterns)
            const assignees = nodes.map(n => n.pmAssignee).filter(a => a && a.trim());
            if (assignees.length > 0) {
                aggregates.assigneeCounts = countBy(nodes, 'pmAssignee');
                aggregates.assigneeCount = Object.keys(aggregates.assigneeCounts).length;
            }

            // Due date aggregates
            const dueDates = nodes.map(n => n.dueDate).filter(d => d);
            if (dueDates.length > 0) {
                const sorted = dueDates.sort();
                aggregates.nextDue = sorted[0];
                aggregates.lastDue = sorted[sorted.length - 1];
                // Check for overdue
                const today = new Date().toISOString().split('T')[0];
                aggregates.overdueCount = dueDates.filter(d => d < today).length;
            }

            return aggregates;
        }

        /**
         * BUILD 361: Format aggregates for display
         * Returns a compact string like "$2.3M â€¢ 67% â€¢ 4 nodes"
         */
        function formatHyperedgeAggregates(aggregates, compact = true) {
            const parts = [];
            const pattern = capexTree.pattern?.key || 'generic';

            // Cost (primary for CAPEX/Sales)
            if (aggregates.totalCost) {
                const cost = aggregates.totalCost;
                if (cost >= 1000000) {
                    parts.push(`$${(cost / 1000000).toFixed(1)}M`);
                } else if (cost >= 1000) {
                    parts.push(`$${(cost / 1000).toFixed(0)}K`);
                } else {
                    parts.push(`$${cost}`);
                }
            }

            // Progress (universal)
            if (aggregates.avgProgress > 0) {
                parts.push(`${aggregates.avgProgress}%`);
            }

            // Lead time (CAPEX)
            if (aggregates.maxLeadTime && pattern === 'capex') {
                parts.push(`${aggregates.maxLeadTime}mo`);
            }

            // Probability (Sales)
            if (aggregates.avgProbability && pattern === 'sales') {
                parts.push(`${aggregates.avgProbability}% prob`);
            }

            // Overdue warning
            if (aggregates.overdueCount > 0) {
                parts.push(`âš ï¸${aggregates.overdueCount} overdue`);
            }

            if (compact && parts.length > 3) {
                return parts.slice(0, 3).join(' â€¢ ');
            }

            return parts.join(' â€¢ ');
        }

        // BUILD 361: Suggested hyperedges (in-memory, opt-in)
        let suggestedHyperedges = [];
        const DISMISSED_SUGGESTIONS_KEY = 'treelisty-dismissed-suggestions';

        /**
         * BUILD 361: Get dismissed suggestion IDs from localStorage
         */
        function getDismissedSuggestions() {
            try {
                return JSON.parse(localStorage.getItem(DISMISSED_SUGGESTIONS_KEY) || '[]');
            } catch (e) {
                return [];
            }
        }

        /**
         * BUILD 361: Dismiss a suggestion (won't appear again)
         */
        function dismissSuggestion(suggestionId) {
            const dismissed = getDismissedSuggestions();
            if (!dismissed.includes(suggestionId)) {
                dismissed.push(suggestionId);
                localStorage.setItem(DISMISSED_SUGGESTIONS_KEY, JSON.stringify(dismissed));
            }
            suggestedHyperedges = suggestedHyperedges.filter(s => s.id !== suggestionId);
        }

        /**
         * BUILD 361: Accept a suggestion - create permanent hyperedge
         */
        function acceptSuggestion(suggestionId) {
            const suggestion = suggestedHyperedges.find(s => s.id === suggestionId);
            if (!suggestion) return;

            // Create real hyperedge
            saveState('Create Hyperedge from Suggestion');
            const hyperedge = addHyperedge(
                suggestion.type || 'suggested',
                suggestion.label,
                suggestion.nodeIds,
                {
                    color: suggestion.color,
                    description: suggestion.description,
                    source: 'auto-detected'
                }
            );

            // Set custom color if provided
            if (hyperedge && suggestion.color) {
                hyperedge.color = suggestion.color;
            }

            // Remove from suggestions
            suggestedHyperedges = suggestedHyperedges.filter(s => s.id !== suggestionId);

            // Re-render
            renderCanvas();
            showToast(`Created hyperedge: ${suggestion.label}`, 'success');
        }

        /**
         * BUILD 361: Detect suggested hyperedges based on tree data
         * Runs on tree load and after significant edits
         */
        function detectSuggestedHyperedges() {
            const dismissed = getDismissedSuggestions();
            const existingEdgeNodeSets = (capexTree.hyperedges || []).map(h =>
                new Set(h.nodeIds || [])
            );
            const suggestions = [];
            const pattern = capexTree.pattern?.key || 'generic';

            // Collect all items from tree
            const allItems = [];
            function collectItems(node) {
                if (node.type === 'item' || node.type === 'subtask') {
                    allItems.push(node);
                }
                (node.items || []).forEach(collectItems);
                (node.children || []).forEach(child => {
                    collectItems(child);
                    (child.items || []).forEach(collectItems);
                });
            }
            collectItems(capexTree);

            if (allItems.length < 2) return [];

            // Helper: Check if suggestion already exists as real hyperedge
            const alreadyExists = (nodeIds) => {
                const newSet = new Set(nodeIds);
                return existingEdgeNodeSets.some(existingSet => {
                    if (existingSet.size !== newSet.size) return false;
                    for (const id of newSet) {
                        if (!existingSet.has(id)) return false;
                    }
                    return true;
                });
            };

            // Helper: Create suggestion if valid
            const addSuggestion = (id, label, nodeIds, color, description, type = 'auto') => {
                if (nodeIds.length < 2) return;
                if (dismissed.includes(id)) return;
                if (alreadyExists(nodeIds)) return;
                suggestions.push({ id, label, nodeIds, color, description, type });
            };

            // ===========================================
            // UNIVERSAL RULES (All Patterns)
            // ===========================================

            // Rule 1: Status clusters (3+ items with same status)
            const statusGroups = {};
            allItems.forEach(item => {
                const status = item.pmStatus || 'Unknown';
                if (!statusGroups[status]) statusGroups[status] = [];
                statusGroups[status].push(item.id);
            });
            Object.entries(statusGroups).forEach(([status, ids]) => {
                if (ids.length >= 3 && status !== 'Unknown') {
                    const colors = {
                        'Done': '#22c55e',
                        'Completed': '#22c55e',
                        'In Progress': '#f59e0b',
                        'To Do': '#6366f1',
                        'Blocked': '#ef4444',
                        'Not Started': '#94a3b8'
                    };
                    addSuggestion(
                        `suggest-status-${status.toLowerCase().replace(/\s+/g, '-')}`,
                        `${status} Items`,
                        ids,
                        colors[status] || '#8b5cf6',
                        `${ids.length} items with status "${status}"`,
                        'status-cluster'
                    );
                }
            });

            // Rule 2: Assignee clusters (2+ items with same assignee)
            const assigneeGroups = {};
            allItems.forEach(item => {
                const assignee = item.pmAssignee?.trim();
                if (assignee) {
                    if (!assigneeGroups[assignee]) assigneeGroups[assignee] = [];
                    assigneeGroups[assignee].push(item.id);
                }
            });
            Object.entries(assigneeGroups).forEach(([assignee, ids]) => {
                if (ids.length >= 2) {
                    addSuggestion(
                        `suggest-assignee-${assignee.toLowerCase().replace(/\s+/g, '-')}`,
                        `${assignee}'s Items`,
                        ids,
                        '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'),
                        `${ids.length} items assigned to ${assignee}`,
                        'assignee-cluster'
                    );
                }
            });

            // Rule 3: Priority clusters (3+ items with same priority)
            const priorityGroups = {};
            allItems.forEach(item => {
                const priority = item.pmPriority;
                if (priority) {
                    if (!priorityGroups[priority]) priorityGroups[priority] = [];
                    priorityGroups[priority].push(item.id);
                }
            });
            Object.entries(priorityGroups).forEach(([priority, ids]) => {
                if (ids.length >= 3) {
                    const colors = {
                        'Critical': '#ef4444',
                        'High': '#f97316',
                        'Medium': '#eab308',
                        'Low': '#22c55e'
                    };
                    addSuggestion(
                        `suggest-priority-${priority.toLowerCase()}`,
                        `${priority} Priority`,
                        ids,
                        colors[priority] || '#8b5cf6',
                        `${ids.length} items with ${priority} priority`,
                        'priority-cluster'
                    );
                }
            });

            // Rule 4: Blocked items (items with incomplete dependencies)
            const blockedIds = allItems
                .filter(item => {
                    const deps = item.dependencies || [];
                    return deps.some(depId => {
                        const depNode = getNodeById(depId);
                        return depNode && depNode.pmStatus !== 'Done' && depNode.pmStatus !== 'Completed';
                    });
                })
                .map(item => item.id);
            if (blockedIds.length >= 2) {
                addSuggestion(
                    'suggest-blocked-items',
                    'Blocked Items',
                    blockedIds,
                    '#ef4444',
                    `${blockedIds.length} items waiting on incomplete dependencies`,
                    'blocked'
                );
            }

            // ===========================================
            // PATTERN-SPECIFIC RULES
            // ===========================================

            // CAPEX: High cost items (top 25% by cost)
            if (['capex', 'generic', 'sales'].includes(pattern)) {
                const itemsWithCost = allItems.filter(i => (i.cost || 0) > 0);
                if (itemsWithCost.length >= 4) {
                    const costs = itemsWithCost.map(i => i.cost).sort((a, b) => b - a);
                    const threshold = costs[Math.floor(costs.length * 0.25)] || costs[0];
                    const highCostIds = itemsWithCost
                        .filter(i => i.cost >= threshold)
                        .map(i => i.id);
                    if (highCostIds.length >= 2) {
                        const total = highCostIds.reduce((sum, id) => {
                            const node = getNodeById(id);
                            return sum + (node?.cost || 0);
                        }, 0);
                        const formatted = total >= 1000000
                            ? `$${(total/1000000).toFixed(1)}M`
                            : `$${(total/1000).toFixed(0)}K`;
                        addSuggestion(
                            'suggest-high-cost',
                            `High Cost Items`,
                            highCostIds,
                            '#dc2626',
                            `${highCostIds.length} items totaling ${formatted}`,
                            'cost-cluster'
                        );
                    }
                }
            }

            // CAPEX: Long lead time items
            if (pattern === 'capex') {
                const longLeadItems = allItems.filter(i => (i.leadTime || 0) >= 6);
                if (longLeadItems.length >= 2) {
                    addSuggestion(
                        'suggest-long-lead',
                        'Long Lead Items',
                        longLeadItems.map(i => i.id),
                        '#7c3aed',
                        `${longLeadItems.length} items with 6+ month lead time`,
                        'lead-time-cluster'
                    );
                }
            }

            // Philosophy: Extract philosopher names from descriptions
            if (pattern === 'philosophy') {
                const philosophers = ['Plato', 'Aristotle', 'Kant', 'Hegel', 'Nietzsche', 'Descartes',
                    'Hume', 'Locke', 'Spinoza', 'Leibniz', 'Socrates', 'Marx', 'Kierkegaard',
                    'Heidegger', 'Wittgenstein', 'Sartre', 'Husserl', 'Schopenhauer'];

                philosophers.forEach(philosopher => {
                    const regex = new RegExp(philosopher, 'i');
                    const matches = allItems.filter(i =>
                        regex.test(i.name || '') || regex.test(i.description || '')
                    );
                    if (matches.length >= 2) {
                        addSuggestion(
                            `suggest-philosopher-${philosopher.toLowerCase()}`,
                            `${philosopher}'s Ideas`,
                            matches.map(i => i.id),
                            '#8b5cf6',
                            `${matches.length} items referencing ${philosopher}`,
                            'philosopher-cluster'
                        );
                    }
                });
            }

            // Sales: Deal stage clusters
            if (pattern === 'sales') {
                const stageGroups = {};
                allItems.forEach(item => {
                    const stage = item.dealStage;
                    if (stage) {
                        if (!stageGroups[stage]) stageGroups[stage] = [];
                        stageGroups[stage].push(item.id);
                    }
                });
                Object.entries(stageGroups).forEach(([stage, ids]) => {
                    if (ids.length >= 2) {
                        addSuggestion(
                            `suggest-stage-${stage.toLowerCase().replace(/\s+/g, '-')}`,
                            `${stage} Deals`,
                            ids,
                            '#0ea5e9',
                            `${ids.length} deals in ${stage} stage`,
                            'stage-cluster'
                        );
                    }
                });
            }

            // Film: Character clusters (look for character names in descriptions)
            if (pattern === 'film') {
                // Look for quoted names or "Character:" patterns
                const characterMentions = {};
                allItems.forEach(item => {
                    const text = `${item.name || ''} ${item.description || ''}`;
                    // Match patterns like "John:", "MARY:", or names in quotes
                    const matches = text.match(/\b([A-Z][a-z]+):/g) || [];
                    matches.forEach(m => {
                        const name = m.replace(':', '');
                        if (!characterMentions[name]) characterMentions[name] = new Set();
                        characterMentions[name].add(item.id);
                    });
                });
                Object.entries(characterMentions).forEach(([character, idSet]) => {
                    const ids = Array.from(idSet);
                    if (ids.length >= 2) {
                        addSuggestion(
                            `suggest-character-${character.toLowerCase()}`,
                            `${character}'s Scenes`,
                            ids,
                            '#f472b6',
                            `${ids.length} items featuring ${character}`,
                            'character-cluster'
                        );
                    }
                });
            }

            suggestedHyperedges = suggestions;
            console.log(`ğŸ” Detected ${suggestions.length} suggested hyperedges`);
            return suggestions;
        }

        /**
         * BUILD 361: Query builder modal for creating hyperedges by filter
         */
        function showQueryBuilderModal() {
            // Close hyperedge panel if open
            const existingPanel = document.getElementById('hyperedge-visibility-panel');
            if (existingPanel) existingPanel.remove();

            const pattern = capexTree.pattern?.key || 'generic';

            // Define available fields based on pattern
            const fields = [
                { key: 'pmStatus', label: 'Status', type: 'select', options: ['To Do', 'In Progress', 'Done', 'Blocked', 'Not Started'] },
                { key: 'pmPriority', label: 'Priority', type: 'select', options: ['Critical', 'High', 'Medium', 'Low'] },
                { key: 'pmAssignee', label: 'Assignee', type: 'text' },
                { key: 'name', label: 'Name contains', type: 'text' },
                { key: 'description', label: 'Description contains', type: 'text' },
                { key: 'type', label: 'Node Type', type: 'select', options: ['item', 'subtask', 'phase'] }
            ];

            // Add pattern-specific fields
            if (['capex', 'generic', 'sales'].includes(pattern)) {
                fields.push({ key: 'cost', label: 'Cost ($)', type: 'number', operators: ['>', '<', '>=', '<=', '='] });
            }
            if (pattern === 'capex') {
                fields.push({ key: 'leadTime', label: 'Lead Time (months)', type: 'number', operators: ['>', '<', '>=', '<=', '='] });
            }
            if (pattern === 'sales') {
                fields.push({ key: 'probability', label: 'Probability (%)', type: 'number', operators: ['>', '<', '>=', '<=', '='] });
                fields.push({ key: 'dealStage', label: 'Deal Stage', type: 'text' });
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'ğŸ” Create Hyperedge by Query';

            const fieldOptions = fields.map(f => `<option value="${f.key}">${f.label}</option>`).join('');

            modalBody.innerHTML = `
                <div style="padding: 16px;">
                    <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 16px;">
                        Find nodes matching your criteria and group them into a hyperedge.
                    </p>

                    <div id="query-conditions" style="margin-bottom: 16px;">
                        <div class="query-condition" style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center;">
                            <select class="query-field" style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: #1e293b; color: #f8fafc; flex: 1;">
                                ${fieldOptions}
                            </select>
                            <select class="query-operator" style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: #1e293b; color: #f8fafc; width: 100px;">
                                <option value="equals">equals</option>
                                <option value="contains">contains</option>
                                <option value="not_equals">not equals</option>
                                <option value=">">></option>
                                <option value="<"><</option>
                            </select>
                            <input type="text" class="query-value" placeholder="Value..."
                                style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--surface); color: var(--text-primary); flex: 1;">
                        </div>
                    </div>

                    <button onclick="addQueryCondition()" style="
                        padding: 6px 12px;
                        background: rgba(99, 102, 241, 0.1);
                        border: 1px dashed rgba(99, 102, 241, 0.3);
                        border-radius: 6px;
                        color: #6366f1;
                        cursor: pointer;
                        font-size: 12px;
                        margin-bottom: 16px;
                    ">+ Add Condition (AND)</button>

                    <div style="padding: 12px; background: var(--surface); border-radius: 8px; margin-bottom: 16px;">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Preview:</div>
                        <div id="query-preview" style="font-size: 14px; color: var(--text-primary); font-weight: 500;">
                            Click "Preview" to see matching nodes
                        </div>
                    </div>

                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1;">
                            <label style="font-size: 12px; color: var(--text-secondary); display: block; margin-bottom: 4px;">Hyperedge Name</label>
                            <input type="text" id="query-hyperedge-name" placeholder="e.g., High Priority Items"
                                style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--surface); color: var(--text-primary);">
                        </div>
                        <div style="width: 100px;">
                            <label style="font-size: 12px; color: var(--text-secondary); display: block; margin-bottom: 4px;">Color</label>
                            <input type="color" id="query-hyperedge-color" value="#8b5cf6"
                                style="width: 100%; height: 34px; padding: 2px; border-radius: 6px; border: 1px solid var(--border); cursor: pointer;">
                        </div>
                    </div>

                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                        <input type="checkbox" id="query-dynamic" style="width: 16px; height: 16px;">
                        <label for="query-dynamic" style="font-size: 13px; color: var(--text-secondary);">
                            Update automatically when tree changes
                        </label>
                    </div>
                </div>
            `;

            // BUILD 603: Reset footer on Cancel to prevent Create Hyperedge button from persisting in other modals
            document.querySelector('#modal .modal-footer').innerHTML = `
                <button class="btn" onclick="document.querySelector('#modal .modal-footer').innerHTML=''; document.getElementById('modal').style.display='none'">Cancel</button>
                <button class="btn" onclick="previewQueryResults()" style="background: rgba(99, 102, 241, 0.2); color: #6366f1;">Preview</button>
                <button class="btn btn-primary" onclick="createHyperedgeFromQuery()">Create Hyperedge</button>
            `;

            modal.style.display = 'flex';
        }

        /**
         * BUILD 361: Add another condition to the query builder
         */
        function addQueryCondition() {
            const container = document.getElementById('query-conditions');
            const pattern = capexTree.pattern?.key || 'generic';

            const fields = [
                { key: 'pmStatus', label: 'Status' },
                { key: 'pmPriority', label: 'Priority' },
                { key: 'pmAssignee', label: 'Assignee' },
                { key: 'name', label: 'Name contains' },
                { key: 'description', label: 'Description contains' },
                { key: 'type', label: 'Node Type' }
            ];
            if (['capex', 'generic', 'sales'].includes(pattern)) {
                fields.push({ key: 'cost', label: 'Cost ($)' });
            }
            if (pattern === 'capex') {
                fields.push({ key: 'leadTime', label: 'Lead Time (months)' });
            }
            // BUILD 565: Add Gmail-specific fields
            if (pattern === 'gmail') {
                fields.push(
                    { key: 'emailBody', label: 'Email Body contains' },
                    { key: 'senderEmail', label: 'From (email)' },
                    { key: 'recipientEmail', label: 'To (email)' },
                    { key: 'labels', label: 'Labels contain' }
                );
            }

            const fieldOptions = fields.map(f => `<option value="${f.key}">${f.label}</option>`).join('');

            const condition = document.createElement('div');
            condition.className = 'query-condition';
            condition.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px; align-items: center;';
            condition.innerHTML = `
                <span style="color: var(--text-secondary); font-size: 12px;">AND</span>
                <select class="query-field" style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: #1e293b; color: #f8fafc; flex: 1;">
                    ${fieldOptions}
                </select>
                <select class="query-operator" style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: #1e293b; color: #f8fafc; width: 100px;">
                    <option value="equals">equals</option>
                    <option value="contains">contains</option>
                    <option value="not_equals">not equals</option>
                    <option value=">">></option>
                    <option value="<"><</option>
                </select>
                <input type="text" class="query-value" placeholder="Value..."
                    style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--surface); color: var(--text-primary); flex: 1;">
                <button onclick="this.parentElement.remove()" style="background: none; border: none; color: #ef4444; cursor: pointer; font-size: 16px;">âœ•</button>
            `;
            container.appendChild(condition);
        }

        /**
         * BUILD 361: Evaluate query conditions against tree nodes
         */
        function evaluateQueryConditions() {
            const conditions = [];
            document.querySelectorAll('.query-condition').forEach(row => {
                const field = row.querySelector('.query-field')?.value;
                const operator = row.querySelector('.query-operator')?.value;
                const value = row.querySelector('.query-value')?.value?.trim();
                if (field && value) {
                    conditions.push({ field, operator, value });
                }
            });

            if (conditions.length === 0) {
                return [];
            }

            // Collect all items from tree
            const allItems = [];
            function collectItems(node) {
                if (node.type === 'item' || node.type === 'subtask' || node.type === 'phase') {
                    allItems.push(node);
                }
                (node.items || []).forEach(collectItems);
                (node.children || []).forEach(child => {
                    collectItems(child);
                    (child.items || []).forEach(collectItems);
                });
            }
            collectItems(capexTree);

            // Filter items by ALL conditions (AND logic)
            return allItems.filter(item => {
                return conditions.every(cond => {
                    const itemValue = item[cond.field];
                    const condValue = cond.value;
                    const searchStr = condValue.toLowerCase();

                    switch (cond.operator) {
                        case 'equals':
                            return String(itemValue || '').toLowerCase() === searchStr;
                        case 'not_equals':
                            return String(itemValue || '').toLowerCase() !== searchStr;
                        case 'contains':
                            // BUILD 565: Enhanced contains search - include email body, description, and name
                            const fieldsToSearch = [
                                itemValue,
                                item.name,
                                item.description,
                                item.emailBody,      // Gmail email body
                                item.fullBody,       // Full email content
                                item.senderEmail,    // Sender address
                                item.recipientEmail  // Recipient address
                            ];
                            return fieldsToSearch.some(field =>
                                String(field || '').toLowerCase().includes(searchStr)
                            );
                        case '>':
                            return Number(itemValue || 0) > Number(condValue);
                        case '<':
                            return Number(itemValue || 0) < Number(condValue);
                        case '>=':
                            return Number(itemValue || 0) >= Number(condValue);
                        case '<=':
                            return Number(itemValue || 0) <= Number(condValue);
                        default:
                            return false;
                    }
                });
            });
        }

        /**
         * BUILD 361: Preview query results
         */
        function previewQueryResults() {
            const matches = evaluateQueryConditions();
            const preview = document.getElementById('query-preview');

            if (matches.length === 0) {
                preview.innerHTML = '<span style="color: var(--text-secondary);">No matching nodes found</span>';
            } else {
                const names = matches.slice(0, 5).map(m => m.name).join(', ');
                const more = matches.length > 5 ? ` +${matches.length - 5} more` : '';
                preview.innerHTML = `<span style="color: #22c55e;">${matches.length} nodes match:</span> ${names}${more}`;
            }

            // Auto-generate name if empty
            const nameInput = document.getElementById('query-hyperedge-name');
            if (!nameInput.value && matches.length > 0) {
                const firstCondition = document.querySelector('.query-condition');
                if (firstCondition) {
                    const field = firstCondition.querySelector('.query-field')?.value;
                    const value = firstCondition.querySelector('.query-value')?.value;
                    if (field && value) {
                        const fieldLabels = {
                            pmStatus: 'Status',
                            pmPriority: 'Priority',
                            pmAssignee: 'Assigned to',
                            cost: 'Cost',
                            leadTime: 'Lead Time'
                        };
                        nameInput.value = `${fieldLabels[field] || field}: ${value}`;
                    }
                }
            }
        }

        /**
         * BUILD 361: Create hyperedge from query results
         */
        function createHyperedgeFromQuery() {
            const matches = evaluateQueryConditions();

            if (matches.length < 2) {
                showToast('Need at least 2 matching nodes to create a hyperedge', 'error');
                return;
            }

            const name = document.getElementById('query-hyperedge-name').value || 'Query Result';
            const color = document.getElementById('query-hyperedge-color').value || '#8b5cf6';
            const isDynamic = document.getElementById('query-dynamic').checked;

            // Collect conditions for dynamic hyperedge
            const conditions = [];
            document.querySelectorAll('.query-condition').forEach(row => {
                const field = row.querySelector('.query-field')?.value;
                const operator = row.querySelector('.query-operator')?.value;
                const value = row.querySelector('.query-value')?.value?.trim();
                if (field && value) {
                    conditions.push({ field, operator, value });
                }
            });

            saveState('Create Hyperedge from Query');

            const hyperedge = addHyperedge(
                'query',
                name,
                matches.map(m => m.id),
                {
                    color: color,
                    description: `Query-generated: ${matches.length} matching nodes`,
                    query: isDynamic ? { conditions, logic: 'AND' } : null,
                    dynamic: isDynamic
                }
            );

            if (hyperedge) {
                hyperedge.color = color;
            }

            // BUILD 603: Reset footer before closing to prevent Create Hyperedge button from persisting
            document.querySelector('#modal .modal-footer').innerHTML = '';
            document.getElementById('modal').style.display = 'none';
            renderCanvas();
            showToast(`Created hyperedge "${name}" with ${matches.length} nodes`, 'success');
        }

        // SVG offset to match the large canvas-connections area (top: -5000px, left: -5000px)
        const SVG_OFFSET = 5000;

        // =====================================================================
        // BUILD 445: LINK TYPES - Configurable link styles for Canvas View
        // =====================================================================
        const LINK_TYPES = {
            parentChild: {
                style: 'orthogonal',        // Right-angle paths
                color: 'rgba(99, 102, 241, 0.4)',
                width: 1.5,
                opacity: 0.5,
                arrow: true,
                animated: false,
                dashPattern: null
            },
            dependency: {
                style: 'bezier',
                color: '#ff6b6b',            // Red (legacy/default)
                width: 2,
                opacity: 0.8,
                arrow: true,
                animated: true,              // Moving dashes
                dashPattern: [8, 4]
            },
            criticalPath: {
                style: 'bezier',
                color: '#ff0000',            // Bright red
                width: 3,
                opacity: 1.0,
                arrow: true,
                animated: true,
                dashPattern: null            // Solid line with glow
            },
            // BUILD 510: Color-coded dependency types
            dependencyFS: {
                style: 'bezier',
                color: '#3b82f6',            // Blue - Finish-to-Start
                width: 2,
                opacity: 0.85,
                arrow: true,
                animated: true,
                dashPattern: [8, 4]
            },
            dependencySS: {
                style: 'bezier',
                color: '#22c55e',            // Green - Start-to-Start
                width: 2,
                opacity: 0.85,
                arrow: true,
                animated: true,
                dashPattern: [6, 3]
            },
            dependencyFF: {
                style: 'bezier',
                color: '#f97316',            // Orange - Finish-to-Finish
                width: 2,
                opacity: 0.85,
                arrow: true,
                animated: true,
                dashPattern: [6, 3]
            },
            dependencySF: {
                style: 'bezier',
                color: '#a855f7',            // Purple - Start-to-Finish
                width: 2,
                opacity: 0.85,
                arrow: true,
                animated: true,
                dashPattern: [4, 4]
            }
        };

        // Animation state for flowing dashes
        let linkAnimationFrame = null;
        let linkAnimationOffset = 0;

        // =====================================================================
        // BUILD 446: TYPED DEPENDENCIES - FS/SS/FF/SF with lag support
        // =====================================================================
        const DEPENDENCY_TYPES = {
            FS: {
                code: 'FS',
                name: 'Finish-to-Start',
                description: 'Successor starts after predecessor finishes',
                icon: 'â†’',
                default: true
            },
            SS: {
                code: 'SS',
                name: 'Start-to-Start',
                description: 'Both tasks start together',
                icon: 'â‡‰'
            },
            FF: {
                code: 'FF',
                name: 'Finish-to-Finish',
                description: 'Both tasks finish together',
                icon: 'â‡¶'
            },
            SF: {
                code: 'SF',
                name: 'Start-to-Finish',
                description: 'Successor finishes when predecessor starts',
                icon: 'â†”'
            }
        };

        // Normalize dependency to extended format (backwards-compatible)
        function normalizeDependency(dep) {
            // If it's just a string ID (old format), convert to object
            if (typeof dep === 'string') {
                return { predecessorId: dep, type: 'FS', lag: 0 };
            }
            // Already object format - ensure defaults and handle legacy field names
            return {
                predecessorId: dep.predecessorId || dep.targetId || dep.id,
                type: dep.type || 'FS',
                lag: dep.lag || 0
            };
        }

        // Get all dependencies for a node (normalized to extended format)
        function getDependencies(node) {
            if (!node.dependencies || !Array.isArray(node.dependencies)) return [];
            return node.dependencies.map(normalizeDependency);
        }

        // Format dependency for display
        function formatDependency(dep) {
            const normalized = normalizeDependency(dep);
            const typeInfo = DEPENDENCY_TYPES[normalized.type] || DEPENDENCY_TYPES.FS;
            let label = typeInfo.icon;
            if (normalized.lag !== 0) {
                label += (normalized.lag > 0 ? '+' : '') + normalized.lag + 'd';
            }
            return label;
        }

        // Expose for external use
        window.DEPENDENCY_TYPES = DEPENDENCY_TYPES;
        window.normalizeDependency = normalizeDependency;
        window.getDependencies = getDependencies;
        window.formatDependency = formatDependency;

        // BUILD 449: Critical Path Engine
        // Forward/backward pass algorithm for critical path calculation

        // Helper: Traverse tree and apply callback to each node
        function traverseTreeForCriticalPath(node, callback) {
            if (!node) return;
            callback(node);
            if (node.children) {
                node.children.forEach(child => traverseTreeForCriticalPath(child, callback));
            }
            if (node.items) {
                node.items.forEach(item => traverseTreeForCriticalPath(item, callback));
            }
        }

        const dependencyEngine = {
            // Build adjacency lists from tree
            buildGraph(tree) {
                const nodes = [];
                const successors = new Map();  // nodeId â†’ [successorIds]
                const predecessors = new Map(); // nodeId â†’ [predecessorIds]

                traverseTreeForCriticalPath(tree, node => {
                    nodes.push(node);
                    successors.set(node.id, []);
                    predecessors.set(node.id, []);
                });

                nodes.forEach(node => {
                    getDependencies(node).forEach(dep => {
                        predecessors.get(node.id).push(dep.predecessorId);
                        const succList = successors.get(dep.predecessorId);
                        if (succList) succList.push(node.id);
                    });
                });

                return { nodes, successors, predecessors };
            },

            // Topological sort using Kahn's algorithm
            topologicalSort(graph) {
                const inDegree = new Map();
                graph.nodes.forEach(n => inDegree.set(n.id, graph.predecessors.get(n.id).length));

                const queue = graph.nodes.filter(n => inDegree.get(n.id) === 0);
                const sorted = [];

                while (queue.length > 0) {
                    const node = queue.shift();
                    sorted.push(node);

                    graph.successors.get(node.id).forEach(succId => {
                        inDegree.set(succId, inDegree.get(succId) - 1);
                        if (inDegree.get(succId) === 0) {
                            const succNode = graph.nodes.find(n => n.id === succId);
                            if (succNode) queue.push(succNode);
                        }
                    });
                }

                // Check for cycles
                if (sorted.length !== graph.nodes.length) {
                    console.warn('Dependency cycle detected - cannot calculate critical path');
                    return null;
                }

                return sorted;
            },

            // Get constraint date based on dependency type
            getConstraintDate(predecessor, successor, dep) {
                const lag = dep.lag || 0;
                const predDuration = predecessor.pmDuration || 1;
                const succDuration = successor.pmDuration || 1;

                switch (dep.type) {
                    case 'FS': return predecessor._earlyFinish + lag;
                    case 'SS': return predecessor._earlyStart + lag;
                    case 'FF': return predecessor._earlyFinish + lag - succDuration;
                    case 'SF': return predecessor._earlyStart + lag - succDuration;
                    default: return predecessor._earlyFinish + lag;
                }
            },

            // Reverse constraint for backward pass
            getReverseConstraintDate(predecessor, successor, dep) {
                const lag = dep.lag || 0;
                const predDuration = predecessor.pmDuration || 1;
                const succDuration = successor.pmDuration || 1;

                switch (dep.type) {
                    case 'FS': return successor._lateStart - lag;
                    case 'SS': return successor._lateStart - lag + predDuration;
                    case 'FF': return successor._lateFinish - lag;
                    case 'SF': return successor._lateFinish - lag + predDuration;
                    default: return successor._lateStart - lag;
                }
            },

            // Forward pass: calculate early start/finish
            forwardPass(tree) {
                const graph = this.buildGraph(tree);
                const sorted = this.topologicalSort(graph);
                if (!sorted) return false;

                sorted.forEach(node => {
                    const preds = graph.predecessors.get(node.id);
                    const duration = node.pmDuration || 1;

                    if (preds.length === 0) {
                        // No predecessors: start at day 0 or node's start date
                        node._earlyStart = this.dateToDay(node.pmStartDate) || 0;
                    } else {
                        // Earliest start = max of all predecessor constraints
                        node._earlyStart = Math.max(...preds.map(predId => {
                            const pred = getNodeById(predId);
                            if (!pred) return 0;
                            const dep = getDependencies(node).find(d => d.predecessorId === predId);
                            return this.getConstraintDate(pred, node, dep || { type: 'FS', lag: 0 });
                        }));
                    }

                    node._earlyFinish = node._earlyStart + duration;
                });

                return true;
            },

            // Backward pass: calculate late start/finish
            backwardPass(tree) {
                const graph = this.buildGraph(tree);
                const sorted = this.topologicalSort(graph);
                if (!sorted) return false;

                // Find project end date
                const projectEnd = Math.max(...sorted.map(n => n._earlyFinish || 0));

                // Process in reverse order
                sorted.reverse().forEach(node => {
                    const succs = graph.successors.get(node.id);
                    const duration = node.pmDuration || 1;

                    if (succs.length === 0) {
                        // No successors: can finish at project end
                        node._lateFinish = projectEnd;
                    } else {
                        // Latest finish = min of all successor constraints
                        node._lateFinish = Math.min(...succs.map(succId => {
                            const succ = getNodeById(succId);
                            if (!succ) return projectEnd;
                            const dep = getDependencies(succ).find(d => d.predecessorId === node.id);
                            return this.getReverseConstraintDate(node, succ, dep || { type: 'FS', lag: 0 });
                        }));
                    }

                    node._lateStart = node._lateFinish - duration;
                    node._slack = node._lateStart - node._earlyStart;
                    node._isCritical = Math.abs(node._slack) < 0.001; // Float tolerance
                });

                return true;
            },

            // Calculate critical path
            calculateCriticalPath(tree) {
                console.time('calculateCriticalPath');

                // Clear previous critical path data
                traverseTreeForCriticalPath(tree, node => {
                    node._earlyStart = undefined;
                    node._earlyFinish = undefined;
                    node._lateStart = undefined;
                    node._lateFinish = undefined;
                    node._slack = undefined;
                    node._isCritical = false;
                });

                if (!this.forwardPass(tree)) {
                    console.timeEnd('calculateCriticalPath');
                    return [];
                }
                if (!this.backwardPass(tree)) {
                    console.timeEnd('calculateCriticalPath');
                    return [];
                }

                const criticalNodes = [];
                traverseTreeForCriticalPath(tree, node => {
                    if (node._isCritical) criticalNodes.push(node);
                });

                console.timeEnd('calculateCriticalPath');
                return criticalNodes;
            },

            // Clear critical path data
            clearCriticalPath(tree) {
                traverseTreeForCriticalPath(tree, node => {
                    node._earlyStart = undefined;
                    node._earlyFinish = undefined;
                    node._lateStart = undefined;
                    node._lateFinish = undefined;
                    node._slack = undefined;
                    node._isCritical = false;
                });
            },

            // Helper: convert date string to day number
            dateToDay(dateStr) {
                if (!dateStr) return null;
                const date = new Date(dateStr);
                const projectStart = new Date(capexTree?.pmStartDate || Date.now());
                return Math.floor((date - projectStart) / (1000 * 60 * 60 * 24));
            }
        };

        // State for critical path display
        let showCriticalPath = false;

        // BUILD 510: Dependency display controls
        let showDependencies = true;           // Toggle all dependency lines
        let showDepsForSelectedOnly = true;    // Only show deps for selected/hovered node
        let selectedCanvasNodeId = null;       // Track selected node for filtering

        // BUILD 449: Toggle critical path visualization
        function toggleCriticalPath() {
            showCriticalPath = !showCriticalPath;

            const btn = document.getElementById('critical-path-toggle');
            if (showCriticalPath) {
                // Calculate critical path when enabled
                const criticalNodes = dependencyEngine.calculateCriticalPath(capexTree);
                if (criticalNodes.length === 0) {
                    showToast('No critical path found (needs dependencies with durations)', 'info');
                }
                btn.style.background = 'rgba(255, 0, 0, 0.3)';
                btn.style.borderColor = '#ff0000';
                btn.style.color = '#ff6b6b';
                showToast(`Critical path: ${criticalNodes.length} nodes highlighted`, 'success');
            } else {
                // Clear critical path data when disabled
                dependencyEngine.clearCriticalPath(capexTree);
                btn.style.background = 'rgba(255, 0, 0, 0.1)';
                btn.style.borderColor = 'rgba(255, 0, 0, 0.3)';
                btn.style.color = 'var(--text-primary)';
            }

            renderCanvas();
        }

        // BUILD 510: Toggle dependency visibility
        function toggleDependencyDisplay() {
            showDependencies = !showDependencies;
            const btn = document.getElementById('deps-toggle');
            if (btn) {
                if (showDependencies) {
                    btn.style.background = 'rgba(255, 107, 107, 0.3)';
                    btn.style.borderColor = '#ff6b6b';
                    btn.style.color = '#ff6b6b';
                    btn.textContent = 'ğŸ”— Deps: On';
                } else {
                    btn.style.background = 'rgba(99, 102, 241, 0.1)';
                    btn.style.borderColor = 'rgba(99, 102, 241, 0.3)';
                    btn.style.color = 'var(--text-secondary)';
                    btn.textContent = 'ğŸ”— Deps: Off';
                }
            }
            renderCanvas();
        }

        // BUILD 510: Toggle selected-only mode
        function toggleDepsSelectedOnly() {
            showDepsForSelectedOnly = !showDepsForSelectedOnly;
            const btn = document.getElementById('deps-filter-toggle');
            if (btn) {
                if (showDepsForSelectedOnly) {
                    btn.style.background = 'rgba(34, 197, 94, 0.2)';
                    btn.style.borderColor = 'rgba(34, 197, 94, 0.5)';
                    btn.textContent = 'ğŸ‘ Selected';
                } else {
                    btn.style.background = 'rgba(99, 102, 241, 0.1)';
                    btn.style.borderColor = 'rgba(99, 102, 241, 0.3)';
                    btn.textContent = 'ğŸ‘ All';
                }
            }
            renderCanvas();
        }

        // Expose for external use
        window.dependencyEngine = dependencyEngine;
        window.toggleCriticalPath = toggleCriticalPath;
        window.toggleDependencyDisplay = toggleDependencyDisplay;
        window.toggleDepsSelectedOnly = toggleDepsSelectedOnly;

        // BUILD 456: Check if tree has any dependencies
        function treeHasDependencies(node = capexTree) {
            if (!node) return false;
            // Check this node
            if (node.dependencies && node.dependencies.length > 0) return true;
            // Check children
            if (node.children) {
                for (const child of node.children) {
                    if (treeHasDependencies(child)) return true;
                }
            }
            // Check items
            if (node.items) {
                for (const item of node.items) {
                    if (treeHasDependencies(item)) return true;
                }
            }
            // Check subItems
            if (node.subItems) {
                for (const sub of node.subItems) {
                    if (treeHasDependencies(sub)) return true;
                }
            }
            return false;
        }

        // BUILD 456: Update Critical Path button visibility
        function updateCriticalPathVisibility() {
            const btn = document.getElementById('critical-path-toggle');
            if (btn) {
                btn.style.display = treeHasDependencies() ? '' : 'none';
            }
        }

        /**
         * Draw all hyperedges as convex hull blobs
         * Performance optimized: Uses O(1) Map lookup instead of O(N) recursive getNodeById
         * Enhanced: Groups each hyperedge for hover/focus interactions
         */
        function drawHyperedges() {
            const svg = document.getElementById('canvas-connections');
            const allHyperedges = getAllHyperedges();

            // Filter out hidden hyperedges
            const hyperedges = (allHyperedges || []).filter(he => !hiddenHyperedges.has(he.id));

            console.log('ğŸ”— drawHyperedges called, found', allHyperedges?.length || 0, 'hyperedges,', hyperedges.length, 'visible');
            console.log('ğŸ”— canvasNodes array has', canvasNodes.length, 'entries');

            if (!hyperedges || hyperedges.length === 0) {
                console.log('ğŸ”— No visible hyperedges to draw');
                return;
            }

            // Track all hyperedge groups for hover interactions
            const hyperedgeGroups = [];

            // Build O(1) lookup map from canvasNodes to avoid O(N) getNodeById calls per node
            // This reduces complexity from O(H * N * TreeDepth) to O(H * N) where H = hyperedges, N = nodes per edge
            const nodeLookup = new Map();
            canvasNodes.forEach(n => {
                if (n.data && n.data.id) {
                    nodeLookup.set(n.data.id, n.data);
                }
            });
            console.log('ğŸ”— nodeLookup built with', nodeLookup.size, 'nodes. Keys:', Array.from(nodeLookup.keys()).slice(0, 15));

            // Color palette for hyperedge types
            const typeColors = {
                'montage': 'rgba(251, 146, 60, 0.15)',       // Orange
                'argument': 'rgba(59, 130, 246, 0.15)',      // Blue
                'theme': 'rgba(168, 85, 247, 0.15)',         // Purple
                'dependency-cluster': 'rgba(34, 197, 94, 0.15)', // Green
                'analysis': 'rgba(139, 92, 246, 0.25)',      // Violet/Purple for Deep Dive (slightly more opaque)
                'default': 'rgba(156, 163, 175, 0.15)'       // Gray
            };

            hyperedges.forEach((hyperedge, idx) => {
                // Guard against malformed hyperedges
                if (!hyperedge || !hyperedge.nodeIds || !Array.isArray(hyperedge.nodeIds)) {
                    console.warn(`âš ï¸ Skipping malformed hyperedge[${idx}]:`, hyperedge);
                    return;
                }

                console.log(`ğŸ”— Processing hyperedge[${idx}]: "${hyperedge.label || hyperedge.name}" with nodeIds:`, hyperedge.nodeIds);

                // Get all nodes in this hyperedge using O(1) lookup
                const nodes = hyperedge.nodeIds.map(id => {
                    const found = nodeLookup.get(id);
                    if (!found) {
                        console.warn(`  âŒ Node ID "${id}" NOT found in canvasNodes`);
                    } else {
                        console.log(`  âœ… Node ID "${id}" found at (${found.canvasX}, ${found.canvasY})`);
                    }
                    return found;
                }).filter(n => n);

                console.log(`ğŸ”— Hyperedge "${hyperedge.label}": ${hyperedge.nodeIds.length} nodeIds â†’ ${nodes.length} found in canvasNodes`);

                if (nodes.length < 2) {
                    console.warn(`âŒ Hyperedge ${hyperedge.id} has < 2 valid nodes, skipping. NodeIds:`, hyperedge.nodeIds);
                    return;
                }

                // Create SVG group for this hyperedge (enables hover/focus interactions)
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'hyperedge-group');
                group.setAttribute('data-hyperedge-id', hyperedge.id);
                group.style.transition = 'opacity 0.3s ease';
                hyperedgeGroups.push({ group, hyperedge });

                // Get node positions (center of each node card) + SVG offset
                const points = nodes.map(node => ({
                    x: (node.canvasX || 0) + 160 + SVG_OFFSET,  // Center X (320px width / 2) + offset
                    y: (node.canvasY || 0) + 60 + SVG_OFFSET   // Center Y (120px height / 2) + offset
                }));
                console.log('ğŸ”— Raw points (with SVG_OFFSET):', points);

                // =====================================================================
                // SPECIAL CASE: 2-node hyperedges use capsule/pill shape
                // Convex hull fails for 2 points (collinear), so we draw a capsule
                // =====================================================================
                if (nodes.length === 2) {
                    const p1 = points[0];
                    const p2 = points[1];
                    const capsuleRadius = 80;  // Generous radius for visibility

                    const colorObj = getHyperedgeColor(hyperedge);
                    const capsulePath = createCapsulePath(p1, p2, capsuleRadius);

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('class', 'hyperedge-capsule');
                    path.setAttribute('d', capsulePath);
                    path.setAttribute('fill', colorObj.fill);
                    path.setAttribute('stroke', colorObj.border);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('stroke-dasharray', '8,4');
                    path.style.cursor = 'pointer';
                    path.style.transition = 'opacity 0.2s';
                    path.addEventListener('mouseenter', () => path.style.opacity = '0.8');
                    path.addEventListener('mouseleave', () => path.style.opacity = '1');
                    path.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });

                    group.appendChild(path);
                    console.log('ğŸ”— Capsule path created for 2-node hyperedge');

                    // Add label at midpoint
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;

                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', midX);
                    label.setAttribute('y', midY - 35);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', colorObj.solid || colorObj.border);
                    label.setAttribute('font-size', '14');
                    label.setAttribute('font-weight', 'bold');
                    label.style.cursor = 'pointer';
                    label.style.textShadow = '0 0 6px rgba(0,0,0,0.8)';
                    label.textContent = getHyperedgeDisplayLabel(hyperedge);
                    label.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });
                    group.appendChild(label);

                    const hint = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    hint.setAttribute('x', midX);
                    hint.setAttribute('y', midY - 18);
                    hint.setAttribute('text-anchor', 'middle');
                    hint.setAttribute('fill', 'rgba(255,255,255,0.6)');
                    hint.setAttribute('font-size', '11');
                    hint.style.cursor = 'pointer';
                    hint.style.textShadow = '0 0 4px rgba(0,0,0,0.8)';
                    hint.textContent = 'â–¶ click to explore relationship';
                    hint.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });
                    group.appendChild(hint);

                    // Append group to SVG and return (skip hull processing)
                    svg.appendChild(group);
                    return;
                }

                // Add padding around the hull with SAFE division (avoid NaN from div-by-zero)
                const padding = 60;  // Increased for better visibility
                const centroid = {
                    x: points.reduce((sum, p) => sum + p.x, 0) / points.length,
                    y: points.reduce((sum, p) => sum + p.y, 0) / points.length
                };
                console.log('ğŸ”— Centroid:', centroid);

                // Safe padding: avoid division by zero when point equals centroid
                const paddedPoints = points.map(p => {
                    const dx = p.x - centroid.x;
                    const dy = p.y - centroid.y;
                    const dist = Math.hypot(dx, dy);

                    // If point is at centroid (dist=0), expand outward in a default direction
                    if (dist < 1) {
                        // Use point index to spread overlapping points
                        const angle = (points.indexOf(p) / points.length) * 2 * Math.PI;
                        return {
                            x: centroid.x + Math.cos(angle) * padding,
                            y: centroid.y + Math.sin(angle) * padding
                        };
                    }

                    return {
                        x: p.x + dx * (padding / dist),
                        y: p.y + dy * (padding / dist)
                    };
                });
                console.log('ğŸ”— Padded points:', paddedPoints);

                // Check for NaN values
                const hasNaN = paddedPoints.some(p => isNaN(p.x) || isNaN(p.y));
                if (hasNaN) {
                    console.error('âŒ NaN detected in padded points! Skipping hyperedge.');
                    return;
                }

                // Compute convex hull
                const hull = computeConvexHull(paddedPoints);
                console.log('ğŸ”— Convex hull computed with', hull.length, 'points');

                if (hull.length < 3) {
                    // Fallback: if hull fails (collinear points), create a simple rounded rect around the centroid
                    console.warn(`âš ï¸ Hyperedge ${hyperedge.id} hull has < 3 points, using fallback rectangle`);

                    // Calculate bounding box
                    const minX = Math.min(...paddedPoints.map(p => p.x)) - 20;
                    const maxX = Math.max(...paddedPoints.map(p => p.x)) + 20;
                    const minY = Math.min(...paddedPoints.map(p => p.y)) - 20;
                    const maxY = Math.max(...paddedPoints.map(p => p.y)) + 20;

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', minX);
                    rect.setAttribute('y', minY);
                    rect.setAttribute('width', maxX - minX);
                    rect.setAttribute('height', maxY - minY);
                    rect.setAttribute('rx', '20');
                    rect.setAttribute('ry', '20');

                    // Get color object (custom from metadata, or type-based fallback)
                    const colorObj = getHyperedgeColor(hyperedge);
                    rect.setAttribute('fill', colorObj.fill);
                    rect.setAttribute('stroke', colorObj.border);
                    rect.setAttribute('stroke-width', '2');
                    rect.setAttribute('stroke-dasharray', '8,4');
                    rect.style.cursor = 'pointer';
                    rect.style.transition = 'opacity 0.2s';
                    rect.addEventListener('mouseenter', () => rect.style.opacity = '0.8');
                    rect.addEventListener('mouseleave', () => rect.style.opacity = '1');
                    rect.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });

                    group.appendChild(rect);
                    console.log('ğŸ”— Fallback rect created');
                } else {
                    // Create SVG polygon for the hull
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const pointsStr = hull.map(p => `${p.x},${p.y}`).join(' ');
                    polygon.setAttribute('points', pointsStr);

                    // Get color object (custom from metadata, or type-based fallback)
                    const colorObj = getHyperedgeColor(hyperedge);
                    polygon.setAttribute('fill', colorObj.fill);
                    polygon.setAttribute('stroke', colorObj.border);
                    polygon.setAttribute('stroke-width', '2');
                    polygon.setAttribute('stroke-dasharray', '8,4');
                    polygon.style.cursor = 'pointer';
                    polygon.style.transition = 'opacity 0.2s';
                    polygon.addEventListener('mouseenter', () => polygon.style.opacity = '0.8');
                    polygon.addEventListener('mouseleave', () => polygon.style.opacity = '1');
                    polygon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });

                    group.appendChild(polygon);
                    console.log('ğŸ”— Polygon appended to group');
                }

                // Add label at centroid (also clickable)
                const labelColorObj = getHyperedgeColor(hyperedge);

                // Main label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', centroid.x);
                label.setAttribute('y', centroid.y - 35);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', labelColorObj.solid || labelColorObj.border);
                label.setAttribute('font-size', '14');
                label.setAttribute('font-weight', 'bold');
                label.style.cursor = 'pointer';
                label.style.textShadow = '0 0 6px rgba(0,0,0,0.8)';
                label.textContent = getHyperedgeDisplayLabel(hyperedge);
                label.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showHyperedgeInfo(hyperedge);
                });
                group.appendChild(label);

                // Subtitle hint "click to explore"
                const hint = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                hint.setAttribute('x', centroid.x);
                hint.setAttribute('y', centroid.y - 18);
                hint.setAttribute('text-anchor', 'middle');
                hint.setAttribute('fill', 'rgba(255,255,255,0.6)');
                hint.setAttribute('font-size', '11');
                hint.style.cursor = 'pointer';
                hint.style.textShadow = '0 0 4px rgba(0,0,0,0.8)';
                hint.textContent = 'â–¶ click to explore relationship';
                hint.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showHyperedgeInfo(hyperedge);
                });
                group.appendChild(hint);

                // Append group to SVG
                svg.appendChild(group);
                console.log('ğŸ”— Group added to SVG');
            });

            // =========================================================================
            // HOVER INTERACTIONS: Dim other hyperedges AND unrelated nodes when hovering one
            // =========================================================================
            hyperedgeGroups.forEach(({ group, hyperedge }) => {
                group.addEventListener('mouseenter', () => {
                    // Dim all other hyperedge groups
                    hyperedgeGroups.forEach(({ group: otherGroup, hyperedge: otherHyperedge }) => {
                        if (otherHyperedge.id !== hyperedge.id) {
                            otherGroup.style.opacity = '0.2';
                        }
                    });

                    // Dim all canvas nodes NOT in this hyperedge
                    const memberNodeIds = new Set(hyperedge.nodeIds || []);
                    document.querySelectorAll('.canvas-node').forEach(nodeEl => {
                        const nodeId = nodeEl.dataset.itemId;  // Canvas nodes use data-item-id
                        if (!memberNodeIds.has(nodeId)) {
                            nodeEl.style.opacity = '0.25';
                            nodeEl.style.transition = 'opacity 0.3s ease';
                        } else {
                            // Highlight member nodes
                            nodeEl.style.opacity = '1';
                            nodeEl.style.boxShadow = '0 0 20px rgba(139, 92, 246, 0.6)';
                            nodeEl.style.transition = 'opacity 0.3s ease, box-shadow 0.3s ease';
                        }
                    });
                });

                group.addEventListener('mouseleave', () => {
                    // Restore all hyperedge groups
                    hyperedgeGroups.forEach(({ group: otherGroup }) => {
                        otherGroup.style.opacity = '1';
                    });

                    // Restore all canvas nodes
                    document.querySelectorAll('.canvas-node').forEach(nodeEl => {
                        nodeEl.style.opacity = '1';
                        nodeEl.style.boxShadow = '';
                    });
                });
            });

            console.log('ğŸ”— drawHyperedges complete with', hyperedgeGroups.length, 'groups');
        }

        /**
         * Show hyperedge info panel with philosophy relationship fields
         */
        function showHyperedgeInfo(hyperedge) {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'ğŸ”— Hyperedge Details';

            const meta = hyperedge.metadata || {};
            const philo = meta.philosophyFields || {};
            const isPhilosophy = currentPattern === 'philosophy';
            const pattern = capexTree.pattern?.key || 'generic';

            // Calculate live aggregates
            const aggregates = calculateHyperedgeAggregates(hyperedge);
            const nodeCount = hyperedge.nodeIds?.length || 0;

            // Get member nodes for display
            const memberNodes = [];
            function findMemberNodes(node) {
                if (hyperedge.nodeIds?.includes(node.id)) {
                    memberNodes.push(node);
                }
                if (node.subItems) node.subItems.forEach(findMemberNodes);
                if (node.children) node.children.forEach(findMemberNodes);
            }
            capexTree.children?.forEach(phase => {
                (phase.items || phase.children || phase.subItems || []).forEach(findMemberNodes);
            });

            // Build aggregates display
            let aggregatesHTML = '';
            if (aggregates.count > 0) {
                const parts = [];
                if (aggregates.totalCost) parts.push(`<span style="color: #22c55e;">ğŸ’° ${formatCost(aggregates.totalCost)}</span>`);
                if (aggregates.avgProgress > 0) parts.push(`<span style="color: #6366f1;">ğŸ“Š ${Math.round(aggregates.avgProgress)}% avg</span>`);

                // Status breakdown
                const statusColors = { 'Done': '#22c55e', 'In Progress': '#f59e0b', 'To Do': '#94a3b8', 'Blocked': '#ef4444' };
                const statusParts = Object.entries(aggregates.statusCounts || {})
                    .map(([status, count]) => `<span style="color: ${statusColors[status] || '#94a3b8'};">${count} ${status}</span>`)
                    .join(' â€¢ ');

                aggregatesHTML = `
                    <div style="padding: 16px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 10px; margin-bottom: 16px;">
                        <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px;">ğŸ“Š Live Aggregates</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 16px; font-size: 14px; font-weight: 500;">
                            ${parts.join('')}
                        </div>
                        ${statusParts ? `<div style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">${statusParts}</div>` : ''}
                    </div>
                `;
            }

            // Build query conditions display (for query-generated hyperedges)
            let queryHTML = '';
            if (hyperedge.query?.conditions?.length > 0) {
                const conditionsList = hyperedge.query.conditions.map(c =>
                    `<div style="padding: 6px 10px; background: rgba(99, 102, 241, 0.1); border-radius: 4px; font-size: 12px;">
                        <span style="color: #818cf8;">${c.field}</span>
                        <span style="color: var(--text-secondary);">${c.operator}</span>
                        <span style="color: #22c55e;">"${c.value}"</span>
                    </div>`
                ).join('');
                queryHTML = `
                    <div style="padding: 16px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <span style="font-size: 14px;">ğŸ”</span>
                            <span style="font-size: 11px; color: #fbbf24; text-transform: uppercase; letter-spacing: 1px;">Query-Based Grouping</span>
                            ${hyperedge.dynamic ? '<span style="padding: 2px 8px; background: rgba(34, 197, 94, 0.2); border-radius: 4px; font-size: 10px; color: #22c55e;">DYNAMIC</span>' : ''}
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                            ${conditionsList}
                        </div>
                    </div>
                `;
            }

            // Build member nodes list with status indicators
            let memberNodesHTML = '';
            if (memberNodes.length > 0) {
                const nodeItems = memberNodes.slice(0, 8).map(n => {
                    const statusColor = { 'Done': '#22c55e', 'In Progress': '#f59e0b', 'To Do': '#94a3b8', 'Blocked': '#ef4444' }[n.pmStatus] || '#94a3b8';
                    return `
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                            <span style="width: 8px; height: 8px; border-radius: 50%; background: ${statusColor};"></span>
                            <span style="flex: 1; font-size: 13px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${n.name}</span>
                            ${n.cost ? `<span style="font-size: 11px; color: #22c55e;">${formatCost(n.cost)}</span>` : ''}
                        </div>
                    `;
                }).join('');
                const moreCount = memberNodes.length - 8;
                memberNodesHTML = `
                    <div style="margin-bottom: 16px;">
                        <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px;">ğŸ“ Member Nodes (${nodeCount})</div>
                        <div style="display: grid; gap: 6px; max-height: 200px; overflow-y: auto;">
                            ${nodeItems}
                            ${moreCount > 0 ? `<div style="padding: 8px; text-align: center; font-size: 12px; color: var(--text-secondary);">+ ${moreCount} more nodes</div>` : ''}
                        </div>
                    </div>
                `;
            }

            // AI Analysis section
            let analysisHTML = '';
            if (meta.aiAnalysis || hyperedge.aiInsight) {
                analysisHTML = `
                    <div style="padding: 16px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <span style="font-size: 14px;">ğŸ§ </span>
                            <span style="font-size: 11px; color: #a78bfa; text-transform: uppercase; letter-spacing: 1px;">AI Analysis</span>
                        </div>
                        <p style="margin: 0; color: var(--text-primary); line-height: 1.6; font-size: 13px;">
                            ${meta.aiAnalysis || hyperedge.aiInsight}
                        </p>
                    </div>
                `;
            }

            // Philosophy-specific fields (condensed)
            let philosophySection = '';
            if (isPhilosophy && Object.keys(philo).length > 0) {
                const philoItems = [];
                if (philo.dialecticalRelation) philoItems.push(`<div><strong>Dialectical:</strong> ${philo.dialecticalRelation}</div>`);
                if (philo.argumentativeFlow) philoItems.push(`<div><strong>Flow:</strong> ${philo.argumentativeFlow}</div>`);
                if (philo.conceptualBridge) philoItems.push(`<div><strong>Bridge:</strong> ${philo.conceptualBridge}</div>`);
                if (philo.tension) philoItems.push(`<div style="color: #f87171;"><strong>Tension:</strong> ${philo.tension}</div>`);
                if (philo.synthesis) philoItems.push(`<div style="color: #4ade80;"><strong>Synthesis:</strong> ${philo.synthesis}</div>`);

                philosophySection = `
                    <div style="padding: 16px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <span style="font-size: 14px;">ğŸ›ï¸</span>
                            <span style="font-size: 11px; color: #a78bfa; text-transform: uppercase; letter-spacing: 1px;">Philosophy Analysis</span>
                        </div>
                        <div style="display: grid; gap: 8px; font-size: 13px; color: var(--text-primary); line-height: 1.5;">
                            ${philoItems.join('')}
                        </div>
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div style="padding: 24px; max-width: 550px;">
                    <!-- Editable Header -->
                    <div style="margin-bottom: 20px;">
                        <input type="text" id="hyperedge-name-input" value="${(hyperedge.name || hyperedge.label || '').replace(/"/g, '&quot;')}"
                            placeholder="Hyperedge name..."
                            style="width: 100%; padding: 12px; font-size: 18px; font-weight: 600; background: rgba(0,0,0,0.2); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary);">
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <span style="font-size: 12px; color: var(--text-secondary);">${hyperedge.type || 'manual'} â€¢ ${nodeCount} nodes</span>
                            <span style="font-size: 12px; color: var(--text-secondary);">${hyperedge.createdAt ? new Date(hyperedge.createdAt).toLocaleDateString() : ''}</span>
                            <input type="color" id="hyperedge-color-input" value="${hyperedge.color || '#8b5cf6'}"
                                style="width: 24px; height: 24px; border: none; border-radius: 4px; cursor: pointer;" title="Change color">
                        </div>
                    </div>

                    <!-- Description -->
                    <div style="margin-bottom: 16px;">
                        <textarea id="hyperedge-desc-input" rows="2" placeholder="Describe why these nodes are grouped together..."
                            style="width: 100%; padding: 10px; font-size: 13px; background: rgba(0,0,0,0.2); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); resize: vertical; line-height: 1.5;">${hyperedge.description || ''}</textarea>
                    </div>

                    ${aggregatesHTML}
                    ${queryHTML}
                    ${analysisHTML}
                    ${philosophySection}
                    ${memberNodesHTML}

                    <!-- Action Buttons -->
                    <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px;">
                        <button onclick="analyzeHyperedgeWithAI('${hyperedge.id}')"
                            style="flex: 1; min-width: 120px; padding: 10px 16px; background: rgba(139, 92, 246, 0.2); color: #a78bfa; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px; cursor: pointer; font-size: 13px; display: flex; align-items: center; justify-content: center; gap: 6px;">
                            <span>ğŸ§ </span> Analyze
                        </button>
                        <button onclick="document.getElementById('modal').style.display='none'; focusOnHyperedge('${hyperedge.id}')"
                            style="flex: 1; min-width: 120px; padding: 10px 16px; background: rgba(99, 102, 241, 0.2); color: #818cf8; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; cursor: pointer; font-size: 13px; display: flex; align-items: center; justify-content: center; gap: 6px;">
                            <span>ğŸ¯</span> Focus View
                        </button>
                        <button onclick="deleteHyperedgeWithConfirm('${hyperedge.id}')"
                            style="padding: 10px 16px; background: rgba(239, 68, 68, 0.1); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 8px; cursor: pointer; font-size: 13px;">
                            ğŸ—‘ï¸
                        </button>
                    </div>
                </div>
            `;

            // Set up auto-save on blur
            setTimeout(() => {
                const nameInput = document.getElementById('hyperedge-name-input');
                const descInput = document.getElementById('hyperedge-desc-input');
                const colorInput = document.getElementById('hyperedge-color-input');

                const saveChanges = () => {
                    const he = capexTree.hyperedges?.find(h => h.id === hyperedge.id);
                    if (!he) return;

                    const newName = nameInput?.value?.trim();
                    const newDesc = descInput?.value?.trim();
                    const newColor = colorInput?.value;

                    let changed = false;
                    if (newName && newName !== (he.name || he.label)) {
                        he.name = newName;
                        he.label = newName;
                        changed = true;
                    }
                    if (newDesc !== he.description) {
                        he.description = newDesc;
                        changed = true;
                    }
                    if (newColor !== he.color) {
                        he.color = newColor;
                        changed = true;
                    }

                    if (changed) {
                        saveState('Edit Hyperedge');
                        renderCanvas();
                    }
                };

                nameInput?.addEventListener('blur', saveChanges);
                descInput?.addEventListener('blur', saveChanges);
                colorInput?.addEventListener('change', saveChanges);
            }, 100);

            document.querySelector('#modal .modal-footer').innerHTML = `
                <button class="btn btn-primary" onclick="document.getElementById('modal').style.display='none'">Done</button>
            `;

            modal.style.display = 'flex';
        }

        /**
         * BUILD 364: Analyze hyperedge relationship with AI
         */
        async function analyzeHyperedgeWithAI(hyperedgeId) {
            const hyperedge = capexTree.hyperedges?.find(h => h.id === hyperedgeId);
            if (!hyperedge) return;

            // Get member nodes
            const memberNodes = [];
            function findNodes(node) {
                if (hyperedge.nodeIds?.includes(node.id)) {
                    memberNodes.push({ name: node.name, description: node.description, status: node.pmStatus, cost: node.cost });
                }
                if (node.subItems) node.subItems.forEach(findNodes);
                if (node.children) node.children.forEach(findNodes);
            }
            capexTree.children?.forEach(phase => {
                (phase.items || phase.children || phase.subItems || []).forEach(findNodes);
            });

            const pattern = capexTree.pattern?.key || 'generic';
            const nodesSummary = memberNodes.map(n => `- ${n.name}${n.description ? ': ' + n.description.slice(0, 100) : ''}`).join('\n');

            const prompt = `Analyze why these ${memberNodes.length} items are grouped together in this "${hyperedge.name || hyperedge.label || 'hyperedge'}" relationship.

Pattern: ${pattern}
Hyperedge type: ${hyperedge.type || 'manual'}
${hyperedge.query?.conditions ? 'Query conditions: ' + hyperedge.query.conditions.map(c => `${c.field} ${c.operator} "${c.value}"`).join(' AND ') : ''}

Member nodes:
${nodesSummary}

Provide a concise (2-3 sentences) analysis explaining:
1. The key relationship or theme connecting these items
2. Why this grouping is meaningful for the ${pattern} context
3. Any insights or patterns you notice

Be specific and insightful, not generic.`;

            showToast('Analyzing relationship...', 'info');

            try {
                // BUILD 416: Fix - use callClaudeAPI (unified AI wrapper) instead of non-existent callAIWithStreaming
                const systemPrompt = 'You are an expert analyst helping understand relationships between items in a project tree. Be concise and insightful.';
                const response = await callClaudeAPI(prompt, systemPrompt, 1024, false);

                if (response) {
                    // Save analysis to hyperedge
                    hyperedge.aiInsight = response;
                    if (!hyperedge.metadata) hyperedge.metadata = {};
                    hyperedge.metadata.aiAnalysis = response;
                    hyperedge.metadata.analysisDate = new Date().toISOString();

                    saveState('AI Hyperedge Analysis');

                    // Refresh the modal
                    showHyperedgeInfo(hyperedge);
                    showToast('Analysis complete!', 'success');
                }
            } catch (error) {
                console.error('AI analysis failed:', error);
                showToast('Analysis failed: ' + (error.message || 'Check API key'), 'error');
            }
        }

        /**
         * Delete hyperedge with confirmation
         */
        function deleteHyperedgeWithConfirm(hyperedgeId) {
            if (confirm('Delete this hyperedge? Member nodes will remain but lose their visual grouping.')) {
                window.deleteHyperedge(hyperedgeId);
                document.getElementById('modal').style.display = 'none';
            }
        }

        /**
         * BUILD 282: Edit hyperedge label and description
         */
        function editHyperedge(hyperedgeId) {
            if (!capexTree.hyperedges) return;
            const hyperedge = capexTree.hyperedges.find(h => h.id === hyperedgeId);
            if (!hyperedge) {
                showToast('Hyperedge not found', 'error');
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            modalBody.innerHTML = `
                <div style="padding: 30px; max-width: 500px;">
                    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 24px;">
                        <div style="font-size: 48px;">âœï¸</div>
                        <div>
                            <h3 style="color: var(--treeplex-primary); margin-bottom: 4px;">Edit Hyperedge</h3>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                Update the label and description
                            </div>
                        </div>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">Label</label>
                        <input type="text" id="edit-hyperedge-label" value="${(hyperedge.label || '').replace(/"/g, '&quot;')}"
                            style="width: 100%; padding: 10px 12px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                            placeholder="e.g., Dialectical Opposition, Causal Link">
                    </div>

                    <div style="margin-bottom: 24px;">
                        <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">Description</label>
                        <textarea id="edit-hyperedge-description" rows="3"
                            style="width: 100%; padding: 10px 12px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-size: 14px; resize: vertical;"
                            placeholder="Describe the relationship between the connected nodes...">${(hyperedge.description || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
                    </div>

                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button onclick="showHyperedgeInfo(capexTree.hyperedges.find(h => h.id === '${hyperedgeId}'))"
                            style="padding: 10px 20px; background: rgba(107, 114, 128, 0.2); color: var(--text-secondary); border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; font-size: 13px;">
                            Cancel
                        </button>
                        <button onclick="saveHyperedgeEdit('${hyperedgeId}')"
                            style="padding: 10px 20px; background: var(--treeplex-primary); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">
                            Save Changes
                        </button>
                    </div>
                </div>
            `;

            // Focus the label input
            setTimeout(() => {
                const labelInput = document.getElementById('edit-hyperedge-label');
                if (labelInput) labelInput.focus();
            }, 100);
        }

        /**
         * BUILD 282: Save hyperedge edits
         */
        function saveHyperedgeEdit(hyperedgeId) {
            if (!capexTree.hyperedges) return;
            const hyperedge = capexTree.hyperedges.find(h => h.id === hyperedgeId);
            if (!hyperedge) {
                showToast('Hyperedge not found', 'error');
                return;
            }

            const labelInput = document.getElementById('edit-hyperedge-label');
            const descInput = document.getElementById('edit-hyperedge-description');

            const newLabel = labelInput?.value.trim() || 'Unnamed Hyperedge';
            const newDesc = descInput?.value.trim() || '';

            // Update hyperedge
            hyperedge.label = newLabel;
            hyperedge.description = newDesc;

            // Save state and re-render
            saveState('Edit hyperedge');
            renderCanvas();
            drawHyperedges();

            // Show updated info modal
            showHyperedgeInfo(hyperedge);
            showToast('Hyperedge updated', 'success');
        }

        /**
         * BUILD 283: Deep dive into a hyperedge relationship using AI
         * Analyzes the connected nodes in the context of the current tree
         * Uses handleAnalyzeSelection directly for reliable execution
         */
        function deepDiveHyperedge(hyperedgeId) {
            if (!capexTree.hyperedges) return;
            const hyperedge = capexTree.hyperedges.find(h => h.id === hyperedgeId);
            if (!hyperedge) {
                showToast('Hyperedge not found', 'error');
                return;
            }

            // Find all nodes in this hyperedge
            const nodeIds = hyperedge.nodeIds || [];
            if (nodeIds.length < 2) {
                showToast('Hyperedge needs at least 2 nodes for deep dive', 'error');
                return;
            }

            // Gather nodes from the tree
            const nodes = [];
            function findNode(item) {
                if (nodeIds.includes(item.id)) {
                    nodes.push(item);
                }
                if (item.subItems) {
                    item.subItems.forEach(findNode);
                }
            }
            capexTree.children.forEach(phase => {
                if (nodeIds.includes(phase.id)) {
                    nodes.push(phase);
                }
                phase.items?.forEach(findNode);
            });

            if (nodes.length < 2) {
                showToast('Could not find enough nodes for deep dive', 'error');
                return;
            }

            // Close the modal first
            document.getElementById('modal').style.display = 'none';

            // Store context about the existing hyperedge for the analysis
            window._hyperedgeDeepDiveContext = {
                label: getHyperedgeDisplayLabel(hyperedge),
                type: hyperedge.type || 'general',
                description: hyperedge.description || '',
                philosophyFields: hyperedge.metadata?.philosophyFields || null
            };

            // Trigger the deep dive analysis using handleAnalyzeSelection
            showToast(`Starting deep dive on ${nodes.length} nodes...`, 'info');
            handleAnalyzeSelection(nodes);
        }

        // =============================================================================
        // END HYPEREDGE VISUALIZATION
        // =============================================================================

        // =============================================================================
        // BUILD 565: IMAGE ANALYSIS - Background Image & Bounding Box Rendering
        // =============================================================================

        /**
         * Render the source image as a semi-transparent background on the canvas
         * Image is scaled to 1000px width and positioned at SVG_OFFSET
         */
        async function renderCanvasBackgroundImage() {
            const bgContainer = document.getElementById('canvas-background-image');
            const bgImg = document.getElementById('canvas-bg-img');

            if (!bgContainer || !bgImg) return;

            const imageData = capexTree._imageAnalysis;
            if (!imageData) {
                bgContainer.style.display = 'none';
                return;
            }

            // BUILD 568: Load image from IndexedDB if imageRef present, else use legacy sourceImage
            let imageSrc = null;

            if (imageData.imageRef?.id) {
                // New pattern: load from IndexedDB
                try {
                    const storedImage = await getImageFromStore(imageData.imageRef.id);
                    if (storedImage) {
                        imageSrc = storedImage.dataUrl;
                        console.log('ğŸ–¼ï¸ Loaded image from IndexedDB:', imageData.imageRef.id);
                    } else {
                        console.warn('âš ï¸ Image not found in IndexedDB:', imageData.imageRef.id);
                    }
                } catch (err) {
                    console.error('âŒ Failed to load image from IndexedDB:', err);
                }
            } else if (imageData.sourceImage) {
                // Legacy pattern: embedded base64
                imageSrc = imageData.sourceImage;
                console.log('ğŸ–¼ï¸ Using legacy embedded image');
            }

            if (!imageSrc) {
                bgContainer.style.display = 'none';
                return;
            }

            // Set image source
            bgImg.src = imageSrc;
            bgContainer.style.display = 'block';

            // Get dimensions and scale to 1000px width
            const imgDims = imageData.imageDimensions || imageData.imageRef?.dimensions;
            if (!imgDims) return;

            const targetWidth = 1000;
            const scale = targetWidth / imgDims.width;
            const scaledHeight = imgDims.height * scale;

            bgImg.style.width = `${targetWidth}px`;
            bgImg.style.height = `${scaledHeight}px`;

            // Position at SVG_OFFSET to align with canvas coordinate system
            bgContainer.style.left = `${SVG_OFFSET}px`;
            bgContainer.style.top = `${SVG_OFFSET}px`;

            // Update opacity from stored preference or default
            bgContainer.style.opacity = imageData.bgOpacity || 0.4;

            console.log('ğŸ–¼ï¸ Rendered background image:', { width: targetWidth, height: scaledHeight });
        }

        /**
         * Draw bounding box overlays for all nodes with _bbox data
         * Boxes are drawn on the canvas-bboxes SVG layer
         */
        function drawBoundingBoxes() {
            const bboxSvg = document.getElementById('canvas-bboxes');
            if (!bboxSvg) return;

            // Clear existing bboxes
            bboxSvg.innerHTML = '';

            const imageData = capexTree._imageAnalysis;
            if (!imageData?.showOverlays) return;

            const imgDims = imageData.imageDimensions;
            if (!imgDims) return;

            // Scale factor: image is rendered at 1000px width
            const targetWidth = 1000;
            const imgScale = targetWidth / imgDims.width;

            // Color map for different object types
            const typeColors = {
                'primary': { stroke: '#22C55E', fill: 'rgba(34, 197, 94, 0.15)' },      // Green
                'secondary': { stroke: '#3B82F6', fill: 'rgba(59, 130, 246, 0.15)' },   // Blue
                'background': { stroke: '#6B7280', fill: 'rgba(107, 114, 128, 0.1)' },  // Gray
                'text': { stroke: '#F59E0B', fill: 'rgba(245, 158, 11, 0.15)' },        // Amber
                'ui-element': { stroke: '#8B5CF6', fill: 'rgba(139, 92, 246, 0.15)' }   // Purple
            };
            const defaultColor = { stroke: '#EF4444', fill: 'rgba(239, 68, 68, 0.15)' }; // Red

            // Collect all nodes with bounding boxes
            const nodesWithBbox = [];
            function collectNodes(node) {
                if (node._bbox) nodesWithBbox.push(node);
                (node.children || []).forEach(collectNodes);
                (node.items || []).forEach(item => {
                    if (item._bbox) nodesWithBbox.push(item);
                    (item.subItems || item.children || []).forEach(collectNodes);
                });
            }
            collectNodes(capexTree);

            // Draw each bounding box
            nodesWithBbox.forEach((node, idx) => {
                const bbox = node._bbox;
                if (!bbox) return;

                // Convert Gemini 0-1000 coords to canvas pixels
                // Gemini format: { yMin, xMin, yMax, xMax }
                const x = (bbox.xMin / 1000) * imgDims.width * imgScale + SVG_OFFSET;
                const y = (bbox.yMin / 1000) * imgDims.height * imgScale + SVG_OFFSET;
                const width = ((bbox.xMax - bbox.xMin) / 1000) * imgDims.width * imgScale;
                const height = ((bbox.yMax - bbox.yMin) / 1000) * imgDims.height * imgScale;

                // Get color based on itemType
                const colors = typeColors[node.itemType] || defaultColor;

                // Create group for bbox elements
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('data-node-id', node.id);
                group.style.cursor = 'pointer';

                // Create SVG rect
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', Math.max(width, 10));
                rect.setAttribute('height', Math.max(height, 10));
                rect.setAttribute('fill', colors.fill);
                rect.setAttribute('stroke', colors.stroke);
                rect.setAttribute('stroke-width', '2');
                rect.setAttribute('stroke-dasharray', '6,3');
                rect.setAttribute('rx', '4');
                rect.style.transition = 'stroke-width 0.2s, opacity 0.2s';

                // Add label above bbox
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x + 4);
                label.setAttribute('y', y - 6);
                label.setAttribute('fill', colors.stroke);
                label.setAttribute('font-size', '11');
                label.setAttribute('font-weight', '600');
                label.style.textShadow = '0 0 4px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.7)';
                label.style.pointerEvents = 'none';
                label.textContent = node.name?.substring(0, 25) || 'Object';

                // Confidence badge
                if (node._confidence) {
                    const conf = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    conf.setAttribute('x', x + width - 4);
                    conf.setAttribute('y', y - 6);
                    conf.setAttribute('fill', 'rgba(255,255,255,0.7)');
                    conf.setAttribute('font-size', '10');
                    conf.setAttribute('text-anchor', 'end');
                    conf.style.textShadow = '0 0 4px rgba(0,0,0,0.9)';
                    conf.style.pointerEvents = 'none';
                    conf.textContent = `${Math.round(node._confidence * 100)}%`;
                    group.appendChild(conf);
                }

                // Hover effects
                group.addEventListener('mouseenter', () => {
                    rect.setAttribute('stroke-width', '4');
                    rect.setAttribute('stroke-dasharray', 'none');
                    highlightCanvasNodeById(node.id);
                });
                group.addEventListener('mouseleave', () => {
                    rect.setAttribute('stroke-width', '2');
                    rect.setAttribute('stroke-dasharray', '6,3');
                    unhighlightCanvasNodeById(node.id);
                });
                group.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectCanvasNodeById(node.id);
                });

                group.appendChild(rect);
                group.appendChild(label);
                bboxSvg.appendChild(group);

                // Draw connecting line from bbox center to node card (if node has canvas position)
                if (node.canvasX !== undefined && node.canvasY !== undefined) {
                    const bboxCenterX = x + width / 2;
                    const bboxCenterY = y + height / 2;
                    const nodeCenterX = node.canvasX + 160 + SVG_OFFSET;
                    const nodeCenterY = node.canvasY + 60 + SVG_OFFSET;

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', bboxCenterX);
                    line.setAttribute('y1', bboxCenterY);
                    line.setAttribute('x2', nodeCenterX);
                    line.setAttribute('y2', nodeCenterY);
                    line.setAttribute('stroke', colors.stroke);
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '4,4');
                    line.setAttribute('opacity', '0.5');
                    line.style.pointerEvents = 'none';

                    bboxSvg.appendChild(line);
                }
            });

            console.log(`ğŸ“¦ Drew ${nodesWithBbox.length} bounding boxes`);
        }

        /**
         * Helper: Highlight a canvas node by its ID
         */
        function highlightCanvasNodeById(nodeId) {
            const nodeEl = document.querySelector(`.canvas-node[data-item-id="${nodeId}"]`) ||
                          document.querySelector(`.canvas-node[data-id="${nodeId}"]`);
            if (nodeEl) {
                nodeEl.style.boxShadow = '0 0 20px rgba(99, 102, 241, 0.8), 0 4px 12px rgba(0,0,0,0.3)';
                nodeEl.style.transform = 'scale(1.02)';
            }
        }

        /**
         * Helper: Remove highlight from a canvas node
         */
        function unhighlightCanvasNodeById(nodeId) {
            const nodeEl = document.querySelector(`.canvas-node[data-item-id="${nodeId}"]`) ||
                          document.querySelector(`.canvas-node[data-id="${nodeId}"]`);
            if (nodeEl) {
                nodeEl.style.boxShadow = '';
                nodeEl.style.transform = '';
            }
        }

        /**
         * Helper: Select/focus a canvas node by its ID
         */
        function selectCanvasNodeById(nodeId) {
            // Try both data-item-id (standard) and data-id (legacy)
            const nodeEl = document.querySelector(`.canvas-node[data-item-id="${nodeId}"]`) ||
                          document.querySelector(`.canvas-node[data-id="${nodeId}"]`);
            if (nodeEl) {
                nodeEl.click();
            }
        }

        /**
         * BUILD 567: Highlight bbox overlay for a node (reverse direction)
         */
        function highlightBboxByNodeId(nodeId) {
            const bboxGroup = document.querySelector(`#canvas-bboxes g[data-node-id="${nodeId}"]`);
            if (bboxGroup) {
                const rect = bboxGroup.querySelector('rect');
                if (rect) {
                    rect.setAttribute('stroke-width', '4');
                    rect.setAttribute('stroke-dasharray', 'none');
                    rect.style.filter = 'drop-shadow(0 0 8px currentColor)';
                }
            }
        }

        /**
         * BUILD 567: Remove highlight from bbox overlay
         */
        function unhighlightBboxByNodeId(nodeId) {
            const bboxGroup = document.querySelector(`#canvas-bboxes g[data-node-id="${nodeId}"]`);
            if (bboxGroup) {
                const rect = bboxGroup.querySelector('rect');
                if (rect) {
                    rect.setAttribute('stroke-width', '2');
                    rect.setAttribute('stroke-dasharray', '6,3');
                    rect.style.filter = '';
                }
            }
        }

        /**
         * BUILD 567: Flash bbox to draw attention
         */
        function flashBboxByNodeId(nodeId) {
            const bboxGroup = document.querySelector(`#canvas-bboxes g[data-node-id="${nodeId}"]`);
            if (bboxGroup) {
                const rect = bboxGroup.querySelector('rect');
                if (rect) {
                    // Flash animation
                    rect.style.transition = 'opacity 0.15s';
                    rect.style.opacity = '0.3';
                    setTimeout(() => { rect.style.opacity = '1'; }, 150);
                    setTimeout(() => { rect.style.opacity = '0.3'; }, 300);
                    setTimeout(() => { rect.style.opacity = '1'; rect.style.transition = ''; }, 450);
                }
            }
        }

        /**
         * BUILD 567: Pan canvas to center on a node's bbox
         */
        function panToBboxByNodeId(nodeId) {
            // Find the node with this ID and its bbox
            let targetNode = null;
            function findNode(node) {
                if (node.id === nodeId) { targetNode = node; return; }
                (node.children || []).forEach(findNode);
                (node.items || []).forEach(item => {
                    if (item.id === nodeId) { targetNode = item; return; }
                    (item.subItems || item.children || []).forEach(findNode);
                });
            }
            findNode(capexTree);

            if (!targetNode?._bbox) return;

            const imageData = capexTree._imageAnalysis;
            if (!imageData?.imageDimensions) return;

            const imgDims = imageData.imageDimensions;
            const targetWidth = 1000;
            const imgScale = targetWidth / imgDims.width;
            const bbox = targetNode._bbox;

            // Convert bbox coords to canvas coords (handle both 0-1000 and 0-1 scale)
            const scale = bbox.xMax > 1 ? 1000 : 1; // Detect scale
            const bboxCenterX = ((bbox.xMin + bbox.xMax) / 2 / scale) * imgDims.width * imgScale + SVG_OFFSET;
            const bboxCenterY = ((bbox.yMin + bbox.yMax) / 2 / scale) * imgDims.height * imgScale + SVG_OFFSET;

            // Calculate pan to center bbox in viewport
            const container = document.getElementById('canvas-container');
            if (!container) return;

            const viewportWidth = container.clientWidth;
            const viewportHeight = container.clientHeight;

            // New pan positions to center the bbox
            const newPanX = (viewportWidth / 2 / canvasZoom) - bboxCenterX;
            const newPanY = (viewportHeight / 2 / canvasZoom) - bboxCenterY;

            // Animate pan
            const startPanX = canvasPan.x;
            const startPanY = canvasPan.y;
            const duration = 300;
            const startTime = performance.now();

            function animatePan(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3); // ease-out cubic

                canvasPan.x = startPanX + (newPanX - startPanX) * eased;
                canvasPan.y = startPanY + (newPanY - startPanY) * eased;
                updateCanvasTransform();

                if (progress < 1) {
                    requestAnimationFrame(animatePan);
                } else {
                    // Flash the bbox after pan completes
                    flashBboxByNodeId(nodeId);
                    highlightBboxByNodeId(nodeId);
                }
            }

            requestAnimationFrame(animatePan);
        }

        /**
         * Toggle bounding box overlay visibility
         */
        function toggleBoundingBoxOverlays() {
            if (!capexTree._imageAnalysis) return;
            capexTree._imageAnalysis.showOverlays = !capexTree._imageAnalysis.showOverlays;
            renderCanvas();
            const status = capexTree._imageAnalysis.showOverlays ? 'shown' : 'hidden';
            showToast(`ğŸ“¦ Bounding boxes ${status}`, 'info');
        }

        // BUILD 567: Bbox filter state
        let bboxTypeFilter = '';
        let bboxConfidenceFilter = 0;

        /**
         * BUILD 567: Filter bboxes by object type
         */
        function filterBboxByType(type) {
            bboxTypeFilter = type;
            applyBboxFilters();
        }

        /**
         * BUILD 567: Filter bboxes by confidence threshold
         */
        function filterBboxByConfidence(threshold) {
            bboxConfidenceFilter = parseFloat(threshold) || 0;
            applyBboxFilters();
        }

        /**
         * BUILD 567: Apply bbox filters - show/hide based on type and confidence
         */
        function applyBboxFilters() {
            const bboxSvg = document.getElementById('canvas-bboxes');
            if (!bboxSvg) return;

            const groups = bboxSvg.querySelectorAll('g[data-node-id]');
            let visibleCount = 0;
            let hiddenCount = 0;

            groups.forEach(group => {
                const nodeId = group.getAttribute('data-node-id');
                const node = findNodeById(nodeId);
                if (!node) return;

                let show = true;

                // Type filter
                if (bboxTypeFilter && node._objectType !== bboxTypeFilter) {
                    show = false;
                }

                // Confidence filter
                if (node._confidence && node._confidence < bboxConfidenceFilter) {
                    show = false;
                }

                group.style.display = show ? '' : 'none';
                if (show) visibleCount++; else hiddenCount++;
            });

            if (bboxTypeFilter || bboxConfidenceFilter > 0) {
                showToast(`ğŸ“¦ Showing ${visibleCount} boxes (${hiddenCount} filtered)`, 'info');
            }
        }

        /**
         * BUILD 567: Populate type filter dropdown from detected objects
         */
        function populateBboxTypeFilter() {
            const select = document.getElementById('bbox-type-filter');
            if (!select) return;

            // Collect unique object types
            const types = new Set();
            function collectTypes(node) {
                if (node._objectType) types.add(node._objectType);
                (node.children || []).forEach(collectTypes);
                (node.items || []).forEach(item => {
                    if (item._objectType) types.add(item._objectType);
                    (item.subItems || item.children || []).forEach(collectTypes);
                });
            }
            collectTypes(capexTree);

            // Reset and populate options
            select.innerHTML = '<option value="">All Types</option>';
            Array.from(types).sort().forEach(type => {
                const opt = document.createElement('option');
                opt.value = type;
                opt.textContent = type;
                select.appendChild(opt);
            });
        }

        /**
         * BUILD 567: Helper to find node by ID
         */
        function findNodeById(nodeId) {
            let found = null;
            function search(node) {
                if (node.id === nodeId) { found = node; return; }
                (node.children || []).forEach(search);
                (node.items || []).forEach(item => {
                    if (item.id === nodeId) { found = item; return; }
                    (item.subItems || item.children || []).forEach(search);
                });
            }
            search(capexTree);
            return found;
        }

        /**
         * Toggle background image visibility
         */
        function toggleBackgroundImage() {
            const bgContainer = document.getElementById('canvas-background-image');
            if (!bgContainer) return;
            const isVisible = bgContainer.style.display !== 'none';
            bgContainer.style.display = isVisible ? 'none' : 'block';
            showToast(`ğŸ–¼ï¸ Background image ${isVisible ? 'hidden' : 'shown'}`, 'info');
        }

        /**
         * Set background image opacity
         */
        function setBackgroundOpacity(value) {
            const bgContainer = document.getElementById('canvas-background-image');
            if (!bgContainer) return;
            const opacity = Math.max(0, Math.min(1, value));
            bgContainer.style.opacity = opacity;
            if (capexTree._imageAnalysis) {
                capexTree._imageAnalysis.bgOpacity = opacity;
            }
        }

        // =============================================================================
        // END IMAGE ANALYSIS RENDERING
        // =============================================================================

        // =============================================================================
        // BUILD 568: IMAGE IMPORT MODAL
        // =============================================================================

        let pendingImageData = null; // Stores the image data URL pending analysis

        function showImageImportModal() {
            const modal = document.getElementById('image-import-modal');
            if (!modal) return;

            // Reset state
            pendingImageData = null;
            document.getElementById('image-url-input').value = '';
            document.getElementById('image-preview-container').style.display = 'none';
            document.getElementById('image-analyze-btn').disabled = true;
            document.getElementById('image-analyze-btn').style.opacity = '0.5';

            // Show capture section if extension connected
            const captureSection = document.getElementById('image-capture-section');
            if (captureSection && typeof mcpBridgeState !== 'undefined' && mcpBridgeState.connected) {
                captureSection.style.display = 'block';
            }

            modal.style.display = 'flex';
            console.log('ğŸ–¼ï¸ Image import modal opened');
        }

        function hideImageImportModal() {
            const modal = document.getElementById('image-import-modal');
            if (modal) {
                modal.style.display = 'none';
                pendingImageData = null;
            }
        }

        function updateImagePreview(dataUrl, fileName = 'Image') {
            pendingImageData = dataUrl;

            const preview = document.getElementById('image-preview');
            const container = document.getElementById('image-preview-container');
            const dims = document.getElementById('image-preview-dims');
            const size = document.getElementById('image-preview-size');
            const analyzeBtn = document.getElementById('image-analyze-btn');

            if (!preview || !container) return;

            preview.src = dataUrl;
            container.style.display = 'block';

            // Get dimensions when loaded
            preview.onload = () => {
                dims.textContent = `${preview.naturalWidth} x ${preview.naturalHeight}`;
            };

            // Calculate size from base64
            const base64Length = dataUrl.split(',')[1]?.length || 0;
            const sizeBytes = Math.round((base64Length * 3) / 4);
            const sizeKB = Math.round(sizeBytes / 1024);
            size.textContent = sizeKB > 1024 ? `${(sizeKB / 1024).toFixed(1)} MB` : `${sizeKB} KB`;

            // Enable analyze button
            analyzeBtn.disabled = false;
            analyzeBtn.style.opacity = '1';

            console.log('ğŸ–¼ï¸ Image preview updated:', { fileName, sizeKB });
        }

        async function captureScreenForImport() {
            showToast('ğŸ“¸ Capturing screen...', 'info');

            try {
                // Use existing MCP bridge capture if available
                if (typeof mcpBridgeState !== 'undefined' && mcpBridgeState.connected && mcpBridgeState.client) {
                    const result = await mcpBridgeState.client.callTool('ext_capture_screen', { quality: 0.8 });
                    if (result?.content?.[0]?.text) {
                        const response = JSON.parse(result.content[0].text);
                        if (response.screenshot) {
                            updateImagePreview(response.screenshot, response.title || 'Captured Screen');
                            showToast('âœ… Screen captured!', 'success');
                            return;
                        }
                    }
                }

                // Fallback: check for cached screen capture
                if (window._lastScreenCapture?.screenshot) {
                    updateImagePreview(window._lastScreenCapture.screenshot, window._lastScreenCapture.title || 'Cached Capture');
                    showToast('âœ… Using cached screen capture', 'success');
                    return;
                }

                showToast('âš ï¸ No screen capture available. Connect MCP Bridge first.', 'warning');
            } catch (err) {
                console.error('Failed to capture screen:', err);
                showToast('âŒ Screen capture failed: ' + err.message, 'error');
            }
        }

        async function analyzeImportedImage() {
            if (!pendingImageData) {
                showToast('âš ï¸ No image selected', 'warning');
                return;
            }

            // Check for Gemini API key
            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) {
                showToast('âš ï¸ Please set your Gemini API key first', 'warning');
                return;
            }

            // Get import mode
            const modeRadio = document.querySelector('input[name="image-import-mode"]:checked');
            const mode = modeRadio?.value || 'replace';

            // IMPORTANT: Save image data before closing modal (which clears pendingImageData)
            const imageDataToAnalyze = pendingImageData;

            hideImageImportModal();
            showToast('ğŸ” Analyzing image with Gemini Vision...', 'info');

            try {
                const result = await analyzeImageForTree(imageDataToAnalyze);

                if (mode === 'replace') {
                    // Replace the entire tree
                    capexTree = result;
                    selectedItemId = capexTree.id;
                } else {
                    // Add as child of selected node
                    const targetNode = findNode(capexTree, selectedItemId) || capexTree;
                    if (!targetNode.children) targetNode.children = [];
                    result.id = 'img-' + Date.now();
                    targetNode.children.push(result);
                }

                saveState('Import Image Analysis');
                render();
                renderCanvas();

                // Switch to canvas view to show the analysis
                if (typeof viewMode !== 'undefined' && viewMode !== 'canvas') {
                    document.getElementById('view-mode-toggle')?.click();
                }

                showToast('âœ… Image analyzed! Switch to Canvas view to see bounding boxes.', 'success');
            } catch (err) {
                console.error('Image analysis failed:', err);
                showToast('âŒ Analysis failed: ' + err.message, 'error');
            }
        }

        // Initialize image import modal event handlers
        function initImageImportModal() {
            const dropZone = document.getElementById('image-drop-zone');
            const urlInput = document.getElementById('image-url-input');
            const fileInput = document.getElementById('image-upload-input');

            if (!dropZone || !fileInput) return;

            // Click to browse
            dropZone.addEventListener('click', () => fileInput.click());

            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.style.borderColor = '#6366f1';
                dropZone.style.background = 'rgba(99, 102, 241, 0.1)';
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.style.borderColor = 'var(--border)';
                dropZone.style.background = 'var(--bg)';
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.style.borderColor = 'var(--border)';
                dropZone.style.background = 'var(--bg)';

                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    handleImageFile(file);
                } else {
                    showToast('âš ï¸ Please drop an image file', 'warning');
                }
            });

            // File input change
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleImageFile(file);
                    fileInput.value = ''; // Reset for next use
                }
            });

            // URL input (on Enter or blur)
            urlInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleImageUrl(urlInput.value);
                }
            });

            urlInput.addEventListener('blur', () => {
                if (urlInput.value) {
                    handleImageUrl(urlInput.value);
                }
            });

            console.log('ğŸ–¼ï¸ Image import modal initialized');
        }

        function handleImageFile(file) {
            if (file.size > 20 * 1024 * 1024) {
                showToast('âš ï¸ Image too large (max 20MB)', 'warning');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                updateImagePreview(e.target.result, file.name);
            };
            reader.onerror = () => {
                showToast('âŒ Failed to read image file', 'error');
            };
            reader.readAsDataURL(file);
        }

        async function handleImageUrl(url) {
            if (!url) return;

            try {
                showToast('â³ Loading image from URL...', 'info');

                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to fetch image');

                const blob = await response.blob();
                if (!blob.type.startsWith('image/')) {
                    throw new Error('URL does not point to an image');
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    updateImagePreview(e.target.result, url.split('/').pop());
                    showToast('âœ… Image loaded', 'success');
                };
                reader.readAsDataURL(blob);
            } catch (err) {
                console.error('Failed to load image from URL:', err);
                showToast('âŒ Failed to load image: ' + err.message, 'error');
            }
        }

        // =============================================================================
        // END IMAGE IMPORT MODAL
        // =============================================================================

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', initImageImportModal);

        function drawConnections() {
            // Skip drawing connections for filesystem pattern (uses indent-based hierarchy)
            if (currentPattern === 'filesystem') {
                return;
            }

            const svg = document.getElementById('canvas-connections');
            svg.innerHTML = '';

            // Draw hyperedges first (so they appear behind regular connections)
            drawHyperedges();

            // Recursively draw connections for all nodes
            capexTree.children.forEach(phase => {
                // Skip hidden phases - don't draw connections for nodes that aren't visible
                if (phase.showInCanvas === false) {
                    return;
                }

                // Handle both items (standard) and children (imported JSON) arrays
                const phaseItems = phase.items || phase.children || phase.subItems || [];
                phaseItems.forEach(item => {
                    drawNodeConnections(item);
                });
            });
        }

        // Recursive function to draw connections for a node and its descendants
        // BUILD 445: Enhanced with link types
        function drawNodeConnections(node) {
            // Only draw connections if this node is expanded (showing children)
            if (node.expanded !== false && node.subItems && node.subItems.length > 0) {
                node.subItems.forEach(subtask => {
                    // Only draw line if subtask is actually visible
                    if (isNodeVisible(subtask.id)) {
                        drawConnection(
                            node.canvasX + 160, node.canvasY + 60,      // From parent center-right
                            subtask.canvasX, subtask.canvasY + 60,      // To subtask center-left
                            null,                                       // Color from link type
                            'solid',
                            'parentChild'                               // Use parentChild link type
                        );
                    }

                    // Recursively draw connections for this subtask's descendants
                    drawNodeConnections(subtask);
                });
            }

            // Draw lines for dependencies only if both nodes are visible
            // BUILD 446: Use getDependencies() for normalized typed dependencies
            // BUILD 449: Highlight critical path dependencies
            // BUILD 510: Respect showDependencies and showDepsForSelectedOnly filters
            if (!showDependencies) return;  // Skip all dependencies if toggle is off

            const deps = getDependencies(node);
            if (deps.length > 0) {
                deps.forEach(dep => {
                    const depNode = canvasNodes.find(n => n.data.id === dep.predecessorId);
                    if (depNode && depNode.data) {
                        // Only draw if both the dependency and this node are visible
                        if (isNodeVisible(dep.predecessorId) && isNodeVisible(node.id)) {
                            // BUILD 510: Filter by selected node if enabled
                            if (showDepsForSelectedOnly && selectedCanvasNodeId) {
                                // Only show deps connected to selected node
                                if (node.id !== selectedCanvasNodeId && dep.predecessorId !== selectedCanvasNodeId) {
                                    return; // Skip this dependency
                                }
                            }

                            const fromX = depNode.data.canvasX + 160;
                            const fromY = depNode.data.canvasY + 60;
                            const toX = node.canvasX;
                            const toY = node.canvasY + 60;

                            // BUILD 449: Use criticalPath link type if both nodes are on critical path
                            const isCritical = showCriticalPath &&
                                depNode.data._isCritical &&
                                node._isCritical;

                            // BUILD 510: Determine link type based on dependency type and critical status
                            let linkType;
                            if (isCritical) {
                                linkType = 'criticalPath';
                            } else {
                                // Use color-coded link type based on dependency type
                                const depType = dep.type || 'FS';
                                linkType = `dependency${depType}`;  // dependencyFS, dependencySS, etc.
                                // Fallback to generic dependency if type not found
                                if (!LINK_TYPES[linkType]) {
                                    linkType = 'dependency';
                                }
                            }

                            drawConnection(
                                fromX, fromY,  // From predecessor
                                toX, toY,      // To successor
                                null,          // Color from link type
                                'dashed',
                                linkType       // Use typed dependency link
                            );

                            // Draw type badge for non-default dependencies (or always for clickability)
                            // BUILD 448: Pass node IDs for edit/delete functionality
                            drawDependencyBadge(fromX, fromY, toX, toY, dep, node.id, dep.predecessorId, isCritical);
                        }
                    }
                });
            }
        }

        // BUILD 447: Helper functions for dependency creation

        // Find nearest canvas node to a point
        function findNearestCanvasNode(x, y, maxDistance = 100) {
            let nearest = null;
            let nearestDist = maxDistance;

            canvasNodes.forEach(nodeObj => {
                const node = nodeObj.data;
                if (node.canvasX === undefined) return;

                // Calculate distance to node center
                const centerX = node.canvasX + 160;  // Approximate center
                const centerY = node.canvasY + 60;
                const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);

                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = node;
                }
            });

            return nearest;
        }

        // Check if a dependency already exists
        function hasDependency(successorNode, predecessorId) {
            const deps = getDependencies(successorNode);
            return deps.some(d => d.predecessorId === predecessorId);
        }

        // Draw temporary dependency line while dragging
        function drawTempDependencyLine() {
            clearTempDependencyLine();

            if (!depSourceNode) return;

            const svg = document.getElementById('canvas-connections');
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.id = 'temp-dependency-line';

            const fromX = depSourceNode.canvasX + 160 + SVG_OFFSET;
            const fromY = depSourceNode.canvasY + 60 + SVG_OFFSET;

            let toX, toY;
            if (depSnapTarget) {
                toX = depSnapTarget.canvasX + SVG_OFFSET;
                toY = depSnapTarget.canvasY + 60 + SVG_OFFSET;
            } else {
                toX = depDragEndX + SVG_OFFSET;
                toY = depDragEndY + SVG_OFFSET;
            }

            // Draw bezier path
            const d = calculateBezierPath(fromX - SVG_OFFSET, fromY - SVG_OFFSET, toX - SVG_OFFSET, toY - SVG_OFFSET);
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', d.replace(/(\d+)/g, (m) => parseFloat(m) + SVG_OFFSET));
            path.setAttribute('stroke', depSnapTarget ? '#22c55e' : '#ff6b6b');
            path.setAttribute('stroke-width', '3');
            path.setAttribute('stroke-dasharray', '8,4');
            path.setAttribute('fill', 'none');
            path.setAttribute('opacity', '0.8');

            g.appendChild(path);
            svg.appendChild(g);
        }

        // Clear temporary dependency line
        function clearTempDependencyLine() {
            const existing = document.getElementById('temp-dependency-line');
            if (existing) existing.remove();
        }

        // Show dependency creation modal
        function showDependencyCreationModal(source, target) {
            const modal = document.getElementById('modal');
            document.getElementById('modal-title').textContent = 'Create Dependency';
            // BUILD 603: Clear modal footer (fixes persisted Create Hyperedge button from Query Builder)
            document.querySelector('#modal .modal-footer').innerHTML = '';
            document.getElementById('modal-body').innerHTML = `
                <div style="padding: 16px;">
                    <p style="margin-bottom: 16px; color: var(--text-secondary);">
                        Create a dependency where <strong style="color: var(--text-primary);">${source.name}</strong>
                        must complete before <strong style="color: var(--text-primary);">${target.name}</strong> can start.
                    </p>

                    <div style="display: grid; gap: 12px;">
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-weight: 500;">Dependency Type:</label>
                            <select id="dep-create-type" style="width: 100%; padding: 8px; border-radius: 6px; background: var(--bg-secondary); border: 1px solid var(--border); color: var(--text-primary);">
                                <option value="FS" selected>â†’ Finish-to-Start (default)</option>
                                <option value="SS">â‡‰ Start-to-Start</option>
                                <option value="FF">â‡¶ Finish-to-Finish</option>
                                <option value="SF">â†” Start-to-Finish</option>
                            </select>
                        </div>

                        <div>
                            <label style="display: block; margin-bottom: 4px; font-weight: 500;">Lag (days):</label>
                            <input type="number" id="dep-create-lag" value="0" min="-365" max="365"
                                style="width: 100%; padding: 8px; border-radius: 6px; background: var(--bg-secondary); border: 1px solid var(--border); color: var(--text-primary);">
                            <span style="font-size: 12px; color: var(--text-secondary);">Positive = delay, Negative = overlap</span>
                        </div>
                    </div>

                    <div style="display: flex; gap: 8px; margin-top: 20px; justify-content: flex-end;">
                        <button onclick="document.getElementById('modal').style.display='none'"
                            style="padding: 8px 16px; border-radius: 6px; background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="confirmCreateDependency('${source.id}', '${target.id}')"
                            style="padding: 8px 16px; border-radius: 6px; background: var(--treeplex-primary); border: none; color: white; cursor: pointer; font-weight: 500;">
                            Create Dependency
                        </button>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
        }

        // Confirm and create the dependency
        function confirmCreateDependency(sourceId, targetId) {
            const type = document.getElementById('dep-create-type').value;
            const lag = parseInt(document.getElementById('dep-create-lag').value) || 0;

            // Find the target node
            let targetNode = null;
            function findNode(nodes) {
                for (const node of nodes) {
                    if (node.id === targetId) return node;
                    const children = node.subItems || node.children || node.items || [];
                    const found = findNode(children);
                    if (found) return found;
                }
                return null;
            }
            for (const phase of (capexTree?.children || [])) {
                if (phase.id === targetId) { targetNode = phase; break; }
                const items = phase.items || phase.children || phase.subItems || [];
                targetNode = findNode(items);
                if (targetNode) break;
            }

            if (!targetNode) {
                showToast('Error: Target node not found', 'error');
                return;
            }

            // Save state for undo
            saveState(`Create dependency: ${sourceId} â†’ ${targetId}`);

            // Add dependency
            if (!targetNode.dependencies) targetNode.dependencies = [];
            targetNode.dependencies.push({
                predecessorId: sourceId,
                type: type,
                lag: lag
            });

            // Close modal and re-render
            document.getElementById('modal').style.display = 'none';
            renderCanvas();
            showToast(`Dependency created (${type}${lag !== 0 ? ', ' + lag + 'd lag' : ''})`, 'success');
        }

        // Expose for external use
        window.confirmCreateDependency = confirmCreateDependency;

        // BUILD 448: Edit/Delete dependency modal
        function showDependencyEditModal(successorId, predecessorId, currentType, currentLag) {
            const successorNode = getNodeById(successorId);
            const predecessorNode = getNodeById(predecessorId);

            if (!successorNode || !predecessorNode) {
                showToast('Could not find dependency nodes', 'error');
                return;
            }

            // Get task names (check both name and title fields)
            const predName = predecessorNode.name || predecessorNode.title || 'Unnamed Task';
            const succName = successorNode.name || successorNode.title || 'Unnamed Task';

            // Get dates if available
            const predEnd = predecessorNode.pmDueDate || predecessorNode.pmEndDate || '';
            const succStart = successorNode.pmStartDate || '';

            // Dependency type descriptions
            const typeDescriptions = {
                'FS': 'Successor starts after predecessor finishes',
                'FF': 'Both tasks must finish at the same time',
                'SS': 'Both tasks must start at the same time',
                'SF': 'Predecessor starts after successor finishes'
            };

            // Current type info
            const currentTypeInfo = DEPENDENCY_TYPES[currentType] || DEPENDENCY_TYPES['FS'];

            const modal = document.getElementById('modal');
            const modalBody = document.querySelector('#modal .modal-body');

            modalBody.innerHTML = `
                <div style="padding: 24px; max-width: 480px;">
                    <!-- Header -->
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #6366f1, #8b5cf6); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 20px;">
                            ğŸ”—
                        </div>
                        <div>
                            <h3 style="margin: 0; color: var(--text-primary); font-size: 18px; font-weight: 600;">
                                Edit Dependency
                            </h3>
                            <div style="font-size: 12px; color: var(--text-tertiary); margin-top: 2px;">
                                Configure how these tasks relate
                            </div>
                        </div>
                    </div>

                    <!-- Visual Relationship Diagram -->
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.05)); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <!-- Predecessor -->
                            <div style="flex: 1; background: var(--bg-secondary); border-radius: 8px; padding: 12px; border-left: 3px solid #22c55e;">
                                <div style="font-size: 10px; color: #22c55e; font-weight: 600; text-transform: uppercase; margin-bottom: 4px;">
                                    Predecessor
                                </div>
                                <div style="font-size: 13px; color: var(--text-primary); font-weight: 500; line-height: 1.3; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${predName}">
                                    ${predName.length > 25 ? predName.substring(0, 25) + '...' : predName}
                                </div>
                                ${predEnd ? `<div style="font-size: 11px; color: var(--text-tertiary); margin-top: 4px;">Ends: ${predEnd}</div>` : ''}
                            </div>

                            <!-- Arrow -->
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
                                <div style="font-size: 20px; color: #6366f1;">â†’</div>
                                <div style="font-size: 10px; color: var(--text-tertiary); font-weight: 600;">${currentType}</div>
                            </div>

                            <!-- Successor -->
                            <div style="flex: 1; background: var(--bg-secondary); border-radius: 8px; padding: 12px; border-left: 3px solid #3b82f6;">
                                <div style="font-size: 10px; color: #3b82f6; font-weight: 600; text-transform: uppercase; margin-bottom: 4px;">
                                    Successor
                                </div>
                                <div style="font-size: 13px; color: var(--text-primary); font-weight: 500; line-height: 1.3; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${succName}">
                                    ${succName.length > 25 ? succName.substring(0, 25) + '...' : succName}
                                </div>
                                ${succStart ? `<div style="font-size: 11px; color: var(--text-tertiary); margin-top: 4px;">Starts: ${succStart}</div>` : ''}
                            </div>
                        </div>
                    </div>

                    <!-- Dependency Type -->
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-primary); font-size: 13px;">
                            Dependency Type
                        </label>
                        <select id="edit-dep-type" onchange="updateDepTypeDescription()" style="width: 100%; padding: 12px 14px; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; background: var(--bg-secondary); color: #ffffff; font-size: 14px; font-weight: 500; cursor: pointer; appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2212%22 height=%2212%22 viewBox=%220 0 12 12%22%3E%3Cpath fill=%22%23ffffff%22 d=%22M2 4l4 4 4-4%22/%3E%3C/svg%3E'); background-repeat: no-repeat; background-position: right 12px center;">
                            ${Object.entries(DEPENDENCY_TYPES).map(([code, info]) => `
                                <option value="${code}" ${code === currentType ? 'selected' : ''} style="background: #1e2128; color: #ffffff; padding: 8px;">
                                    ${info.icon} ${info.name} (${code})
                                </option>
                            `).join('')}
                        </select>
                        <div id="dep-type-description" style="font-size: 12px; color: var(--text-secondary); margin-top: 8px; padding: 10px 12px; background: var(--bg-tertiary); border-radius: 6px; border-left: 2px solid #6366f1;">
                            ${typeDescriptions[currentType] || typeDescriptions['FS']}
                        </div>
                    </div>

                    <!-- Lag -->
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-primary); font-size: 13px;">
                            Lag Time
                        </label>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="number" id="edit-dep-lag" value="${currentLag}"
                                style="flex: 1; padding: 12px 14px; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; background: var(--bg-secondary); color: #ffffff; font-size: 14px; font-weight: 500; box-sizing: border-box;">
                            <span style="color: var(--text-secondary); font-size: 14px; font-weight: 500;">days</span>
                        </div>
                        <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 6px; display: flex; gap: 16px;">
                            <span>ğŸ“… <strong>0</strong> = immediate</span>
                            <span>â³ <strong>+N</strong> = wait N days</span>
                            <span>âš¡ <strong>-N</strong> = overlap N days</span>
                        </div>
                    </div>

                    <!-- Actions -->
                    <div style="display: flex; gap: 10px;">
                        <button onclick="saveDependencyEdit('${successorId}', '${predecessorId}')"
                            style="flex: 1; padding: 12px 16px; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; transition: transform 0.1s, box-shadow 0.1s;"
                            onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(34, 197, 94, 0.3)'"
                            onmouseout="this.style.transform=''; this.style.boxShadow=''">
                            ğŸ’¾ Save
                        </button>
                        <button onclick="deleteDependency('${successorId}', '${predecessorId}')"
                            style="flex: 1; padding: 12px 16px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; transition: transform 0.1s, box-shadow 0.1s;"
                            onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(239, 68, 68, 0.3)'"
                            onmouseout="this.style.transform=''; this.style.boxShadow=''">
                            ğŸ—‘ï¸ Delete
                        </button>
                        <button onclick="document.getElementById('modal').style.display='none'"
                            style="padding: 12px 20px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 14px;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;

            // Add description update function
            window.updateDepTypeDescription = function() {
                const select = document.getElementById('edit-dep-type');
                const descDiv = document.getElementById('dep-type-description');
                const descriptions = {
                    'FS': 'Successor starts after predecessor finishes',
                    'FF': 'Both tasks must finish at the same time',
                    'SS': 'Both tasks must start at the same time',
                    'SF': 'Predecessor starts after successor finishes'
                };
                if (descDiv && select) {
                    descDiv.textContent = descriptions[select.value] || descriptions['FS'];
                }
            };

            modal.style.display = 'flex';
        }

        // BUILD 448: Save edited dependency
        function saveDependencyEdit(successorId, predecessorId) {
            const node = getNodeById(successorId);
            if (!node) {
                showToast('Node not found', 'error');
                return;
            }

            const newType = document.getElementById('edit-dep-type').value;
            const newLag = parseInt(document.getElementById('edit-dep-lag').value) || 0;

            // Save undo state
            saveState(`Edit dependency ${predecessorId} â†’ ${successorId}`);

            // Find and update the dependency
            if (!node.dependencies) node.dependencies = [];

            // Find existing dependency (could be string or object)
            const depIndex = node.dependencies.findIndex(dep => {
                if (typeof dep === 'string') return dep === predecessorId;
                return dep.predecessorId === predecessorId || dep.targetId === predecessorId || dep.id === predecessorId;
            });

            if (depIndex >= 0) {
                // Update to new format with type and lag
                node.dependencies[depIndex] = {
                    predecessorId: predecessorId,
                    type: newType,
                    lag: newLag
                };
            }

            document.getElementById('modal').style.display = 'none';
            renderCanvas();
            showToast(`Dependency updated (${newType}${newLag !== 0 ? ', ' + newLag + 'd lag' : ''})`, 'success');
        }

        // BUILD 448: Delete dependency with confirmation
        function deleteDependency(successorId, predecessorId) {
            const node = getNodeById(successorId);
            if (!node) {
                showToast('Node not found', 'error');
                return;
            }

            // Confirm deletion
            if (!confirm('Delete this dependency?')) {
                return;
            }

            // Save undo state
            saveState(`Delete dependency ${predecessorId} â†’ ${successorId}`);

            // Remove the dependency
            if (node.dependencies) {
                node.dependencies = node.dependencies.filter(dep => {
                    if (typeof dep === 'string') return dep !== predecessorId;
                    return dep.predecessorId !== predecessorId && dep.targetId !== predecessorId && dep.id !== predecessorId;
                });
            }

            document.getElementById('modal').style.display = 'none';
            renderCanvas();
            showToast('Dependency deleted', 'success');
        }

        // Expose for modal buttons
        window.showDependencyEditModal = showDependencyEditModal;
        window.saveDependencyEdit = saveDependencyEdit;
        window.deleteDependency = deleteDependency;

        // BUILD 446: Draw dependency type badge at link midpoint
        // BUILD 448: Made interactive with click to edit/delete
        // BUILD 449: Critical path styling
        function drawDependencyBadge(x1, y1, x2, y2, dep, successorId, predecessorId, isCritical = false) {
            const svg = document.getElementById('canvas-connections');
            const midX = (x1 + x2) / 2 + SVG_OFFSET;
            const midY = (y1 + y2) / 2 + SVG_OFFSET;

            const typeInfo = DEPENDENCY_TYPES[dep.type] || DEPENDENCY_TYPES.FS;
            let label = typeInfo.icon;
            if (dep.lag !== 0) {
                label += (dep.lag > 0 ? '+' : '') + dep.lag + 'd';
            }

            // Critical path styling
            const strokeColor = isCritical ? '#ff0000' : '#ff6b6b';
            const fillColor = isCritical ? 'rgba(255, 0, 0, 0.15)' : 'rgba(30, 30, 40, 0.9)';
            const hoverFill = isCritical ? 'rgba(255, 0, 0, 0.25)' : 'rgba(50, 50, 60, 0.95)';

            // Create a group for the badge (for single click handler)
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'dependency-badge' + (isCritical ? ' critical-path' : ''));
            group.style.cursor = 'pointer';

            // Store data for edit modal
            group.dataset.successorId = successorId;
            group.dataset.predecessorId = predecessorId;
            group.dataset.type = dep.type || 'FS';
            group.dataset.lag = dep.lag || 0;

            // Background pill
            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bg.setAttribute('x', midX - 16);
            bg.setAttribute('y', midY - 10);
            bg.setAttribute('width', 32);
            bg.setAttribute('height', 20);
            bg.setAttribute('rx', 10);
            bg.setAttribute('fill', fillColor);
            bg.setAttribute('stroke', strokeColor);
            bg.setAttribute('stroke-width', isCritical ? '2' : '1');
            bg.setAttribute('class', 'badge-bg');
            group.appendChild(bg);

            // Text label
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', midX);
            text.setAttribute('y', midY + 4);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('fill', strokeColor);
            text.setAttribute('font-size', '11');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('pointer-events', 'none'); // Let clicks pass through to group
            text.textContent = label;
            group.appendChild(text);

            // Click handler to open edit modal
            group.addEventListener('click', (e) => {
                e.stopPropagation();
                showDependencyEditModal(successorId, predecessorId, dep.type || 'FS', dep.lag || 0);
            });

            // Hover effect
            group.addEventListener('mouseenter', () => {
                bg.setAttribute('stroke-width', isCritical ? '3' : '2');
                bg.setAttribute('fill', hoverFill);
            });
            group.addEventListener('mouseleave', () => {
                bg.setAttribute('stroke-width', isCritical ? '2' : '1');
                bg.setAttribute('fill', fillColor);
            });

            svg.appendChild(group);
        }

        // BUILD 445: Enhanced connection drawing with link types
        function drawConnection(x1, y1, x2, y2, color, style = 'solid', linkType = null) {
            const svg = document.getElementById('canvas-connections');

            // Adjust coordinates for SVG offset
            x1 += SVG_OFFSET;
            y1 += SVG_OFFSET;
            x2 += SVG_OFFSET;
            y2 += SVG_OFFSET;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let d;

            // Determine link type config
            const config = linkType ? LINK_TYPES[linkType] : null;
            const pathStyle = config?.style || 'bezier';

            if (pathStyle === 'orthogonal') {
                // Orthogonal path (right-angle turns) for parent-child
                d = calculateOrthogonalPath(x1, y1, x2, y2);
            } else {
                // Bezier curve for dependencies/hyperedges
                d = calculateBezierPath(x1, y1, x2, y2);
            }

            path.setAttribute('d', d);
            path.setAttribute('stroke', config?.color || color);
            path.setAttribute('stroke-width', config?.width || 2);
            path.setAttribute('fill', 'none');
            path.setAttribute('opacity', config?.opacity || 1);

            // Apply dash pattern
            if (config?.dashPattern) {
                path.setAttribute('stroke-dasharray', config.dashPattern.join(','));
                if (config.animated) {
                    path.classList.add('animated-link');
                }
            } else if (style === 'dashed') {
                path.setAttribute('stroke-dasharray', '5,5');
            }

            // Add arrow marker
            const markerStyle = style === 'dashed' ? 'dashed' : 'solid';
            if (config?.arrow !== false) {
                path.setAttribute('marker-end', `url(#arrowhead-${markerStyle})`);
            }

            svg.appendChild(path);
        }

        // Calculate orthogonal (right-angle) path
        function calculateOrthogonalPath(x1, y1, x2, y2) {
            // Determine direction: horizontal first or vertical first
            const dx = x2 - x1;
            const dy = y2 - y1;

            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal dominant - go right then down/up
                const midX = x1 + dx / 2;
                return `M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x2} ${y2}`;
            } else {
                // Vertical dominant - go down then right/left
                const midY = y1 + dy / 2;
                return `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;
            }
        }

        // Calculate smooth bezier path
        function calculateBezierPath(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const curvature = 0.3;

            // Control points for smooth S-curve
            const cp1x = x1 + dx * curvature;
            const cp1y = y1 + dy * 0.1;
            const cp2x = x2 - dx * curvature;
            const cp2y = y2 - dy * 0.1;

            return `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
        }

        // Animation loop for flowing dashes
        function startLinkAnimation() {
            if (linkAnimationFrame) return; // Already running

            function animate() {
                linkAnimationOffset = (linkAnimationOffset + 0.5) % 20;

                // Update all animated links
                const animatedLinks = document.querySelectorAll('.animated-link');
                animatedLinks.forEach(link => {
                    link.style.strokeDashoffset = -linkAnimationOffset;
                });

                linkAnimationFrame = requestAnimationFrame(animate);
            }

            linkAnimationFrame = requestAnimationFrame(animate);
        }

        function stopLinkAnimation() {
            if (linkAnimationFrame) {
                cancelAnimationFrame(linkAnimationFrame);
                linkAnimationFrame = null;
            }
        }

        // Initialize arrow markers for SVG
        function initializeArrowMarkers() {
            const svg = document.getElementById('canvas-connections');

            // Define arrow markers
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Solid arrow (for parent-child)
            const solidMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            solidMarker.setAttribute('id', 'arrowhead-solid');
            solidMarker.setAttribute('markerWidth', '10');
            solidMarker.setAttribute('markerHeight', '10');
            solidMarker.setAttribute('refX', '9');
            solidMarker.setAttribute('refY', '3');
            solidMarker.setAttribute('orient', 'auto');
            const solidPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            solidPath.setAttribute('points', '0 0, 10 3, 0 6');
            solidPath.setAttribute('fill', 'rgba(99, 102, 241, 0.5)');
            solidMarker.appendChild(solidPath);

            // Dashed arrow (for dependencies)
            const dashedMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            dashedMarker.setAttribute('id', 'arrowhead-dashed');
            dashedMarker.setAttribute('markerWidth', '10');
            dashedMarker.setAttribute('markerHeight', '10');
            dashedMarker.setAttribute('refX', '9');
            dashedMarker.setAttribute('refY', '3');
            dashedMarker.setAttribute('orient', 'auto');
            const dashedPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            dashedPath.setAttribute('points', '0 0, 10 3, 0 6');
            dashedPath.setAttribute('fill', 'rgba(239, 68, 68, 0.4)');
            dashedMarker.appendChild(dashedPath);

            defs.appendChild(solidMarker);
            defs.appendChild(dashedMarker);
            svg.appendChild(defs);
        }

        /**
         * Show dialog to create a hyperedge from selected nodes
         */
        function showHyperedgeDialog() {
            // Remove any existing dialog
            const existingDialog = document.getElementById('hyperedge-dialog');
            if (existingDialog) existingDialog.remove();

            // Create modal dialog
            const dialog = document.createElement('div');
            dialog.id = 'hyperedge-dialog';
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--card-bg);
                border: 2px solid var(--border);
                border-radius: 12px;
                padding: 24px;
                z-index: 10001;
                box-shadow: 0 12px 48px rgba(0,0,0,0.8);
                min-width: 400px;
                max-width: 500px;
            `;

            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: var(--text-primary);">Create Hyperedge</h3>
                <p style="color: var(--text-secondary); font-size: 14px;">
                    Creating hyperedge with ${selectedNodes.length} selected nodes
                </p>

                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-primary); font-weight: 600;">
                        Hyperedge Type:
                    </label>
                    <select id="hyperedge-type" style="
                        width: 100%;
                        padding: 10px;
                        background: var(--input-bg);
                        border: 1px solid var(--border);
                        border-radius: 6px;
                        color: var(--text-primary);
                        font-size: 14px;
                    ">
                        <option value="montage">ğŸ¬ Montage (Film)</option>
                        <option value="argument">ğŸ—£ï¸ Argument (Philosophy)</option>
                        <option value="theme">ğŸ¯ Theme (Roadmap/Product)</option>
                        <option value="dependency-cluster">ğŸ“¦ Dependency Cluster</option>
                        <option value="location">ğŸ“ Location Group (Film)</option>
                        <option value="character">ğŸ‘¥ Character Arc (Film)</option>
                        <option value="custom">âœï¸ Custom</option>
                    </select>
                </div>

                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-primary); font-weight: 600;">
                        Label:
                    </label>
                    <input type="text" id="hyperedge-label" placeholder="e.g., 'Training Montage', 'Socratic Refutation'" style="
                        width: 100%;
                        padding: 10px;
                        background: var(--input-bg);
                        border: 1px solid var(--border);
                        border-radius: 6px;
                        color: var(--text-primary);
                        font-size: 14px;
                    ">
                </div>

                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button id="hyperedge-create-btn" style="
                        flex: 1;
                        padding: 12px 24px;
                        background: var(--treeplex-primary);
                        border: none;
                        border-radius: 6px;
                        color: white;
                        font-weight: 600;
                        cursor: pointer;
                        font-size: 14px;
                    ">Create Hyperedge</button>
                    <button id="hyperedge-cancel-btn" style="
                        flex: 1;
                        padding: 12px 24px;
                        background: var(--input-bg);
                        border: 1px solid var(--border);
                        border-radius: 6px;
                        color: var(--text-primary);
                        font-weight: 600;
                        cursor: pointer;
                        font-size: 14px;
                    ">Cancel</button>
                </div>
            `;

            // Add backdrop
            const backdrop = document.createElement('div');
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
            `;
            backdrop.id = 'hyperedge-backdrop';

            document.body.appendChild(backdrop);
            document.body.appendChild(dialog);

            // Focus label input
            const labelInput = document.getElementById('hyperedge-label');
            labelInput.focus();

            // Handle create button
            const createBtn = document.getElementById('hyperedge-create-btn');
            createBtn.addEventListener('click', () => {
                const type = document.getElementById('hyperedge-type').value;
                const label = labelInput.value.trim();

                if (!label) {
                    alert('Please enter a label for the hyperedge');
                    return;
                }

                // Get node IDs
                const nodeIds = selectedNodes.map(n => n.id);

                // Create hyperedge
                const hyperedge = addHyperedge(type, label, nodeIds);

                if (hyperedge) {
                    console.log('âœ… Hyperedge created:', hyperedge);

                    // Clear selection
                    selectedNodes = [];
                    document.querySelectorAll('.canvas-node').forEach(n => n.classList.remove('selected'));
                    updateSelectionCounter();

                    // Re-render canvas to show the new hyperedge
                    renderCanvas();

                    // Close dialog
                    dialog.remove();
                    backdrop.remove();
                } else {
                    alert('Failed to create hyperedge');
                }
            });

            // Handle cancel button
            const cancelBtn = document.getElementById('hyperedge-cancel-btn');
            cancelBtn.addEventListener('click', () => {
                dialog.remove();
                backdrop.remove();
            });

            // Close on backdrop click
            backdrop.addEventListener('click', () => {
                dialog.remove();
                backdrop.remove();
            });

            // Close on Escape
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    dialog.remove();
                    backdrop.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }

        function showCanvasContextMenu(x, y, item) {
            console.log('Showing canvas context menu for:', item.name);

            // Remove any existing context menu
            const existing = document.getElementById('canvas-context-menu');
            if (existing) existing.remove();

            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'canvas-context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                background: var(--card-bg);
                border: 2px solid var(--border);
                border-radius: 8px;
                padding: 8px;
                z-index: 10000;
                box-shadow: 0 8px 24px rgba(0,0,0,0.6);
                min-width: 200px;
            `;

            const menuItems = [
                { label: 'âœï¸ Edit Details', action: () => {
                    console.log('Edit Details clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's native handleEdit function
                    if (typeof handleEdit === 'function') {
                        console.log('Calling TreeListy handleEdit function');
                        handleEdit();
                    } else {
                        console.error('handleEdit function not found!');
                    }
                }},
                { label: 'â• Add Subtask', action: () => {
                    console.log('Add Subtask clicked for:', item.name);
                    activeNode = item;

                    if (!item.subItems) item.subItems = [];
                    const newSubtask = {
                        id: 'subtask-' + Date.now(),
                        name: 'New Subtask',
                        type: 'subtask',
                        description: '',
                        pmStatus: 'To Do',
                        pmProgress: 0,
                        pmRAGStatus: 'Amber',
                        pmPriority: 'Medium',
                        icon: 'ğŸ“‹',
                        itemType: 'Feature'  // Add itemType to match pattern
                    };
                    item.subItems.push(newSubtask);

                    // Set the new subtask as active and open edit
                    activeNode = newSubtask;

                    // Save state for undo before opening edit
                    if (typeof saveState === 'function') {
                        saveState('Add subtask');
                    }

                    if (typeof handleEdit === 'function') {
                        console.log('Opening edit for new subtask');
                        handleEdit();

                        // Re-render canvas AFTER modal closes (when user saves)
                        // Listen for modal close event
                        const modal = document.getElementById('edit-modal');
                        const renderOnClose = () => {
                            if (modal.style.display === 'none') {
                                console.log('Edit modal closed, re-rendering canvas');
                                renderCanvas();
                                modal.removeEventListener('DOMSubtreeModified', renderOnClose);
                            }
                        };

                        // Watch for modal close
                        setTimeout(() => {
                            const observer = new MutationObserver((mutations) => {
                                mutations.forEach((mutation) => {
                                    if (mutation.attributeName === 'style') {
                                        if (modal.style.display === 'none') {
                                            console.log('Edit modal closed, re-rendering canvas');
                                            renderCanvas();
                                            observer.disconnect();
                                        }
                                    }
                                });
                            });
                            observer.observe(modal, { attributes: true });
                        }, 100);
                    }
                }},
                { label: 'ğŸ” Quick Insight', action: () => {
                    console.log('Quick Insight clicked for:', item.name);
                    activeNode = item;
                    handleAI();
                }},
                { label: 'ğŸ“Š Show Info Panel', action: () => {
                    console.log('Show Info Panel clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's showInfo function
                    if (typeof showInfo === 'function') {
                        console.log('Calling TreeListy showInfo function');
                        showInfo(item);
                    } else {
                        console.error('showInfo function not found!');
                    }
                }},
                { label: 'ğŸ—‘ï¸ Delete Item', action: () => {
                    console.log('Delete clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's native handleDelete function
                    if (typeof handleDelete === 'function') {
                        console.log('Calling TreeListy handleDelete function');
                        handleDelete();
                        // Re-render canvas after deletion
                        renderCanvas();
                    } else {
                        console.error('handleDelete function not found!');
                    }
                }}
            ];

            // Add "Create Hyperedge" option if 2+ nodes are selected
            if (selectedNodes.length >= 2) {
                menuItems.push({
                    label: `ğŸ”— Create Hyperedge (${selectedNodes.length} nodes)`,
                    action: () => {
                        console.log('Create Hyperedge clicked');
                        showHyperedgeDialog();
                    }
                });
            }

            // Add "Analyze Selection" - Deep Dive feature (Structured Scholar)
            // Works for single node or multiple nodes
            const nodesToAnalyze = selectedNodes.length > 0 ? selectedNodes : [item];
            const analyzeLabel = nodesToAnalyze.length > 1
                ? `ğŸ“ Deep Dive (${nodesToAnalyze.length} nodes)`
                : 'ğŸ“ Deep Dive';

            menuItems.push({
                label: analyzeLabel,
                action: () => {
                    console.log('Deep Dive Analysis clicked for:', nodesToAnalyze.map(n => n.name));
                    handleAnalyzeSelection(nodesToAnalyze);
                }
            });

            // Add "Share for Collaboration" option (works for 1+ nodes)
            const shareNodes = selectedNodes.length > 0 ? selectedNodes : [item];
            const shareLabel = shareNodes.length > 1
                ? `ğŸ“¤ Share ${shareNodes.length} nodes for collaboration`
                : 'ğŸ“¤ Share for collaboration';

            menuItems.push({
                label: shareLabel,
                action: () => {
                    console.log('Share for collaboration clicked for:', shareNodes.map(n => n.name));
                    showShareBranchModal(shareNodes.map(n => n.id));
                }
            });

            // Add "Generate Image" option (Nano Banana / Imagen 4)
            const imageNodes = selectedNodes.length > 0 ? selectedNodes : [item];
            const imageLabel = imageNodes.length > 1
                ? `ğŸŒ Generate Image (${imageNodes.length} nodes)`
                : 'ğŸŒ Generate Image';

            menuItems.push({
                label: imageLabel,
                action: () => {
                    console.log('Generate Image clicked for:', imageNodes.map(n => n.name));
                    showImagenModal(imageNodes);
                }
            });

            menuItems.forEach(menuItem => {
                const btn = document.createElement('button');
                btn.textContent = menuItem.label;
                btn.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 10px 12px;
                    background: transparent;
                    border: none;
                    color: var(--text-primary);
                    text-align: left;
                    cursor: pointer;
                    border-radius: 4px;
                    font-size: 14px;
                    margin-bottom: 4px;
                `;
                btn.onmouseover = () => btn.style.background = 'var(--treeplex-primary)';
                btn.onmouseout = () => btn.style.background = 'transparent';
                btn.onclick = (e) => {
                    console.log('Context menu button clicked:', menuItem.label);
                    e.preventDefault();
                    e.stopPropagation();

                    // Execute action first
                    try {
                        menuItem.action();
                    } catch (error) {
                        console.error('Error executing menu action:', error);
                    }

                    // Remove menu after a tiny delay to ensure action completes
                    setTimeout(() => menu.remove(), 10);
                };
                menu.appendChild(btn);
            });

            document.body.appendChild(menu);

            // Close menu on click outside
            setTimeout(() => {
                const closeMenu = (e) => {
                    // Don't close if clicking inside the menu
                    if (menu.contains(e.target)) {
                        console.log('Click inside menu, not closing');
                        return;
                    }
                    console.log('Click outside menu, closing');
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                };
                document.addEventListener('click', closeMenu);
            }, 100);

            // Also close on Escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    menu.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }

        function renderCanvasNode(item, phase, parentItem = null, nestingLevel = 0) {
            const canvas = document.getElementById('canvas');
            const node = document.createElement('div');
            node.className = 'canvas-node';

            // Preserve selection state across re-renders
            if (selectedNodes && selectedNodes.some(n => n.id === item.id)) {
                node.classList.add('selected');
            }

            // Check if this node belongs to a hyperedge
            const hyperedge = getNodeHyperedge(item.id);
            const heColors = hyperedge ? getHyperedgeColor(hyperedge) : null;

            // Calculate hierarchical shadow based on nesting level
            // Level 0 (root items): High elevation (big shadow)
            // Level 1+ (subtasks): Lower elevation (smaller shadow)
            const shadowIntensity = Math.max(0, 5 - nestingLevel);  // 5, 4, 3, 2, 1, 0
            const shadowBlur = 8 + (shadowIntensity * 4);  // 8-28px blur
            const shadowSpread = shadowIntensity * 2;  // 0-10px spread
            const shadowOffset = 2 + (shadowIntensity * 2);  // 2-12px offset

            // Apply hyperedge glow if member, otherwise default shadow
            if (heColors) {
                // Hyperedge member: tinted glow effect
                node.style.boxShadow = `
                    0 ${shadowOffset}px ${shadowBlur}px rgba(0, 0, 0, 0.3),
                    0 0 20px ${heColors.glow},
                    inset 0 0 30px ${heColors.fill}
                `;
                node.style.border = `3px solid ${heColors.border}`;
                node.dataset.hyperedgeId = hyperedge.id;
            } else {
                node.style.boxShadow = `
                    0 ${shadowOffset}px ${shadowBlur}px rgba(0, 0, 0, 0.3),
                    0 ${shadowOffset / 2}px ${shadowBlur / 2}px rgba(99, 102, 241, ${0.1 + shadowIntensity * 0.05})
                `;

                // Add visual distinction for subtasks
                if (parentItem || item.type === 'subtask') {
                    node.style.border = '2px dashed rgba(99, 102, 241, 0.4)';
                    node.style.opacity = '0.95';
                } else {
                    // Root items get solid border with glow
                    node.style.border = '2px solid rgba(99, 102, 241, 0.3)';
                }
            }

            node.style.left = `${item.canvasX}px`;
            node.style.top = `${item.canvasY}px`;
            node.dataset.itemId = item.id;
            node.dataset.nestingLevel = nestingLevel;

            // Check if node has children (support both subItems and children)
            const childList = item.subItems || item.children || [];
            const hasChildren = childList.length > 0;

            // Dynamic tooltip based on whether node has children
            node.title = hasChildren
                ? 'Left-click: Expand/Collapse | Double-click: Edit | Right-click: Menu | Middle-click: Drag'
                : 'Left-click: Info | Double-click: Edit | Right-click: Menu | Middle-click: Drag';

            // Add collapse/expand indicator if node has children
            let expandIndicator = '';
            if (hasChildren) {
                const isExpanded = item.expanded !== false;
                const indicatorIcon = isExpanded ? 'â–¼' : 'â–¶';
                expandIndicator = `<div style="position: absolute; top: 8px; right: 8px; font-size: 12px; cursor: pointer; padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; user-select: none;" class="expand-indicator" data-item-id="${item.id}">${indicatorIcon} ${childList.length}</div>`;
            }

            // RAG status indicator
            let ragHtml = '';
            if (item.pmRAGStatus) {
                const ragColors = { Green: '#22C55E', Amber: '#F59E0B', Red: '#EF4444' };
                const ragColor = ragColors[item.pmRAGStatus];
                ragHtml = `<span style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: ${ragColor}; margin-left: 8px; box-shadow: 0 0 6px ${ragColor}80;"></span>`;
            }

            // Cost badge - only show if pattern supports cost AND cost > 0
            let costHtml = '';
            const patternSupportsCost = PATTERNS[currentPattern]?.fields?.cost;
            if (patternSupportsCost && item.cost && item.cost > 0) {
                const costStr = item.cost >= 1000000 ? `$${(item.cost/1000000).toFixed(1)}M` :
                               item.cost >= 1000 ? `$${(item.cost/1000).toFixed(0)}K` :
                               `$${item.cost}`;
                costHtml = `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; background: rgba(34, 197, 94, 0.2); color: #22C55E;">${costStr}</span>`;
            }

            // Type badge - BUILD 390: Enhanced visual cues for semantic types
            let typeHtml = '';
            let typeLeftBorder = '';
            let typeBackgroundTint = '';
            const semType = typeof getSemanticType === 'function' ? getSemanticType(item) : item.itemType;
            if (semType) {
                // BUILD 390: Expanded type color palette with icons
                const typeStyles = {
                    // Philosophy pattern - dialectical types
                    'critique': { color: '#EF4444', icon: 'âš”' },      // Red - attack
                    'response': { color: '#3B82F6', icon: 'â†©' },      // Blue - reply
                    'argument': { color: '#8B5CF6', icon: 'â—†' },      // Purple - main point
                    'counter': { color: '#F59E0B', icon: 'â‡„' },       // Amber - counter
                    'objection': { color: '#F97316', icon: 'âœ—' },     // Orange - objection
                    'defense': { color: '#22C55E', icon: 'ğŸ›¡' },      // Green - defense
                    'synthesis': { color: '#10B981', icon: 'âˆ´' },     // Teal - synthesis
                    'thesis': { color: '#3B82F6', icon: 'â†’' },        // Blue - thesis
                    'antithesis': { color: '#EF4444', icon: 'â†' },    // Red - antithesis
                    'premise': { color: '#A855F7', icon: 'âˆµ' },       // Violet - premise
                    'conclusion': { color: '#06B6D4', icon: 'âˆ' },    // Cyan - conclusion
                    'implicit-premise': { color: '#D946EF', icon: 'â‡' }, // Fuchsia - hidden
                    'distinction': { color: '#EC4899', icon: 'â‰ ' },   // Pink - distinction
                    'thought-experiment': { color: '#14B8A6', icon: 'ğŸ’­' }, // Teal - thought
                    // Generic/structural types
                    'risk-factor': { color: '#EF4444', icon: 'âš ' },   // Red - risk
                    'sub-node': { color: '#6B7280', icon: 'â†³' },      // Gray - sub
                    'supporting': { color: '#22C55E', icon: 'âœ“' },    // Green - support
                    // LifeTree pattern
                    'birth': { color: '#EC4899', icon: 'â˜…' },
                    'education': { color: '#3B82F6', icon: 'ğŸ“š' },
                    'career': { color: '#10B981', icon: 'ğŸ’¼' },
                    'relationship': { color: '#EC4899', icon: 'â¤' },
                    'milestone': { color: '#F59E0B', icon: 'ğŸ†' },
                    'loss': { color: '#6B7280', icon: 'â—‡' },
                    'achievement': { color: '#F59E0B', icon: 'â­' },
                    // Sales pattern
                    'lead': { color: '#3B82F6', icon: 'ğŸ¯' },
                    'opportunity': { color: '#F59E0B', icon: 'ğŸ’¡' },
                    'deal': { color: '#22C55E', icon: 'ğŸ¤' },
                    'closed': { color: '#10B981', icon: 'âœ…' },
                    'lost': { color: '#EF4444', icon: 'âŒ' }
                };
                const style = typeStyles[semType.toLowerCase()] || { color: 'var(--treeplex-primary)', icon: 'â€¢' };
                const badgeColor = style.color;

                // BUILD 390: Visual cues - left border stripe and background tint
                typeLeftBorder = `border-left: 4px solid ${badgeColor};`;
                typeBackgroundTint = `background: linear-gradient(135deg, ${badgeColor}08 0%, transparent 50%);`;

                // Type badge with icon
                typeHtml = `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; background: ${badgeColor}20; color: ${badgeColor};">${style.icon} ${semType}</span>`;

                // BUILD 390: Apply visual cues to node
                node.style.borderLeft = `4px solid ${badgeColor}`;
                node.style.background = `linear-gradient(135deg, ${badgeColor}08 0%, var(--card-bg, #1E1E2F) 50%)`;
            }

            // Progress indicator
            let progressHtml = '';
            if (item.pmProgress) {
                progressHtml = `<div style="margin-top: 8px; background: rgba(255,255,255,0.1); height: 4px; border-radius: 2px; overflow: hidden;">
                    <div style="background: var(--treeplex-primary); height: 100%; width: ${item.pmProgress}%;"></div>
                </div>`;
            }

            // Contributor badge for canvas
            let canvasContributorHtml = '';
            if (item.contributor) {
                canvasContributorHtml = `<span class="contributor-badge" title="Last edited by ${item.contributor}${item.contributorTimestamp ? ' on ' + new Date(item.contributorTimestamp).toLocaleDateString() : ''}">ğŸ‘¤ ${item.contributor}</span>`;
            }

            // Collab comments indicator for canvas
            let canvasCollabHtml = '';
            if (item.collabComments) {
                canvasCollabHtml = `<span class="collab-indicator" title="${item.collabComments.substring(0, 100)}${item.collabComments.length > 100 ? '...' : ''}">ğŸ’¬</span>`;
            }

            node.innerHTML = `
                ${expandIndicator}
                <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                    <div style="font-size: 24px;">${item.icon || 'ğŸ“¦'}</div>
                    <div style="flex: 1;">
                        <div style="font-size: 14px; font-weight: 600; margin-bottom: 4px;">
                            ${(item.name && item.name !== 'undefined') ? item.name : (item.title || 'âš ï¸ Unnamed')}${typeof getTypeIndicator === 'function' ? getTypeIndicator(item) : ''}${ragHtml}${canvasCollabHtml}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                            ${(item.description || 'No description').substring(0, 100)}${item.description?.length > 100 ? '...' : ''}
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    ${typeHtml}
                    ${costHtml}
                    ${item.pmOwnerEmail ? `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; background: rgba(255,255,255,0.1);">ğŸ‘¤ ${item.pmOwnerEmail.split('@')[0]}</span>` : ''}
                    ${canvasContributorHtml}
                </div>
                ${progressHtml}
            `;

            // Add expand/collapse handler - BUILD 444: With animation
            const expandBtn = node.querySelector('.expand-indicator');
            if (expandBtn) {
                expandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isExpanding = item.expanded === false;
                    console.log('Toggling expand for:', item.name, 'to:', isExpanding ? 'expanded' : 'collapsed');
                    animateCanvasExpandCollapse(item, isExpanding);
                });
            }

            // Left-click to expand/collapse if has children, otherwise show info panel
            // CTRL+CLICK to multi-select
            node.addEventListener('click', (e) => {
                console.log('Left-click detected on:', item.name);
                e.stopPropagation();

                // CTRL+CLICK or CMD+CLICK: Toggle selection (multi-select)
                if (e.ctrlKey || e.metaKey) {
                    console.log('Ctrl+Click detected - toggling selection');

                    // Check if already selected
                    const index = selectedNodes.indexOf(item);

                    if (index > -1) {
                        // Already selected - DESELECT
                        selectedNodes.splice(index, 1);
                        node.classList.remove('selected');
                        console.log(`Deselected: ${item.name}. Now ${selectedNodes.length} selected.`);
                    } else {
                        // Not selected - ADD TO SELECTION
                        selectedNodes.push(item);
                        node.classList.add('selected');
                        console.log(`Selected: ${item.name}. Now ${selectedNodes.length} selected.`);
                    }

                    // Set most recently clicked as activeNode
                    activeNode = item;

                    // Update selection counter
                    updateSelectionCounter();

                } else {
                    // NORMAL CLICK: Clear all selections and select only this node

                    // Clear all selections
                    selectedNodes = [];
                    document.querySelectorAll('.canvas-node').forEach(n => n.classList.remove('selected'));

                    // Select this node
                    activeNode = item;
                    selectedNodes = [item];
                    node.classList.add('selected');

                    // BUILD 510: Track selected node for dependency filtering
                    const prevSelected = selectedCanvasNodeId;
                    selectedCanvasNodeId = item.id;

                    // BUILD 567: Highlight bbox if this node has one (image analysis)
                    if (item._bbox && capexTree._imageAnalysis) {
                        // Clear previous bbox highlight
                        if (prevSelected) unhighlightBboxByNodeId(prevSelected);
                        // Highlight and pan to new bbox
                        panToBboxByNodeId(item.id);
                    }

                    // Update selection counter
                    updateSelectionCounter();

                    // Check if node has children (support both subItems and children)
                    const hasChildren = (item.subItems && item.subItems.length > 0) ||
                                      (item.children && item.children.length > 0);

                    if (hasChildren) {
                        // Toggle expand/collapse - BUILD 444: With animation
                        const isExpanding = item.expanded === false;
                        console.log('Toggling expand for:', item.name, 'to:', isExpanding ? 'expanded' : 'collapsed');
                        animateCanvasExpandCollapse(item, isExpanding);
                    }

                    // Always show info panel for selected node (regardless of children)
                    if (typeof showInfo === 'function') {
                        console.log('Calling TreeListy showInfo function');
                        showInfo(item);
                    } else {
                        console.error('showInfo function not found!');
                    }

                    // BUILD 510: Re-draw connections if selection-based filtering is on
                    if (showDepsForSelectedOnly && prevSelected !== selectedCanvasNodeId) {
                        drawConnections();
                    }
                }
            });

            // Double-click to edit (HIGHEST PRIORITY)
            node.addEventListener('dblclick', (e) => {
                console.log('Double-click detected on:', item.name);
                e.preventDefault();
                e.stopPropagation();

                // Cancel any drag that might have started
                isDraggingCanvasNode = false;
                draggedCanvasNode = null;
                node.classList.remove('dragging');

                // Set active node and call TreeListy's edit function
                activeNode = item;
                console.log('Opening edit dialog for:', item.name);

                if (typeof handleEdit === 'function') {
                    console.log('Calling TreeListy handleEdit function');
                    handleEdit();
                } else {
                    console.error('handleEdit function not found!');
                }
            });

            // Right-click context menu
            node.addEventListener('contextmenu', (e) => {
                console.log('Right-click detected on:', item.name);
                e.preventDefault();
                e.stopPropagation();

                // Cancel any drag
                isDraggingCanvasNode = false;
                draggedCanvasNode = null;
                node.classList.remove('dragging');

                activeNode = item;

                // Show simple inline context menu
                showCanvasContextMenu(e.pageX, e.pageY, item);
            });

            // Drag with MIDDLE MOUSE BUTTON (button 1) only - left button reserved for panning
            // BUILD 447: Shift+Left-click starts dependency creation
            node.addEventListener('mousedown', (e) => {
                const containerRect = document.getElementById('canvas-container').getBoundingClientRect();

                // BUILD 447: Shift+Left-click starts dependency creation
                if (e.button === 0 && e.shiftKey) {
                    e.preventDefault();
                    e.stopPropagation();

                    isCreatingDependency = true;
                    depSourceNode = item;
                    depDragEndX = item.canvasX + 160;  // Start from node center-right
                    depDragEndY = item.canvasY + 60;
                    depSnapTarget = null;

                    // Add visual indicator
                    node.classList.add('dep-source');
                    showToast('Drag to target node to create dependency', 'info');
                    return;
                }

                // Middle-click - drag group if node is selected, otherwise drag individual
                if (e.button === 1) {
                    e.preventDefault(); // Prevent browser's middle-click scroll
                    e.stopPropagation();

                    // Check if this node is part of a selection
                    if (selectedNodes.includes(item) && selectedNodes.length > 1) {
                        console.log('Middle-click drag group activated (', selectedNodes.length, 'nodes )');
                        isDraggingSelection = true;
                        const clickX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                        const clickY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                        selectionDragStart = { x: clickX, y: clickY };
                    } else {
                        // Individual node drag
                        console.log('Middle-click drag activated for:', item.name);
                        isDraggingCanvasNode = true;
                        draggedCanvasNode = item;
                        dragStartX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x - item.canvasX;
                        dragStartY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y - item.canvasY;
                        node.classList.add('dragging');
                    }
                }
                // Left-click (button 0) is reserved for panning
                // Right-click (button 2) is free for context menu
            });

            // BUILD 567: Hover interactions for bbox â†” node highlighting
            node.addEventListener('mouseenter', () => {
                if (item._bbox && capexTree._imageAnalysis) {
                    highlightBboxByNodeId(item.id);
                }
            });
            node.addEventListener('mouseleave', () => {
                if (item._bbox && capexTree._imageAnalysis) {
                    // Only unhighlight if not selected
                    if (selectedCanvasNodeId !== item.id) {
                        unhighlightBboxByNodeId(item.id);
                    }
                }
            });

            canvas.appendChild(node);
            canvasNodes.push({ element: node, data: item, phase: phase });
        }

        function updateCanvasTransform() {
            const canvas = document.getElementById('canvas');
            if (canvas) {
                canvas.style.transform = `translate(${canvasPan.x}px, ${canvasPan.y}px) scale(${canvasZoom})`;
            }
            updateZoomDisplay();
            // BUILD 435: Update minimap viewport on pan/zoom
            if (typeof updateMinimapViewport === 'function') updateMinimapViewport();
        }

        // BUILD 547: Center-focused zoom - keeps the center/cursor point stable during zoom
        function zoomCanvasAt(newZoom, focusX, focusY) {
            const container = document.getElementById('canvas-container');
            if (!container) return;

            // Clamp zoom
            newZoom = Math.max(0.1, Math.min(5, newZoom));

            // Convert screen focus point to world coordinates at old zoom
            const worldX = (focusX - canvasPan.x) / canvasZoom;
            const worldY = (focusY - canvasPan.y) / canvasZoom;

            // Update zoom
            canvasZoom = newZoom;

            // Adjust pan so the world point stays at the same screen position
            canvasPan.x = focusX - worldX * canvasZoom;
            canvasPan.y = focusY - worldY * canvasZoom;

            updateCanvasTransform();
        }

        // BUILD 547: Zoom toward viewport center (for +/- buttons and default)
        function zoomCanvasCenter(delta) {
            const container = document.getElementById('canvas-container');
            if (!container) return;

            const rect = container.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;

            const newZoom = canvasZoom * delta;
            zoomCanvasAt(newZoom, centerX, centerY);
        }

        function updateZoomDisplay() {
            const zoomLevel = document.getElementById('zoom-level');
            if (zoomLevel) {
                zoomLevel.textContent = Math.round(canvasZoom * 100) + '%';
            }
        }

        function updateSelectionCounter() {
            const counter = document.getElementById('selection-counter');
            const countSpan = document.getElementById('selection-count');

            if (counter && countSpan) {
                if (selectedNodes.length > 1) {
                    countSpan.textContent = selectedNodes.length;
                    counter.style.display = 'block';
                } else {
                    counter.style.display = 'none';
                }
            }
        }

        function resetView() {
            canvasPan = { x: 0, y: 0 };
            canvasZoom = 1;
            updateCanvasTransform();
        }

        function fitToView() {
            if (canvasNodes.length === 0) return;

            // Find bounding box of all nodes
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            canvasNodes.forEach(({ data }) => {
                minX = Math.min(minX, data.canvasX);
                minY = Math.min(minY, data.canvasY);
                maxX = Math.max(maxX, data.canvasX + 320);  // node width
                maxY = Math.max(maxY, data.canvasY + 120);  // node height
            });

            const container = document.getElementById('canvas-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const contentWidth = maxX - minX + 200;  // padding
            const contentHeight = maxY - minY + 200;

            const scaleX = containerWidth / contentWidth;
            const scaleY = containerHeight / contentHeight;
            canvasZoom = Math.min(scaleX, scaleY, 1);  // Don't zoom in beyond 100%

            // Center the content
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            canvasPan.x = containerWidth / 2 - centerX * canvasZoom;
            canvasPan.y = containerHeight / 2 - centerY * canvasZoom;

            updateCanvasTransform();
        }

        // =============================================================================
        // BUILD 435: CANVAS SEARCH (Ctrl+F)
        // =============================================================================

        let canvasSearchState = {
            isOpen: false,
            results: [],
            currentIndex: -1,
            query: ''
        };

        function openCanvasSearch() {
            if (viewMode !== 'canvas') return;

            const overlay = document.getElementById('canvas-search-overlay');
            const input = document.getElementById('canvas-search-input');

            overlay.style.display = 'block';
            canvasSearchState.isOpen = true;
            input.value = canvasSearchState.query; // Preserve last search
            input.focus();
            input.select();
            console.log('ğŸ” Canvas search opened');
        }

        function closeCanvasSearch() {
            const overlay = document.getElementById('canvas-search-overlay');
            overlay.style.display = 'none';
            canvasSearchState.isOpen = false;
            clearSearchHighlight();
            console.log('ğŸ” Canvas search closed');
        }

        function clearSearchHighlight() {
            document.querySelectorAll('.canvas-node.search-highlight').forEach(el => {
                el.classList.remove('search-highlight');
            });
        }

        function performCanvasSearch(query) {
            canvasSearchState.query = query;
            canvasSearchState.results = [];
            canvasSearchState.currentIndex = -1;

            const resultsContainer = document.getElementById('canvas-search-results');
            const countEl = document.getElementById('canvas-search-count');

            if (!query.trim()) {
                resultsContainer.innerHTML = '';
                countEl.textContent = '';
                clearSearchHighlight();
                return;
            }

            const lowerQuery = query.toLowerCase();

            // Search through canvasNodes (only nodes visible in Canvas View)
            canvasNodes.forEach(({ data, phase }) => {
                const nameMatch = (data.name || '').toLowerCase().includes(lowerQuery);
                const descMatch = (data.description || '').toLowerCase().includes(lowerQuery);
                const notesMatch = (data.notes || '').toLowerCase().includes(lowerQuery);

                if (nameMatch || descMatch || notesMatch) {
                    canvasSearchState.results.push({
                        node: data,
                        phase: phase,
                        matchType: nameMatch ? 'name' : (descMatch ? 'description' : 'notes')
                    });
                }
            });

            // Update count
            const count = canvasSearchState.results.length;
            countEl.textContent = count > 0 ? `${count} found` : 'No results';

            // Render results list
            resultsContainer.innerHTML = canvasSearchState.results.map((result, idx) => `
                <div class="canvas-search-result" data-index="${idx}" onclick="selectSearchResult(${idx})">
                    <span class="canvas-search-result-icon">${getSearchNodeIcon(result.node)}</span>
                    <span class="canvas-search-result-name">${escapeHtmlForSearch(result.node.name || 'Untitled')}</span>
                    <span class="canvas-search-result-phase">${escapeHtmlForSearch(result.phase?.name || '')}</span>
                </div>
            `).join('');

            // Auto-select first result
            if (count > 0) {
                selectSearchResult(0);
            }
        }

        function selectSearchResult(index) {
            if (index < 0 || index >= canvasSearchState.results.length) return;

            canvasSearchState.currentIndex = index;
            const result = canvasSearchState.results[index];

            // Update active state in results list
            document.querySelectorAll('.canvas-search-result').forEach((el, i) => {
                el.classList.toggle('active', i === index);
            });

            // Zoom to node
            zoomToCanvasNode(result.node);

            // Highlight the node
            highlightSearchResult(result.node);
        }

        function zoomToCanvasNode(node) {
            const container = document.getElementById('canvas-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            // Target zoom level (close enough to see detail)
            const targetZoom = Math.max(Math.min(canvasZoom * 1.2, 1.0), 0.6);

            // Calculate pan to center the node
            const nodeX = node.canvasX + 160; // Center of node (320px width / 2)
            const nodeY = node.canvasY + 60;  // Center of node (120px height / 2)

            // Animate to position
            animateCanvasTo({
                zoom: targetZoom,
                panX: containerWidth / 2 - nodeX * targetZoom,
                panY: containerHeight / 2 - nodeY * targetZoom
            });
        }

        // BUILD 444: Refactored to use animationManager for consistency + accessibility
        function animateCanvasTo({ zoom, panX, panY, duration = 300, easing = 'easeOutCubic', onComplete }) {
            animationManager.animate('viewport',
                { panX: canvasPan.x, panY: canvasPan.y, zoom: canvasZoom },
                { panX, panY, zoom },
                {
                    duration,
                    easing,
                    onUpdate: () => updateCanvasTransform(),
                    onComplete
                }
            );
        }

        function highlightSearchResult(node) {
            clearSearchHighlight();

            const nodeEl = canvasNodes.find(n => n.data.id === node.id)?.element;
            if (nodeEl) {
                nodeEl.classList.add('search-highlight');

                // Auto-remove highlight after 3 seconds
                setTimeout(() => {
                    nodeEl.classList.remove('search-highlight');
                }, 3000);
            }
        }

        function navigateSearchResults(direction) {
            const count = canvasSearchState.results.length;
            if (count === 0) return;

            let newIndex = canvasSearchState.currentIndex + direction;
            if (newIndex < 0) newIndex = count - 1;
            if (newIndex >= count) newIndex = 0;

            selectSearchResult(newIndex);

            // Scroll result into view
            const resultEl = document.querySelector(`.canvas-search-result[data-index="${newIndex}"]`);
            resultEl?.scrollIntoView({ block: 'nearest' });
        }

        function getSearchNodeIcon(node) {
            if (node.subItems?.length > 0 || node.children?.length > 0) return 'ğŸ“';
            if (node.pmStatus === 'complete') return 'âœ…';
            if (node.pmStatus === 'in-progress') return 'ğŸ”„';
            return 'ğŸ“„';
        }

        // Helper for escaping HTML in search results
        function escapeHtmlForSearch(text) {
            if (!text) return '';
            return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        function initCanvasSearch() {
            const input = document.getElementById('canvas-search-input');
            const prevBtn = document.getElementById('canvas-search-prev');
            const nextBtn = document.getElementById('canvas-search-next');
            const closeBtn = document.getElementById('canvas-search-close');

            if (!input) return;

            // Live search on input
            input.addEventListener('input', (e) => {
                performCanvasSearch(e.target.value);
            });

            // Keyboard navigation
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    navigateSearchResults(e.shiftKey ? -1 : 1);
                } else if (e.key === 'Escape') {
                    closeCanvasSearch();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    navigateSearchResults(1);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    navigateSearchResults(-1);
                }
            });

            // Button handlers
            prevBtn?.addEventListener('click', () => navigateSearchResults(-1));
            nextBtn?.addEventListener('click', () => navigateSearchResults(1));
            closeBtn?.addEventListener('click', closeCanvasSearch);

            console.log('ğŸ” Canvas search initialized');
        }

        // =============================================================================
        // BUILD 435: CANVAS MINIMAP
        // =============================================================================

        const minimapConfig = {
            width: 200,
            height: 150,
            padding: 10,
            nodeColor: 'rgba(99, 102, 241, 0.6)',
            selectedColor: 'rgba(234, 179, 8, 0.8)',
            connectionColor: 'rgba(99, 102, 241, 0.3)',
            backgroundColor: 'rgba(30, 30, 40, 0.8)'
        };

        let minimapScale = 1;
        let minimapBounds = { minX: 0, minY: 0, maxX: 1000, maxY: 1000 };

        // BUILD 436: Minimap viewport drag state
        let minimapDragging = false;
        let minimapDragStart = { x: 0, y: 0 };
        let minimapDragPanStart = { x: 0, y: 0 };

        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            if (!canvas || viewMode !== 'canvas') return;

            const ctx = canvas.getContext('2d');
            const { width, height, padding } = minimapConfig;

            // Clear canvas
            ctx.fillStyle = minimapConfig.backgroundColor;
            ctx.fillRect(0, 0, width, height);

            if (canvasNodes.length === 0) return;

            // Calculate bounds of all nodes
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            canvasNodes.forEach(({ data }) => {
                minX = Math.min(minX, data.canvasX || 0);
                minY = Math.min(minY, data.canvasY || 0);
                maxX = Math.max(maxX, (data.canvasX || 0) + 320);
                maxY = Math.max(maxY, (data.canvasY || 0) + 120);
            });

            // Add padding
            minX -= padding * 10;
            minY -= padding * 10;
            maxX += padding * 10;
            maxY += padding * 10;

            minimapBounds = { minX, minY, maxX, maxY };

            // Calculate scale to fit all nodes
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;
            const scaleX = (width - padding * 2) / contentWidth;
            const scaleY = (height - padding * 2) / contentHeight;
            minimapScale = Math.min(scaleX, scaleY);

            // Transform function
            const toMinimap = (x, y) => ({
                x: padding + (x - minX) * minimapScale,
                y: padding + (y - minY) * minimapScale
            });

            // Draw connections first (behind nodes)
            ctx.strokeStyle = minimapConfig.connectionColor;
            ctx.lineWidth = 1;
            canvasNodes.forEach(({ data }) => {
                if (data.dependencies?.length > 0) {
                    data.dependencies.forEach(dep => {
                        const depId = typeof dep === 'string' ? dep : (dep.predecessorId || dep.targetId);
                        const depNode = canvasNodes.find(n => n.data.id === depId);
                        if (depNode) {
                            const from = toMinimap((depNode.data.canvasX || 0) + 160, (depNode.data.canvasY || 0) + 60);
                            const to = toMinimap((data.canvasX || 0) + 160, (data.canvasY || 0) + 60);
                            ctx.beginPath();
                            ctx.moveTo(from.x, from.y);
                            ctx.lineTo(to.x, to.y);
                            ctx.stroke();
                        }
                    });
                }
            });

            // Draw nodes
            canvasNodes.forEach(({ data }) => {
                const pos = toMinimap(data.canvasX || 0, data.canvasY || 0);
                const nodeWidth = 320 * minimapScale;
                const nodeHeight = 120 * minimapScale;

                // Check if selected
                const isSelected = selectedNodes.some(n => n.id === data.id);
                ctx.fillStyle = isSelected ? minimapConfig.selectedColor : minimapConfig.nodeColor;

                ctx.fillRect(pos.x, pos.y, Math.max(nodeWidth, 4), Math.max(nodeHeight, 3));
            });

            // Update viewport indicator
            updateMinimapViewport();
        }

        function updateMinimapViewport() {
            const viewport = document.getElementById('minimap-viewport');
            const container = document.getElementById('canvas-container');
            if (!viewport || !container || viewMode !== 'canvas') return;

            const { minX, minY } = minimapBounds;
            const { padding } = minimapConfig;

            // Current visible area in canvas coordinates
            const visibleLeft = -canvasPan.x / canvasZoom;
            const visibleTop = -canvasPan.y / canvasZoom;
            const visibleWidth = container.clientWidth / canvasZoom;
            const visibleHeight = container.clientHeight / canvasZoom;

            // Convert to minimap coordinates
            const left = padding + (visibleLeft - minX) * minimapScale;
            const top = padding + (visibleTop - minY) * minimapScale;
            const width = visibleWidth * minimapScale;
            const height = visibleHeight * minimapScale;

            viewport.style.left = `${Math.max(0, left)}px`;
            viewport.style.top = `${Math.max(0, top)}px`;
            viewport.style.width = `${Math.min(width, 200)}px`;
            viewport.style.height = `${Math.min(height, 150)}px`;
        }

        function initMinimap() {
            const minimap = document.getElementById('canvas-minimap');
            if (!minimap) return;

            // Click to navigate (but not during/after drag)
            minimap.addEventListener('click', (e) => {
                // BUILD 436: Skip if click is on viewport (handled by drag) or just finished dragging
                if (e.target.id === 'minimap-viewport' || minimapDragging) return;

                const rect = minimap.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                // Convert minimap click to canvas coordinates
                const { minX, minY } = minimapBounds;
                const { padding } = minimapConfig;

                const canvasX = minX + (clickX - padding) / minimapScale;
                const canvasY = minY + (clickY - padding) / minimapScale;

                // Pan to center this point
                const container = document.getElementById('canvas-container');
                const centerX = container.clientWidth / 2;
                const centerY = container.clientHeight / 2;

                animateCanvasTo({
                    zoom: canvasZoom, // Keep current zoom
                    panX: centerX - canvasX * canvasZoom,
                    panY: centerY - canvasY * canvasZoom
                });
            });

            // BUILD 436: Viewport drag to pan
            const viewport = document.getElementById('minimap-viewport');
            if (viewport) {
                viewport.addEventListener('mousedown', (e) => {
                    e.stopPropagation(); // Don't trigger minimap click
                    e.preventDefault();
                    minimapDragging = true;
                    minimapDragStart = { x: e.clientX, y: e.clientY };
                    minimapDragPanStart = { x: canvasPan.x, y: canvasPan.y };
                    viewport.classList.add('dragging');
                    minimap.classList.add('dragging');
                });
            }

            // Global mousemove for viewport drag
            document.addEventListener('mousemove', (e) => {
                if (!minimapDragging) return;

                // Calculate delta in screen pixels
                const deltaX = e.clientX - minimapDragStart.x;
                const deltaY = e.clientY - minimapDragStart.y;

                // Convert minimap delta to canvas delta
                // Moving viewport right = view moves right = pan decreases
                const canvasDeltaX = deltaX / minimapScale;
                const canvasDeltaY = deltaY / minimapScale;

                // Apply pan (scaled by zoom)
                canvasPan.x = minimapDragPanStart.x - canvasDeltaX * canvasZoom;
                canvasPan.y = minimapDragPanStart.y - canvasDeltaY * canvasZoom;

                updateCanvasTransform();
            });

            // Global mouseup to end drag
            document.addEventListener('mouseup', () => {
                if (minimapDragging) {
                    minimapDragging = false;
                    const vp = document.getElementById('minimap-viewport');
                    const mm = document.getElementById('canvas-minimap');
                    if (vp) vp.classList.remove('dragging');
                    if (mm) mm.classList.remove('dragging');
                }
            });

            console.log('ğŸ—ºï¸ Canvas minimap initialized (with drag-to-pan)');
        }

        function snapToGrid(value) {
            if (!gridEnabled) return value;
            return Math.round(value / gridSize) * gridSize;
        }

        function clearSelection() {
            // Remove selected class from all nodes
            selectedNodes.forEach(nodeData => {
                const nodeEl = canvasNodes.find(n => n.data.id === nodeData.id)?.element;
                if (nodeEl) {
                    nodeEl.classList.remove('selected');
                }
            });
            selectedNodes = [];
            updateSelectionCounter();
        }

        function toggleGrid() {
            gridEnabled = !gridEnabled;
            const gridBtn = document.getElementById('grid-toggle');
            const gridSvg = document.getElementById('canvas-grid');

            if (gridBtn) {
                if (gridEnabled) {
                    gridBtn.style.background = 'rgba(99, 102, 241, 0.6)';
                    gridBtn.style.borderColor = 'rgba(99, 102, 241, 0.8)';
                    gridBtn.style.color = 'white';
                } else {
                    gridBtn.style.background = 'rgba(99, 102, 241, 0.1)';
                    gridBtn.style.borderColor = 'rgba(99, 102, 241, 0.3)';
                    gridBtn.style.color = 'var(--text-primary)';
                }
            }

            if (gridSvg) {
                gridSvg.style.opacity = gridEnabled ? '1' : '0';
            }

            console.log('Grid:', gridEnabled ? 'ON (visible + snapping)' : 'OFF');
        }

        // Auto-layout algorithms
        function applyAutoLayout(layoutType) {
            console.log('Applying layout:', layoutType);

            if (layoutType === 'hierarchical') {
                applyHierarchicalLayout();
            } else if (layoutType === 'timeline') {
                applyTimelineLayout();
            } else if (layoutType === 'force') {
                applyForceDirectedLayout();
            } else if (layoutType === 'radial') {
                applyRadialLayout();
            } else if (layoutType === 'grid') {
                applyGridLayout();
            }

            renderCanvas();
            fitToView();
        }

        function applyHierarchicalLayout() {
            let currentY = 100;
            const levelGap = 250;
            const nodeGap = 350;

            capexTree.children.forEach((phase, phaseIdx) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                let currentX = 200;

                phase.items?.forEach((item) => {
                    item.canvasX = currentX;
                    item.canvasY = currentY;

                    // Layout subtasks to the right and down
                    layoutSubtasksHierarchical(item, currentX + nodeGap, currentY, 1);

                    currentX += nodeGap;
                });

                currentY += levelGap;
            });
        }

        function layoutSubtasksHierarchical(item, startX, startY, level) {
            if (!item.subItems || item.subItems.length === 0) return;

            let currentY = startY;
            const verticalGap = 140;

            item.subItems.forEach((subtask, idx) => {
                subtask.canvasX = startX;
                subtask.canvasY = currentY;

                layoutSubtasksHierarchical(subtask, startX + 350, currentY, level + 1);

                currentY += verticalGap;
            });
        }

        function applyTimelineLayout() {
            let currentX = 200;
            const xGap = 400;
            let currentY = 100;

            capexTree.children.forEach((phase) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach((item) => {
                    item.canvasX = currentX;
                    item.canvasY = currentY;

                    // Layout subtasks vertically below
                    if (item.subItems) {
                        let subY = currentY + 150;
                        item.subItems.forEach(subtask => {
                            subtask.canvasX = currentX;
                            subtask.canvasY = subY;
                            subY += 140;
                        });
                    }

                    currentX += xGap;
                });
            });
        }

        function applyGridLayout() {
            const cols = 4;
            const nodeWidth = 350;
            const nodeHeight = 180;
            let index = 0;

            capexTree.children.forEach((phase) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach((item) => {
                    const col = index % cols;
                    const row = Math.floor(index / cols);

                    item.canvasX = 100 + col * nodeWidth;
                    item.canvasY = 100 + row * nodeHeight;

                    index++;

                    // Layout subtasks in continuation of grid
                    if (item.subItems) {
                        item.subItems.forEach(subtask => {
                            index++;
                            const col = index % cols;
                            const row = Math.floor(index / cols);
                            subtask.canvasX = 100 + col * nodeWidth;
                            subtask.canvasY = 100 + row * nodeHeight;
                        });
                    }
                });
            });
        }

        function applyRadialLayout() {
            const centerX = 600;
            const centerY = 400;
            const radius = 300;
            let totalItems = 0;

            // Count items (only from visible phases)
            capexTree.children.forEach(phase => {
                if (phase.showInCanvas !== false) {
                    totalItems += phase.items?.length || 0;
                }
            });

            let index = 0;

            capexTree.children.forEach((phase) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach((item) => {
                    const angle = (index / totalItems) * Math.PI * 2;
                    item.canvasX = centerX + Math.cos(angle) * radius;
                    item.canvasY = centerY + Math.sin(angle) * radius;

                    // Place subtasks further out
                    if (item.subItems) {
                        item.subItems.forEach((subtask, subIdx) => {
                            const subAngle = angle + (subIdx * 0.2);
                            subtask.canvasX = centerX + Math.cos(subAngle) * (radius + 200);
                            subtask.canvasY = centerY + Math.sin(subAngle) * (radius + 200);
                        });
                    }

                    index++;
                });
            });
        }

        // Barnes-Hut Quadtree for O(n log n) force approximation
        class QuadtreeNode {
            constructor(x, y, width, height, depth = 0) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.depth = depth;  // Track recursion depth
                this.mass = 0;
                this.centerX = 0;
                this.centerY = 0;
                this.children = [];
                this.node = null;  // Actual canvas node if leaf
                this.subdivided = false;
            }

            insert(node) {
                // Check if node is within bounds
                if (node.canvasX < this.x || node.canvasX > this.x + this.width ||
                    node.canvasY < this.y || node.canvasY > this.y + this.height) {
                    return false;
                }

                // If this is empty, place node here
                if (this.mass === 0) {
                    this.node = node;
                    this.mass = 1;
                    this.centerX = node.canvasX;
                    this.centerY = node.canvasY;
                    return true;
                }

                // PREVENT INFINITE RECURSION: Max depth or minimum size check
                const MAX_DEPTH = 15;
                const MIN_SIZE = 1;
                if (this.depth >= MAX_DEPTH || this.width < MIN_SIZE || this.height < MIN_SIZE) {
                    // Can't subdivide further - keep both nodes at this level
                    // Update center of mass to include both
                    const totalMass = this.mass + 1;
                    this.centerX = (this.centerX * this.mass + node.canvasX) / totalMass;
                    this.centerY = (this.centerY * this.mass + node.canvasY) / totalMass;
                    this.mass = totalMass;
                    return true;
                }

                // If this is a leaf, subdivide
                if (!this.subdivided) {
                    this.subdivide();
                }

                // Update center of mass
                const totalMass = this.mass + 1;
                this.centerX = (this.centerX * this.mass + node.canvasX) / totalMass;
                this.centerY = (this.centerY * this.mass + node.canvasY) / totalMass;
                this.mass = totalMass;

                // Insert into appropriate child
                for (let child of this.children) {
                    if (child.insert(node)) {
                        return true;
                    }
                }

                // SAFETY: If no child accepted it, keep it here (prevents infinite recursion)
                // This can happen with floating point precision issues or nodes exactly on boundaries
                return true;
            }

            subdivide() {
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;

                // Create 4 quadrants: NW, NE, SW, SE (pass depth + 1)
                this.children = [
                    new QuadtreeNode(this.x, this.y, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x + halfWidth, this.y, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x, this.y + halfHeight, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x + halfWidth, this.y + halfHeight, halfWidth, halfHeight, this.depth + 1)
                ];

                // Reinsert existing node
                if (this.node) {
                    for (let child of this.children) {
                        if (child.insert(this.node)) {
                            break;
                        }
                    }
                    this.node = null;
                }

                this.subdivided = true;
            }

            calculateForce(node, force, repulsion, theta = 0.5) {
                // Skip if this is the same node
                if (this.node === node) {
                    return;
                }

                const dx = this.centerX - node.canvasX;
                const dy = this.centerY - node.canvasY;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                // If this is a leaf or far enough, treat as single body
                if (!this.subdivided || (this.width / dist < theta)) {
                    const forceMag = repulsion * this.mass / (dist * dist);
                    force.x -= (dx / dist) * forceMag;
                    force.y -= (dy / dist) * forceMag;
                } else {
                    // Recurse into children
                    for (let child of this.children) {
                        if (child.mass > 0) {
                            child.calculateForce(node, force, repulsion, theta);
                        }
                    }
                }
            }
        }

        function buildQuadtree(nodes) {
            // Find bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.canvasX);
                minY = Math.min(minY, node.canvasY);
                maxX = Math.max(maxX, node.canvasX);
                maxY = Math.max(maxY, node.canvasY);
            });

            // Add padding
            const padding = 100;
            minX -= padding;
            minY -= padding;
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;

            // Build tree
            const root = new QuadtreeNode(minX, minY, width, height);
            nodes.forEach(node => root.insert(node));
            return root;
        }

        function applyForceDirectedLayout() {
            // Enhanced force-directed layout with Barnes-Hut, collision detection, and phase-aware forces
            const iterations = 500;  // Increased from 100 for better convergence
            const baseRepulsion = 8000;  // Stronger repulsion
            const baseAttraction = 0.02;  // Stronger attraction
            const nodeRadius = 120;  // Collision detection radius
            const phaseAttractionStrength = 0.008;  // Keep nodes near their phase
            const centerPull = 0.001;  // Weak pull toward center

            // Collect all nodes and track phase membership
            let allNodes = [];
            const phaseMap = new Map();  // Map node ID to phase

            // Recursive function to add node and all its descendants
            function addNodeAndDescendants(node, phase) {
                allNodes.push(node);
                phaseMap.set(node.id, phase);

                // Recursively add all subItems
                if (node.subItems) {
                    node.subItems.forEach(subtask => {
                        addNodeAndDescendants(subtask, phase);
                    });
                }

                // Also handle 'children' for filesystem pattern
                if (node.children) {
                    node.children.forEach(child => {
                        addNodeAndDescendants(child, phase);
                    });
                }
            }

            capexTree.children.forEach(phase => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach(item => {
                    addNodeAndDescendants(item, phase);
                });
            });

            // Calculate initial phase centers for phase-aware forces
            const phaseCenters = new Map();
            capexTree.children.forEach(phase => {
                const phaseNodes = allNodes.filter(n => phaseMap.get(n.id) === phase);
                if (phaseNodes.length > 0) {
                    const avgX = phaseNodes.reduce((sum, n) => sum + n.canvasX, 0) / phaseNodes.length;
                    const avgY = phaseNodes.reduce((sum, n) => sum + n.canvasY, 0) / phaseNodes.length;
                    phaseCenters.set(phase.id, { x: avgX, y: avgY });
                }
            });

            // Main simulation loop with progressive damping
            for (let iter = 0; iter < iterations; iter++) {
                const progress = iter / iterations;
                const damping = 0.95 - (progress * 0.45);  // Progressive cooling: 0.95 â†’ 0.5
                const tempRepulsion = baseRepulsion * (1 - progress * 0.3);  // Reduce repulsion over time

                // Build quadtree for Barnes-Hut approximation (O(n log n) instead of O(nÂ²))
                const quadtree = buildQuadtree(allNodes);

                // Apply repulsion using Barnes-Hut approximation
                allNodes.forEach(node => {
                    const force = { x: 0, y: 0 };
                    quadtree.calculateForce(node, force, tempRepulsion);
                    node.canvasX += force.x * damping;
                    node.canvasY += force.y * damping;
                });

                // Collision detection: prevent overlaps (still O(nÂ²) but necessary for precision)
                for (let i = 0; i < allNodes.length; i++) {
                    for (let j = i + 1; j < allNodes.length; j++) {
                        const dx = allNodes[j].canvasX - allNodes[i].canvasX;
                        const dy = allNodes[j].canvasY - allNodes[i].canvasY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        const minDist = nodeRadius * 2;
                        if (dist < minDist && dist > 0) {
                            // Push nodes apart to prevent overlap
                            const pushForce = (minDist - dist) / dist * 0.5;
                            const pushX = dx * pushForce;
                            const pushY = dy * pushForce;

                            allNodes[i].canvasX -= pushX;
                            allNodes[i].canvasY -= pushY;
                            allNodes[j].canvasX += pushX;
                            allNodes[j].canvasY += pushY;
                        }
                    }
                }

                // Apply attraction for parent-child relationships (recursive)
                function applyParentChildAttraction(parent, damping) {
                    const childList = parent.subItems || parent.children || [];
                    childList.forEach(child => {
                        const dx = child.canvasX - parent.canvasX;
                        const dy = child.canvasY - parent.canvasY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 0) {
                            // Spring-like attraction
                            const force = baseAttraction * dist;
                            const fx = (dx / dist) * force;
                            const fy = (dy / dist) * force;

                            parent.canvasX += fx * damping;
                            parent.canvasY += fy * damping;
                            child.canvasX -= fx * damping;
                            child.canvasY -= fy * damping;
                        }

                        // Recursively apply to this child's children
                        applyParentChildAttraction(child, damping);
                    });
                }

                capexTree.children.forEach(phase => {
                    // Skip hidden phases
                    if (phase.showInCanvas === false) {
                        return;
                    }

                    phase.items?.forEach(item => {
                        applyParentChildAttraction(item, damping);
                    });
                });

                // Apply phase-aware forces (keep nodes grouped by phase)
                allNodes.forEach(node => {
                    const phase = phaseMap.get(node.id);
                    if (phase) {
                        const phaseCenter = phaseCenters.get(phase.id);
                        if (phaseCenter) {
                            const dx = phaseCenter.x - node.canvasX;
                            const dy = phaseCenter.y - node.canvasY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist > 0) {
                                // Gentle pull toward phase center (weaker over time)
                                const force = phaseAttractionStrength * dist * (1 - progress);
                                node.canvasX += (dx / dist) * force;
                                node.canvasY += (dy / dist) * force;
                            }
                        }
                    }
                });

                // Apply metadata-based clustering (if enabled)
                if (clusterByField) {
                    const clusterStrength = 0.015;  // Strength of clustering attraction

                    // Helper function to get comparable value for clustering
                    const getClusterValue = (node, field) => {
                        if (field === 'cost') {
                            // Group by cost ranges (0-10k, 10k-50k, 50k-200k, 200k+)
                            const cost = node.cost || 0;
                            if (cost < 10000) return 'low';
                            if (cost < 50000) return 'medium';
                            if (cost < 200000) return 'high';
                            return 'very-high';
                        } else if (field === 'modifiedDate') {
                            // Group by month
                            if (!node.modifiedDate) return 'unknown';
                            return node.modifiedDate.substring(0, 7); // YYYY-MM
                        } else {
                            // Direct field value (itemType, owner, pmRAGStatus, etc.)
                            return node[field] || 'unknown';
                        }
                    };

                    // Apply clustering forces between nodes with matching metadata
                    for (let i = 0; i < allNodes.length; i++) {
                        for (let j = i + 1; j < allNodes.length; j++) {
                            const valueA = getClusterValue(allNodes[i], clusterByField);
                            const valueB = getClusterValue(allNodes[j], clusterByField);

                            // If nodes share the same metadata value, attract them
                            if (valueA === valueB && valueA !== 'unknown') {
                                const dx = allNodes[j].canvasX - allNodes[i].canvasX;
                                const dy = allNodes[j].canvasY - allNodes[i].canvasY;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist > 0) {
                                    // Gentle attraction between similar nodes
                                    const force = clusterStrength * dist * (1 - progress * 0.5);
                                    const fx = (dx / dist) * force;
                                    const fy = (dy / dist) * force;

                                    allNodes[i].canvasX += fx;
                                    allNodes[i].canvasY += fy;
                                    allNodes[j].canvasX -= fx;
                                    allNodes[j].canvasY -= fy;
                                }
                            }
                        }
                    }
                }

                // Pull towards global center (very weak)
                allNodes.forEach(node => {
                    node.canvasX -= (node.canvasX - 600) * centerPull * damping;
                    node.canvasY -= (node.canvasY - 400) * centerPull * damping;
                });

                // Recalculate phase centers every 50 iterations for better clustering
                if (iter % 50 === 0) {
                    capexTree.children.forEach(phase => {
                        const phaseNodes = allNodes.filter(n => phaseMap.get(n.id) === phase);
                        if (phaseNodes.length > 0) {
                            const avgX = phaseNodes.reduce((sum, n) => sum + n.canvasX, 0) / phaseNodes.length;
                            const avgY = phaseNodes.reduce((sum, n) => sum + n.canvasY, 0) / phaseNodes.length;
                            phaseCenters.set(phase.id, { x: avgX, y: avgY });
                        }
                    });
                }
            }

            const clusterMsg = clusterByField ? ` with clustering by ${clusterByField}` : '';
            console.log(`Force-directed layout complete: ${iterations} iterations, ${allNodes.length} nodes${clusterMsg}`);
        }

        // Canvas container event listeners
        function initializeCanvasEvents() {
            const container = document.getElementById('canvas-container');

            container.addEventListener('mousedown', (e) => {
                const containerRect = container.getBoundingClientRect();

                // Middle mouse button - start selection
                if (e.button === 1 && (e.target === container || e.target.id === 'canvas')) {
                    e.preventDefault();
                    isSelecting = true;
                    const x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                    selectionStart = { x, y };
                    selectionEnd = { x, y };

                    // Clear previous selection
                    clearSelection();

                    // Create selection overlay
                    let selectionBox = document.getElementById('selection-box');
                    if (!selectionBox) {
                        selectionBox = document.createElement('div');
                        selectionBox.id = 'selection-box';
                        selectionBox.style.position = 'absolute';
                        selectionBox.style.border = '2px dashed var(--treeplex-primary)';
                        selectionBox.style.background = 'rgba(0, 166, 125, 0.1)';
                        selectionBox.style.pointerEvents = 'none';
                        selectionBox.style.zIndex = '9999';
                        document.getElementById('canvas').appendChild(selectionBox);
                    }
                    selectionBox.style.display = 'block';
                    return;
                }

                // Left mouse button on canvas background - pan
                // BUILD 330: Also allow Space+Left-drag for Mac trackpad users
                if (e.button === 0 && (e.target === container || e.target.id === 'canvas')) {
                    // Clear selection when clicking on empty space (unless holding modifier)
                    if (selectedNodes.length > 0 && !e.ctrlKey && !e.metaKey && !isSpacePressed) {
                        clearSelection();
                    }

                    // Start panning
                    isPanningCanvas = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    container.classList.add('grabbing');
                }

                // BUILD 330: Space+Left-drag also pans (Mac-friendly)
                if (e.button === 0 && isSpacePressed) {
                    e.preventDefault();
                    isPanningCanvas = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    container.classList.add('grabbing');
                }
            });

            container.addEventListener('mousemove', (e) => {
                const containerRect = container.getBoundingClientRect();

                // BUILD 447: Dependency creation drag
                if (isCreatingDependency && depSourceNode) {
                    depDragEndX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    depDragEndY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;

                    // Find nearest node to snap to
                    depSnapTarget = findNearestCanvasNode(depDragEndX, depDragEndY, 80);

                    // Don't snap to source node
                    if (depSnapTarget && depSnapTarget.id === depSourceNode.id) {
                        depSnapTarget = null;
                    }

                    // Highlight snap target
                    canvasNodes.forEach(n => n.element.classList.remove('dep-target', 'dep-invalid'));
                    if (depSnapTarget) {
                        const targetEl = canvasNodes.find(n => n.data.id === depSnapTarget.id)?.element;
                        if (targetEl) {
                            // Check if dependency would be valid
                            const isValid = !hasDependency(depSnapTarget, depSourceNode.id);
                            targetEl.classList.add(isValid ? 'dep-target' : 'dep-invalid');
                        }
                    }

                    // Draw temporary dependency line
                    drawTempDependencyLine();
                    return;
                }

                // Drawing selection box with middle mouse
                if (isSelecting) {
                    const x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                    selectionEnd = { x, y };

                    // Update selection box visual
                    const selectionBox = document.getElementById('selection-box');
                    if (selectionBox) {
                        const minX = Math.min(selectionStart.x, selectionEnd.x);
                        const minY = Math.min(selectionStart.y, selectionEnd.y);
                        const maxX = Math.max(selectionStart.x, selectionEnd.x);
                        const maxY = Math.max(selectionStart.y, selectionEnd.y);

                        // Convert canvas coordinates back to screen coordinates (reverse the zoom/pan transformation)
                        const screenMinX = (minX + canvasPan.x) * canvasZoom;
                        const screenMinY = (minY + canvasPan.y) * canvasZoom;
                        const screenMaxX = (maxX + canvasPan.x) * canvasZoom;
                        const screenMaxY = (maxY + canvasPan.y) * canvasZoom;

                        selectionBox.style.left = `${screenMinX}px`;
                        selectionBox.style.top = `${screenMinY}px`;
                        selectionBox.style.width = `${screenMaxX - screenMinX}px`;
                        selectionBox.style.height = `${screenMaxY - screenMinY}px`;
                    }
                    return;
                }

                // Dragging multiple selected nodes
                if (isDraggingSelection && selectedNodes.length > 0) {
                    const currentX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const currentY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;

                    const deltaX = currentX - selectionDragStart.x;
                    const deltaY = currentY - selectionDragStart.y;

                    // Move all selected nodes
                    selectedNodes.forEach(nodeData => {
                        nodeData.canvasX += deltaX;
                        nodeData.canvasY += deltaY;

                        const nodeEl = canvasNodes.find(n => n.data.id === nodeData.id)?.element;
                        if (nodeEl) {
                            nodeEl.style.left = `${nodeData.canvasX}px`;
                            nodeEl.style.top = `${nodeData.canvasY}px`;
                        }

                        // Move children of each selected node
                        function moveChildren(node, dx, dy) {
                            const childList = node.items || node.children || node.subItems || [];
                            childList.forEach(child => {
                                if (child.canvasX !== undefined && child.canvasY !== undefined) {
                                    child.canvasX += dx;
                                    child.canvasY += dy;

                                    const childEl = canvasNodes.find(n => n.data.id === child.id)?.element;
                                    if (childEl) {
                                        childEl.style.left = `${child.canvasX}px`;
                                        childEl.style.top = `${child.canvasY}px`;
                                    }

                                    moveChildren(child, dx, dy);
                                }
                            });
                        }
                        moveChildren(nodeData, deltaX, deltaY);
                    });

                    selectionDragStart = { x: currentX, y: currentY };
                    drawConnections();
                    return;
                }

                if (isPanningCanvas) {
                    const dx = (e.clientX - panStartX) / canvasZoom;
                    const dy = (e.clientY - panStartY) / canvasZoom;
                    canvasPan.x += dx;
                    canvasPan.y += dy;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    updateCanvasTransform();
                } else if (isDraggingCanvasNode && draggedCanvasNode) {
                    const containerRect = container.getBoundingClientRect();
                    let x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x - dragStartX;
                    let y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y - dragStartY;

                    // Apply grid snapping if enabled
                    x = snapToGrid(x);
                    y = snapToGrid(y);

                    // Calculate delta (how much the node moved)
                    const deltaX = x - draggedCanvasNode.canvasX;
                    const deltaY = y - draggedCanvasNode.canvasY;

                    // Update parent position
                    draggedCanvasNode.canvasX = x;
                    draggedCanvasNode.canvasY = y;

                    const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                    if (nodeEl) {
                        nodeEl.style.left = `${x}px`;
                        nodeEl.style.top = `${y}px`;
                    }

                    // Recursively move all children by the same delta
                    function moveChildren(node, dx, dy) {
                        const childList = node.items || node.children || node.subItems || [];
                        childList.forEach(child => {
                            if (child.canvasX !== undefined && child.canvasY !== undefined) {
                                child.canvasX += dx;
                                child.canvasY += dy;

                                // Update child DOM element
                                const childEl = canvasNodes.find(n => n.data.id === child.id)?.element;
                                if (childEl) {
                                    childEl.style.left = `${child.canvasX}px`;
                                    childEl.style.top = `${child.canvasY}px`;
                                }

                                // Recursively move grandchildren
                                moveChildren(child, dx, dy);
                            }
                        });
                    }

                    // Move all descendants
                    if (deltaX !== 0 || deltaY !== 0) {
                        moveChildren(draggedCanvasNode, deltaX, deltaY);
                    }

                    // Redraw connections while dragging
                    drawConnections();
                }
            });

            container.addEventListener('mouseup', (e) => {
                // BUILD 447: Complete dependency creation
                if (isCreatingDependency && depSourceNode) {
                    // Clean up visual state
                    canvasNodes.forEach(n => {
                        n.element.classList.remove('dep-source', 'dep-target', 'dep-invalid');
                    });
                    clearTempDependencyLine();

                    if (depSnapTarget && depSnapTarget.id !== depSourceNode.id) {
                        // Check if dependency already exists
                        if (hasDependency(depSnapTarget, depSourceNode.id)) {
                            showToast('Dependency already exists', 'warning');
                        } else {
                            // Show modal to confirm and set type/lag
                            showDependencyCreationModal(depSourceNode, depSnapTarget);
                        }
                    }

                    isCreatingDependency = false;
                    depSourceNode = null;
                    depSnapTarget = null;
                    return;
                }

                // Finalize selection
                if (isSelecting) {
                    isSelecting = false;

                    // Hide selection box
                    const selectionBox = document.getElementById('selection-box');
                    if (selectionBox) {
                        selectionBox.style.display = 'none';
                    }

                    // Calculate selection bounds
                    const minX = Math.min(selectionStart.x, selectionEnd.x);
                    const minY = Math.min(selectionStart.y, selectionEnd.y);
                    const maxX = Math.max(selectionStart.x, selectionEnd.x);
                    const maxY = Math.max(selectionStart.y, selectionEnd.y);

                    // Find nodes within selection
                    const containerRect = container.getBoundingClientRect();
                    canvasNodes.forEach(nodeObj => {
                        const node = nodeObj.data;
                        const nodeEl = nodeObj.element;

                        if (node.canvasX !== undefined && node.canvasY !== undefined) {
                            const rect = nodeEl.getBoundingClientRect();
                            const nodeX = (rect.left - containerRect.left) / canvasZoom - canvasPan.x;
                            const nodeY = (rect.top - containerRect.top) / canvasZoom - canvasPan.y;
                            const nodeW = rect.width / canvasZoom;
                            const nodeH = rect.height / canvasZoom;

                            // Check if node intersects with selection box
                            if (nodeX < maxX && nodeX + nodeW > minX &&
                                nodeY < maxY && nodeY + nodeH > minY) {
                                selectedNodes.push(node);
                                nodeEl.classList.add('selected');
                            }
                        }
                    });

                    console.log(`Selected ${selectedNodes.length} nodes`);
                    return;
                }

                // End dragging selection
                if (isDraggingSelection) {
                    isDraggingSelection = false;
                    return;
                }

                isPanningCanvas = false;
                container.classList.remove('grabbing');

                // Clean up dragging state
                if (isDraggingCanvasNode || draggedCanvasNode) {
                    if (draggedCanvasNode) {
                        const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                        if (nodeEl) {
                            nodeEl.classList.remove('dragging');
                        }
                    }
                    isDraggingCanvasNode = false;
                    draggedCanvasNode = null;
                }
            });

            // Also handle mouseleave to stop dragging when mouse leaves container
            container.addEventListener('mouseleave', () => {
                isPanningCanvas = false;
                container.classList.remove('grabbing');

                if (isDraggingCanvasNode || draggedCanvasNode) {
                    if (draggedCanvasNode) {
                        const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                        if (nodeEl) {
                            nodeEl.classList.remove('dragging');
                        }
                    }
                    isDraggingCanvasNode = false;
                    draggedCanvasNode = null;
                }
            });

            // BUILD 547: Wheel zoom toward cursor position
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = canvasZoom * delta;
                zoomCanvasAt(newZoom, mouseX, mouseY);
            }, { passive: false });

            // BUILD 491/547: Pinch-to-zoom for mobile Canvas View (with center focus)
            let canvasTouchState = { initialDistance: 0, initialZoom: 1, isPinching: false, lastTouchX: 0, lastTouchY: 0, pinchCenterX: 0, pinchCenterY: 0, initialPanX: 0, initialPanY: 0 };

            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    // Two-finger pinch start
                    e.preventDefault();
                    const rect = container.getBoundingClientRect();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    canvasTouchState.initialDistance = Math.hypot(dx, dy);
                    canvasTouchState.initialZoom = canvasZoom;
                    canvasTouchState.initialPanX = canvasPan.x;
                    canvasTouchState.initialPanY = canvasPan.y;
                    // Calculate pinch center in container coordinates
                    canvasTouchState.pinchCenterX = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left;
                    canvasTouchState.pinchCenterY = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top;
                    canvasTouchState.isPinching = true;
                } else if (e.touches.length === 1) {
                    // Single finger - start pan
                    canvasTouchState.lastTouchX = e.touches[0].clientX;
                    canvasTouchState.lastTouchY = e.touches[0].clientY;
                    canvasTouchState.isPinching = false;
                }
            }, { passive: false });

            container.addEventListener('touchmove', (e) => {
                if (canvasTouchState.isPinching && e.touches.length === 2) {
                    e.preventDefault();
                    const rect = container.getBoundingClientRect();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const currentDistance = Math.hypot(dx, dy);
                    const scale = currentDistance / canvasTouchState.initialDistance;
                    // Calculate new pinch center
                    const newCenterX = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left;
                    const newCenterY = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top;
                    // Calculate world point at initial pinch center
                    const worldX = (canvasTouchState.pinchCenterX - canvasTouchState.initialPanX) / canvasTouchState.initialZoom;
                    const worldY = (canvasTouchState.pinchCenterY - canvasTouchState.initialPanY) / canvasTouchState.initialZoom;
                    // Apply new zoom
                    canvasZoom = Math.max(0.1, Math.min(5, canvasTouchState.initialZoom * scale));
                    // Adjust pan so world point stays at new center (allows pan+zoom simultaneously)
                    canvasPan.x = newCenterX - worldX * canvasZoom;
                    canvasPan.y = newCenterY - worldY * canvasZoom;
                    updateCanvasTransform();
                } else if (e.touches.length === 1 && !canvasTouchState.isPinching) {
                    // Single finger pan
                    const deltaX = e.touches[0].clientX - canvasTouchState.lastTouchX;
                    const deltaY = e.touches[0].clientY - canvasTouchState.lastTouchY;
                    canvasPan.x += deltaX;
                    canvasPan.y += deltaY;
                    canvasTouchState.lastTouchX = e.touches[0].clientX;
                    canvasTouchState.lastTouchY = e.touches[0].clientY;
                    updateCanvasTransform();
                }
            }, { passive: false });

            container.addEventListener('touchend', () => {
                canvasTouchState.isPinching = false;
            });

            // BUILD 330: Space key for Mac-friendly panning (hold Space + drag)
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && viewMode === 'canvas') {
                    // Only if not typing in an input
                    if (!['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                        isSpacePressed = true;
                        container.style.cursor = 'grab';
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    isSpacePressed = false;
                    if (!isPanningCanvas) {
                        container.style.cursor = '';
                    }
                }
            });
        }

        // =====================================================================
        // PROGRESSIVE EXPAND/COLLAPSE - Works in both Tree and Canvas Views
        // =====================================================================

        // Calculate the maximum depth of the tree
        function getMaxDepth(node = capexTree, depth = 0) {
            let maxDepth = depth;
            if (node.children) {
                node.children.forEach(child => {
                    maxDepth = Math.max(maxDepth, getMaxDepth(child, depth + 1));
                });
            }
            if (node.items) {
                node.items.forEach(item => {
                    maxDepth = Math.max(maxDepth, getItemMaxDepth(item, depth + 1));
                });
            }
            return maxDepth;
        }

        function getItemMaxDepth(item, depth = 0) {
            let maxDepth = depth;
            if (item.subItems && item.subItems.length > 0) {
                item.subItems.forEach(subItem => {
                    maxDepth = Math.max(maxDepth, getItemMaxDepth(subItem, depth + 1));
                });
            }
            return maxDepth;
        }

        // BUILD 536: Collapse one level at a time (deepest first)
        // Handles all node types: children (folders), items, subItems
        // Collapses down to single root node when fully collapsed
        function collapseOneLevel() {
            // Helper: get all children of a node (handles different child key names)
            function getNodeChildren(node) {
                return [...(node.children || []), ...(node.items || []), ...(node.subItems || [])];
            }

            // Find all expanded nodes with children, tracking their depth
            let expandedWithChildren = [];
            let maxDepthFound = -1;

            function findExpanded(node, depth = 0, parentExpanded = true) {
                // Skip if parent is collapsed (not visible)
                if (!parentExpanded && depth > 0) return;

                const children = getNodeChildren(node);
                const isExpanded = node.expanded !== false;

                // Include ALL expanded nodes with children (including root at depth 0)
                if (isExpanded && children.length > 0) {
                    expandedWithChildren.push({ node, depth });
                    maxDepthFound = Math.max(maxDepthFound, depth);
                }

                // Recurse into children if expanded
                if (isExpanded) {
                    children.forEach(child => findExpanded(child, depth + 1, true));
                }
            }

            findExpanded(capexTree);

            if (expandedWithChildren.length === 0) {
                showToast('ğŸ“ Fully collapsed', 'info');
                return;
            }

            // Collapse only the nodes at the deepest level
            const toCollapse = expandedWithChildren.filter(x => x.depth === maxDepthFound);

            toCollapse.forEach(({ node }) => {
                node.expanded = false;
            });
        }

        // BUILD 536: Expand one level at a time (shallowest first)
        // Handles all node types: children (folders), items, subItems
        // Expands from single root to fully expanded tree
        function expandOneLevel() {
            // Helper: get all children of a node (handles different child key names)
            function getNodeChildren(node) {
                return [...(node.children || []), ...(node.items || []), ...(node.subItems || [])];
            }

            // Find all collapsed nodes with children at the shallowest visible level
            let collapsedWithChildren = [];
            let minDepthFound = Infinity;

            function findCollapsed(node, depth = 0, parentExpanded = true) {
                // Skip if parent is collapsed (not visible) - except root
                if (!parentExpanded && depth > 0) return;

                const children = getNodeChildren(node);
                const isExpanded = node.expanded !== false;

                // If this node is collapsed and has children, record it
                if (!isExpanded && children.length > 0) {
                    collapsedWithChildren.push({ node, depth });
                    minDepthFound = Math.min(minDepthFound, depth);
                    // Don't recurse into collapsed node's children (they're not visible)
                    return;
                }

                // Recurse into children if expanded
                if (isExpanded) {
                    children.forEach(child => findCollapsed(child, depth + 1, true));
                }
            }

            findCollapsed(capexTree);

            if (collapsedWithChildren.length === 0) {
                showToast('ğŸ“‚ Fully expanded', 'info');
                return;
            }

            // Expand only the nodes at the shallowest level
            const toExpand = collapsedWithChildren.filter(x => x.depth === minDepthFound);

            toExpand.forEach(({ node }) => {
                node.expanded = true;
            });
        }

        // Canvas-aware expand/collapse handlers
        window.canvasExpandOneLevel = function() {
            console.log('ğŸ¯ canvasExpandOneLevel called, viewMode:', viewMode);
            expandOneLevel();

            // Always update tree view
            if (typeof render === 'function') {
                console.log('Calling render() for tree view');
                render();
            }

            // Update canvas view if we're in canvas mode
            if (viewMode === 'canvas') {
                console.log('Calling renderCanvas() for canvas view');
                renderCanvas();
            }

            // BUILD 537: Update 3D view if we're in 3D mode
            if (viewMode === '3d' && typeof window.refresh3DData === 'function') {
                console.log('Calling refresh3DData() for 3D view');
                window.refresh3DData();
            }

            console.log('âœ… Expand complete');
        };

        window.canvasCollapseOneLevel = function() {
            console.log('ğŸ¯ canvasCollapseOneLevel called, viewMode:', viewMode);
            collapseOneLevel();

            // Always update tree view
            if (typeof render === 'function') {
                console.log('Calling render() for tree view');
                render();
            }

            // Update canvas view if we're in canvas mode
            if (viewMode === 'canvas') {
                console.log('Calling renderCanvas() for canvas view');
                renderCanvas();
            }

            // BUILD 537: Update 3D view if we're in 3D mode
            if (viewMode === '3d' && typeof window.refresh3DData === 'function') {
                console.log('Calling refresh3DData() for 3D view');
                window.refresh3DData();
            }

            console.log('âœ… Collapse complete');
        };

        // Helper to check if a node is visible (not hidden by collapsed parent)
        function isNodeVisible(nodeId) {
            // Find the node and check all its ancestors
            function findAndCheckNode(searchId, node = capexTree, ancestors = []) {
                if (node.id === searchId) {
                    // Check if any ancestor is collapsed
                    return ancestors.every(ancestor => ancestor.expanded !== false);
                }

                if (node.items) {
                    for (const item of node.items) {
                        if (checkItemVisibility(searchId, item, ancestors)) {
                            return true;
                        }
                    }
                }

                if (node.children) {
                    for (const child of node.children) {
                        const result = findAndCheckNode(searchId, child, [...ancestors, node]);
                        if (result !== undefined) return result;
                    }
                }

                return undefined;
            }

            function checkItemVisibility(searchId, item, ancestors = []) {
                if (item.id === searchId) {
                    return ancestors.every(ancestor => ancestor.expanded !== false);
                }

                if (item.subItems) {
                    for (const subItem of item.subItems) {
                        const result = checkItemVisibility(searchId, subItem, [...ancestors, item]);
                        if (result !== undefined) return result;
                    }
                }

                return undefined;
            }

            const result = findAndCheckNode(nodeId);
            return result === undefined ? true : result;  // Default to visible if not found
        }

        window.isNodeVisible = isNodeVisible;


        // =============================================================================
        // UNDO/REDO SYSTEM
        // =============================================================================

        // History stack for undo functionality
        const historyStack = [];
        const MAX_HISTORY = 50; // Keep last 50 states

        // Save current state to history before making changes
        function saveState(actionName = 'Unknown action') {
            const state = {
                tree: JSON.parse(JSON.stringify(capexTree)), // Deep copy
                pattern: currentPattern,
                timestamp: Date.now(),
                action: actionName
            };

            historyStack.push(state);

            // Limit history size
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift(); // Remove oldest
            }

            updateUndoButton();

            // Mark tree as changed (for auto-save)
            if (typeof treeManager !== 'undefined') {
                treeManager.markAsChanged();
            }
            console.log(`ğŸ’¾ State saved: ${actionName} (${historyStack.length} states in history)`);
        }

        // Undo last action
        function undo() {
            if (historyStack.length === 0) {
                console.warn('âš ï¸ No history to undo');
                return;
            }

            const previousState = historyStack.pop();

            // Restore previous state
            capexTree = previousState.tree;
            currentPattern = previousState.pattern;
            document.getElementById('pattern-select').value = currentPattern;

            // Re-render
            render();

            updateUndoButton();

            console.log(`â†©ï¸ Undo: Restored state from "${previousState.action}" (${historyStack.length} states remaining)`);

            // Show toast notification
            showToast(`Undone: ${previousState.action}`);
        }

        // Update undo button state
        function updateUndoButton() {
            const undoBtn = document.getElementById('undo-btn');
            if (undoBtn) {
                if (historyStack.length > 0) {
                    undoBtn.disabled = false;
                    undoBtn.style.opacity = '1';
                    const lastAction = historyStack[historyStack.length - 1].action;
                    undoBtn.title = `Undo: ${lastAction}`;
                } else {
                    undoBtn.disabled = true;
                    undoBtn.style.opacity = '0.5';
                    undoBtn.title = 'Nothing to undo';
                }
            }
        }

        // Toast notification for undo
        function showToast(message) {
            // Remove existing toast if any
            const existingToast = document.getElementById('undo-toast');
            if (existingToast) {
                existingToast.remove();
            }

            // Create toast
            const toast = document.createElement('div');
            toast.id = 'undo-toast';
            toast.style.cssText = `
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.85);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                animation: slideUp 0.3s ease-out;
            `;
            toast.textContent = message;

            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideUp {
                    from {
                        opacity: 0;
                        transform: translateX(-50%) translateY(20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(toast);

            // Auto-remove after 2 seconds
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        // Attach undo button handler
        const undoBtnEl = document.getElementById('undo-btn');
        if (undoBtnEl) {
            undoBtnEl.addEventListener('click', undo);
        }

        // Keyboard shortcut for undo (Ctrl+Z / Cmd+Z)
        document.addEventListener('keydown', (e) => {
            // Check for Ctrl+Z (Windows/Linux) or Cmd+Z (Mac)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                // Don't trigger undo if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle undo in text fields
                }

                e.preventDefault();
                undo();
            }

            // Check for Ctrl+S (Windows/Linux) or Cmd+S (Mac) - Save shortcut
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                // Don't trigger save if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle save in text fields if needed
                }

                e.preventDefault();
                console.log('âŒ¨ï¸ Ctrl+S pressed - triggering manual save');
                if (typeof treeManager !== 'undefined') {
                    treeManager.save(capexTree, { forceSaveAs: false });
                } else {
                    console.warn('TreeManager not initialized yet');
                }
            }

            // BUILD 396: Ctrl+/ or Cmd+/ - Toggle Chat Panel
            if ((e.ctrlKey || e.metaKey) && e.key === '/') {
                // Don't toggle if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return;
                }

                e.preventDefault();
                console.log('âŒ¨ï¸ Ctrl+/ pressed - toggling chat');
                if (typeof toggleChatPanel === 'function') {
                    toggleChatPanel();
                }
            }

            // Check for Ctrl+A (Windows/Linux) or Cmd+A (Mac) - Select all nodes in Canvas View
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                // Only work in Canvas View and not when typing in text fields
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle Ctrl+A in text fields
                }

                // Only work in Canvas View
                if (viewMode === 'canvas' && canvasNodes.length > 0) {
                    e.preventDefault();
                    console.log('âŒ¨ï¸ Ctrl+A pressed - selecting all visible nodes');

                    // Clear current selection
                    selectedNodes = [];

                    // Select all visible canvas nodes
                    canvasNodes.forEach(nodeObj => {
                        const node = nodeObj.data;
                        const nodeEl = nodeObj.element;

                        if (node.canvasX !== undefined && node.canvasY !== undefined) {
                            selectedNodes.push(node);
                            nodeEl.classList.add('selected');
                        }
                    });

                    updateSelectionCounter();
                    console.log(`Selected ${selectedNodes.length} nodes`);
                }
            }

            // BUILD 435: Ctrl+F - Open Canvas Search
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                // Only work in Canvas View
                if (viewMode === 'canvas') {
                    e.preventDefault();
                    console.log('âŒ¨ï¸ Ctrl+F pressed - opening canvas search');
                    if (typeof openCanvasSearch === 'function') {
                        openCanvasSearch();
                    }
                }
            }

            // BUILD 547: Email reader modal keyboard navigation
            const emailModal = document.getElementById('email-reader-modal');
            if (emailModal && emailModal.style.display === 'flex') {
                if (e.key === 'j' || e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    emailReaderNext();
                    return;
                }
                if (e.key === 'k' || e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                    e.preventDefault();
                    emailReaderPrev();
                    return;
                }
            }

            // Check for Escape - Clear selection in Canvas View + close modals
            if (e.key === 'Escape') {
                // BUILD 547: Close email reader modal if open
                if (emailModal && emailModal.style.display === 'flex') {
                    closeEmailReaderModal();
                    return;
                }
                // BUILD 541: Close keyboard shortcut modal if open
                const kbModal = document.getElementById('keyboard-shortcut-modal');
                if (kbModal && kbModal.style.display === 'flex') {
                    kbModal.style.display = 'none';
                    return;
                }
                // Only work in Canvas View
                if (viewMode === 'canvas' && selectedNodes.length > 0) {
                    console.log('âŒ¨ï¸ Escape pressed - clearing selection');
                    clearSelection();
                }
            }

            // BUILD 461: G key - Toggle Gantt View
            if (e.key === 'g' || e.key === 'G') {
                // Don't trigger if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return;
                }

                e.preventDefault();
                console.log('âŒ¨ï¸ G key pressed - toggling Gantt view');
                if (typeof toggleGanttView === 'function') {
                    toggleGanttView();
                }
            }

            // BUILD 541: ? key - Open keyboard shortcuts reference
            if (e.key === '?') {
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return;
                }
                e.preventDefault();
                console.log('âŒ¨ï¸ ? pressed - opening keyboard shortcuts');
                document.getElementById('keyboard-shortcut-modal').style.display = 'flex';
            }
        });

        // BUILD 541: Close keyboard shortcut modal on click outside
        document.getElementById('keyboard-shortcut-modal')?.addEventListener('click', (e) => {
            if (e.target.id === 'keyboard-shortcut-modal') {
                e.target.style.display = 'none';
            }
        });

        // BUILD 547: Close email reader modal on click outside
        document.getElementById('email-reader-modal')?.addEventListener('click', (e) => {
            if (e.target.id === 'email-reader-modal') {
                closeEmailReaderModal();
            }
        });

        // =============================================================================
        // END UNDO/REDO SYSTEM
        // =============================================================================

// TREEPLEXITY PATTERN SELECTOR
// Insert this code into treelisty.html

// ============================================================================
// BUILD 544: CAPABILITY NODE SCHEMA
// ============================================================================
// Capability nodes enable sub-agents to perform authenticated actions on websites
// using Chrome, with user-defined permission scopes. Part of Chrome Capability Nodes design.

const CAPABILITY_PERMISSIONS = ['read', 'navigate', 'download', 'fill_form', 'submit', 'send'];
const CAPABILITY_PERMISSIONS_MVP = ['read', 'navigate']; // Phase 1 only

const CAPABILITY_SCHEMA = {
    type: 'capability',
    required: ['name', 'site', 'goal'],
    defaults: {
        allow: ['read', 'navigate'],
        examples: [],
        aliases: [],
        selectors: {},
        profileHint: null,
        pathPattern: null,
        status: 'untested',  // untested | healthy | degraded | broken
        lastSuccessAt: null,
        failureStreak: 0
    },
    // Validate a capability node
    validate(node) {
        const errors = [];
        if (!node.name) errors.push('name is required');
        if (!node.site) errors.push('site is required');
        if (!node.goal) errors.push('goal is required');
        if (node.allow) {
            const invalid = node.allow.filter(p => !CAPABILITY_PERMISSIONS.includes(p));
            if (invalid.length) errors.push(`invalid permissions: ${invalid.join(', ')}`);
        }
        return { valid: errors.length === 0, errors };
    },
    // Create a new capability node with defaults
    create(data) {
        return {
            id: data.id || 'cap-' + Date.now(),
            type: 'capability',
            name: data.name,
            site: data.site,
            goal: data.goal,
            allow: data.allow || this.defaults.allow,
            examples: data.examples || this.defaults.examples,
            aliases: data.aliases || this.defaults.aliases,
            selectors: data.selectors || this.defaults.selectors,
            profileHint: data.profileHint || this.defaults.profileHint,
            pathPattern: data.pathPattern || this.defaults.pathPattern,
            status: this.defaults.status,
            lastSuccessAt: this.defaults.lastSuccessAt,
            failureStreak: this.defaults.failureStreak
        };
    }
};

// Helper to check if a node is a capability
function isCapabilityNode(node) {
    return node && node.type === 'capability';
}

// ============================================================================
// BUILD 616: DEDICATED CAPABILITIES TREE (Global, Cross-Project)
// ============================================================================
// Capabilities are stored in a separate tree that persists across all projects.
// This allows "check my Chase balance" to work regardless of which tree is open.

const CAPABILITIES_TREE_KEY = 'treelisty_capabilities_tree';

// Default capabilities tree structure
function createDefaultCapabilitiesTree() {
    return {
        id: 'capabilities_root',
        treeId: 'tree_capabilities_registry',
        name: 'Capabilities Registry',
        type: 'root',
        pattern: { key: 'generic' },
        expanded: true,
        children: [
            {
                id: 'phase_banking',
                type: 'phase',
                name: 'Banking & Finance',
                expanded: true,
                showInCanvas: true,
                items: []
            },
            {
                id: 'phase_work',
                type: 'phase',
                name: 'Work & Productivity',
                expanded: true,
                showInCanvas: true,
                items: []
            },
            {
                id: 'phase_research',
                type: 'phase',
                name: 'Research & Reading',
                expanded: true,
                showInCanvas: true,
                items: []
            },
            {
                id: 'phase_other',
                type: 'phase',
                name: 'Other',
                expanded: true,
                showInCanvas: true,
                items: []
            }
        ],
        hyperedges: []
    };
}

// Global capabilities tree (loaded on startup)
let capabilitiesTree = null;

// Load capabilities tree from localStorage
function loadCapabilitiesTree() {
    try {
        const stored = localStorage.getItem(CAPABILITIES_TREE_KEY);
        if (stored) {
            capabilitiesTree = JSON.parse(stored);
            console.log(`ğŸ” Loaded ${getCapabilityCount()} capabilities from registry`);
        } else {
            capabilitiesTree = createDefaultCapabilitiesTree();
            saveCapabilitiesTree();
            console.log('ğŸ” Created new capabilities registry');
        }
    } catch (e) {
        console.error('Failed to load capabilities tree:', e);
        capabilitiesTree = createDefaultCapabilitiesTree();
    }
    return capabilitiesTree;
}

// Save capabilities tree to localStorage
function saveCapabilitiesTree() {
    try {
        localStorage.setItem(CAPABILITIES_TREE_KEY, JSON.stringify(capabilitiesTree));
    } catch (e) {
        console.error('Failed to save capabilities tree:', e);
    }
}

// Get count of capabilities
function getCapabilityCount() {
    if (!capabilitiesTree) return 0;
    return findCapabilityNodesInTree(capabilitiesTree).length;
}

// Find all capability nodes in a tree (recursive helper)
function findCapabilityNodesInTree(node, results = []) {
    if (!node) return results;
    if (isCapabilityNode(node)) results.push(node);
    const children = node.children || node.items || node.subItems || [];
    children.forEach(child => findCapabilityNodesInTree(child, results));
    return results;
}

// Helper to find all capability nodes (uses global capabilities tree)
function findCapabilityNodes(nodeOrTree, results = []) {
    // If called with no args or capexTree, use global capabilities tree
    const tree = (nodeOrTree === capexTree || !nodeOrTree) ? capabilitiesTree : nodeOrTree;
    if (!tree) {
        loadCapabilitiesTree();
        return findCapabilityNodesInTree(capabilitiesTree, results);
    }
    return findCapabilityNodesInTree(tree, results);
}

// Add capability to the global registry
function addCapabilityToRegistry(capability, category = 'other') {
    if (!capabilitiesTree) loadCapabilitiesTree();

    // Find the appropriate phase based on category or site
    const site = (capability.site || '').toLowerCase();
    let targetPhase;

    if (category === 'banking' || site.includes('chase') || site.includes('bank') || site.includes('fidelity') || site.includes('schwab')) {
        targetPhase = capabilitiesTree.children.find(p => p.id === 'phase_banking');
    } else if (category === 'work' || site.includes('concur') || site.includes('workday') || site.includes('slack') || site.includes('jira')) {
        targetPhase = capabilitiesTree.children.find(p => p.id === 'phase_work');
    } else if (category === 'research' || site.includes('wsj') || site.includes('nytimes') || site.includes('medium')) {
        targetPhase = capabilitiesTree.children.find(p => p.id === 'phase_research');
    } else {
        targetPhase = capabilitiesTree.children.find(p => p.id === 'phase_other');
    }

    if (!targetPhase) {
        targetPhase = capabilitiesTree.children[capabilitiesTree.children.length - 1]; // Fallback to last phase
    }

    if (!targetPhase.items) targetPhase.items = [];
    targetPhase.items.push(capability);
    saveCapabilitiesTree();

    return targetPhase.name;
}

// View the capabilities tree (switch to it)
function viewCapabilitiesTree() {
    if (!capabilitiesTree) loadCapabilitiesTree();

    // Store current tree for "back" functionality
    window._previousTree = JSON.parse(JSON.stringify(capexTree));
    window._previousTreeName = capexTree.name;

    // Load capabilities tree into main view
    Object.assign(capexTree, JSON.parse(JSON.stringify(capabilitiesTree)));

    render();
    showToast('ğŸ” Viewing Capabilities Registry', 'info');

    return 'ğŸ” Switched to Capabilities Registry. Use `back` to return to your project.';
}

// Return to previous tree
function returnFromCapabilitiesTree() {
    if (window._previousTree) {
        Object.assign(capexTree, window._previousTree);
        render();
        showToast(`ğŸ“‚ Returned to: ${window._previousTreeName}`, 'info');
        window._previousTree = null;
        window._previousTreeName = null;
        return `ğŸ“‚ Returned to your project.`;
    }
    return 'âš ï¸ No previous tree to return to.';
}

// Initialize capabilities tree on page load
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        loadCapabilitiesTree();
    }, 100);
});

// Helper to match intent to capability
function matchIntentToCapability(intent, capabilities) {
    const intentLower = intent.toLowerCase().trim();

    // 1. Exact example match
    for (const cap of capabilities) {
        if (cap.examples && cap.examples.some(ex => intentLower.includes(ex.toLowerCase()))) {
            return { capability: cap, matchType: 'example' };
        }
    }

    // 2. Alias match
    for (const cap of capabilities) {
        if (cap.aliases && cap.aliases.some(alias => intentLower.includes(alias.toLowerCase()))) {
            return { capability: cap, matchType: 'alias' };
        }
    }

    // 3. Site match
    for (const cap of capabilities) {
        if (cap.site && intentLower.includes(cap.site.toLowerCase().replace('.com', '').replace('.', ''))) {
            return { capability: cap, matchType: 'site' };
        }
    }

    // 4. Goal semantic match (simple keyword overlap)
    for (const cap of capabilities) {
        if (cap.goal) {
            const goalWords = cap.goal.toLowerCase().split(/\s+/);
            const intentWords = intentLower.split(/\s+/);
            const overlap = goalWords.filter(w => intentWords.includes(w) && w.length > 3);
            if (overlap.length >= 2) {
                return { capability: cap, matchType: 'goal' };
            }
        }
    }

    return null;
}

// ============================================================================
// PATTERN DEFINITIONS
// ============================================================================

const PATTERNS = {
    generic: {
        name: 'Generic Project',
        icon: 'ğŸ“‹',
        levels: {
            root: 'Project',
            phase: 'Phase',
            item: 'Item',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Seed', 'Seed', 'Build'],
        types: [
            { value: 'land', label: 'Land' },
            { value: 'engineering', label: 'Engineering' },
            { value: 'equipment', label: 'Equipment' },
            { value: 'infrastructure', label: 'Infrastructure' },
            { value: 'corporate', label: 'Corporate' },
            { value: 'professional', label: 'Professional' },
            { value: 'contingency', label: 'Contingency' }
        ],
        description: 'Universal structure for any project',
        sortOptions: [
            { value: 'cost-high', label: 'ğŸ’° Cost (Highest First)', field: 'cost', order: 'desc', type: 'number' },
            { value: 'cost-low', label: 'ğŸ’° Cost (Lowest First)', field: 'cost', order: 'asc', type: 'number' },
            { value: 'leadtime-soonest', label: 'â±ï¸ Lead Time (Soonest First)', field: 'leadTime', order: 'asc', type: 'leadtime' },
            { value: 'leadtime-latest', label: 'â±ï¸ Lead Time (Latest First)', field: 'leadTime', order: 'desc', type: 'leadtime' },
            { value: 'name-az', label: 'ğŸ”¤ Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ğŸ”¤ Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ],
        fields: {
            cost: { label: 'Cost ($)', type: 'number', step: 1000, helpText: 'ğŸ’° Budget allocated for this item' },
            alternateSource: { label: 'Alternate Source', type: 'text', placeholder: 'Backup vendor, supplier, or alternative solution...', helpText: 'ğŸ“¦ Alternative supplier or backup option for risk mitigation' },
            leadTime: { label: 'Lead Time', type: 'text', placeholder: 'e.g., 12-18 months, 6 weeks, 90 days...', helpText: 'â±ï¸ Expected procurement or delivery timeline' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    sales: {
        name: 'Sales Pipeline',
        icon: 'ğŸ’¼',
        levels: {
            root: 'Pipeline',
            phase: 'Quarter',
            item: 'Deal',
            subtask: 'Action'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'inbound', label: 'Inbound Lead' },
            { value: 'outbound', label: 'Outbound Prospect' },
            { value: 'partnership', label: 'Partnership' },
            { value: 'expansion', label: 'Account Expansion' },
            { value: 'renewal', label: 'Renewal' },
            { value: 'upsell', label: 'Upsell' },
            { value: 'cross-sell', label: 'Cross-sell' },
            { value: 'enterprise', label: 'Enterprise Deal' }
        ],
        description: 'Track sales opportunities through quarters',
        sortOptions: [
            { value: 'dealvalue-high', label: 'ğŸ’° Deal Value (Largest First)', field: 'dealValue', order: 'desc', type: 'number' },
            { value: 'dealvalue-low', label: 'ğŸ’° Deal Value (Smallest First)', field: 'dealValue', order: 'asc', type: 'number' },
            { value: 'closedate-soonest', label: 'ğŸ“… Close Date (Soonest First)', field: 'expectedCloseDate', order: 'asc', type: 'date' },
            { value: 'closedate-latest', label: 'ğŸ“… Close Date (Latest First)', field: 'expectedCloseDate', order: 'desc', type: 'date' },
            { value: 'probability-high', label: 'ğŸ“Š Probability (Highest First)', field: 'stageProbability', order: 'desc', type: 'number' },
            { value: 'probability-low', label: 'ğŸ“Š Probability (Lowest First)', field: 'stageProbability', order: 'asc', type: 'number' },
            { value: 'name-az', label: 'ğŸ”¤ Deal Name (A-Z)', field: 'name', order: 'asc', type: 'text' }
        ],
        fields: {
            dealValue: { label: 'Deal Value ($)', type: 'number', step: 1000, helpText: 'ğŸ’° Potential revenue from this deal' },
            expectedCloseDate: { label: 'Expected Close Date', type: 'date', helpText: 'ğŸ“… Target date to close this deal' },
            leadSource: { label: 'Lead Source', type: 'text', placeholder: 'Inbound, Referral, Cold Outreach...', helpText: 'ğŸ“ How did this lead originate?' },
            contactPerson: { label: 'Contact Person', type: 'text', placeholder: 'Primary contact name...', helpText: 'ğŸ‘¤ Main decision maker or champion' },
            stageProbability: { label: 'Stage Probability (%)', type: 'number', min: 0, max: 100, step: 5, helpText: 'ğŸ“Š Likelihood of closing this deal' },
            competitorInfo: { label: 'Competitor Info', type: 'textarea', placeholder: 'Who else is competing for this deal...', helpText: 'ğŸ¯ Other vendors in consideration' },
            includeDependencies: false,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    thesis: {
        name: 'Academic Writing',
        icon: 'ğŸ“',
        levels: {
            root: 'Thesis',
            phase: 'Chapter',
            item: 'Section',
            subtask: 'Point'
        },
        phaseSubtitles: ['Introduction', 'Body', 'Conclusion'],
        types: [
            { value: 'literature-review', label: 'Literature Review' },
            { value: 'methodology', label: 'Methodology' },
            { value: 'analysis', label: 'Analysis' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'theory', label: 'Theoretical Framework' },
            { value: 'evidence', label: 'Evidence' },
            { value: 'argument', label: 'Argument' },
            { value: 'conclusion', label: 'Conclusion' }
        ],
        description: 'Structure academic papers and dissertations',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'ğŸ“ Current word count for this section' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'ğŸ¯ Goal word count for this section' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: 'âœï¸ Current revision stage' },
            citations: { label: 'Key Citations', type: 'textarea', placeholder: 'List main sources and references...', helpText: 'ğŸ“š Important sources for this section' },
            keyArgument: { label: 'Key Argument', type: 'textarea', placeholder: 'Main point of this section...', helpText: 'ğŸ’¡ Central claim or thesis' },
            evidenceType: { label: 'Evidence Type', type: 'select', options: ['Empirical', 'Theoretical', 'Mixed', 'N/A'], helpText: 'ğŸ”¬ Nature of supporting evidence' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    roadmap: {
        name: 'Product Roadmap',
        icon: 'ğŸš€',
        levels: {
            root: 'Product',
            phase: 'Quarter',
            item: 'Feature',
            subtask: 'Story'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'core-feature', label: 'Core Feature' },
            { value: 'enhancement', label: 'Enhancement' },
            { value: 'bug-fix', label: 'Bug Fix' },
            { value: 'technical-debt', label: 'Technical Debt' },
            { value: 'research', label: 'Research/Spike' },
            { value: 'platform', label: 'Platform' },
            { value: 'integration', label: 'Integration' },
            { value: 'ux', label: 'UX Improvement' }
        ],
        description: 'Plan product features across quarters',
        fields: {
            storyPoints: { label: 'Story Points', type: 'number', min: 0, step: 1, placeholder: '1, 2, 3, 5, 8, 13...', helpText: 'ğŸ¯ Effort estimate (Fibonacci scale)' },
            engineeringEstimate: { label: 'Engineering Estimate', type: 'text', placeholder: '2 weeks, 1 sprint, 3 days...', helpText: 'â±ï¸ Time estimate from engineering' },
            userImpact: { label: 'User Impact', type: 'select', options: ['High', 'Medium', 'Low'], helpText: 'ğŸ‘¥ How many users does this affect?' },
            technicalRisk: { label: 'Technical Risk', type: 'select', options: ['Low', 'Medium', 'High', 'Unknown'], helpText: 'âš ï¸ Complexity and technical uncertainty' },
            featureFlag: { label: 'Feature Flag', type: 'text', placeholder: 'flag_name...', helpText: 'ğŸš© Feature flag for gradual rollout' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    book: {
        name: 'Book Writing',
        icon: 'ğŸ“š',
        levels: {
            root: 'Book',
            phase: 'Part',
            item: 'Chapter',
            subtask: 'Scene'
        },
        phaseSubtitles: ['Act I', 'Act II', 'Act III'],
        types: [
            { value: 'narrative', label: 'Narrative' },
            { value: 'dialogue', label: 'Dialogue' },
            { value: 'description', label: 'Description' },
            { value: 'action', label: 'Action' },
            { value: 'reflection', label: 'Reflection' },
            { value: 'transition', label: 'Transition' },
            { value: 'climax', label: 'Climax' },
            { value: 'exposition', label: 'Exposition' }
        ],
        description: 'Organize books into parts, chapters, and scenes',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'ğŸ“ Current word count' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'ğŸ¯ Goal word count' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: 'âœï¸ Current revision stage' },
            povCharacter: { label: 'POV Character', type: 'text', placeholder: 'Whose perspective...', helpText: 'ğŸ‘¤ Point-of-view character' },
            sceneSetting: { label: 'Scene Setting', type: 'textarea', placeholder: 'Location, time, mood...', helpText: 'ğŸ­ Where and when this takes place' },
            plotFunction: { label: 'Plot Function', type: 'select', options: ['Setup', 'Conflict', 'Resolution', 'Transition'], helpText: 'ğŸ“– Role in story structure' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    event: {
        name: 'Event Planning',
        icon: 'ğŸ‰',
        levels: {
            root: 'Event',
            phase: 'Stage',
            item: 'Activity',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Event', 'Event Day', 'Post-Event'],
        types: [
            { value: 'logistics', label: 'Logistics' },
            { value: 'catering', label: 'Catering' },
            { value: 'entertainment', label: 'Entertainment' },
            { value: 'venue', label: 'Venue' },
            { value: 'marketing', label: 'Marketing' },
            { value: 'registration', label: 'Registration' },
            { value: 'follow-up', label: 'Follow-up' },
            { value: 'av-tech', label: 'AV/Tech' }
        ],
        description: 'Plan events from prep to execution to follow-up',
        fields: {
            budget: { label: 'Budget ($)', type: 'number', step: 100, helpText: 'ğŸ’° Budget for this activity' },
            vendor: { label: 'Vendor/Supplier', type: 'text', placeholder: 'Company or person name...', helpText: 'ğŸ¢ External vendor or supplier' },
            bookingDeadline: { label: 'Booking Deadline', type: 'date', helpText: 'ğŸ“… Last date to book/reserve' },
            guestCount: { label: 'Guest Count', type: 'number', min: 0, placeholder: 'Expected attendees...', helpText: 'ğŸ‘¥ Number of expected guests' },
            location: { label: 'Location', type: 'text', placeholder: 'Venue, room, area...', helpText: 'ğŸ“ Where this takes place' },
            responsiblePerson: { label: 'Responsible Person', type: 'text', placeholder: 'Team member name...', helpText: 'ğŸ‘¤ Who\'s handling this' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    fitness: {
        name: 'Fitness Program',
        icon: 'ğŸ’ª',
        levels: {
            root: 'Program',
            phase: 'Phase',
            item: 'Workout',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Foundation', 'Build', 'Peak'],
        types: [
            { value: 'strength', label: 'Strength Training' },
            { value: 'cardio', label: 'Cardio' },
            { value: 'flexibility', label: 'Flexibility' },
            { value: 'recovery', label: 'Recovery' },
            { value: 'nutrition', label: 'Nutrition' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'conditioning', label: 'Conditioning' },
            { value: 'mobility', label: 'Mobility' }
        ],
        description: 'Structure training programs with periodization',
        fields: {
            sets: { label: 'Sets', type: 'number', min: 0, step: 1, placeholder: 'Number of sets...', helpText: 'ğŸ”¢ Number of sets' },
            reps: { label: 'Reps', type: 'text', placeholder: '8-12, 10, AMRAP...', helpText: 'ğŸ” Repetitions per set' },
            duration: { label: 'Duration', type: 'text', placeholder: '30 minutes, 45 sec...', helpText: 'â±ï¸ Time for this exercise/workout' },
            intensity: { label: 'Intensity Level', type: 'select', options: ['Light', 'Moderate', 'High', 'Max'], helpText: 'ğŸ”¥ Effort level' },
            equipment: { label: 'Equipment Needed', type: 'text', placeholder: 'Dumbbells, Barbell, Bodyweight...', helpText: 'ğŸ‹ï¸ Required equipment' },
            formCues: { label: 'Form Cues', type: 'textarea', placeholder: 'Key technique reminders...', helpText: 'âœ… Important form tips' },
            restPeriod: { label: 'Rest Period', type: 'text', placeholder: '60 sec, 2 min...', helpText: 'â¸ï¸ Rest between sets' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    strategy: {
        name: 'Strategic Plan',
        icon: 'ğŸ“Š',
        levels: {
            root: 'Strategy',
            phase: 'Pillar',
            item: 'Initiative',
            subtask: 'Action'
        },
        phaseSubtitles: ['Planning', 'Execution', 'Review'],
        types: [
            { value: 'market-expansion', label: 'Market Expansion' },
            { value: 'operational', label: 'Operational Excellence' },
            { value: 'financial', label: 'Financial' },
            { value: 'hr', label: 'Human Resources' },
            { value: 'technology', label: 'Technology' },
            { value: 'risk-management', label: 'Risk Management' },
            { value: 'innovation', label: 'Innovation' },
            { value: 'customer', label: 'Customer Experience' }
        ],
        description: 'Organize business strategy into pillars and initiatives',
        fields: {
            investment: { label: 'Investment ($)', type: 'number', step: 10000, helpText: 'ğŸ’° Capital investment required' },
            keyMetric: { label: 'Key Metric', type: 'text', placeholder: 'What defines success...', helpText: 'ğŸ“Š Success measurement' },
            targetValue: { label: 'Target Value', type: 'text', placeholder: 'Goal for metric...', helpText: 'ğŸ¯ Goal to achieve' },
            responsibleExecutive: { label: 'Responsible Executive', type: 'text', placeholder: 'C-level owner...', helpText: 'ğŸ‘” Executive sponsor' },
            strategicTheme: { label: 'Strategic Theme', type: 'select', options: ['Growth', 'Efficiency', 'Innovation', 'Transformation', 'Risk Mitigation'], helpText: 'ğŸ­ Strategic category' },
            riskLevel: { label: 'Risk Level', type: 'select', options: ['Low', 'Medium', 'High'], helpText: 'âš ï¸ Implementation risk' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    course: {
        name: 'Course Design',
        icon: 'ğŸ“–',
        levels: {
            root: 'Course',
            phase: 'Unit',
            item: 'Lesson',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Beginning', 'Middle', 'Advanced'],
        types: [
            { value: 'lecture', label: 'Lecture' },
            { value: 'lab', label: 'Lab/Practical' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'reading', label: 'Reading' },
            { value: 'project', label: 'Project' },
            { value: 'workshop', label: 'Workshop' },
            { value: 'field-work', label: 'Field Work' }
        ],
        description: 'Build educational curricula with units and lessons',
        fields: {
            learningObjectives: { label: 'Learning Objectives', type: 'textarea', placeholder: 'What students will learn...', helpText: 'ğŸ“ Expected learning outcomes' },
            duration: { label: 'Duration', type: 'text', placeholder: '50 minutes, 2 hours...', helpText: 'â±ï¸ Class time needed' },
            difficultyLevel: { label: 'Difficulty Level', type: 'select', options: ['Beginner', 'Intermediate', 'Advanced'], helpText: 'ğŸ“Š Complexity level' },
            prerequisites: { label: 'Prerequisites', type: 'textarea', placeholder: 'Prior knowledge needed...', helpText: 'ğŸ“‹ Required background' },
            assessmentType: { label: 'Assessment Type', type: 'select', options: ['Quiz', 'Assignment', 'Project', 'Discussion', 'Exam', 'None'], helpText: 'âœ… How learning is evaluated' },
            resourcesNeeded: { label: 'Resources Needed', type: 'textarea', placeholder: 'Textbook chapters, videos, materials...', helpText: 'ğŸ“š Required materials' },
            homework: { label: 'Homework', type: 'textarea', placeholder: 'Out-of-class work...', helpText: 'ğŸ“ Assignments for students' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    film: {
        name: 'AI Video Production',
        icon: 'ğŸ¬',
        levels: {
            root: 'Film',
            phase: 'Act',
            item: 'Scene',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Act I - Setup', 'Act II - Conflict', 'Act III - Resolution'],
        types: [
            { value: 'establishing', label: 'Establishing Shot' },
            { value: 'character-intro', label: 'Character Introduction' },
            { value: 'dialogue', label: 'Dialogue Scene' },
            { value: 'action', label: 'Action Sequence' },
            { value: 'montage', label: 'Montage' },
            { value: 'transition', label: 'Transition' },
            { value: 'climax', label: 'Climax' },
            { value: 'resolution', label: 'Resolution' }
        ],
        description: 'Create films using AI video generation (Sora, Veo, Runway, Pika)',
        fields: {
            aiPlatform: { label: 'AI Platform', type: 'select', options: ['Sora (OpenAI)', 'Veo 3 (Google)', 'Runway Gen-3', 'Pika 2.0', 'Kling AI', 'Luma Dream Machine', 'Haiper', 'Testing Multiple'], helpText: 'ğŸ¤– Which AI video model to use' },
            videoPrompt: { label: 'Video Prompt', type: 'textarea', placeholder: 'Detailed text-to-video prompt...', helpText: 'âœï¸ Primary prompt describing the scene (be specific: camera movement, lighting, mood, action)' },
            visualStyle: { label: 'Visual Style', type: 'select', options: ['Photorealistic', 'Cinematic', 'Documentary', 'Anime', 'Pixar 3D', 'Stop Motion', 'Vintage Film', 'Noir', 'Sci-Fi', 'Fantasy'], helpText: 'ğŸ¨ Overall aesthetic and look' },
            duration: { label: 'Duration', type: 'select', options: ['2 seconds', '4 seconds', '6 seconds', '10 seconds', '20 seconds', 'Extended (loop)'], helpText: 'â±ï¸ Video clip length' },
            aspectRatio: { label: 'Aspect Ratio', type: 'select', options: ['16:9 (Widescreen)', '9:16 (Vertical/Mobile)', '1:1 (Square)', '2.39:1 (Cinematic)', '4:3 (Classic)'], helpText: 'ğŸ“ Video dimensions for target platform' },
            cameraMovement: { label: 'Camera Movement', type: 'select', options: ['Static', 'Slow Pan', 'Dolly In', 'Dolly Out', 'Tracking Shot', 'Crane Up', 'Crane Down', 'Handheld', 'Orbiting'], helpText: 'ğŸ¥ How camera moves through scene' },
            motionIntensity: { label: 'Motion Intensity', type: 'select', options: ['Minimal', 'Subtle', 'Moderate', 'Dynamic', 'Intense'], helpText: 'ğŸŒŠ Amount of movement and action' },
            lightingMood: { label: 'Lighting Mood', type: 'select', options: ['Golden Hour', 'Overcast', 'Night', 'Neon', 'Dramatic', 'Soft Natural', 'High Contrast', 'Backlit'], helpText: 'ğŸ’¡ Lighting setup and atmosphere' },
            iterationNotes: { label: 'Generation Notes', type: 'textarea', placeholder: 'Prompt refinements, variations tried, best practices learned...', helpText: 'ğŸ“ What worked, what didn\'t, prompt engineering insights' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        },
        sortOptions: [
            { value: 'visualstyle', label: 'ğŸ¨ Visual Style', field: 'visualStyle', order: 'asc', type: 'text' },
            { value: 'lightingmood', label: 'ğŸ’¡ Lighting Mood', field: 'lightingMood', order: 'asc', type: 'text' },
            { value: 'cameramovement', label: 'ğŸ¥ Camera Movement', field: 'cameraMovement', order: 'asc', type: 'text' },
            { value: 'aiplatform', label: 'ğŸ¤– AI Platform', field: 'aiPlatform', order: 'asc', type: 'text' },
            { value: 'duration', label: 'â±ï¸ Duration', field: 'duration', order: 'asc', type: 'text' },
            { value: 'name-az', label: 'ğŸ”¤ Scene Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ğŸ”¤ Scene Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ]
    },
    veo3: {
        name: 'Veo3 (Google)',
        icon: 'ğŸ¥',
        levels: {
            root: 'Project',
            phase: 'Sequence',
            item: 'Scene',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Opening Sequence', 'Development', 'Climax Sequence'],
        types: [
            { value: 'ingredients', label: 'Ingredients to Video' },
            { value: 'frames', label: 'Frames to Video' },
            { value: 'extend', label: 'Extend Video' },
            { value: 'standard', label: 'Standard Generation' }
        ],
        description: 'Google Veo 3.1 AI video generation with Flow workflow',
        fields: {
            flowMode: { label: 'Flow Mode', type: 'select', options: ['Ingredients to Video', 'Frames to Video', 'Extend', 'Standard'], helpText: 'ğŸ¬ Veo 3 generation mode (ingredients, frame bridging, or extension)' },
            videoPrompt: { label: 'Video Prompt', type: 'textarea', placeholder: 'Detailed text-to-video prompt...', helpText: 'âœï¸ Primary prompt for Veo 3 generation' },
            ingredientImages: { label: 'Ingredient Images', type: 'textarea', placeholder: 'URLs of reference images (character, objects, style)...', helpText: 'ğŸ–¼ï¸ Reference images for character/object/style control (Ingredients mode)' },
            startFrame: { label: 'Start Frame', type: 'text', placeholder: 'URL or ID...', helpText: 'ğŸï¸ Starting frame for frame bridging (Frames mode)' },
            endFrame: { label: 'End Frame', type: 'text', placeholder: 'URL or ID...', helpText: 'ğŸï¸ Ending frame for frame bridging (Frames mode)' },
            extendDuration: { label: 'Extend Duration', type: 'select', options: ['10 seconds', '20 seconds', '30 seconds', '60+ seconds'], helpText: 'â±ï¸ Target duration for extended video (Extend mode)' },
            duration: { label: 'Duration', type: 'select', options: ['4 seconds', '6 seconds', '8 seconds'], helpText: 'â±ï¸ Standard Veo 3 durations @ 24 FPS' },
            resolution: { label: 'Resolution', type: 'select', options: ['720p', '1080p'], helpText: 'ğŸ“º Output resolution' },
            audioType: { label: 'Audio Type', type: 'select', options: ['Dialogue', 'Sound Effects', 'Ambience', 'Mixed', 'Silent'], helpText: 'ğŸ”Š Native audio generation type' },
            cinematicStyle: { label: 'Cinematic Style', type: 'select', options: ['Realistic', 'Dramatic', 'Documentary', 'Commercial', 'Artistic', 'Music Video'], helpText: 'ğŸ­ Veo 3 cinematic style understanding' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    sora2: {
        name: 'Sora2 (OpenAI)',
        icon: 'ğŸ¬',
        levels: {
            root: 'Project',
            phase: 'Sequence',
            item: 'Beat',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Setup', 'Conflict', 'Resolution'],
        types: [
            { value: 'cameo', label: 'Cameo Shot' },
            { value: 'remix', label: 'Remix Variant' },
            { value: 'standard', label: 'Standard Generation' },
            { value: 'physics-complex', label: 'Complex Physics' }
        ],
        description: 'OpenAI Sora 2 AI video generation with cameo and remix capabilities',
        fields: {
            videoPrompt: { label: 'Video Prompt', type: 'textarea', placeholder: 'Detailed text-to-video prompt for Sora 2...', helpText: 'âœï¸ Primary prompt for Sora 2 generation (physics-aware)' },
            beatType: { label: 'Beat Type', type: 'select', options: ['Setup', 'Conflict', 'Transition', 'Resolution', 'Character Moment'], helpText: 'ğŸ¯ Narrative beat purpose in storyboard' },
            cameoUsed: { label: 'Uses Cameo', type: 'select', options: ['None', 'Cameo ID 1', 'Cameo ID 2', 'Cameo ID 3'], helpText: 'ğŸ‘¤ Insert pre-recorded cameo (person/object) into scene' },
            remixSource: { label: 'Remix Source', type: 'text', placeholder: 'Source shot ID...', helpText: 'ğŸ”„ Source shot for remix/modification (instead of full regeneration)' },
            physicsComplexity: { label: 'Physics Complexity', type: 'select', options: ['Simple', 'Medium', 'Complex (Gymnastics/Water/Ballistics)'], helpText: 'âš¡ Physics accuracy level needed' },
            duration: { label: 'Duration', type: 'select', options: ['4 seconds', '8 seconds', '12 seconds'], helpText: 'â±ï¸ Sora 2 Pro fixed durations' },
            resolution: { label: 'Resolution', type: 'select', options: ['720p', '1080p'], helpText: 'ğŸ“º Output resolution for cinematic quality' },
            nleExportFormat: { label: 'NLE Export', type: 'select', options: ['Premiere Pro', 'Final Cut Pro', 'DaVinci Resolve', 'After Effects', 'Raw Files'], helpText: 'ğŸ“¤ Post-production NLE format' },
            audioSync: { label: 'Audio Sync', type: 'select', options: ['Synchronized Dialogue', 'Sound Effects', 'Background Score', 'Silent'], helpText: 'ğŸµ Sora 2 synchronized audio generation' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    philosophy: {
        name: 'Philosophy',
        icon: 'ğŸ¤”',
        levels: {
            root: 'Dialogue',
            phase: 'Movement',
            item: 'Claim',
            subtask: 'Support'
        },
        phaseSubtitles: ['Opening Question', 'First Definition', 'Refutation', 'Second Attempt', 'Deeper Inquiry', 'Resolution'],
        types: [
            // Dialectical moves
            { value: 'question', label: 'â“ Question' },
            { value: 'definition', label: 'ğŸ“ Definition' },
            { value: 'refutation', label: 'âŒ Refutation/Elenchus' },
            { value: 'premise', label: 'ğŸ“ Premise' },
            { value: 'conclusion', label: 'âœ“ Conclusion' },
            { value: 'objection', label: 'âš ï¸ Objection' },
            { value: 'response', label: 'ğŸ’¬ Response' },
            { value: 'example', label: 'ğŸ“– Example' },
            { value: 'analogy', label: 'ğŸ”„ Analogy' },
            { value: 'distinction', label: 'âš–ï¸ Distinction' },
            { value: 'paradox', label: 'ğŸŒ€ Paradox' },
            { value: 'thought-experiment', label: 'ğŸ’­ Thought Experiment' },
            { value: 'aporia', label: 'ğŸ¤· Aporia (Impasse)' },
            // Philosophical domains
            { value: 'metaphysical', label: 'ğŸŒŒ Metaphysical' },
            { value: 'epistemological', label: 'ğŸ§  Epistemological' },
            { value: 'ethical', label: 'âš–ï¸ Ethical' },
            { value: 'political', label: 'ğŸ›ï¸ Political' },
            { value: 'logical', label: 'ğŸ”¢ Logical' }
        ],
        description: 'Structure philosophical dialogues, treatises, and arguments with dialectical precision',
        fields: {
            speaker: { label: 'Speaker', type: 'text', placeholder: 'Socrates, Meno, etc...', helpText: 'ğŸ—£ï¸ Who makes this claim or argument' },
            argumentType: { label: 'Argument Type', type: 'select', options: ['Deductive', 'Inductive', 'Abductive', 'Dialectical', 'Reductio ad Absurdum', 'Socratic Elenchus'], helpText: 'ğŸ¯ Type of reasoning employed' },
            validity: { label: 'Logical Validity', type: 'select', options: ['Valid', 'Invalid', 'Sound', 'Unsound', 'Uncertain'], helpText: 'âœ“ Logical soundness' },
            keyTerms: { label: 'Key Terms', type: 'text', placeholder: 'virtue, knowledge, piety...', helpText: 'ğŸ“ Central concepts defined or discussed' },
            premise1: { label: 'Premise 1', type: 'textarea', placeholder: 'First premise of argument...', helpText: '1ï¸âƒ£ First assumption or claim' },
            premise2: { label: 'Premise 2', type: 'textarea', placeholder: 'Second premise...', helpText: '2ï¸âƒ£ Second assumption or claim' },
            conclusion: { label: 'Conclusion', type: 'textarea', placeholder: 'What follows from premises...', helpText: 'âœ“ Logical conclusion' },
            objection: { label: 'Objection', type: 'textarea', placeholder: 'Main counterargument...', helpText: 'âŒ Key objection raised' },
            response: { label: 'Response to Objection', type: 'textarea', placeholder: 'How objection is addressed...', helpText: 'ğŸ’¡ Defense or reply to objection' },
            textualReference: { label: 'Textual Reference', type: 'text', placeholder: 'e.g., Meno 70a-72c, Republic 347c...', helpText: 'ğŸ“– Stephanus number or page reference' },
            philosophicalSchool: { label: 'School of Thought', type: 'select', options: ['Pre-Socratic', 'Platonic', 'Aristotelian', 'Stoic', 'Epicurean', 'Skeptic', 'Medieval', 'Rationalist', 'Empiricist', 'Kantian', 'Hegelian', 'Phenomenological', 'Analytic', 'Continental', 'Pragmatist', 'Other'], helpText: 'ğŸ›ï¸ Philosophical tradition or school' },
            includeDependencies: true,
            includeTracking: false
        },
        sortOptions: [
            { value: 'speaker-az', label: 'ğŸ—£ï¸ Speaker (A-Z)', field: 'speaker', order: 'asc', type: 'text' },
            { value: 'speaker-za', label: 'ğŸ—£ï¸ Speaker (Z-A)', field: 'speaker', order: 'desc', type: 'text' },
            { value: 'argumenttype', label: 'ğŸ¯ Argument Type', field: 'argumentType', order: 'asc', type: 'text' },
            { value: 'validity', label: 'âœ“ Logical Validity', field: 'validity', order: 'asc', type: 'text' },
            { value: 'school', label: 'ğŸ›ï¸ Philosophical School', field: 'philosophicalSchool', order: 'asc', type: 'text' },
            { value: 'name-az', label: 'ğŸ”¤ Claim Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ğŸ”¤ Claim Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ]
    },
    prompting: {
        name: 'Prompt Engineering',
        icon: 'ğŸ§ ',
        levels: {
            root: 'Prompt Library',
            phase: 'Category',
            item: 'Prompt',
            subtask: 'Test Case'
        },
        phaseSubtitles: ['Customer Support', 'Content Generation', 'Data Analysis', 'Code Assistance', 'Research', 'Creative Writing'],
        types: [
            { value: 'task-instruction', label: 'ğŸ’¬ Task Instruction' },
            { value: 'few-shot', label: 'ğŸ“š Few-Shot Examples' },
            { value: 'chain-of-thought', label: 'ğŸ§  Chain-of-Thought' },
            { value: 'structured-output', label: 'ğŸ“ Structured Output' },
            { value: 'xml-guided', label: 'ğŸ—ï¸ XML-Guided (Anthropic)' },
            { value: 'prefill-guided', label: 'ğŸ¯ Prefill-Guided (Claude)' },
            { value: 'production', label: 'âœ… Production-Ready' },
            { value: 'experimental', label: 'ğŸ§ª Experimental' }
        ],
        description: 'Design and test AI prompts with best practices from OpenAI and Anthropic',
        fields: {
            systemPrompt: {
                label: 'System Prompt (Required)',
                type: 'textarea',
                placeholder: 'You are an expert customer support agent with 10 years of experience. You are helpful, empathetic, and solution-focused. Always maintain a professional yet friendly tone.',
                helpText: 'ğŸ‘¤ Define the AI\'s role, expertise, and behavior. This sets the foundation for all responses.'
            },
            userPromptTemplate: {
                label: 'User Prompt (Required)',
                type: 'textarea',
                placeholder: 'Analyze the following customer support ticket and provide a recommended response:\n\nTicket: {{ticket_text}}\nPriority: {{priority}}\nCustomer Tier: {{tier}}\n\nProvide:\n1. Issue summary\n2. Recommended resolution\n3. Escalation needed (yes/no)',
                helpText: 'ğŸ’¬ The main instruction telling the AI what to do. Use {{variables}} for dynamic content.'
            },
            fewShotExamples: {
                label: 'Examples (Recommended)',
                type: 'textarea',
                placeholder: '<example>\nInput: Customer reports login issue on mobile app\nOutput: {\n  "summary": "Authentication failure on iOS app",\n  "resolution": "Clear app cache and reinstall",\n  "escalate": "no"\n}\n</example>\n\n<example>\nInput: Customer requests refund for annual subscription\nOutput: {\n  "summary": "Refund request - annual plan",\n  "resolution": "Process pro-rated refund per policy",\n  "escalate": "yes"\n}\n</example>',
                helpText: 'ğŸ“š Show 2-3 examples of input â†’ output. This dramatically improves accuracy and consistency.'
            },
            outputFormat: {
                label: 'Output Format (Recommended)',
                type: 'textarea',
                placeholder: 'Return your response as JSON with this exact structure:\n{\n  "summary": "brief issue description",\n  "resolution": "recommended action",\n  "escalate": "yes or no"\n}',
                helpText: 'ğŸ“ Specify exactly how you want the output structured (JSON, markdown, bullet points, etc.)'
            },
            chainOfThought: {
                label: 'Chain-of-Thought (Optional)',
                type: 'textarea',
                placeholder: 'Before providing your answer, think through this step-by-step:\n1. What is the core issue?\n2. What are possible solutions?\n3. Which solution is best and why?',
                helpText: 'ğŸ§  Ask the AI to "think out loud" before answering. Improves reasoning quality.'
            },
            modelTarget: {
                label: 'Target Model',
                type: 'select',
                options: ['Claude 3.5 Sonnet', 'Claude 3 Opus', 'GPT-4o', 'GPT-4 Turbo', 'o1-preview'],
                helpText: 'ğŸ¤– Which AI model this prompt is optimized for'
            },
            temperature: {
                label: 'Temperature',
                type: 'number',
                min: 0,
                max: 1,
                step: 0.1,
                placeholder: '0.7',
                helpText: 'ğŸŒ¡ï¸ 0 = consistent/factual, 1 = creative/varied. Use 0-0.3 for analysis, 0.7-1.0 for creative writing.'
            },
            testResults: {
                label: 'Test Results',
                type: 'textarea',
                placeholder: 'Tested on 50 examples:\nâœ… 94% accuracy\nâš¡ Avg response time: 1.3s\nğŸ’° Cost per request: $0.015',
                helpText: 'âœ… Track how well this prompt performs on real test cases'
            },
            testStatus: {
                label: 'Status',
                type: 'select',
                options: ['Draft', 'Testing', 'Validated', 'Production', 'Deprecated'],
                helpText: 'âœ… Development stage'
            },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    familytree: {
        name: 'Family Tree',
        icon: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦',
        levels: {
            root: 'Family',
            phase: 'Generation',
            item: 'Person',
            subtask: 'Event'
        },
        phaseSubtitles: ['Self/Siblings', 'Parents', 'Grandparents', 'Great-Grandparents', 'Great-Great-Grandparents', 'Children', 'Grandchildren', 'Great-Grandchildren'],
        types: [
            { value: 'paternal', label: 'Paternal Line' },
            { value: 'maternal', label: 'Maternal Line' },
            { value: 'spouse', label: 'Spouse' },
            { value: 'biological', label: 'Biological' },
            { value: 'adopted', label: 'Adopted' },
            { value: 'step', label: 'Step-Family' },
            { value: 'foster', label: 'Foster' },
            { value: 'half', label: 'Half-Sibling' }
        ],
        description: 'Build and document your family genealogy',
        fields: {
            fullName: { label: 'Full Name', type: 'text', placeholder: 'First Middle Last...', helpText: 'ğŸ‘¤ Complete name including middle names' },
            maidenName: { label: 'Maiden Name', type: 'text', placeholder: 'Birth surname if different...', helpText: 'ğŸ’ Birth surname (if changed after marriage)' },
            gender: { label: 'Gender', type: 'select', options: ['Male', 'Female', 'Other', 'Unknown'], helpText: 'âš§ Gender identity' },
            birthDate: { label: 'Birth Date', type: 'date', helpText: 'ğŸ‚ Date of birth' },
            birthPlace: { label: 'Birth Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'ğŸ“ Place of birth (city, state, country)' },
            livingStatus: { label: 'Living Status', type: 'select', options: ['Living', 'Deceased', 'Unknown'], helpText: 'ğŸ’š Current living status' },
            deathDate: { label: 'Death Date', type: 'date', helpText: 'ğŸ•Šï¸ Date of death (if deceased)' },
            deathPlace: { label: 'Death Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'ğŸ“ Place of death (if deceased)' },
            marriageDate: { label: 'Marriage Date', type: 'date', helpText: 'ğŸ’’ Date of marriage' },
            marriagePlace: { label: 'Marriage Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'ğŸ“ Place of marriage ceremony' },
            spouseName: { label: 'Spouse Name', type: 'text', placeholder: 'Name of spouse...', helpText: 'ğŸ’‘ Current or former spouse' },
            occupation: { label: 'Occupation', type: 'text', placeholder: 'Profession or career...', helpText: 'ğŸ’¼ Primary occupation or career' },
            photoURL: { label: 'Photo URL', type: 'text', placeholder: 'https://...', helpText: 'ğŸ“· Link to portrait or photo' },
            dnaInfo: { label: 'DNA/Genetic Info', type: 'textarea', placeholder: 'Haplogroup, DNA matches, test results...', helpText: 'ğŸ§¬ DNA test results, haplogroups, genetic markers' },
            sources: { label: 'Sources/Citations', type: 'textarea', placeholder: 'Documents, certificates, records...', helpText: 'ğŸ“„ Birth certificates, census records, documents' },
            relationshipType: { label: 'Relationship Type', type: 'select', options: ['Biological', 'Adopted', 'Step', 'Foster', 'Half-Sibling', 'Unknown'], helpText: 'ğŸ”— Type of family relationship' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    dialogue: {
        name: 'Dialogue & Rhetoric',
        icon: 'ğŸ’¬',
        levels: {
            root: 'Conversation',
            phase: 'Speaker',
            item: 'Statement',
            subtask: 'Point'
        },
        phaseSubtitles: ['Speaker A', 'Speaker B', 'Speaker C', 'Moderator'],
        types: [
            { value: 'logical', label: 'ğŸ§  Logical Argument' },
            { value: 'emotional', label: 'â¤ï¸ Emotional Appeal (Pathos)' },
            { value: 'ethical', label: 'âš–ï¸ Ethical Appeal (Ethos)' },
            { value: 'statistical', label: 'ğŸ“Š Statistical Evidence' },
            { value: 'anecdotal', label: 'ğŸ“– Anecdotal Evidence' },
            { value: 'rhetorical-question', label: 'â“ Rhetorical Question' },
            { value: 'counterargument', label: 'ğŸ”„ Counterargument' },
            { value: 'deflection', label: 'â†©ï¸ Deflection/Dodge' },
            { value: 'concession', label: 'ğŸ¤ Concession/Agreement' }
        ],
        description: 'Analyze conversations, debates, and rhetoric to uncover hidden logic, fallacies, and motivations',
        fields: {
            speaker: {
                label: 'Speaker/Character',
                type: 'text',
                placeholder: 'e.g., Senator Jane Smith, John (protagonist), Anonymous commenter...',
                helpText: 'ğŸ‘¤ Who is making this statement? Include role, title, or context if known'
            },
            verbatimQuote: {
                label: 'Verbatim Quote',
                type: 'textarea',
                placeholder: 'Copy/paste the exact words spoken or written...',
                helpText: 'ğŸ’¬ The actual statement, word-for-word. Essential for accurate analysis of rhetoric and tone'
            },
            rhetoricalDevice: {
                label: 'Rhetorical Device Used',
                type: 'select',
                options: ['Logos (Logic)', 'Pathos (Emotion)', 'Ethos (Credibility)', 'Kairos (Timing)', 'Metaphor', 'Analogy', 'Repetition', 'Hyperbole', 'Irony', 'Appeal to Authority', 'None'],
                helpText: 'ğŸ­ Primary rhetorical technique used to persuade or communicate. Identify the dominant device'
            },
            logicalStructure: {
                label: 'Logical Structure',
                type: 'textarea',
                placeholder: 'Premise 1: All experts agree...\nPremise 2: Dr. Chen is an expert...\nConclusion: Therefore, Dr. Chen\'s view is valid',
                helpText: 'ğŸ§© Break down the argument into premises and conclusion. How does the speaker construct their logic?'
            },
            fallaciesPresent: {
                label: 'Fallacies Present',
                type: 'textarea',
                placeholder: 'Ad hominem: Attacks opponent\'s character instead of argument\nStraw man: Misrepresents opponent\'s position...',
                helpText: 'âš ï¸ Identify any logical fallacies (ad hominem, straw man, slippery slope, false dichotomy, etc.) and explain how they appear'
            },
            hiddenMotivation: {
                label: 'Hidden Motivation/Subtext',
                type: 'textarea',
                placeholder: 'Surface: Arguing for policy change\nHidden: Positioning for re-election, deflecting from scandal, protecting financial interests...',
                helpText: 'ğŸ” What unstated goals or motivations might underlie this statement? Consider political, financial, or personal incentives'
            },
            emotionalTone: {
                label: 'Emotional Tone',
                type: 'select',
                options: ['Calm/Neutral', 'Passionate', 'Angry', 'Defensive', 'Condescending', 'Empathetic', 'Dismissive', 'Fearful', 'Confident', 'Sarcastic'],
                helpText: 'ğŸ­ The emotional delivery and affect. How does tone enhance or undermine the message?'
            },
            counterargument: {
                label: 'Strongest Counterargument',
                type: 'textarea',
                placeholder: 'The strongest rebuttal would be: "While the speaker claims X, evidence shows Y because..."',
                helpText: 'ğŸ”„ What is the most effective counter to this statement? Build the opposing case using logic and evidence'
            },
            evidenceQuality: {
                label: 'Evidence Quality',
                type: 'select',
                options: ['Strong (Peer-reviewed, verified)', 'Moderate (Credible sources)', 'Weak (Anecdotal, unverified)', 'None (Opinion only)', 'Misleading (Cherry-picked data)'],
                helpText: 'ğŸ“Š Assess the strength and credibility of any evidence or data cited. Is it rigorous or rhetorical?'
            },
            effectivenessRating: {
                label: 'Persuasiveness Rating',
                type: 'number',
                min: 1,
                max: 10,
                step: 1,
                placeholder: '7',
                helpText: 'ğŸ¯ Rate 1-10: How persuasive is this statement to the target audience? (1=unconvincing, 10=highly compelling)'
            },
            includeDependencies: true,
            includeTracking: false
        }
    },
    filesystem: {
        name: 'File System',
        icon: 'ğŸ’¾',
        isFlexibleDepth: true,
        levels: {
            root: 'Drive',
            phase: 'Folder',
            item: 'File/Folder',
            subtask: 'File'
        },
        phaseSubtitles: ['Documents', 'Downloads', 'Desktop', 'Pictures', 'Videos', 'Projects'],
        types: [
            // Folder types
            { value: 'folder', label: 'ğŸ“ Folder' },
            { value: 'folder-shared', label: 'ğŸ“‚ Shared Folder' },
            { value: 'folder-cloud', label: 'â˜ï¸ Cloud Folder' },

            // Document types
            { value: 'pdf', label: 'ğŸ“• PDF' },
            { value: 'word', label: 'ğŸ“˜ Word Doc' },
            { value: 'excel', label: 'ğŸ“— Spreadsheet' },
            { value: 'powerpoint', label: 'ğŸ“™ Presentation' },
            { value: 'text', label: 'ğŸ“ Text File' },
            { value: 'document', label: 'ğŸ“„ Document' },

            // Media types
            { value: 'image', label: 'ğŸ–¼ï¸ Image' },
            { value: 'video', label: 'ğŸ¬ Video' },
            { value: 'audio', label: 'ğŸµ Audio' },

            // Code types
            { value: 'code', label: 'ğŸ’» Code' },
            { value: 'html', label: 'ğŸŒ HTML' },
            { value: 'css', label: 'ğŸ¨ CSS' },
            { value: 'javascript', label: 'âš¡ JavaScript' },
            { value: 'python', label: 'ğŸ Python' },

            // Archive types
            { value: 'archive', label: 'ğŸ“¦ Archive' },
            { value: 'zip', label: 'ğŸ—œï¸ ZIP' },

            // Other
            { value: 'executable', label: 'âš™ï¸ Executable' },
            { value: 'database', label: 'ğŸ—„ï¸ Database' },
            { value: 'unknown', label: 'â“ Unknown' }
        ],
        description: 'Organize files and folders from local drives, Google Drive, and OneDrive',
        sortOptions: [
            { value: 'name-az', label: 'ğŸ”¤ Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ğŸ”¤ Name (Z-A)', field: 'name', order: 'desc', type: 'text' },
            { value: 'size-large', label: 'ğŸ“Š Size (Largest First)', field: 'fileSize', order: 'desc', type: 'number' },
            { value: 'size-small', label: 'ğŸ“Š Size (Smallest First)', field: 'fileSize', order: 'asc', type: 'number' },
            { value: 'modified-newest', label: 'ğŸ•’ Modified (Newest First)', field: 'dateModified', order: 'desc', type: 'date' },
            { value: 'modified-oldest', label: 'ğŸ•’ Modified (Oldest First)', field: 'dateModified', order: 'asc', type: 'date' },
            { value: 'created-newest', label: 'ğŸ“… Created (Newest First)', field: 'dateCreated', order: 'desc', type: 'date' },
            { value: 'created-oldest', label: 'ğŸ“… Created (Oldest First)', field: 'dateCreated', order: 'asc', type: 'date' },
            { value: 'type-folders-first', label: 'ğŸ“ Type (Folders First)', field: 'isFolder', order: 'desc', type: 'boolean' },
            { value: 'type-files-first', label: 'ğŸ“„ Type (Files First)', field: 'isFolder', order: 'asc', type: 'boolean' },
            { value: 'extension-az', label: 'ğŸ·ï¸ Extension (A-Z)', field: 'fileExtension', order: 'asc', type: 'text' },
            { value: 'extension-za', label: 'ğŸ·ï¸ Extension (Z-A)', field: 'fileExtension', order: 'desc', type: 'text' },
            { value: 'owner-az', label: 'ğŸ‘¤ Owner (A-Z)', field: 'fileOwner', order: 'asc', type: 'text' },
            { value: 'owner-za', label: 'ğŸ‘¤ Owner (Z-A)', field: 'fileOwner', order: 'desc', type: 'text' }
        ],
        fields: {
            fileSize: {
                label: 'File Size (bytes)',
                type: 'number',
                min: 0,
                step: 1,
                placeholder: '2500000',
                helpText: 'ğŸ“Š Size in bytes (will be formatted as KB/MB/GB)'
            },
            fileExtension: {
                label: 'File Extension',
                type: 'text',
                placeholder: '.pdf, .docx, .jpg...',
                helpText: 'ğŸ·ï¸ File type extension (e.g., .pdf, .docx, .mp4)'
            },
            filePath: {
                label: 'Full Path',
                type: 'text',
                placeholder: 'C:\\Users\\Documents\\file.pdf',
                helpText: 'ğŸ“‚ Complete file path'
            },
            dateModified: {
                label: 'Date Modified',
                type: 'datetime-local',
                helpText: 'ğŸ•’ Last modification date and time'
            },
            dateCreated: {
                label: 'Date Created',
                type: 'datetime-local',
                helpText: 'ğŸ“… Creation date and time'
            },
            fileOwner: {
                label: 'Owner',
                type: 'text',
                placeholder: 'john.doe@company.com',
                helpText: 'ğŸ‘¤ File owner (for cloud files)'
            },
            sharedWith: {
                label: 'Shared With',
                type: 'textarea',
                placeholder: 'user1@email.com, user2@email.com...',
                helpText: 'ğŸ‘¥ Users with access (for cloud files)'
            },
            permissions: {
                label: 'Permissions',
                type: 'select',
                options: ['Read Only', 'Read/Write', 'Owner', 'Viewer', 'Editor', 'Commenter'],
                helpText: 'ğŸ”’ Access permissions'
            },
            driveType: {
                label: 'Drive Type',
                type: 'select',
                options: ['Local Drive', 'Google Drive', 'OneDrive', 'Dropbox', 'Network Drive', 'External Drive'],
                helpText: 'ğŸ’¾ Storage location type'
            },
            mimeType: {
                label: 'MIME Type',
                type: 'text',
                placeholder: 'application/pdf, image/jpeg...',
                helpText: 'ğŸ“‹ File MIME type (for web/cloud files)'
            },
            tags: {
                label: 'Tags',
                type: 'text',
                placeholder: 'work, important, archive...',
                helpText: 'ğŸ·ï¸ Custom tags for organization'
            },
            fileUrl: {
                label: 'Cloud URL',
                type: 'text',
                placeholder: 'https://drive.google.com/...',
                helpText: 'ğŸ”— Direct link to cloud file'
            },
            isFolder: {
                label: 'Is Folder',
                type: 'checkbox',
                helpText: 'ğŸ“ Check if this is a folder (not a file)'
            },
            includeDependencies: false,
            includeTracking: false
        }
    },
    gmail: {
        name: 'Email Workflow',
        icon: 'ğŸ“§',
        levels: {
            root: 'Inbox/Campaign',
            phase: 'Label/Stage',
            item: 'Thread',
            subtask: 'Message'
        },
        phaseSubtitles: ['Inbox', 'Sent', 'Important', 'Archive'],
        types: [
            { value: 'cold-outreach', label: 'â„ï¸ Cold Outreach' },
            { value: 'newsletter', label: 'ğŸ“° Newsletter' },
            { value: 'response', label: 'â†©ï¸ Response' },
            { value: 'follow-up', label: 'â¡ï¸ Follow-up' },
            { value: 'internal', label: 'ğŸ¢ Internal Update' },
            { value: 'transactional', label: 'ğŸ§¾ Transactional' }
        ],
        description: 'Import and analyze Gmail threads with full conversation context',
        sortOptions: [
            { value: 'date-newest', label: 'ğŸ“… Date (Newest First)', field: 'sendDate', order: 'desc', type: 'date' },
            { value: 'date-oldest', label: 'ğŸ“… Date (Oldest First)', field: 'sendDate', order: 'asc', type: 'date' },
            { value: 'subject-az', label: 'ğŸ”¤ Subject (A-Z)', field: 'subjectLine', order: 'asc', type: 'text' },
            { value: 'subject-za', label: 'ğŸ”¤ Subject (Z-A)', field: 'subjectLine', order: 'desc', type: 'text' },
            { value: 'messages-most', label: 'ğŸ’¬ Messages (Most First)', field: 'messageCount', order: 'desc', type: 'number' },
            { value: 'messages-least', label: 'ğŸ’¬ Messages (Least First)', field: 'messageCount', order: 'asc', type: 'number' }
        ],
        fields: {
            recipientEmail: {
                label: 'To (Email)',
                type: 'text',
                placeholder: 'client@company.com',
                helpText: 'ğŸ‘¤ Primary recipient address'
            },
            ccEmail: {
                label: 'CC',
                type: 'text',
                placeholder: 'manager@company.com',
                helpText: 'ğŸ‘¥ Carbon copy recipients'
            },
            subjectLine: {
                label: 'Subject Line',
                type: 'text',
                placeholder: 'Meeting Request: Q4 Planning',
                helpText: 'ğŸ“ The email subject line'
            },
            emailBody: {
                label: 'Email Body',
                type: 'textarea',
                placeholder: 'Hi [Name],\n\nWriting to follow up on...',
                helpText: 'âœï¸ The main content of the email'
            },
            sendDate: {
                label: 'Date Sent',
                type: 'date',
                helpText: 'ğŸ“… When this email was sent/received'
            },
            status: {
                label: 'Status',
                type: 'select',
                options: ['Draft', 'Ready', 'Sent', 'Replied', 'Archived'],
                helpText: 'ğŸ“¬ Email status'
            },
            threadId: {
                label: 'Thread ID',
                type: 'text',
                placeholder: 'Gmail thread ID',
                helpText: 'ğŸ”— Gmail thread identifier'
            },
            messageCount: {
                label: 'Message Count',
                type: 'number',
                min: 1,
                helpText: 'ğŸ’¬ Number of messages in this thread'
            },
            sender: {
                label: 'Sender',
                type: 'text',
                placeholder: 'john@company.com',
                helpText: 'ğŸ‘¤ Email sender'
            },
            labels: {
                label: 'Gmail Labels',
                type: 'text',
                placeholder: 'INBOX, IMPORTANT, SENT',
                helpText: 'ğŸ·ï¸ Gmail labels/categories'
            },
            includeDependencies: true,
            includeTracking: true
        }
    },
    'knowledge-base': {
        name: 'Knowledge Base',
        icon: 'ğŸ“š',
        levels: {
            root: 'Knowledge Base',
            phase: 'Source',
            item: 'Section',
            subtask: 'Chunk'
        },
        phaseSubtitles: ['Documents', 'Web Pages', 'Notes', 'Research'],
        types: [
            { value: 'pdf', label: 'ğŸ“„ PDF Document' },
            { value: 'webpage', label: 'ğŸŒ Web Page' },
            { value: 'text', label: 'ğŸ“ Plain Text' },
            { value: 'markdown', label: 'ğŸ“‹ Markdown' },
            { value: 'note', label: 'ğŸ—’ï¸ Personal Note' },
            { value: 'research', label: 'ğŸ”¬ Research Paper' },
            { value: 'article', label: 'ğŸ“° Article' },
            { value: 'transcript', label: 'ğŸ™ï¸ Transcript' }
        ],
        description: 'Document corpus for knowledge retrieval and AI context',
        sortOptions: [
            { value: 'date-newest', label: 'ğŸ“… Date (Newest First)', field: 'importDate', order: 'desc', type: 'date' },
            { value: 'date-oldest', label: 'ğŸ“… Date (Oldest First)', field: 'importDate', order: 'asc', type: 'date' },
            { value: 'title-az', label: 'ğŸ”¤ Title (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'title-za', label: 'ğŸ”¤ Title (Z-A)', field: 'name', order: 'desc', type: 'text' },
            { value: 'relevance', label: 'â­ Relevance Score', field: 'relevanceScore', order: 'desc', type: 'number' }
        ],
        fields: {
            sourceUrl: {
                label: 'Source URL',
                type: 'text',
                placeholder: 'https://example.com/article',
                helpText: 'ğŸ”— Original source location'
            },
            sourceType: {
                label: 'Source Type',
                type: 'select',
                options: ['PDF', 'Web Page', 'Plain Text', 'Markdown', 'Note', 'Transcript'],
                helpText: 'ğŸ“ Type of source document'
            },
            importDate: {
                label: 'Import Date',
                type: 'date',
                helpText: 'ğŸ“… When this content was imported'
            },
            author: {
                label: 'Author',
                type: 'text',
                placeholder: 'Author name',
                helpText: 'âœï¸ Content author or source'
            },
            wordCount: {
                label: 'Word Count',
                type: 'number',
                helpText: 'ğŸ“Š Total words in this section'
            },
            chunkIndex: {
                label: 'Chunk Index',
                type: 'number',
                helpText: 'ğŸ”¢ Position in source document'
            },
            relevanceScore: {
                label: 'Relevance',
                type: 'number',
                min: 0,
                max: 100,
                helpText: 'â­ How relevant this content is (0-100)'
            },
            tags: {
                label: 'Tags',
                type: 'text',
                placeholder: 'tag1, tag2, tag3',
                helpText: 'ğŸ·ï¸ Comma-separated keywords'
            },
            includeDependencies: false,
            includeTracking: false
        }
    },
    capex: {
        name: 'CAPEX / Angel Pitch',
        icon: 'ğŸ’°',
        levels: {
            root: 'Project',
            phase: 'Funding Phase',
            item: 'Investment',
            subtask: 'Deliverable'
        },
        phaseSubtitles: ['Seed', 'Series A', 'Series B'],
        types: [
            { value: 'equipment', label: 'Equipment' },
            { value: 'infrastructure', label: 'Infrastructure' },
            { value: 'validation', label: 'Validation' },
            { value: 'development', label: 'Development' },
            { value: 'milestone', label: 'Milestone' },
            { value: 'risk-mitigation', label: 'Risk Mitigation' },
            { value: 'working-capital', label: 'Working Capital' },
            { value: 'personnel', label: 'Personnel' }
        ],
        description: 'Investor-ready capital expenditure structure for fundraising',
        sortOptions: [
            { value: 'cost-high', label: 'ğŸ’° Cost (Highest First)', field: 'cost', order: 'desc', type: 'number' },
            { value: 'cost-low', label: 'ğŸ’° Cost (Lowest First)', field: 'cost', order: 'asc', type: 'number' },
            { value: 'name-az', label: 'ğŸ”¤ Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ğŸ”¤ Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ],
        fields: {
            cost: { label: 'Cost ($)', type: 'number', step: 1000, helpText: 'ğŸ’° Capital expenditure for this item' },
            risk: { label: 'Key Risk', type: 'text', placeholder: 'Primary risk associated with this item...', helpText: 'âš ï¸ Main risk investors should know about' },
            mitigation: { label: 'Mitigation', type: 'text', placeholder: 'How we address this risk...', helpText: 'ğŸ›¡ï¸ Specific strategy to mitigate the risk' },
            valuationImpact: { label: 'Valuation Impact', type: 'text', placeholder: 'e.g., Enables 2x ARR, De-risks Series A...', helpText: 'ğŸ“ˆ How this investment affects company valuation' },
            leadTime: { label: 'Lead Time', type: 'text', placeholder: 'e.g., 12 weeks, 6 months...', helpText: 'â±ï¸ Time to complete or procure' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    freespeech: {
        name: 'Free Speech',
        icon: 'ğŸ™ï¸',
        levels: {
            root: 'Session',
            phase: 'Theme',
            item: 'Pattern',
            subtask: 'Evidence'
        },
        phaseSubtitles: ['Surface Themes', 'Hidden Patterns', 'Contradictions', 'Silences', 'Recurring Structures'],
        types: [
            { value: 'repetition', label: 'ğŸ” Repetition (mentioned multiple times)' },
            { value: 'emotional', label: 'â¤ï¸ Emotional Weight (intensity markers)' },
            { value: 'contradiction', label: 'âš¡ Contradiction (opposing statements)' },
            { value: 'avoidance', label: 'ğŸ•³ï¸ Avoidance (logical gaps)' },
            { value: 'implicit', label: 'ğŸ’­ Implicit Belief (unstated assumption)' },
            { value: 'entity', label: 'ğŸ‘¤ Named Entity (person/thing mentioned)' },
            { value: 'structure', label: 'ğŸ“ Sentence Structure (grammar pattern)' }
        ],
        description: 'Stream-of-consciousness voice capture with psychological pattern analysis',
        sortOptions: [
            { value: 'frequency-high', label: 'ğŸ”¢ Frequency (Most First)', field: 'frequency', order: 'desc', type: 'number' },
            { value: 'frequency-low', label: 'ğŸ”¢ Frequency (Least First)', field: 'frequency', order: 'asc', type: 'number' },
            { value: 'emotional-high', label: 'ğŸ’“ Emotional Intensity (Highest)', field: 'emotionalIntensity', order: 'desc', type: 'text' },
            { value: 'emotional-low', label: 'ğŸ’“ Emotional Intensity (Lowest)', field: 'emotionalIntensity', order: 'asc', type: 'text' }
        ],
        fields: {
            frequency: {
                label: 'Frequency',
                type: 'number',
                min: 1,
                step: 1,
                helpText: 'ğŸ”¢ Times this pattern appeared in speech'
            },
            emotionalIntensity: {
                label: 'Emotional Intensity',
                type: 'select',
                options: ['Low', 'Medium', 'High', 'Peak'],
                helpText: 'ğŸ’“ Detected emotional weight of this pattern'
            },
            quotedText: {
                label: 'Quoted Text',
                type: 'textarea',
                placeholder: 'Exact words from transcript...',
                helpText: 'ğŸ’¬ Verbatim speech that evidences this pattern'
            },
            insight: {
                label: 'AI Insight',
                type: 'textarea',
                placeholder: 'What this pattern reveals about the speaker...',
                helpText: 'ğŸ”® Psychological interpretation of what this pattern suggests'
            },
            includeDependencies: false,
            includeTracking: false
        }
    },
    lifetree: {
        name: 'LifeTree',
        icon: 'ğŸŒ³',
        levels: {
            root: 'Life',
            phase: 'Decade',
            item: 'Event',
            subtask: 'Detail'
        },
        phaseSubtitles: [], // Auto-generated from birth year
        types: [
            { value: 'birth', label: 'Birth' },
            { value: 'family', label: 'Family' },
            { value: 'education', label: 'Education' },
            { value: 'career', label: 'Career' },
            { value: 'relationship', label: 'Relationship' },
            { value: 'residence', label: 'Residence/Move' },
            { value: 'health', label: 'Health' },
            { value: 'milestone', label: 'Milestone' },
            { value: 'loss', label: 'Loss' },
            { value: 'travel', label: 'Travel' },
            { value: 'achievement', label: 'Achievement' },
            { value: 'memory', label: 'Memory/Story' }
        ],
        description: 'Biographical timeline for a life story',
        sortOptions: [
            { value: 'date-oldest', label: 'ğŸ“… Date (Oldest First)', field: 'eventDate', order: 'asc', type: 'date' },
            { value: 'date-newest', label: 'ğŸ“… Date (Newest First)', field: 'eventDate', order: 'desc', type: 'date' },
            { value: 'age-youngest', label: 'ğŸ‚ Age (Youngest First)', field: 'age', order: 'asc', type: 'number' },
            { value: 'age-oldest', label: 'ğŸ‚ Age (Oldest First)', field: 'age', order: 'desc', type: 'number' },
            { value: 'emotion', label: 'ğŸ’­ By Emotion', field: 'emotion', order: 'asc', type: 'text' },
            { value: 'type', label: 'ğŸ“ By Type', field: 'itemType', order: 'asc', type: 'text' }
        ],
        fields: {
            eventDate: {
                label: 'When',
                type: 'text',
                placeholder: 'March 1965, Summer 1952, age 7...',
                helpText: 'ğŸ“… Date or approximate time (AI parses natural language)'
            },
            age: {
                label: 'Age',
                type: 'number',
                computed: true,
                helpText: 'ğŸ‚ Auto-calculated from birth year'
            },
            location: {
                label: 'Where',
                type: 'text',
                placeholder: 'Brooklyn, NY...',
                helpText: 'ğŸ“ Location of this event'
            },
            people: {
                label: 'Who',
                type: 'text',
                placeholder: 'Dad, Aunt Rose, friend Betty...',
                helpText: 'ğŸ‘¥ People involved in this event'
            },
            emotion: {
                label: 'Feeling',
                type: 'select',
                options: ['Joyful', 'Proud', 'Bittersweet', 'Difficult', 'Routine', 'Milestone'],
                helpText: 'ğŸ’­ Emotional tone of this memory'
            },
            source: {
                label: 'Remembered by',
                type: 'text',
                placeholder: 'Mom, sister, family letter...',
                helpText: 'ğŸ—£ï¸ Who contributed this memory'
            },
            confidence: {
                label: 'Certainty',
                type: 'select',
                options: ['Exact', 'Approximate', 'Family legend'],
                helpText: 'ğŸ¯ How certain is this date/detail?'
            },
            historicalContext: {
                label: 'Historical Context',
                type: 'textarea',
                placeholder: 'AI-generated: what was happening in the world...',
                computed: true,
                helpText: 'ğŸŒ World events at this time'
            },
            locationContext: {
                label: 'Location Context',
                type: 'textarea',
                placeholder: 'AI-generated: what this place was like...',
                computed: true,
                helpText: 'ğŸ˜ï¸ What this location was like then'
            },
            mediaUrl: {
                label: 'Photo/Document',
                type: 'text',
                placeholder: 'URL or file path...',
                helpText: 'ğŸ“· Attach image or document'
            },
            includeDependencies: false,
            includeTracking: false
        },
        // LifeTree-specific metadata
        requiresBirthYear: true,
        supportsDeathYear: true,
        autoGenerateDecades: true
    },
    custom: {
        name: 'Custom Names',
        icon: 'âœï¸',
        levels: {
            root: 'Level 0',
            phase: 'Level 1',
            item: 'Level 2',
            subtask: 'Level 3'
        },
        description: 'Define your own names for all four levels',
        customizable: true
    }
};

// =============================================================================
// MIGRATION & SCHEMA MANAGEMENT (Cognitive Citadel Foundation)
// =============================================================================

const SCHEMA_VERSION = 1;

/**
 * Recursively normalizes node structure and adds defense fields
 */
// ============================================================================
// ATLAS IDENTITY INFRASTRUCTURE (Build 573 - Phase-0 Identity Lockdown)
// Foundation for cross-tree intelligence: stable IDs that survive moves/renames
// ============================================================================

/**
 * Generate a unique tree identifier.
 * Format: tree_XXXXXXXX (8 random hex chars)
 * This ID is immutable once created - survives file renames.
 */
function generateTreeId() {
    const bytes = new Uint8Array(4);
    crypto.getRandomValues(bytes);
    const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    return `tree_${hex}`;
}

/**
 * Generate a unique node identifier.
 * Format: n_XXXXXXXX (8 random hex chars)
 * This ID is stable - survives node moves within tree.
 */
function generateNodeGuid() {
    const bytes = new Uint8Array(4);
    crypto.getRandomValues(bytes);
    const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    return `n_${hex}`;
}

/**
 * THE SINGLE SOURCE OF TRUTH FOR ATLAS IDENTITY
 * Get the Atlas UID for a node. Use this EVERYWHERE in Atlas code.
 * Never reference node.id directly in Atlas - use this function.
 *
 * @param {string} treeId - The tree's immutable ID
 * @param {object} node - The node object
 * @returns {string} The composite UID (treeId:nodeGuid)
 * @throws {Error} If node is missing nodeGuid
 */
function uidOf(treeId, node) {
    if (!node) {
        throw new Error('[Atlas] uidOf called with null/undefined node');
    }
    if (!node.nodeGuid) {
        // Auto-generate if missing (migration path)
        console.warn(`[Atlas] Node missing nodeGuid: ${node.id || 'unknown'}, auto-generating`);
        node.nodeGuid = generateNodeGuid();
    }
    if (!treeId) {
        throw new Error('[Atlas] uidOf called with null/undefined treeId');
    }
    return `${treeId}:${node.nodeGuid}`;
}

/**
 * Parse a UID back into components
 * @param {string} uid - The composite UID (treeId:nodeGuid)
 * @returns {{treeId: string, nodeGuid: string}}
 * @throws {Error} If UID format is invalid
 */
function parseUid(uid) {
    if (!uid || typeof uid !== 'string') {
        throw new Error(`[Atlas] Invalid UID: ${uid}`);
    }
    const colonIdx = uid.indexOf(':');
    if (colonIdx === -1) {
        throw new Error(`[Atlas] Invalid UID format (missing colon): ${uid}`);
    }
    return {
        treeId: uid.substring(0, colonIdx),
        nodeGuid: uid.substring(colonIdx + 1)
    };
}

/**
 * CANONICAL LINK PATTERN
 * Matches: [[text]], [[uid:tree:node]], [[uid:tree:node|Alias]]
 * Groups: Full content inside brackets
 */
const ATLAS_LINK_PATTERN = /\[\[((?:uid:[^|\]]+|[^|\]]+)(?:\|[^\]]+)?)\]\]/g;

/**
 * Parse a link from ATLAS_LINK_PATTERN match
 * @param {string} content - The content inside [[ ]]
 * @returns {object} Parsed link info
 */
function parseAtlasLink(content) {
    if (content.startsWith('uid:')) {
        const pipeIdx = content.indexOf('|');
        if (pipeIdx > -1) {
            // Has alias: [[uid:tree:node|Display Text]]
            return {
                type: 'uid',
                uid: content.substring(4, pipeIdx),
                displayText: content.substring(pipeIdx + 1),
                raw: content
            };
        } else {
            // No alias: [[uid:tree:node]]
            return {
                type: 'uid',
                uid: content.substring(4),
                displayText: null,
                raw: content
            };
        }
    } else {
        // Soft link: [[Some Title]] or [[Title|Alias]]
        const pipeIdx = content.indexOf('|');
        if (pipeIdx > -1) {
            return {
                type: 'soft',
                searchText: content.substring(0, pipeIdx),
                displayText: content.substring(pipeIdx + 1),
                raw: content
            };
        } else {
            return {
                type: 'soft',
                searchText: content,
                displayText: content,
                raw: content
            };
        }
    }
}

/**
 * Migrate a single node to have a stable nodeGuid
 * @param {object} node - The node to migrate
 * @returns {boolean} True if migration was performed
 */
function migrateNodeIdentity(node) {
    if (!node) return false;

    let migrated = false;

    // Add nodeGuid if missing
    if (!node.nodeGuid) {
        node.nodeGuid = generateNodeGuid();
        migrated = true;
    }

    // Recurse through all child types
    if (node.children) {
        node.children.forEach(child => {
            if (migrateNodeIdentity(child)) migrated = true;
        });
    }
    if (node.items) {
        node.items.forEach(child => {
            if (migrateNodeIdentity(child)) migrated = true;
        });
    }
    if (node.subItems) {
        node.subItems.forEach(child => {
            if (migrateNodeIdentity(child)) migrated = true;
        });
    }
    if (node.subtasks) {
        node.subtasks.forEach(child => {
            if (migrateNodeIdentity(child)) migrated = true;
        });
    }

    return migrated;
}

/**
 * Migrate a tree to have stable Atlas identity (treeId, nodeGuids)
 * @param {object} tree - The tree root to migrate
 * @returns {boolean} True if migration was performed
 */
function migrateTreeIdentity(tree) {
    if (!tree) return false;

    let migrated = false;

    // Add treeId if missing
    if (!tree.treeId) {
        tree.treeId = generateTreeId();
        console.log(`[Atlas] Generated treeId: ${tree.treeId}`);
        migrated = true;
    }

    // Add nodeGuid to root
    if (!tree.nodeGuid) {
        tree.nodeGuid = generateNodeGuid();
        migrated = true;
    }

    // Migrate all nodes recursively
    if (migrateNodeIdentity(tree)) {
        migrated = true;
    }

    return migrated;
}

// ============================================================================
// ATLAS LINK RESOLUTION (Build 575 - Phase-1 Link Resolution)
// ============================================================================

/**
 * Find a node by name within a tree (case-insensitive, exact match first)
 * @param {object} tree - The tree to search
 * @param {string} searchText - The node name to find
 * @returns {object|null} The matching node or null
 */
function findNodeByName(tree, searchText) {
    if (!tree || !searchText) return null;

    const searchLower = searchText.toLowerCase().trim();
    let exactMatch = null;
    let partialMatch = null;

    function traverse(node) {
        if (!node) return;

        const nodeName = (node.name || '').toLowerCase().trim();

        // Exact match takes priority
        if (nodeName === searchLower) {
            exactMatch = node;
            return; // Found exact match, stop searching
        }

        // Track first partial match (starts with)
        if (!partialMatch && nodeName.startsWith(searchLower)) {
            partialMatch = node;
        }

        // Recurse through children
        if (node.children) node.children.forEach(traverse);
        if (node.items) node.items.forEach(traverse);
        if (node.subItems) node.subItems.forEach(traverse);
        if (node.subtasks) node.subtasks.forEach(traverse);
    }

    // Check root
    if ((tree.name || '').toLowerCase().trim() === searchLower) {
        return tree;
    }

    // Search children
    traverse(tree);

    return exactMatch || partialMatch;
}

/**
 * Find a node by its nodeGuid within a tree
 * @param {object} tree - The tree to search
 * @param {string} nodeGuid - The nodeGuid to find
 * @returns {object|null} The matching node or null
 */
function findNodeByGuid(tree, nodeGuid) {
    if (!tree || !nodeGuid) return null;

    let result = null;

    function traverse(node) {
        if (!node || result) return;

        if (node.nodeGuid === nodeGuid) {
            result = node;
            return;
        }

        // Recurse through children
        if (node.children) node.children.forEach(traverse);
        if (node.items) node.items.forEach(traverse);
        if (node.subItems) node.subItems.forEach(traverse);
        if (node.subtasks) node.subtasks.forEach(traverse);
    }

    // Check root
    if (tree.nodeGuid === nodeGuid) return tree;

    traverse(tree);
    return result;
}

/**
 * Resolve an Atlas link to a target node
 * @param {object} parsedLink - Output from parseAtlasLink()
 * @param {object} currentTree - The current tree (capexTree)
 * @returns {object} Resolution result {resolved, node, displayText, error}
 */
function resolveAtlasLink(parsedLink, currentTree) {
    if (!parsedLink) {
        return { resolved: false, node: null, error: 'No link provided' };
    }

    if (parsedLink.type === 'uid') {
        // UID link: [[uid:treeId:nodeGuid]] or [[uid:treeId:nodeGuid|Alias]]
        try {
            const { treeId, nodeGuid } = parseUid(parsedLink.uid);

            // Check if this is the current tree
            if (currentTree && currentTree.treeId === treeId) {
                const node = findNodeByGuid(currentTree, nodeGuid);
                if (node) {
                    return {
                        resolved: true,
                        node: node,
                        displayText: parsedLink.displayText || node.name || 'Unnamed Node',
                        isLocal: true
                    };
                }
            }

            // Cross-tree link - not yet implemented (Phase 2)
            return {
                resolved: false,
                node: null,
                displayText: parsedLink.displayText || parsedLink.uid,
                error: 'Cross-tree links not yet supported',
                isCrossTree: true,
                targetTreeId: treeId,
                targetNodeGuid: nodeGuid
            };
        } catch (e) {
            return {
                resolved: false,
                node: null,
                displayText: parsedLink.raw,
                error: e.message
            };
        }
    } else {
        // Soft link: [[Node Name]] or [[Node Name|Alias]]
        const node = findNodeByName(currentTree, parsedLink.searchText);

        if (node) {
            return {
                resolved: true,
                node: node,
                displayText: parsedLink.displayText || node.name,
                searchText: parsedLink.searchText
            };
        } else {
            return {
                resolved: false,
                node: null,
                displayText: parsedLink.displayText || parsedLink.searchText,
                error: `Node "${parsedLink.searchText}" not found`,
                searchText: parsedLink.searchText
            };
        }
    }
}

/**
 * Navigate to a node by clicking an Atlas link
 * @param {string} nodeId - The node.id to navigate to
 * @param {string} nodeGuid - The node.nodeGuid (optional, for future cross-tree)
 */
function handleAtlasLinkClick(nodeId, nodeGuid) {
    if (!nodeId) {
        console.warn('[Atlas] handleAtlasLinkClick called with no nodeId');
        return;
    }

    // Find the node in the current tree
    const node = findNodeByGuid(capexTree, nodeGuid) || findById(capexTree, nodeId);

    if (!node) {
        showToast(`Could not find node "${nodeId}"`, 'error');
        return;
    }

    // Select the node (this will update the info panel)
    if (typeof selectNode === 'function') {
        selectNode(node);
    }

    // Scroll to node if in tree view
    if (typeof scrollToNode === 'function') {
        scrollToNode(node);
    }

    console.log(`[Atlas] Navigated to: ${node.name} (${node.nodeGuid || node.id})`);
}

/**
 * Render Atlas links in text as clickable HTML elements
 * Converts [[link]] syntax to clickable spans
 * @param {string} text - The text containing Atlas links
 * @returns {string} HTML with clickable links
 */
function renderAtlasLinks(text) {
    if (!text || typeof text !== 'string') return text;

    // Use fresh regex to avoid state issues
    const pattern = /\[\[((?:uid:[^|\]]+|[^|\]]+)(?:\|[^\]]+)?)\]\]/g;

    return text.replace(pattern, (match, content) => {
        const parsed = parseAtlasLink(content);
        const resolution = resolveAtlasLink(parsed, capexTree);

        if (resolution.resolved && resolution.node) {
            // Resolved link - make clickable
            const nodeId = resolution.node.id;
            const nodeGuid = resolution.node.nodeGuid || '';
            const displayText = escapeHtml(resolution.displayText);

            return `<span class="atlas-link atlas-link-resolved"
                onclick="handleAtlasLinkClick('${escapeHtml(nodeId)}', '${escapeHtml(nodeGuid)}')"
                title="Go to: ${escapeHtml(resolution.node.name)}"
                style="color: #8b5cf6; cursor: pointer; text-decoration: underline; font-weight: 500;">
                ${displayText}
            </span>`;
        } else if (resolution.isCrossTree) {
            // Cross-tree link - show as pending (Phase 2)
            const displayText = escapeHtml(resolution.displayText);
            return `<span class="atlas-link atlas-link-cross-tree"
                title="Cross-tree link (not yet supported)"
                style="color: #6b7280; cursor: not-allowed; text-decoration: underline dotted;">
                ${displayText}
            </span>`;
        } else {
            // Unresolved link - show as broken
            const displayText = escapeHtml(resolution.displayText);
            const error = escapeHtml(resolution.error || 'Not found');
            return `<span class="atlas-link atlas-link-broken"
                title="${error}"
                style="color: #ef4444; text-decoration: underline wavy;">
                ${displayText}
            </span>`;
        }
    });
}

/**
 * Escape HTML special characters
 * @param {string} str - String to escape
 * @returns {string} Escaped string
 */
function escapeHtml(str) {
    if (!str) return '';
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

// ============================================================================
// END ATLAS IDENTITY INFRASTRUCTURE
// ============================================================================

function normalizeNode(node, source = 'legacy') {
    if (!node) return;

    // 1. Provenance Stamping
    if (!node.provenance) {
        node.provenance = {
            source: source,
            timestamp: new Date().toISOString(),
            modelId: null
        };
    }

    // 2. Phenomenology (The "Residue" - node-specific reflections)
    if (!node.phenomenology) {
        node.phenomenology = [];
    }

    // 3. Metrics (Attention Economics)
    if (!node.metrics) {
        node.metrics = {
            editCount: 0,
            focusTime: 0,
            lastModified: Date.now()
        };
    }

    // Recurse through all child types
    if (node.children) node.children.forEach(child => normalizeNode(child, source));
    if (node.items) node.items.forEach(child => normalizeNode(child, source));
    if (node.subItems) node.subItems.forEach(child => normalizeNode(child, source));
}

/**
 * Migrates tree to current SCHEMA_VERSION
 * Called on every file load to ensure backward compatibility
 */
function migrateTree(tree) {
    const currentVersion = tree.schemaVersion || 0;

    if (currentVersion < 1) {
        console.log(`ğŸ›¡ï¸ Migrating tree from v${currentVersion} to v1 (Cognitive Citadel Foundation)`);

        // Initialize Hyperedges if missing
        if (!tree.hyperedges) tree.hyperedges = [];

        // Initialize Snapshot references (for future IndexedDB storage)
        if (!tree.snapshotRefs) tree.snapshotRefs = [];

        // Normalize all nodes with legacy source
        normalizeNode(tree, 'legacy');

        tree.schemaVersion = 1;
        console.log('âœ… Migration to v1 complete');
    }

    if (currentVersion < 2) {
        console.log(`ğŸ” Migrating tree from v${currentVersion} to v2 (Atlas Identity Lockdown)`);

        // Add stable identity fields for Atlas cross-tree intelligence
        // - treeId: immutable identifier that survives file renames
        // - nodeGuid: stable identifier that survives node moves
        const migrated = migrateTreeIdentity(tree);

        if (migrated) {
            console.log(`[Atlas] Tree identity established: ${tree.treeId}`);
        }

        tree.schemaVersion = 2;
        console.log('âœ… Migration to v2 complete (Atlas Identity Lockdown)');
    }

    // Future migrations stack here:
    // if (currentVersion < 3) { ... }

    return tree;
}

// ============================================================================
// SMART JSON NORMALIZATION (Build 609)
// Converts any tree-like JSON into TreeListy's canonical schema
// ============================================================================

/**
 * Normalize any tree-like JSON to TreeListy's canonical schema.
 * Called automatically on import, before migrateTree().
 * @param {object} tree - The raw parsed JSON tree
 * @returns {object} Result with { tree: normalizedTree, fixes: string[] }
 */
function normalizeTreeStructure(tree) {
    if (!tree || typeof tree !== 'object') {
        return { tree: { id: 'root', type: 'root', name: 'New Tree', expanded: true, children: [], hyperedges: [] }, fixes: ['created empty tree'] };
    }

    const fixes = [];
    const normalized = JSON.parse(JSON.stringify(tree));

    normalizeRootNode(normalized, fixes);
    normalizeChildrenRecursive(normalized, 0, fixes);
    ensureRequiredArrays(normalized, fixes);

    return { tree: normalized, fixes };
}

function normalizeRootNode(node, fixes) {
    // ID normalization
    if (!node.id) {
        node.id = 'root';
        fixes.push('missing root ID');
    }

    // Type normalization
    if (!node.type) {
        node.type = 'root';
        fixes.push('missing types');
    }

    // Name from title fallback
    if (!node.name && node.title) {
        node.name = node.title;
        delete node.title;
        fixes.push('title->name');
    }

    // Expanded state
    if (node.expanded !== true) {
        node.expanded = true;
        fixes.push('root expanded');
    }

    // Pattern normalization - string to object
    if (node.pattern && typeof node.pattern === 'string') {
        node.pattern = { key: node.pattern };
        fixes.push('pattern->object');
    }

    // Normalize child array at root level
    normalizeChildArrayForDepth(node, 0, fixes);
}

function normalizeChildArrayForDepth(node, depth, fixes) {
    if (depth === 0) {
        // Root: canonical property is 'children'
        if (!node.children) {
            node.children = node.items || node.subItems || node.subtasks || [];
            if (node.items) { delete node.items; fixes.push('items->children'); }
            if (node.subItems) { delete node.subItems; fixes.push('subItems->children'); }
            if (node.subtasks) { delete node.subtasks; fixes.push('subtasks->children'); }
        }
    } else if (depth === 1) {
        // Phase: canonical property is 'items'
        if (!node.items) {
            node.items = node.children || node.subItems || node.subtasks || [];
            if (node.children) { delete node.children; fixes.push('children->items'); }
            if (node.subItems) { delete node.subItems; fixes.push('subItems->items'); }
            if (node.subtasks) { delete node.subtasks; fixes.push('subtasks->items'); }
        }
    } else if (depth === 2) {
        // Item: canonical property is 'subtasks'
        if (!node.subtasks) {
            node.subtasks = node.children || node.items || node.subItems || [];
            if (node.children) delete node.children;
            if (node.items) delete node.items;
            if (node.subItems) delete node.subItems;
        }
    }
}

function normalizeChildrenRecursive(node, depth, fixes) {
    const children = depth === 0 ? (node.children || [])
                   : depth === 1 ? (node.items || [])
                   : (node.subtasks || []);

    children.forEach(child => {
        // ID normalization
        if (!child.id) {
            child.id = generateNormalizationId(getTypeForDepth(depth + 1));
            fixes.push('missing IDs');
        }

        // Type normalization
        if (!child.type) {
            child.type = getTypeForDepth(depth + 1);
            fixes.push('missing types');
        }

        // Name from title
        if (!child.name && child.title) {
            child.name = child.title;
            delete child.title;
            fixes.push('title->name');
        }

        // Expanded state for phases and items (not subtasks)
        if (depth < 2 && child.expanded !== true) {
            child.expanded = true;
            fixes.push('expanded flags');
        }

        // showInCanvas for phases only
        if (depth === 0 && child.showInCanvas !== true) {
            child.showInCanvas = true;
            fixes.push('showInCanvas flags');
        }

        // Normalize this node's child array
        normalizeChildArrayForDepth(child, depth + 1, fixes);

        // Recurse into children (max depth 4)
        if (depth < 3) {
            normalizeChildrenRecursive(child, depth + 1, fixes);
        }
    });
}

function getTypeForDepth(depth) {
    return ['root', 'phase', 'item', 'subtask'][depth] || 'subtask';
}

function generateNormalizationId(prefix) {
    const bytes = new Uint8Array(4);
    crypto.getRandomValues(bytes);
    return `${prefix}_${Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('')}`;
}

function ensureRequiredArrays(tree, fixes) {
    if (!tree.hyperedges) {
        tree.hyperedges = [];
        fixes.push('hyperedges array');
    }
    if (!tree.children) {
        tree.children = [];
        fixes.push('children array');
    }
}

// ============================================================================
// FILE SYSTEM ICON MAPPING
// ============================================================================

const FILE_ICON_MAP = {
    // Documents
    '.pdf': { icon: 'ğŸ“•', type: 'pdf' },
    '.doc': { icon: 'ğŸ“˜', type: 'word' },
    '.docx': { icon: 'ğŸ“˜', type: 'word' },
    '.odt': { icon: 'ğŸ“˜', type: 'document' },

    // Spreadsheets
    '.xls': { icon: 'ğŸ“—', type: 'excel' },
    '.xlsx': { icon: 'ğŸ“—', type: 'excel' },
    '.csv': { icon: 'ğŸ“Š', type: 'excel' },
    '.ods': { icon: 'ğŸ“Š', type: 'excel' },

    // Presentations
    '.ppt': { icon: 'ğŸ“™', type: 'powerpoint' },
    '.pptx': { icon: 'ğŸ“™', type: 'powerpoint' },
    '.key': { icon: 'ğŸ“™', type: 'powerpoint' },
    '.odp': { icon: 'ğŸ“™', type: 'powerpoint' },

    // Text
    '.txt': { icon: 'ğŸ“', type: 'text' },
    '.md': { icon: 'ğŸ“', type: 'text' },
    '.rtf': { icon: 'ğŸ“', type: 'text' },

    // Images
    '.jpg': { icon: 'ğŸ–¼ï¸', type: 'image' },
    '.jpeg': { icon: 'ğŸ–¼ï¸', type: 'image' },
    '.png': { icon: 'ğŸ–¼ï¸', type: 'image' },
    '.gif': { icon: 'ğŸ¨', type: 'image' },
    '.bmp': { icon: 'ğŸ–¼ï¸', type: 'image' },
    '.svg': { icon: 'ğŸ¨', type: 'image' },
    '.webp': { icon: 'ğŸ–¼ï¸', type: 'image' },

    // Videos
    '.mp4': { icon: 'ğŸ¬', type: 'video' },
    '.avi': { icon: 'ğŸ¬', type: 'video' },
    '.mov': { icon: 'ğŸ¬', type: 'video' },
    '.mkv': { icon: 'ğŸ¬', type: 'video' },
    '.webm': { icon: 'ğŸ¬', type: 'video' },
    '.flv': { icon: 'ğŸ¬', type: 'video' },

    // Audio
    '.mp3': { icon: 'ğŸµ', type: 'audio' },
    '.wav': { icon: 'ğŸµ', type: 'audio' },
    '.flac': { icon: 'ğŸµ', type: 'audio' },
    '.aac': { icon: 'ğŸµ', type: 'audio' },
    '.ogg': { icon: 'ğŸµ', type: 'audio' },
    '.m4a': { icon: 'ğŸµ', type: 'audio' },

    // Code
    '.html': { icon: 'ğŸŒ', type: 'html' },
    '.htm': { icon: 'ğŸŒ', type: 'html' },
    '.css': { icon: 'ğŸ¨', type: 'css' },
    '.js': { icon: 'âš¡', type: 'javascript' },
    '.jsx': { icon: 'âš¡', type: 'javascript' },
    '.ts': { icon: 'ğŸ’™', type: 'javascript' },
    '.tsx': { icon: 'ğŸ’™', type: 'javascript' },
    '.py': { icon: 'ğŸ', type: 'python' },
    '.java': { icon: 'â˜•', type: 'code' },
    '.cpp': { icon: 'âš™ï¸', type: 'code' },
    '.c': { icon: 'âš™ï¸', type: 'code' },
    '.php': { icon: 'ğŸ˜', type: 'code' },
    '.rb': { icon: 'ğŸ’', type: 'code' },
    '.go': { icon: 'ğŸ”µ', type: 'code' },
    '.rs': { icon: 'ğŸ¦€', type: 'code' },
    '.json': { icon: 'ğŸ“‹', type: 'code' },
    '.xml': { icon: 'ğŸ“‹', type: 'code' },
    '.yaml': { icon: 'ğŸ“‹', type: 'code' },
    '.yml': { icon: 'ğŸ“‹', type: 'code' },

    // Archives
    '.zip': { icon: 'ğŸ—œï¸', type: 'zip' },
    '.rar': { icon: 'ğŸ“¦', type: 'archive' },
    '.7z': { icon: 'ğŸ“¦', type: 'archive' },
    '.tar': { icon: 'ğŸ“¦', type: 'archive' },
    '.gz': { icon: 'ğŸ“¦', type: 'archive' },

    // Executables
    '.exe': { icon: 'âš™ï¸', type: 'executable' },
    '.msi': { icon: 'âš™ï¸', type: 'executable' },
    '.app': { icon: 'âš™ï¸', type: 'executable' },
    '.dmg': { icon: 'ğŸ’¿', type: 'executable' },
    '.deb': { icon: 'ğŸ“¦', type: 'executable' },

    // Database
    '.db': { icon: 'ğŸ—„ï¸', type: 'database' },
    '.sqlite': { icon: 'ğŸ—„ï¸', type: 'database' },
    '.sql': { icon: 'ğŸ—„ï¸', type: 'database' },

    // Default
    'default': { icon: 'â“', type: 'unknown' }
};

const FOLDER_ICON_MAP = {
    'default': 'ğŸ“',
    'open': 'ğŸ“‚',
    'shared': 'ğŸ‘¥',
    'cloud': 'â˜ï¸',
    'system': 'âš™ï¸',
    'user': 'ğŸ‘¤',
    'downloads': 'ğŸ“¥',
    'documents': 'ğŸ“„',
    'pictures': 'ğŸ–¼ï¸',
    'videos': 'ğŸ¬',
    'music': 'ğŸµ',
    'desktop': 'ğŸ–¥ï¸',
    'trash': 'ğŸ—‘ï¸'
};

function getFileIcon(fileName, isFolder = false) {
    if (isFolder) {
        // Check for special folder names
        const folderNameLower = fileName.toLowerCase();
        if (folderNameLower.includes('download')) return FOLDER_ICON_MAP.downloads;
        if (folderNameLower.includes('document')) return FOLDER_ICON_MAP.documents;
        if (folderNameLower.includes('picture') || folderNameLower.includes('photo')) return FOLDER_ICON_MAP.pictures;
        if (folderNameLower.includes('video') || folderNameLower.includes('movie')) return FOLDER_ICON_MAP.videos;
        if (folderNameLower.includes('music') || folderNameLower.includes('audio')) return FOLDER_ICON_MAP.music;
        if (folderNameLower.includes('desktop')) return FOLDER_ICON_MAP.desktop;
        if (folderNameLower.includes('trash') || folderNameLower.includes('recycle')) return FOLDER_ICON_MAP.trash;
        if (folderNameLower.includes('user')) return FOLDER_ICON_MAP.user;
        return FOLDER_ICON_MAP.default;
    }

    // Extract extension
    const ext = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
    const mapping = FILE_ICON_MAP[ext] || FILE_ICON_MAP.default;
    return mapping.icon;
}

function getFileType(fileName, isFolder = false) {
    if (isFolder) return 'folder';
    const ext = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
    const mapping = FILE_ICON_MAP[ext] || FILE_ICON_MAP.default;
    return mapping.type;
}

// ============================================================================
// PATTERN STATE
// ============================================================================

let currentPattern = 'generic';
let customPatternNames = null;
let currentSortConfig = null; // Stores current sort configuration

// ============================================================================
// PATTERN FUNCTIONS
// ============================================================================

// Helper: Get pattern key from either string or object format
function getPatternKey(pattern) {
    if (typeof pattern === 'string') {
        return pattern;
    } else if (pattern && pattern.key) {
        return pattern.key;
    }
    return null;
}

function getPatternLabels() {
    console.log('getPatternLabels called, currentPattern:', currentPattern);
    if (currentPattern === 'custom' && customPatternNames) {
        console.log('Returning custom labels:', customPatternNames);
        return customPatternNames;
    }
    const labels = PATTERNS[currentPattern].levels;
    console.log('Returning pattern labels:', labels);
    return labels;
}

function renameNodesForPattern(node, labels) {
    if (!node) return;

    // Collect all possible terms from all patterns for replacement
    const allRootTerms = ['Project', 'Pipeline', 'Thesis', 'Product', 'Book', 'Event', 'Program', 'Strategy', 'Course', 'Film', 'Treatise', 'Family'];
    const allPhaseTerms = ['Phase', 'Quarter', 'Chapter', 'Part', 'Stage', 'Pillar', 'Unit', 'Generation', 'Act', 'Sequence'];
    const allItemTerms = ['Item', 'Deal', 'Section', 'Feature', 'Chapter', 'Activity', 'Workout', 'Initiative', 'Lesson', 'Scene', 'Argument', 'Person', 'Beat'];
    const allSubtaskTerms = ['Task', 'Sub-task', 'Action', 'Point', 'Story', 'Scene', 'Exercise', 'Shot', 'Premise', 'Event', 'Frame', 'Remix'];

    // Rename based on node type - replace ANY pattern term with the new one
    // Handle both 'name' and 'title' fields (imported JSON may use 'title')
    const nodeName = node.name || node.title || '';

    if (node.type === 'root') {
        // Try to replace any root term from any pattern
        let newName = nodeName;
        for (const term of allRootTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            newName = newName.replace(regex, labels.root);
        }
        if (node.name) node.name = newName;
        if (node.title) node.title = newName;
    } else if (node.type === 'phase') {
        // Try to replace any phase term from any pattern
        let newName = nodeName;
        for (const term of allPhaseTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            newName = newName.replace(regex, labels.phase);
        }
        if (node.name) node.name = newName;
        if (node.title) node.title = newName;
        // Update phase subtitle based on pattern
        if (PATTERNS[currentPattern].phaseSubtitles && node.phase !== undefined) {
            const phaseIndex = parseInt(node.phase);
            if (!isNaN(phaseIndex) && phaseIndex < PATTERNS[currentPattern].phaseSubtitles.length) {
                node.subtitle = PATTERNS[currentPattern].phaseSubtitles[phaseIndex];
            }
        }
    } else if (node.type === 'item') {
        // Try to replace any item term from any pattern
        let newName = nodeName;
        for (const term of allItemTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            newName = newName.replace(regex, labels.item);
        }
        if (node.name) node.name = newName;
        if (node.title) node.title = newName;
    } else if (node.type === 'subtask') {
        // Try to replace any subtask term from any pattern
        let newName = nodeName;
        for (const term of allSubtaskTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            newName = newName.replace(regex, labels.subtask);
        }
        if (node.name) node.name = newName;
        if (node.title) node.title = newName;
    }

    // Recursively process children
    if (node.children) {
        node.children.forEach(child => renameNodesForPattern(child, labels));
    }

    // Process items in phases
    if (node.items) {
        node.items.forEach(item => {
            renameNodesForPattern(item, labels);
            // Process subtasks
            if (item.subItems) {
                item.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
            }
        });
    }

    // Process nested subtasks
    if (node.subItems) {
        node.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
    }
}

function applyPattern(patternKey) {
    console.log('applyPattern called with:', patternKey);
    currentPattern = patternKey;

    if (patternKey === 'custom') {
        showCustomPatternDialog();
    } else {
        // Store in data
        if (!capexTree.pattern) {
            capexTree.pattern = {};
        }
        capexTree.pattern.key = patternKey;
        capexTree.pattern.labels = PATTERNS[patternKey].levels;
        console.log('Pattern applied:', PATTERNS[patternKey].name);
        console.log('New labels:', PATTERNS[patternKey].levels);

        // Auto-rename existing nodes to match pattern
        renameNodesForPattern(capexTree, PATTERNS[patternKey].levels);
        console.log('Nodes renamed to match pattern');

        // Re-render to apply new labels
        render();

        // Update sort dropdown for new pattern
        updateSortDropdown();

        // Update AI button label to match pattern
        updateAIButtonLabel();

        // BUILD 380: Update biographer indicator for LifeTree
        if (typeof checkBiographerIndicator === 'function') {
            checkBiographerIndicator();
        }
    }
}

// Update AI Analysis button label based on active pattern
function updateAIButtonLabel() {
    const btn = document.getElementById('ai-btn');
    if (!btn) return;

    const span = btn.querySelector('span');
    if (!span) return;

    const labelMap = {
        'generic': { text: 'ğŸ“Š Project Report', tooltip: 'Generate executive summary and risk assessment' },
        'sales': { text: 'ğŸ’° Deal Scorecard', tooltip: 'Analyze deal probability, revenue weight, and blockers' },
        'film': { text: 'ğŸ¬ Scene Breakdown', tooltip: 'Analyze shot lists, camera moves, and continuity' },
        'book': { text: 'ğŸ“– Story Arc Review', tooltip: 'Analyze pacing, character beats, and plot structure' },
        'philosophy': { text: 'ğŸ§  Logic Audit', tooltip: 'Check validity of premises and argument strength' },
        'thesis': { text: 'ğŸ“š Academic Review', tooltip: 'Analyze structure, citations, and argumentation' },
        'roadmap': { text: 'ğŸš€ Roadmap Analysis', tooltip: 'Check feature dependencies and timeline coherence' },
        'prompting': { text: 'ğŸ§ª Prompt Test', tooltip: 'Analyze prompt structure against best practices' },
        'gmail': { text: 'ğŸ“§ Thread Summary', tooltip: 'Summarize conversation and identify action items' },
        'event': { text: 'ğŸ‰ Event Checklist', tooltip: 'Check logistics, timeline, and vendor coordination' },
        'fitness': { text: 'ğŸ’ª Workout Audit', tooltip: 'Analyze progression, volume, and recovery balance' },
        'strategy': { text: 'ğŸ¯ Strategy Review', tooltip: 'Analyze objectives, initiatives, and resource alignment' },
        'course': { text: 'ğŸ“ Curriculum Check', tooltip: 'Check learning objectives and scaffolding' },
        'family': { text: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Family Tree Analysis', tooltip: 'Analyze relationships and genealogical connections' },
        'rhetoric': { text: 'ğŸ—£ï¸ Argument Review', tooltip: 'Analyze rhetorical devices and persuasion structure' },
        'filesystem': { text: 'ğŸ§¹ Clean Up Files', tooltip: 'Find duplicates, suggest better names and organization' },
        'default': { text: 'ğŸ“Š Project Report', tooltip: 'Generate analysis report for this tree' }
    };

    const config = labelMap[currentPattern] || labelMap.default;
    span.textContent = config.text;
    btn.title = config.tooltip;
    btn.setAttribute('data-icon', config.text.split(' ')[0]); // Extract emoji for collapsed view

    console.log(`âœ… AI button updated for "${currentPattern}" pattern: ${config.text}`);
}

// Populate sort dropdown based on current pattern
function updateSortDropdown() {
    console.log('ğŸ”„ updateSortDropdown called, currentPattern:', currentPattern);

    const sortSection = document.getElementById('sort-section');
    const sortSelect = document.getElementById('pattern-sort-select');

    if (!sortSection || !sortSelect) {
        console.log('âŒ Sort elements not found in DOM');
        return;
    }

    const pattern = PATTERNS[currentPattern];
    console.log('Pattern object:', pattern ? pattern.name : 'undefined');

    // Check if pattern has sortOptions
    if (pattern && pattern.sortOptions && pattern.sortOptions.length > 0) {
        // Show sort section
        sortSection.style.display = 'flex';

        // Clear existing options
        const previousCount = sortSelect.options.length;
        sortSelect.innerHTML = '<option value="">Sort By</option>';

        // Add pattern-specific sort options
        pattern.sortOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.label;
            opt.dataset.field = option.field;
            opt.dataset.order = option.order;
            opt.dataset.type = option.type;
            sortSelect.appendChild(opt);
        });

        console.log(`âœ… Sort dropdown updated: ${previousCount} â†’ ${sortSelect.options.length} options (${pattern.sortOptions.length} + Default) for "${currentPattern}" pattern`);
    } else {
        // Hide sort section if pattern has no sort options
        sortSection.style.display = 'none';
        console.log(`âš ï¸ Pattern "${currentPattern}" has no sort options`);
    }
}

// Dynamically populate cluster-by dropdown based on current pattern
function updateClusterByOptions() {
    const clusterBySelect = document.getElementById('cluster-by-select');
    if (!clusterBySelect) {
        console.log('âš ï¸ Cluster-by select not found in DOM');
        return;
    }

    const currentValue = clusterBySelect.value;
    clusterBySelect.innerHTML = '';

    // Always start with default option
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = 'ğŸ”— Cluster By';
    defaultOption.style.cssText = 'background: #1a1a2e; color: #ffffff;';
    clusterBySelect.appendChild(defaultOption);

    // Universal fields (work for all patterns)
    const universalFields = [
        { value: 'itemType', label: 'ğŸ“¦ Type' },
        { value: 'owner', label: 'ğŸ‘¤ Owner' },
        { value: 'pmRAGStatus', label: 'ğŸš¦ Status' },
        { value: 'cost', label: 'ğŸ’° Cost Range' },
        { value: 'modifiedDate', label: 'ğŸ“… Date' }
    ];

    // Pattern-specific fields
    const patternFields = {
        philosophy: [
            { value: 'argumentType', label: 'ğŸ¯ Argument Type' },
            { value: 'validity', label: 'âœ“ Logical Validity' },
            { value: 'speaker', label: 'ğŸ—£ï¸ Speaker' },
            { value: 'philosophicalSchool', label: 'ğŸ›ï¸ School of Thought' }
        ],
        film: [
            { value: 'visualStyle', label: 'ğŸ¨ Visual Style' },
            { value: 'lightingMood', label: 'ğŸ’¡ Lighting Mood' },
            { value: 'cameraMovement', label: 'ğŸ¥ Camera Movement' },
            { value: 'aiPlatform', label: 'ğŸ¤– AI Platform' }
        ],
        veo3: [
            { value: 'flowMode', label: 'ğŸ¬ Flow Mode' },
            { value: 'audioType', label: 'ğŸ”Š Audio Type' },
            { value: 'cinematicStyle', label: 'ğŸ¨ Cinematic Style' }
        ],
        sora2: [
            { value: 'beatType', label: 'ğŸµ Beat Type' },
            { value: 'cameoUsed', label: 'ğŸ‘¤ Cameo Used' },
            { value: 'physicsComplexity', label: 'âš›ï¸ Physics Complexity' }
        ],
        sales: [
            { value: 'leadStage', label: 'ğŸ“Š Lead Stage' },
            { value: 'leadSource', label: 'ğŸ“ Lead Source' },
            { value: 'dealSize', label: 'ğŸ’° Deal Size' }
        ],
        roadmap: [
            { value: 'priority', label: 'â­ Priority' },
            { value: 'stakeholder', label: 'ğŸ‘¥ Stakeholder' },
            { value: 'featureCategory', label: 'ğŸ“¦ Feature Category' }
        ]
    };

    // Get pattern-specific fields for current pattern
    const specificFields = patternFields[currentPattern] || [];

    // Add universal fields first
    universalFields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.value;
        option.textContent = field.label;
        option.style.cssText = 'background: #1a1a2e; color: #ffffff;';
        clusterBySelect.appendChild(option);
    });

    // Add separator if we have pattern-specific fields
    if (specificFields.length > 0) {
        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
        separator.style.cssText = 'background: #1a1a2e; color: #555;';
        clusterBySelect.appendChild(separator);

        // Add pattern-specific fields
        specificFields.forEach(field => {
            const option = document.createElement('option');
            option.value = field.value;
            option.textContent = field.label;
            option.style.cssText = 'background: #1a1a2e; color: #ffffff;';
            clusterBySelect.appendChild(option);
        });
    }

    // Restore previous value if it still exists
    if (currentValue) {
        const optionExists = Array.from(clusterBySelect.options).some(opt => opt.value === currentValue);
        if (optionExists) {
            clusterBySelect.value = currentValue;
        }
    }

    console.log(`âœ… Cluster-by options updated for pattern: ${currentPattern} (${specificFields.length} pattern-specific fields)`);
}

function showCustomPatternDialog() {
    const pattern = PATTERNS[currentPattern];
    const currentLabels = customPatternNames || pattern.levels;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = `
        <div style="padding: 20px;">
            <h3 style="color: var(--treeplex-primary); margin-bottom: 20px;">Custom Pattern Names</h3>
            <p style="margin-bottom: 20px; color: var(--text-secondary); font-size: 14px;">
                Define your own names for each level of your project structure.
            </p>

            <div style="display: flex; flex-direction: column; gap: 16px;">
                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 0 (Root):
                    </label>
                    <input type="text" id="custom-root" value="${currentLabels.root}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Project, Campaign, Thesis">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 1 (Phase):
                    </label>
                    <input type="text" id="custom-phase" value="${currentLabels.phase}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Phase, Quarter, Chapter">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 2 (Item):
                    </label>
                    <input type="text" id="custom-item" value="${currentLabels.item}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Item, Feature, Section">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 3 (Subtask):
                    </label>
                    <input type="text" id="custom-subtask" value="${currentLabels.subtask}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Task, Story, Point">
                </div>
            </div>

            <div style="display: flex; gap: 12px; margin-top: 24px;">
                <button class="btn btn-primary" onclick="saveCustomPattern()" style="flex: 1;">
                    âœ“ Apply Custom Names
                </button>
                <button class="btn" onclick="closeModal()" style="flex: 1;">
                    Cancel
                </button>
            </div>
        </div>
    `;

    document.getElementById('modal').style.display = 'flex';
}

function saveCustomPattern() {
    const root = document.getElementById('custom-root').value.trim() || 'Level 0';
    const phase = document.getElementById('custom-phase').value.trim() || 'Level 1';
    const item = document.getElementById('custom-item').value.trim() || 'Level 2';
    const subtask = document.getElementById('custom-subtask').value.trim() || 'Level 3';

    customPatternNames = { root, phase, item, subtask };

    // Store in data
    if (!capexTree.pattern) {
        capexTree.pattern = {};
    }
    capexTree.pattern.key = 'custom';
    capexTree.pattern.labels = customPatternNames;

    closeModal();
    render();
}

// ============================================================================
// INITIALIZATION
// ============================================================================


function showPatternDescription() {
    const select = document.getElementById('pattern-select');
    const selectedOption = select.options[select.selectedIndex];
    const desc = selectedOption.getAttribute('data-desc');

    if (desc) {
        select.setAttribute('title', desc);
    }
}

function hidePatternDescription() {
    // Keep title for basic tooltip
}

        // State
        let activeNode = null;

        // Utilities
        function formatCost(cost) {
            // Handle null, undefined, or non-numeric values
            if (cost === null || cost === undefined || cost === '' || isNaN(cost)) {
                return '$0';
            }

            // Convert to number if it's a string
            const numCost = typeof cost === 'string' ? parseFloat(cost) : cost;

            if (numCost >= 1000000) return '$' + (numCost / 1000000).toFixed(1) + 'M';
            if (numCost >= 1000) return '$' + (numCost / 1000).toFixed(0) + 'k';
            return '$' + numCost.toLocaleString();
        }

        // BUILD 575: Convert URLs and Atlas links in text to clickable elements
        // Order: Atlas links first (to preserve [[]] syntax), then URL linkification
        function linkifyText(text) {
            if (!text) return text;

            // 1. First process Atlas links [[...]]
            let result = renderAtlasLinks(text);

            // 2. Then convert URLs (http, https, or www)
            const urlRegex = /(https?:\/\/[^\s<>"{}|\\^`\[\]]+)|(www\.[^\s<>"{}|\\^`\[\]]+)/gi;
            result = result.replace(urlRegex, (match) => {
                const url = match.startsWith('www.') ? 'https://' + match : match;
                // Truncate display for very long URLs
                const displayUrl = match.length > 50 ? match.substring(0, 47) + '...' : match;
                return `<a href="${url}" target="_blank" rel="noopener noreferrer" style="color: #8b5cf6; text-decoration: underline; word-break: break-all;">${displayUrl}</a>`;
            });

            return result;
        }

        // BUILD 387: Safe node name helper - prevents "undefined" from displaying
        function safeNodeName(node) {
            if (!node) return 'âš ï¸ Unnamed';
            const name = node.name || node.title;
            if (!name || name === 'undefined' || (typeof name === 'string' && name.trim() === '')) {
                return 'âš ï¸ Unnamed';
            }
            return name;
        }

        // BUILD 389: Get semantic type for display (when type field is used for categorization)
        // Structural types (root, phase, item, subtask) are inferred from position, not displayed
        const STRUCTURAL_TYPES = ['root', 'phase', 'item', 'subtask', 'subItem', 'child', undefined, null, ''];
        function getSemanticType(node) {
            if (!node || !node.type) return null;
            // If it's a structural type, check itemType instead
            if (STRUCTURAL_TYPES.includes(node.type)) {
                return node.itemType || null;
            }
            // Otherwise, the type IS the semantic type (e.g., 'risk-factor', 'critique')
            return node.type;
        }

        // BUILD 390: Subtle type indicator - small colored pip or abbreviated label
        // Chess-like notation: different paths/variations get subtle markers
        function getTypeIndicator(node) {
            const semType = getSemanticType(node);
            if (!semType) return '';

            // Map semantic types to subtle indicators (short, unobtrusive)
            // BUILD 390: Expanded with philosophy dialectical types
            const typeStyles = {
                // Philosophy pattern - dialectical types
                'critique': { icon: 'âš”', color: '#EF4444', abbr: 'crit' },
                'response': { icon: 'â†©', color: '#3B82F6', abbr: 'resp' },
                'argument': { icon: 'â—†', color: '#8B5CF6', abbr: 'arg' },
                'counter': { icon: 'â‡„', color: '#F59E0B', abbr: 'ctr' },
                'objection': { icon: 'âœ—', color: '#F97316', abbr: 'obj' },
                'defense': { icon: 'ğŸ›¡', color: '#22C55E', abbr: 'def' },
                'synthesis': { icon: 'âˆ´', color: '#10B981', abbr: 'syn' },
                'thesis': { icon: 'â†’', color: '#3B82F6', abbr: 'th' },
                'antithesis': { icon: 'â†', color: '#EF4444', abbr: 'anti' },
                'premise': { icon: 'âˆµ', color: '#A855F7', abbr: 'prem' },
                'conclusion': { icon: 'âˆ', color: '#06B6D4', abbr: 'conc' },
                'implicit-premise': { icon: 'â‡', color: '#D946EF', abbr: 'impl' },
                'distinction': { icon: 'â‰ ', color: '#EC4899', abbr: 'dist' },
                'thought-experiment': { icon: 'ğŸ’­', color: '#14B8A6', abbr: 'thgt' },
                // Generic/structural types
                'risk-factor': { icon: 'âš ', color: '#EF4444', abbr: 'risk' },
                'sub-node': { icon: 'â†³', color: '#6B7280', abbr: 'sub' },
                'supporting': { icon: 'âœ“', color: '#22C55E', abbr: 'supp' },
                // LifeTree pattern
                'birth': { icon: 'â˜…', color: '#EC4899', abbr: 'birth' },
                'education': { icon: 'ğŸ“š', color: '#3B82F6', abbr: 'edu' },
                'career': { icon: 'ğŸ’¼', color: '#10B981', abbr: 'work' },
                'relationship': { icon: 'â¤', color: '#EC4899', abbr: 'rel' },
                'milestone': { icon: 'ğŸ†', color: '#F59E0B', abbr: 'mile' },
                'loss': { icon: 'â—‡', color: '#6B7280', abbr: 'loss' },
                'achievement': { icon: 'â­', color: '#F59E0B', abbr: 'achv' },
                'travel': { icon: 'âœˆ', color: '#06B6D4', abbr: 'trvl' },
                'residence': { icon: 'ğŸ ', color: '#8B5CF6', abbr: 'home' },
                'family': { icon: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§', color: '#EC4899', abbr: 'fam' },
                'memory': { icon: 'ğŸ’­', color: '#6B7280', abbr: 'mem' },
                'health': { icon: 'â¤ï¸â€ğŸ©¹', color: '#EF4444', abbr: 'hlth' },
                // Sales pattern
                'lead': { icon: 'ğŸ¯', color: '#3B82F6', abbr: 'lead' },
                'opportunity': { icon: 'ğŸ’¡', color: '#F59E0B', abbr: 'oppt' },
                'deal': { icon: 'ğŸ¤', color: '#22C55E', abbr: 'deal' },
                'closed': { icon: 'âœ…', color: '#10B981', abbr: 'won' },
                'lost': { icon: 'âŒ', color: '#EF4444', abbr: 'lost' }
            };

            const style = typeStyles[semType.toLowerCase()] || { icon: 'â€¢', color: '#6B7280', abbr: semType.substring(0, 4) };
            // Return subtle inline indicator - just a small colored marker with tooltip
            return `<span class="type-indicator" style="color: ${style.color}; font-size: 10px; margin-left: 6px; opacity: 0.8;" title="${semType}">${style.icon}</span>`;
        }

        // Calculate total including all children (for root node)
        function calculateTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            if (node.children) {
                node.children.forEach(child => {
                    total += calculateTotal(child);
                });
            }
            return total;
        }

        // Calculate only items in this phase (NOT children phases)
        function calculatePhaseTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            return total;
        }

        function findNode(id, node = capexTree) {
            if (node.id === id) return node;
            if (node.children) {
                for (let child of node.children) {
                    const found = findNode(id, child);
                    if (found) return found;
                }
            }
            return null;
        }

        // BUILD 544: Render capability node card HTML
        function renderCapabilityCard(node) {
            const status = node.status || 'untested';
            const statusLabels = {
                healthy: 'Healthy',
                degraded: 'Needs attention',
                broken: 'Broken',
                untested: 'Not tested'
            };

            const allowBadges = (node.allow || ['read', 'navigate'])
                .map(p => `<span class="permission-badge allowed">âœ“ ${p}</span>`)
                .join('');

            const profileHint = node.profileHint
                ? `<span style="color: #a0aec0; font-size: 11px;"> â€¢ ${node.profileHint}</span>`
                : '';

            return `
                <div class="node-header">
                    <div class="capability-icon">ğŸ”</div>
                    <div class="capability-info">
                        <div class="capability-name">${node.name || 'Unnamed Capability'}</div>
                        <div class="capability-site">${node.site || 'No site'}${profileHint}</div>
                    </div>
                </div>
                <div class="capability-goal">${node.goal || 'No goal defined'}</div>
                <div class="capability-permissions">${allowBadges}</div>
                <div class="capability-status">
                    <span class="status-dot ${status}"></span>
                    <span style="color: #a0aec0;">${statusLabels[status]}</span>
                </div>
                <div class="capability-actions">
                    <button class="cap-action-btn" onclick="testCapability('${node.id}')">Test</button>
                    <button class="cap-action-btn" onclick="editCapability('${node.id}')">Edit</button>
                </div>
            `;
        }

        // BUILD 544: Test capability (placeholder)
        function testCapability(nodeId) {
            const node = findNodeById(nodeId);
            if (!node) return;
            showToast(`Testing capability: ${node.name}...`, 'info');
            // TODO: Implement actual capability test via MCP
        }

        // BUILD 544: Edit capability (placeholder)
        function editCapability(nodeId) {
            const node = findNodeById(nodeId);
            if (!node) return;
            // For now, just show info panel
            if (typeof showInfo === 'function') {
                showInfo(node);
            }
        }

        // BUILD 615: Show create capability modal
        function showCreateCapabilityModal() {
            const modal = document.getElementById('create-capability-modal');
            if (modal) {
                // Clear form
                document.getElementById('cap-name').value = '';
                document.getElementById('cap-site').value = '';
                document.getElementById('cap-goal').value = '';
                document.getElementById('cap-examples').value = '';
                modal.style.display = 'flex';
            }
        }
        window.showCreateCapabilityModal = showCreateCapabilityModal;

        // BUILD 615: Submit create capability form
        function submitCreateCapability() {
            const name = document.getElementById('cap-name').value.trim();
            const site = document.getElementById('cap-site').value.trim();
            const goal = document.getElementById('cap-goal').value.trim();
            const examplesRaw = document.getElementById('cap-examples').value.trim();

            if (!name || !site || !goal) {
                showToast('Please fill in Name, Site, and Goal', 'error');
                return;
            }

            const examples = examplesRaw ? examplesRaw.split(',').map(s => s.trim()).filter(Boolean) : [];

            const newCap = CAPABILITY_SCHEMA.create({
                name,
                site,
                goal,
                examples
            });

            // BUILD 616: Add to global capabilities registry (not current project tree)
            const category = addCapabilityToRegistry(newCap);

            // Close modal
            document.getElementById('create-capability-modal').style.display = 'none';

            showToast(`ğŸ” Created capability: ${name} (${category})`, 'success');
        }
        window.submitCreateCapability = submitCreateCapability;

        // Render tree - phases flow left to right
        function render() {
            const container = document.getElementById('tree-root');
            container.innerHTML = '';

            // Show/hide empty state CTA based on tree content
            // BUILD 538: Respect manual dismissal
            const emptyStateCta = document.getElementById('empty-state-cta');
            if (emptyStateCta && typeof hasExistingContent === 'function') {
                const showEmptyState = !hasExistingContent() && !window.emptyStateManuallyDismissed;
                emptyStateCta.style.display = showEmptyState ? 'block' : 'none';
            }

            const tableEl = document.createElement('div');
            tableEl.className = 'tree';

            // FILESYSTEM PATTERN: Use vertical tree layout
            if (currentPattern === 'filesystem') {
                tableEl.classList.add('filesystem-tree');

                function buildFilesystemNode(node, depth = 0) {
                    // BUILD 409: Ensure node has type set for context menu to work
                    if (!node.type) {
                        if (node.id === 'root' || depth === 0) node.type = 'root';
                        else if (node.children && node.children.length > 0) node.type = 'phase'; // Folders
                        else node.type = 'item'; // Files
                    }

                    // Initialize expanded property if not set
                    if (node.expanded === undefined) {
                        node.expanded = (depth === 0 || depth === 1); // Auto-expand root and drives
                    }

                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = `tree-node ${node.type} filesystem-indent-${depth}`;
                    if (node.expanded) nodeDiv.classList.add('expanded');
                    else nodeDiv.classList.add('collapsed');
                    nodeDiv.dataset.nodeId = node.id;
                    // BUILD 415: Track depth for shape hierarchy
                    nodeDiv.dataset.depth = depth;

                    // BUILD 406: Apply visual highlighting for recently changed nodes
                    if (typeof hasRecentChange === 'function') {
                        const change = hasRecentChange(node.id);
                        if (change) {
                            const highlightClass = change.type === 'new' ? 'node-new-highlight' :
                                               change.type === 'moved' ? 'node-moved-highlight' : 'node-modified-highlight';
                            nodeDiv.classList.add(highlightClass);
                        }
                    }

                    // Build node content
                    // BUILD 544: Handle capability nodes specially
                    if (node.type === 'capability') {
                        nodeDiv.innerHTML = renderCapabilityCard(node);
                    } else if (node.type === 'root') {
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0) || (node.children && node.children.length > 0);
                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? 'â–¼' : 'â–¶') + '</span>' : ''}
                                <span class="node-icon">${node.icon || 'ğŸ“'}</span>
                                <div class="node-content">
                                    <div class="node-title">${safeNodeName(node)}</div>
                                </div>
                            </div>
                        `;
                    } else if (node.type === 'phase') {
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0) || (node.children && node.children.length > 0);
                        const isVisibleInCanvas = node.showInCanvas !== false;
                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? 'â–¼' : 'â–¶') + '</span>' : ''}
                                <span class="node-icon">${node.icon || 'ğŸ“‹'}</span>
                                <div class="node-content">
                                    <div class="node-title">${safeNodeName(node)}</div>
                                </div>
                                <button class="canvas-visibility-toggle" title="${isVisibleInCanvas ? 'Hide from Canvas View' : 'Show in Canvas View'}" style="background: none; border: none; cursor: pointer; padding: 4px; margin-left: 8px; font-size: 16px; opacity: ${isVisibleInCanvas ? '1' : '0.3'};">
                                    ${isVisibleInCanvas ? 'ğŸ‘ï¸' : 'ğŸ‘ï¸'}
                                </button>
                            </div>
                        `;
                    } else {
                        // Item/Subtask - file or folder
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0) || (node.children && node.children.length > 0);
                        // Build contributor badge HTML if contributor exists
                        const fsContributorBadge = node.contributor ? `<span class="contributor-badge" title="Last edited by ${node.contributor}${node.contributorTimestamp ? ' on ' + new Date(node.contributorTimestamp).toLocaleDateString() : ''}">ğŸ‘¤ ${node.contributor}</span>` : '';
                        const fsCollabIndicator = node.collabComments ? `<span class="collab-indicator" title="${node.collabComments.substring(0, 100)}${node.collabComments.length > 100 ? '...' : ''}">ğŸ’¬</span>` : '';

                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? 'â–¼' : 'â–¶') + '</span>' : ''}
                                <span class="node-icon">${node.icon || 'ğŸ“„'}</span>
                                <div class="node-content">
                                    <span class="item-name">${safeNodeName(node)}</span>
                                    ${fsContributorBadge}
                                    ${fsCollabIndicator}
                                </div>
                            </div>
                        `;
                    }

                    // Add event listener for canvas visibility toggle (phases only)
                    if (node.type === 'phase') {
                        const toggleBtn = nodeDiv.querySelector('.canvas-visibility-toggle');
                        if (toggleBtn) {
                            toggleBtn.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();

                                // Toggle visibility
                                node.showInCanvas = !(node.showInCanvas !== false);
                                console.log(`Phase "${node.name}" showInCanvas: ${node.showInCanvas}`);

                                // Re-render tree to update button appearance
                                const treeContainer = document.getElementById('tree-container');
                                const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;
                                render();
                                if (treeContainer) {
                                    setTimeout(() => {
                                        treeContainer.scrollTop = scrollTop;
                                        treeContainer.scrollLeft = scrollLeft;
                                    }, 0);
                                }

                                // If in Canvas View, re-render canvas
                                if (viewMode === 'canvas') {
                                    renderCanvas();
                                }
                            });
                        }
                    }

                    // Event listeners
                    nodeDiv.addEventListener('click', (e) => {
                        e.stopPropagation();

                        const hasChildren = (node.items && node.items.length > 0) ||
                                          (node.subItems && node.subItems.length > 0) ||
                                          (node.children && node.children.length > 0);

                        console.log('Clicked node:', node.name, {
                            type: node.type,
                            hasItems: node.items?.length || 0,
                            hasSubItems: node.subItems?.length || 0,
                            hasChildren: node.children?.length || 0,
                            expanded: node.expanded,
                            hasChildrenTotal: hasChildren
                        });

                        if (hasChildren) {
                            node.expanded = !node.expanded;
                            console.log('â†’ Toggled', node.name, 'to', node.expanded ? 'EXPANDED' : 'COLLAPSED');

                            // Preserve scroll position during re-render (both vertical and horizontal)
                            const treeContainer = document.getElementById('tree-container');
                            const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                            const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                            render();

                            // Restore scroll position after render
                            if (treeContainer) {
                                setTimeout(() => {
                                    treeContainer.scrollTop = scrollTop;
                                    treeContainer.scrollLeft = scrollLeft;
                                }, 0);
                            }
                        } else {
                            console.log('â†’ No children, showing info panel');
                            showInfo(node);
                        }
                    });

                    nodeDiv.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        activeNode = node;
                        showContextMenu(e.pageX, e.pageY);
                    });

                    tableEl.appendChild(nodeDiv);

                    // Recursively render children if expanded
                    if (node.expanded) {
                        if (node.children && node.children.length > 0) {
                            node.children.forEach(child => buildFilesystemNode(child, depth + 1));
                        }
                        if (node.items && node.items.length > 0) {
                            node.items.forEach(item => buildFilesystemNode(item, depth + 1));
                        }
                        if (node.subItems && node.subItems.length > 0) {
                            node.subItems.forEach(subItem => buildFilesystemNode(subItem, depth + 1));
                        }
                    }
                }

                // Start rendering from root
                buildFilesystemNode(capexTree, 0);

                container.appendChild(tableEl);

                // BUILD 566: Auto-refresh non-tree views if active
                if (viewMode === 'canvas') {
                    setTimeout(() => renderCanvas(), 50);
                } else if (viewMode === '3d') {
                    setTimeout(() => render3D(), 50);
                }
                return;
            }

            // DEFAULT PATTERN: Use horizontal column layout
            // Traverse and build columns
            function buildColumn(node) {
                // BUILD 409: Ensure node has type set for context menu to work
                if (!node.type) {
                    if (node.id === 'root' || node.id === capexTree.id) node.type = 'root';
                    else if (node.phase !== undefined || node.phaseNumber !== undefined) node.type = 'phase';
                    else node.type = 'item';
                }

                const levelDiv = document.createElement('div');
                levelDiv.className = 'tree-level';

                // Render current node
                const nodeDiv = document.createElement('div');
                nodeDiv.className = `tree-node ${node.type}`;
                if (node.type === 'phase') nodeDiv.classList.add(`phase-${node.phase}`);
                if (node.expanded) nodeDiv.classList.add('expanded');
                else nodeDiv.classList.add('collapsed');

                nodeDiv.dataset.nodeId = node.id;

                // BUILD 406: Apply visual highlighting for recently changed nodes
                if (typeof hasRecentChange === 'function') {
                    const change = hasRecentChange(node.id);
                    if (change) {
                        const highlightClass = change.type === 'new' ? 'node-new-highlight' :
                                               change.type === 'moved' ? 'node-moved-highlight' : 'node-modified-highlight';
                            nodeDiv.classList.add(highlightClass);
                    }
                }

                // BUILD 544: Handle capability nodes specially
                if (node.type === 'capability') {
                    nodeDiv.innerHTML = renderCapabilityCard(node);
                } else if (node.type === 'root') {
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon || 'ğŸŒ³'}</span>
                            <div class="node-content">
                                <div class="node-title">${safeNodeName(node)}</div>
                                <div class="node-subtitle">by geej</div>
                            </div>
                            ${node.children ? '<span class="expand-toggle">â–¶</span>' : ''}
                        </div>
                    `;
                } else if (node.type === 'phase') {
                    const total = calculatePhaseTotal(node);
                    const isVisibleInCanvas = node.showInCanvas !== false;
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon || 'ğŸ“‹'}</span>
                            <div class="node-content">
                                <div class="node-title">${safeNodeName(node)}</div>
                                ${node.subtitle ? `<div class="node-subtitle">${node.subtitle}</div>` : ''}
                                ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost && total > 0 ? `<div class="node-cost">${formatCost(total)}</div>` : ''}
                            </div>
                            <button class="canvas-visibility-toggle" title="${isVisibleInCanvas ? 'Hide from Canvas View' : 'Show in Canvas View'}" style="background: none; border: none; cursor: pointer; padding: 4px 8px; margin-right: 8px; font-size: 18px; opacity: ${isVisibleInCanvas ? '1' : '0.3'};">
                                ${isVisibleInCanvas ? 'ğŸ‘ï¸' : 'ğŸ‘ï¸'}
                            </button>
                            ${node.items || node.children ? '<span class="expand-toggle">â–¶</span>' : ''}
                        </div>
                    `;
                } else {
                    // Build contributor badge HTML if contributor exists
                    const contributorBadge = node.contributor ? `<span class="contributor-badge" title="Last edited by ${node.contributor}${node.contributorTimestamp ? ' on ' + new Date(node.contributorTimestamp).toLocaleDateString() : ''}">ğŸ‘¤ ${node.contributor}</span>` : '';
                    const collabIndicator = node.collabComments ? `<span class="collab-indicator" title="${node.collabComments.substring(0, 100)}${node.collabComments.length > 100 ? '...' : ''}">ğŸ’¬</span>` : '';
                    // BUILD 389: Subtle type indicator for semantic types (like chess variation markers)
                    const typeIndicator = typeof getTypeIndicator === 'function' ? getTypeIndicator(node) : '';

                    // BUILD 390: Compute type styling for tree view
                    const semType = typeof getSemanticType === 'function' ? getSemanticType(node) : node.itemType;
                    let typeStyleAttr = '';
                    let typeBadgeHtml = '';
                    if (semType) {
                        // BUILD 390: Expanded type color palette matching canvas view
                        const typeStyles = {
                            'critique': { color: '#EF4444', icon: 'âš”' },
                            'response': { color: '#3B82F6', icon: 'â†©' },
                            'argument': { color: '#8B5CF6', icon: 'â—†' },
                            'counter': { color: '#F59E0B', icon: 'â‡„' },
                            'objection': { color: '#F97316', icon: 'âœ—' },
                            'defense': { color: '#22C55E', icon: 'ğŸ›¡' },
                            'synthesis': { color: '#10B981', icon: 'âˆ´' },
                            'thesis': { color: '#3B82F6', icon: 'â†’' },
                            'antithesis': { color: '#EF4444', icon: 'â†' },
                            'premise': { color: '#A855F7', icon: 'âˆµ' },
                            'conclusion': { color: '#06B6D4', icon: 'âˆ' },
                            'implicit-premise': { color: '#D946EF', icon: 'â‡' },
                            'distinction': { color: '#EC4899', icon: 'â‰ ' },
                            'thought-experiment': { color: '#14B8A6', icon: 'ğŸ’­' },
                            'risk-factor': { color: '#EF4444', icon: 'âš ' },
                            'sub-node': { color: '#6B7280', icon: 'â†³' },
                            'supporting': { color: '#22C55E', icon: 'âœ“' }
                        };
                        const style = typeStyles[semType.toLowerCase()] || { color: 'var(--treeplex-primary)', icon: 'â€¢' };
                        // Left border stripe for tree view nodes
                        typeStyleAttr = `style="border-left: 3px solid ${style.color}; padding-left: 8px;"`;
                        typeBadgeHtml = `<span class="badge" style="background: ${style.color}20; color: ${style.color};">${style.icon} ${semType}</span>`;
                    }

                    nodeDiv.innerHTML = `
                        <div class="node-header" ${typeStyleAttr}>
                            <span class="node-icon">${node.icon || 'ğŸ“„'}</span>
                            <div class="node-content">
                                <div class="item-name">${safeNodeName(node)}${typeIndicator}</div>
                                ${node.description ? `<div class="item-description">${node.description}</div>` : ''}
                                <div class="item-meta">
                                    ${typeBadgeHtml}
                                    ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost && node.cost > 0 ? `<span class="item-cost">${formatCost(node.cost)}</span>` : ''}
                                    ${contributorBadge}
                                    ${collabIndicator}
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Add event listener for canvas visibility toggle (phases only)
                if (node.type === 'phase') {
                    const toggleBtn = nodeDiv.querySelector('.canvas-visibility-toggle');
                    if (toggleBtn) {
                        toggleBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            // Toggle visibility
                            node.showInCanvas = !(node.showInCanvas !== false);
                            console.log(`Phase "${node.name}" showInCanvas: ${node.showInCanvas}`);

                            // Re-render tree to update button appearance
                            const treeContainer = document.getElementById('tree-container');
                            const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                            const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;
                            render();
                            if (treeContainer) {
                                setTimeout(() => {
                                    treeContainer.scrollTop = scrollTop;
                                    treeContainer.scrollLeft = scrollLeft;
                                }, 0);
                            }

                            // If in Canvas View, re-render canvas
                            if (viewMode === 'canvas') {
                                renderCanvas();
                            }
                        });
                    }
                }

                nodeDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if ((node.items && node.items.length > 0) || (node.children && node.children.length > 0)) {
                        node.expanded = !node.expanded;

                        // Preserve scroll position during re-render (both vertical and horizontal)
                        const treeContainer = document.getElementById('tree-container');
                        const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                        const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                        render();

                        // Restore scroll position after render
                        if (treeContainer) {
                            setTimeout(() => {
                                treeContainer.scrollTop = scrollTop;
                                treeContainer.scrollLeft = scrollLeft;
                            }, 0);
                        }
                    } else {
                        showInfo(node);
                    }
                });

                nodeDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    activeNode = node;
                    showContextMenu(e.pageX, e.pageY);
                });

                levelDiv.appendChild(nodeDiv);
                tableEl.appendChild(levelDiv);

                // If expanded, show items in next column, then next phase in following column
                if (node.expanded) {
                    // Show items if any
                    if (node.items && node.items.length > 0) {
                        const itemsColumn = document.createElement('div');
                        itemsColumn.className = 'tree-level';

                        // Get all item IDs in this phase to check for same-phase dependencies
                        const phaseItemIds = node.items.map(i => i.id);

                        // Topological sort: order items by dependencies
                        // Items with no same-phase dependencies first, then items that depend on them
                        function topologicalSort(items, phaseIds) {
                            const sorted = [];
                            const visited = new Set();
                            const visiting = new Set();

                            function visit(item) {
                                if (visited.has(item.id)) return;
                                if (visiting.has(item.id)) {
                                    // Circular dependency - just add it
                                    sorted.push(item);
                                    visited.add(item.id);
                                    return;
                                }

                                visiting.add(item.id);

                                // Visit dependencies first (only same-phase dependencies)
                                if (item.dependencies) {
                                    // Handle both array and string formats
                                    const deps = Array.isArray(item.dependencies) ? item.dependencies : [];
                                    deps.forEach(depId => {
                                        if (phaseIds.includes(depId)) {
                                            const depItem = items.find(i => i.id === depId);
                                            if (depItem) {
                                                visit(depItem);
                                            }
                                        }
                                    });
                                }

                                visiting.delete(item.id);
                                visited.add(item.id);
                                sorted.push(item);
                            }

                            items.forEach(item => visit(item));
                            return sorted;
                        }

                        // Calculate dependency depth/level for hierarchical indentation
                        // Returns the depth in the dependency chain (0 = no deps, 1 = direct child, 2 = grandchild, etc.)
                        function calculateDependencyLevel(item, phaseItems, phaseItemIds, visited = new Set()) {
                            // Base case: no same-phase dependencies
                            if (!item.dependencies || item.dependencies.length === 0) {
                                return 0;
                            }

                            const samePhaseDeps = item.dependencies.filter(depId => phaseItemIds.includes(depId));
                            if (samePhaseDeps.length === 0) {
                                return 0;
                            }

                            // Prevent circular dependency infinite loops
                            if (visited.has(item.id)) {
                                return 0;
                            }

                            visited.add(item.id);

                            // Find max depth among all same-phase dependencies
                            let maxLevel = 0;
                            samePhaseDeps.forEach(depId => {
                                const depItem = phaseItems.find(i => i.id === depId);
                                if (depItem) {
                                    const depLevel = calculateDependencyLevel(depItem, phaseItems, phaseItemIds, new Set(visited));
                                    maxLevel = Math.max(maxLevel, depLevel + 1);
                                }
                            });

                            return maxLevel;
                        }

                        // Use topological sort only when no custom sort is active
                        const sortedItems = (typeof currentSortConfig !== 'undefined' && currentSortConfig !== null)
                            ? node.items  // Use existing order when user has sorted
                            : topologicalSort(node.items, phaseItemIds);  // Use dependency-based order otherwise

                        sortedItems.forEach(item => {
                            // BUILD 409: Ensure item has type set (matches subtask behavior)
                            if (!item.type) {
                                item.type = 'item';
                            }

                            const itemDiv = document.createElement('div');
                            itemDiv.className = `tree-node item phase-${node.phase}`;
                            itemDiv.dataset.itemId = item.id; // Add item ID for dependency linking

                            // Calculate dependency depth for hierarchical indentation
                            const dependencyLevel = calculateDependencyLevel(item, node.items, phaseItemIds);

                            // Add multi-level indentation based on dependency depth
                            // Level 0 = no indent, Level 1 = 20px, Level 2 = 40px, Level 3 = 60px, etc.
                            if (dependencyLevel > 0) {
                                itemDiv.classList.add('has-same-phase-dependency');
                                itemDiv.style.marginLeft = `${dependencyLevel * 20}px`;
                                itemDiv.style.position = 'relative';
                                itemDiv.dataset.dependencyLevel = dependencyLevel; // Store for potential visual enhancements
                            }

                            // Add expanded class if item has subtasks and is expanded
                            if (item.subItems && item.subItems.length > 0 && item.expanded) {
                                itemDiv.classList.add('has-expanded-subtasks');
                            }

                            // Add dependency indicator
                            const depInfo = item.dependencies && item.dependencies.length > 0
                                ? `<div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">Depends: ${item.dependencies.join(', ')}</div>`
                                : '';

                            // Check if item has subtasks for expand/collapse indicator
                            const hasSubtasks = item.subItems && item.subItems.length > 0;
                            const expandIndicator = hasSubtasks
                                ? `<span class="expand-toggle" onclick="event.stopPropagation(); window.toggleSubtasks('${item.id}');" style="margin-left: 8px; font-size: 12px; opacity: 0.7; cursor: pointer; user-select: none;">${item.expanded ? 'â–¼' : 'â–¶'}</span>`
                                : '';

                            // RAG Status indicator
                            const ragStatusColors = {
                                'Green': '#22C55E',
                                'Amber': '#F59E0B',
                                'Red': '#EF4444'
                            };
                            const itemRAGStatus = item.pmRAGStatus;
                            const ragIndicator = itemRAGStatus ?
                                `<span style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: ${ragStatusColors[itemRAGStatus]}; margin-left: 8px; box-shadow: 0 0 6px ${ragStatusColors[itemRAGStatus]}80; vertical-align: middle;" title="RAG Status: ${itemRAGStatus}"></span>` : '';

                            // PM Status badge
                            const pmStatusBadge = item.pmStatus && item.pmStatus !== 'To Do' ?
                                `<span style="font-size: 10px; padding: 2px 6px; border-radius: 4px; background: ${item.pmStatus === 'Completed' ? '#22C55E' : item.pmStatus === 'Blocked' ? '#EF4444' : '#3B82F6'}; color: white; margin-left: 8px; font-weight: 600;">${item.pmStatus}</span>` : '';

                            itemDiv.innerHTML = `
                                <div class="node-header">
                                    <span class="node-icon">${item.icon || 'ğŸ“„'}</span>
                                    <div class="node-content">
                                        <div class="item-name">
                                            ${safeNodeName(item)}
                                            ${ragIndicator}
                                            ${pmStatusBadge}
                                            ${expandIndicator}
                                            ${hasSubtasks ? `<span style="font-size: 10px; color: var(--text-secondary); margin-left: 8px;">(${item.subItems.length} tasks)</span>` : ''}
                                        </div>
                                        <div class="item-description">${item.description || ''}</div>
                                        <div class="item-meta">
                                            ${item.itemType ? `<span class="badge badge-${item.itemType}">${item.itemType}</span>` : ''}
                                            ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost && item.cost > 0 ? `<span class="item-cost">${formatCost(item.cost)}</span>` : ''}
                                            ${item.pmOwnerEmail ? `<span style="font-size: 10px; color: var(--text-secondary); margin-left: 12px;">ğŸ‘¤ ${item.pmOwnerEmail.split('@')[0]}</span>` : ''}
                                            ${item.pmProgress > 0 ? `<span style="font-size: 10px; color: var(--treeplex-primary); margin-left: 12px; font-weight: 600;">${item.pmProgress}%</span>` : ''}
                                        </div>
                                        ${depInfo}
                                    </div>
                                </div>
                            `;
                            itemDiv.addEventListener('click', (e) => {
                                e.stopPropagation();

                                const panel = document.getElementById('info-panel');
                                const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === item.id;

                                if (isPanelOpen) {
                                    // Second click: Close panel and collapse subtasks
                                    panel.classList.remove('open');
                                    currentOpenItemId = null;
                                    if (hasSubtasks) {
                                        item.expanded = false;

                                        // Preserve scroll position during re-render (both vertical and horizontal)
                                        const treeContainer = document.getElementById('tree-container');
                                        const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                        const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                        render();

                                        // Restore scroll position after render
                                        if (treeContainer) {
                                            setTimeout(() => {
                                                treeContainer.scrollTop = scrollTop;
                                                treeContainer.scrollLeft = scrollLeft;
                                            }, 0);
                                        }
                                    }
                                } else {
                                    // First click: Open panel and expand subtasks
                                    showInfo(item);
                                    if (hasSubtasks) {
                                        item.expanded = true;

                                        // Preserve scroll position during re-render (both vertical and horizontal)
                                        const treeContainer = document.getElementById('tree-container');
                                        const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                        const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                        render();

                                        // Restore scroll position after render
                                        if (treeContainer) {
                                            setTimeout(() => {
                                                treeContainer.scrollTop = scrollTop;
                                                treeContainer.scrollLeft = scrollLeft;
                                            }, 0);
                                        }
                                    }
                                }
                            });

                            itemDiv.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                activeNode = item;
                                showContextMenu(e.pageX, e.pageY);
                            });

                            itemsColumn.appendChild(itemDiv);

                            // RECURSIVE function to render subtasks - keeps same generation on horizontal plane
                            function renderSubtasks(parentItem, containerEl, phaseNum, nestLevel = 0) {
                                if (!parentItem.expanded || !parentItem.subItems || parentItem.subItems.length === 0) {
                                    return;
                                }

                                const subtaskContainer = document.createElement('div');
                                subtaskContainer.className = 'subtask-container';
                                subtaskContainer.style.marginLeft = `${(dependencyLevel + nestLevel) * 20}px`;

                                // Get sub-item IDs for dependency calculations
                                const subItemIds = parentItem.subItems.map(s => s.id);

                                // Sort sub-items by dependencies (topological sort)
                                const sortedSubItems = topologicalSort(parentItem.subItems, subItemIds);

                                // Collect all expanded children that need rendering in next generation
                                const allExpandedGrandchildren = [];

                                // Render all subtasks horizontally first (same generation on same row)
                                sortedSubItems.forEach((subItem, index) => {
                                    const subItemDiv = document.createElement('div');
                                    subItemDiv.className = `tree-node item phase-${phaseNum} subtask`;
                                    subItemDiv.dataset.itemId = subItem.id;
                                    // BUILD 415: Track depth for shape hierarchy opacity fade
                                    subItemDiv.dataset.depth = nestLevel + 3; // root=0, phase=1, item=2, subtask=3+

                                    // Ensure subItem has type set
                                    if (!subItem.type) {
                                        subItem.type = 'subtask';
                                    }

                                    // Status color indicator
                                    const statusColors = {
                                        'To Do': '#9CA3AF',
                                        'In Progress': '#3B82F6',
                                        'Completed': '#10B981',
                                        'Done': '#10B981',
                                        'Blocked': '#EF4444'
                                    };
                                    const statusColor = statusColors[subItem.pmStatus] || '#9CA3AF';

                                    // Get initials from assignee name
                                    const getInitials = (name) => {
                                        if (!name || name === 'Unassigned') return '?';
                                        const parts = name.trim().split(' ');
                                        if (parts.length === 1) return parts[0].substring(0, 2).toUpperCase();
                                        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                                    };

                                    // Check if this task has children
                                    const hasChildren = subItem.subItems && subItem.subItems.length > 0;
                                    const chevronIcon = hasChildren ? (subItem.expanded ? 'â–¼' : 'â–¶') : '';

                                    // RAG Status for subtasks
                                    const subRAGColors = {
                                        'Green': '#22C55E',
                                        'Amber': '#F59E0B',
                                        'Red': '#EF4444'
                                    };
                                    const subRAGStatus = subItem.pmRAGStatus;
                                    const ragDot = subRAGStatus ?
                                        `<div style="width: 8px; height: 8px; border-radius: 50%; background: ${subRAGColors[subRAGStatus]}; box-shadow: 0 0 4px ${subRAGColors[subRAGStatus]}; flex-shrink: 0; position: absolute; top: -2px; right: -2px; border: 1.5px solid var(--card-bg-light);" title="RAG: ${subRAGStatus}"></div>` : '';

                                    subItemDiv.innerHTML = `
                                        <div style="display: flex; flex-direction: column; gap: 6px; width: 100%; height: 100%;">
                                            <!-- Task Title with optional chevron -->
                                            <div style="display: flex; align-items: flex-start; gap: 4px;">
                                                ${chevronIcon ? `<span style="font-size: 8px; color: var(--text-secondary); cursor: pointer; margin-top: 2px;" class="task-chevron">${chevronIcon}</span>` : ''}
                                                <div style="font-size: 11px; font-weight: 600; line-height: 1.2; color: var(--text-primary); flex: 1; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                                                    ${safeNodeName(subItem)}
                                                </div>
                                            </div>

                                            <!-- Visual Indicators Row -->
                                            <div style="display: flex; align-items: center; gap: 6px; margin-top: auto;">
                                                <!-- Status Dot with RAG overlay -->
                                                <div style="position: relative; width: 12px; height: 12px; flex-shrink: 0;">
                                                    <div style="width: 12px; height: 12px; border-radius: 50%; background: ${statusColor}; box-shadow: 0 0 6px ${statusColor}; flex-shrink: 0;" title="${subItem.pmStatus || 'To Do'}"></div>
                                                    ${ragDot}
                                                </div>

                                                <!-- Owner Badge -->
                                                <div style="width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; color: white; flex-shrink: 0;" title="${subItem.pmOwnerEmail || subItem.pmAssignee || 'Unassigned'}">
                                                    ${getInitials(subItem.pmOwnerEmail || subItem.pmAssignee)}
                                                </div>

                                                <!-- Progress % -->
                                                <div style="font-size: 11px; font-weight: 700; color: var(--treeplex-primary); margin-left: auto;" title="Progress">
                                                    ${subItem.pmProgress || 0}%
                                                </div>
                                            </div>

                                            <!-- Mini Progress Bar -->
                                            <div style="width: 100%; height: 3px; background: rgba(0, 0, 0, 0.3); border-radius: 2px; overflow: hidden;">
                                                <div style="height: 100%; width: ${subItem.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                                            </div>
                                        </div>
                                    `;

                                    // Click to show info panel AND toggle nested subtasks
                                    subItemDiv.addEventListener('click', (e) => {
                                        e.stopPropagation();

                                        const panel = document.getElementById('info-panel');
                                        const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === subItem.id;

                                        if (isPanelOpen) {
                                            // Second click: Close panel and collapse nested subtasks
                                            panel.classList.remove('open');
                                            currentOpenItemId = null;
                                            if (hasChildren) {
                                                subItem.expanded = false;

                                                // Preserve scroll position during re-render (both vertical and horizontal)
                                                const treeContainer = document.getElementById('tree-container');
                                                const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                                const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                                render();

                                                // Restore scroll position after render
                                                if (treeContainer) {
                                                    setTimeout(() => {
                                                        treeContainer.scrollTop = scrollTop;
                                                        treeContainer.scrollLeft = scrollLeft;
                                                    }, 0);
                                                }
                                            }
                                        } else {
                                            // First click: Open panel and expand nested subtasks
                                            showInfo(subItem);
                                            if (hasChildren) {
                                                subItem.expanded = true;

                                                // Preserve scroll position during re-render (both vertical and horizontal)
                                                const treeContainer = document.getElementById('tree-container');
                                                const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                                const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                                render();

                                                // Restore scroll position after render
                                                if (treeContainer) {
                                                    setTimeout(() => {
                                                        treeContainer.scrollTop = scrollTop;
                                                        treeContainer.scrollLeft = scrollLeft;
                                                    }, 0);
                                                }
                                            }
                                        }
                                    });

                                    subItemDiv.addEventListener('contextmenu', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        activeNode = subItem;
                                        showContextMenu(e.pageX, e.pageY);
                                    });

                                    subtaskContainer.appendChild(subItemDiv);

                                    // Collect expanded children for next generation
                                    if (subItem.expanded && subItem.subItems && subItem.subItems.length > 0) {
                                        allExpandedGrandchildren.push(subItem);
                                    }
                                });

                                containerEl.appendChild(subtaskContainer);

                                // Now render ALL children of this generation on the NEXT horizontal row below
                                allExpandedGrandchildren.forEach(expandedChild => {
                                    renderSubtasks(expandedChild, containerEl, phaseNum, nestLevel + 1);
                                });
                            }

                            // Initial call to render subtasks
                            renderSubtasks(item, itemsColumn, node.phase, 0);
                        });

                        tableEl.appendChild(itemsColumn);
                    }

                    // Recursively render next phase
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => buildColumn(child));
                    }
                }
            }

            buildColumn(capexTree);
            container.appendChild(tableEl);

            // Draw dependency lines after rendering
            setTimeout(drawDependencyLines, 100);

            // BUILD 566: Auto-refresh non-tree views if active
            // This ensures views stay in sync when render() is called
            if (viewMode === 'canvas') {
                setTimeout(() => renderCanvas(), 50);
            } else if (viewMode === '3d') {
                setTimeout(() => render3D(), 50);
            }
        }

        // Draw dependency lines using SVG
        function drawDependencyLines() {
            const svg = document.getElementById('dependency-svg');
            const treeEl = document.getElementById('tree-root');
            const wrapperEl = document.getElementById('tree-transform-wrapper');

            // Clear existing lines
            svg.innerHTML = '';

            // Set SVG dimensions to be large enough for panning/zooming
            // Use a fixed large size that the CSS will position correctly
            svg.setAttribute('width', '20000');
            svg.setAttribute('height', '20000');

            // Add arrow marker definitions
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Create markers for each phase color - using darker vibrant colors
            const colors = {
                'phase-0': '#4CAF50',
                'phase-1': '#2196F3',
                'phase-2': '#FB8C00',
                'cross-phase': '#008F6D'
            };

            Object.entries(colors).forEach(([className, color]) => {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', `arrow-${className}`);
                marker.setAttribute('viewBox', '0 0 10 10');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '5');
                marker.setAttribute('markerWidth', '8');
                marker.setAttribute('markerHeight', '8');
                marker.setAttribute('orient', 'auto');

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                path.setAttribute('fill', color);
                path.setAttribute('opacity', '0.8');
                path.setAttribute('filter', 'drop-shadow(0 2px 2px rgba(0,0,0,0.2))');

                marker.appendChild(path);
                defs.appendChild(marker);
            });

            svg.appendChild(defs);

            // Find all items with dependencies
            function getAllItems(node, items = [], phase = null) {
                if (node.phase !== undefined) phase = node.phase;
                if (node.items) {
                    node.items.forEach(item => items.push({ ...item, currentPhase: phase }));
                }
                if (node.children) {
                    node.children.forEach(child => getAllItems(child, items, phase));
                }
                return items;
            }

            const allItems = getAllItems(capexTree);

            // Helper to find item phase
            function findItemPhase(itemId) {
                const item = allItems.find(i => i.id === itemId);
                return item ? item.currentPhase : null;
            }

            // Draw lines for each dependency
            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    const targetEl = document.querySelector(`[data-item-id="${item.id}"]`);
                    if (!targetEl) return;

                    item.dependencies.forEach(depId => {
                        const sourceEl = document.querySelector(`[data-item-id="${depId}"]`);
                        if (!sourceEl) return;

                        // Get positions in tree's local coordinate space (not viewport)
                        // This accounts for the transform by using offsetLeft/Top instead of getBoundingClientRect
                        function getElementPosition(el) {
                            let x = 0;
                            let y = 0;
                            let current = el;

                            // Walk up to the tree root to get cumulative offset
                            while (current && current !== treeEl.parentElement) {
                                x += current.offsetLeft || 0;
                                y += current.offsetTop || 0;
                                current = current.offsetParent;
                            }

                            return { x, y, width: el.offsetWidth, height: el.offsetHeight };
                        }

                        const sourcePos = getElementPosition(sourceEl);
                        const targetPos = getElementPosition(targetEl);

                        // SVG offset constant (matches CSS top/left offset)
                        const SVG_OFFSET = 5000;

                        const x1 = sourcePos.x + sourcePos.width + SVG_OFFSET;
                        const y1 = sourcePos.y + sourcePos.height / 2 + SVG_OFFSET;
                        const x2 = targetPos.x + SVG_OFFSET;
                        const y2 = targetPos.y + targetPos.height / 2 + SVG_OFFSET;

                        // Determine if cross-phase dependency
                        const sourcePhase = findItemPhase(depId);
                        const targetPhase = item.currentPhase;
                        const isCrossPhase = sourcePhase !== targetPhase;

                        // Skip same-phase dependencies - only draw cross-phase arrows
                        if (!isCrossPhase) return;

                        const lineClass = 'cross-phase';

                        // Create curved path (quadratic bezier)
                        const midX = (x1 + x2) / 2;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const d = `M ${x1} ${y1} Q ${midX} ${y1}, ${midX} ${(y1 + y2) / 2} T ${x2} ${y2}`;

                        path.setAttribute('d', d);
                        path.setAttribute('class', `dependency-line ${lineClass}`);
                        path.setAttribute('marker-end', `url(#arrow-${lineClass})`);

                        // Add tooltip
                        const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                        title.textContent = `${depId} â†’ ${item.id}${isCrossPhase ? ' (cross-phase)' : ''}`;
                        path.appendChild(title);

                        svg.appendChild(path);
                    });
                }
            });

            // =================================================================
            // DRAW PARENT-CHILD CONNECTORS FOR TASKS (Symmetrical Grey Lines)
            // =================================================================
            // Find all subtasks and draw symmetrical connectors to their parent items
            function getAllSubtasksWithParent(node, subtasks = []) {
                if (node.items) {
                    node.items.forEach(item => {
                        if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                            // Collect parent with all its children for symmetrical layout
                            subtasks.push({
                                parent: item,
                                children: item.subItems
                            });

                            // Recursively handle nested tasks
                            item.subItems.forEach(subtask => {
                                if (subtask.subItems && Array.isArray(subtask.subItems) && subtask.subItems.length > 0) {
                                    subtasks.push({
                                        parent: subtask,
                                        children: subtask.subItems
                                    });
                                }
                            });
                        }
                    });
                }
                if (node.children) {
                    node.children.forEach(child => getAllSubtasksWithParent(child, subtasks));
                }
                return subtasks;
            }

            const allParentChildPairs = getAllSubtasksWithParent(capexTree);

            // Helper to get element position
            function getElementPosition(el) {
                let x = 0;
                let y = 0;
                let current = el;

                while (current && current !== treeEl.parentElement) {
                    x += current.offsetLeft || 0;
                    y += current.offsetTop || 0;
                    current = current.offsetParent;
                }

                return { x, y, width: el.offsetWidth, height: el.offsetHeight };
            }

            const SVG_OFFSET = 5000;

            allParentChildPairs.forEach(({ parent, children }) => {
                const parentEl = document.querySelector(`[data-item-id="${parent.id}"]`);
                if (!parentEl) return;

                const parentPos = getElementPosition(parentEl);

                // Draw symmetrical lines from parent to each child
                children.forEach(child => {
                    const childEl = document.querySelector(`[data-item-id="${child.id}"]`);
                    if (!childEl) return;

                    const childPos = getElementPosition(childEl);

                    // Start from bottom-center of parent
                    const x1 = parentPos.x + parentPos.width / 2 + SVG_OFFSET;
                    const y1 = parentPos.y + parentPos.height + SVG_OFFSET;

                    // End at top-center of child
                    const x2 = childPos.x + childPos.width / 2 + SVG_OFFSET;
                    const y2 = childPos.y + SVG_OFFSET;

                    // Create symmetrical line (no arrow head)
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', 'rgba(128, 128, 128, 0.4)');  // Grey
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('opacity', '0.6');

                    // Add tooltip
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = `${parent.name} â†’ ${child.name}`;
                    line.appendChild(title);

                    svg.appendChild(line);
                });
            });
        }


        // BUILD 534: Open file from info panel via MCP Bridge (local files) or browser (web URLs)
        function openFileFromInfoPanel(url, isLocalPath, isGoogleNative, fileExt) {
            // For local files and Google native files, use MCP Bridge if connected
            if (isLocalPath || isGoogleNative) {
                const localPath = isLocalPath ? url.replace('file:///', '').replace(/\//g, '\\') : url;

                // Check if MCP WebSocket is connected (client uses 'socket' property)
                const wsReady = window.mcpBridgeState?.client?.socket?.readyState === WebSocket.OPEN;
                console.log('[MCP File Open] WebSocket ready:', wsReady, 'readyState:', window.mcpBridgeState?.client?.socket?.readyState);

                if (wsReady) {
                    try {
                        // Send direct message to MCP Bridge to open file
                        const msg = { type: 'open_file', filePath: localPath };
                        console.log('[MCP File Open] Sending:', msg);
                        mcpBridgeState.client.socket.send(JSON.stringify(msg));

                        if (isGoogleNative) {
                            showToast(`ğŸ”— Opening ${fileExt}...`, 'info');
                        } else {
                            showToast('ğŸ“‚ Opening file...', 'info');
                        }
                        return;
                    } catch (e) {
                        console.error('[MCP File Open] Send failed:', e);
                        // Fall through to clipboard fallback
                    }
                }

                // MCP not connected - show connect prompt with clipboard fallback
                if (isGoogleNative) {
                    showToast(`âš ï¸ Connect Claude Code to open ${fileExt} files`, 'warning');
                } else {
                    // Copy path to clipboard as fallback
                    navigator.clipboard.writeText(localPath).then(() => {
                        showToast('ğŸ“‹ Path copied! Connect Claude Code for direct file opening.', 'info');
                    }).catch(() => {
                        prompt('Copy this path (connect Claude Code for direct opening):', localPath);
                    });
                }
                return;
            }

            // Regular web URL - just open it in browser
            window.open(url, '_blank');
            showToast('ğŸ”— Opening in new tab...', 'success');
        }

        // Info Panel
        function showInfo(node) {
            const panel = document.getElementById('info-panel');
            const titleElement = document.getElementById('info-title');
            const labels = getPatternLabels();
            const pattern = PATTERNS[currentPattern];

            // BUILD 422: Enhanced titles for root/phase/subtask nodes
            if (node.type === 'root') {
                const phases = node.children || [];
                const totalItems = phases.reduce((sum, p) => sum + (p.items?.length || 0), 0);
                titleElement.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                        <span style="font-size: 36px;">${node.icon || 'ğŸŒ³'}</span>
                        <div>
                            <div style="font-size: 22px; font-weight: 700; color: var(--text-primary); line-height: 1.2;">${node.name}</div>
                            <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">${labels.root} â€¢ ${phases.length} ${labels.phase}s â€¢ ${totalItems} ${labels.item}s</div>
                        </div>
                    </div>
                    <button onclick="showEditDetailsModal(activeNode)" style="padding: 8px 14px; background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark)); border: none; border-radius: 8px; color: white; font-size: 12px; font-weight: 600; cursor: pointer; margin-top: 8px;">
                        ğŸ“ Edit Project Details
                    </button>
                `;
            } else if (node.type === 'phase') {
                const items = node.items || [];
                titleElement.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                        <span style="font-size: 36px;">${node.icon || 'ğŸ“‹'}</span>
                        <div>
                            <div style="font-size: 22px; font-weight: 700; color: var(--text-primary); line-height: 1.2;">${node.name}</div>
                            ${node.subtitle ? `<div style="font-size: 13px; color: var(--treeplex-primary); margin-top: 2px;">${node.subtitle}</div>` : ''}
                            <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">${labels.phase} â€¢ ${items.length} ${labels.item}s</div>
                        </div>
                    </div>
                    <button onclick="showEditDetailsModal(activeNode)" style="padding: 8px 14px; background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark)); border: none; border-radius: 8px; color: white; font-size: 12px; font-weight: 600; cursor: pointer; margin-top: 8px;">
                        ğŸ“ Edit Phase Details
                    </button>
                `;
            } else if (node.type === 'subtask') {
                titleElement.innerHTML = `
                    <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); line-height: 1.3;">
                        ${node.name}
                    </div>
                `;
            } else {
                titleElement.textContent = `${node.icon || 'ğŸ“„'} ${node.name}`;
            }

            const body = document.getElementById('info-body');

            // Build dependencies section (supports both legacy string IDs and typed objects)
            let depsHtml = '';
            if (node.dependencies && node.dependencies.length > 0) {
                const depNames = node.dependencies.map(dep => {
                    // Handle both string IDs (legacy) and typed objects (Build 446+)
                    const depId = typeof dep === 'string' ? dep : (dep.predecessorId || dep);
                    const depType = typeof dep === 'object' ? dep.type : 'FS';
                    const depLag = typeof dep === 'object' ? (dep.lag || 0) : 0;

                    // Find the dependency item to get its name
                    function findItemById(id, n = capexTree) {
                        if (n.id === id) return n;
                        if (n.items) {
                            const found = n.items.find(i => i.id === id);
                            if (found) return found;
                        }
                        if (n.children) {
                            for (let child of n.children) {
                                const found = findItemById(id, child);
                                if (found) return found;
                            }
                        }
                        return null;
                    }
                    const depItem = findItemById(depId);
                    const itemName = depItem ? `${depItem.icon || 'ğŸ“„'} ${depItem.name || depItem.title}` : depId;

                    // Show type info if not standard FS+0
                    let typeInfo = '';
                    if (depType !== 'FS' || depLag !== 0) {
                        typeInfo = ` <span style="color: var(--primary); font-size: 0.85em;">(${depType}${depLag ? `+${depLag}d` : ''})</span>`;
                    }

                    return itemName + typeInfo;
                }).join('<br>');

                depsHtml = `
                    <div class="info-section">
                        <h4>DEPENDENCIES</h4>
                        <p style="line-height: 1.8;">${depNames}</p>
                    </div>
                `;
            }

            // Build dependents section (items that depend on this one)
            let dependentsHtml = '';
            if (node.id) {
                function findDependents(nodeId, n = capexTree, dependents = []) {
                    // Helper to check if an item depends on nodeId
                    function hasDependencyOn(item, targetId) {
                        if (!item.dependencies || !Array.isArray(item.dependencies)) return false;
                        return item.dependencies.some(dep => {
                            // Handle both string IDs (legacy) and typed objects (Build 446+)
                            const depId = typeof dep === 'string' ? dep : (dep.predecessorId || '');
                            return depId === targetId;
                        });
                    }

                    if (n.items) {
                        n.items.forEach(item => {
                            if (hasDependencyOn(item, nodeId)) {
                                dependents.push(item);
                            }
                        });
                    }
                    if (n.children) {
                        n.children.forEach(child => findDependents(nodeId, child, dependents));
                    }
                    return dependents;
                }

                const dependents = findDependents(node.id);
                if (dependents.length > 0) {
                    const depList = dependents.map(d => `${d.icon || 'ğŸ“„'} ${d.name || d.title}`).join('<br>');
                    dependentsHtml = `
                        <div class="info-section">
                            <h4>Required By</h4>
                            <p style="line-height: 1.8;">${depList}</p>
                        </div>
                    `;
                }
            }

            // Build PM Dashboard section for subtasks (only if pattern has tracking enabled)
            let pmDashboardHtml = '';
            // Note: 'pattern' already declared at line 19629 in this function
            const hasTracking = pattern.fields?.includeTracking === true;

            if (node.type === 'subtask' && hasTracking) {
                const statusColors = {
                    'To Do': { bg: 'rgba(156, 163, 175, 0.3)', color: '#9CA3AF' },
                    'In Progress': { bg: 'rgba(59, 130, 246, 0.3)', color: '#3B82F6' },
                    'Completed': { bg: 'rgba(16, 185, 129, 0.3)', color: '#10B981' },
                    'Blocked': { bg: 'rgba(239, 68, 68, 0.3)', color: '#EF4444' }
                };
                const statusStyle = statusColors[node.pmStatus] || statusColors['To Do'];

                const priorityEmojis = { 'Low': 'ğŸŸ¢', 'Medium': 'ğŸŸ¡', 'High': 'ğŸŸ ', 'Critical': 'ğŸ”´' };
                const priorityEmoji = priorityEmojis[node.pmPriority] || 'âšª';

                // Calculate days until/since due date
                let dueDateInfo = '';
                if (node.pmDueDate) {
                    const dueDate = new Date(node.pmDueDate);
                    const today = new Date();
                    const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                    if (diffDays < 0) {
                        dueDateInfo = `<span style="color: #EF4444; font-weight: 600;">âš ï¸ ${Math.abs(diffDays)} days overdue</span>`;
                    } else if (diffDays === 0) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">ğŸ“… Due today!</span>`;
                    } else if (diffDays <= 3) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">â° ${diffDays} days left</span>`;
                    } else {
                        dueDateInfo = `<span style="color: var(--text-secondary);">${diffDays} days left</span>`;
                    }
                }

                pmDashboardHtml = `
                    <!-- Status + Progress Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: ${statusStyle.bg}; border-radius: 10px; border: 2px solid ${statusStyle.color};">
                            <div style="font-size: 28px; font-weight: 700; color: ${statusStyle.color};">
                                ${node.pmStatus || 'To Do'}
                            </div>
                        </div>
                        <div style="flex: 1; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); border-radius: 10px; border: 2px solid rgba(0, 166, 125, 0.4); display: flex; flex-direction: column; justify-content: center;">
                            <div style="font-size: 36px; font-weight: 700; color: var(--treeplex-primary); line-height: 1;">${node.pmProgress || 0}%</div>
                            <div style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden; margin-top: 8px;">
                                <div style="height: 100%; width: ${node.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Owner + Priority Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; align-items: center; gap: 12px;">
                            <div style="width: 48px; height: 48px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: 700; color: white; flex-shrink: 0;">
                                ${node.pmAssignee ? node.pmAssignee.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2) : '?'}
                            </div>
                            <div style="font-size: 18px; font-weight: 600;">${node.pmAssignee || 'Unassigned'}</div>
                        </div>
                        <div style="width: 120px; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <div style="font-size: 40px; margin-bottom: 4px;">${priorityEmoji}</div>
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-secondary);">${node.pmPriority || 'Medium'}</div>
                        </div>
                    </div>

                    <!-- Timeline -->
                    <div style="padding: 16px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-around; margin-bottom: 12px;">
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">ğŸ“…</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmStartDate ? new Date(node.pmStartDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                            <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
                                <div style="height: 2px; flex: 1; background: linear-gradient(90deg, var(--treeplex-primary), transparent);"></div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">ğŸ¯</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmDueDate ? new Date(node.pmDueDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                        </div>
                        ${dueDateInfo ? `<div style="text-align: center; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; font-size: 13px;">${dueDateInfo}</div>` : ''}
                    </div>

                    <!-- Notes -->
                    ${node.pmNotes ? `
                        <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; border-left: 4px solid var(--treeplex-primary); margin-bottom: 16px;">
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary);">${node.pmNotes}</div>
                        </div>
                    ` : ''}

                    <!-- Blocking Issue -->
                    ${node.pmBlockingIssue ? `
                        <div style="padding: 14px; background: rgba(239, 68, 68, 0.15); border-radius: 10px; border-left: 4px solid #EF4444; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">ğŸš§</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #FCA5A5;">${node.pmBlockingIssue}</div>
                        </div>
                    ` : ''}

                    <!-- Next Steps -->
                    ${node.pmNextSteps ? `
                        <div style="padding: 14px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; border-left: 4px solid #3B82F6; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">â¡ï¸</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #93C5FD;">${node.pmNextSteps}</div>
                        </div>
                    ` : ''}

                    <!-- Latest Updates -->
                    ${node.pmUpdates && node.pmUpdates.length > 0 ? `
                        <div style="max-height: 300px; overflow-y: auto;">
                            ${node.pmUpdates.map(update => `
                                <div style="margin-bottom: 10px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 6px;">
                                        ğŸ“… ${new Date(update.timestamp).toLocaleString('en-US', {month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'})}
                                    </div>
                                    <div style="font-size: 13px; line-height: 1.5; white-space: pre-wrap;">${update.text}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            }

            // BUILD 422: Enhanced infographic for root and phase nodes
            let keyNodeInfoHtml = '';
            if (node.type === 'root') {
                const phases = node.children || [];
                const totalItems = phases.reduce((sum, p) => sum + (p.items?.length || 0), 0);
                const totalSubtasks = phases.reduce((sum, p) => {
                    return sum + (p.items || []).reduce((s, item) => s + (item.subtasks?.length || item.subItems?.length || 0), 0);
                }, 0);
                const totalCost = pattern.fields?.cost ? calculateTotal(node) : 0;

                keyNodeInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.12), rgba(139, 92, 246, 0.08)); border-radius: 16px; padding: 24px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 14px; font-weight: 700; color: var(--treeplex-primary); text-transform: uppercase; letter-spacing: 1px;">ğŸ“Š Project Dashboard</div>
                        </div>

                        <!-- Stats Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            <div style="padding: 16px; background: rgba(99, 102, 241, 0.15); border-radius: 12px; text-align: center;">
                                <div style="font-size: 32px; font-weight: 700; color: #6366F1;">${phases.length}</div>
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase;">${labels.phase}s</div>
                            </div>
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.15); border-radius: 12px; text-align: center;">
                                <div style="font-size: 32px; font-weight: 700; color: #3B82F6;">${totalItems}</div>
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase;">${labels.item}s</div>
                            </div>
                            <div style="padding: 16px; background: rgba(139, 92, 246, 0.15); border-radius: 12px; text-align: center;">
                                <div style="font-size: 32px; font-weight: 700; color: #8B5CF6;">${totalSubtasks}</div>
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase;">${labels.subtask}s</div>
                            </div>
                            ${totalCost > 0 ? `
                                <div style="padding: 16px; background: rgba(16, 185, 129, 0.15); border-radius: 12px; text-align: center;">
                                    <div style="font-size: 24px; font-weight: 700; color: #10B981;">${formatCost(totalCost)}</div>
                                    <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase;">Total Cost</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Goals Section -->
                        ${node.goals ? `
                            <div style="padding: 16px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; margin-bottom: 16px; border-left: 4px solid #F59E0B;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; text-transform: uppercase; margin-bottom: 8px;">ğŸ¯ Goals & Objectives</div>
                                <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.goals}</div>
                            </div>
                        ` : ''}

                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="handleAnalyzeSelection([activeNode])" style="flex: 1; min-width: 140px; padding: 10px 16px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(99, 102, 241, 0.2)); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 8px; color: #A78BFA; font-size: 12px; font-weight: 600; cursor: pointer;">
                                ğŸ“ Deep Dive Analysis
                            </button>
                            <button onclick="handleAI()" style="flex: 1; min-width: 140px; padding: 10px 16px; background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2)); border: 1px solid rgba(59, 130, 246, 0.4); border-radius: 8px; color: #60A5FA; font-size: 12px; font-weight: 600; cursor: pointer;">
                                ğŸ” Quick Insight
                            </button>
                        </div>
                    </div>
                `;
            } else if (node.type === 'phase') {
                const items = node.items || [];
                const totalSubtasks = items.reduce((sum, item) => sum + (item.subtasks?.length || item.subItems?.length || 0), 0);
                const totalCost = pattern.fields?.cost ? calculatePhaseTotal(node) : 0;

                // Determine phase color based on phase index
                const phaseIdx = (capexTree.children || []).findIndex(p => p.id === node.id);
                const phaseColors = ['#3a5a5a', '#4a4a5f', '#3a4a5f', '#3a5a4a', '#5a4a50', '#5a5040'];
                const phaseColor = phaseColors[phaseIdx % phaseColors.length];

                keyNodeInfoHtml = `
                    <div style="background: linear-gradient(135deg, ${phaseColor}22, ${phaseColor}11); border-radius: 16px; padding: 24px; margin-bottom: 24px; border: 2px solid ${phaseColor}66;">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 14px; font-weight: 700; color: ${phaseColor}; text-transform: uppercase; letter-spacing: 1px; filter: brightness(1.5);">ğŸ“‹ ${labels.phase} Overview</div>
                        </div>

                        <!-- Stats Row -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 100px; padding: 16px; background: rgba(59, 130, 246, 0.15); border-radius: 12px; text-align: center;">
                                <div style="font-size: 32px; font-weight: 700; color: #3B82F6;">${items.length}</div>
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase;">${labels.item}s</div>
                            </div>
                            <div style="flex: 1; min-width: 100px; padding: 16px; background: rgba(139, 92, 246, 0.15); border-radius: 12px; text-align: center;">
                                <div style="font-size: 32px; font-weight: 700; color: #8B5CF6;">${totalSubtasks}</div>
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase;">${labels.subtask}s</div>
                            </div>
                            ${totalCost > 0 ? `
                                <div style="flex: 1; min-width: 100px; padding: 16px; background: rgba(16, 185, 129, 0.15); border-radius: 12px; text-align: center;">
                                    <div style="font-size: 24px; font-weight: 700; color: #10B981;">${formatCost(totalCost)}</div>
                                    <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase;">Phase Cost</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Timeline -->
                        ${node.startDate || node.endDate ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; margin-bottom: 16px; display: flex; justify-content: space-around; align-items: center;">
                                <div style="text-align: center;">
                                    <div style="font-size: 20px;">ğŸ“…</div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${node.startDate ? new Date(node.startDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'}) : 'Not set'}</div>
                                    <div style="font-size: 10px; color: var(--text-secondary);">Start</div>
                                </div>
                                <div style="flex: 1; height: 2px; background: linear-gradient(90deg, var(--treeplex-primary), transparent); margin: 0 16px;"></div>
                                <div style="text-align: center;">
                                    <div style="font-size: 20px;">ğŸ¯</div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${node.endDate ? new Date(node.endDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'}) : 'Not set'}</div>
                                    <div style="font-size: 10px; color: var(--text-secondary);">End</div>
                                </div>
                            </div>
                        ` : ''}

                        <!-- Goals Section -->
                        ${node.goals ? `
                            <div style="padding: 16px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; margin-bottom: 16px; border-left: 4px solid #F59E0B;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; text-transform: uppercase; margin-bottom: 8px;">ğŸ¯ Goals & Objectives</div>
                                <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.goals}</div>
                            </div>
                        ` : ''}

                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="handleAnalyzeSelection([activeNode])" style="flex: 1; min-width: 140px; padding: 10px 16px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(99, 102, 241, 0.2)); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 8px; color: #A78BFA; font-size: 12px; font-weight: 600; cursor: pointer;">
                                ğŸ“ Deep Dive Analysis
                            </button>
                            <button onclick="handleAI()" style="flex: 1; min-width: 140px; padding: 10px 16px; background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2)); border: 1px solid rgba(59, 130, 246, 0.4); border-radius: 8px; color: #60A5FA; font-size: 12px; font-weight: 600; cursor: pointer;">
                                ğŸ” Quick Insight
                            </button>
                        </div>
                    </div>
                `;
            }

            // Build pattern-specific infographic (geometric and visual)
            let patternInfoHtml = '';

            // SALES PIPELINE - Funnel with probability
            if (currentPattern === 'sales' && (node.dealValue || node.stageProbability || node.expectedCloseDate || node.competitorInfo)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(16, 185, 129, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #10B981; margin-bottom: 8px;">ğŸ’¼ Sales Deal Pipeline</div>
                        </div>

                        <!-- Deal Value + Probability Row -->
                        <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                            ${node.dealValue ? `
                                <div style="flex: 1; padding: 20px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ğŸ’° Deal Value</div>
                                    <div style="font-size: 32px; font-weight: 700; color: #10B981;">$${node.dealValue.toLocaleString()}</div>
                                </div>
                            ` : ''}
                            ${node.stageProbability !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ğŸ“Š Close Probability</div>
                                    <div style="font-size: 32px; font-weight: 700; color: #3B82F6;">${node.stageProbability}%</div>
                                    <div style="width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; overflow: hidden; margin-top: 12px;">
                                        <div style="height: 100%; width: ${node.stageProbability}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Expected Revenue (Value Ã— Probability) -->
                        ${node.dealValue && node.stageProbability !== undefined ? `
                            <div style="text-align: center; padding: 16px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; margin-bottom: 20px;">
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">Expected Revenue (Value Ã— Probability)</div>
                                <div style="font-size: 24px; font-weight: 700; color: #F59E0B;">$${Math.round(node.dealValue * (node.stageProbability / 100)).toLocaleString()}</div>
                            </div>
                        ` : ''}

                        <!-- Timeline & Contact -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.expectedCloseDate ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ“… Target Close</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${new Date(node.expectedCloseDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                            ${node.contactPerson ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ‘¤ Contact</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.contactPerson}</div>
                                </div>
                            ` : ''}
                            ${node.leadSource ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ“ Source</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.leadSource}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Competitor Info -->
                        ${node.competitorInfo ? `
                            <div style="padding: 16px; background: rgba(239, 68, 68, 0.12); border-left: 4px solid #EF4444; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #EF4444; margin-bottom: 8px; text-transform: uppercase;">ğŸ¯ Competitive Landscape</div>
                                <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.competitorInfo}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILM/VIDEO - Scene storyboard card
            else if (currentPattern === 'film' && (node.videoPrompt || node.aiPlatform || node.cameraMovement)) {
                const platformColors = {
                    'Sora (OpenAI)': '#74aa9c',
                    'Veo 3 (Google)': '#4285f4',
                    'Runway Gen-3': '#6366f1',
                    'Pika 2.0': '#f59e0b',
                    'Testing Multiple': '#8b5cf6'
                };
                const platformColor = platformColors[node.aiPlatform] || '#9ca3af';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ğŸ¬ AI Video Scene</div>
                        </div>

                        <!-- Platform & Technical Specs -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.aiPlatform ? `
                                <div style="padding: 12px; background: rgba(${parseInt(platformColor.slice(1, 3), 16)}, ${parseInt(platformColor.slice(3, 5), 16)}, ${parseInt(platformColor.slice(5, 7), 16)}, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Platform</div>
                                    <div style="font-size: 13px; font-weight: 600; color: ${platformColor};">ğŸ¤– ${node.aiPlatform}</div>
                                </div>
                            ` : ''}
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #3B82F6;">â±ï¸ ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.aspectRatio ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Ratio</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #10B981;">ğŸ“ ${node.aspectRatio.split(' ')[0]}</div>
                                </div>
                            ` : ''}
                            ${node.visualStyle ? `
                                <div style="padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Style</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #A78BFA;">ğŸ¨ ${node.visualStyle}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Cinematography -->
                        ${node.cameraMovement || node.lightingMood || node.motionIntensity ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 12px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 12px; text-transform: uppercase;">ğŸ¥ Cinematography</div>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                    ${node.cameraMovement && node.cameraMovement !== 'Static' ? `
                                        <div style="padding: 8px 14px; background: rgba(245, 158, 11, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #F59E0B;">
                                            ğŸ“¹ ${node.cameraMovement}
                                        </div>
                                    ` : ''}
                                    ${node.lightingMood ? `
                                        <div style="padding: 8px 14px; background: rgba(251, 191, 36, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #FCD34D;">
                                            ğŸ’¡ ${node.lightingMood}
                                        </div>
                                    ` : ''}
                                    ${node.motionIntensity ? `
                                        <div style="padding: 8px 14px; background: rgba(59, 130, 246, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #60A5FA;">
                                            ğŸŒŠ ${node.motionIntensity}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}

                        <!-- Video Prompt (Main) -->
                        ${node.videoPrompt ? `
                            <div style="padding: 16px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid var(--treeplex-primary); border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px; text-transform: uppercase;">âœï¸ Video Prompt</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">${node.videoPrompt}</div>
                            </div>
                        ` : ''}

                        <!-- Iteration Notes -->
                        ${node.iterationNotes ? `
                            <div style="padding: 14px; background: rgba(139, 92, 246, 0.12); border-left: 4px solid #A78BFA; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #A78BFA; margin-bottom: 6px; text-transform: uppercase;">ğŸ“ Generation Notes</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.iterationNotes}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // PHILOSOPHY - Logical argument structure (already implemented)
            else if (currentPattern === 'philosophy' && (node.premise1 || node.premise2 || node.conclusion || node.objection || node.response)) {
                // Philosophy Pattern Infographic
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ğŸ¤” Philosophical Argument Structure</div>
                            ${node.speaker ? `<div style="font-size: 14px; color: var(--text-secondary);">ğŸ—£ï¸ Speaker: <span style="color: var(--text-primary); font-weight: 600;">${node.speaker}</span></div>` : ''}
                        </div>

                        <!-- Argument Metadata Row -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.argumentType ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Argument Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #60A5FA;">ğŸ¯ ${node.argumentType}</div>
                                </div>
                            ` : ''}
                            ${node.validity ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: ${node.validity === 'Valid' || node.validity === 'Sound' ? 'rgba(16, 185, 129, 0.15)' : 'rgba(239, 68, 68, 0.15)'}; border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Validity</div>
                                    <div style="font-size: 14px; font-weight: 600; color: ${node.validity === 'Valid' || node.validity === 'Sound' ? '#10B981' : '#EF4444'};">âœ“ ${node.validity}</div>
                                </div>
                            ` : ''}
                            ${node.philosophicalSchool ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">School</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">ğŸ›ï¸ ${node.philosophicalSchool}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Argument Flow: Premises â†’ Conclusion -->
                        ${node.premise1 || node.premise2 || node.conclusion ? `
                            <div style="margin-bottom: 24px;">
                                <div style="text-align: center; font-size: 13px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px;">âš¡ Logical Structure</div>

                                ${node.premise1 ? `
                                    <div style="position: relative; margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">1ï¸âƒ£ Premise 1</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.premise1}</div>
                                        </div>
                                        <div style="text-align: center; margin: 8px 0; font-size: 20px; color: var(--treeplex-primary);">â†“</div>
                                    </div>
                                ` : ''}

                                ${node.premise2 ? `
                                    <div style="position: relative; margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">2ï¸âƒ£ Premise 2</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.premise2}</div>
                                        </div>
                                        <div style="text-align: center; margin: 8px 0; font-size: 20px; color: var(--treeplex-primary);">â†“</div>
                                    </div>
                                ` : ''}

                                ${node.conclusion ? `
                                    <div style="position: relative;">
                                        <div style="text-align: center; margin-bottom: 8px;">
                                            <span style="display: inline-block; padding: 6px 16px; background: var(--treeplex-primary); color: white; border-radius: 20px; font-size: 13px; font-weight: 700;">âˆ´ THEREFORE</span>
                                        </div>
                                        <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1)); border: 2px solid #10B981; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">âœ“ Conclusion</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; font-weight: 500;">${node.conclusion}</div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Objection & Response (Dialectic) -->
                        ${node.objection || node.response ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 13px; font-weight: 700; color: #F59E0B; margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px;">âš”ï¸ Dialectical Challenge</div>

                                ${node.objection ? `
                                    <div style="margin-bottom: 12px;">
                                        <div style="background: rgba(239, 68, 68, 0.12); border-left: 4px solid #EF4444; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #EF4444; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">âŒ Objection</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.objection}</div>
                                        </div>
                                    </div>
                                ` : ''}

                                ${node.response ? `
                                    <div style="text-align: center; margin: 12px 0; font-size: 16px; color: var(--treeplex-primary);">â¤·</div>
                                    <div style="margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">ğŸ’¡ Response to Objection</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.response}</div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Key Concepts & References -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.keyTerms ? `
                                <div style="flex: 1; min-width: 200px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ“ Key Terms</div>
                                    <div style="font-size: 13px; line-height: 1.5; color: var(--text-primary);">${node.keyTerms}</div>
                                </div>
                            ` : ''}
                            ${node.textualReference ? `
                                <div style="flex: 1; min-width: 200px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ“– Reference</div>
                                    <div style="font-size: 13px; line-height: 1.5; color: var(--text-primary); font-family: monospace;">${node.textualReference}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // THESIS - Academic structure with argument â†’ evidence
            else if (currentPattern === 'thesis' && (node.keyArgument || node.citations || node.evidenceType)) {
                const progressPercent = node.targetWordCount ? Math.min(100, Math.round((node.wordCount / node.targetWordCount) * 100)) : 0;

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(16, 185, 129, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #10B981; margin-bottom: 8px;">ğŸ“ Academic Section</div>
                        </div>

                        <!-- Word Count Progress -->
                        ${node.wordCount !== undefined || node.targetWordCount ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-radius: 10px; margin-bottom: 20px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="font-size: 13px; color: var(--text-secondary);">ğŸ“ Word Count</span>
                                    <span style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.wordCount || 0} / ${node.targetWordCount || '?'} words</span>
                                </div>
                                ${node.targetWordCount ? `
                                    <div style="width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; overflow: hidden;">
                                        <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                    <div style="text-align: center; margin-top: 6px; font-size: 12px; color: var(--text-secondary);">${progressPercent}% complete</div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Draft Status + Evidence Type -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.draftStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Status</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B;">âœï¸ ${node.draftStatus}</div>
                                </div>
                            ` : ''}
                            ${node.evidenceType ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Evidence</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">ğŸ”¬ ${node.evidenceType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Key Argument (Central claim) -->
                        ${node.keyArgument ? `
                            <div style="padding: 16px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase;">ğŸ’¡ Key Argument</div>
                                <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.keyArgument}</div>
                            </div>
                        ` : ''}

                        <!-- Citations -->
                        ${node.citations ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid #9ca3af; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">ğŸ“š Key Citations</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.citations}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // ROADMAP - Feature card with user impact & technical risk
            else if (currentPattern === 'roadmap' && (node.storyPoints || node.userImpact || node.technicalRisk)) {
                const impactColors = { 'High': '#10B981', 'Medium': '#F59E0B', 'Low': '#9CA3AF' };
                const riskColors = { 'Low': '#10B981', 'Medium': '#F59E0B', 'High': '#EF4444', 'Unknown': '#9CA3AF' };

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ğŸš€ Product Feature</div>
                        </div>

                        <!-- Story Points (Large) -->
                        ${node.storyPoints !== undefined ? `
                            <div style="text-align: center; padding: 24px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.1)); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">Effort Estimate</div>
                                <div style="font-size: 48px; font-weight: 700; color: var(--treeplex-primary); line-height: 1;">${node.storyPoints}</div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">Story Points</div>
                            </div>
                        ` : ''}

                        <!-- Impact & Risk Matrix -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
                            ${node.userImpact ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(impactColors[node.userImpact].slice(1, 3), 16)}, ${parseInt(impactColors[node.userImpact].slice(3, 5), 16)}, ${parseInt(impactColors[node.userImpact].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">User Impact</div>
                                    <div style="font-size: 20px; font-weight: 700; color: ${impactColors[node.userImpact]};">ğŸ‘¥ ${node.userImpact}</div>
                                </div>
                            ` : ''}
                            ${node.technicalRisk ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(riskColors[node.technicalRisk].slice(1, 3), 16)}, ${parseInt(riskColors[node.technicalRisk].slice(3, 5), 16)}, ${parseInt(riskColors[node.technicalRisk].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Technical Risk</div>
                                    <div style="font-size: 20px; font-weight: 700; color: ${riskColors[node.technicalRisk]};">âš ï¸ ${node.technicalRisk}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Engineering Estimate & Feature Flag -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.engineeringEstimate ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">â±ï¸ Estimate</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.engineeringEstimate}</div>
                                </div>
                            ` : ''}
                            ${node.featureFlag ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸš© Feature Flag</div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--treeplex-primary); font-family: monospace;">${node.featureFlag}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // PROMPTING - Layered prompt structure
            else if (currentPattern === 'prompting' && (node.systemPrompt || node.userPromptTemplate || node.fewShotExamples)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(167, 139, 250, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(139, 92, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #8B5CF6; margin-bottom: 8px;">ğŸ§  Prompt Structure</div>
                        </div>

                        <!-- Model + Temperature -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.modelTarget ? `
                                <div style="flex: 1; min-width: 180px; padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Target Model</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #60A5FA;">ğŸ¤– ${node.modelTarget}</div>
                                </div>
                            ` : ''}
                            ${node.temperature !== undefined ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Temperature</div>
                                    <div style="font-size: 18px; font-weight: 700; color: #F59E0B;">ğŸ”¥ ${node.temperature}</div>
                                </div>
                            ` : ''}
                            ${node.maxTokens ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Max Tokens</div>
                                    <div style="font-size: 18px; font-weight: 700; color: #10B981;">ğŸ“ ${node.maxTokens}</div>
                                </div>
                            ` : ''}
                            ${node.testStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Status</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #A78BFA;">âœ… ${node.testStatus}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Layered Structure -->
                        ${node.systemPrompt ? `
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #8B5CF6; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 1: SYSTEM</span>
                                </div>
                                <div style="padding: 14px; background: rgba(139, 92, 246, 0.12); border-left: 4px solid #8B5CF6; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.systemPrompt}</div>
                                </div>
                            </div>
                        ` : ''}

                        ${node.userPromptTemplate ? `
                            <div style="text-align: center; margin: 12px 0; font-size: 18px; color: var(--treeplex-primary);">â†“</div>
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #3B82F6; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 2: USER PROMPT</span>
                                </div>
                                <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.userPromptTemplate}</div>
                                </div>
                            </div>
                        ` : ''}

                        ${node.fewShotExamples ? `
                            <div style="text-align: center; margin: 12px 0; font-size: 18px; color: var(--treeplex-primary);">â†“</div>
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #10B981; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 3: FEW-SHOT EXAMPLES</span>
                                </div>
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.fewShotExamples}</div>
                                </div>
                            </div>
                        ` : ''}

                        <!-- Test Results -->
                        ${node.testResults ? `
                            <div style="padding: 14px; background: rgba(245, 158, 11, 0.12); border-left: 4px solid #F59E0B; border-radius: 8px; margin-top: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 6px; text-transform: uppercase;">âœ… Test Results</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.testResults}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // BOOK - Narrative arc card
            else if (currentPattern === 'book' && (node.povCharacter || node.sceneSetting || node.plotFunction)) {
                const progressPercent = node.targetWordCount ? Math.min(100, Math.round((node.wordCount / node.targetWordCount) * 100)) : 0;

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.08), rgba(251, 146, 60, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(245, 158, 11, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #F59E0B; margin-bottom: 8px;">ğŸ“š Narrative Scene</div>
                        </div>

                        <!-- Word Count -->
                        ${node.wordCount !== undefined || node.targetWordCount ? `
                            <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-radius: 10px; margin-bottom: 16px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 12px; color: var(--text-secondary);">ğŸ“ Words</span>
                                    <span style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.wordCount || 0} / ${node.targetWordCount || '?'}</span>
                                </div>
                                ${node.targetWordCount ? `
                                    <div style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden;">
                                        <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- POV + Plot Function -->
                        <div style="display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">
                            ${node.povCharacter ? `
                                <div style="flex: 1; min-width: 180px; padding: 14px; background: rgba(139, 92, 246, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ‘¤ POV Character</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #A78BFA;">${node.povCharacter}</div>
                                </div>
                            ` : ''}
                            ${node.plotFunction ? `
                                <div style="flex: 1; min-width: 180px; padding: 14px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ“– Plot Function</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #10B981;">${node.plotFunction}</div>
                                </div>
                            ` : ''}
                            ${node.draftStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 14px; background: rgba(245, 158, 11, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">Status</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #F59E0B;">âœï¸ ${node.draftStatus}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Scene Setting -->
                        ${node.sceneSetting ? `
                            <div style="padding: 16px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid #F59E0B; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 8px; text-transform: uppercase;">ğŸ­ Scene Setting</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.sceneSetting}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // COURSE - Learning module
            else if (currentPattern === 'course' && (node.learningObjectives || node.duration || node.assessmentType)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(96, 165, 250, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">ğŸ“– Learning Module</div>
                        </div>

                        <!-- Duration + Difficulty + Assessment -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #10B981;">â±ï¸ ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.difficultyLevel ? `
                                <div style="padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Level</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B;">ğŸ“Š ${node.difficultyLevel}</div>
                                </div>
                            ` : ''}
                            ${node.assessmentType ? `
                                <div style="padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Assessment</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">âœ… ${node.assessmentType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Learning Objectives -->
                        ${node.learningObjectives ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase;">ğŸ“ Learning Objectives</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.learningObjectives}</div>
                            </div>
                        ` : ''}

                        <!-- Prerequisites & Resources -->
                        ${node.prerequisites || node.resourcesNeeded ? `
                            <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                                ${node.prerequisites ? `
                                    <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">ğŸ“‹ Prerequisites</div>
                                        <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.prerequisites}</div>
                                    </div>
                                ` : ''}
                                ${node.resourcesNeeded ? `
                                    <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">ğŸ“š Resources</div>
                                        <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.resourcesNeeded}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // EVENT PLANNING - Timeline with logistics grid
            else if (currentPattern === 'event' && (node.budget || node.vendor || node.guestCount || node.bookingDeadline)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(236, 72, 153, 0.08), rgba(219, 39, 119, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(236, 72, 153, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #EC4899; margin-bottom: 8px;">ğŸ‰ Event Activity</div>
                        </div>

                        <!-- Budget + Guest Count -->
                        <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                            ${node.budget !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ğŸ’° Budget</div>
                                    <div style="font-size: 28px; font-weight: 700; color: #10B981;">$${node.budget.toLocaleString()}</div>
                                </div>
                            ` : ''}
                            ${node.guestCount !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ğŸ‘¥ Guests</div>
                                    <div style="font-size: 28px; font-weight: 700; color: #3B82F6;">${node.guestCount}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Vendor + Location + Deadline -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            ${node.vendor ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ¢ Vendor</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.vendor}</div>
                                </div>
                            ` : ''}
                            ${node.location ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ“ Location</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.location}</div>
                                </div>
                            ` : ''}
                            ${node.responsiblePerson ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ‘¤ Owner</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.responsiblePerson}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Booking Deadline (Urgent Banner) -->
                        ${node.bookingDeadline ? `
                            <div style="padding: 16px; background: rgba(245, 158, 11, 0.15); border-left: 4px solid #F59E0B; border-radius: 8px; text-align: center;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 6px; text-transform: uppercase;">ğŸ“… Booking Deadline</div>
                                <div style="font-size: 18px; font-weight: 700; color: var(--text-primary);">${new Date(node.bookingDeadline).toLocaleDateString('en-US', {weekday: 'long', month: 'short', day: 'numeric', year: 'numeric'})}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FITNESS PROGRAM - Exercise card with sets/reps grid
            else if (currentPattern === 'fitness' && (node.sets || node.reps || node.duration || node.intensity)) {
                const intensityColors = { 'Light': '#10B981', 'Moderate': '#F59E0B', 'High': '#EF4444', 'Max': '#DC2626' };
                const intensityColor = intensityColors[node.intensity] || '#9CA3AF';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.08), rgba(220, 38, 38, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(239, 68, 68, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #EF4444; margin-bottom: 8px;">ğŸ’ª Exercise Specification</div>
                        </div>

                        <!-- Sets Ã— Reps (Large Display) -->
                        ${node.sets || node.reps ? `
                            <div style="text-align: center; padding: 24px; background: rgba(239, 68, 68, 0.15); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 48px; font-weight: 700; color: #EF4444; line-height: 1;">
                                    ${node.sets || '?'} <span style="font-size: 32px; color: var(--text-secondary);">Ã—</span> ${node.reps || '?'}
                                </div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-top: 8px;">Sets Ã— Reps</div>
                            </div>
                        ` : ''}

                        <!-- Duration + Intensity + Rest -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #3B82F6;">â±ï¸ ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.intensity ? `
                                <div style="padding: 12px; background: rgba(${parseInt(intensityColor.slice(1, 3), 16)}, ${parseInt(intensityColor.slice(3, 5), 16)}, ${parseInt(intensityColor.slice(5, 7), 16)}, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Intensity</div>
                                    <div style="font-size: 16px; font-weight: 600; color: ${intensityColor};">ğŸ”¥ ${node.intensity}</div>
                                </div>
                            ` : ''}
                            ${node.restPeriod ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Rest</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #10B981;">â¸ï¸ ${node.restPeriod}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Equipment -->
                        ${node.equipment ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ‹ï¸ Equipment</div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.equipment}</div>
                            </div>
                        ` : ''}

                        <!-- Form Cues -->
                        ${node.formCues ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase;">âœ… Form Cues</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.formCues}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // STRATEGY - Strategic initiative card with metrics
            else if (currentPattern === 'strategy' && (node.investment || node.keyMetric || node.strategicTheme)) {
                const themeColors = { 'Growth': '#10B981', 'Efficiency': '#3B82F6', 'Innovation': '#8B5CF6', 'Transformation': '#F59E0B', 'Risk Mitigation': '#EF4444' };
                const themeColor = themeColors[node.strategicTheme] || '#9CA3AF';
                const riskColors = { 'Low': '#10B981', 'Medium': '#F59E0B', 'High': '#EF4444' };

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(37, 99, 235, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">ğŸ“Š Strategic Initiative</div>
                        </div>

                        <!-- Investment (Large) -->
                        ${node.investment !== undefined ? `
                            <div style="text-align: center; padding: 24px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">Capital Investment</div>
                                <div style="font-size: 40px; font-weight: 700; color: #10B981; line-height: 1;">$${node.investment.toLocaleString()}</div>
                            </div>
                        ` : ''}

                        <!-- Strategic Theme + Risk Level -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
                            ${node.strategicTheme ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(themeColor.slice(1, 3), 16)}, ${parseInt(themeColor.slice(3, 5), 16)}, ${parseInt(themeColor.slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Theme</div>
                                    <div style="font-size: 18px; font-weight: 700; color: ${themeColor};">ğŸ­ ${node.strategicTheme}</div>
                                </div>
                            ` : ''}
                            ${node.riskLevel ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(riskColors[node.riskLevel].slice(1, 3), 16)}, ${parseInt(riskColors[node.riskLevel].slice(3, 5), 16)}, ${parseInt(riskColors[node.riskLevel].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Risk</div>
                                    <div style="font-size: 18px; font-weight: 700; color: ${riskColors[node.riskLevel]};">âš ï¸ ${node.riskLevel}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Key Metric â†’ Target Value -->
                        ${node.keyMetric || node.targetValue ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 12px; font-weight: 700; color: #3B82F6; margin-bottom: 12px; text-transform: uppercase;">ğŸ“ˆ Success Metrics</div>
                                ${node.keyMetric ? `
                                    <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 10px;">
                                        <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 4px; text-transform: uppercase;">ğŸ“Š Key Metric</div>
                                        <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.keyMetric}</div>
                                    </div>
                                ` : ''}
                                ${node.targetValue ? `
                                    <div style="text-align: center; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ¯ Target</div>
                                        <div style="font-size: 20px; font-weight: 700; color: #10B981;">${node.targetValue}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Executive Owner -->
                        ${node.responsibleExecutive ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ‘” Executive Sponsor</div>
                                <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.responsibleExecutive}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FAMILY TREE - Person card with genealogy info
            else if (currentPattern === 'familytree' && (node.fullName || node.birthDate || node.birthPlace)) {
                const isLiving = node.livingStatus === 'Living';
                const statusColor = isLiving ? '#10B981' : '#9CA3AF';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(124, 58, 237, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(139, 92, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #8B5CF6; margin-bottom: 8px;">ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Family Member</div>
                        </div>

                        <!-- Full Name + Living Status -->
                        ${node.fullName ? `
                            <div style="text-align: center; padding: 20px; background: rgba(139, 92, 246, 0.15); border-radius: 10px; margin-bottom: 20px;">
                                <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">${node.fullName}</div>
                                ${node.maidenName ? `<div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">(nÃ©e ${node.maidenName})</div>` : ''}
                                ${node.livingStatus ? `
                                    <div style="display: inline-block; padding: 6px 14px; background: rgba(${parseInt(statusColor.slice(1, 3), 16)}, ${parseInt(statusColor.slice(3, 5), 16)}, ${parseInt(statusColor.slice(5, 7), 16)}, 0.2); border-radius: 20px; font-size: 12px; font-weight: 600; color: ${statusColor};">
                                        ${isLiving ? 'ğŸ’š' : 'ğŸ•Šï¸'} ${node.livingStatus}
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Birth & Death Info -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            ${node.birthDate || node.birthPlace ? `
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase;">ğŸ‚ Birth</div>
                                    ${node.birthDate ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${new Date(node.birthDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                    ${node.birthPlace ? `<div style="font-size: 13px; color: var(--text-secondary);">ğŸ“ ${node.birthPlace}</div>` : ''}
                                </div>
                            ` : ''}
                            ${node.deathDate || node.deathPlace ? `
                                <div style="padding: 14px; background: rgba(156, 163, 175, 0.12); border-left: 4px solid #9CA3AF; border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: #9CA3AF; margin-bottom: 8px; text-transform: uppercase;">ğŸ•Šï¸ Death</div>
                                    ${node.deathDate ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${new Date(node.deathDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                    ${node.deathPlace ? `<div style="font-size: 13px; color: var(--text-secondary);">ğŸ“ ${node.deathPlace}</div>` : ''}
                                </div>
                            ` : ''}
                        </div>

                        <!-- Marriage & Family -->
                        ${node.spouseName || node.marriageDate ? `
                            <div style="padding: 14px; background: rgba(236, 72, 153, 0.12); border-left: 4px solid #EC4899; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #EC4899; margin-bottom: 8px; text-transform: uppercase;">ğŸ’‘ Marriage</div>
                                ${node.spouseName ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">Spouse: ${node.spouseName}</div>` : ''}
                                ${node.marriageDate ? `<div style="font-size: 13px; color: var(--text-secondary);">${new Date(node.marriageDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                ${node.marriagePlace ? `<div style="font-size: 13px; color: var(--text-secondary);">ğŸ“ ${node.marriagePlace}</div>` : ''}
                            </div>
                        ` : ''}

                        <!-- Occupation & Gender & Relationship -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 16px;">
                            ${node.gender ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Gender</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">âš§ ${node.gender}</div>
                                </div>
                            ` : ''}
                            ${node.occupation ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Occupation</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">ğŸ’¼ ${node.occupation}</div>
                                </div>
                            ` : ''}
                            ${node.relationshipType ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Relationship</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">ğŸ”— ${node.relationshipType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- DNA Info -->
                        ${node.dnaInfo ? `
                            <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 6px; text-transform: uppercase;">ğŸ§¬ DNA / Genetic Info</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.dnaInfo}</div>
                            </div>
                        ` : ''}

                        <!-- Sources -->
                        ${node.sources ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid #9ca3af; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ“„ Sources</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.sources}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILE SYSTEM - File preview/open button with thumbnail
            // BUILD 531: Show file details for ANY file with fileUrl/filePath, not just filesystem pattern
            else if (!node.isFolder && (node.fileUrl || node.filePath || node.fileExtension)) {
                // Format file size
                const formatFileSize = (bytes) => {
                    if (!bytes) return 'Unknown size';
                    if (bytes < 1024) return bytes + ' B';
                    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                    if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                    return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
                };

                // Get file icon based on extension
                const fileIcon = node.icon || getFileIcon(node.name, false);
                const fileSize = formatFileSize(node.fileSize);

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ğŸ’¾ File Details</div>
                        </div>

                        <!-- File Thumbnail/Icon & Open Button -->
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 16px; margin-bottom: 20px;">
                            <!-- Large Icon -->
                            <div style="font-size: 80px; line-height: 1;">${fileIcon}</div>

                            <!-- File Name -->
                            <div style="font-size: 18px; font-weight: 600; color: var(--text-primary); text-align: center; word-break: break-all;">
                                ${node.name}
                            </div>

                            <!-- Open File Button - BUILD 532: Properly handle local paths -->
                            ${(node.fileUrl || node.filePath) ? (() => {
                                // Determine the open URL
                                let openUrl = node.fileUrl;
                                let isLocalPath = false;
                                let isGoogleNative = false;

                                if (!openUrl && node.filePath) {
                                    isLocalPath = true;
                                    // Convert Windows path to file:// URL
                                    openUrl = 'file:///' + node.filePath.replace(/\\\\/g, '/').replace(/\\/g, '/');
                                }

                                // Check for Google native formats
                                const ext = (node.fileExtension || '').toLowerCase();
                                if (['.gsheet', '.gdoc', '.gslides', '.gform'].includes(ext)) {
                                    isGoogleNative = true;
                                }

                                // Escape quotes in URL for onclick
                                const escapedUrl = openUrl.replace(/'/g, "\\'");

                                return `
                                <button onclick="openFileFromInfoPanel('${escapedUrl}', ${isLocalPath}, ${isGoogleNative}, '${ext}')"
                                        style="padding: 14px 32px;
                                               background: linear-gradient(135deg, #6366f1, #8b5cf6);
                                               border: none;
                                               border-radius: 12px;
                                               color: white;
                                               font-size: 16px;
                                               font-weight: 700;
                                               cursor: pointer;
                                               transition: all 0.2s;
                                               box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);"
                                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(99, 102, 241, 0.4)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(99, 102, 241, 0.3)'">
                                    ${node.isFolder ? 'ğŸ“‚ Open Folder' : 'ğŸ”— Open File'}
                                </button>`;
                            })() : ''}
                        </div>

                        <!-- File Metadata Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.fileSize ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ“Š Size</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${fileSize}</div>
                                </div>
                            ` : ''}
                            ${node.fileExtension ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ·ï¸ Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.fileExtension}</div>
                                </div>
                            ` : ''}
                            ${node.dateModified ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ•’ Modified</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary);">${new Date(node.dateModified).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                            ${node.dateCreated ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ“… Created</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary);">${new Date(node.dateCreated).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- File Path -->
                        ${node.filePath ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid var(--treeplex-primary); border-radius: 8px; margin-bottom: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ“‚ Path</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); font-family: monospace; word-break: break-all;">${node.filePath}</div>
                            </div>
                        ` : ''}

                        <!-- Permissions & Owner -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.permissions ? `
                                <div style="flex: 1; min-width: 150px; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">ğŸ”’ Permissions</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #10B981;">${node.permissions}</div>
                                </div>
                            ` : ''}
                            ${node.fileOwner ? `
                                <div style="flex: 1; min-width: 150px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">ğŸ‘¤ Owner</div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${node.fileOwner}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Shared With -->
                        ${node.sharedWith ? `
                            <div style="padding: 14px; background: rgba(168, 85, 247, 0.15); border-left: 4px solid #a855f7; border-radius: 8px; margin-top: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: #a855f7; margin-bottom: 6px; text-transform: uppercase;">ğŸ‘¥ Shared With</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary);">${node.sharedWith}</div>
                            </div>
                        ` : ''}

                        <!-- Tags -->
                        ${node.tags ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-top: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ·ï¸ Tags</div>
                                <div style="font-size: 13px; color: var(--text-primary);">${node.tags}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILESYSTEM - Folder info card with Open button
            // BUILD 531: Show for FOLDERS only (files handled by patternInfoHtml above)
            let filesystemInfoHtml = '';
            if (node.type === 'item' && node.isFolder && (node.filePath || node.fileUrl)) {
                const formatFileSize = (bytes) => {
                    if (!bytes || bytes === 0) return 'N/A';
                    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
                    let size = bytes;
                    let unitIndex = 0;
                    while (size >= 1024 && unitIndex < units.length - 1) {
                        size /= 1024;
                        unitIndex++;
                    }
                    return `${size.toFixed(2)} ${units[unitIndex]}`;
                };

                const formatDate = (dateStr) => {
                    if (!dateStr) return 'N/A';
                    try {
                        return new Date(dateStr).toLocaleString('en-US', {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                    } catch (e) {
                        return dateStr;
                    }
                };

                // Determine if it's a folder or file
                const isFolder = node.isFolder === true;
                const entityType = isFolder ? 'Folder' : 'File';
                const entityIcon = isFolder ? 'ğŸ“' : node.icon || 'ğŸ“„';

                filesystemInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(99, 102, 241, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">${entityIcon} ${entityType} Details</div>
                        </div>

                        <!-- Open Button (Prominent) - BUILD 532: Use proper file opener -->
                        ${(node.fileUrl || node.filePath) ? (() => {
                            let openUrl = node.fileUrl;
                            let isLocalPath = false;
                            if (!openUrl && node.filePath) {
                                isLocalPath = true;
                                openUrl = 'file:///' + node.filePath.replace(/\\\\/g, '/').replace(/\\/g, '/');
                            }
                            const escapedUrl = openUrl.replace(/'/g, "\\'");
                            return `
                            <div style="text-align: center; margin-bottom: 20px;">
                                <button onclick="openFileFromInfoPanel('${escapedUrl}', ${isLocalPath}, false, '')" style="
                                    padding: 16px 32px;
                                    background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
                                    color: white;
                                    border: none;
                                    border-radius: 12px;
                                    font-size: 16px;
                                    font-weight: 700;
                                    cursor: pointer;
                                    display: inline-flex;
                                    align-items: center;
                                    gap: 10px;
                                    transition: all 0.3s;
                                    box-shadow: 0 4px 12px rgba(0, 166, 125, 0.3);
                                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0, 166, 125, 0.4)';" onmouseout="this.style.transform=''; this.style.boxShadow='0 4px 12px rgba(0, 166, 125, 0.3)';">
                                    <span style="font-size: 20px;">ğŸ“‚</span>
                                    <span>Open Folder</span>
                                </button>
                            </div>`;
                        })() : ''}

                        <!-- File/Folder Metadata Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 16px;">
                            ${!isFolder && node.fileSize !== undefined ? `
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ’¾ Size</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #10B981;">${formatFileSize(node.fileSize)}</div>
                                </div>
                            ` : ''}
                            ${node.fileExtension ? `
                                <div style="padding: 14px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ“‹ Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B; font-family: monospace;">${node.fileExtension}</div>
                                </div>
                            ` : ''}
                            ${node.mimeType ? `
                                <div style="padding: 14px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ”– MIME</div>
                                    <div style="font-size: 11px; font-weight: 600; color: #A78BFA; font-family: monospace; word-break: break-all;">${node.mimeType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Dates -->
                        ${node.dateModified || node.dateCreated ? `
                            <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                                ${node.dateModified ? `
                                    <div style="flex: 1; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ“… Modified</div>
                                        <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${formatDate(node.dateModified)}</div>
                                    </div>
                                ` : ''}
                                ${node.dateCreated ? `
                                    <div style="flex: 1; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ†• Created</div>
                                        <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${formatDate(node.dateCreated)}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Owner & Path -->
                        ${node.fileOwner ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ‘¤ Owner</div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.fileOwner}</div>
                            </div>
                        ` : ''}
                        ${node.filePath ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ğŸ“‚ Path</div>
                                <div style="font-size: 12px; color: var(--text-primary); font-family: monospace; word-break: break-all;">${node.filePath}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            body.innerHTML = `
                <!-- BUILD 422: Key Node Infographic (Root/Phase Dashboard) -->
                ${keyNodeInfoHtml}

                <!-- BUILD 559: Email Header Section (for email nodes) -->
                ${(node.senderEmail || node.recipientEmail || node.threadId) ? `
                <div style="margin-bottom: 24px; padding: 20px; background: linear-gradient(135deg, rgba(234, 67, 53, 0.08), rgba(251, 188, 5, 0.05)); border-radius: 16px; border: 1px solid rgba(234, 67, 53, 0.2);">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(234, 67, 53, 0.15);">
                        <span style="font-size: 20px;">ğŸ“¬</span>
                        <span style="font-size: 12px; font-weight: 700; color: #ea4335; text-transform: uppercase; letter-spacing: 1px;">Email Details</span>
                        ${node.messageCount > 1 ? `<span style="font-size: 11px; padding: 3px 8px; background: rgba(234, 67, 53, 0.15); border-radius: 10px; color: #ea4335; font-weight: 600;">${node.messageCount} messages</span>` : ''}
                    </div>
                    <div style="display: grid; gap: 12px;">
                        ${node.senderEmail ? `
                        <div style="display: flex; gap: 12px; align-items: flex-start;">
                            <span style="font-size: 11px; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; min-width: 50px; padding-top: 2px;">From</span>
                            <span style="font-size: 14px; color: var(--text-primary); font-weight: 500;">${node.senderEmail}</span>
                        </div>
                        ` : ''}
                        ${node.recipientEmail ? `
                        <div style="display: flex; gap: 12px; align-items: flex-start;">
                            <span style="font-size: 11px; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; min-width: 50px; padding-top: 2px;">To</span>
                            <span style="font-size: 14px; color: var(--text-primary);">${node.recipientEmail}</span>
                        </div>
                        ` : ''}
                        ${node.ccEmail ? `
                        <div style="display: flex; gap: 12px; align-items: flex-start;">
                            <span style="font-size: 11px; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; min-width: 50px; padding-top: 2px;">CC</span>
                            <span style="font-size: 13px; color: var(--text-secondary);">${node.ccEmail}</span>
                        </div>
                        ` : ''}
                        ${node.subjectLine ? `
                        <div style="display: flex; gap: 12px; align-items: flex-start;">
                            <span style="font-size: 11px; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; min-width: 50px; padding-top: 2px;">Subject</span>
                            <span style="font-size: 14px; color: var(--text-primary); font-weight: 600;">${node.subjectLine}</span>
                        </div>
                        ` : ''}
                        ${node.sendDate ? `
                        <div style="display: flex; gap: 12px; align-items: flex-start;">
                            <span style="font-size: 11px; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; min-width: 50px; padding-top: 2px;">Date</span>
                            <span style="font-size: 13px; color: var(--text-secondary);">${node.sendDateTime ? new Date(node.sendDateTime).toLocaleString() : node.sendDate}</span>
                        </div>
                        ` : ''}
                        ${node.labels && node.labels.length > 0 ? `
                        <div style="display: flex; gap: 12px; align-items: flex-start;">
                            <span style="font-size: 11px; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; min-width: 50px; padding-top: 2px;">Labels</span>
                            <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                                ${node.labels.filter(l => !['UNREAD', 'CATEGORY_PERSONAL', 'CATEGORY_UPDATES', 'CATEGORY_PROMOTIONS', 'CATEGORY_SOCIAL', 'CATEGORY_FORUMS'].includes(l)).map(l => `<span style="font-size: 11px; padding: 2px 8px; background: rgba(139, 92, 246, 0.15); border-radius: 4px; color: #8b5cf6;">${l}</span>`).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                </div>
                ` : ''}

                <!-- BUILD 515: Improved Description Section (BUILD 549: linkified URLs) -->
                <div style="margin-bottom: 24px; padding: 24px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.06), rgba(139, 92, 246, 0.03)); border-radius: 16px; border: 1px solid rgba(99, 102, 241, 0.15);">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(99, 102, 241, 0.1);">
                        <span style="font-size: 20px;">ğŸ“</span>
                        <span style="font-size: 12px; font-weight: 700; color: var(--treeplex-primary); text-transform: uppercase; letter-spacing: 1px;">Description</span>
                    </div>
                    <div style="font-size: 16px; line-height: 1.8; color: var(--text-primary); white-space: pre-wrap; font-weight: 400;">${linkifyText(node.description || node.subtitle) || '<span style="color: var(--text-secondary); font-style: italic;">No description yet. Double-click to edit.</span>'}</div>
                </div>

                <!-- BUILD 549: Email Actions (for email nodes) -->
                ${(node.emailBody || node.fullBody || node.threadId) ? `
                <div style="margin-bottom: 24px; padding: 16px 20px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(59, 130, 246, 0.05)); border-radius: 12px; border: 1px solid rgba(16, 185, 129, 0.2);">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <span style="font-size: 18px;">ğŸ“§</span>
                        <span style="font-size: 12px; font-weight: 700; color: #10b981; text-transform: uppercase; letter-spacing: 1px;">Email Actions</span>
                    </div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button onclick="emailReaderReplyFromNode(window.currentInfoPanelNode)" style="padding: 8px 16px; background: rgba(16, 185, 129, 0.15); border: 1px solid #10b981; border-radius: 8px; color: #10b981; cursor: pointer; font-size: 13px; font-weight: 500;">
                            â†©ï¸ Reply
                        </button>
                        <button onclick="emailReaderForwardFromNode(window.currentInfoPanelNode)" style="padding: 8px 16px; background: rgba(59, 130, 246, 0.15); border: 1px solid #3b82f6; border-radius: 8px; color: #3b82f6; cursor: pointer; font-size: 13px; font-weight: 500;">
                            â¡ï¸ Forward
                        </button>
                        <button onclick="openEmailReaderModal(window.currentInfoPanelNode)" style="padding: 8px 16px; background: rgba(139, 92, 246, 0.15); border: 1px solid #8b5cf6; border-radius: 8px; color: #8b5cf6; cursor: pointer; font-size: 13px; font-weight: 500;">
                            ğŸ“– Read Full
                        </button>
                        ${node.threadId ? `
                        <button onclick="window.open('https://mail.google.com/mail/u/0/#inbox/${node.threadId}', '_blank')" style="padding: 8px 16px; background: rgba(234, 67, 53, 0.15); border: 1px solid #ea4335; border-radius: 8px; color: #ea4335; cursor: pointer; font-size: 13px; font-weight: 500;">
                            ğŸ”— Open in Gmail
                        </button>
                        ` : ''}
                    </div>
                </div>
                ` : ''}

                <!-- BUILD 550: Gmail Sync Actions (requires MCP Bridge) -->
                ${node.threadId ? `
                <div style="margin-bottom: 24px; padding: 16px 20px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(79, 70, 229, 0.05)); border-radius: 12px; border: 1px solid rgba(139, 92, 246, 0.2);">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <span style="font-size: 18px;">ğŸ”„</span>
                        <span style="font-size: 12px; font-weight: 700; color: #8b5cf6; text-transform: uppercase; letter-spacing: 1px;">Gmail Sync</span>
                        <span id="gmail-sync-status-${node.id}" style="font-size: 10px; padding: 2px 6px; border-radius: 4px; background: rgba(100,100,100,0.3); color: var(--text-secondary);">checking...</span>
                    </div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button onclick="gmailSyncArchive('${node.threadId}', '${node.id}', this)" style="padding: 8px 16px; background: rgba(59, 130, 246, 0.15); border: 1px solid #3b82f6; border-radius: 8px; color: #3b82f6; cursor: pointer; font-size: 13px; font-weight: 500;" title="Remove from Gmail inbox">
                            ğŸ“¥ Archive
                        </button>
                        <button onclick="gmailSyncTrash('${node.threadId}', '${node.id}', this)" style="padding: 8px 16px; background: rgba(239, 68, 68, 0.15); border: 1px solid #ef4444; border-radius: 8px; color: #ef4444; cursor: pointer; font-size: 13px; font-weight: 500;" title="Move to Gmail trash (30-day recovery)">
                            ğŸ—‘ï¸ Trash
                        </button>
                        <button onclick="gmailSyncStar('${node.threadId}', '${node.id}', this)" style="padding: 8px 16px; background: rgba(245, 158, 11, 0.15); border: 1px solid #f59e0b; border-radius: 8px; color: #f59e0b; cursor: pointer; font-size: 13px; font-weight: 500;" title="Star in Gmail">
                            â­ Star
                        </button>
                        <button onclick="gmailSyncMarkRead('${node.threadId}', '${node.id}', this)" style="padding: 8px 16px; background: rgba(16, 185, 129, 0.15); border: 1px solid #10b981; border-radius: 8px; color: #10b981; cursor: pointer; font-size: 13px; font-weight: 500;" title="Mark as read in Gmail">
                            âœ“ Mark Read
                        </button>
                    </div>
                    <div style="margin-top: 10px; font-size: 11px; color: var(--text-secondary);">
                        ğŸ’¡ Requires MCP Bridge running. Changes sync to Gmail with 10s undo window.
                    </div>

                    <!-- BUILD 551: Quick Reply Box -->
                    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(139, 92, 246, 0.2);">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <span style="font-size: 14px;">âœï¸</span>
                            <span style="font-size: 12px; font-weight: 600; color: var(--text-primary);">Quick Reply</span>
                            <span id="draft-status-${node.id}" style="font-size: 10px; padding: 2px 6px; border-radius: 4px; background: rgba(100,100,100,0.3); color: var(--text-secondary);">local</span>
                        </div>
                        <textarea id="quick-reply-${node.id}" placeholder="Type your reply..." style="width: 100%; min-height: 80px; padding: 12px; background: rgba(0,0,0,0.3); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 14px; line-height: 1.5; resize: vertical; font-family: inherit;" oninput="draftAutoSave('${node.id}', '${node.threadId}', this.value)"></textarea>
                        <div style="display: flex; gap: 8px; margin-top: 10px; justify-content: flex-end;">
                            <button onclick="openComposeModal('${node.id}', '${node.threadId}')" style="padding: 8px 14px; background: transparent; border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 6px; color: var(--text-secondary); cursor: pointer; font-size: 12px;">
                                Expand
                            </button>
                            <button onclick="saveDraftToGmail('${node.id}', '${node.threadId}', this)" style="padding: 8px 14px; background: rgba(139, 92, 246, 0.2); border: 1px solid #8b5cf6; border-radius: 6px; color: #8b5cf6; cursor: pointer; font-size: 12px; font-weight: 500;">
                                Save to Gmail
                            </button>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- BUILD 559: Email Thread Conversation View -->
                ${(node.subItems && node.subItems.length > 0) ? `
                <div style="margin-bottom: 24px; padding: 20px; background: linear-gradient(135deg, rgba(59, 130, 246, 0.06), rgba(99, 102, 241, 0.03)); border-radius: 16px; border: 1px solid rgba(59, 130, 246, 0.15);">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(59, 130, 246, 0.1);">
                        <span style="font-size: 20px;">ğŸ’¬</span>
                        <span style="font-size: 12px; font-weight: 700; color: #3b82f6; text-transform: uppercase; letter-spacing: 1px;">Conversation Thread</span>
                        <span style="font-size: 11px; padding: 3px 8px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; color: #3b82f6; font-weight: 600;">${node.subItems.length} message${node.subItems.length > 1 ? 's' : ''}</span>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 16px; max-height: 400px; overflow-y: auto; padding-right: 8px;">
                        ${node.subItems.map((msg, idx) => `
                        <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px; border-left: 3px solid ${msg.sender && msg.sender.includes(node.recipientEmail?.split('@')[0] || 'you') ? '#10b981' : '#3b82f6'};">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                                <div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${msg.sender || 'Unknown'}</div>
                                    ${msg.recipient ? `<div style="font-size: 11px; color: var(--text-secondary);">To: ${msg.recipient}</div>` : ''}
                                </div>
                                <div style="font-size: 11px; color: var(--text-secondary);">${msg.sendDateTime ? new Date(msg.sendDateTime).toLocaleString() : msg.sendDate || ''}</div>
                            </div>
                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; overflow: hidden; ${msg.fullBody && msg.fullBody.length > 500 ? 'max-height: 150px;' : ''}">${(msg.fullBody || msg.description || '(No content)').substring(0, 800)}${(msg.fullBody || '').length > 800 ? '...' : ''}</div>
                            ${(msg.fullBody || '').length > 500 ? `
                            <button onclick="this.previousElementSibling.style.maxHeight = this.previousElementSibling.style.maxHeight ? '' : '150px'; this.textContent = this.previousElementSibling.style.maxHeight ? 'Show more' : 'Show less';" style="margin-top: 8px; padding: 4px 10px; background: transparent; border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 4px; color: #3b82f6; cursor: pointer; font-size: 11px;">Show more</button>
                            ` : ''}
                        </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}

                <!-- BUILD 549: Attachments (for email nodes with attachments) -->
                ${(node.attachments && node.attachments.length > 0) ? `
                <div style="margin-bottom: 24px; padding: 16px 20px; background: linear-gradient(135deg, rgba(251, 146, 60, 0.08), rgba(234, 88, 12, 0.05)); border-radius: 12px; border: 1px solid rgba(251, 146, 60, 0.2);">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <span style="font-size: 18px;">ğŸ“</span>
                        <span style="font-size: 12px; font-weight: 700; color: #fb923c; text-transform: uppercase; letter-spacing: 1px;">Attachments (${node.attachments.length})</span>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        ${node.attachments.map(att => `
                            <div style="display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                                <span style="font-size: 16px;">${att.mimeType?.startsWith('image/') ? 'ğŸ–¼ï¸' : att.mimeType?.includes('pdf') ? 'ğŸ“„' : att.mimeType?.includes('spreadsheet') || att.mimeType?.includes('excel') ? 'ğŸ“Š' : 'ğŸ“'}</span>
                                <div style="flex: 1; min-width: 0;">
                                    <div style="font-size: 13px; font-weight: 500; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${att.filename}</div>
                                    <div style="font-size: 11px; color: var(--text-secondary);">${att.size ? (att.size > 1024*1024 ? (att.size/1024/1024).toFixed(1) + ' MB' : (att.size/1024).toFixed(0) + ' KB') : 'Unknown size'}</div>
                                </div>
                                ${att.attachmentId ? `<span style="font-size: 11px; color: var(--text-secondary); opacity: 0.5;">ID: ${att.attachmentId.substring(0, 8)}...</span>` : ''}
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin-top: 12px; font-size: 11px; color: var(--text-secondary); font-style: italic;">
                        ğŸ’¡ Tip: Click "Open in Gmail" above to download attachments
                    </div>
                </div>
                ` : ''}

                <!-- BUILD 515: Compact Metadata Footer -->
                <div style="display: flex; gap: 8px; margin-bottom: 20px; padding: 12px 16px; background: rgba(0,0,0,0.2); border-radius: 10px; align-items: center; flex-wrap: wrap;">
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 10px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase;">Type:</span>
                        <span style="font-size: 12px; font-weight: 500; color: var(--text-primary); background: rgba(255,255,255,0.05); padding: 4px 8px; border-radius: 4px;">${node.itemType || node.type || 'N/A'}</span>
                    </div>
                    <span style="color: var(--border);">â€¢</span>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 10px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase;">ID:</span>
                        <span style="font-size: 10px; font-family: monospace; color: var(--text-secondary);">${(node.id || 'N/A').substring(0, 20)}${(node.id || '').length > 20 ? '...' : ''}</span>
                    </div>
                    ${PATTERNS[currentPattern]?.fields?.cost && node.cost > 0 ? `
                    <span style="color: var(--border);">â€¢</span>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 10px; font-weight: 600; color: #10B981; text-transform: uppercase;">Cost:</span>
                        <span style="font-size: 13px; font-weight: 700; color: #10B981;">${formatCost(node.cost)}</span>
                    </div>
                    ` : ''}
                </div>

                ${node.type === 'root' && PATTERNS[currentPattern]?.fields?.cost && calculateTotal(node) > 0 ? `
                <div style="padding: 16px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.08)); border-radius: 10px; border: 2px solid rgba(16, 185, 129, 0.4); margin-bottom: 20px; text-align: center;">
                    <div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 6px;">Total Project Cost</div>
                    <div style="font-size: 28px; font-weight: 700; color: #10B981;">${formatCost(calculateTotal(node))}</div>
                </div>
                ` : ''}

                ${pmDashboardHtml}
                ${patternInfoHtml}
                ${filesystemInfoHtml}
                ${node.alternateSource ? `
                    <div class="info-section">
                        <h4>Alternate Source</h4>
                        <p style="font-size: 14px; line-height: 1.6;">ğŸ“¦ ${node.alternateSource}</p>
                    </div>
                ` : ''}
                ${node.leadTime ? `
                    <div class="info-section">
                        <h4>Lead Time</h4>
                        <p style="font-size: 14px; line-height: 1.6;">â±ï¸ ${node.leadTime}</p>
                    </div>
                ` : ''}
                ${node.notes ? `
                    <div class="info-section">
                        <h4>Context Notes</h4>
                        <p style="background: var(--bg); padding: 12px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary); font-size: 13px; line-height: 1.6; white-space: pre-wrap;">${node.notes}</p>
                    </div>
                ` : ''}
                ${depsHtml}
                ${dependentsHtml}
                ${node.type === 'phase' && PATTERNS[currentPattern].fields?.cost && calculatePhaseTotal(node) > 0 ? `
                    <div class="info-section">
                        <h4>Phase Total</h4>
                        <p class="value">${formatCost(calculatePhaseTotal(node))}</p>
                    </div>
                ` : ''}
                ${node.type === 'root' && PATTERNS[currentPattern].fields?.cost && calculateTotal(node) > 0 ? `
                    <div class="info-section">
                        <h4>Total Cost</h4>
                        <p class="value">${formatCost(calculateTotal(node))}</p>
                    </div>
                ` : ''}
                ${node.type === 'root' && node.hyperedges && node.hyperedges.length > 0 ? `
                    <div class="info-section">
                        <h4>Hyperedges (Groups)</h4>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            ${node.hyperedges.map(h => `
                                <div style="display: flex; align-items: center; justify-content: space-between; background: rgba(255,255,255,0.05); padding: 10px 12px; border-radius: 8px; border-left: 3px solid ${h.type === 'montage' ? '#fb923c' : h.type === 'argument' ? '#3b82f6' : h.type === 'theme' ? '#a855f7' : h.type === 'dependency-cluster' ? '#22c55e' : '#9ca3af'};">
                                    <div style="flex: 1;">
                                        <span style="font-size: 14px; font-weight: 500;">${h.label || 'Unnamed Group'}</span>
                                        <span style="opacity: 0.5; font-size: 12px; margin-left: 8px;">(${h.type || 'group'})</span>
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">${h.nodeIds?.length || 0} nodes</div>
                                    </div>
                                    <button onclick="window.deleteHyperedge('${h.id}')" style="background: rgba(239, 68, 68, 0.2); border: none; cursor: pointer; font-size: 14px; padding: 6px 10px; border-radius: 6px; color: #ef4444;" title="Delete hyperedge">ğŸ—‘ï¸</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            `;

            panel.classList.add('open');
            currentOpenItemId = node.id;
            window.currentInfoPanelNode = node; // BUILD 549: Store for email actions

            // BUILD 489: Highlight selected node in tree view
            document.querySelectorAll('.tree-node.selected').forEach(n => n.classList.remove('selected'));
            const selectedNode = document.querySelector(`.tree-node[data-node-id="${node.id}"]`);
            if (selectedNode) {
                selectedNode.classList.add('selected');
            }

            // Reposition hyperedge panel if it's open
            repositionHyperedgePanel(true);

            // Build 411: Update reader navigation bar
            updateReaderNav();

            // BUILD 553: Update Gmail sync status indicator
            const gmailStatusEl = document.getElementById(`gmail-sync-status-${node.id}`);
            if (gmailStatusEl) {
                if (typeof isMCPBridgeConnected === 'function' && isMCPBridgeConnected()) {
                    gmailStatusEl.textContent = 'connected';
                    gmailStatusEl.style.background = 'rgba(16, 185, 129, 0.2)';
                    gmailStatusEl.style.color = '#10b981';
                } else {
                    gmailStatusEl.textContent = 'not connected';
                    gmailStatusEl.style.background = 'rgba(239, 68, 68, 0.2)';
                    gmailStatusEl.style.color = '#ef4444';
                }
            }
        }

        // Track which item's panel is currently open
        let currentOpenItemId = null;

        // ========================================================================
        // BUILD 411: READER NAVIGATION
        // Sequential prev/next navigation through all nodes
        // ========================================================================

        // Reader navigation state
        const readerNavState = {
            linearList: [],      // Flattened list of all nodes
            currentIndex: -1,    // Current position in the list
            readModeActive: false, // Read mode toggle state
            groupMode: 'all',    // BUILD 508: 'all', 'hyperedge', 'dependencies'
            currentHyperedgeId: null, // Active hyperedge for filtering
            currentDependencyChain: [] // Dependency chain node IDs
        };

        // Load read mode preference from localStorage
        readerNavState.readModeActive = localStorage.getItem('treelistyReadMode') === 'true';

        /**
         * Flatten tree into linear node list (depth-first traversal)
         * BUILD 508: Supports group filtering (all, hyperedge, dependencies)
         * @param {string} groupMode - 'all', 'hyperedge', or 'dependencies'
         * @param {string} currentNodeId - Current node ID for context
         * @returns {Array} Array of node objects
         */
        function getLinearNodeList(groupMode = 'all', currentNodeId = null) {
            const list = [];

            function traverse(node, depth = 0) {
                // Add this node to the list
                list.push({ node, depth });

                // Traverse children (for root nodes or any node with children array)
                if (node.children && Array.isArray(node.children)) {
                    node.children.forEach(child => traverse(child, depth + 1));
                }

                // Traverse items (for phases)
                if (node.items && Array.isArray(node.items)) {
                    node.items.forEach(item => traverse(item, depth + 1));
                }

                // Traverse subtasks (legacy naming)
                if (node.subtasks && Array.isArray(node.subtasks)) {
                    node.subtasks.forEach(subtask => traverse(subtask, depth + 1));
                }

                // BUILD 507: Traverse subItems (used by voice capture and some patterns)
                if (node.subItems && Array.isArray(node.subItems)) {
                    node.subItems.forEach(subItem => traverse(subItem, depth + 1));
                }
            }

            // Start from root
            if (capexTree) {
                traverse(capexTree, 0);
            }

            // BUILD 508: Filter by group mode
            if (groupMode === 'hyperedge' && currentNodeId) {
                // Find hyperedge containing current node
                const hyperedge = (capexTree.hyperedges || []).find(he =>
                    he.nodeIds && he.nodeIds.includes(currentNodeId)
                );
                if (hyperedge) {
                    readerNavState.currentHyperedgeId = hyperedge.id;
                    const nodeIds = new Set(hyperedge.nodeIds);
                    return list.filter(entry => nodeIds.has(entry.node.id));
                }
                // No hyperedge found, fall back to all
                readerNavState.currentHyperedgeId = null;
            } else if (groupMode === 'dependencies' && currentNodeId) {
                // Build dependency chain (predecessors and successors)
                const chainIds = new Set([currentNodeId]);

                // Find all nodes and their dependencies
                function findDependencyChain(nodeId, visited = new Set()) {
                    if (visited.has(nodeId)) return;
                    visited.add(nodeId);
                    chainIds.add(nodeId);

                    // Find the node
                    const nodeEntry = list.find(e => e.node.id === nodeId);
                    if (!nodeEntry) return;

                    // Add predecessors (dependencies)
                    const deps = nodeEntry.node.dependencies || [];
                    deps.forEach(dep => {
                        const depId = typeof dep === 'string' ? dep : dep.predecessorId;
                        if (depId) findDependencyChain(depId, visited);
                    });

                    // Add successors (nodes that depend on this)
                    list.forEach(e => {
                        const nodeDeps = e.node.dependencies || [];
                        nodeDeps.forEach(dep => {
                            const depId = typeof dep === 'string' ? dep : dep.predecessorId;
                            if (depId === nodeId) findDependencyChain(e.node.id, visited);
                        });
                    });
                }

                findDependencyChain(currentNodeId);
                readerNavState.currentDependencyChain = Array.from(chainIds);

                if (chainIds.size > 1) {
                    return list.filter(entry => chainIds.has(entry.node.id));
                }
                // No dependencies found, fall back to all
            }

            return list;
        }

        /**
         * Update the reader nav bar in info panel
         * BUILD 508: Supports group modes (all, hyperedge, dependencies)
         */
        function updateReaderNav() {
            const readerNav = document.getElementById('reader-nav');
            const prevBtn = document.getElementById('reader-prev');
            const nextBtn = document.getElementById('reader-next');
            const positionText = document.getElementById('reader-position');
            const readModeBtn = document.getElementById('reader-mode-toggle');
            const groupSelect = document.getElementById('reader-group-select');
            const infoPanel = document.getElementById('info-panel');

            if (!readerNav || !currentOpenItemId) {
                if (readerNav) readerNav.style.display = 'none';
                return;
            }

            // BUILD 508: Rebuild linear list with group filtering
            readerNavState.linearList = getLinearNodeList(
                readerNavState.groupMode,
                currentOpenItemId
            );

            // Find current index
            readerNavState.currentIndex = readerNavState.linearList.findIndex(
                entry => entry.node.id === currentOpenItemId
            );

            const total = readerNavState.linearList.length;

            // BUILD 509: Handle edge case where node not found in list
            // This can happen with filtered groups or tree structure changes
            if (readerNavState.currentIndex === -1 && total > 0) {
                // Node not in current list - reset to first item
                readerNavState.currentIndex = 0;
                console.log('ğŸ“– Reader: Node not in current list, reset to first item');
            }

            const current = readerNavState.currentIndex + 1;

            // Show nav bar (even if only 1 node in filtered group)
            readerNav.style.display = 'flex';

            // BUILD 508: Update position text with group context
            let posLabel = `${current} of ${total}`;
            if (readerNavState.groupMode === 'hyperedge' && readerNavState.currentHyperedgeId) {
                posLabel = `${current}/${total} in hyperedge`;
            } else if (readerNavState.groupMode === 'dependencies' && readerNavState.currentDependencyChain.length > 1) {
                posLabel = `${current}/${total} in chain`;
            }
            positionText.textContent = posLabel;

            // Update group selector
            if (groupSelect) {
                groupSelect.value = readerNavState.groupMode;
                // Disable options if not applicable
                const hyperedgeOpt = groupSelect.querySelector('option[value="hyperedge"]');
                const depsOpt = groupSelect.querySelector('option[value="dependencies"]');
                if (hyperedgeOpt) {
                    const hasHyperedge = (capexTree.hyperedges || []).some(he =>
                        he.nodeIds && he.nodeIds.includes(currentOpenItemId)
                    );
                    hyperedgeOpt.disabled = !hasHyperedge;
                    hyperedgeOpt.textContent = hasHyperedge ? 'ğŸ”— Hyperedge' : 'ğŸ”— (no hyperedge)';
                }
                if (depsOpt) {
                    const allNodes = getLinearNodeList('all');
                    const currentNode = allNodes.find(e => e.node.id === currentOpenItemId)?.node;
                    const hasDeps = currentNode?.dependencies?.length > 0 ||
                        allNodes.some(e => (e.node.dependencies || []).some(d =>
                            (typeof d === 'string' ? d : d.predecessorId) === currentOpenItemId
                        ));
                    depsOpt.disabled = !hasDeps;
                    depsOpt.textContent = hasDeps ? 'â›“ï¸ Dependencies' : 'â›“ï¸ (no deps)';
                }
            }

            // Update button states
            // BUILD 509: Ensure buttons work even with edge cases
            if (total === 0) {
                // Empty list - disable both buttons
                prevBtn.disabled = true;
                nextBtn.disabled = true;
            } else {
                prevBtn.disabled = readerNavState.currentIndex <= 0;
                nextBtn.disabled = readerNavState.currentIndex >= total - 1;
            }

            // Update read mode button state
            if (readModeBtn) {
                readModeBtn.classList.toggle('active', readerNavState.readModeActive);
            }

            // Apply read mode class to info panel
            if (infoPanel) {
                infoPanel.classList.toggle('read-mode', readerNavState.readModeActive);
            }

            // Highlight current node in tree view
            highlightCurrentNodeInTree();
        }

        /**
         * Navigate to a specific node by index
         * @param {number} index - Index in the linear list
         */
        function navigateToNode(index) {
            if (index < 0 || index >= readerNavState.linearList.length) return;

            const entry = readerNavState.linearList[index];
            if (!entry || !entry.node) return;

            // Show the node in the info panel
            showInfo(entry.node);

            // Scroll the tree view to the node
            scrollToNodeInTree(entry.node.id);
        }

        /**
         * Navigate to previous node
         */
        function navigatePrev() {
            if (readerNavState.currentIndex > 0) {
                navigateToNode(readerNavState.currentIndex - 1);
            }
        }

        /**
         * Navigate to next node
         */
        function navigateNext() {
            if (readerNavState.currentIndex < readerNavState.linearList.length - 1) {
                navigateToNode(readerNavState.currentIndex + 1);
            }
        }

        /**
         * Toggle read mode on/off
         */
        function toggleReadMode() {
            readerNavState.readModeActive = !readerNavState.readModeActive;
            localStorage.setItem('treelistyReadMode', readerNavState.readModeActive);
            updateReaderNav();
        }

        /**
         * Highlight the current node in tree view with visual indicator
         */
        function highlightCurrentNodeInTree() {
            // Remove existing highlight
            document.querySelectorAll('.tree-node.reader-current').forEach(el => {
                el.classList.remove('reader-current');
            });

            if (readerNavState.currentIndex < 0) return;

            const entry = readerNavState.linearList[readerNavState.currentIndex];
            if (!entry || !entry.node) return;

            // Find the node element in tree view
            const nodeEl = document.querySelector(`[data-node-id="${entry.node.id}"]`);
            if (nodeEl) {
                nodeEl.classList.add('reader-current');
            }
        }

        /**
         * Scroll tree view to show a specific node
         * @param {string} nodeId - ID of the node to scroll to
         */
        function scrollToNodeInTree(nodeId) {
            const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (nodeEl) {
                nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Reader navigation button event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const prevBtn = document.getElementById('reader-prev');
            const nextBtn = document.getElementById('reader-next');
            const readModeBtn = document.getElementById('reader-mode-toggle');
            const groupSelect = document.getElementById('reader-group-select');

            if (prevBtn) {
                prevBtn.addEventListener('click', navigatePrev);
            }
            if (nextBtn) {
                nextBtn.addEventListener('click', navigateNext);
            }
            if (readModeBtn) {
                readModeBtn.addEventListener('click', toggleReadMode);
            }
            // BUILD 508: Group selector change handler
            if (groupSelect) {
                groupSelect.addEventListener('change', (e) => {
                    readerNavState.groupMode = e.target.value;
                    updateReaderNav();
                });
            }

            // BUILD 512: TTS button event listeners
            const speakBtn = document.getElementById('reader-speak');
            const playBtn = document.getElementById('reader-play');
            if (speakBtn) {
                speakBtn.addEventListener('click', handleSpeakClick);
            }
            if (playBtn) {
                playBtn.addEventListener('click', toggleAutoPlay);
            }
        });

        // Keyboard navigation (arrow keys when info panel is open)
        document.addEventListener('keydown', (e) => {
            const infoPanel = document.getElementById('info-panel');
            if (!infoPanel || !infoPanel.classList.contains('open')) return;

            // Don't trigger if user is typing in an input/textarea
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable)) {
                return;
            }

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                navigatePrev();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                navigateNext();
            }
        });

        // ========================================================================
        // END BUILD 411: READER NAVIGATION
        // ========================================================================

        // ========================================================================
        // BUILD 512: TEXT-TO-SPEECH (Read Aloud / Auto-Play)
        // ========================================================================

        const ttsState = {
            isPlaying: false,      // Auto-play mode active
            isSpeaking: false,     // Currently speaking
            utterance: null,       // Current speech utterance
            autoPlayNavigating: false  // Flag to prevent interrupt during auto-play nav
        };

        /**
         * Speak the current node's description
         */
        function speakCurrentNode() {
            if (!('speechSynthesis' in window)) {
                showToast('Text-to-speech not supported in this browser', 'error');
                return;
            }

            // Stop any current speech
            window.speechSynthesis.cancel();

            // Get current node
            if (readerNavState.currentIndex < 0 || !readerNavState.linearList[readerNavState.currentIndex]) {
                showToast('No node selected', 'warning');
                return;
            }

            const entry = readerNavState.linearList[readerNavState.currentIndex];
            const node = entry.node;

            // Build text to speak: name + description
            let textToSpeak = node.name || 'Untitled';
            if (node.description) {
                textToSpeak += '. ' + node.description;
            }

            // Create utterance
            ttsState.utterance = new SpeechSynthesisUtterance(textToSpeak);
            ttsState.utterance.rate = 1.0;
            ttsState.utterance.pitch = 1.0;

            ttsState.utterance.onstart = () => {
                ttsState.isSpeaking = true;
                updateTTSButtons();
            };

            ttsState.utterance.onend = () => {
                ttsState.isSpeaking = false;
                updateTTSButtons();

                // If auto-play mode, advance to next
                if (ttsState.isPlaying) {
                    if (readerNavState.currentIndex < readerNavState.linearList.length - 1) {
                        setTimeout(() => {
                            // Set flag to prevent interrupt wrapper from stopping us
                            ttsState.autoPlayNavigating = true;
                            navigateNext();
                            ttsState.autoPlayNavigating = false;
                            setTimeout(() => speakCurrentNode(), 300);
                        }, 500);
                    } else {
                        // Reached end
                        stopAutoPlay();
                        showToast('Finished reading all nodes', 'success');
                    }
                }
            };

            ttsState.utterance.onerror = (e) => {
                console.error('TTS error:', e);
                ttsState.isSpeaking = false;
                if (ttsState.isPlaying) {
                    stopAutoPlay();
                }
                updateTTSButtons();
            };

            window.speechSynthesis.speak(ttsState.utterance);
        }

        /**
         * Toggle auto-play mode (read through all nodes)
         */
        function toggleAutoPlay() {
            if (ttsState.isPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }

        /**
         * Start auto-play mode
         */
        function startAutoPlay() {
            if (!('speechSynthesis' in window)) {
                showToast('Text-to-speech not supported', 'error');
                return;
            }

            ttsState.isPlaying = true;
            updateTTSButtons();
            showToast('Auto-play started. Click stop or navigate to interrupt.', 'info');
            speakCurrentNode();
        }

        /**
         * Stop auto-play mode
         */
        function stopAutoPlay() {
            ttsState.isPlaying = false;
            window.speechSynthesis.cancel();
            ttsState.isSpeaking = false;
            updateTTSButtons();
        }

        /**
         * Update TTS button appearances
         */
        function updateTTSButtons() {
            const speakBtn = document.getElementById('reader-speak');
            const playBtn = document.getElementById('reader-play');

            if (speakBtn) {
                if (ttsState.isSpeaking && !ttsState.isPlaying) {
                    speakBtn.textContent = 'â¹ï¸';
                    speakBtn.style.background = 'rgba(239, 68, 68, 0.3)';
                    speakBtn.title = 'Stop speaking';
                } else {
                    speakBtn.textContent = 'ğŸ”Š';
                    speakBtn.style.background = 'rgba(16, 185, 129, 0.2)';
                    speakBtn.title = 'Read description aloud';
                }
            }

            if (playBtn) {
                if (ttsState.isPlaying) {
                    playBtn.textContent = 'â¹ï¸';
                    playBtn.style.background = 'rgba(239, 68, 68, 0.3)';
                    playBtn.title = 'Stop auto-play';
                } else {
                    playBtn.textContent = 'â–¶ï¸';
                    playBtn.style.background = 'rgba(99, 102, 241, 0.2)';
                    playBtn.title = 'Auto-play through all nodes';
                }
            }
        }

        /**
         * Handle speak button click
         */
        function handleSpeakClick() {
            if (ttsState.isSpeaking && !ttsState.isPlaying) {
                // Stop current speech
                window.speechSynthesis.cancel();
                ttsState.isSpeaking = false;
                updateTTSButtons();
            } else {
                speakCurrentNode();
            }
        }

        // Stop TTS when user manually navigates (interruption)
        const originalNavigateToNode = navigateToNode;
        navigateToNode = function(index) {
            // Skip interrupt if auto-play is doing the navigation
            if (!ttsState.autoPlayNavigating && (ttsState.isPlaying || ttsState.isSpeaking)) {
                // User navigated manually - stop auto-play but continue to node
                window.speechSynthesis.cancel();
                ttsState.isSpeaking = false;
                if (ttsState.isPlaying) {
                    ttsState.isPlaying = false;
                    showToast('Auto-play stopped', 'info');
                }
                updateTTSButtons();
            }
            originalNavigateToNode(index);
        };

        // ========================================================================
        // END BUILD 512: TEXT-TO-SPEECH
        // ========================================================================

        /**
         * Reposition the hyperedge visibility panel based on info panel state
         * @param {boolean} infoPanelOpen - Whether info panel is open
         */
        function repositionHyperedgePanel(infoPanelOpen) {
            const hyperedgePanel = document.getElementById('hyperedge-visibility-panel');
            if (hyperedgePanel) {
                const rightOffset = infoPanelOpen ? 470 : 20;
                hyperedgePanel.style.right = `${rightOffset}px`;
            }
        }

        document.getElementById('close-info').addEventListener('click', () => {
            document.getElementById('info-panel').classList.remove('open');
            currentOpenItemId = null;

            // BUILD 512: Stop TTS when closing info panel
            if (ttsState.isPlaying || ttsState.isSpeaking) {
                stopAutoPlay();
            }

            // BUILD 489: Clear tree node selection
            document.querySelectorAll('.tree-node.selected').forEach(n => n.classList.remove('selected'));

            // Reposition hyperedge panel back to right edge
            repositionHyperedgePanel(false);

            // Build 411: Clear reader navigation highlight
            document.querySelectorAll('.tree-node.reader-current').forEach(el => {
                el.classList.remove('reader-current');
            });
        });

        // Context Menu
        function showContextMenu(x, y) {
            const menu = document.getElementById('context-menu');
            const labels = getPatternLabels();

            // Build menu dynamically based on node type
            let menuHtml = '';

            if (activeNode.type === 'item') {
                // Item context menu
                // BUILD 547: Add email reader option for email nodes
                const hasEmailData = activeNode.emailBody || activeNode.fullBody || activeNode.subItems?.some(s => s.fullBody);
                const emailOption = hasEmailData ? `<div class="context-item" id="ctx-open-email">ğŸ“§ Open Email</div>` : '';
                menuHtml = `
                    <div class="context-item" id="ctx-view">ğŸ“‹ View Details</div>
                    ${emailOption}
                    <div class="context-item" id="ctx-edit">âœï¸ Edit ${labels.item}</div>
                    <div class="context-item" id="ctx-add-subtask">â• Add ${labels.subtask}</div>
                    <div class="context-item" id="ctx-attach">ğŸ“ Attachments</div>
                    <div class="context-item" id="ctx-delete">ğŸ—‘ï¸ Delete ${labels.item}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ğŸ” Quick Insight</div>
                    <div class="context-item" id="ctx-deep-dive">ğŸ“ Deep Dive</div>
                    <div class="context-item" id="ctx-debate">ğŸ­ Debate This Topic</div>
                `;
            } else if (activeNode.type === 'subtask') {
                // Subtask context menu (can now have nested subtasks)
                // BUILD 547: Add email reader option for email messages
                const hasEmailData = activeNode.fullBody || activeNode.emailBody;
                const emailOption = hasEmailData ? `<div class="context-item" id="ctx-open-email">ğŸ“§ Open Email</div>` : '';
                menuHtml = `
                    <div class="context-item" id="ctx-view">ğŸ“‹ View Details</div>
                    ${emailOption}
                    <div class="context-item" id="ctx-edit">âœï¸ Edit ${labels.subtask}</div>
                    <div class="context-item" id="ctx-add-subtask">â• Add Nested ${labels.subtask}</div>
                    <div class="context-item" id="ctx-attach">ğŸ“ Attachments</div>
                    <div class="context-item" id="ctx-delete">ğŸ—‘ï¸ Delete ${labels.subtask}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ğŸ” Quick Insight</div>
                    <div class="context-item" id="ctx-deep-dive">ğŸ“ Deep Dive</div>
                    <div class="context-item" id="ctx-debate">ğŸ­ Debate This Topic</div>
                `;
            } else if (activeNode.type === 'phase') {
                // Phase context menu (Build 391: Added delete option, Build 422: Added Edit Details)
                const itemCount = activeNode.items ? activeNode.items.length : 0;
                const deleteWarning = itemCount > 0 ? ` (${itemCount} items)` : '';
                menuHtml = `
                    <div class="context-item" id="ctx-view">ğŸ“‹ View Details</div>
                    <div class="context-item" id="ctx-edit">âœï¸ Edit ${labels.phase}</div>
                    <div class="context-item" id="ctx-edit-details">ğŸ“ Edit Phase Details</div>
                    <div class="context-item" id="ctx-create">â• Add ${labels.item} to ${activeNode.name}</div>
                    <div class="context-item" id="ctx-delete" style="color: #ef4444;">ğŸ—‘ï¸ Delete ${labels.phase}${deleteWarning}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ğŸ” Quick Insight</div>
                    <div class="context-item" id="ctx-deep-dive">ğŸ“ Deep Dive</div>
                    <div class="context-item" id="ctx-debate">ğŸ­ Debate This Topic</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">ğŸ’¾ Download JSON</div>
                    <div class="context-item" id="ctx-upload">ğŸ“‚ Upload JSON</div>
                `;
            } else if (activeNode.type === 'root') {
                // Root context menu (Build 260: Edit opens Project Settings, Build 422: Enhanced)
                menuHtml = `
                    <div class="context-item" id="ctx-view">ğŸ“‹ View Details</div>
                    <div class="context-item" id="ctx-edit">âš™ï¸ Project Settings</div>
                    <div class="context-item" id="ctx-edit-details">ğŸ“ Edit Project Details</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-expand">ğŸ“‚ Expand All</div>
                    <div class="context-item" id="ctx-collapse">ğŸ“ Collapse All</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ğŸ” ${labels.root} Quick Insight</div>
                    <div class="context-item" id="ctx-deep-dive">ğŸ“ Deep Dive</div>
                    <div class="context-item" id="ctx-debate">ğŸ­ Debate This Topic</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">ğŸ’¾ Download JSON</div>
                    <div class="context-item" id="ctx-upload">ğŸ“‚ Upload JSON</div>
                `;
            }

            menu.innerHTML = menuHtml;
            menu.style.display = 'block';

            // Position menu first (to measure dimensions)
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Check if menu goes off screen and adjust position
            const menuRect = menu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            let finalX = x;
            let finalY = y;

            // Adjust horizontal position if menu goes off right edge
            if (menuRect.right > viewportWidth) {
                finalX = viewportWidth - menuRect.width - 10;
            }

            // Adjust vertical position if menu goes off bottom edge
            if (menuRect.bottom > viewportHeight) {
                finalY = viewportHeight - menuRect.height - 10;
            }

            // Ensure menu doesn't go off left edge
            if (finalX < 10) finalX = 10;

            // Ensure menu doesn't go off top edge
            if (finalY < 10) finalY = 10;

            menu.style.left = finalX + 'px';
            menu.style.top = finalY + 'px';

            // Re-attach event listeners
            attachContextMenuListeners();
        }

        function attachContextMenuListeners() {
            const viewBtn = document.getElementById('ctx-view');
            const editBtn = document.getElementById('ctx-edit');
            const editDetailsBtn = document.getElementById('ctx-edit-details');
            const createBtn = document.getElementById('ctx-create');
            const addSubtaskBtn = document.getElementById('ctx-add-subtask');
            const attachBtn = document.getElementById('ctx-attach');
            const deleteBtn = document.getElementById('ctx-delete');
            const aiBtn = document.getElementById('ctx-ai');
            const deepDiveBtn = document.getElementById('ctx-deep-dive');
            const debateBtn = document.getElementById('ctx-debate');
            const downloadBtn = document.getElementById('ctx-download');
            const uploadBtn = document.getElementById('ctx-upload');
            const expandBtn = document.getElementById('ctx-expand');
            const collapseBtn = document.getElementById('ctx-collapse');
            const openEmailBtn = document.getElementById('ctx-open-email'); // BUILD 547

            if (viewBtn) viewBtn.onclick = handleViewDetails;
            if (editBtn) editBtn.onclick = handleEdit;
            if (editDetailsBtn) editDetailsBtn.onclick = handleEditDetails;
            if (createBtn) createBtn.onclick = handleCreate;
            if (addSubtaskBtn) addSubtaskBtn.onclick = handleAddSubtask;
            if (attachBtn) attachBtn.onclick = handleAttachments;
            if (deleteBtn) deleteBtn.onclick = handleDelete;
            if (aiBtn) aiBtn.onclick = handleAI;
            if (deepDiveBtn) deepDiveBtn.onclick = () => handleAnalyzeSelection([activeNode]);
            if (debateBtn) debateBtn.onclick = handleDebate;
            // BUILD 547: Open email reader
            if (openEmailBtn) openEmailBtn.onclick = () => {
                document.getElementById('context-menu').style.display = 'none';
                openEmailReaderModal(activeNode);
            };
            // Fix: ctx-debate appears in 4 menus - attach handler to ALL of them
            document.querySelectorAll('#ctx-debate').forEach(btn => btn.onclick = handleDebate);
            if (downloadBtn) downloadBtn.onclick = handleDownload;
            if (uploadBtn) uploadBtn.onclick = handleUpload;
            if (expandBtn) expandBtn.onclick = handleExpandAll;
            if (collapseBtn) collapseBtn.onclick = handleCollapseAll;
        }

        // BUILD 422: Handle Edit Details for root/phase nodes
        function handleEditDetails() {
            if (!activeNode) return;
            document.getElementById('context-menu').style.display = 'none';
            showEditDetailsModal(activeNode);
        }

        // BUILD 422: Edit Details Modal for Root/Phase nodes
        function showEditDetailsModal(node) {
            const isRoot = node.type === 'root';
            const labels = getPatternLabels();
            const title = isRoot ? 'Project Details' : `${labels.phase} Details`;
            const pattern = PATTERNS[currentPattern];

            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = `ğŸ“ ${title}`;
            // BUILD 603: Clear modal footer (fixes persisted Create Hyperedge button from Query Builder)
            document.querySelector('#modal .modal-footer').innerHTML = '';

            // Calculate stats for display
            let stats = {};
            if (isRoot) {
                const phases = node.children || [];
                const totalItems = phases.reduce((sum, p) => sum + (p.items?.length || 0), 0);
                const totalCost = pattern.fields?.cost ? calculateTotal(node) : 0;
                stats = { phases: phases.length, items: totalItems, cost: totalCost };
            } else {
                const items = node.items || [];
                const totalCost = pattern.fields?.cost ? calculatePhaseTotal(node) : 0;
                stats = { items: items.length, cost: totalCost };
            }

            modalBody.innerHTML = `
                <div style="max-height: 70vh; overflow-y: auto;">
                    <!-- Stats Banner -->
                    <div style="display: flex; gap: 12px; margin-bottom: 24px; flex-wrap: wrap;">
                        ${isRoot ? `
                            <div style="flex: 1; min-width: 100px; padding: 16px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(139, 92, 246, 0.1)); border-radius: 12px; text-align: center; border: 1px solid rgba(99, 102, 241, 0.3);">
                                <div style="font-size: 28px; font-weight: 700; color: var(--treeplex-primary);">${stats.phases}</div>
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase;">${labels.phase}s</div>
                            </div>
                        ` : ''}
                        <div style="flex: 1; min-width: 100px; padding: 16px; background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.1)); border-radius: 12px; text-align: center; border: 1px solid rgba(59, 130, 246, 0.3);">
                            <div style="font-size: 28px; font-weight: 700; color: #3B82F6;">${stats.items}</div>
                            <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase;">${labels.item}s</div>
                        </div>
                        ${pattern.fields?.cost && stats.cost > 0 ? `
                            <div style="flex: 1; min-width: 100px; padding: 16px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1)); border-radius: 12px; text-align: center; border: 1px solid rgba(16, 185, 129, 0.3);">
                                <div style="font-size: 24px; font-weight: 700; color: #10B981;">${formatCost(stats.cost)}</div>
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase;">Total Cost</div>
                            </div>
                        ` : ''}
                    </div>

                    <!-- Name Field -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">
                            ${isRoot ? 'Project Name' : `${labels.phase} Name`}
                        </label>
                        <input type="text" id="edit-details-name" value="${node.name || ''}"
                            style="width: 100%; padding: 12px 16px; background: var(--surface-elevated); border: 2px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 16px; font-weight: 600;"
                            placeholder="Enter ${isRoot ? 'project' : labels.phase.toLowerCase()} name...">
                    </div>

                    <!-- Icon Selection -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">
                            Icon
                        </label>
                        <input type="text" id="edit-details-icon" value="${node.icon || (isRoot ? 'ğŸŒ³' : 'ğŸ“‹')}"
                            style="width: 80px; padding: 12px 16px; background: var(--surface-elevated); border: 2px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 24px; text-align: center;">
                    </div>

                    <!-- Subtitle Field (for phases) -->
                    ${!isRoot ? `
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">
                                Subtitle
                            </label>
                            <input type="text" id="edit-details-subtitle" value="${node.subtitle || ''}"
                                style="width: 100%; padding: 12px 16px; background: var(--surface-elevated); border: 2px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px;"
                                placeholder="Optional subtitle or tagline...">
                        </div>
                    ` : ''}

                    <!-- Description Field -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">
                            Description
                        </label>
                        <textarea id="edit-details-description" rows="4"
                            style="width: 100%; padding: 12px 16px; background: var(--surface-elevated); border: 2px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; line-height: 1.6; resize: vertical;"
                            placeholder="Provide a detailed description of this ${isRoot ? 'project' : labels.phase.toLowerCase()}...">${node.description || ''}</textarea>
                    </div>

                    <!-- Goals/Objectives Field -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">
                            ğŸ¯ Goals & Objectives
                        </label>
                        <textarea id="edit-details-goals" rows="3"
                            style="width: 100%; padding: 12px 16px; background: var(--surface-elevated); border: 2px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; line-height: 1.6; resize: vertical;"
                            placeholder="What are the key objectives? What does success look like?">${node.goals || ''}</textarea>
                    </div>

                    <!-- Notes Field -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">
                            ğŸ“ Notes & Context
                        </label>
                        <textarea id="edit-details-notes" rows="3"
                            style="width: 100%; padding: 12px 16px; background: var(--surface-elevated); border: 2px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; line-height: 1.6; resize: vertical;"
                            placeholder="Additional context, background, or important notes...">${node.notes || ''}</textarea>
                    </div>

                    <!-- Date Fields (for phases) -->
                    ${!isRoot ? `
                        <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                            <div style="flex: 1;">
                                <label style="display: block; font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">
                                    ğŸ“… Start Date
                                </label>
                                <input type="date" id="edit-details-start" value="${node.startDate || ''}"
                                    style="width: 100%; padding: 12px 16px; background: var(--surface-elevated); border: 2px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                            </div>
                            <div style="flex: 1;">
                                <label style="display: block; font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">
                                    ğŸ¯ End Date
                                </label>
                                <input type="date" id="edit-details-end" value="${node.endDate || ''}"
                                    style="width: 100%; padding: 12px 16px; background: var(--surface-elevated); border: 2px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                            </div>
                        </div>
                    ` : ''}

                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 12px; margin-top: 24px; padding-top: 16px; border-top: 1px solid var(--border-color);">
                        <button onclick="document.getElementById('modal').style.display='none'"
                            style="flex: 1; padding: 14px; background: var(--surface-elevated); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="saveEditDetails('${node.id}', ${isRoot})"
                            style="flex: 2; padding: 14px; background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark)); border: none; border-radius: 8px; color: white; font-size: 14px; font-weight: 600; cursor: pointer;">
                            ğŸ’¾ Save Changes
                        </button>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';
        }

        // Save edit details
        function saveEditDetails(nodeId, isRoot) {
            const name = document.getElementById('edit-details-name')?.value?.trim();
            const icon = document.getElementById('edit-details-icon')?.value?.trim();
            const description = document.getElementById('edit-details-description')?.value?.trim();
            const goals = document.getElementById('edit-details-goals')?.value?.trim();
            const notes = document.getElementById('edit-details-notes')?.value?.trim();
            const subtitle = document.getElementById('edit-details-subtitle')?.value?.trim();
            const startDate = document.getElementById('edit-details-start')?.value;
            const endDate = document.getElementById('edit-details-end')?.value;

            // Find the node
            let targetNode = null;
            if (isRoot) {
                targetNode = capexTree;
            } else {
                targetNode = capexTree.children?.find(p => p.id === nodeId);
            }

            if (!targetNode) {
                showToast('âŒ Node not found', 'error');
                return;
            }

            // Save state for undo
            saveState('Edit ' + (isRoot ? 'project' : 'phase') + ' details');

            // Update fields
            if (name) targetNode.name = name;
            if (icon) targetNode.icon = icon;
            targetNode.description = description || '';
            targetNode.goals = goals || '';
            targetNode.notes = notes || '';
            if (!isRoot) {
                targetNode.subtitle = subtitle || '';
                if (startDate) targetNode.startDate = startDate;
                if (endDate) targetNode.endDate = endDate;
            }

            // Close modal and refresh
            document.getElementById('modal').style.display = 'none';
            render();
            showToast('âœ… Details saved!', 'success');

            // Update info panel if open
            if (activeNode && activeNode.id === nodeId) {
                showInfo(targetNode);
            }
        }
        window.saveEditDetails = saveEditDetails;
        window.showEditDetailsModal = showEditDetailsModal;

        // BUILD 371: Handle attachments context menu
        function handleAttachments() {
            if (activeNode) {
                document.getElementById('context-menu').style.display = 'none';
                window.openArtifactPanel(activeNode.id, activeNode.name);
            }
        }

        document.addEventListener('click', () => {
            document.getElementById('context-menu').style.display = 'none';
        });

        // Context menu handlers
        function handleViewDetails() {
            if (activeNode) showInfo(activeNode);
        }

        // =============================================================================
        // SMART SUGGESTION ENGINE - AI-Powered with Pattern Expertise
        // =============================================================================

        // Helper: Extract tree context for AI suggestions
        function extractTreeContext(itemContext) {
            const allItems = getAllProjectItems(capexTree);

            // Find current phase
            let currentPhase = null;
            let siblingItems = [];
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    if (phase.items && phase.items.find(item => item.id === itemContext.id)) {
                        currentPhase = phase;
                        siblingItems = phase.items.filter(item => item.id !== itemContext.id);
                        break;
                    }
                }
            }

            // Find items this depends on
            const dependencies = [];
            if (itemContext.dependencies) {
                itemContext.dependencies.forEach(depId => {
                    const depItem = allItems.find(item => item.id === depId);
                    if (depItem) dependencies.push(depItem);
                });
            }

            // Find items that depend on this
            const dependents = allItems.filter(item =>
                item.dependencies && item.dependencies.includes(itemContext.id)
            );

            return {
                projectName: capexTree.name || 'Project',
                projectDescription: capexTree.description || '',
                pattern: currentPattern,
                totalItems: allItems.length,
                currentPhase: currentPhase ? {
                    name: currentPhase.name,
                    subtitle: currentPhase.subtitle,
                    itemCount: currentPhase.items?.length || 0
                } : null,
                siblingItems: siblingItems.slice(0, 5), // Limit to 5 for context
                dependencies: dependencies.slice(0, 3),
                dependents: dependents.slice(0, 3),
                allItems: allItems.slice(0, 10) // Sample for pattern learning
            };
        }

        // Helper: Build pattern-expert AI prompts
        function buildPatternExpertPrompt(fieldType, itemContext, treeContext) {
            const pattern = currentPattern;

            // Base context shared across all patterns
            let prompt = `You are a subject matter expert for ${pattern} pattern projects. `;

            // Pattern-specific expert persona
            const expertPersonas = {
                philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments.',
                sales: 'You are a sales strategist with 20 years of enterprise B2B experience.',
                thesis: 'You are an academic advisor helping graduate students structure rigorous research.',
                roadmap: 'You are a product manager experienced in agile development and feature prioritization.',
                prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude and GPT-4.',
                book: 'You are a professional fiction editor and writing coach.',
                film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway).',
                course: 'You are a senior instructional designer with 12+ years of experience and an M.Ed. in Curriculum & Instruction, specializing in competency-based learning design, Bloom\'s Taxonomy application, ADDIE methodology, and Gagne\'s Nine Events of Instruction. You apply adult learning theory (Knowles\' andragogy) and backward design principles (Wiggins & McTighe).',
                fitness: 'You are a certified personal trainer and exercise physiologist with expertise in program design, exercise science, and progressive overload.',
                event: 'You are a professional event planner with experience in corporate events, weddings, and large-scale conferences.',
                strategy: 'You are a senior business strategy consultant with 12+ years of experience. Your expertise spans Porter\'s Five Forces, McKinsey 7-S Model, BCG Matrix, Blue Ocean Strategy, and OKRs. You draw from the strategic thinking of Michael Porter, Clayton Christensen, and Rita McGrath.',
                familytree: 'You are a professional genealogist and family historian specializing in genealogical research and family tree documentation.',
                dialogue: 'You are a rhetoric and argumentation expert specializing in debate analysis, persuasive communication, and identifying logical fallacies.',
                gmail: 'You are an expert email analyst and communication strategist. You analyze email threads for tone, intent, rhetoric, and relationship dynamics. You provide context-aware suggestions for responses based on the full conversation history.',
                capex: 'You are an expert financial strategist and CFO crafting investor-ready CAPEX structures for angel investor presentations. Your approach: (1) FUNDING STORY - structure phases as stepping stones to funding milestones with clear de-risking; (2) RISK TRANSPARENCY - for each item, identify risks and concrete mitigations (sophisticated investors will find them anyway); (3) RETURN NARRATIVE - connect phases to valuation drivers and path to returns; (4) COMPETITIVE MOAT - highlight cost advantages and sustainable competitive edges. Demonstrate capital efficiency and make the path to value creation explicit.',
                generic: 'You are an experienced Project Manager with expertise in breaking down complex projects into manageable phases and tasks. Focus on clear structure, logical dependencies, and realistic planning.'
            };

            prompt += expertPersonas[pattern] || expertPersonas.generic;
            prompt += `\n\n`;

            // Project context (trimmed for speed)
            prompt += `PROJECT: ${treeContext.projectName}`;
            if (treeContext.currentPhase) {
                prompt += ` - ${treeContext.currentPhase.name}`;
            }
            prompt += `\n\n`;

            // Current item context (trimmed)
            prompt += `ITEM: ${itemContext.name || 'New Item'}\n`;
            if (itemContext.description && itemContext.description.length < 200) {
                prompt += `${itemContext.description.substring(0, 200)}\n`;
            }

            // Add existing field values for context
            const relevantFields = ['speaker', 'conclusion', 'premise1', 'premise2',
                                    'dealValue', 'contactPerson', 'leadSource',
                                    'keyArgument', 'evidenceType',
                                    'videoPrompt', 'visualStyle', 'cameraMovement',
                                    'itemType', 'notes'];
            relevantFields.forEach(field => {
                if (itemContext[field] && field !== fieldType) {
                    prompt += `- ${field}: ${itemContext[field]}\n`;
                }
            });

            // Dependencies (minimal, for speed)
            if (treeContext.dependencies.length > 0) {
                prompt += `Builds on: ${treeContext.dependencies.map(d => d.name).join(', ')}\n`;
            }

            // Sibling examples (limit to 2, show only relevant field)
            if (treeContext.siblingItems.length > 0) {
                const examples = treeContext.siblingItems
                    .filter(sib => sib[fieldType])
                    .slice(0, 2)
                    .map(sib => String(sib[fieldType]).substring(0, 60));
                if (examples.length > 0) {
                    prompt += `Examples: ${examples.join('; ')}\n`;
                }
            }

            prompt += `\n`;

            // CONTINUITY INSTRUCTIONS for sequential/narrative patterns
            const sequentialPatterns = ['film', 'book', 'roadmap'];
            if (sequentialPatterns.includes(pattern) && treeContext.siblingItems.length > 0) {
                const lastSibling = treeContext.siblingItems[treeContext.siblingItems.length - 1];
                prompt += `âš ï¸ CONTINUITY REQUIREMENT:\n`;
                prompt += `This item follows: "${lastSibling.name}"\n`;

                if (pattern === 'film') {
                    prompt += `Ensure visual/narrative continuity from previous scene:\n`;
                    if (lastSibling.description) prompt += `- Previous scene: ${lastSibling.description.substring(0, 100)}\n`;
                    if (lastSibling.lightingMood) prompt += `- Previous lighting: ${lastSibling.lightingMood}\n`;
                    prompt += `- If previous scene ended with location change/fade, this scene must establish new context\n`;
                    prompt += `- Maintain consistent visual style and tone unless intentionally shifting\n`;
                } else if (pattern === 'book') {
                    prompt += `Ensure narrative continuity from previous chapter/section:\n`;
                    if (lastSibling.description) prompt += `- Previous: ${lastSibling.description.substring(0, 100)}\n`;
                    prompt += `- Maintain character consistency, plot coherence, and thematic threads\n`;
                    prompt += `- If starting new section/arc, provide logical handover from previous\n`;
                } else if (pattern === 'roadmap') {
                    prompt += `Ensure feature sequencing makes sense:\n`;
                    if (lastSibling.description) prompt += `- Previous feature: ${lastSibling.description.substring(0, 100)}\n`;
                    prompt += `- Check dependencies: does this feature build on or require the previous one?\n`;
                    prompt += `- If starting new phase, ensure logical progression from previous phase goals\n`;
                }
                prompt += `\n`;
            }

            // Pattern-specific field instructions
            prompt += buildFieldInstructions(pattern, fieldType, itemContext);

            // CRITICAL: For video prompts and other direct-use fields, be VERY strict
            const directUseFields = ['videoPrompt', 'visualStyle', 'cameraMovement', 'flowMode', 'audioType',
                                     'cinematicStyle', 'beatType', 'physicsComplexity', 'nleExportFormat', 'audioSync'];
            if (directUseFields.includes(fieldType)) {
                prompt += `\nâš ï¸ CRITICAL OUTPUT FORMAT âš ï¸
Return ONLY the raw ${fieldType} text that will be used directly with AI video generation.
NO conversational introductions like "Okay, buckle up..." or "Get ready..." or "Here's..." or "Let me..."
NO explanations, NO context, NO meta-commentary, NO exclamation marks before the actual content
JUST the actual ${fieldType} text itself, ready to paste directly into Sora/Veo/Runway.

Example WRONG: "Okay, buckle up! Here's an amazing prompt: [actual prompt]"
Example WRONG: "Get ready to ignite the screen with this: [actual prompt]"
Example CORRECT: "[actual prompt]"

Your response:`;
            } else {
                prompt += `\nReturn ONLY the ${fieldType} value (1-3 sentences, no explanation).\n`;
            }

            return prompt;
        }

        // Helper: Pattern-specific field instructions
        function buildFieldInstructions(pattern, fieldType, itemContext) {
            let instructions = `YOUR TASK: Suggest a ${fieldType} for the current item.\n\n`;

            // Philosophy pattern
            if (pattern === 'philosophy') {
                const fieldInstructions = {
                    speaker: 'Suggest the most appropriate philosophical speaker/author for this argument based on the topic and historical context.',
                    premise1: 'Suggest a first premise that would logically support the conclusion. Use clear, precise philosophical language.',
                    premise2: 'Suggest a second premise that bridges premise1 to the conclusion, creating a valid logical inference.',
                    premise3: 'Suggest a third premise if needed to complete the argument structure.',
                    conclusion: 'Suggest a philosophical conclusion that follows from the premises. State it clearly and precisely.',
                    objection: 'Suggest a strong objection to this argument - what would a critic say? Be specific and philosophically rigorous.',
                    response: 'Suggest how the author would respond to the objection. Use careful distinctions and counterarguments.',
                    keyTerms: 'List 3-5 key philosophical terms central to this argument (comma-separated).',
                    textualReference: 'Suggest specific textual references (work and section numbers) where this argument appears or is discussed.',
                    description: 'Write a 2-3 sentence description of this philosophical argument, its method, and its significance.',
                    name: 'Suggest a concise title for this philosophical argument that captures its core claim.',
                    notes: 'Suggest key considerations for evaluating this argument: validity, soundness, implications, objections.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Sales pattern
            else if (pattern === 'sales') {
                const fieldInstructions = {
                    dealValue: 'Suggest a realistic deal value (in thousands $K) based on the deal type and company size.',
                    contactPerson: 'Suggest the most likely decision-maker title for this type of deal.',
                    leadSource: 'Suggest the most probable lead source for this deal type.',
                    competitorInfo: 'Suggest realistic competitive intelligence: who are we competing against and how do we differentiate? (2-3 sentences)',
                    expectedCloseDate: 'Suggest a realistic close date based on deal size and sales cycle.',
                    stageProbability: 'Suggest a close probability (0-100) based on the deal stage and context.',
                    description: 'Write a 2-3 sentence description of this sales opportunity, key stakeholders, and success factors.',
                    name: 'Suggest a descriptive name for this deal that includes company type and solution.',
                    notes: 'Suggest key considerations: budget timing, decision process, procurement, champion identification.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Thesis pattern
            else if (pattern === 'thesis') {
                const fieldInstructions = {
                    keyArgument: 'Suggest the main thesis argument for this chapter/section. What gap does it address? What contribution does it make?',
                    citations: 'Suggest 3-5 realistic academic citations (Author Year format) relevant to this topic.',
                    evidenceType: 'Suggest the most appropriate evidence type (Empirical, Theoretical, Mixed, Case Study, etc.).',
                    wordCount: 'Suggest a realistic current word count for this section.',
                    targetWordCount: 'Suggest an appropriate target word count based on section type.',
                    description: 'Write a 2-3 sentence description of this chapter/section: its argument, evidence, and contribution.',
                    name: 'Suggest a clear chapter/section title that reflects its content and argument.',
                    notes: 'Suggest key considerations: citation completeness, argument coherence, methodological rigor.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Film pattern
            else if (pattern === 'film') {
                const fieldInstructions = {
                    videoPrompt: 'Suggest a detailed Sora/Veo prompt (100-200 chars) for this scene. Include: subject, action, camera movement, lighting, style. Be cinematic and specific.',
                    cameraMovement: 'Suggest the most appropriate camera movement for this scene type and mood.',
                    lightingMood: 'Suggest the best lighting mood based on time of day, genre, and emotional tone.',
                    visualStyle: 'Suggest the visual style that best matches this scene\'s purpose and genre.',
                    duration: 'Suggest appropriate clip duration based on scene complexity and action.',
                    aiPlatform: 'Suggest the best AI platform (Sora, Veo 3, Runway Gen-3) for this scene type.',
                    description: 'Write a 2-3 sentence description of this scene: what happens, mood, visual approach.',
                    name: 'Suggest a concise scene name that captures the key action or emotion.',
                    notes: 'Suggest key considerations: continuity, platform strengths, prompt specificity, motion artifacts.',
                    iterationNotes: 'Suggest prompt engineering tips specific to this scene type.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Veo3 pattern
            else if (pattern === 'veo3') {
                const fieldInstructions = {
                    videoPrompt: 'Suggest a detailed Veo 3 prompt optimized for Google\'s model. Include: subject, action, camera movement, lighting, cinematic style.',
                    flowMode: 'Suggest the best Veo 3 Flow mode (Ingredients/Frames/Extend/Standard) for this scene.',
                    ingredientImages: 'Suggest what reference images would be needed for character/object/style consistency.',
                    startFrame: 'Suggest description of the starting frame for frame-to-frame bridging.',
                    endFrame: 'Suggest description of the ending frame for frame-to-frame bridging.',
                    extendDuration: 'Suggest target duration for video extension based on scene complexity.',
                    audioType: 'Suggest the best native audio type (Dialogue/SFX/Ambience/Mixed) for this scene.',
                    cinematicStyle: 'Suggest the Veo 3 cinematic style that best matches this scene.',
                    description: 'Write 2-3 sentences: what this scene shows, the Flow workflow, and visual approach.',
                    name: 'Suggest a concise scene name capturing the key visual or action.',
                    notes: 'Suggest key considerations: ingredient image quality, frame coherence, extension strategy.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Sora2 pattern
            else if (pattern === 'sora2') {
                const fieldInstructions = {
                    videoPrompt: 'Suggest a detailed Sora 2 prompt optimized for OpenAI\'s physics-accurate model. Include: subject, action, physics requirements, lighting, style.',
                    beatType: 'Suggest the narrative beat type (Setup/Conflict/Transition/Resolution) for this shot.',
                    cameoUsed: 'Suggest if this shot should use cameo integration and which cameo ID.',
                    remixSource: 'Suggest if this should be a remix of an existing shot, and which shot ID.',
                    physicsComplexity: 'Suggest physics complexity level (Simple/Medium/Complex) based on motion requirements.',
                    duration: 'Suggest Sora 2 duration (4s/8s/12s) based on action complexity.',
                    nleExportFormat: 'Suggest the best NLE format for post-production workflow.',
                    audioSync: 'Suggest audio type (Synchronized Dialogue/SFX/Background Score) for this beat.',
                    description: 'Write 2-3 sentences: what this beat accomplishes, physics requirements, and narrative purpose.',
                    name: 'Suggest a concise beat name capturing the narrative moment.',
                    notes: 'Suggest key considerations: physics accuracy, cameo setup, remix strategy, NLE workflow.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Roadmap pattern
            else if (pattern === 'roadmap') {
                const fieldInstructions = {
                    storyPoints: 'Suggest story point estimate (Fibonacci: 1,2,3,5,8,13) based on feature complexity.',
                    userImpact: 'Suggest user impact level (Low/Medium/High/Critical) based on affected user percentage and importance.',
                    technicalRisk: 'Suggest technical risk (Low/Medium/High) considering dependencies, unknowns, and complexity.',
                    engineeringEstimate: 'Suggest time estimate in sprints/weeks based on complexity.',
                    featureFlag: 'Suggest a feature flag name following naming conventions (feature_*).',
                    description: 'Write 2-3 sentences: what this feature does, who it affects, and key success metrics.',
                    name: 'Suggest a clear feature name that describes the user-facing capability.',
                    notes: 'Suggest key considerations: testing requirements, rollout strategy, monitoring, documentation.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Prompting pattern
            else if (pattern === 'prompting') {
                const fieldInstructions = {
                    systemPrompt: 'Suggest a clear, specific system prompt defining the AI\'s role, capabilities, and constraints. Use Anthropic best practices.',
                    userPromptTemplate: 'Suggest a user prompt template with {{variables}} and XML tags for structure.',
                    fewShotExamples: 'Suggest 1-2 few-shot examples in <examples><example> format showing input/output patterns.',
                    chainOfThought: 'Suggest CoT instructions: "Think step by step..." tailored to this task.',
                    outputFormat: 'Suggest the expected output structure (markdown, JSON, specific sections).',
                    structuralTags: 'Suggest XML tags for this task (e.g., <thinking>, <answer>, <critique>).',
                    assistantPrefill: 'Suggest an assistant prefill to guide tone and format.',
                    toolDefinitions: 'Suggest tool/function definitions if this task needs tool calling (JSON schema).',
                    modelTarget: 'Suggest the best model (Claude 3.5 Sonnet, GPT-4o, etc.) for this use case.',
                    temperature: 'Suggest temperature (0-1). Use 0-0.3 for deterministic tasks, 0.7-1.0 for creative.',
                    description: 'Write 2-3 sentences: what this prompt does, its approach, and optimization goals.',
                    name: 'Suggest a descriptive name for this prompt use case.',
                    notes: 'Suggest OpenAI/Anthropic best practices applied to this specific prompt.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Generic pattern - PM and CFO perspective
            else if (pattern === 'generic') {
                const fieldInstructions = {
                    cost: 'Suggest a realistic cost estimate based on the item type, scope, and market rates. Consider labor, materials, overhead.',
                    leadTime: 'Suggest a realistic timeline considering procurement cycles, dependencies, and resource availability.',
                    alternateSource: 'Suggest a credible backup vendor or alternative approach to mitigate supply chain/delivery risks.',
                    pmNextSteps: 'Suggest 2-3 specific, actionable next steps a PM would take to advance this task.',
                    pmBlockingIssue: 'Identify likely blockers: budget constraints, resource conflicts, vendor delays, approvals needed.',
                    description: 'Write 2-3 sentences describing this deliverable, its business value, and key execution considerations.',
                    name: 'Suggest a clear deliverable name that communicates scope and business value.',
                    notes: 'Suggest PM considerations: budget burn rate, stakeholder alignment, risk mitigation, change management.',
                    pmOwnerEmail: 'Suggest the most appropriate role/person to own this (e.g., engineering-lead@, procurement@, finance@).'
                };
                instructions += fieldInstructions[fieldType] || `From a PM and CFO perspective, suggest a realistic ${fieldType} value considering budget, timeline, and risk factors.`;
            }

            // Gmail pattern - Email analysis and response generation
            else if (pattern === 'gmail') {
                const fieldInstructions = {
                    subjectLine: 'Suggest 2-3 high-converting subject lines based on the email context. Keep under 50 characters. Avoid spammy words. Focus on value or curiosity.',
                    emailBody: 'Analyze the full conversation thread and suggest a contextually-appropriate response. Reference previous messages. Match the tone and formality level. Include a clear call to action if appropriate.',
                    recipientEmail: 'Suggest the likely recipient based on the conversation context and sender patterns.',
                    status: 'Suggest the appropriate email status (Draft/Sent/Replied/Archived) based on the conversation state.',
                    name: 'Suggest a short internal name for this email thread that captures the main topic or business context.',
                    description: 'Analyze this email thread: summarize the key points, identify the tone/sentiment, note any action items, and assess relationship dynamics.',
                    notes: 'Suggest key observations: communication style, negotiation position, objections raised, next steps needed, relationship temperature (warm/neutral/cold).'
                };
                instructions += fieldInstructions[fieldType] || `Analyze the email context and conversation history to suggest an appropriate ${fieldType} value.`;
            }

            // Event Planning pattern
            else if (pattern === 'event') {
                const fieldInstructions = {
                    budget: 'Suggest realistic budget based on activity type. Catering: $25-75/person, Venue: $2-10K, AV/Tech: $1-5K, Entertainment: $500-5K. Consider event scale and location.',
                    vendor: 'Suggest appropriate vendor type and realistic company name. Include specialization (e.g., "ABC Catering - Corporate Events", "Premier AV - Full-service production").',
                    bookingDeadline: 'Suggest booking deadline based on vendor type: Venues (6-12 months ahead), Catering (2-3 months), Entertainment (3-6 months), AV/Tech (1-2 months).',
                    guestCount: 'Suggest realistic guest count based on event type: Corporate (50-500), Wedding (100-250), Conference (100-1000), Team building (20-100).',
                    location: 'Suggest specific location based on activity. Be detailed: "Grand Ballroom, 2nd floor" not just "Hotel". Include practical details.',
                    responsiblePerson: 'Suggest appropriate role based on activity type: Event Manager (overall), AV Coordinator (tech), Catering Manager (food), Registration Lead (check-in).',
                    description: 'Write 2-3 sentences: what this activity entails, its role in the event, and key success factors.',
                    name: 'Suggest a clear activity name that includes the type and purpose.',
                    notes: 'Suggest key considerations: vendor contracts, backup plans, timing dependencies, permits needed, weather contingencies.'
                };
                instructions += fieldInstructions[fieldType] || `From an event planner\'s perspective, suggest a realistic ${fieldType} value considering logistics, timeline, and vendor coordination.`;
            }

            // Fitness pattern
            else if (pattern === 'fitness') {
                const fieldInstructions = {
                    sets: 'Suggest sets based on training goal: Hypertrophy (3-4 sets), Strength (5+ sets), Endurance (2-3 sets), Skill work (3-5 sets). Consider training age and recovery capacity.',
                    reps: 'Suggest rep ranges by goal: Strength (3-6 reps), Hypertrophy (8-12 reps), Endurance (15+ reps), Power (1-5 reps explosive). Match to exercise type (compound vs isolation).',
                    duration: 'Suggest duration based on workout type: Strength session (45-75 min), Cardio (20-60 min), Circuit training (30-45 min), Recovery/mobility (15-30 min).',
                    intensity: 'Suggest intensity level based on training phase, exercise type, and proximity to competition/testing. Consider recovery status.',
                    equipment: 'Suggest realistic equipment based on exercise. Be specific: "Olympic Barbell, 45lb plates" not just "weights". Consider gym vs home setup.',
                    formCues: 'Provide 3 specific biomechanical safety cues focusing on joint angles, spine position, and common injury risks. Example: "Deadlift: Neutral spine, shoulders over bar, drive through heels." Reference anatomy.',
                    restPeriod: 'Suggest rest based on goal: Strength (3-5 min - CNS recovery), Hypertrophy (60-90s - metabolic stress), Endurance (30-45s - conditioning), Power (2-3 min).',
                    description: 'Write 2-3 sentences: training stimulus, primary muscle groups, and how this fits into the program phase.',
                    name: 'Suggest a descriptive workout name indicating focus (e.g., "Upper Body Hypertrophy A", "Lower Power Day").',
                    notes: 'Suggest key considerations: progression scheme (linear, wave, double progression), deload timing, exercise substitutions, injury prevention.'
                };
                instructions += fieldInstructions[fieldType] || `From a certified strength coach perspective (CSCS), suggest a ${fieldType} value based on training science and periodization principles.`;
            }

            // Strategic Planning pattern
            else if (pattern === 'strategy') {
                const fieldInstructions = {
                    investment: 'Suggest realistic capital investment based on initiative scope. Consider: Technology ($100K-$5M), Market expansion ($500K-$10M), Operational improvements ($50K-$2M). Include CAPEX and OPEX.',
                    keyMetric: 'Suggest a specific, measurable KPI that defines success. Use SMART criteria. Examples: "Revenue growth %", "Customer acquisition cost", "Market share %", "Employee retention rate".',
                    targetValue: 'Suggest a specific, ambitious but achievable target for the metric. Base on industry benchmarks. Example: "Increase revenue by 25% YoY", "Reduce CAC by $150".',
                    responsibleExecutive: 'Suggest appropriate C-level owner: CEO (transformation), CFO (financial), CTO (technology), CMO (marketing), COO (operations), CHRO (people).',
                    strategicTheme: 'Assign theme based on initiative nature: Growth (revenue expansion), Efficiency (cost reduction), Innovation (new products), Transformation (business model change), Risk Mitigation (compliance, security).',
                    riskLevel: 'Assess risk considering: Market uncertainty, technical complexity, regulatory factors, resource constraints. High risk: unproven, complex, resource-intensive.',
                    description: 'Write 2-3 sentences: strategic rationale, expected business impact, and key success factors.',
                    name: 'Suggest a clear initiative name that communicates strategic intent and business value.',
                    notes: 'Suggest key considerations: competitive response, regulatory requirements, change management, ROI timeline, resource conflicts.'
                };
                instructions += fieldInstructions[fieldType] || `From a strategy consultant perspective (McKinsey/BCG), suggest a ${fieldType} value considering competitive dynamics, market forces, and organizational capabilities.`;
            }

            // Course Design pattern
            else if (pattern === 'course') {
                const fieldInstructions = {
                    learningObjectives: 'Write 2-3 specific learning objectives using Bloom\'s Taxonomy action verbs (Remember: define, list; Understand: explain, summarize; Apply: demonstrate, solve; Analyze: compare, critique; Evaluate: judge, defend; Create: design, compose). Make them measurable and specific.',
                    duration: 'Suggest duration based on lesson type: Lecture (50-75 min), Lab/Practical (90-120 min), Discussion (30-60 min), Workshop (2-4 hours), Field work (half-day to full-day).',
                    difficultyLevel: 'Suggest level based on prerequisite knowledge, cognitive complexity (Bloom\'s level), and abstraction required. Beginner: foundational concepts. Intermediate: application/analysis. Advanced: synthesis/evaluation.',
                    prerequisites: 'List specific prior knowledge, skills, or courses needed. Be concrete: "Understanding of basic statistics (mean, median, standard deviation)" not just "some statistics".',
                    assessmentType: 'Suggest assessment matching learning objectives. Use Bloom\'s level: Quiz (remember/understand), Assignment (apply/analyze), Project (analyze/evaluate/create), Discussion (understand/evaluate), Exam (comprehensive).',
                    resourcesNeeded: 'List specific resources: Textbook chapters with page numbers, required readings with citations, software/tools, datasets, lab equipment, handouts.',
                    homework: 'Suggest homework that reinforces learning objectives. Estimate time required (typically 2-3x class time for college courses). Make it specific and scaffolded.',
                    description: 'Write 2-3 sentences: key concepts covered, pedagogical approach, and how this builds toward course goals.',
                    name: 'Suggest a clear lesson title that reflects content and cognitive level.',
                    notes: 'Suggest key considerations: active learning strategies, accommodation needs, technology requirements, formative assessment touchpoints.'
                };
                instructions += fieldInstructions[fieldType] || `From an instructional designer perspective (ADDIE model, Bloom\'s Taxonomy), suggest a ${fieldType} value considering learning science and curriculum design principles.`;
            }

            // Family Tree pattern
            else if (pattern === 'familytree') {
                const fieldInstructions = {
                    fullName: 'Suggest full legal name including middle names. Use historical naming conventions for era (e.g., patronymics, matronymics in certain cultures).',
                    maidenName: 'Suggest maiden name (birth surname) if person changed name after marriage. Consider cultural naming traditions.',
                    gender: 'Suggest gender based on name and historical context. Use "Unknown" if insufficient evidence.',
                    birthDate: 'Suggest realistic birth date based on generation, parent ages, and historical context. Parents typically 20-35 years older than children.',
                    birthPlace: 'Suggest birth location with specificity appropriate to era and records. Format: City, State/Province, Country. Consider migration patterns.',
                    livingStatus: 'Determine based on birth year and typical lifespan. Anyone born before 1920 likely deceased. Use "Unknown" if uncertain.',
                    deathDate: 'Suggest death date if deceased. Consider typical lifespan for era: pre-1900 (40-60 years), 1900-1950 (60-70 years), post-1950 (70-85 years).',
                    deathPlace: 'Suggest death location considering migration history and family patterns. Often different from birthplace.',
                    marriageDate: 'Suggest marriage date considering historical marriage ages: Pre-1900 (women 18-22, men 22-26), Modern (women 25-30, men 27-32). Check birth dates of children.',
                    marriagePlace: 'Suggest marriage location based on family residence patterns and cultural traditions.',
                    spouseName: 'Suggest spouse name if married. Consider multiple marriages if dates suggest (remarriage after death/divorce).',
                    occupation: 'Suggest historically appropriate occupation for era, location, and social class. Be specific: "Locomotive Engineer" not just "Railroad worker".',
                    photoURL: 'Suggest type of photo if known: "Portrait photo circa 1920s" or "Family photo, wedding day". Note if no photo available.',
                    dnaInfo: 'Suggest relevant genetic information: Haplogroups (Y-DNA for paternal line, mtDNA for maternal line), ethnic percentages, DNA matches, genetic markers.',
                    sources: 'Suggest appropriate primary sources: Birth/death certificates, census records (1850-1940 US), marriage licenses, military records, church records, immigration documents.',
                    relationshipType: 'Classify relationship: Biological (default), Adopted, Step (remarriage), Foster, Half-Sibling (shared one parent). Consider family dynamics.',
                    description: 'Write 2-3 sentences: brief biography, significant life events, and family role/legacy.',
                    name: 'Suggest identifying name (often nickname or commonly used name): "John Smith (Big John)" or "Mary Johnson (nÃ©e Williams)".',
                    notes: 'Suggest key considerations: Missing records, conflicting data, DNA confirmation status, historical context, research leads to pursue.'
                };
                instructions += fieldInstructions[fieldType] || `From a genealogist perspective (NGSQ standards), suggest a ${fieldType} value based on historical records, naming patterns, and genealogical best practices.`;
            }

            // Dialogue & Rhetoric pattern
            else if (pattern === 'dialogue') {
                const fieldInstructions = {
                    speaker: 'Identify speaker and relevant context: Name, role/title, political affiliation, expertise, or motivation. Example: "Senator Jane Smith (R-TX, Healthcare Committee Chair)".',
                    verbatimQuote: 'Extract the exact statement word-for-word. Capture tone indicators (emphasis, pauses). Essential for accurate rhetorical analysis.',
                    rhetoricalDevice: 'Identify primary persuasion technique: Logos (logical reasoning), Pathos (emotional appeal), Ethos (credibility), Metaphor, Analogy, Repetition, Hyperbole, Irony, Appeal to Authority.',
                    logicalStructure: 'Break down argument into formal logic: "Premise 1: [claim], Premise 2: [claim], Conclusion: [claim]". Identify deductive/inductive/abductive reasoning.',
                    fallaciesPresent: 'Identify logical fallacies with examples: Ad hominem (attack person not argument), Straw man (misrepresent position), Slippery slope, False dichotomy, Appeal to emotion, Hasty generalization. Explain how fallacy appears.',
                    hiddenMotivation: 'Analyze subtext and hidden agenda. What is the speaker really trying to achieve? Consider: Political positioning, fundraising, deflection, changing topic, rallying base.',
                    description: 'Write 2-3 sentences: summarize the argument, identify rhetorical strategy, and assess persuasive effectiveness.',
                    name: 'Suggest a short label capturing the argument\'s core claim or tactic (e.g., "Healthcare Cost Deflection", "Moral Authority Appeal").',
                    notes: 'Suggest key observations: Communication style, negotiation position, emotional valence, audience targeting, cultural context, historical parallels.'
                };
                instructions += fieldInstructions[fieldType] || `From a rhetoric expert perspective (Aristotelian persuasion, critical discourse analysis), suggest a ${fieldType} value analyzing argument structure, persuasion techniques, and logical coherence.`;
            }

            // Filesystem pattern - Digital Librarian AI
            else if (pattern === 'filesystem') {
                const fieldInstructions = {
                    tags: 'Suggest 3-5 taxonomic tags based on the filename, location, and file extension. Use consistent casing (lowercase-kebab). Examples: "financial-report", "customer-data", "design-asset", "code-source", "archive-2024".',
                    fileOwner: 'Suggest the most likely owner/creator based on the folder context, file type, and naming patterns. Format as email or department: "finance@company.com", "engineering-dept", "john.doe", "admin".',
                    permissions: 'Suggest appropriate permissions (Read Only, Read/Write, Owner, Viewer, Editor) based on file type, sensitivity, and likely use case. Financial data â†’ Read Only, Shared docs â†’ Read/Write, System files â†’ Owner only.',
                    description: 'Write a clear 1-2 sentence summary of what this file/folder likely contains based on its name, extension, location, and context. Be specific about content type and purpose.',
                    name: 'Suggest a clean, standardized filename if the current one is messy. Use ISO 8601 dates (YYYY-MM-DD), no spaces (use hyphens or underscores), descriptive keywords, and proper casing. Example: "2024-Q3-financial-report.pdf" instead of "report final FINAL (1).pdf".',
                    notes: 'Suggest data governance notes: retention policy (how long to keep), backup priority (critical/standard/low), security classification (public/internal/confidential/restricted), compliance requirements (GDPR, HIPAA, SOX), and archival recommendations.',
                    fileSize: 'Estimate realistic file size in bytes based on file type and likely content. Documents (50KB-5MB), Images (100KB-10MB), Videos (10MB-2GB), Code (10KB-500KB), Archives (1MB-500MB).',
                    fileExtension: 'Suggest the correct file extension based on the filename and file type. Be specific: .pdf, .docx, .xlsx, .pptx, .jpg, .png, .mp4, .zip, .py, .js, .html, etc.',
                    filePath: 'Suggest a logical full file path based on the file type, organizational context, and best practices for file organization. Use clear folder hierarchies.',
                    dateModified: 'Suggest when this file was likely last modified based on context clues (project timelines, version numbers, naming patterns). Use ISO 8601 format.',
                    dateCreated: 'Suggest when this file was likely created based on naming conventions, project context, or folder structure. Use ISO 8601 format.',
                    sharedWith: 'Suggest who should have access to this file based on content type, sensitivity, and organizational context. List email addresses or group names.',
                    driveType: 'Suggest the appropriate storage location (Local Drive, Google Drive, OneDrive, Dropbox, Network Drive, External Drive) based on file type, sharing needs, and organizational policies.',
                    mimeType: 'Suggest the MIME type based on file extension. Examples: application/pdf, image/jpeg, text/html, video/mp4, application/zip, text/plain, application/json.',
                    fileUrl: 'Suggest whether this should be stored in cloud storage and note the URL pattern (e.g., "Google Drive - shared link", "OneDrive - team folder", "Local only").',
                    isFolder: 'Determine if this should be a folder or file based on naming patterns. Folders typically have generic names (Documents, 2024-Reports, Assets) while files have extensions.'
                };
                instructions += fieldInstructions[fieldType] || `Act as a Digital Librarian and File Management expert. Suggest appropriate metadata for this file/folder, considering: organizational best practices, data governance, security classification, and clean naming conventions. Help tame messy filesystems.`;
            }

            // Other patterns
            else {
                instructions += `Consider the project context, dependencies, and sibling items. Suggest a realistic, specific ${fieldType} value that fits the pattern.`;
            }

            return instructions;
        }

        // MAIN AI SUGGESTION FUNCTION (async with AI integration)
        async function generateAISuggestion(fieldType, itemContext) {
            console.log('ğŸ¤– generateAISuggestion called:', fieldType);

            // Check global AI mode
            const aiMode = getGlobalAIMode();
            console.log('ğŸ¤– Global AI Mode:', aiMode);

            if (aiMode === 'off') {
                console.log('âŒ AI features disabled, using static fallback');
                return generateStaticSuggestion(fieldType, itemContext);
            }

            // Check if API key is available (needed for all modes)
            const apiKey = getLocalAPIKey(getAIProvider());
            console.log('ğŸ”‘ API Key present:', !!apiKey);

            if (!apiKey && aiMode === 'deep') {
                console.log('âš ï¸ Deep Mode requires API key, falling back to static');
                alert('ğŸ”¬ Deep Mode requires your own API key.\n\nPlease configure your API key (ğŸ”‘ button) or switch to Quick Mode in the header.');
                return generateStaticSuggestion(fieldType, itemContext);
            }

            if (!apiKey && aiMode === 'quick') {
                console.log('âš¡ Quick Mode: Will use server API key');
            }

            try {
                // Extract full tree context
                console.log('ğŸ“Š Extracting tree context...');
                const treeContext = extractTreeContext(itemContext);
                console.log('ğŸ“Š Tree context extracted:', treeContext);

                // Build pattern-expert prompt
                console.log('ğŸ“ Building expert prompt...');
                const expertPrompt = buildPatternExpertPrompt(fieldType, itemContext, treeContext);
                console.log('ğŸ“ Expert prompt built, length:', expertPrompt.length);

                // Call Claude API for intelligent suggestion (low token limit for speed)
                console.log('â˜ï¸ Calling Claude API...');
                const suggestion = await callClaudeAPI(expertPrompt, '', 256); // 256 tokens max = faster, stays under 10s Netlify limit
                console.log('â˜ï¸ Claude API response:', suggestion);

                // Clean up the response (remove quotes, trim)
                let cleaned = suggestion.trim();
                if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
                    cleaned = cleaned.slice(1, -1);
                }
                if (cleaned.startsWith("'") && cleaned.endsWith("'")) {
                    cleaned = cleaned.slice(1, -1);
                }

                console.log('âœ¨ Returning cleaned suggestion:', cleaned);
                return cleaned || generateStaticSuggestion(fieldType, itemContext);

            } catch (error) {
                console.error('âŒ AI suggestion failed, falling back to static:', error);
                console.error('Error details:', error.message, error.stack);
                return generateStaticSuggestion(fieldType, itemContext);
            }
        }

        // STATIC SUGGESTION ENGINE (fallback when no API key)
        function generateStaticSuggestion(fieldType, itemContext) {
            const pattern = PATTERNS[currentPattern];
            const itemType = itemContext.itemType || '';
            const phase = itemContext.id ? itemContext.id.split('-')[0] : 'p0';
            const notes = itemContext.notes || '';

            // Get all existing items for contextual analysis
            function getAllProjectItems(node = capexTree, items = []) {
                if (node.items) items.push(...node.items);
                if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
                return items;
            }
            const existingItems = getAllProjectItems();

            // Pattern-aware AI suggestion templates - Subject matter experts for each domain
            const patternSuggestions = {
                philosophy: {
                    name: ['Knowledge is Virtue', 'The Nature of Justice', 'Definition of Piety', 'Forms vs Particulars', 'The Good Life', 'Moral Relativism Critique', 'Socratic Paradox', 'The Cave Allegory', 'Mind-Body Problem', 'Free Will vs Determinism'],
                    description: 'Dialectical examination of fundamental concepts through logical argumentation. Present premises systematically, consider objections, and respond with careful distinctions. Ground claims in textual evidence and philosophical tradition.',
                    speaker: ['Socrates', 'Plato', 'Aristotle', 'Meno', 'Euthyphro', 'Thrasymachus', 'Glaucon', 'Adeimantus'],
                    premise1: 'All humans desire what is genuinely good for them.',
                    premise2: 'If someone pursues what is harmful, they must not recognize it as harmful.',
                    conclusion: 'Therefore, wrongdoing is a form of ignorance, not deliberate evil.',
                    objection: 'Some people knowingly pursue harmful pleasures despite understanding the consequences.',
                    response: 'True knowledge of harm would necessarily prevent pursuit; what appears as knowledge may be mere belief.',
                    keyTerms: 'virtue, knowledge, piety, justice, wisdom, excellence (arete)',
                    textualReference: 'Meno 77b-78b, Protagoras 352-358',
                    notes: 'Consider: logical validity of argument, strength of premises, historical context, counterexamples from lived experience, implications for ethics and epistemology.'
                },
                sales: {
                    name: ['Enterprise Cloud Migration', 'SaaS Platform Expansion', 'Strategic Partnership Deal', 'Fortune 500 Account', 'Multi-Year Service Agreement', 'Technology Integration Project'],
                    description: 'High-value opportunity requiring executive engagement and multi-stakeholder alignment. Key success factors: clear ROI demonstration, competitive differentiation, and relationship-building with economic buyer.',
                    leadSource: 'Inbound marketing, industry conference referral, or strategic partner introduction',
                    contactPerson: 'VP of IT, CFO, or Chief Digital Officer',
                    competitorInfo: 'Competing against 2-3 established vendors. Differentiation: superior support, proven ROI, and industry-specific features.',
                    notes: 'Key considerations: budget approval timing, decision-making process, technical evaluation criteria, procurement requirements, champion identification, stakeholder mapping.'
                },
                thesis: {
                    name: ['Literature Review', 'Theoretical Framework', 'Methodology Design', 'Data Analysis', 'Results Interpretation', 'Discussion of Findings', 'Limitations & Future Research'],
                    description: 'Critical analysis of existing scholarship establishing theoretical foundation for research. Synthesize major debates, identify gaps in literature, and position current study within academic discourse.',
                    keyArgument: 'Previous research has overlooked [specific aspect], creating need for [your contribution]. This study addresses gap through [your approach].',
                    citations: 'Smith (2020), Johnson & Lee (2019), Martinez et al. (2018), Chen (2021)',
                    evidenceType: 'Mixed: quantitative data analysis combined with qualitative case studies',
                    notes: 'Key considerations: citation completeness, argument coherence, gap identification, methodological rigor, contribution to field, clarity of research questions.'
                },
                roadmap: {
                    name: ['User Authentication V2', 'Mobile App Redesign', 'API Performance Optimization', 'Analytics Dashboard', 'Third-Party Integration', 'Search Functionality'],
                    description: 'User-facing feature delivering measurable business value. Requires cross-functional coordination between product, engineering, and design. Success metrics defined upfront.',
                    userImpact: 'High - affects 80% of active users',
                    technicalRisk: 'Medium - depends on third-party API stability',
                    engineeringEstimate: '2 sprints (4 weeks)',
                    featureFlag: 'feature_new_search_v2',
                    notes: 'Key considerations: user testing requirements, performance benchmarks, rollout strategy, rollback plan, monitoring and alerting, documentation needs.'
                },
                prompting: {
                    name: ['Customer Support Agent', 'Code Reviewer with CoT', 'RAG Query Handler', 'Content Generator', 'Multi-Agent Router', 'Safety Classifier', 'Summarizer with Examples', 'Function Calling Orchestrator'],
                    description: 'Production prompt engineered using OpenAI/Anthropic best practices. Clear role definition, task breakdown, few-shot examples, output format specification, and evaluation criteria. Optimized for consistency and reliability.',
                    systemPrompt: 'You are an expert customer support agent for a SaaS platform. Your goal is to resolve customer issues quickly while maintaining a friendly, professional tone. Always prioritize customer satisfaction. If you cannot resolve an issue, escalate appropriately with clear context.',
                    userPromptTemplate: 'A customer has reported the following issue:\n\n<customer_issue>\n{{issue}}\n</customer_issue>\n\n<context>\nAccount: {{account_tier}}\nPrevious tickets: {{ticket_history}}\n</context>\n\nAnalyze the issue and provide: 1) Root cause, 2) Resolution steps, 3) Prevention advice.',
                    fewShotExamples: '<examples>\n<example>\n<user>Login broken after password reset</user>\n<assistant>Root cause: Session cache not cleared. Resolution: Clear browser cache or wait 5 minutes for auto-refresh. Prevention: Use incognito mode during password changes.</assistant>\n</example>\n</examples>',
                    structuralTags: '<thinking>\nAnalyze issue type and severity\n</thinking>\n\n<answer>\nProvide structured response\n</answer>',
                    assistantPrefill: 'Here is my analysis of the customer issue:',
                    chainOfThought: 'Think step by step: First identify the symptom, then trace back to root cause, then propose the minimal effective solution.',
                    outputFormat: 'Use this structure:\n**Root Cause:** [one sentence]\n**Resolution:** [numbered steps]\n**Prevention:** [actionable advice]',
                    modelTarget: 'Claude 3.5 Sonnet',
                    temperature: 0.3,
                    maxTokens: 1500,
                    testResults: 'Golden set: 94% accuracy on 200 support tickets\nAvg latency: 1.8s\nCost: $0.025 per call\nCustomer satisfaction: 4.7/5',
                    toolDefinitions: '{\n  "escalate_ticket": {\n    "description": "Escalate to human agent",\n    "parameters": {"reason": "string", "priority": "high|medium|low"}\n  }\n}',
                    agentWorkflow: 'Single agent (support responder)\nâ†’ Optionally calls escalate_ticket function\nâ†’ Human agent takes over if escalated',
                    contextManagement: 'Sliding window: keep last 6 messages (3 turns)\nCompress older history with summarization\nToken budget: 8K context, 1.5K completion',
                    promptInjectionDefense: 'Use XML tags to separate user input: <customer_issue>{{untrusted}}</customer_issue>\nValidate output doesn\'t leak system prompt\nMonitor for jailbreak patterns',
                    iterationNotes: 'v1: Too verbose, 350 tokens avg\nv2: Added output format, reduced to 180 tokens\nv3: Few-shot examples improved consistency to 94%\nv4: Lowered temp from 0.7â†’0.3 for more deterministic responses',
                    notes: 'OpenAI/Anthropic best practices applied:\n- Clear system role (Anthropic: system parameter)\n- XML tags for structure (Anthropic recommendation)\n- Few-shot examples in <examples> tags\n- Assistant prefill to guide tone (Claude-specific)\n- Chain-of-thought instruction for reasoning\n- Explicit output format\n- Prompt injection defense with delimiters\n- Golden test set for validation\n- Iterative refinement based on metrics'
                },
                book: {
                    name: ['Opening Scene', 'Character Introduction', 'Rising Action', 'Climactic Confrontation', 'Resolution', 'Twist Reveal', 'Emotional Payoff', 'Transition Chapter'],
                    description: 'Narrative chapter advancing plot through character development, conflict escalation, or thematic exploration. Balance dialogue, action, and description. Maintain pacing and reader engagement.',
                    wordCount: 3500,
                    targetWordCount: 4000,
                    draftStatus: 'First Draft',
                    povCharacter: 'Sarah Chen (protagonist)',
                    sceneSetting: 'Downtown coffee shop, early morning, rain outside',
                    plotFunction: 'Establishes protagonist motivation and introduces central conflict',
                    notes: 'Key considerations: POV consistency, show vs tell balance, scene vs sequel structure, sensory details, dialogue authenticity, pacing variation, emotional beats, foreshadowing.'
                },
                film: {
                    name: ['Opening Establishing Shot', 'Character Introduction', 'Emotional Dialogue', 'Action Chase Sequence', 'Atmospheric Transition', 'Climactic Confrontation', 'Dream/Memory Sequence', 'Final Resolution'],
                    description: 'AI-generated video scene created through detailed text-to-video prompting. Specify camera movement, lighting, mood, action, and visual style. Iterate on prompt wording for best results. Consider continuity across shots.',
                    aiPlatform: 'Sora (OpenAI)',
                    videoPrompt: 'A cinematic close-up shot slowly pulling back to reveal a woman in her 30s standing at a rain-streaked window overlooking a neon-lit city at night. Soft blue and purple lighting from the city illuminates her contemplative expression. Camera movement: slow dolly back. Mood: melancholic, cyberpunk aesthetic. Shot on 35mm film, shallow depth of field, bokeh lights in background.',
                    visualStyle: 'Cinematic',
                    duration: '10 seconds',
                    aspectRatio: '16:9 (Widescreen)',
                    cameraMovement: 'Dolly Out',
                    motionIntensity: 'Subtle',
                    lightingMood: 'Neon',
                    iterationNotes: 'Best practices: Be extremely specific about camera movement and speed. Mention lighting sources explicitly. Use cinematography terms (bokeh, depth of field, shot types). Reference film stock or camera models for aesthetic cues. Specify exact actions and their duration. Include mood/emotion words. Test multiple aspect ratios - some models handle certain ratios better. Start with shorter durations for complex scenes. Use "slow", "gradual", "subtle" for smoother motion.',
                    notes: 'Key considerations: Prompt engineering (specificity vs brevity), continuity between shots, aspect ratio consistency, motion artifacts detection, prompt variations for A/B testing, platform-specific strengths (Sora: physics/realism, Veo: motion control, Runway: speed), generation cost budgeting, style consistency across scenes, temporal coherence for extended clips, copyright/likeness considerations.'
                },
                course: {
                    name: ['Introduction to Topic', 'Foundational Concepts', 'Hands-On Lab Exercise', 'Case Study Analysis', 'Group Discussion', 'Skill Application Project', 'Assessment', 'Review Session'],
                    description: 'Instructional session designed to build student knowledge and skills through active learning. Combines lecture, practice, and assessment. Aligned with course learning objectives.',
                    learningObjectives: 'Students will be able to: 1) Define key concepts, 2) Apply techniques to novel problems, 3) Analyze real-world examples, 4) Evaluate trade-offs',
                    duration: '90 minutes',
                    difficultyLevel: 'Intermediate',
                    prerequisites: 'Completion of Module 2, basic programming knowledge, familiarity with data structures',
                    assessmentType: 'Quiz',
                    resourcesNeeded: 'Textbook Chapter 5, online simulation tool, practice dataset, reference handout',
                    homework: 'Complete problem set 4 (problems 1-10), read Chapter 6, prepare discussion questions',
                    notes: 'Key considerations: accessibility accommodations, engagement strategies, timing flexibility, technology backup plans, formative assessment checkpoints, inclusive pedagogy, active learning techniques.'
                },
                strategic: {
                    name: ['Digital Transformation Initiative', 'Market Expansion Strategy', 'Operational Excellence Program', 'Customer Experience Overhaul', 'Innovation Portfolio', 'Risk Mitigation Plan', 'Sustainability Initiative'],
                    description: 'Strategic initiative aligned with organizational priorities. Requires executive sponsorship, cross-functional resources, and measurable outcomes. Board-level visibility and quarterly review cadence.',
                    investment: 2500000,
                    keyMetric: 'Revenue growth in target segment',
                    targetValue: '25% year-over-year increase',
                    responsibleExecutive: 'Chief Strategy Officer',
                    strategicTheme: 'Growth',
                    riskLevel: 'Medium',
                    notes: 'Key considerations: stakeholder alignment, resource allocation, change management, governance structure, milestone tracking, competitive response, market timing, regulatory compliance.'
                },
                generic: {
                    name: {
                        land: ['Land Acquisition & Title', 'Site Purchase & Legal', 'Property Option Agreement'],
                        engineering: ['Engineering Design Services', 'Technical Specification Development', 'System Architecture'],
                        equipment: ['Equipment Procurement', 'Hardware Purchase & Installation', 'Capital Equipment'],
                        infrastructure: ['Infrastructure Development', 'Site Preparation', 'Facility Build-Out'],
                        corporate: ['Corporate Administration', 'Business Operations', 'Management Overhead'],
                        professional: ['Professional Services', 'Consulting & Advisory', 'Expert Services'],
                        contingency: ['Contingency Reserve', 'Risk Mitigation Fund', 'Budget Reserve']
                    },
                    description: {
                        equipment: 'Procurement of capital equipment with extended lead times. Requires vendor evaluation, competitive bidding, and early commitment to secure production slots.',
                        default: 'Detailed specification of deliverables, timeline, dependencies, and success criteria. Coordinate with stakeholders and manage risks proactively.'
                    },
                    cost: { p0: [50000, 100000, 250000], p1: [500000, 1000000, 2000000], p2: [25000000, 50000000, 100000000] },
                    alternateSource: 'Secondary vendors, in-house capability, strategic partnerships, or alternative procurement strategies',
                    leadTime: { p0: '2-8 weeks', p1: '3-6 months', p2: '12-24 months' },
                    notes: 'Key considerations: timeline, budget allocation, vendor selection, risk mitigation, quality assurance, regulatory compliance.'
                }
            };

            // PATTERN-AWARE SUGGESTION GENERATION - Each pattern acts as subject expert
            const patternKey = currentPattern;
            const patternData = patternSuggestions[patternKey] || patternSuggestions.generic;

            // Handle pattern-specific fields (philosophy, sales, thesis, etc.)
            if (patternData[fieldType]) {
                const suggestion = patternData[fieldType];

                // If array, pick random option
                if (Array.isArray(suggestion)) {
                    return suggestion[Math.floor(Math.random() * suggestion.length)];
                }

                // If string, return directly
                return suggestion;
            }

            // Common fields handled for all patterns
            if (fieldType === 'name') {
                if (patternKey === 'generic' && patternData.name[itemType]) {
                    const options = patternData.name[itemType];
                    return options[Math.floor(Math.random() * options.length)];
                }
                return `New ${pattern.levels.item || 'Item'}`;
            }

            if (fieldType === 'description') {
                if (patternKey === 'generic' && itemType) {
                    return patternData.description[itemType] || patternData.description.default;
                }
                return patternData.description || 'Enter detailed description here...';
            }

            if (fieldType === 'notes') {
                return patternData.notes || 'Key considerations and implementation notes...';
            }

            if (fieldType === 'icon') {
                const iconMap = {
                    philosophy: ['ğŸ¤”', 'ğŸ’­', 'ğŸ“œ', 'ğŸ›ï¸', 'âš–ï¸'],
                    sales: ['ğŸ’¼', 'ğŸ’°', 'ğŸ“Š', 'ğŸ¤', 'ğŸ“ˆ'],
                    thesis: ['ğŸ“š', 'ğŸ“', 'ğŸ“', 'ğŸ“–', 'âœï¸'],
                    roadmap: ['ğŸš€', 'âš¡', 'ğŸ”§', 'ğŸ’¡', 'ğŸ¯'],
                    prompting: ['ğŸ§ ', 'ğŸ¤–', 'âš™ï¸', 'ğŸ”®', 'ğŸ’¬'],
                    book: ['ğŸ“–', 'âœï¸', 'ğŸ“š', 'ğŸ–‹ï¸', 'ğŸ“'],
                    film: ['ğŸ¬', 'ğŸ¥', 'ğŸï¸', 'ğŸ­', 'ğŸ“¹'],
                    course: ['ğŸ“–', 'ğŸ“', 'ğŸ“š', 'ğŸ‘¨â€ğŸ«', 'ğŸ“'],
                    strategic: ['ğŸ¯', 'ğŸ“Š', 'ğŸ›ï¸', 'ğŸ’¼', 'ğŸ—ºï¸'],
                    generic: ['ğŸ“¦', 'âš™ï¸', 'ğŸ”§', 'ğŸ“Š', 'ğŸ’¼']
                };
                const icons = iconMap[patternKey] || iconMap.generic;
                return icons[Math.floor(Math.random() * icons.length)];
            }

            // Generic pattern: cost and leadTime (other patterns don't use these)
            if (fieldType === 'cost' && patternKey === 'generic') {
                const similarItems = existingItems.filter(item => item.itemType === itemType && item.cost > 0);
                if (similarItems.length > 0) {
                    const costs = similarItems.map(i => i.cost).sort((a, b) => a - b);
                    const median = costs[Math.floor(costs.length / 2)];
                    return Math.round(median * (0.9 + Math.random() * 0.2));
                }
                const costRanges = patternData.cost[phase] || patternData.cost.p1;
                return costRanges[Math.floor(Math.random() * costRanges.length)];
            }

            if (fieldType === 'leadTime' && patternKey === 'generic') {
                return patternData.leadTime[phase] || patternData.leadTime.p1;
            }

            if (fieldType === 'alternateSource' && patternKey === 'generic') {
                return patternData.alternateSource;
            }

            return '';
        }

        // Add AI suggestion capability to text fields
        function enableAISuggestionsOnField(fieldElement, fieldType, itemContext) {
            fieldElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Check if API key available for AI mode
                const hasAPIKey = getLocalAPIKey();
                const modeLabel = hasAPIKey ? 'âœ¨ AI Suggest' : 'ğŸ’¡ Quick Suggest';
                const modeDesc = hasAPIKey ? 'AI-powered contextual suggestion' : 'Template-based suggestion (add API key for AI mode)';

                // Show smart suggestion context menu
                const menu = document.getElementById('context-menu');
                menu.innerHTML = `
                    <div class="context-item" id="ai-suggest-field">${modeLabel}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" style="font-size: 11px; color: var(--text-secondary); cursor: default; padding: 8px 14px;" onmouseover="this.style.background='transparent'">${modeDesc}</div>
                `;
                menu.style.display = 'block';

                // Position menu
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';

                // Smart positioning to avoid going off screen
                const menuRect = menu.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                let finalX = e.pageX;
                let finalY = e.pageY;

                if (menuRect.right > viewportWidth) {
                    finalX = viewportWidth - menuRect.width - 10;
                }
                if (menuRect.bottom > viewportHeight) {
                    finalY = viewportHeight - menuRect.height - 10;
                }
                if (finalX < 10) finalX = 10;
                if (finalY < 10) finalY = 10;

                menu.style.left = finalX + 'px';
                menu.style.top = finalY + 'px';

                // Attach AI suggest handler (ASYNC)
                const aiSuggestBtn = document.getElementById('ai-suggest-field');
                aiSuggestBtn.onclick = async () => {
                    console.log('ğŸ” Smart Suggest clicked:', fieldType, hasAPIKey ? 'AI mode' : 'Quick mode');
                    menu.style.display = 'none';

                    // Get current context including notes field value
                    const currentContext = { ...itemContext };
                    const notesField = document.getElementById('edit-notes');
                    if (notesField) {
                        currentContext.notes = notesField.value;
                    }

                    console.log('ğŸ“‹ Context:', currentContext);

                    // Show loading state
                    const originalValue = fieldElement.value;
                    const originalPlaceholder = fieldElement.placeholder;
                    fieldElement.value = '';
                    fieldElement.placeholder = hasAPIKey ? 'âœ¨ AI is thinking...' : 'ğŸ’¡ Generating suggestion...';
                    fieldElement.style.transition = 'all 0.3s';
                    fieldElement.style.background = 'rgba(99, 102, 241, 0.1)';
                    fieldElement.disabled = true;

                    try {
                        console.log('â³ Calling generateAISuggestion...');
                        // Call AI suggestion (async)
                        const suggestion = await generateAISuggestion(fieldType, currentContext);
                        console.log('âœ… Got suggestion:', suggestion);

                        // Apply suggestion
                        fieldElement.value = suggestion;

                        // Trigger input event for any listeners
                        fieldElement.dispatchEvent(new Event('input', { bubbles: true }));

                        // Success feedback
                        fieldElement.style.background = 'rgba(0, 166, 125, 0.15)';
                        setTimeout(() => {
                            fieldElement.style.background = 'var(--bg)';
                        }, 600);

                    } catch (error) {
                        console.error('âŒ Smart Suggest error:', error);
                        console.error('Error stack:', error.stack);

                        // Restore original value on error
                        fieldElement.value = originalValue;

                        // Error feedback
                        fieldElement.style.background = 'rgba(239, 68, 68, 0.1)';
                        setTimeout(() => {
                            fieldElement.style.background = 'var(--bg)';
                        }, 600);

                        // Show error to user
                        alert(`Smart Suggest Error: ${error.message}\n\nCheck browser console (F12) for details.`);
                    } finally {
                        console.log('ğŸ”„ Re-enabling field');
                        // Re-enable field
                        fieldElement.disabled = false;
                        fieldElement.placeholder = originalPlaceholder;
                    }
                };
            });
        }

        // Helper function to generate dynamic field HTML based on pattern
        function generateFieldHTML(fieldKey, fieldConfig, node) {
            const value = node[fieldKey] || '';
            const fieldId = `edit-${fieldKey}`;

            let inputHTML = '';

            if (fieldConfig.type === 'select') {
                const options = fieldConfig.options.map(opt =>
                    `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`
                ).join('');
                inputHTML = `<select id="${fieldId}">${options}</select>`;
            } else if (fieldConfig.type === 'textarea') {
                inputHTML = `<textarea id="${fieldId}" placeholder="${fieldConfig.placeholder || ''}" style="min-height: 80px;">${value}</textarea>`;
            } else if (fieldConfig.type === 'number') {
                const min = fieldConfig.min !== undefined ? `min="${fieldConfig.min}"` : '';
                const max = fieldConfig.max !== undefined ? `max="${fieldConfig.max}"` : '';
                const step = fieldConfig.step !== undefined ? `step="${fieldConfig.step}"` : '';
                inputHTML = `<input type="number" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" ${min} ${max} ${step} />`;
            } else if (fieldConfig.type === 'date') {
                inputHTML = `<input type="date" id="${fieldId}" value="${value}" />`;
            } else {
                // default to text
                inputHTML = `<input type="text" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" />`;
            }

            return `
                <div class="form-group">
                    <label>${fieldConfig.label} <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ğŸ’¡)</span></label>
                    ${inputHTML}
                    ${fieldConfig.helpText ? `<p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">${fieldConfig.helpText}</p>` : ''}
                </div>
            `;
        }

        function handleEdit() {
            if (!activeNode) return;

            // Root node - open Project Settings modal (Build 260)
            if (activeNode.type === 'root') {
                openProjectSettingsModal();
                return;
            }

            // Simple name editing for phase nodes
            if (activeNode.type === 'phase') {
                const labels = getPatternLabels();
                const newName = prompt(`Enter new ${labels.phase} name:`, activeNode.name);

                if (newName && newName !== activeNode.name) {
                    activeNode.name = newName;
                    render();
                }
                return;
            }

            // BUILD 388: Full edit modal for any non-root/non-phase node (items, subtasks, subItems, deep nodes)
            // This enables editing at any depth in the tree
            if (activeNode.type !== 'root' && activeNode.type !== 'phase') {
                const modal = document.getElementById('edit-modal');
                const body = document.getElementById('edit-modal-body');

                // Get all items from all phases for dependency selection
                function getAllItems(node, items = [], phaseName = '') {
                    if (node.phase !== undefined) phaseName = `Phase ${node.phase}`;
                    if (node.items) {
                        node.items.forEach(item => {
                            items.push({ ...item, phaseName });
                        });
                    }
                    if (node.children) {
                        node.children.forEach(child => getAllItems(child, items, phaseName));
                    }
                    return items;
                }

                const allItems = getAllItems(capexTree).filter(item => item.id !== activeNode.id);

                // Build dependency checkboxes
                const currentDeps = activeNode.dependencies || [];
                const depsHtml = allItems.map(item => {
                    const checked = currentDeps.includes(item.id) ? 'checked' : '';
                    return `
                        <label style="display: flex; align-items: center; gap: 10px; padding: 8px 10px; cursor: pointer; font-weight: normal; text-transform: none; letter-spacing: normal; border-radius: 6px; transition: background 0.2s; margin-bottom: 4px;" onmouseover="this.style.background='var(--card-bg-light)'" onmouseout="this.style.background='transparent'">
                            <input type="checkbox" class="dep-checkbox" value="${item.id}" ${checked} style="flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; accent-color: var(--treeplex-primary);" />
                            <span style="flex: 1; display: flex; align-items: center; gap: 8px; font-size: 14px;">
                                <span style="font-size: 18px; flex-shrink: 0;">${item.icon || 'ğŸ“„'}</span>
                                <span style="flex: 1; color: var(--text-primary);">${item.name}</span>
                                <span style="color: var(--text-secondary); font-size: 11px; padding: 2px 8px; background: var(--card-bg); border-radius: 4px; border: 1px solid var(--border);">${item.phaseName}</span>
                            </span>
                        </label>
                    `;
                }).join('');

                // Get current pattern and its fields configuration
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                // Check if PM tracking should be shown
                const showTracking = fields.includeTracking &&
                                    fields.trackingFor &&
                                    fields.trackingFor.includes(activeNode.type);

                // Build field HTML
                let fieldsHTML = '';

                // 1. PM Tracking Section (conditional)
                if (showTracking) {
                    // Calculate RAG status color
                    const ragStatus = activeNode.pmRAGStatus || 'Amber';
                    const ragColors = {
                        'Green': '#22C55E',
                        'Amber': '#F59E0B',
                        'Red': '#EF4444'
                    };
                    const ragColor = ragColors[ragStatus] || ragColors.Amber;

                    // Calculate time tracking metrics
                    const estHours = activeNode.pmEstimatedHours || 0;
                    const actHours = activeNode.pmActualHours || 0;
                    const remHours = activeNode.pmRemainingHours || estHours - actHours;
                    const timeProgress = estHours > 0 ? Math.min(100, (actHours / estHours) * 100) : 0;
                    const isOverBudget = actHours > estHours;

                    fieldsHTML += `
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--treeplex-primary);">ğŸ¯ Project Management</h3>

                        <!-- PM Infographic Dashboard -->
                        <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(99, 102, 241, 0.05) 100%); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 16px;">
                                <!-- RAG Status Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">RAG Status</div>
                                    <div style="width: 48px; height: 48px; border-radius: 50%; background: ${ragColor}; margin: 0 auto; box-shadow: 0 4px 12px ${ragColor}40, inset 0 2px 4px rgba(255,255,255,0.3);"></div>
                                    <div style="font-size: 13px; font-weight: 600; margin-top: 8px; color: ${ragColor};">${ragStatus}</div>
                                </div>

                                <!-- Progress Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Progress</div>
                                    <div style="position: relative; width: 64px; height: 64px; margin: 0 auto;">
                                        <svg width="64" height="64" style="transform: rotate(-90deg);">
                                            <circle cx="32" cy="32" r="28" stroke="var(--border)" stroke-width="6" fill="none"></circle>
                                            <circle cx="32" cy="32" r="28" stroke="var(--treeplex-primary)" stroke-width="6" fill="none"
                                                stroke-dasharray="${(activeNode.pmProgress || 0) * 1.759} 175.9"
                                                stroke-linecap="round"
                                                style="transition: stroke-dasharray 0.3s ease;"></circle>
                                        </svg>
                                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 16px; font-weight: 700; color: var(--treeplex-primary);">${activeNode.pmProgress || 0}%</div>
                                    </div>
                                </div>

                                <!-- Priority Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Priority</div>
                                    <div style="margin-top: 4px;">
                                        ${(() => {
                                            const priority = activeNode.pmPriority || 'Medium';
                                            const priorityIcons = {
                                                'Low': 'ğŸŸ¢',
                                                'Medium': 'ğŸŸ¡',
                                                'High': 'ğŸŸ ',
                                                'Critical': 'ğŸ”´'
                                            };
                                            return `<div style="font-size: 32px; margin: 4px 0;">${priorityIcons[priority] || priorityIcons.Medium}</div>
                                                   <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${priority}</div>`;
                                        })()}
                                    </div>
                                </div>
                            </div>

                            <!-- Time Tracking Visualization -->
                            ${estHours > 0 ? `
                            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
                                <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Time Tracking</div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 12px;">
                                    <span>â±ï¸ Estimated: <strong>${estHours}h</strong></span>
                                    <span>âœ… Actual: <strong style="color: ${isOverBudget ? '#EF4444' : '#22C55E'};">${actHours}h</strong></span>
                                    <span>â³ Remaining: <strong>${remHours}h</strong></span>
                                </div>
                                <div style="width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
                                    <div style="width: ${timeProgress}%; height: 100%; background: ${isOverBudget ? '#EF4444' : '#22C55E'}; transition: width 0.3s ease;"></div>
                                </div>
                                ${isOverBudget ? `<div style="font-size: 11px; color: #EF4444; margin-top: 4px; font-weight: 600;">âš ï¸ Over Budget by ${actHours - estHours}h</div>` : ''}
                            </div>
                            ` : ''}
                        </div>

                        <!-- PM Form Fields -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                            <div class="form-group">
                                <label>Status</label>
                                <select id="edit-pm-status">
                                    <option value="To Do" ${activeNode.pmStatus === 'To Do' ? 'selected' : ''}>To Do</option>
                                    <option value="In Progress" ${activeNode.pmStatus === 'In Progress' ? 'selected' : ''}>In Progress</option>
                                    <option value="Completed" ${activeNode.pmStatus === 'Completed' ? 'selected' : ''}>Completed</option>
                                    <option value="Blocked" ${activeNode.pmStatus === 'Blocked' ? 'selected' : ''}>Blocked</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>RAG Status ğŸš¦</label>
                                <select id="edit-pm-rag-status">
                                    <option value="Green" ${ragStatus === 'Green' ? 'selected' : ''}>ğŸŸ¢ Green - On Track</option>
                                    <option value="Amber" ${ragStatus === 'Amber' ? 'selected' : ''}>ğŸŸ¡ Amber - At Risk</option>
                                    <option value="Red" ${ragStatus === 'Red' ? 'selected' : ''}>ğŸ”´ Red - Critical</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Owner Email ğŸ‘¤</label>
                            <input type="email" id="edit-pm-owner-email" value="${activeNode.pmOwnerEmail || activeNode.pmAssignee || ''}" placeholder="owner@company.com" />
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 4px; font-style: italic;">ğŸ“§ Email for collaborative pipeline reviews</p>
                        </div>
                        <div class="form-group">
                            <label>Progress (%)</label>
                            <input type="number" id="edit-pm-progress" value="${activeNode.pmProgress || 0}" min="0" max="100" step="5" />
                        </div>
                        <div class="form-group">
                            <label>Priority</label>
                            <select id="edit-pm-priority">
                                <option value="Low" ${activeNode.pmPriority === 'Low' ? 'selected' : ''}>Low</option>
                                <option value="Medium" ${activeNode.pmPriority === 'Medium' ? 'selected' : ''}>Medium</option>
                                <option value="High" ${activeNode.pmPriority === 'High' ? 'selected' : ''}>High</option>
                                <option value="Critical" ${activeNode.pmPriority === 'Critical' ? 'selected' : ''}>Critical</option>
                            </select>
                        </div>

                        <!-- Time Management Fields -->
                        <div style="margin-top: 16px; padding: 16px; background: rgba(99, 102, 241, 0.05); border: 1px dashed var(--border); border-radius: 8px;">
                            <h4 style="font-size: 14px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">â±ï¸ Time Management</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Estimated (hours)</label>
                                    <input type="number" id="edit-pm-estimated-hours" value="${estHours}" min="0" step="0.5" placeholder="0" />
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Actual (hours)</label>
                                    <input type="number" id="edit-pm-actual-hours" value="${actHours}" min="0" step="0.5" placeholder="0" />
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Remaining (hours)</label>
                                    <input type="number" id="edit-pm-remaining-hours" value="${remHours}" min="0" step="0.5" placeholder="Auto" />
                                </div>
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">ğŸ’¡ Remaining auto-calculates if left empty (Estimated - Actual)</p>
                        </div>
                        <div class="form-group">
                            <label>Start Date</label>
                            <input type="date" id="edit-pm-start-date" value="${activeNode.pmStartDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>Due Date</label>
                            <input type="date" id="edit-pm-due-date" value="${activeNode.pmDueDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>ğŸš§ Blocking Issue <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ğŸ’¡)</span></label>
                            <textarea id="edit-pm-blocking-issue" style="min-height: 60px;" placeholder="What's preventing progress?">${activeNode.pmBlockingIssue || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>â¡ï¸ Next Steps <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ğŸ’¡)</span></label>
                            <textarea id="edit-pm-next-steps" style="min-height: 80px;" placeholder="Specific actions needed...">${activeNode.pmNextSteps || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>PM Notes</label>
                            <textarea id="edit-pm-notes" style="min-height: 80px;" placeholder="Task-specific notes, blockers, action items...">${activeNode.pmNotes || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>ğŸ“ Latest Updates</label>
                            <div style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 8px; max-height: 200px; overflow-y: auto;">
                                ${activeNode.pmUpdates && activeNode.pmUpdates.length > 0 ? activeNode.pmUpdates.map((update, idx) => `
                                    <div style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border);">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">${new Date(update.timestamp).toLocaleString()}</div>
                                        <div style="font-size: 13px; line-height: 1.5;">${update.text}</div>
                                        <button onclick="window.deleteUpdate(${idx})" style="margin-top: 6px; padding: 2px 8px; font-size: 10px; background: rgba(239, 68, 68, 0.2); border: 1px solid #EF4444; border-radius: 4px; color: #EF4444; cursor: pointer;">Delete</button>
                                    </div>
                                `).join('') : '<p style="color: var(--text-secondary); font-size: 13px; text-align: center; padding: 20px;">No updates yet</p>'}
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <textarea id="edit-pm-new-update" style="flex: 1; min-height: 60px;" placeholder="Add a new update..."></textarea>
                                <button onclick="window.addUpdate()" style="padding: 8px 16px; background: var(--treeplex-primary); border: none; border-radius: 6px; color: white; font-weight: 600; cursor: pointer; white-space: nowrap;">Add Update</button>
                            </div>
                        </div>
                        <hr style="margin: 24px 0; border: none; border-top: 1px solid var(--border);" />
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--text-secondary);">Details</h3>
                    `;
                }

                // 2. Universal Fields (always shown)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Name <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ğŸ’¡)</span></label>
                        <input type="text" id="edit-name" value="${activeNode.name || ''}" />
                    </div>
                    <div class="form-group">
                        <label>Description <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ğŸ’¡)</span></label>
                        <textarea id="edit-description">${activeNode.description || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label>Icon <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ğŸ’¡)</span></label>
                        <input type="text" id="edit-icon" value="${activeNode.icon || ''}" maxlength="2" />
                    </div>
                    <div class="form-group">
                        <label>Type</label>
                        <select id="edit-type">
                            ${PATTERNS[currentPattern].types.map(type =>
                                `<option value="${type.value}" ${activeNode.itemType === type.value ? 'selected' : ''}>${type.label}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;

                // 3. Collaboration Section (universal - prominent placement) - Build 262: Dynamic team buttons
                fieldsHTML += `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 12px; padding: 16px; margin: 16px 0;">
                        <h3 style="font-size: 14px; font-weight: 600; margin: 0 0 12px 0; color: var(--treeplex-primary);">ğŸ‘¥ Collaboration</h3>
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label style="font-size: 12px;">ğŸ‘¤ Contributor</label>
                            <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                                <input type="text" id="edit-contributor" style="flex: 1; min-width: 120px; padding: 8px 12px;" placeholder="Your name" value="${activeNode.contributor || ''}" />
                                ${generateContributorButtons()}
                            </div>
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label style="font-size: 12px;">ğŸ’¬ Comments for Collaborators</label>
                            <textarea id="edit-collab-comments" style="min-height: 60px; padding: 8px 12px;" placeholder="Leave notes, questions, or feedback for collaborators...">${activeNode.collabComments || ''}</textarea>
                        </div>
                    </div>
                `;

                // 4. Pattern-Specific Custom Fields (dynamic)
                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }
                    const fieldConfig = fields[fieldKey];
                    fieldsHTML += generateFieldHTML(fieldKey, fieldConfig, activeNode);
                });

                // 5. Notes (universal)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Notes <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ğŸ’¡)</span></label>
                        <textarea id="edit-notes" style="min-height: 100px;" placeholder="Additional notes...">${activeNode.notes || ''}</textarea>
                    </div>
                `;

                // 6. Dependencies (conditional)
                if (fields.includeDependencies) {
                    fieldsHTML += `
                        <div class="form-group">
                            <label>Dependencies</label>
                            <div style="max-height: 240px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 6px; background: var(--bg);">
                                ${depsHtml || '<p style="color: var(--text-secondary); font-size: 13px; margin: 0; padding: 10px; text-align: center;">No other items available</p>'}
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">âœ“ Select prerequisite items that must be completed first</p>
                        </div>
                    `;
                }

                body.innerHTML = fieldsHTML;

                modal.style.display = 'flex';

                // Enable AI suggestions on text fields after modal is displayed
                setTimeout(() => {
                    // Universal fields
                    const nameField = document.getElementById('edit-name');
                    const descField = document.getElementById('edit-description');
                    const iconField = document.getElementById('edit-icon');
                    const notesField = document.getElementById('edit-notes');

                    if (nameField) enableAISuggestionsOnField(nameField, 'name', activeNode);
                    if (descField) enableAISuggestionsOnField(descField, 'description', activeNode);
                    if (iconField) enableAISuggestionsOnField(iconField, 'icon', activeNode);
                    if (notesField) enableAISuggestionsOnField(notesField, 'notes', activeNode);

                    // Pattern-specific fields (dynamic)
                    Object.keys(fields).forEach(fieldKey => {
                        if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                            return;
                        }
                        const fieldElement = document.getElementById(`edit-${fieldKey}`);
                        if (fieldElement) {
                            enableAISuggestionsOnField(fieldElement, fieldKey, activeNode);
                        }
                    });

                    // Enable AI suggestions for PM fields (conditional)
                    if (showTracking) {
                        const pmBlockingIssueField = document.getElementById('edit-pm-blocking-issue');
                        const pmNextStepsField = document.getElementById('edit-pm-next-steps');

                        if (pmBlockingIssueField) enableAISuggestionsOnField(pmBlockingIssueField, 'pmBlockingIssue', activeNode);
                        if (pmNextStepsField) enableAISuggestionsOnField(pmNextStepsField, 'pmNextSteps', activeNode);
                    }
                }, 50);
            }
        }

        function handleCreate() {
            if (activeNode && activeNode.type === 'phase') {
                // Save state for undo
                saveState(`Create item in ${activeNode.name}`);

                // Create new item in this phase
                const labels = getPatternLabels();
                const defaultType = PATTERNS[currentPattern].types[0].value;
                const newItem = {
                    id: `p${activeNode.phase}-${Date.now()}`,
                    name: `New ${labels.item}`,
                    description: 'Enter description',
                    cost: 0,
                    icon: 'ğŸ“¦',
                    itemType: defaultType,
                    type: 'item',
                    dependencies: [],
                    provenance: {
                        source: 'user',
                        timestamp: new Date().toISOString()
                    }
                };

                if (!activeNode.items) activeNode.items = [];
                activeNode.items.push(newItem);
                activeNode.expanded = true;
                render();
            }
        }

        function handleAddSubtask() {
            // Allow both items AND subtasks to have nested sub-tasks
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask')) {
                const labels = getPatternLabels();
                const isNestedSubtask = activeNode.type === 'subtask';
                const promptLabel = isNestedSubtask ? `nested ${labels.subtask}` : labels.subtask;

                // Prompt for sub-task name
                const subtaskName = prompt(`Enter ${promptLabel} name:`, `New ${isNestedSubtask ? 'Nested ' : ''}${labels.subtask}`);
                if (!subtaskName) return;

                // Save state for undo
                saveState(`Add subtask to ${activeNode.name}`);

                // Get today's date in YYYY-MM-DD format
                const today = new Date().toISOString().split('T')[0];

                // Create new sub-task with PM fields
                const newSubtask = {
                    id: `${activeNode.id}-sub-${Date.now()}`,
                    nodeGuid: generateNodeGuid(), // Atlas: stable identity
                    name: subtaskName,
                    description: 'Task description',
                    cost: 0,
                    icon: 'ğŸ“‹',
                    itemType: 'subtask',
                    type: 'subtask',
                    dependencies: [],
                    parentId: activeNode.id,
                    // Project Management fields
                    pmStatus: 'To Do',
                    pmAssignee: 'Unassigned',
                    pmStartDate: today,
                    pmDueDate: today,
                    pmProgress: 0,
                    pmPriority: 'Medium',
                    pmNotes: '',
                    pmBlockingIssue: '',
                    pmNextSteps: '',
                    pmUpdates: [],
                    // Initialize subItems for nested support
                    subItems: [],
                    // Provenance stamping
                    provenance: {
                        source: 'user',
                        timestamp: new Date().toISOString()
                    }
                };

                // Initialize subItems array if it doesn't exist
                if (!activeNode.subItems) activeNode.subItems = [];
                activeNode.subItems.push(newSubtask);

                // Mark parent as expanded to show sub-tasks
                activeNode.expanded = true;

                render();
                document.getElementById('context-menu').style.display = 'none';
            }
        }

        function handleDelete() {
            // Build 391: Extended to support phase deletion
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask' || activeNode.type === 'phase')) {
                const labels = getPatternLabels();
                let itemType, confirmMsg;

                if (activeNode.type === 'phase') {
                    itemType = labels.phase || 'phase';
                    const itemCount = activeNode.items ? activeNode.items.length : 0;
                    if (itemCount > 0) {
                        confirmMsg = `Delete "${activeNode.name}" ${itemType}?\n\nâš ï¸ This will also delete ${itemCount} item${itemCount > 1 ? 's' : ''} inside it.`;
                    } else {
                        confirmMsg = `Delete "${activeNode.name}" ${itemType}?`;
                    }
                } else {
                    itemType = activeNode.type === 'subtask' ? 'sub-task' : 'item';
                    confirmMsg = `Delete "${activeNode.name}" ${itemType}?`;
                }

                if (confirm(confirmMsg)) {
                    // Save state for undo
                    saveState(`Delete ${itemType}: ${activeNode.name}`);
                    if (activeNode.type === 'subtask') {
                        // Remove subtask from its parent item (supports nested subtasks)
                        function removeSubtaskRecursive(subtaskId, node = capexTree) {
                            // Check items in this node
                            if (node.items) {
                                for (let item of node.items) {
                                    if (item.subItems) {
                                        const index = item.subItems.findIndex(s => s.id === subtaskId);
                                        if (index !== -1) {
                                            item.subItems.splice(index, 1);
                                            return true;
                                        }
                                        // Check nested subtasks within subtasks
                                        for (let subtask of item.subItems) {
                                            if (removeFromSubItems(subtaskId, subtask)) return true;
                                        }
                                    }
                                }
                            }
                            // Check child phases
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeSubtaskRecursive(subtaskId, child)) return true;
                                }
                            }
                            return false;
                        }
                        // Helper to remove from nested subItems
                        function removeFromSubItems(subtaskId, parent) {
                            if (parent.subItems) {
                                const index = parent.subItems.findIndex(s => s.id === subtaskId);
                                if (index !== -1) {
                                    parent.subItems.splice(index, 1);
                                    return true;
                                }
                                // Recursively check deeper nesting
                                for (let subtask of parent.subItems) {
                                    if (removeFromSubItems(subtaskId, subtask)) return true;
                                }
                            }
                            return false;
                        }
                        removeSubtaskRecursive(activeNode.id);
                    } else if (activeNode.type === 'phase') {
                        // Build 391: Remove phase from root's children array
                        if (capexTree.children) {
                            const index = capexTree.children.findIndex(p => p.id === activeNode.id);
                            if (index !== -1) {
                                capexTree.children.splice(index, 1);
                                console.log(`ğŸ—‘ï¸ Deleted phase: ${activeNode.name}`);
                            }
                        }
                    } else {
                        // Find and remove the item from its parent phase
                        function removeItem(itemId, node = capexTree) {
                            if (node.items) {
                                const index = node.items.findIndex(i => i.id === itemId);
                                if (index !== -1) {
                                    node.items.splice(index, 1);
                                    return true;
                                }
                            }
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeItem(itemId, child)) return true;
                                }
                            }
                            return false;
                        }
                        removeItem(activeNode.id);
                    }
                    render();

                    // Trigger Firebase sync immediately after delete
                    if (window.pushTreeToFirebase) {
                        console.log('ğŸ”¥ Triggering Firebase sync after delete');
                        window.pushTreeToFirebase();
                    }

                    // Mark as changed for auto-save
                    if (window.treeManager && window.treeManager.markAsChanged) {
                        window.treeManager.markAsChanged();
                    }
                }
            }
        }

        // =============================================================================
        // BUILD 284: LOAD TREE DATA FUNCTION - Centralized tree loading
        // =============================================================================

        /**
         * Load tree data into capexTree and update UI
         * Used by JSON upload, version conflict resolution, and other loaders
         */
        function loadTreeData(data) {
            // BUILD 352: Exit 3D view before loading new tree data
            if (viewMode === '3d') {
                const toggle3DBtn = document.getElementById('toggle-3d-mode');
                if (toggle3DBtn) toggle3DBtn.click();
            }

            // Replace the tree data
            Object.assign(capexTree, data);

            // BUILD 572: Clear irrelevant bboxes from structured data imports
            // If _imageAnalysis is explicitly null, or if there's no source image but bboxes exist,
            // clear them to prevent confusing overlays from URL/JSON imports
            if (data._imageAnalysis === null ||
                (data._imageAnalysis && !data._imageAnalysis.sourceImage && !data._imageAnalysis.virtual)) {
                console.log('ğŸ§¹ Clearing irrelevant image analysis bboxes from structured import');
                delete capexTree._imageAnalysis;
                function clearBboxes(node) {
                    if (!node) return;
                    delete node._bbox;
                    delete node._confidence;
                    delete node._objectType;
                    (node.children || []).forEach(clearBboxes);
                    (node.items || []).forEach(clearBboxes);
                    (node.subtasks || []).forEach(clearBboxes);
                }
                clearBboxes(capexTree);
            }

            // BUILD 530: Restore pattern from loaded tree data
            if (data.pattern) {
                const patternKey = typeof data.pattern === 'string'
                    ? data.pattern
                    : (data.pattern.key || 'generic');

                if (PATTERNS[patternKey]) {
                    currentPattern = patternKey;
                    console.log(`ğŸ¨ Pattern restored from tree: ${patternKey}`);

                    // Update pattern selector UI
                    const patternSelect = document.getElementById('pattern-select');
                    if (patternSelect) {
                        patternSelect.value = patternKey;
                    }

                    // Handle custom pattern labels
                    if (patternKey === 'custom' && data.pattern.labels) {
                        customPatternNames = data.pattern.labels;
                    }

                    // Update AI button and sort dropdown
                    if (typeof updateAIButtonLabel === 'function') updateAIButtonLabel();
                    if (typeof updateSortDropdown === 'function') updateSortDropdown();
                }
            }

            // BUILD 387: Ensure root node has type="root" for editing support
            if (!capexTree.type) {
                capexTree.type = 'root';
            }

            // BUILD 507: Collapse phases on mobile for cleaner initial view
            const isMobileDevice = window.matchMedia('(max-width: 768px)').matches ||
                                   ('ontouchstart' in window && window.innerWidth <= 768);
            if (isMobileDevice && capexTree.children) {
                capexTree.children.forEach(phase => {
                    if (phase.expanded !== false) {
                        phase.expanded = false;  // Collapse phases on mobile
                    }
                });
                console.log('ğŸ“± Mobile detected: phases collapsed for cleaner view');
            }

            // Restore pattern if saved
            if (capexTree.pattern) {
                // Handle both string and object formats
                if (typeof capexTree.pattern === 'string') {
                    currentPattern = capexTree.pattern;
                } else if (capexTree.pattern.key) {
                    currentPattern = getPatternKey(capexTree.pattern);
                    if (currentPattern === 'custom' && capexTree.pattern.labels) {
                        customPatternNames = capexTree.pattern.labels;
                    }
                }

                const patternSelect = document.getElementById('pattern-select');
                if (patternSelect) {
                    patternSelect.value = currentPattern;
                }

                console.log('Pattern loaded from file:', currentPattern);
                updateSortDropdown();

                if (typeof updateClusterByOptions === 'function') {
                    updateClusterByOptions();
                }
            } else {
                console.log('No pattern in file, using current:', currentPattern);
                updateSortDropdown();

                if (typeof updateClusterByOptions === 'function') {
                    updateClusterByOptions();
                }
            }

            render();

            // BUILD 561: Update refresh button visibility for Gmail/GDrive trees
            updateTreeRefreshButton();

            // BUILD 562: Create hyperedge for new Gmail items after refresh
            if (window._gmailRefreshBeforeIds && window._gmailRefreshBeforeIds.size > 0) {
                const beforeIds = window._gmailRefreshBeforeIds;
                const newItems = [];

                // Collect new thread IDs
                const collectNewItems = (node) => {
                    if (node.threadId && !beforeIds.has(node.threadId)) {
                        newItems.push({ id: node.id, threadId: node.threadId, name: node.name });
                    }
                    (node.items || node.children || node.subItems || []).forEach(collectNewItems);
                };

                if (capexTree?.children) {
                    capexTree.children.forEach(collectNewItems);
                }

                if (newItems.length >= 2) {
                    // Create hyperedge for new items
                    const hyperedge = addHyperedge(
                        'gmail_new',
                        `New Emails (${newItems.length})`,
                        newItems.map(item => item.id),
                        {
                            color: '#10b981',
                            description: `New emails discovered during refresh at ${new Date().toLocaleTimeString()}`,
                            isAutoCreated: true
                        }
                    );
                    if (hyperedge) {
                        showToast(`Created hyperedge for ${newItems.length} new emails`, 'success');
                        console.log('ğŸ“¨ New email hyperedge created:', newItems.map(i => i.name).join(', '));
                    }
                } else if (newItems.length === 1) {
                    showToast(`1 new email: ${newItems[0].name?.substring(0, 50)}...`, 'info');
                }

                // Clear the refresh state
                delete window._gmailRefreshBeforeIds;
                delete window._gmailRefreshFilename;
            }

            // Apply default sort for filesystem pattern
            if (currentPattern === 'filesystem') {
                sortTree(null);
            }

            // BUILD 285: Restore view state if saved
            if (data.viewState) {
                const vs = data.viewState;
                console.log('ğŸ“ Restoring view state:', vs);

                // BUILD 507: Reset pan position on mobile (saved desktop pan may be off-screen)
                const isMobileView = window.matchMedia('(max-width: 768px)').matches ||
                                     ('ontouchstart' in window && window.innerWidth <= 768);
                if (isMobileView) {
                    // Reset to centered view on mobile
                    panX = 0;
                    panY = 0;
                    zoomLevel = vs.treeZoom || 1;
                    console.log('ğŸ“± Mobile: reset pan to center');
                } else {
                    // Restore tree view zoom/pan on desktop
                    if (typeof vs.treeZoom === 'number') zoomLevel = vs.treeZoom;
                    if (typeof vs.treePanX === 'number') panX = vs.treePanX;
                    if (typeof vs.treePanY === 'number') panY = vs.treePanY;
                }

                // Restore canvas zoom/pan
                if (typeof vs.canvasZoom === 'number') canvasZoom = vs.canvasZoom;
                if (typeof vs.canvasPanX === 'number') canvasPan.x = vs.canvasPanX;
                if (typeof vs.canvasPanY === 'number') canvasPan.y = vs.canvasPanY;

                // Apply tree view transform
                const wrapper = document.getElementById('tree-transform-wrapper');
                if (wrapper) {
                    wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
                }
                const zoomDisplay = document.getElementById('zoom-display');
                if (zoomDisplay) {
                    zoomDisplay.textContent = Math.round(zoomLevel * 100) + '%';
                }

                // Restore view mode (tree or canvas)
                if (vs.viewMode && vs.viewMode !== viewMode) {
                    // Switch to the saved view mode
                    setTimeout(() => {
                        const toggleBtn = document.getElementById('view-toggle');
                        if (toggleBtn && vs.viewMode === 'canvas' && viewMode === 'tree') {
                            toggleBtn.click();
                        } else if (toggleBtn && vs.viewMode === 'tree' && viewMode === 'canvas') {
                            toggleBtn.click();
                        }
                    }, 100);
                }
            } else {
                // BUILD 310: Smart default view for large trees without saved viewState
                // Count total nodes to determine if tree is "large"
                let nodeCount = 0;
                function countNodes(node) {
                    nodeCount++;
                    // Check all child properties - must check length to avoid empty arrays
                    if (node.children && node.children.length > 0) node.children.forEach(countNodes);
                    if (node.items && node.items.length > 0) node.items.forEach(countNodes);
                    if (node.subItems && node.subItems.length > 0) node.subItems.forEach(countNodes);
                }
                countNodes(capexTree);

                console.log(`ğŸ“Š Loaded tree with ${nodeCount} nodes (no saved viewState)`);

                // For large trees (>30 nodes), collapse to show only root + phases
                if (nodeCount > 30) {
                    console.log('ğŸŒ³ Large tree detected - collapsing for better initial view');

                    // Collapse all nodes recursively, getting children from the right property
                    function getChildren(node) {
                        // Check items first (used by philosophy pattern), then children
                        if (node.items && node.items.length > 0) return node.items;
                        if (node.children && node.children.length > 0) return node.children;
                        if (node.subItems && node.subItems.length > 0) return node.subItems;
                        return [];
                    }

                    // Keep root expanded, expand phases (depth 1), collapse rest
                    capexTree.expanded = true;
                    getChildren(capexTree).forEach(phase => {
                        phase.expanded = true; // Show phases
                        // Collapse items within phases
                        getChildren(phase).forEach(item => {
                            item.expanded = false;
                            getChildren(item).forEach(sub => {
                                sub.expanded = false;
                            });
                        });
                    });

                    // Re-render with collapsed state
                    render();
                }

                // Reset zoom/pan to defaults
                zoomLevel = 1.0;
                panX = 0;
                panY = 0;

                const wrapper = document.getElementById('tree-transform-wrapper');
                if (wrapper) {
                    wrapper.style.transform = `translate(0px, 0px) scale(1)`;
                }
                const zoomDisplay = document.getElementById('zoom-display');
                if (zoomDisplay) {
                    zoomDisplay.textContent = '100%';
                }

                // BUILD 312: Reset scroll position to show tree from top-left
                const treeContainer = document.getElementById('tree-container');
                if (treeContainer) {
                    treeContainer.scrollTop = 0;
                    treeContainer.scrollLeft = 0;
                }

                // BUILD 313/314: For filesystem pattern, align tree to top-left instead of center
                if (currentPattern === 'filesystem') {
                    if (wrapper) {
                        wrapper.style.alignItems = 'flex-start';
                        wrapper.style.justifyContent = 'flex-start';
                        wrapper.style.padding = '20px';
                        wrapper.style.transformOrigin = 'top left';
                    }
                    if (treeContainer) {
                        treeContainer.style.alignItems = 'flex-start';
                        treeContainer.style.justifyContent = 'flex-start';
                    }
                } else {
                    // For other patterns, ensure transform-origin is center (default)
                    if (wrapper) {
                        wrapper.style.transformOrigin = 'center center';
                    }
                }
            }

            // Mark tree manager as having this tree loaded
            if (window.treeManager) {
                window.treeManager.currentTreeId = data.id;
                window.treeManager.hasUnsavedChanges = false;
            }
        }

        /**
         * BUILD 284/426/605: Show version conflict dialog
         * When loading a file that has a different version in LocalStorage
         * BUILD 426: Clearer labels, neutral styling when dates unknown
         * BUILD 605: Show ALL browser stored trees with full metadata (name, date, size, items)
         */
        function showVersionConflictDialog(options) {
            const { treeId, treeName, fileData, fileDate, localData, localDate, localItemCount } = options;

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            // Count items in file - BUILD 598: Handle all child property types
            let fileItemCount = 0;
            function countAllItems(node) {
                let count = 0;
                const children = node.children || node.items || node.subItems || [];
                children.forEach(child => {
                    count++; // Count this child
                    count += countAllItems(child); // Recursively count descendants
                });
                return count;
            }
            fileItemCount = countAllItems(fileData);

            // Calculate file size
            const fileJson = JSON.stringify(fileData);
            const fileSizeKB = (fileJson.length / 1024).toFixed(1);
            const fileSizeDisplay = fileSizeKB >= 1000 ? `${(fileSizeKB / 1024).toFixed(1)} MB` : `${fileSizeKB} KB`;

            // BUILD 605: Get ALL stored trees from browser
            const allStoredTrees = window.treeManager?.getAllStoredTrees() || [];

            // Format date helper
            const formatDate = (timestamp) => {
                if (!timestamp) return 'Unknown';
                return new Date(timestamp).toLocaleString();
            };

            // Determine if we can actually compare dates
            const fileDateKnown = fileDate && fileDate !== 'Unknown';

            // Title and subtitle
            const title = allStoredTrees.length > 1
                ? `Choose Version to Load`
                : 'Multiple Versions Found';
            const subtitle = `"${treeName}" - select which version to open`;

            // Build stored trees list HTML
            let storedTreesHtml = '';
            if (allStoredTrees.length > 0) {
                storedTreesHtml = allStoredTrees.map((tree, idx) => {
                    const isMatch = tree.id === treeId;
                    const bgColor = isMatch ? 'rgba(16, 185, 129, 0.15)' : 'rgba(107, 114, 128, 0.1)';
                    const borderColor = isMatch ? 'rgba(16, 185, 129, 0.4)' : 'rgba(107, 114, 128, 0.2)';
                    const labelColor = isMatch ? '#10B981' : 'var(--text-secondary)';
                    const matchBadge = isMatch ? '<span style="background: #10B981; color: white; font-size: 9px; padding: 2px 6px; border-radius: 4px; margin-left: 8px;">MATCH</span>' : '';

                    return `
                        <div onclick="loadVersionChoice('local', '${tree.id}')"
                            style="padding: 12px 16px; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 8px; cursor: pointer; transition: all 0.2s;"
                            onmouseover="this.style.transform='translateX(4px)'; this.style.borderColor='#6366f1'"
                            onmouseout="this.style.transform='none'; this.style.borderColor='${borderColor}'">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px;">
                                <div style="font-weight: 600; color: var(--text-primary); font-size: 14px;">
                                    ğŸ’¾ ${tree.name}${matchBadge}
                                </div>
                                <div style="font-size: 11px; color: ${labelColor}; text-transform: uppercase;">${tree.pattern}</div>
                            </div>
                            <div style="display: flex; gap: 16px; font-size: 12px; color: var(--text-secondary);">
                                <span>ğŸ“… ${formatDate(tree.lastModified)}</span>
                                <span>ğŸ“Š ${tree.itemCount} items</span>
                                <span>ğŸ’¿ ${tree.sizeDisplay}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                storedTreesHtml = `
                    <div style="padding: 16px; background: rgba(107, 114, 128, 0.1); border-radius: 8px; text-align: center; color: var(--text-secondary);">
                        No browser-stored trees found
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div style="padding: 24px; max-width: 650px;">
                    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 20px;">
                        <div style="font-size: 40px;">ğŸ“‚</div>
                        <div>
                            <h3 style="color: #6366f1; margin-bottom: 4px; font-size: 18px;">${title}</h3>
                            <div style="font-size: 12px; color: var(--text-secondary);">${subtitle}</div>
                        </div>
                    </div>

                    <!-- File being opened -->
                    <div style="margin-bottom: 16px;">
                        <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">ğŸ“ File You're Opening</div>
                        <div onclick="loadVersionChoice('file')"
                            style="padding: 12px 16px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; cursor: pointer; transition: all 0.2s;"
                            onmouseover="this.style.transform='translateX(4px)'; this.style.borderColor='#6366f1'"
                            onmouseout="this.style.transform='none'; this.style.borderColor='rgba(99, 102, 241, 0.3)'">
                            <div style="font-weight: 600; color: var(--text-primary); font-size: 14px; margin-bottom: 6px;">
                                ğŸ“„ ${treeName}
                            </div>
                            <div style="display: flex; gap: 16px; font-size: 12px; color: var(--text-secondary);">
                                <span>ğŸ“… ${fileDateKnown ? fileDate : 'Date not in file'}</span>
                                <span>ğŸ“Š ${fileItemCount} items</span>
                                <span>ğŸ’¿ ${fileSizeDisplay}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Browser stored trees -->
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">
                            ğŸ’¾ Browser Stored Trees (${allStoredTrees.length})
                        </div>
                        <div style="max-height: 240px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px;">
                            ${storedTreesHtml}
                        </div>
                    </div>

                    <div style="background: rgba(107, 114, 128, 0.08); padding: 10px 14px; border-radius: 6px; margin-bottom: 16px;">
                        <p style="color: var(--text-secondary); font-size: 12px; margin: 0; line-height: 1.5;">
                            Click any option above to load. Browser trees are auto-saved every 2 minutes.
                        </p>
                    </div>

                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button onclick="document.getElementById('modal').style.display='none'"
                            style="padding: 10px 20px; background: rgba(107, 114, 128, 0.2); color: var(--text-secondary); border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; font-size: 13px;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;

            // Store file data for potential loading
            window._pendingFileData = fileData;

            // BUILD 603: Reset modal footer
            document.querySelector('#modal .modal-footer').innerHTML = '';

            modal.style.display = 'flex';
        }

        /**
         * BUILD 284: Handle version choice from conflict dialog
         */
        function loadVersionChoice(choice, treeId) {
            document.getElementById('modal').style.display = 'none';

            if (choice === 'file') {
                // Load the file version from stored pending data
                const data = window._pendingFileData;
                if (data) {
                    loadTreeData(data);
                    showToast(`Loaded file version: ${data.name || 'Tree'}`, 'success');
                }
            } else if (choice === 'local') {
                // Load from LocalStorage
                const localTree = localStorage.getItem(`treelisty:tree:${treeId}`);
                if (localTree) {
                    try {
                        const data = JSON.parse(localTree);
                        migrateTree(data);
                        loadTreeData(data);
                        showToast(`Loaded local version: ${data.name || 'Tree'}`, 'success');
                    } catch (err) {
                        showToast('Failed to load local version', 'error');
                    }
                }
            }

            // Cleanup
            window._pendingFileData = null;
        }

        // =============================================================================
        // TREE MANAGER - Save/Load with Auto-Save & Organized Folders
        // =============================================================================

        class TreeManager {
            constructor() {
                this.currentTreeId = null;
                this.lastSaveTimestamp = null;
                this.hasUnsavedChanges = false;
                this.autoSaveInterval = null;
            }

            initialize() {
                console.log('ğŸŒ³ TreeManager: Initializing...');
                console.log('ğŸ’¾ Save mode: LocalStorage + Download to Downloads folder');
                this.loadTreeFromURLOrStorage();
                this.startAutoSave(120);
                this.startIndicatorUpdates();
                this.watchForChanges();
            }

            getTimestamp() {
                const now = new Date();
                const y = now.getFullYear();
                const m = String(now.getMonth() + 1).padStart(2, '0');
                const d = String(now.getDate()).padStart(2, '0');
                const h = String(now.getHours()).padStart(2, '0');
                const min = String(now.getMinutes()).padStart(2, '0');
                const s = String(now.getSeconds()).padStart(2, '0');
                return `${y}${m}${d}-${h}${min}${s}`;
            }

            slugify(text) {
                return text.toString().toLowerCase().trim()
                    .replace(/\s+/g, '-').replace(/[^\w\-]+/g, '')
                    .replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
            }

            generateFilename(tree) {
                const pattern = tree.pattern?.key || 'generic';
                const treeName = tree.name || 'project';
                const slug = this.slugify(treeName);
                const timestamp = this.getTimestamp();

                // Format: treelisty-<pattern>-<name>-<timestamp>.json
                // Example: treelisty-philosophy-plato-cave-20251118-153045.json
                return `treelisty-${pattern}-${slug}-${timestamp}.json`;
            }

            saveToLocalStorage(tree) {
                try {
                    const treeId = tree.id || 'default';
                    const jsonStr = JSON.stringify(tree, null, 2);
                    localStorage.setItem(`treelisty:tree:${treeId}`, jsonStr);
                    const metadata = this.extractMetadata(tree);
                    localStorage.setItem(`treelisty:meta:${treeId}`, JSON.stringify(metadata));
                    this.lastSaveTimestamp = Date.now();
                    this.hasUnsavedChanges = false;
                    console.log(`ğŸ’¾ Saved to LocalStorage: ${treeId}`);
                    return true;
                } catch (error) {
                    console.error('âŒ LocalStorage save failed:', error);
                    return false;
                }
            }

            extractMetadata(tree) {
                return {
                    id: tree.id || 'default',
                    name: tree.name || 'Untitled',
                    pattern: tree.pattern?.key || 'generic',
                    itemCount: this.countItems(tree),
                    lastModified: Date.now(),
                    lastSaved: this.lastSaveTimestamp
                };
            }

            // BUILD 598: Count all items recursively, handling all child property types
            countItems(tree) {
                let count = 0;
                function countRecursive(node) {
                    const children = node.children || node.items || node.subItems || [];
                    children.forEach(child => {
                        count++;
                        countRecursive(child);
                    });
                }
                countRecursive(tree);
                return count;
            }

            // BUILD 605: Get all stored trees from localStorage with full metadata
            getAllStoredTrees() {
                const trees = [];
                const treePrefix = 'treelisty:tree:';
                const metaPrefix = 'treelisty:meta:';

                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(treePrefix)) {
                        const treeId = key.replace(treePrefix, '');
                        try {
                            const treeJson = localStorage.getItem(key);
                            const metaJson = localStorage.getItem(metaPrefix + treeId);
                            const tree = JSON.parse(treeJson);
                            const meta = metaJson ? JSON.parse(metaJson) : {};

                            // Calculate size in KB
                            const sizeKB = (treeJson.length / 1024).toFixed(1);

                            trees.push({
                                id: treeId,
                                name: tree.name || meta.name || 'Untitled',
                                pattern: tree.pattern?.key || meta.pattern || 'generic',
                                itemCount: meta.itemCount || this.countItems(tree),
                                lastModified: meta.lastModified || null,
                                lastSaved: meta.lastSaved || meta.lastModified || null,
                                sizeKB: parseFloat(sizeKB),
                                sizeDisplay: sizeKB >= 1000 ? `${(sizeKB / 1024).toFixed(1)} MB` : `${sizeKB} KB`
                            });
                        } catch (err) {
                            console.warn(`Failed to parse stored tree ${treeId}:`, err);
                        }
                    }
                }

                // Sort by lastModified descending (most recent first)
                trees.sort((a, b) => (b.lastModified || 0) - (a.lastModified || 0));
                return trees;
            }

            downloadJSON(tree) {
                try {
                    const filename = this.generateFilename(tree);
                    const jsonStr = JSON.stringify(tree, null, 2);
                    const blob = new Blob([jsonStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    console.log(`ğŸ’¾ Downloaded: ${filename}`);
                    if (typeof showToast === 'function') showToast(`âœ… Saved: ${filename}`);
                    return true;
                } catch (error) {
                    console.error('âŒ Download failed:', error);
                    return false;
                }
            }

            save(tree, options = {}) {
                const { silent = false, forceSaveAs = false } = options;

                // BUILD 285: Capture current view state before saving
                tree.viewState = {
                    viewMode: typeof viewMode !== 'undefined' ? viewMode : 'tree',
                    treeZoom: typeof zoomLevel !== 'undefined' ? zoomLevel : 1,
                    treePanX: typeof panX !== 'undefined' ? panX : 0,
                    treePanY: typeof panY !== 'undefined' ? panY : 0,
                    canvasZoom: typeof canvasZoom !== 'undefined' ? canvasZoom : 1,
                    canvasPanX: typeof canvasPan !== 'undefined' ? canvasPan.x : 0,
                    canvasPanY: typeof canvasPan !== 'undefined' ? canvasPan.y : 0
                };

                // Save to LocalStorage for auto-save tracking
                this.saveToLocalStorage(tree);

                // Download JSON file (only on manual save, not auto-save)
                if (!silent) {
                    this.downloadJSON(tree);
                    this.updateSaveIndicator('saved');
                }

                this.addToRecentFiles(tree);
            }

            startAutoSave(intervalSeconds) {
                console.log(`â° Auto-save enabled: every ${intervalSeconds} seconds`);
                this.autoSaveInterval = setInterval(() => {
                    if (this.hasUnsavedChanges) {
                        console.log('ğŸ’¾ Auto-saving...');
                        this.save(capexTree, { silent: true });
                    }
                }, intervalSeconds * 1000);
            }

            startIndicatorUpdates() {
                // Update save indicator every 30 seconds to keep "Saved Xm ago" current
                setInterval(() => {
                    if (this.lastSaveTimestamp && !this.hasUnsavedChanges) {
                        this.updateSaveIndicator('saved');
                    }
                }, 30000); // 30 seconds
            }

            watchForChanges() {
                this.hasUnsavedChanges = true;
            }

            markAsChanged() {
                this.hasUnsavedChanges = true;
                this.updateSaveIndicator('unsaved');
            }

            updateSaveIndicator(status) {
                const indicator = document.getElementById('save-indicator');
                if (!indicator) return;
                if (status === 'saving') {
                    indicator.textContent = 'ğŸ’¾ Saving...';
                    indicator.style.color = '#9DA3B4';
                } else if (status === 'saved') {
                    const timeAgo = this.getTimeAgo(this.lastSaveTimestamp);
                    indicator.textContent = `âœ“ Saved ${timeAgo}`;
                    indicator.style.color = '#5FA463';
                } else if (status === 'unsaved') {
                    indicator.textContent = 'â— Unsaved changes';
                    indicator.style.color = '#D68A2E';
                }
            }

            getTimeAgo(timestamp) {
                if (!timestamp) return 'just now';
                const seconds = Math.floor((Date.now() - timestamp) / 1000);
                if (seconds < 10) return 'just now';
                if (seconds < 60) return `${seconds}s ago`;
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            }

            addToRecentFiles(tree) {
                try {
                    let recent = this.getRecentFiles();
                    const metadata = this.extractMetadata(tree);
                    recent = recent.filter(r => r.id !== metadata.id);
                    recent.unshift(metadata);
                    recent = recent.slice(0, 10);
                    localStorage.setItem('treelisty:recent', JSON.stringify(recent));
                } catch (error) {
                    console.error('âŒ Failed to update recent files:', error);
                }
            }

            getRecentFiles() {
                try {
                    const data = localStorage.getItem('treelisty:recent');
                    return data ? JSON.parse(data) : [];
                } catch (error) {
                    return [];
                }
            }

            loadTreeFromURLOrStorage() {
                const urlParams = new URLSearchParams(window.location.search);

                // BUILD 610: Check for tree source from URL parameter
                if (window.TREELISTY_MODE && window.TREELISTY_MODE.treeSource) {
                    console.log('ğŸ“¥ Loading tree from URL parameter:', window.TREELISTY_MODE.treeSource);
                    this.loadTreeFromSource(window.TREELISTY_MODE.treeSource);
                    return;
                }

                if (urlParams.has('data')) {
                    console.log('ğŸ“¥ Loading tree from shared URL...');
                    return;
                }
                const treeId = 'default';
                const treeData = localStorage.getItem(`treelisty:tree:${treeId}`);
                if (treeData) {
                    try {
                        const tree = JSON.parse(treeData);

                        // Migrate tree to current schema (Cognitive Citadel Foundation)
                        migrateTree(tree);

                        console.log('ğŸ“¥ Loaded tree from LocalStorage:', treeId);
                        Object.assign(capexTree, tree);
                        this.currentTreeId = treeId;

                        // BUILD 507: Collapse phases on mobile for cleaner initial view
                        const isMobileDevice = window.matchMedia('(max-width: 768px)').matches ||
                                               ('ontouchstart' in window && window.innerWidth <= 768);
                        if (isMobileDevice && capexTree.children) {
                            capexTree.children.forEach(phase => {
                                if (phase.expanded !== false) {
                                    phase.expanded = false;
                                }
                            });
                            console.log('ğŸ“± Mobile: phases collapsed');
                        }

                        // BUILD 379: Restore pattern from saved tree
                        if (tree.pattern) {
                            const patternKey = typeof tree.pattern === 'string'
                                ? tree.pattern
                                : (tree.pattern.key || 'generic');

                            if (PATTERNS[patternKey]) {
                                currentPattern = patternKey;
                                console.log(`ğŸ¨ Restored pattern: ${patternKey}`);

                                // Update pattern selector UI
                                const patternSelect = document.getElementById('pattern-select');
                                if (patternSelect) {
                                    patternSelect.value = patternKey;
                                }

                                // Handle custom pattern labels
                                if (patternKey === 'custom' && tree.pattern.labels) {
                                    customPatternNames = tree.pattern.labels;
                                }

                                // BUILD 380: Show biographer indicator for LifeTree
                                setTimeout(() => {
                                    if (typeof checkBiographerIndicator === 'function') {
                                        checkBiographerIndicator();
                                    }
                                }, 100);
                            }
                        }

                        // BUILD 529: Re-render after loading from localStorage
                        // This ensures the restored tree is displayed, especially in PWA mode
                        if (typeof render === 'function') {
                            console.log('ğŸ”„ Re-rendering after localStorage restore');
                            render();
                        }
                    } catch (error) {
                        console.error('âŒ Failed to load tree from LocalStorage:', error);
                    }
                }
            }

            // BUILD 610: Load tree from source (help, welcome, URL, or base64)
            async loadTreeFromSource(source) {
                try {
                    let treeData;

                    if (source === 'help') {
                        // Load built-in help tree
                        console.log('ğŸ“– Loading help tree...');
                        const response = await fetch('help-tree.json');
                        if (!response.ok) throw new Error('Failed to load help-tree.json');
                        treeData = await response.json();
                    } else if (source === 'welcome') {
                        // Load default welcome tree
                        console.log('ğŸ‘‹ Loading welcome tree...');
                        const response = await fetch('welcome-to-treelisty.json');
                        if (!response.ok) throw new Error('Failed to load welcome-to-treelisty.json');
                        treeData = await response.json();
                    } else if (source.startsWith('http://') || source.startsWith('https://')) {
                        // Load from external URL
                        console.log('ğŸŒ Loading tree from URL:', source);
                        const response = await fetch(source);
                        if (!response.ok) throw new Error(`Failed to fetch tree from ${source}`);
                        treeData = await response.json();
                    } else {
                        // Try to decompress as LZ-String base64
                        console.log('ğŸ“¦ Loading tree from compressed data...');
                        if (typeof LZString !== 'undefined') {
                            const decompressed = LZString.decompressFromEncodedURIComponent(source);
                            if (decompressed) {
                                treeData = JSON.parse(decompressed);
                            }
                        }
                    }

                    if (treeData) {
                        // Normalize and migrate the tree
                        if (typeof normalizeTreeStructure === 'function') {
                            const { tree: normalized, fixes } = normalizeTreeStructure(treeData);
                            treeData = normalized;
                            if (fixes.length > 0) {
                                console.log('ğŸ”§ Tree normalized:', [...new Set(fixes)].join(', '));
                            }
                        }
                        if (typeof migrateTree === 'function') {
                            migrateTree(treeData);
                        }

                        // Apply to capexTree
                        Object.assign(capexTree, treeData);
                        this.currentTreeId = treeData.id || 'embedded';

                        // Restore pattern
                        if (treeData.pattern) {
                            const patternKey = typeof treeData.pattern === 'string'
                                ? treeData.pattern
                                : (treeData.pattern.key || 'generic');
                            if (PATTERNS && PATTERNS[patternKey]) {
                                currentPattern = patternKey;
                                const patternSelect = document.getElementById('pattern-select');
                                if (patternSelect) patternSelect.value = patternKey;
                            }
                        }

                        // Render the tree
                        if (typeof render === 'function') {
                            render();
                        }

                        console.log('âœ… Tree loaded from source:', source);
                        if (typeof showToast === 'function') {
                            showToast(`Loaded: ${treeData.name || 'Tree'}`, 'success');
                        }
                    }
                } catch (error) {
                    console.error('âŒ Failed to load tree from source:', error);
                    if (typeof showToast === 'function') {
                        showToast(`Failed to load tree: ${error.message}`, 'error');
                    }
                }
            }
        }

        const treeManager = new TreeManager();
        // Expose treeManager to window for Firebase sync
        window.treeManager = treeManager;
        window.addEventListener('DOMContentLoaded', () => {
            treeManager.initialize();
        });

        // BUILD 610: Clone to Edit - opens current tree in a new editable window
        function cloneTreeForEditing() {
            try {
                // Serialize current tree to compressed format
                const treeJson = JSON.stringify(capexTree);
                const compressed = typeof LZString !== 'undefined'
                    ? LZString.compressToEncodedURIComponent(treeJson)
                    : null;

                if (compressed && compressed.length < 8000) {
                    // Open new window with compressed tree data
                    const editUrl = `${window.location.pathname}?data=${compressed}`;
                    window.open(editUrl, '_blank');
                    showToast('Opening editable copy...', 'info');
                } else {
                    // Tree too large for URL, copy to clipboard instead
                    navigator.clipboard.writeText(treeJson).then(() => {
                        window.open(window.location.pathname, '_blank');
                        showToast('Tree copied! Paste in new window via Open â†’ Paste JSON', 'info');
                    }).catch(() => {
                        // Fallback: just open new window
                        window.open(window.location.pathname, '_blank');
                        showToast('Opening TreeListy... Save current tree first to edit it', 'warning');
                    });
                }
            } catch (error) {
                console.error('Clone to edit failed:', error);
                showToast('Failed to clone tree', 'error');
            }
        }
        window.cloneTreeForEditing = cloneTreeForEditing;

        // BUILD 284: Warn user before closing if there are unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (treeManager.hasUnsavedChanges) {
                const message = 'You have unsaved changes. Are you sure you want to leave?';
                e.preventDefault();
                e.returnValue = message;
                return message;
            }
        });

        // Enhanced save function
        function handleDownload() {
            treeManager.save(capexTree, { forceSaveAs: false });
        }

        function handleUpload() {
            document.getElementById('json-upload-input').click();
        }

        // BUILD 536: Incremental expand/collapse - one level at a time
        function handleExpandAll() {
            // Reuse the same logic as toolbar button
            document.getElementById('expand-btn')?.click();
        }

        function handleCollapseAll() {
            // Reuse the same logic as toolbar button
            document.getElementById('collapse-btn')?.click();
        }

        // Toggle subtasks for a specific item
        window.toggleSubtasks = function(itemId) {
            function findAndToggle(node) {
                if (node.items) {
                    const item = node.items.find(i => i.id === itemId);
                    if (item) {
                        item.expanded = !item.expanded;
                        render();
                        return true;
                    }
                }
                if (node.children) {
                    for (let child of node.children) {
                        if (findAndToggle(child)) return true;
                    }
                }
                return false;
            }
            findAndToggle(capexTree);
        };

        // Add update to current activeNode
        window.addUpdate = function() {
            if (!activeNode) return;
            const updateText = document.getElementById('edit-pm-new-update').value.trim();
            if (!updateText) {
                alert('Please enter an update message');
                return;
            }

            if (!activeNode.pmUpdates) activeNode.pmUpdates = [];
            activeNode.pmUpdates.unshift({
                timestamp: new Date().toISOString(),
                text: updateText
            });

            // Clear the input and re-render the modal
            document.getElementById('edit-pm-new-update').value = '';
            handleEdit(); // Re-render the edit modal to show the new update
        };

        // Delete update from current activeNode
        window.deleteUpdate = function(index) {
            if (!activeNode || !activeNode.pmUpdates) return;
            if (confirm('Delete this update?')) {
                activeNode.pmUpdates.splice(index, 1);
                handleEdit(); // Re-render the edit modal
            }
        };

        // BUILD 483: Expose handleEdit globally for Gantt view integration
        window.handleEdit = handleEdit;
        window.setActiveNode = function(node) { activeNode = node; };

        async function handleAI() {
            if (activeNode) {
                const modal = document.getElementById('modal');
                const modalBody = document.getElementById('modal-body');

                // Show loading state
                modalBody.innerHTML = `
                    <div style="padding: 40px; text-align: center;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">AI is analyzing ${activeNode.name}...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                `;
                modal.style.display = 'flex';

                try {
                    // Determine analysis type (subtask, item, or project)
                    let analysisType = 'item';
                    if (activeNode.type === 'root') {
                        analysisType = 'project';
                    } else if (activeNode.type === 'subtask') {
                        analysisType = 'subtask';
                    }

                    // Call real AI
                    const aiResponse = await generateAIAnalysis(activeNode, analysisType);

                    // Display AI response with markdown-like formatting
                    modalBody.innerHTML = `
                        <div style="padding: 20px; line-height: 1.8;">
                            <div style="white-space: pre-wrap; font-size: 14px; color: var(--text-primary);">${aiResponse}</div>
                            <div style="margin-top: 24px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ğŸ¤– Analysis powered by Claude Sonnet â€¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;

                } catch (error) {
                    // Show error
                    modalBody.innerHTML = `
                        <div style="padding: 30px; text-align: center;">
                            <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                            <h3 style="margin-bottom: 16px; color: var(--text-primary);">AI Analysis Failed</h3>
                            <p style="margin-bottom: 24px; color: var(--text-secondary); line-height: 1.6;">
                                ${error.message}
                            </p>
                            <p style="font-size: 12px; color: var(--text-secondary);">
                                If this problem persists, contact geej support.
                            </p>
                        </div>
                    `;
                }
            }
        }

        // =============================================================================
        // DEEP DIVE ANALYSIS - Structured Scholar for Selected Nodes
        // =============================================================================
        // PHILOSOPHY RELATIONSHIP INFERENCE HELPERS
        // =============================================================================

        /**
         * Infer dialectical relation between nodes based on their types
         */
        function inferDialecticalRelation(nodes) {
            const types = nodes.map(n => n.itemType).filter(Boolean);

            // Check for thesis-antithesis patterns
            if (types.includes('premise') && types.includes('objection')) {
                return 'Thesis-Antithesis: A claim is challenged by a counter-argument';
            }
            if (types.includes('premise') && types.includes('refutation')) {
                return 'Dialectical Exchange: Premises face critical refutation';
            }
            if (types.includes('conclusion') && types.includes('objection')) {
                return 'Conclusion Under Scrutiny: Final claim faces objection';
            }
            if (types.includes('definition') && types.includes('distinction')) {
                return 'Conceptual Clarification: Definitions refined through distinction';
            }
            if (types.includes('implicit-premise') && types.includes('premise')) {
                return 'Hidden Foundations: Explicit claims rest on implicit assumptions';
            }
            if (types.every(t => t === 'premise')) {
                return 'Cumulative Argument: Multiple premises building toward conclusion';
            }
            if (types.includes('thought-experiment')) {
                return 'Exploratory Dialectic: Thought experiments probe conceptual boundaries';
            }

            return 'Conceptual Network: Interrelated philosophical claims';
        }

        /**
         * Infer argumentative flow direction
         */
        function inferArgumentativeFlow(nodes) {
            const types = nodes.map(n => n.itemType).filter(Boolean);

            if (types.includes('premise') && types.includes('conclusion')) {
                return 'Deductive: Premises â†’ Conclusion';
            }
            if (types.includes('objection') && types.includes('refutation')) {
                return 'Refutational: Objection â†’ Counter-Response';
            }
            if (types.filter(t => t === 'premise').length >= 2) {
                return 'Synthetic: Multiple premises converging';
            }
            if (types.includes('distinction')) {
                return 'Analytical: Concepts being differentiated';
            }
            if (types.includes('definition')) {
                return 'Foundational: Establishing base definitions';
            }

            return 'Exploratory: Mapping conceptual territory';
        }

        /**
         * Infer the conceptual bridge connecting the nodes
         */
        function inferConceptualBridge(nodes) {
            // Look for shared key terms or speakers
            const allKeyTerms = nodes.flatMap(n => n.keyTerms || []);
            const termCounts = {};
            allKeyTerms.forEach(t => {
                const term = typeof t === 'string' ? t : t.term;
                if (term) termCounts[term] = (termCounts[term] || 0) + 1;
            });

            // Find terms appearing in multiple nodes
            const sharedTerms = Object.entries(termCounts)
                .filter(([_, count]) => count > 1)
                .map(([term, _]) => term);

            if (sharedTerms.length > 0) {
                return `Shared Concepts: ${sharedTerms.slice(0, 3).join(', ')}`;
            }

            // Check speakers
            const speakers = [...new Set(nodes.map(n => n.speaker).filter(Boolean))];
            if (speakers.length === 1) {
                return `Single Voice: All claims attributed to ${speakers[0]}`;
            }
            if (speakers.length > 1) {
                return `Dialogue: Exchange between ${speakers.slice(0, 2).join(' and ')}`;
            }

            return 'Thematic Unity: Connected through subject matter';
        }

        // =============================================================================
        // DEEP DIVE ANALYSIS (Structured Scholar)
        // =============================================================================
        // Enriches selected nodes with:
        // - subItems (objections, counter-arguments, implications)
        // - Missing fields (speaker, keyTerms, textualReference)
        // - Creates hyperedge linking analyzed nodes
        // =============================================================================

        async function handleAnalyzeSelection(nodes) {
            if (!nodes || nodes.length === 0) {
                console.warn('No nodes to analyze');
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            // Get pattern context
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;
            const isPhilosophy = currentPattern === 'philosophy';

            // Show loading state with progress
            const nodeNames = nodes.map(n => n.name).join(', ');
            const truncatedNames = nodeNames.length > 100 ? nodeNames.substring(0, 100) + '...' : nodeNames;

            modalBody.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <div class="spinner" style="margin: 0 auto 20px;"></div>
                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px;">ğŸ“ Deep Dive Analysis</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 8px;">
                        Analyzing ${nodes.length} node${nodes.length > 1 ? 's' : ''}...
                    </p>
                    <p style="font-size: 12px; color: var(--text-secondary); opacity: 0.7;">
                        ${truncatedNames}
                    </p>
                    <div style="margin-top: 20px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 8px;">
                        <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                            ğŸ”¬ Structured Scholar technique: Identifying objections, implications, and hidden premises...
                        </p>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';

            try {
                // Build context from tree
                const treeContext = {
                    projectName: capexTree.name,
                    projectDescription: capexTree.description,
                    pattern: currentPattern,
                    metadata: capexTree.metadata || {}
                };

                // Find parent phases for context
                const nodesWithContext = nodes.map(node => {
                    let parentPhase = null;
                    if (capexTree.children) {
                        for (const phase of capexTree.children) {
                            if (phase.items && phase.items.find(item => item.id === node.id)) {
                                parentPhase = { name: phase.name, subtitle: phase.subtitle };
                                break;
                            }
                        }
                    }
                    return { ...node, parentPhase };
                });

                // Build the Structured Scholar prompt
                const prompt = buildDeepDivePrompt(nodesWithContext, treeContext, isPhilosophy);

                // Call AI
                const response = await callDeepDiveAI(prompt, isPhilosophy);

                // Parse and merge the enriched data (new format returns { nodes, relationshipAnalysis })
                const parseResult = parseDeepDiveResponse(response, nodes);
                const enrichedNodes = parseResult.nodes || parseResult; // Handle both new and legacy format
                const aiRelationshipAnalysis = parseResult.relationshipAnalysis || null;

                if (enrichedNodes && enrichedNodes.length > 0) {
                    // Save state for undo
                    saveState('Deep Dive Analysis');

                    // Merge enriched data into actual nodes
                    let totalSubItemsAdded = 0;
                    enrichedNodes.forEach(enriched => {
                        const originalNode = nodes.find(n => n.id === enriched.id);
                        if (originalNode) {
                            // Merge fields (don't overwrite existing non-empty values)
                            if (enriched.speaker && !originalNode.speaker) originalNode.speaker = enriched.speaker;
                            if (enriched.keyTerms && !originalNode.keyTerms) originalNode.keyTerms = enriched.keyTerms;
                            if (enriched.textualReference && !originalNode.textualReference) originalNode.textualReference = enriched.textualReference;
                            if (enriched.argumentType && !originalNode.argumentType) originalNode.argumentType = enriched.argumentType;

                            // Merge subItems (add new ones, don't duplicate)
                            if (enriched.subItems && enriched.subItems.length > 0) {
                                if (!originalNode.subItems) originalNode.subItems = [];
                                enriched.subItems.forEach(newSubItem => {
                                    // Check if similar subItem already exists
                                    const exists = originalNode.subItems.some(
                                        existing => existing.name.toLowerCase() === newSubItem.name.toLowerCase()
                                    );
                                    if (!exists) {
                                        // Add ID and type if missing
                                        newSubItem.id = newSubItem.id || `subitem-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
                                        newSubItem.type = newSubItem.type || 'subtask';
                                        originalNode.subItems.push(newSubItem);
                                        totalSubItemsAdded++;
                                    }
                                });
                            }
                        }
                    });

                    // Create hyperedge if multiple nodes were analyzed
                    // Include BOTH original nodes AND their newly generated subitems (Venn diagram effect)
                    let hyperedgeCreated = false;
                    if (nodes.length >= 2) {
                        // Collect all node IDs including subitems
                        const allNodeIds = [];
                        nodes.forEach(n => {
                            allNodeIds.push(n.id);
                            // Include subitems in the hyperedge
                            if (n.subItems) {
                                n.subItems.forEach(sub => allNodeIds.push(sub.id));
                            }
                        });
                        const nodeIds = allNodeIds;
                        console.log('ğŸ”— Creating Deep Dive hyperedge with nodeIds:', nodeIds);

                        // Build analysis metadata - USE AI's relationship analysis if available
                        const analysisMetadata = {
                            analyzedNodes: nodes.map(n => ({ id: n.id, name: n.name, itemType: n.itemType })),
                            totalSubItemsGenerated: totalSubItemsAdded,
                            analysisMethod: 'Structured Scholar',
                            pattern: currentPattern
                        };

                        // Use AI-generated relationship analysis if available, else fallback to inference
                        if (aiRelationshipAnalysis) {
                            // AI provided scholarly analysis of the relationship
                            analysisMetadata.philosophyFields = {
                                dialecticalRelation: aiRelationshipAnalysis.dialecticalRelation || '',
                                argumentativeFlow: aiRelationshipAnalysis.argumentativeFlow || '',
                                conceptualBridge: aiRelationshipAnalysis.conceptualBridge || '',
                                tension: aiRelationshipAnalysis.tension || '',
                                synthesis: aiRelationshipAnalysis.synthesis || '',
                                relationshipType: aiRelationshipAnalysis.relationshipType || '',
                                speakers: [...new Set(nodes.map(n => n.speaker).filter(Boolean))],
                                itemTypes: [...new Set(nodes.map(n => n.itemType).filter(Boolean))],
                                tradition: capexTree.metadata?.tradition || 'Unknown',
                                aiGenerated: true  // Flag that this came from AI analysis
                            };
                            console.log('ğŸ§  Using AI-generated relationship analysis:', aiRelationshipAnalysis);
                        } else if (isPhilosophy) {
                            // Fallback to rule-based inference
                            const itemTypes = nodes.map(n => n.itemType).filter(Boolean);
                            const speakers = nodes.map(n => n.speaker).filter(Boolean);

                            analysisMetadata.philosophyFields = {
                                dialecticalRelation: inferDialecticalRelation(nodes),
                                argumentativeFlow: inferArgumentativeFlow(nodes),
                                conceptualBridge: inferConceptualBridge(nodes),
                                speakers: [...new Set(speakers)],
                                itemTypes: [...new Set(itemTypes)],
                                tradition: capexTree.metadata?.tradition || 'Unknown',
                                aiGenerated: false
                            };
                        }

                        // Generate label from AI's relationshipType or fallback
                        let hyperedgeLabel = 'ğŸ“ Deep Dive Analysis';
                        if (aiRelationshipAnalysis?.relationshipType) {
                            // Use AI's concise relationship type as the label
                            hyperedgeLabel = `ğŸ›ï¸ ${aiRelationshipAnalysis.relationshipType}`;
                        } else if (isPhilosophy && analysisMetadata.philosophyFields) {
                            // Fallback to inferred dialectical relation
                            const dialectical = analysisMetadata.philosophyFields.dialecticalRelation || '';
                            const labelType = dialectical.split(':')[0].trim();
                            if (labelType && labelType !== 'Conceptual Network') {
                                hyperedgeLabel = `ğŸ›ï¸ ${labelType}`;
                            }
                        }

                        // Generate unique color based on number of existing analysis hyperedges
                        if (!capexTree.hyperedges) capexTree.hyperedges = [];
                        const existingAnalysisCount = capexTree.hyperedges.filter(h => h.type === 'analysis').length;
                        const uniqueColor = generateHyperedgeColor(existingAnalysisCount);

                        // Store the color in metadata
                        analysisMetadata.color = uniqueColor;

                        const hyperedge = {
                            id: `hyperedge-deepdive-${Date.now()}`,
                            nodeIds: nodeIds,
                            label: hyperedgeLabel,
                            description: aiRelationshipAnalysis?.dialecticalRelation || `Structured Scholar analysis linking: ${nodes.map(n => n.name).join(', ')}`,
                            createdAt: new Date().toISOString(),
                            type: 'analysis',
                            metadata: analysisMetadata
                        };

                        capexTree.hyperedges.push(hyperedge);
                        hyperedgeCreated = true;

                        console.log('ğŸ”— Hyperedge created:', hyperedge);
                        console.log('ğŸ”— Total hyperedges now:', capexTree.hyperedges.length);
                    }

                    // Re-render
                    render();
                    // Check if canvas view is active by looking at container class
                    const canvasContainer = document.getElementById('canvas-container');
                    const isCanvasActive = canvasContainer && canvasContainer.classList.contains('active');

                    // If hyperedge was created, auto-focus on it for clean visualization
                    if (hyperedgeCreated && isCanvasActive) {
                        // Short delay to ensure modal is shown first
                        setTimeout(() => {
                            focusOnHyperedge(hyperedge.id);
                        }, 100);
                    } else if (isCanvasActive) {
                        renderCanvas();
                        drawHyperedges();
                    }

                    // Show success with summary
                    modalBody.innerHTML = `
                        <div style="padding: 30px;">
                            <div style="text-align: center; margin-bottom: 24px;">
                                <div style="font-size: 48px; margin-bottom: 16px;">ğŸ“</div>
                                <h3 style="color: var(--treeplex-primary); margin-bottom: 8px;">Deep Dive Complete!</h3>
                                <p style="color: var(--text-secondary);">
                                    Analyzed ${nodes.length} node${nodes.length > 1 ? 's' : ''} using Structured Scholar
                                </p>
                            </div>

                            <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                                <h4 style="color: #10B981; margin-bottom: 12px;">ğŸ“Š Analysis Summary</h4>
                                <ul style="margin: 0; padding-left: 20px; color: var(--text-primary); line-height: 1.8;">
                                    <li><strong>${totalSubItemsAdded}</strong> new sub-items added (objections, implications, etc.)</li>
                                    <li><strong>${enrichedNodes.filter(n => n.speaker).length}</strong> speaker attributions</li>
                                    <li><strong>${enrichedNodes.filter(n => n.keyTerms).length}</strong> key term annotations</li>
                                    ${hyperedgeCreated ? `<li>ğŸ”— <strong>Hyperedge created</strong> linking analyzed nodes</li>` : ''}
                                </ul>
                            </div>

                            <div style="background: rgba(99, 102, 241, 0.1); border-radius: 8px; padding: 16px;">
                                <h4 style="color: var(--treeplex-primary); margin-bottom: 8px;">ğŸ’¡ What's New</h4>
                                <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                                    Expand the analyzed nodes to see new sub-items including objections, counter-arguments,
                                    hidden premises, and philosophical implications. ${hyperedgeCreated ? 'The purple hyperedge in Canvas View shows the conceptual relationship between these nodes.' : ''}
                                </p>
                            </div>

                            <div style="margin-top: 20px; text-align: center;">
                                <button onclick="document.getElementById('modal').style.display='none'"
                                    style="padding: 12px 24px; background: var(--treeplex-primary); color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
                                    Got it!
                                </button>
                            </div>
                        </div>
                    `;

                } else {
                    throw new Error('AI returned no enrichment data. Try again or select different nodes.');
                }

            } catch (error) {
                console.error('Deep Dive Analysis failed:', error);
                modalBody.innerHTML = `
                    <div style="padding: 30px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                        <h3 style="margin-bottom: 16px; color: var(--text-primary);">Deep Dive Analysis Failed</h3>
                        <p style="margin-bottom: 24px; color: var(--text-secondary); line-height: 1.6;">
                            ${error.message}
                        </p>
                        <button onclick="document.getElementById('modal').style.display='none'"
                            style="padding: 10px 20px; background: var(--treeplex-primary); color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Close
                        </button>
                    </div>
                `;
            }
        }

        // Build the Structured Scholar deep dive prompt
        function buildDeepDivePrompt(nodesWithContext, treeContext, isPhilosophy) {
            const nodesJson = JSON.stringify(nodesWithContext, null, 2);
            const multipleNodes = nodesWithContext.length >= 2;

            if (isPhilosophy) {
                return {
                    system: `You are a philosophy professor using the "Structured Scholar" technique for deep textual analysis within TreeListy, a hierarchical project decomposition tool.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TREELISTY CONTEXT (Important for output structure)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TREE STRUCTURE: Root â†’ Phases (children) â†’ Items (items) â†’ Subtasks (subItems)
- Each node has: id, name, type, icon, description, and pattern-specific fields
- Philosophy pattern fields: speaker, premises, objections, keyTerms, textualReference, argumentType
- SubItems appear as collapsible nested content under their parent item
- Multiple nodes can be connected via Hyperedges to show cross-cutting relationships

PURPOSE: Your enriched output will be integrated back into the tree, adding depth and scholarly rigor to the user's philosophical analysis. The subItems you generate become visible nested content.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Your expertise includes: identifying hidden premises, reconstructing arguments, citing secondary sources, anticipating objections, and ANALYZING RELATIONSHIPS between philosophical claims.

You will receive JSON data for philosophical nodes to analyze. Your tasks:
1. For EACH node: Fill in missing fields and generate 2-4 subItems
2. ${multipleNodes ? 'CRITICAL: Analyze the RELATIONSHIP between these nodes - what is their dialectical connection?' : ''}

SubItem types to generate:
- "implicit-premise" (ğŸ”®): Hidden assumptions the argument relies on
- "objection" (âš”ï¸): Named philosophical objections with specific critics (e.g., "Carnap", "Ryle")
- "refutation" (ğŸ”„): Responses to objections
- "implication" (ğŸ’¡): Philosophical consequences or downstream effects
- "distinction" (âš–ï¸): Important conceptual distinctions

CRITICAL: Return ONLY valid JSON. No markdown, no explanations.`,

                    user: `Analyze these philosophical nodes and enrich them with deeper analysis.

PROJECT CONTEXT:
- Name: ${treeContext.projectName}
- Pattern: ${treeContext.pattern}
${treeContext.metadata?.tradition ? `- Tradition: ${treeContext.metadata.tradition}` : ''}
${treeContext.metadata?.method ? `- Method: ${treeContext.metadata.method}` : ''}
${treeContext.metadata?.secondarySources ? `- Secondary Sources Available: ${treeContext.metadata.secondarySources.slice(0, 3).join(', ')}` : ''}

NODES TO ANALYZE:
${nodesJson}

Return a JSON object with this structure:
{
  "enrichedNodes": [
    {
      "id": "original-node-id",
      "speaker": "Philosopher name",
      "keyTerms": ["term1", "term2"],
      "textualReference": "Specific citation",
      "argumentType": "deductive|inductive|transcendental|dialectical",
      "subItems": [
        {
          "id": "sub-unique-id",
          "name": "Objection/Implication name",
          "type": "subtask",
          "itemType": "objection|implicit-premise|implication|distinction",
          "speaker": "Critic name if applicable",
          "description": "Detailed description with citations...",
          "icon": "âš”ï¸|ğŸ”®|ğŸ’¡|âš–ï¸"
        }
      ]
    }
  ]${multipleNodes ? `,
  "relationshipAnalysis": {
    "relationshipType": "Short label (3-5 words) e.g., 'Thesis-Antithesis Dialectic', 'Premises Supporting Conclusion', 'Conceptual Dependency Chain'",
    "dialecticalRelation": "One sentence describing how these claims relate dialectically",
    "argumentativeFlow": "How arguments flow between these nodes (e.g., 'Node A provides grounds for Node B')",
    "conceptualBridge": "The key concept or term that connects these nodes",
    "tension": "Any philosophical tension or contradiction between the nodes",
    "synthesis": "If applicable, what synthesis emerges from considering these nodes together"
  }` : ''}
}

${multipleNodes ? `IMPORTANT: The relationshipAnalysis must reflect YOUR scholarly analysis of how these specific philosophical claims relate to each other based on their CONTENT, not just their types. Consider:
- Are they premises building toward a conclusion?
- Is one an objection to another?
- Do they represent different aspects of the same problem?
- Is there a dialectical progression (thesis â†’ antithesis â†’ synthesis)?
- Do they share conceptual dependencies?` : ''}

Return ONLY the JSON object, no other text.`
                };
            } else {
                // Generic pattern - McKinsey-style structured analysis
                return {
                    system: `You are a senior management consultant with 15 years at McKinsey & Company specializing in project risk assessment and work breakdown structures within TreeListy, a hierarchical project decomposition tool.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TREELISTY CONTEXT (Important for output structure)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TREE STRUCTURE: Root â†’ Phases (children) â†’ Items (items) â†’ Subtasks (subItems)
- Each node has: id, name, type, icon, description, and pattern-specific fields
- Generic pattern fields: cost, leadTime, dependencies
- SubItems appear as collapsible nested content under their parent item
- TreeListy supports 21 patterns including: Sales Pipeline, Product Roadmap, Course, Book, Film Production, Gmail Workflow, Free Speech, LifeTree (biographies), and more

PURPOSE: Your enriched output will be integrated back into the tree, adding depth and rigor to the user's project analysis. The subItems you generate become visible nested content that can be further expanded.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Your expertise includes: RAID analysis (Risks, Assumptions, Issues, Dependencies), RACI matrix construction, Critical Path Method, stakeholder impact assessment, and ANALYZING INTERDEPENDENCIES between project components.

SubItem types to generate:
- "risk-factor" (âš ï¸): Specific risks with probability/impact assessment
- "dependency" (ğŸ”—): Hard dependencies with named stakeholders/systems
- "assumption" (ğŸ’­): Hidden assumptions that could invalidate the approach
- "subtask" (âœ…): Actionable work items with clear ownership
- "constraint" (ğŸš«): Resource, time, or regulatory limitations
- "success-metric" (ğŸ“Š): Measurable outcomes and KPIs

Return ONLY valid JSON. No markdown, no explanations.`,

                    user: `Analyze these project items using RAID methodology and enrich with structured analysis.

PROJECT: ${treeContext.projectName}
PATTERN: ${treeContext.pattern}

ITEMS TO ANALYZE:
${nodesJson}

Return a JSON array with the SAME item IDs, enriched with:
1. Any missing fields you can infer
2. subItems: Array of 2-4 structured analysis items using the types above

Each subItem needs: id (generate unique), name, type (one of: risk-factor, dependency, assumption, subtask, constraint, success-metric), itemType, description, icon (use emoji matching type)

Include severity/priority where applicable: "high", "medium", "low"

Return ONLY the JSON array.`
                };
            }
        }

        // Call AI for deep dive analysis
        async function callDeepDiveAI(prompt, isPhilosophy) {
            // Use the existing unified AI infrastructure (callClaudeAPI handles all providers)
            const aiProvider = document.getElementById('ai-provider')?.value || 'gemini';
            const modelSelect = document.getElementById('ai-model-select');
            const selectedModel = modelSelect?.value || '';

            console.log(`Deep Dive using ${aiProvider} (${selectedModel})`);

            // callClaudeAPI is the unified wrapper that routes to Gemini/OpenAI/Claude
            // based on the selected provider in the UI
            const maxTokens = 4096; // Allow room for detailed subItems
            const useExtendedThinking = false; // Fast mode for now

            return await callClaudeAPI(prompt.user, prompt.system, maxTokens, useExtendedThinking);
        }

        // Parse AI response and extract enriched nodes + relationship analysis
        function parseDeepDiveResponse(response, originalNodes) {
            try {
                // Try to extract JSON from response
                let jsonStr = response;

                // Remove markdown code blocks if present
                if (jsonStr.includes('```json')) {
                    jsonStr = jsonStr.replace(/```json\s*/g, '').replace(/```\s*/g, '');
                } else if (jsonStr.includes('```')) {
                    jsonStr = jsonStr.replace(/```\s*/g, '');
                }

                // Trim whitespace
                jsonStr = jsonStr.trim();

                // Parse JSON
                const parsedData = JSON.parse(jsonStr);

                // Handle new structure with enrichedNodes + relationshipAnalysis
                let enrichedData;
                let relationshipAnalysis = null;

                if (parsedData.enrichedNodes) {
                    // New format: { enrichedNodes: [...], relationshipAnalysis: {...} }
                    enrichedData = parsedData.enrichedNodes;
                    relationshipAnalysis = parsedData.relationshipAnalysis || null;
                    console.log('ğŸ”— AI Relationship Analysis:', relationshipAnalysis);
                } else if (Array.isArray(parsedData)) {
                    // Legacy format: just an array
                    enrichedData = parsedData;
                } else {
                    // Single object, wrap it
                    console.warn('Deep Dive response is not expected format, wrapping...');
                    enrichedData = [parsedData];
                }

                // Map enriched data back to original node IDs
                const mappedNodes = enrichedData.map(enriched => {
                    // Try to match by ID or name
                    const matchingOriginal = originalNodes.find(
                        orig => orig.id === enriched.id || orig.name === enriched.name
                    );

                    if (matchingOriginal) {
                        return {
                            id: matchingOriginal.id,
                            speaker: enriched.speaker,
                            keyTerms: enriched.keyTerms,
                            textualReference: enriched.textualReference,
                            argumentType: enriched.argumentType,
                            subItems: enriched.subItems || []
                        };
                    }
                    return enriched;
                });

                // Return both enriched nodes and relationship analysis
                return {
                    nodes: mappedNodes,
                    relationshipAnalysis: relationshipAnalysis
                };

            } catch (parseError) {
                console.error('Failed to parse Deep Dive response:', parseError);
                console.log('Raw response:', response);
                throw new Error('AI response was not valid JSON. Please try again.');
            }
        }

        // Edit modal save/cancel handlers
        document.getElementById('edit-save').addEventListener('click', () => {
            if (activeNode) {
                // Save state for undo
                saveState(`Edit ${activeNode.type}: ${activeNode.name}`);

                // Save universal fields
                activeNode.name = document.getElementById('edit-name').value;
                activeNode.description = document.getElementById('edit-description').value;
                activeNode.icon = document.getElementById('edit-icon').value;
                activeNode.itemType = document.getElementById('edit-type').value;
                activeNode.notes = document.getElementById('edit-notes').value;

                // Save collaboration fields
                const collabComments = document.getElementById('edit-collab-comments');
                const contributor = document.getElementById('edit-contributor');
                if (collabComments) activeNode.collabComments = collabComments.value;
                if (contributor && contributor.value) {
                    activeNode.contributor = contributor.value;
                    activeNode.contributorTimestamp = new Date().toISOString();
                }

                // Save pattern-specific fields dynamically
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    const fieldElement = document.getElementById(`edit-${fieldKey}`);
                    if (fieldElement) {
                        const fieldConfig = fields[fieldKey];
                        if (fieldConfig.type === 'number') {
                            activeNode[fieldKey] = parseInt(fieldElement.value) || 0;
                        } else {
                            activeNode[fieldKey] = fieldElement.value;
                        }
                    }
                });

                // Collect selected dependencies from checkboxes (conditional)
                if (fields.includeDependencies) {
                    const depCheckboxes = document.querySelectorAll('.dep-checkbox');
                    const selectedDeps = [];
                    depCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedDeps.push(checkbox.value);
                        }
                    });
                    activeNode.dependencies = selectedDeps;
                }

                // Save PM fields for subtasks
                if (activeNode.type === 'subtask') {
                    const pmStatus = document.getElementById('edit-pm-status');
                    const pmRAGStatus = document.getElementById('edit-pm-rag-status');
                    const pmOwnerEmail = document.getElementById('edit-pm-owner-email');
                    const pmStartDate = document.getElementById('edit-pm-start-date');
                    const pmDueDate = document.getElementById('edit-pm-due-date');
                    const pmProgress = document.getElementById('edit-pm-progress');
                    const pmPriority = document.getElementById('edit-pm-priority');
                    const pmEstimatedHours = document.getElementById('edit-pm-estimated-hours');
                    const pmActualHours = document.getElementById('edit-pm-actual-hours');
                    const pmRemainingHours = document.getElementById('edit-pm-remaining-hours');
                    const pmNotes = document.getElementById('edit-pm-notes');
                    const pmBlockingIssue = document.getElementById('edit-pm-blocking-issue');
                    const pmNextSteps = document.getElementById('edit-pm-next-steps');

                    if (pmStatus) activeNode.pmStatus = pmStatus.value;
                    if (pmRAGStatus) activeNode.pmRAGStatus = pmRAGStatus.value;
                    if (pmOwnerEmail) {
                        activeNode.pmOwnerEmail = pmOwnerEmail.value;
                        // Backward compatibility: also save as pmAssignee
                        activeNode.pmAssignee = pmOwnerEmail.value;
                    }
                    if (pmStartDate) activeNode.pmStartDate = pmStartDate.value;
                    if (pmDueDate) activeNode.pmDueDate = pmDueDate.value;
                    if (pmProgress) activeNode.pmProgress = parseInt(pmProgress.value) || 0;
                    if (pmPriority) activeNode.pmPriority = pmPriority.value;
                    if (pmEstimatedHours) activeNode.pmEstimatedHours = parseFloat(pmEstimatedHours.value) || 0;
                    if (pmActualHours) activeNode.pmActualHours = parseFloat(pmActualHours.value) || 0;
                    if (pmRemainingHours) {
                        // If remaining is explicitly set, use it; otherwise auto-calculate
                        const remValue = parseFloat(pmRemainingHours.value);
                        if (remValue > 0) {
                            activeNode.pmRemainingHours = remValue;
                        } else {
                            // Auto-calculate: Estimated - Actual
                            const est = parseFloat(pmEstimatedHours?.value) || 0;
                            const act = parseFloat(pmActualHours?.value) || 0;
                            activeNode.pmRemainingHours = Math.max(0, est - act);
                        }
                    }
                    if (pmNotes) activeNode.pmNotes = pmNotes.value;
                    if (pmBlockingIssue) activeNode.pmBlockingIssue = pmBlockingIssue.value;
                    if (pmNextSteps) activeNode.pmNextSteps = pmNextSteps.value;
                    // pmUpdates are managed separately via window.addUpdate and window.deleteUpdate
                }

                document.getElementById('edit-modal').style.display = 'none';
                render();
            }
        });

        document.getElementById('edit-cancel').addEventListener('click', () => {
            document.getElementById('edit-modal').style.display = 'none';
        });

        // JSON upload handler (BUILD 372: Also handles .treelisty bundles)
        document.getElementById('json-upload-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                // BUILD 372: Handle .treelisty bundle files
                if (file.name.endsWith('.treelisty')) {
                    await window.importTreelistyBundle(file);
                    e.target.value = '';
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const rawData = JSON.parse(event.target.result);

                        // Build 609: Smart JSON Normalization - fix structure before migration
                        const { tree: data, fixes } = normalizeTreeStructure(rawData);

                        // Migrate tree to current schema (Cognitive Citadel Foundation)
                        migrateTree(data);

                        // Validate basic structure
                        if (data.id && data.children) {
                            // BUILD 284: Check for newer LocalStorage version
                            const treeId = data.id || 'default';
                            const localStorageKey = `treelisty:tree:${treeId}`;
                            const localMetaKey = `treelisty:meta:${treeId}`;
                            const localTree = localStorage.getItem(localStorageKey);
                            const localMeta = localStorage.getItem(localMetaKey);

                            if (localTree && localMeta) {
                                try {
                                    const localMetaData = JSON.parse(localMeta);
                                    const fileLastModified = data.metadata?.lastModified || data.lastModified || 0;
                                    const localLastModified = localMetaData.lastModified || 0;

                                    // If local version is newer, show conflict dialog
                                    if (localLastModified > fileLastModified) {
                                        const localDate = new Date(localLastModified).toLocaleString();
                                        const fileDate = fileLastModified ? new Date(fileLastModified).toLocaleString() : 'Unknown';

                                        showVersionConflictDialog({
                                            treeId,
                                            treeName: data.name || 'Untitled',
                                            fileData: data,
                                            fileDate,
                                            localData: JSON.parse(localTree),
                                            localDate,
                                            localItemCount: localMetaData.itemCount || 0
                                        });
                                        e.target.value = '';
                                        return; // Don't load file yet - wait for user choice
                                    }
                                } catch (parseErr) {
                                    console.warn('Could not parse local metadata:', parseErr);
                                }
                            }

                            // No conflict - proceed with loading
                            loadTreeData(data);

                            // Build 609: Show normalization summary if fixes were made
                            const uniqueFixes = [...new Set(fixes)];
                            if (uniqueFixes.length > 0) {
                                const summary = uniqueFixes.slice(0, 3).join(', ') + (uniqueFixes.length > 3 ? '...' : '');
                                showToast(`Loaded: ${data.name || 'Tree'} (Fixed ${uniqueFixes.length}: ${summary})`, 'success');
                            } else {
                                showToast(`Loaded: ${data.name || 'Tree'}`, 'success');
                            }
                        } else {
                            alert('Invalid JSON structure. Must have "id" and "children" properties.');
                        }
                    } catch (err) {
                        alert('Error parsing JSON: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
            // Reset input
            e.target.value = '';
        });

        // Controls - Expand/Collapse by Level (BUILD 536)
        // Expand: unfold one level deeper each click
        // Collapse: fold one level (reduce deepest visible level by 1)
        const expandBtn = document.getElementById('expand-btn');
        const collapseBtn = document.getElementById('collapse-btn');

        // Helper: get all children of a node (handles different child key names)
        function getNodeChildren(node) {
            return [...(node.children || []), ...(node.items || []), ...(node.subItems || [])];
        }

        // Helper: check if node has expandable children
        function hasChildren(node) {
            return getNodeChildren(node).length > 0;
        }

        // Helper: collect nodes at each depth level that are visible (parent chain is expanded)
        function getNodesByLevel(root) {
            const levels = []; // levels[depth] = [nodes at that depth]

            function traverse(node, depth, parentExpanded) {
                if (!levels[depth]) levels[depth] = [];

                // Only include if visible (all ancestors expanded, or it's root)
                if (depth === 0 || parentExpanded) {
                    levels[depth].push(node);

                    // Traverse children if this node is expanded
                    if (node.expanded !== false) {
                        getNodeChildren(node).forEach(child => {
                            traverse(child, depth + 1, node.expanded !== false);
                        });
                    }
                }
            }

            traverse(root, 0, true);
            return levels;
        }

        // Helper: find deepest level with expanded nodes that have collapsed children
        function findDeepestExpandedLevel(root) {
            let maxDepth = -1;

            function traverse(node, depth, visible) {
                if (!visible) return;

                const children = getNodeChildren(node);
                const isExpanded = node.expanded !== false;

                if (isExpanded && children.length > 0) {
                    maxDepth = Math.max(maxDepth, depth);
                }

                if (isExpanded) {
                    children.forEach(child => traverse(child, depth + 1, true));
                }
            }

            traverse(root, 0, true);
            return maxDepth;
        }

        if (expandBtn) {
            expandBtn.addEventListener('click', () => {
                // Find visible nodes that are collapsed but have children - expand them
                let expandedAny = false;

                function expandOneLevel(node, depth, parentExpanded) {
                    if (!parentExpanded && depth > 0) return;

                    const children = getNodeChildren(node);
                    const isExpanded = node.expanded !== false;

                    // If this node is visible, expanded, and has collapsed children with their own children
                    if (isExpanded && children.length > 0) {
                        children.forEach(child => {
                            if (child.expanded === false && hasChildren(child)) {
                                child.expanded = true;
                                expandedAny = true;
                            }
                        });
                    }

                    // Continue traversing expanded nodes
                    if (isExpanded) {
                        children.forEach(child => expandOneLevel(child, depth + 1, true));
                    }
                }

                expandOneLevel(capexTree, 0, true);

                if (!expandedAny) {
                    showToast('ğŸ“‚ Fully expanded', 'info');
                }

                render();
            });
        }

        if (collapseBtn) {
            collapseBtn.addEventListener('click', () => {
                // Find the deepest level with expanded nodes and collapse them
                const deepestLevel = findDeepestExpandedLevel(capexTree);

                if (deepestLevel <= 0) {
                    showToast('ğŸ“ Fully collapsed', 'info');
                    render();
                    return;
                }

                let collapsedAny = false;

                function collapseAtDepth(node, depth, parentExpanded) {
                    if (!parentExpanded && depth > 0) return;

                    const children = getNodeChildren(node);
                    const isExpanded = node.expanded !== false;

                    // If at target depth and expanded with children, collapse
                    if (depth === deepestLevel && isExpanded && children.length > 0) {
                        node.expanded = false;
                        collapsedAny = true;
                        return; // Don't traverse deeper
                    }

                    // Continue traversing if expanded
                    if (isExpanded) {
                        children.forEach(child => collapseAtDepth(child, depth + 1, true));
                    }
                }

                collapseAtDepth(capexTree, 0, true);
                render();
            });
        }

        // Search functionality
        document.getElementById('search-btn').addEventListener('click', () => {
            const modal = document.getElementById('search-modal');
            modal.style.display = 'flex';
            document.getElementById('search-input').focus();
        });

        document.getElementById('close-search-modal').addEventListener('click', () => {
            document.getElementById('search-modal').style.display = 'none';
        });

        // Recursive search function
        function searchNodes(query, node, path = [], results = []) {
            const queryLower = query.toLowerCase();

            // Helper to check if a value contains the query
            function matchesQuery(value) {
                if (value === null || value === undefined) return false;
                return String(value).toLowerCase().includes(queryLower);
            }

            // Search all fields in this node
            const matches = [];
            Object.keys(node).forEach(key => {
                // Skip non-searchable fields
                if (['children', 'items', 'subItems', 'dependencies', 'expanded', 'type', 'canvasX', 'canvasY'].includes(key)) {
                    return;
                }

                if (matchesQuery(node[key])) {
                    matches.push({ field: key, value: node[key] });
                }
            });

            // If this node has matches, add it to results
            if (matches.length > 0) {
                results.push({
                    node: node,
                    path: path,
                    matches: matches
                });
            }

            // Recursively search children (support both standard and filesystem patterns)
            const childList = node.children || node.items || node.subItems || [];
            childList.forEach((child, idx) => {
                searchNodes(query, child, [...path, { name: node.name || node.id, index: idx }], results);
            });

            return results;
        }

        // Perform search and display results
        function performSearch() {
            const query = document.getElementById('search-input').value.trim();
            const resultsContainer = document.getElementById('search-results');
            const emptyState = document.getElementById('search-results-empty');

            if (!query) {
                resultsContainer.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }

            const results = [];

            // Search through all phases
            if (capexTree.children) {
                capexTree.children.forEach((phase, phaseIdx) => {
                    // Search the phase itself
                    searchNodes(query, phase, [{ name: capexTree.name, index: phaseIdx }], results);
                });
            }

            // Display results
            if (results.length === 0) {
                resultsContainer.style.display = 'none';
                emptyState.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 12px;">ğŸ¤·</div>
                    <div style="font-size: 14px;">No results found for "${query}"</div>
                `;
                emptyState.style.display = 'block';
            } else {
                emptyState.style.display = 'none';
                resultsContainer.style.display = 'block';

                resultsContainer.innerHTML = `
                    <div style="margin-bottom: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px;">
                        <strong style="color: var(--treeplex-primary);">${results.length}</strong> result${results.length !== 1 ? 's' : ''} found
                    </div>
                    ${results.map((result, idx) => {
                        const pathStr = result.path.map(p => p.name).join(' â†’ ') + ' â†’ ' + result.node.name;
                        const matchesHtml = result.matches.map(m => {
                            const value = String(m.value).substring(0, 200);
                            return `<div style="margin: 4px 0;"><strong>${m.field}:</strong> ${highlightMatch(value, query)}</div>`;
                        }).join('');

                        return `
                            <div class="search-result-item" data-node-id="${result.node.id}" style="padding: 12px 16px; margin-bottom: 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px; display: flex; align-items: center; gap: 8px;">
                                    ${result.node.icon || 'ğŸ“„'} ${result.node.name}
                                </div>
                                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                                    ${pathStr}
                                </div>
                                <div style="font-size: 13px; color: var(--text-primary); padding: 8px; background: var(--bg-secondary); border-radius: 4px;">
                                    ${matchesHtml}
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;

                // Add click handlers to results
                resultsContainer.querySelectorAll('.search-result-item').forEach((el, idx) => {
                    el.addEventListener('click', () => {
                        const nodeId = el.dataset.nodeId;
                        // Close search modal
                        document.getElementById('search-modal').style.display = 'none';
                        // Highlight and scroll to the node
                        highlightNode(nodeId);
                    });

                    // Hover effect
                    el.addEventListener('mouseenter', () => {
                        el.style.borderColor = 'var(--treeplex-primary)';
                        el.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                    el.addEventListener('mouseleave', () => {
                        el.style.borderColor = 'var(--border)';
                        el.style.background = 'var(--card-bg)';
                    });
                });
            }
        }

        // Highlight matched text
        function highlightMatch(text, query) {
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<mark style="background: rgba(255, 187, 0, 0.3); padding: 2px 4px; border-radius: 3px; font-weight: 600;">$1</mark>');
        }

        // Highlight node in tree view and show info panel
        function highlightNode(nodeId) {
            let foundNode = null;

            // Find and expand ancestors to make node visible
            function findAndExpandNode(node, targetId, ancestors = []) {
                if (node.id === targetId) {
                    foundNode = node;
                    // Expand all ancestors
                    ancestors.forEach(ancestor => {
                        ancestor.expanded = true;
                    });
                    return true;
                }

                // Recursively search children
                const childList = node.children || node.items || node.subItems || [];
                for (const child of childList) {
                    if (findAndExpandNode(child, targetId, [...ancestors, node])) {
                        return true;
                    }
                }
                return false;
            }

            // Search through all phases
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    if (findAndExpandNode(phase, nodeId, [capexTree])) {
                        break;
                    }
                }
            }

            // Also check root
            if (!foundNode && capexTree.id === nodeId) {
                foundNode = capexTree;
            }

            if (foundNode) {
                // Re-render tree with expanded ancestors
                render();

                // Show the info panel for this node
                if (typeof showInfo === 'function') {
                    showInfo(foundNode);
                }

                // Select the node
                selectedNodes = [foundNode];

                // Scroll to node after render
                setTimeout(() => {
                    const nodeEl = document.querySelector(`[data-item-id="${nodeId}"]`);
                    if (nodeEl) {
                        nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Flash highlight
                        nodeEl.style.background = 'rgba(99, 102, 241, 0.3)';
                        nodeEl.style.boxShadow = '0 0 0 2px var(--treeplex-primary)';
                        nodeEl.style.transition = 'all 0.3s';
                        setTimeout(() => {
                            nodeEl.style.background = '';
                            nodeEl.style.boxShadow = '';
                        }, 2000);
                    }
                }, 150);
            }
        }

        // Search on input
        const searchInput = document.getElementById('search-input');
        searchInput.addEventListener('input', debounce(performSearch, 300));
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });

        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Save and Load JSON buttons in console
        // New Project button - Start fresh
        document.getElementById('new-project-btn').addEventListener('click', () => {
            // Check if LifeTree pattern - needs special initialization
            if (currentPattern === 'lifetree') {
                showLifeTreeInitModal();
                return;
            }

            const confirmNew = confirm(
                'ğŸ†• Start New Project?\n\n' +
                'This will clear your current project.\n\n' +
                'Make sure to save first if you want to keep your work!'
            );

            if (confirmNew) {
                createNewProject();
            }
        });

        /**
         * BUILD 365: LifeTree initialization modal
         * Collects subject name, birth year, and living status
         */
        function showLifeTreeInitModal() {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'ğŸŒ³ Start a New LifeTree';

            const currentYear = new Date().getFullYear();

            modalBody.innerHTML = `
                <div style="padding: 24px; max-width: 480px;">
                    <p style="color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6;">
                        A LifeTree is a biographical timeline. Let's start with the basics.
                    </p>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                            Whose life is this? *
                        </label>
                        <input type="text" id="lifetree-subject-name" placeholder="e.g., Mom, Grandpa Joe, Marie Curie..."
                            style="width: 100%; padding: 12px; font-size: 16px; background: #1e293b; border: 1px solid var(--border-color); border-radius: 8px; color: #f8fafc;">
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                                Birth Year *
                            </label>
                            <input type="number" id="lifetree-birth-year" placeholder="${currentYear - 70}"
                                min="-3000" max="${currentYear}"
                                style="width: 100%; padding: 12px; font-size: 16px; background: #1e293b; border: 1px solid var(--border-color); border-radius: 8px; color: #f8fafc;">
                            <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                                Use negative for BC (e.g., -428 for Plato)
                            </div>
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                                Still Living?
                            </label>
                            <select id="lifetree-living-status"
                                style="width: 100%; padding: 12px; font-size: 16px; background: #1e293b; border: 1px solid var(--border-color); border-radius: 8px; color: #f8fafc;">
                                <option value="living">Yes, still living</option>
                                <option value="deceased">No, passed away</option>
                            </select>
                        </div>
                    </div>

                    <div id="lifetree-death-year-container" style="display: none; margin-bottom: 20px;">
                        <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                            Year of Passing
                        </label>
                        <input type="number" id="lifetree-death-year" placeholder="${currentYear}"
                            min="-3000" max="${currentYear}"
                            style="width: 100%; padding: 12px; font-size: 16px; background: #1e293b; border: 1px solid var(--border-color); border-radius: 8px; color: #f8fafc;">
                    </div>

                    <div style="padding: 16px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px; margin-bottom: 20px;">
                        <div style="font-size: 12px; color: #a78bfa; margin-bottom: 8px;">ğŸ’¡ What happens next</div>
                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                            TreeBeard will help you build the timeline by asking about key life events,
                            family members, and memories. You can also add events and photos anytime.
                        </div>
                    </div>
                </div>
            `;

            // Show/hide death year based on selection
            setTimeout(() => {
                const livingSelect = document.getElementById('lifetree-living-status');
                const deathContainer = document.getElementById('lifetree-death-year-container');
                livingSelect?.addEventListener('change', () => {
                    deathContainer.style.display = livingSelect.value === 'deceased' ? 'block' : 'none';
                });
            }, 100);

            document.querySelector('#modal .modal-footer').innerHTML = `
                <button class="btn" onclick="document.getElementById('modal').style.display='none'">Cancel</button>
                <button class="btn btn-primary" onclick="createLifeTree()">ğŸŒ³ Create LifeTree</button>
            `;

            modal.style.display = 'flex';
        }

        /**
         * BUILD 365: Create LifeTree with decades generated from birth year
         */
        function createLifeTree() {
            const subjectName = document.getElementById('lifetree-subject-name')?.value?.trim();
            const birthYear = parseInt(document.getElementById('lifetree-birth-year')?.value);
            const livingStatus = document.getElementById('lifetree-living-status')?.value;
            const deathYear = livingStatus === 'deceased'
                ? parseInt(document.getElementById('lifetree-death-year')?.value)
                : null;

            // Validation
            if (!subjectName) {
                showToast('Please enter a name', 'error');
                return;
            }
            if (isNaN(birthYear)) {
                showToast('Please enter a birth year', 'error');
                return;
            }
            if (livingStatus === 'deceased' && isNaN(deathYear)) {
                showToast('Please enter year of passing', 'error');
                return;
            }

            saveState('New LifeTree');

            // Generate decades from birth year to now (or death year)
            const currentYear = new Date().getFullYear();
            const endYear = deathYear || currentYear;
            const decades = generateDecades(birthYear, endYear);

            const pattern = PATTERNS.lifetree;
            const levels = pattern.levels;

            // Create birth event as first item
            const birthEvent = {
                id: 'event-birth-' + Date.now(),
                name: `${subjectName} was born`,
                description: '',
                icon: 'ğŸ‘¶',
                itemType: 'birth',
                type: 'item',
                eventDate: birthYear.toString(),
                age: 0,
                location: '',
                people: '',
                emotion: 'Milestone',
                source: '',
                confidence: 'Exact',
                dependencies: [],
                subItems: [],
                expanded: true
            };

            // Build decade phases
            const decadePhases = decades.map((decade, idx) => ({
                id: `phase-${idx}`,
                name: decade.label,
                subtitle: decade.subtitle,
                type: 'phase',
                phase: idx,
                icon: decade.icon,
                expanded: idx === 0, // Expand first decade
                items: idx === 0 ? [birthEvent] : [],
                children: []
            }));

            // Create the LifeTree
            capexTree = {
                id: 'root',
                name: `${subjectName}'s Life`,
                type: 'root',
                icon: 'ğŸŒ³',
                expanded: true,
                children: decadePhases,
                pattern: {
                    key: 'lifetree',
                    labels: levels
                },
                // LifeTree-specific metadata
                lifetree: {
                    subjectName: subjectName,
                    birthYear: birthYear,
                    deathYear: deathYear,
                    isLiving: livingStatus === 'living',
                    people: [] // Will store relationship data
                }
            };

            document.getElementById('modal').style.display = 'none';
            render();
            renderCanvas();
            showToast(`ğŸŒ³ ${subjectName}'s LifeTree created!`, 'success');
            console.log(`ğŸŒ³ LifeTree created for ${subjectName}, born ${birthYear}`);

            // Open TreeBeard to start guided interview
            setTimeout(() => {
                const treebeard = document.getElementById('treebeard-panel');
                if (treebeard && !treebeard.classList.contains('open')) {
                    treebeard.classList.add('open');
                }
                // Add welcome message
                if (typeof addMessage === 'function') {
                    addMessage(
                        `ğŸŒ³ Welcome to ${subjectName}'s LifeTree!\n\n` +
                        `I've created decades from ${formatDecadeYear(birthYear)} to ${formatDecadeYear(endYear)}.\n\n` +
                        `Let's start filling in the story. You can:\n` +
                        `â€¢ Tell me a memory or story\n` +
                        `â€¢ Drop in a photo\n` +
                        `â€¢ Answer my questions\n\n` +
                        `**First question:** Who were ${subjectName}'s parents?`,
                        'assistant'
                    );
                }
            }, 500);
        }

        /**
         * BUILD 365: Generate decade phases from birth to end year
         */
        function generateDecades(birthYear, endYear) {
            const decades = [];
            const isBC = birthYear < 0;

            // Round birth year down to decade start
            const startDecade = Math.floor(birthYear / 10) * 10;
            const endDecade = Math.floor(endYear / 10) * 10;

            const decadeIcons = ['ğŸ‘¶', 'ğŸ’’', 'ğŸ§’', 'ğŸ“', 'ğŸ’¼', 'ğŸ ', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§', 'ğŸŒŸ', 'ğŸ“š', 'ğŸ„', 'ğŸŒ…', 'âœ¨'];

            if (isBC) {
                // BC years go backwards (higher numbers are earlier)
                for (let d = startDecade; d >= endDecade; d -= 10) {
                    const idx = decades.length;
                    decades.push({
                        label: `${Math.abs(d)}s BC`,
                        subtitle: getDecadeSubtitle(birthYear, d, idx),
                        icon: decadeIcons[idx % decadeIcons.length]
                    });
                }
            } else {
                for (let d = startDecade; d <= endDecade; d += 10) {
                    const idx = decades.length;
                    decades.push({
                        label: `${d}s`,
                        subtitle: getDecadeSubtitle(birthYear, d, idx),
                        icon: decadeIcons[idx % decadeIcons.length]
                    });
                }
            }

            return decades;
        }

        /**
         * Get appropriate subtitle for a decade based on age
         */
        function getDecadeSubtitle(birthYear, decadeStart, idx) {
            const ageAtDecadeStart = Math.abs(decadeStart - birthYear);
            if (ageAtDecadeStart < 10) return 'Childhood';
            if (ageAtDecadeStart < 20) return 'Teen Years';
            if (ageAtDecadeStart < 30) return 'Twenties';
            if (ageAtDecadeStart < 40) return 'Thirties';
            if (ageAtDecadeStart < 50) return 'Forties';
            if (ageAtDecadeStart < 60) return 'Fifties';
            if (ageAtDecadeStart < 70) return 'Sixties';
            if (ageAtDecadeStart < 80) return 'Seventies';
            if (ageAtDecadeStart < 90) return 'Eighties';
            return 'Golden Years';
        }

        /**
         * Format year for display (handles BC)
         */
        function formatDecadeYear(year) {
            if (year < 0) return `${Math.abs(year)} BC`;
            return year.toString();
        }

        /**
         * Standard new project creation (non-LifeTree patterns)
         */
        function createNewProject() {
            saveState('New Project');

            // Use current pattern from dropdown (pattern-aware)
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;
            const fields = pattern.fields || {};

            // Build starter item with only pattern-specific fields
            const starterItem = {
                id: 'item-' + Date.now(),
                name: `New ${levels.item}`,
                description: 'Enter description',
                icon: 'ğŸ“¦',
                itemType: '',
                type: 'item',
                dependencies: [],
                subItems: [],
                expanded: true
            };

            // Add pattern-specific fields
            Object.keys(fields).forEach(fieldKey => {
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return; // Skip meta fields
                }

                const fieldConfig = fields[fieldKey];

                // Set default values based on field type
                if (fieldConfig.type === 'number') {
                    starterItem[fieldKey] = 0;
                } else if (fieldConfig.type === 'date') {
                    starterItem[fieldKey] = '';
                } else if (fieldConfig.type === 'select') {
                    starterItem[fieldKey] = '';
                } else if (fieldConfig.type === 'textarea') {
                    starterItem[fieldKey] = '';
                } else {
                    starterItem[fieldKey] = '';
                }
            });

            // Reset to fresh tree with pattern-specific structure
            capexTree = {
                id: 'root',
                name: `My ${levels.root}`,
                type: 'root',
                icon: pattern.icon,
                expanded: true,
                children: [
                    {
                        id: 'phase-0',
                        name: `${levels.phase} 0`,
                        subtitle: pattern.phaseSubtitles ? pattern.phaseSubtitles[0] : '',
                        type: 'phase',
                        phase: 0,
                        icon: '1ï¸âƒ£',
                        expanded: true,
                        items: [starterItem],
                        children: []
                    }
                ],
                pattern: {
                    key: currentPattern,
                    labels: levels
                }
            };

            render();
            renderCanvas();  // Also update canvas view if visible
            showToast(`âœ… New ${pattern.name} project started!`);
            console.log(`ğŸ†• New ${pattern.name} project created`);
        }

        document.getElementById('save-json-btn').addEventListener('click', handleDownload);
        document.getElementById('load-json-btn').addEventListener('click', handleUpload);

        // Share button - Generate shareable URL
        document.getElementById('share-btn').addEventListener('click', async () => {
            const shareableURL = await generateShareableURL();
            updateShareModal(shareableURL);
        });

        // Helper to update share modal with URL and warnings
        function updateShareModal(shareableURL) {
            const modal = document.getElementById('share-modal');
            const urlInput = document.getElementById('share-url-input');
            urlInput.value = shareableURL;

            // Update stats
            const nodeCount = countAllNodes(capexTree);
            document.getElementById('share-node-count').textContent = nodeCount;
            document.getElementById('share-url-length').textContent = shareableURL.length.toLocaleString();

            // Show appropriate warning based on URL length
            const warning = document.getElementById('share-size-warning');
            const criticalWarning = document.getElementById('share-critical-warning');
            const urlKb = document.getElementById('share-url-kb');

            // Reset warnings
            warning.style.display = 'none';
            criticalWarning.style.display = 'none';

            if (shareableURL.length > 8000) {
                // Critical: URL will definitely fail
                urlKb.textContent = (shareableURL.length / 1024).toFixed(1);
                criticalWarning.style.display = 'block';
            } else if (shareableURL.length > 2500) {
                // Warning: URL may fail in email/chat apps
                warning.style.display = 'block';
            }

            modal.style.display = 'flex';

            // Select the URL text for easy copying
            setTimeout(() => urlInput.select(), 100);
        }

        // Generate lite shareable URL (strips non-essential data)
        async function generateLiteShareableURL() {
            // Lazy load LZ-String library
            await loadLibrary('lzstring');

            // Create stripped copy of tree
            function stripNode(node) {
                const stripped = {
                    id: node.id,
                    name: node.name,
                    type: node.type
                };
                // Keep essential fields only
                if (node.icon) stripped.icon = node.icon;
                if (node.phase !== undefined) stripped.phase = node.phase;
                if (node.cost) stripped.cost = node.cost;
                if (node.pmProgress) stripped.pmProgress = node.pmProgress;
                if (node.pmStatus) stripped.pmStatus = node.pmStatus;
                if (node.pmDueDate) stripped.pmDueDate = node.pmDueDate;
                if (node.expanded) stripped.expanded = node.expanded;
                // Recurse children/items/subtasks
                if (node.children) stripped.children = node.children.map(stripNode);
                if (node.items) stripped.items = node.items.map(stripNode);
                if (node.subtasks) stripped.subtasks = node.subtasks.map(stripNode);
                return stripped;
            }

            const liteTree = stripNode(capexTree);
            // Keep pattern
            if (capexTree.pattern) liteTree.pattern = capexTree.pattern;

            const jsonData = JSON.stringify(liteTree);
            const compressed = LZString.compressToEncodedURIComponent(jsonData);
            const baseURL = window.location.origin + window.location.pathname;

            console.log(`ğŸ“¦ Lite share: ${jsonData.length} chars JSON â†’ ${compressed.length} chars compressed`);
            return `${baseURL}?p=${compressed}`;
        }

        // Lite share button handler (shared logic for both buttons)
        async function handleLiteShare() {
            const liteURL = await generateLiteShareableURL();
            const urlInput = document.getElementById('share-url-input');
            urlInput.value = liteURL;
            document.getElementById('share-url-length').textContent = liteURL.length.toLocaleString();

            // Update warnings
            const warning = document.getElementById('share-size-warning');
            const criticalWarning = document.getElementById('share-critical-warning');
            const urlKb = document.getElementById('share-url-kb');

            if (liteURL.length <= 2500) {
                warning.style.display = 'none';
                criticalWarning.style.display = 'none';
                showToast('âœ… Lite URL generated - safe to share!', 'success');
            } else if (liteURL.length <= 8000) {
                warning.style.display = 'block';
                criticalWarning.style.display = 'none';
                showToast('âš ï¸ Lite URL still long - may have issues in email', 'info');
            } else {
                urlKb.textContent = (liteURL.length / 1024).toFixed(1);
                warning.style.display = 'none';
                criticalWarning.style.display = 'block';
                showToast('âŒ Project too large even for lite sharing - use JSON export', 'error');
            }

            // Select the URL
            setTimeout(() => urlInput.select(), 100);
        }

        // Attach to both lite share buttons
        document.getElementById('share-lite-btn')?.addEventListener('click', handleLiteShare);
        document.getElementById('share-lite-btn-critical')?.addEventListener('click', handleLiteShare);

        // Share modal - Copy button
        document.getElementById('copy-share-url').addEventListener('click', () => {
            const urlInput = document.getElementById('share-url-input');
            urlInput.select();
            document.execCommand('copy');

            // Change button text temporarily
            const btn = document.getElementById('copy-share-url');
            const originalText = btn.textContent;
            btn.textContent = 'âœ… Copied!';
            btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';

            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
            }, 2000);
        });

        // Share modal - Open in new tab button
        document.getElementById('open-share-url').addEventListener('click', () => {
            const url = document.getElementById('share-url-input').value;
            window.open(url, '_blank');
        });

        // Share modal - Close button
        document.getElementById('share-close').addEventListener('click', () => {
            document.getElementById('share-modal').style.display = 'none';
        });

        // =============================================================================
        // CLOUD SHARE (Firebase Short URLs)
        // =============================================================================

        // Generate a short random ID (7 chars, alphanumeric)
        function generateShortId() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
            let id = '';
            for (let i = 0; i < 7; i++) {
                id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return id;
        }

        // Save tree to Firebase and return short URL
        async function saveTreeToCloud() {
            if (!window.firebaseReady) {
                throw new Error('Firebase not ready - please refresh the page');
            }

            // Ensure user is authenticated (anonymous auth)
            const auth = window.firebaseAuth;
            if (!auth.currentUser) {
                console.log('â˜ï¸ Cloud Share: Signing in anonymously...');
                try {
                    await window.firebaseSignInAnonymously(auth);
                    console.log('â˜ï¸ Cloud Share: Anonymous auth successful');
                } catch (authError) {
                    console.error('â˜ï¸ Cloud Share auth failed:', authError);
                    throw new Error('Authentication failed - please try again');
                }
            }

            // Check tree size (Firestore limit is 1MB)
            const treeJson = JSON.stringify(capexTree);
            if (treeJson.length > 900000) {
                throw new Error('Tree too large for cloud sharing (max ~900KB)');
            }

            const shareId = generateShortId();
            const db = window.firebaseDb;
            const doc = window.firebaseDoc;
            const setDoc = window.firebaseSetDoc;
            const serverTimestamp = window.firebaseServerTimestamp;

            await setDoc(doc(db, 'shared', shareId), {
                tree: capexTree,
                created: serverTimestamp(),
                name: capexTree.name || 'Untitled',
                nodeCount: countAllNodes(capexTree),
                pattern: capexTree.pattern?.key || 'generic',
                createdBy: auth.currentUser?.uid || 'anonymous'
            });

            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?share=${shareId}`;
        }

        // Load shared tree from Firebase
        async function loadSharedTree(shareId) {
            if (!window.firebaseReady) {
                console.warn('Firebase not ready, waiting...');
                await new Promise(resolve => setTimeout(resolve, 1000));
                if (!window.firebaseReady) {
                    throw new Error('Firebase failed to initialize');
                }
            }

            const db = window.firebaseDb;
            const doc = window.firebaseDoc;
            const getDoc = window.firebaseGetDoc;

            const snapshot = await getDoc(doc(db, 'shared', shareId));
            if (!snapshot.exists()) {
                throw new Error('Shared tree not found or expired');
            }

            return snapshot.data().tree;
        }

        // Cloud share button handler
        document.getElementById('cloud-share-btn')?.addEventListener('click', async () => {
            const btn = document.getElementById('cloud-share-btn');
            const originalText = btn.innerHTML;
            const errorDiv = document.getElementById('cloud-share-error');
            const errorMsg = document.getElementById('cloud-share-error-msg');
            const resultDiv = document.getElementById('cloud-share-result');

            // Reset state
            errorDiv.style.display = 'none';
            resultDiv.style.display = 'none';
            btn.innerHTML = '<span>â³</span> Creating link...';
            btn.disabled = true;

            try {
                const cloudUrl = await saveTreeToCloud();

                // Show result
                resultDiv.style.display = 'block';
                document.getElementById('cloud-share-url').value = cloudUrl;

                btn.innerHTML = '<span>âœ…</span> Link Created!';
                btn.style.background = 'linear-gradient(135deg, #059669, #047857)';

                showToast('â˜ï¸ Cloud link created!', 'success');

                // Select the URL for easy copying
                setTimeout(() => {
                    document.getElementById('cloud-share-url').select();
                }, 100);

            } catch (error) {
                console.error('Cloud share failed:', error);
                btn.innerHTML = originalText;
                btn.disabled = false;

                // Show error in the error div
                errorDiv.style.display = 'block';
                errorMsg.textContent = 'âŒ ' + error.message;

                // Also show toast for visibility
                showToast('Cloud share failed - see details below', 'error');
            }
        });

        // Copy cloud URL button
        document.getElementById('copy-cloud-url')?.addEventListener('click', () => {
            const urlInput = document.getElementById('cloud-share-url');
            urlInput.select();
            document.execCommand('copy');

            const btn = document.getElementById('copy-cloud-url');
            const originalText = btn.textContent;
            btn.textContent = 'âœ… Copied!';

            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        });

        // Check for ?share= parameter on page load
        async function checkForSharedTree() {
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');

            if (!shareId) return false;

            try {
                showToast('â˜ï¸ Loading shared project...', 'info');

                const sharedTree = await loadSharedTree(shareId);

                // Load the tree
                Object.assign(capexTree, sharedTree);

                // Update pattern if specified
                if (capexTree.pattern) {
                    const patternKey = typeof capexTree.pattern === 'string'
                        ? capexTree.pattern
                        : capexTree.pattern.key || 'generic';
                    currentPattern = patternKey;
                    const patternSelect = document.getElementById('pattern-select');
                    if (patternSelect) patternSelect.value = patternKey;
                }

                // Render the tree
                render();
                showToast(`âœ… Loaded: ${capexTree.name || 'Shared Project'}`, 'success');

                // Clear the URL parameter (optional - keeps URL clean)
                const cleanUrl = window.location.origin + window.location.pathname;
                window.history.replaceState({}, document.title, cleanUrl);

                return true;
            } catch (error) {
                console.error('Failed to load shared tree:', error);
                showToast('âŒ ' + error.message, 'error');
                return false;
            }
        }

        // Hook into page initialization to check for shared trees
        window.checkForSharedTree = checkForSharedTree;

        // Generate shareable URL with compressed data
        async function generateShareableURL() {
            // Lazy load LZ-String library
            await loadLibrary('lzstring');

            // DEBUG: Check cost values before serialization
            if (capexTree.children && capexTree.children[0] && capexTree.children[0].items && capexTree.children[0].items[0]) {
                console.log('First item cost before stringify:', capexTree.children[0].items[0].cost);
            }

            const jsonData = JSON.stringify(capexTree);

            // DEBUG: Log first 500 chars of JSON
            console.log('JSON before compress (first 500 chars):', jsonData.substring(0, 500));

            const compressed = LZString.compressToEncodedURIComponent(jsonData);
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?p=${compressed}`;
        }

        // Count all nodes in tree (for stats)
        function countAllNodes(node) {
            let count = 1; // Count this node
            if (node.children) {
                node.children.forEach(child => {
                    if (child.items) {
                        count += child.items.length;
                        child.items.forEach(item => {
                            if (item.subtasks) {
                                count += item.subtasks.length;
                            }
                        });
                    } else {
                        count += countAllNodes(child);
                    }
                });
            }
            return count;
        }

        // =============================================================================
        // BUILD 427: DEBATE MODE
        // AI vs AI spectator debates with insight extraction
        // =============================================================================

        // Build 430: Debate styles (how they argue) - role (defend/challenge) assigned separately
        const DEBATE_STYLES = {
            scholarly: {
                name: "Scholar",
                icon: "ğŸ“š",
                stylePrompt: `Argue with academic rigor. Cite relevant concepts, historical context, and logical frameworks. Be precise and thorough.`
            },
            socratic: {
                name: "Socratic",
                icon: "ğŸ›ï¸",
                stylePrompt: `Use the Socratic method. Ask probing questions that expose assumptions or strengthen your position. Guide through questioning.`
            },
            passionate: {
                name: "Passionate",
                icon: "ğŸ”¥",
                stylePrompt: `Argue with conviction and rhetorical force. Use vivid language and emotional appeals alongside logic. Be persuasive.`
            },
            pragmatic: {
                name: "Pragmatist",
                icon: "âš–ï¸",
                stylePrompt: `Focus on practical implications and real-world consequences. What works? What are the concrete outcomes?`
            }
        };

        // Role prompts - these define the POSITION, not just the style
        const DEBATE_ROLES = {
            defender: {
                label: "Defender",
                rolePrompt: `You are DEFENDING this position with conviction. You believe in it deeply.

TACTICS:
- Directly rebut your opponent's last point before advancing your own
- Quote their words back at them when exposing their errors
- Vary your response length: sometimes a devastating one-liner, sometimes a thorough dismantling
- Use rhetorical questions to expose their contradictions
- Channel the original thinker's voice and arguments if applicable`
            },
            challenger: {
                label: "Challenger",
                rolePrompt: `You are ATTACKING this position relentlessly. Find every flaw.

TACTICS:
- Directly attack the weakest part of their last argument
- Don't let them get away with vague claims - demand specifics
- Vary your approach: sometimes quick jabs, sometimes sustained assault
- Use their own logic against them when possible
- Mock gently when they contradict themselves`
            }
        };

        // State machine: setup â†’ active â†’ extracting â†’ completed
        const DEBATE_STATES = {
            SETUP: 'setup',
            ACTIVE: 'active',
            EXTRACTING: 'extracting',
            COMPLETED: 'completed'
        };

        let currentDebate = null;
        let debateIsBusy = false;
        let autoPlayTimer = null;
        const AUTOPLAY_DELAY = 2500;
        const DEBATE_STORAGE_KEY = 'treelisty_debate_state';

        // State persistence
        function saveDebateState() {
            if (!currentDebate) {
                localStorage.removeItem(DEBATE_STORAGE_KEY);
                return;
            }
            const saveData = {
                ...currentDebate,
                sourceNodeId: currentDebate.sourceNode?.id || null,
                sourceNode: null
            };
            localStorage.setItem(DEBATE_STORAGE_KEY, JSON.stringify(saveData));
        }

        function restoreDebateState() {
            try {
                const saved = localStorage.getItem(DEBATE_STORAGE_KEY);
                if (!saved) return false;

                const data = JSON.parse(saved);
                if (data.status !== DEBATE_STATES.ACTIVE) {
                    localStorage.removeItem(DEBATE_STORAGE_KEY);
                    return false;
                }

                const sourceNode = findNodeById(data.sourceNodeId);
                if (!sourceNode) {
                    localStorage.removeItem(DEBATE_STORAGE_KEY);
                    return false;
                }

                currentDebate = { ...data, sourceNode };
                document.getElementById('debate-panel').classList.add('open');
                document.getElementById('debate-title').textContent = `Debate: ${currentDebate.topic}`;
                updateDebateTranscript();
                updateDebateTurnCounter();
                showToast('Restored previous debate session', 'info');
                return true;
            } catch (e) {
                console.error('Failed to restore debate:', e);
                localStorage.removeItem(DEBATE_STORAGE_KEY);
                return false;
            }
        }

        // UI Control locking
        function setDebateBusy(busy) {
            debateIsBusy = busy;
            const nextBtn = document.getElementById('debate-next-turn-btn');
            const endBtn = document.getElementById('debate-end-btn');
            const interjectBtn = document.getElementById('debate-interject-btn');
            const interjectInput = document.getElementById('debate-interject-input');

            if (nextBtn) nextBtn.disabled = busy;
            if (endBtn) endBtn.disabled = busy;
            if (interjectBtn) interjectBtn.disabled = busy;
            if (interjectInput) interjectInput.disabled = busy;
        }

        // Build 430: Combined role + style + pattern prompt
        function buildDebatePrompt(role, style) {
            const roleData = DEBATE_ROLES[role === 'a' ? 'defender' : 'challenger'];
            const styleData = style;
            const pattern = PATTERNS[currentPattern];
            const patternName = pattern?.name || 'general';
            const patternDesc = pattern?.description || '';

            return `${roleData.rolePrompt}

ARGUMENTATION STYLE: ${styleData.stylePrompt}

DOMAIN CONTEXT: This debate is in a "${patternName}" context. ${patternDesc}

VOICE REQUIREMENTS:
- Vary sentence structure: mix short punches with longer elaborations
- Use concrete examples and specifics, not abstractions
- Address your opponent directly ("You claim..." / "Your argument fails because...")
- Show intellectual respect while being devastating in critique`;
        }

        // Core debate functions
        function handleDebate() {
            if (!activeNode) return;
            document.getElementById('context-menu').style.display = 'none';
            showDebateSetup(activeNode);
        }

        function showDebateSetup(node) {
            const modal = document.getElementById('debate-setup-modal');
            const topicDisplay = document.getElementById('debate-topic-display');

            let topic = node.name;
            if (node.description) {
                topic += `: ${node.description.substring(0, 100)}`;
            }

            topicDisplay.textContent = topic;
            modal.classList.add('open');

            currentDebate = {
                sourceNodeId: node.id,  // Store ID for reliable lookup
                sourceNodeType: node.type,
                topic: node.name,
                context: node.description || '',
                status: DEBATE_STATES.SETUP,
                personas: { a: null, b: null },
                turns: [],
                maxRounds: 5,
                extractedInsights: []
            };
        }

        function startDebate() {
            const styleAKey = document.getElementById('debate-persona-a').value;
            const styleBKey = document.getElementById('debate-persona-b').value;
            const maxRounds = parseInt(document.getElementById('debate-rounds').value) || 0;

            // Build 430: Persona A = Defender, Persona B = Challenger (always opposed)
            const styleA = DEBATE_STYLES[styleAKey];
            const styleB = DEBATE_STYLES[styleBKey];

            currentDebate.personas = {
                a: {
                    key: styleAKey,
                    role: 'defender',
                    name: `Defender (${styleA.name})`,
                    icon: 'ğŸ›¡ï¸',
                    style: styleA
                },
                b: {
                    key: styleBKey,
                    role: 'challenger',
                    name: `Challenger (${styleB.name})`,
                    icon: 'âš”ï¸',
                    style: styleB
                }
            };
            currentDebate.maxRounds = maxRounds;
            currentDebate.status = DEBATE_STATES.ACTIVE;

            document.getElementById('debate-setup-modal').classList.remove('open');
            document.getElementById('debate-panel').classList.add('open');
            document.getElementById('debate-title').textContent = `Debate: ${currentDebate.topic}`;
            document.getElementById('debate-transcript').innerHTML = '';
            updateDebateTurnCounter();

            saveDebateState();
            getNextDebateTurn('a');
        }

        async function getNextDebateTurn(role) {
            if (!currentDebate || currentDebate.status !== DEBATE_STATES.ACTIVE) return;
            if (debateIsBusy) return;

            // Rounds enforcement
            if (currentDebate.maxRounds > 0 && currentDebate.turns.length >= currentDebate.maxRounds * 2) {
                showToast(`Debate complete! (${currentDebate.maxRounds} rounds)`, 'info');
                handleDebateEnd();
                return;
            }

            setDebateBusy(true);

            const persona = currentDebate.personas[role];
            const transcript = currentDebate.turns.map(t => {
                const speaker = t.role === 'user' ? 'USER' : currentDebate.personas[t.role].name;
                return `${speaker}: ${t.text}`;
            }).join('\n\n');

            // Build 430: Use role-aware prompt (defender vs challenger)
            const systemPrompt = buildDebatePrompt(role, persona.style);

            const roleLabel = role === 'a' ? 'DEFENDER' : 'CHALLENGER';
            const lastTurn = currentDebate.turns[currentDebate.turns.length - 1];
            const engagementPrompt = lastTurn
                ? `Your opponent just said: "${lastTurn.text.substring(0, 150)}${lastTurn.text.length > 150 ? '...' : ''}"\n\nRESPOND DIRECTLY to this. Don't ignore it.`
                : 'Open the debate with a strong opening statement.';

            const prompt = `Topic: "${currentDebate.topic}"
${currentDebate.context ? `Context: ${currentDebate.context}` : ''}

${transcript ? `DEBATE HISTORY:\n${transcript}\n\n` : ''}${engagementPrompt}

You are the ${roleLabel}. Be tactical. Vary your length (20-120 words). Make every word count.`;

            addDebateTurnLoading(role);

            try {
                const response = await callClaudeAPI(prompt, {
                    systemPrompt: systemPrompt,
                    temperature: 0.8,
                    maxTokens: 200
                });

                currentDebate.turns.push({ role, text: response, timestamp: Date.now() });
                updateDebateTranscript();
                updateDebateTurnCounter();
                saveDebateState();

                // Auto-play logic
                const autoPlayChecked = document.getElementById('debate-autoplay')?.checked;
                if (autoPlayChecked && currentDebate.status === DEBATE_STATES.ACTIVE) {
                    autoPlayTimer = setTimeout(() => {
                        handleDebateNextTurn();
                    }, AUTOPLAY_DELAY);
                }

            } catch (error) {
                console.error('Debate turn error:', error);
                showToast('Failed to get debate response', 'error');
                updateDebateTranscript();
            } finally {
                setDebateBusy(false);
            }
        }

        // XSS-safe DOM rendering
        function addDebateTurnLoading(role) {
            const transcript = document.getElementById('debate-transcript');
            const persona = currentDebate.personas[role];
            const turnClass = `persona-${role}`;

            const turnDiv = document.createElement('div');
            turnDiv.className = `debate-turn ${turnClass} loading`;
            turnDiv.id = 'debate-loading-turn';

            const headerDiv = document.createElement('div');
            headerDiv.className = 'debate-turn-header';

            const iconSpan = document.createElement('span');
            iconSpan.textContent = persona.icon;
            headerDiv.appendChild(iconSpan);

            const nameSpan = document.createElement('span');
            nameSpan.textContent = persona.name;
            headerDiv.appendChild(nameSpan);

            const loadingSpan = document.createElement('span');
            loadingSpan.className = 'loading-dots';
            loadingSpan.textContent = '...';
            headerDiv.appendChild(loadingSpan);

            const textDiv = document.createElement('div');
            textDiv.className = 'debate-turn-text';
            textDiv.textContent = 'Thinking...';

            turnDiv.appendChild(headerDiv);
            turnDiv.appendChild(textDiv);
            transcript.appendChild(turnDiv);
            transcript.scrollTop = transcript.scrollHeight;
        }

        function updateDebateTranscript() {
            const transcript = document.getElementById('debate-transcript');
            transcript.innerHTML = '';

            for (const turn of currentDebate.turns) {
                const persona = turn.role === 'user'
                    ? { name: 'You', icon: 'ğŸ‘¤' }
                    : currentDebate.personas[turn.role];
                const turnClass = turn.role === 'user' ? 'user' : `persona-${turn.role}`;

                const turnDiv = document.createElement('div');
                turnDiv.className = `debate-turn ${turnClass}`;

                const headerDiv = document.createElement('div');
                headerDiv.className = 'debate-turn-header';

                const iconSpan = document.createElement('span');
                iconSpan.textContent = persona.icon;
                headerDiv.appendChild(iconSpan);

                const nameSpan = document.createElement('span');
                nameSpan.textContent = persona.name;
                headerDiv.appendChild(nameSpan);

                const textDiv = document.createElement('div');
                textDiv.className = 'debate-turn-text';
                textDiv.textContent = turn.text;

                turnDiv.appendChild(headerDiv);
                turnDiv.appendChild(textDiv);
                transcript.appendChild(turnDiv);
            }

            transcript.scrollTop = transcript.scrollHeight;
        }

        function updateDebateTurnCounter() {
            const counter = document.getElementById('debate-turn-counter');
            const turnCount = currentDebate.turns.length;
            const maxRounds = currentDebate.maxRounds;

            if (maxRounds > 0) {
                const currentRound = Math.ceil(turnCount / 2);
                counter.textContent = `Round ${currentRound}/${maxRounds}`;
            } else {
                counter.textContent = `Turn ${turnCount}`;
            }
        }

        function handleDebateNextTurn() {
            if (!currentDebate || currentDebate.status !== DEBATE_STATES.ACTIVE) return;
            if (debateIsBusy) return;

            if (autoPlayTimer) {
                clearTimeout(autoPlayTimer);
                autoPlayTimer = null;
            }

            const lastTurn = currentDebate.turns[currentDebate.turns.length - 1];
            const nextRole = (!lastTurn || lastTurn.role === 'b' || lastTurn.role === 'user') ? 'a' : 'b';

            getNextDebateTurn(nextRole);
        }

        function handleDebateInterject() {
            if (debateIsBusy) return;

            const input = document.getElementById('debate-interject-input');
            const text = input.value.trim();
            if (!text || !currentDebate) return;

            if (autoPlayTimer) {
                clearTimeout(autoPlayTimer);
                autoPlayTimer = null;
            }

            currentDebate.turns.push({ role: 'user', text, timestamp: Date.now() });
            updateDebateTranscript();
            updateDebateTurnCounter();
            saveDebateState();
            input.value = '';
        }

        // Insight extraction
        async function handleDebateEnd() {
            if (!currentDebate) return;

            if (autoPlayTimer) {
                clearTimeout(autoPlayTimer);
                autoPlayTimer = null;
            }

            currentDebate.status = DEBATE_STATES.EXTRACTING;
            setDebateBusy(true);
            showToast('Extracting insights...', 'info');

            try {
                const insights = await extractDebateInsights();
                showInsightSelection(insights);
            } catch (error) {
                console.error('Insight extraction error:', error);
                showExtractionRetry();
            } finally {
                setDebateBusy(false);
            }
        }

        // Build 431: Structured argument extraction for research-grade tree output
        async function extractDebateInsights() {
            const transcript = currentDebate.turns.map(t => {
                const speaker = t.role === 'user' ? 'USER' : currentDebate.personas[t.role].name;
                return `${speaker}: ${t.text}`;
            }).join('\n\n');

            const prompt = `Analyze this debate and extract a STRUCTURED argument analysis.

Topic: "${currentDebate.topic}"

DEBATE TRANSCRIPT:
${transcript}

Extract arguments made by each side. Be specific - quote or closely paraphrase actual points made.

Output JSON only (no markdown):
{
  "defender": {
    "mainClaim": "The central thesis defended",
    "premises": ["Key assumption or premise 1", "Premise 2"],
    "evidence": ["Specific example or evidence cited"],
    "rebuttals": ["How defender countered attacks"]
  },
  "challenger": {
    "mainCritique": "The central attack",
    "counterexamples": ["Counter-example raised"],
    "weaknesses": ["Flaw or weakness exposed"],
    "questions": ["Challenge left unanswered"]
  },
  "clashes": [
    {"point": "Key disagreement", "defender": "Their position", "challenger": "Their position"}
  ],
  "unresolved": ["Open question or unresolved tension"]
}`;

            const response = await callClaudeAPI(prompt, { temperature: 0.3, maxTokens: 1000 });

            // Try to parse structured format first
            const jsonMatch = response.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    const structured = JSON.parse(jsonMatch[0]);
                    if (structured.defender || structured.challenger) {
                        return { type: 'structured', data: structured };
                    }
                } catch (e) {
                    console.log('Structured parse failed, trying flat format');
                }
            }

            // Fallback to flat array format
            const arrayMatch = response.match(/\[[\s\S]*\]/);
            if (arrayMatch) {
                const parsed = JSON.parse(arrayMatch[0]);
                const validTypes = ['pro', 'con', 'tension', 'question'];
                const normalized = parsed
                    .filter(item => item && typeof item.text === 'string')
                    .map(item => ({
                        type: validTypes.includes(item.type?.toLowerCase()) ? item.type.toLowerCase() : 'insight',
                        text: item.text.trim()
                    }))
                    .filter(item => item.text.length > 0);
                if (normalized.length > 0) {
                    return { type: 'flat', data: normalized };
                }
            }

            throw new Error('Could not parse extraction response');
        }

        function showExtractionRetry() {
            const transcript = document.getElementById('debate-transcript');
            transcript.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                    <div style="margin-bottom: 16px; color: var(--text-secondary);">
                        Failed to extract insights from the debate.
                    </div>
                    <button onclick="handleDebateEnd()" class="debate-action-btn primary">
                        ğŸ”„ Retry Extraction
                    </button>
                    <button onclick="closeDebatePanel()" class="debate-action-btn" style="margin-left: 8px;">
                        Cancel
                    </button>
                </div>
            `;
        }

        // Build 431: Show structured argument analysis for review
        function showInsightSelection(extractionResult) {
            currentDebate.extractedInsights = extractionResult;
            currentDebate.status = DEBATE_STATES.COMPLETED;

            const transcript = document.getElementById('debate-transcript');
            transcript.innerHTML = '';

            const container = document.createElement('div');
            container.className = 'debate-insights-selection';
            container.style.cssText = 'padding: 12px; max-height: 300px; overflow-y: auto;';

            if (extractionResult.type === 'structured') {
                // Structured format - show argument tree preview
                const data = extractionResult.data;

                const header = document.createElement('h4');
                header.style.cssText = 'margin: 0 0 12px 0; color: #a78bfa;';
                header.textContent = 'ğŸ“Š Argument Structure Preview';
                container.appendChild(header);

                // Defender section
                if (data.defender) {
                    const defSection = createArgumentSection('ğŸ›¡ï¸ Defender Arguments', data.defender, '#10b981');
                    container.appendChild(defSection);
                }

                // Challenger section
                if (data.challenger) {
                    const chalSection = createArgumentSection('âš”ï¸ Challenger Arguments', data.challenger, '#ef4444');
                    container.appendChild(chalSection);
                }

                // Clashes
                if (data.clashes && data.clashes.length > 0) {
                    const clashDiv = document.createElement('div');
                    clashDiv.style.cssText = 'margin-top: 12px; padding: 8px; background: rgba(245,158,11,0.1); border-radius: 8px;';
                    clashDiv.innerHTML = `<strong style="color:#f59e0b">ğŸ’¥ Key Clashes</strong>`;
                    data.clashes.forEach(clash => {
                        const p = document.createElement('p');
                        p.style.cssText = 'margin: 4px 0; font-size: 12px; color: var(--text-secondary);';
                        p.textContent = `â€¢ ${clash.point}`;
                        clashDiv.appendChild(p);
                    });
                    container.appendChild(clashDiv);
                }

                // Unresolved
                if (data.unresolved && data.unresolved.length > 0) {
                    const unresolvedDiv = document.createElement('div');
                    unresolvedDiv.style.cssText = 'margin-top: 12px; padding: 8px; background: rgba(99,102,241,0.1); border-radius: 8px;';
                    unresolvedDiv.innerHTML = `<strong style="color:#6366f1">â“ Unresolved</strong>`;
                    data.unresolved.forEach(q => {
                        const p = document.createElement('p');
                        p.style.cssText = 'margin: 4px 0; font-size: 12px; color: var(--text-secondary);';
                        p.textContent = `â€¢ ${q}`;
                        unresolvedDiv.appendChild(p);
                    });
                    container.appendChild(unresolvedDiv);
                }

            } else {
                // Flat format - original behavior
                const header = document.createElement('h4');
                header.style.cssText = 'margin: 0 0 12px 0; color: var(--text-secondary);';
                header.textContent = 'Extracted insights:';
                container.appendChild(header);

                const typeIcons = { pro: 'âœ…', con: 'âŒ', tension: 'âš¡', question: 'â“' };
                extractionResult.data.forEach((insight, i) => {
                    const div = document.createElement('div');
                    div.style.cssText = 'padding: 6px; margin: 4px 0; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 12px;';
                    div.textContent = `${typeIcons[insight.type] || 'ğŸ’¡'} ${insight.text}`;
                    container.appendChild(div);
                });
            }

            transcript.appendChild(container);

            document.getElementById('debate-next-turn-btn').style.display = 'none';
            document.getElementById('debate-end-btn').textContent = 'ğŸ“¥ Add to Tree';
            document.getElementById('debate-end-btn').onclick = addInsightsToTree;

            saveDebateState();
        }

        function createArgumentSection(title, args, color) {
            const section = document.createElement('div');
            section.style.cssText = `margin-top: 12px; padding: 8px; background: ${color}15; border-left: 3px solid ${color}; border-radius: 0 8px 8px 0;`;

            const titleEl = document.createElement('strong');
            titleEl.style.cssText = `color: ${color}; font-size: 13px;`;
            titleEl.textContent = title;
            section.appendChild(titleEl);

            const addLine = (icon, text) => {
                if (!text) return;
                const p = document.createElement('p');
                p.style.cssText = 'margin: 4px 0; font-size: 12px; color: var(--text-secondary);';
                p.textContent = `${icon} ${text}`;
                section.appendChild(p);
            };

            if (args.mainClaim) addLine('ğŸ“Œ', args.mainClaim);
            if (args.mainCritique) addLine('ğŸ¯', args.mainCritique);
            if (args.premises) args.premises.forEach(p => addLine('â†’', p));
            if (args.evidence) args.evidence.forEach(e => addLine('ğŸ“‹', e));
            if (args.rebuttals) args.rebuttals.forEach(r => addLine('â†©ï¸', r));
            if (args.counterexamples) args.counterexamples.forEach(c => addLine('âš¡', c));
            if (args.weaknesses) args.weaknesses.forEach(w => addLine('âš ï¸', w));
            if (args.questions) args.questions.forEach(q => addLine('â“', q));

            return section;
        }

        // Pattern-aware tree insertion
        function getPatternItemType(insightType) {
            const patternKey = currentPattern || 'generic';

            const mappings = {
                philosophy: { pro: 'defense', con: 'objection', tension: 'paradox', question: 'inquiry' },
                sales: { pro: 'benefit', con: 'risk-factor', tension: 'objection', question: 'discovery' },
                legal: { pro: 'precedent', con: 'counterargument', tension: 'conflict', question: 'issue' },
                default: { pro: 'pro', con: 'con', tension: 'consideration', question: 'question' }
            };

            const patternMap = mappings[patternKey] || mappings.default;
            return patternMap[insightType] || insightType;
        }

        // Build 431: Create structured argument tree from debate
        function addInsightsToTree() {
            if (!currentDebate || !currentDebate.sourceNodeId) {
                showToast('Error: No source node found', 'error');
                return;
            }

            const extraction = currentDebate.extractedInsights;
            if (!extraction) {
                showToast('No insights to add', 'warning');
                return;
            }

            // Find the actual node in the tree by ID
            const sourceNode = findNodeById(capexTree, currentDebate.sourceNodeId);
            if (!sourceNode) {
                showToast('Error: Source node not found in tree', 'error');
                return;
            }

            saveState();

            const today = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            let containerNode;
            let nodeCount = 0;

            if (extraction.type === 'structured') {
                // Build hierarchical argument structure
                const data = extraction.data;
                containerNode = {
                    id: generateId(),
                    name: `âš”ï¸ Debate: ${currentDebate.topic} (${today})`,
                    type: 'item',
                    icon: 'âš”ï¸',
                    description: `Structured argument analysis from debate`,
                    expanded: true,
                    subtasks: []
                };

                // Defender arguments branch
                if (data.defender) {
                    const defenderNode = {
                        id: generateId(),
                        name: 'ğŸ›¡ï¸ Defender Arguments',
                        type: 'subtask',
                        itemType: 'defense',
                        expanded: true,
                        subtasks: []
                    };
                    if (data.defender.mainClaim) {
                        defenderNode.subtasks.push({ id: generateId(), name: `ğŸ“Œ Main Claim: ${data.defender.mainClaim}`, type: 'subtask', itemType: 'thesis' });
                        nodeCount++;
                    }
                    if (data.defender.premises) {
                        data.defender.premises.forEach(p => {
                            defenderNode.subtasks.push({ id: generateId(), name: `â†’ Premise: ${p}`, type: 'subtask', itemType: 'premise' });
                            nodeCount++;
                        });
                    }
                    if (data.defender.evidence) {
                        data.defender.evidence.forEach(e => {
                            defenderNode.subtasks.push({ id: generateId(), name: `ğŸ“‹ Evidence: ${e}`, type: 'subtask', itemType: 'evidence' });
                            nodeCount++;
                        });
                    }
                    if (data.defender.rebuttals) {
                        data.defender.rebuttals.forEach(r => {
                            defenderNode.subtasks.push({ id: generateId(), name: `â†©ï¸ Rebuttal: ${r}`, type: 'subtask', itemType: 'rebuttal' });
                            nodeCount++;
                        });
                    }
                    if (defenderNode.subtasks.length > 0) {
                        containerNode.subtasks.push(defenderNode);
                    }
                }

                // Challenger arguments branch
                if (data.challenger) {
                    const challengerNode = {
                        id: generateId(),
                        name: 'âš”ï¸ Challenger Arguments',
                        type: 'subtask',
                        itemType: 'critique',
                        expanded: true,
                        subtasks: []
                    };
                    if (data.challenger.mainCritique) {
                        challengerNode.subtasks.push({ id: generateId(), name: `ğŸ¯ Main Critique: ${data.challenger.mainCritique}`, type: 'subtask', itemType: 'objection' });
                        nodeCount++;
                    }
                    if (data.challenger.counterexamples) {
                        data.challenger.counterexamples.forEach(c => {
                            challengerNode.subtasks.push({ id: generateId(), name: `âš¡ Counter-example: ${c}`, type: 'subtask', itemType: 'counter' });
                            nodeCount++;
                        });
                    }
                    if (data.challenger.weaknesses) {
                        data.challenger.weaknesses.forEach(w => {
                            challengerNode.subtasks.push({ id: generateId(), name: `âš ï¸ Weakness: ${w}`, type: 'subtask', itemType: 'weakness' });
                            nodeCount++;
                        });
                    }
                    if (data.challenger.questions) {
                        data.challenger.questions.forEach(q => {
                            challengerNode.subtasks.push({ id: generateId(), name: `â“ Challenge: ${q}`, type: 'subtask', itemType: 'question' });
                            nodeCount++;
                        });
                    }
                    if (challengerNode.subtasks.length > 0) {
                        containerNode.subtasks.push(challengerNode);
                    }
                }

                // Key clashes
                if (data.clashes && data.clashes.length > 0) {
                    const clashNode = {
                        id: generateId(),
                        name: 'ğŸ’¥ Key Clashes',
                        type: 'subtask',
                        itemType: 'tension',
                        subtasks: []
                    };
                    data.clashes.forEach(clash => {
                        clashNode.subtasks.push({
                            id: generateId(),
                            name: `ğŸ’¥ ${clash.point}`,
                            type: 'subtask',
                            description: `Defender: ${clash.defender || clash.defenderSays}\nChallenger: ${clash.challenger || clash.challengerSays}`
                        });
                        nodeCount++;
                    });
                    containerNode.subtasks.push(clashNode);
                }

                // Unresolved questions
                if (data.unresolved && data.unresolved.length > 0) {
                    const unresolvedNode = {
                        id: generateId(),
                        name: 'â“ Unresolved Questions',
                        type: 'subtask',
                        itemType: 'inquiry',
                        subtasks: []
                    };
                    data.unresolved.forEach(q => {
                        unresolvedNode.subtasks.push({ id: generateId(), name: `â“ ${q}`, type: 'subtask', itemType: 'question' });
                        nodeCount++;
                    });
                    containerNode.subtasks.push(unresolvedNode);
                }

            } else {
                // Flat format fallback
                containerNode = {
                    id: generateId(),
                    name: `Debate Insights (${today})`,
                    type: 'item',
                    icon: 'ğŸ­',
                    description: `Debate between ${currentDebate.personas.a.name} and ${currentDebate.personas.b.name}`,
                    subtasks: []
                };
                const typeIcons = { pro: 'âœ…', con: 'âŒ', tension: 'âš¡', question: 'â“' };
                extraction.data.forEach(insight => {
                    containerNode.subtasks.push({
                        id: generateId(),
                        name: `${typeIcons[insight.type] || 'ğŸ’¡'} ${insight.text}`,
                        type: 'subtask',
                        itemType: getPatternItemType(insight.type)
                    });
                    nodeCount++;
                });
            }

            // Add to appropriate location based on node type
            if (sourceNode.type === 'phase') {
                if (!sourceNode.items) sourceNode.items = [];
                sourceNode.items.push(containerNode);
                sourceNode.expanded = true;
            } else if (sourceNode.type === 'item' || sourceNode.type === 'subtask') {
                if (!sourceNode.subtasks) sourceNode.subtasks = [];
                sourceNode.subtasks.push(containerNode);
                sourceNode.expanded = true;
            } else if (sourceNode.id === capexTree.id || sourceNode.type === 'root') {
                if (capexTree.children && capexTree.children.length > 0) {
                    const firstPhase = capexTree.children[0];
                    if (!firstPhase.items) firstPhase.items = [];
                    firstPhase.items.push(containerNode);
                    firstPhase.expanded = true;
                } else {
                    const insightsPhase = {
                        id: generateId(),
                        name: 'Debate Analysis',
                        type: 'phase',
                        items: [containerNode]
                    };
                    if (!capexTree.children) capexTree.children = [];
                    capexTree.children.push(insightsPhase);
                }
            }

            localStorage.removeItem(DEBATE_STORAGE_KEY);
            closeDebatePanel();
            renderTree();

            setTimeout(() => {
                const nodeEl = document.querySelector(`[data-id="${containerNode.id}"]`);
                if (nodeEl) {
                    nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);

            showToast(`Added ${nodeCount} argument nodes to "${sourceNode.name}"`, 'success');
        }

        function closeDebatePanel() {
            if (autoPlayTimer) {
                clearTimeout(autoPlayTimer);
                autoPlayTimer = null;
            }

            document.getElementById('debate-panel').classList.remove('open');
            document.getElementById('debate-setup-modal').classList.remove('open');

            localStorage.removeItem(DEBATE_STORAGE_KEY);
            currentDebate = null;

            const nextBtn = document.getElementById('debate-next-turn-btn');
            const endBtn = document.getElementById('debate-end-btn');
            if (nextBtn) nextBtn.style.display = '';
            if (endBtn) {
                endBtn.textContent = 'âœ… End & Extract';
                endBtn.onclick = handleDebateEnd;
            }
        }

        function initDebatePanel() {
            // Build 428 fix: Debate panel HTML loads after this script
            // Retry until elements exist (same pattern as Build 418 Tree Agent fix)
            const startBtn = document.getElementById('debate-start-btn');
            if (!startBtn) {
                setTimeout(initDebatePanel, 100);
                return;
            }

            document.getElementById('debate-cancel-setup')?.addEventListener('click', () => {
                document.getElementById('debate-setup-modal').classList.remove('open');
                currentDebate = null;
            });

            startBtn.addEventListener('click', startDebate);

            document.getElementById('debate-close-btn')?.addEventListener('click', closeDebatePanel);
            document.getElementById('debate-minimize-btn')?.addEventListener('click', () => {
                document.getElementById('debate-panel').classList.toggle('minimized');
            });

            document.getElementById('debate-next-turn-btn')?.addEventListener('click', handleDebateNextTurn);
            document.getElementById('debate-end-btn')?.addEventListener('click', handleDebateEnd);

            document.getElementById('debate-interject-btn')?.addEventListener('click', handleDebateInterject);
            document.getElementById('debate-interject-input')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleDebateInterject();
            });

            document.getElementById('debate-autoplay')?.addEventListener('change', (e) => {
                if (!e.target.checked && autoPlayTimer) {
                    clearTimeout(autoPlayTimer);
                    autoPlayTimer = null;
                }
            });

            // Build 429: Make debate panel draggable
            initDebateDrag();

            // Restore previous debate session if exists
            restoreDebateState();
        }

        // Build 429: Draggable debate panel (same pattern as Tree Agent)
        function initDebateDrag() {
            const panel = document.getElementById('debate-panel');
            const header = panel?.querySelector('.debate-header');
            if (!panel || !header) return;

            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            header.addEventListener('mousedown', (e) => {
                if (e.target.closest('.debate-btn')) return;
                isDragging = true;
                dragOffset.x = e.clientX - panel.offsetLeft;
                dragOffset.y = e.clientY - panel.offsetTop;
                panel.style.transition = 'none';
                header.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const newX = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, e.clientX - dragOffset.x));
                const newY = Math.max(0, Math.min(window.innerHeight - panel.offsetHeight, e.clientY - dragOffset.y));
                panel.style.left = `${newX}px`;
                panel.style.top = `${newY}px`;
                panel.style.bottom = 'auto';
                panel.style.right = 'auto';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    panel.style.transition = '';
                    header.style.cursor = 'grab';
                }
            });

            // Double-click header to reset position
            header.addEventListener('dblclick', (e) => {
                if (e.target.closest('.debate-btn')) return;
                panel.style.left = '20px';
                panel.style.bottom = '20px';
                panel.style.top = 'auto';
                panel.style.right = 'auto';
            });

            // Touch support
            header.addEventListener('touchstart', (e) => {
                if (e.target.closest('.debate-btn')) return;
                const touch = e.touches[0];
                isDragging = true;
                dragOffset.x = touch.clientX - panel.offsetLeft;
                dragOffset.y = touch.clientY - panel.offsetTop;
                panel.style.transition = 'none';
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const newX = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, touch.clientX - dragOffset.x));
                const newY = Math.max(0, Math.min(window.innerHeight - panel.offsetHeight, touch.clientY - dragOffset.y));
                panel.style.left = `${newX}px`;
                panel.style.top = `${newY}px`;
                panel.style.bottom = 'auto';
                panel.style.right = 'auto';
            }, { passive: true });

            document.addEventListener('touchend', () => {
                if (isDragging) {
                    isDragging = false;
                    panel.style.transition = '';
                }
            });
        }

        // =============================================================================
        // END DEBATE MODE
        // =============================================================================

        // =============================================================================
        // AI WIZARD SYSTEM
        // =============================================================================

        // Wizard state
        let wizardState = {
            active: false,
            conversation: [],
            questionsAsked: 0,
            fieldsCompleted: new Set(),
            totalFields: 0,
            awaitingResponse: false,
            workingTree: null,
            patternKey: null
        };

        // Check if tree has meaningful content
        function hasExistingContent() {
            // Check if any phase has items or children (filesystem pattern uses 'children')
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    // Support both 'items' (standard patterns) and 'children' (filesystem pattern)
                    const nodeList = phase.items || phase.children || phase.subItems || [];
                    if (nodeList.length > 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Start wizard
        document.getElementById('wizard-btn').addEventListener('click', () => {
            // Check global AI mode
            const aiMode = getGlobalAIMode();
            if (aiMode === 'off') {
                alert('âŒ AI features are currently disabled.\n\nPlease enable AI mode in the header (ğŸ¤– AI Mode dropdown) to use the AI Wizard.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            // If tree has content, ask user if they want to enhance or start fresh
            if (hasExistingContent()) {
                showWizardModeChoice();
            } else {
                startWizard(false); // false = start fresh
            }
        });

        // Show modal to choose wizard mode
        function showWizardModeChoice() {
            const pattern = PATTERNS[currentPattern];
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸª„ AI Wizard Mode';

            // Count existing items
            const itemCount = capexTree.children?.reduce((sum, phase) =>
                sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 24px;">
                        Your tree already has <strong style="color: var(--treeplex-primary);">${itemCount} ${pattern.levels.item.toLowerCase()}(s)</strong>.
                        How would you like to proceed?
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="mode-enhance" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">âœ¨</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Enhance Existing
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Keep your current tree and use the wizard to add more detail, fill gaps, or expand sections.
                            </div>
                        </div>

                        <div id="mode-fresh" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">ğŸŒ±</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Start Fresh
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Clear the current tree and build a completely new structure from scratch.
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 16px; padding: 12px; background: rgba(163, 85, 247, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                        ğŸ’¡ <strong>Tip:</strong> Enhancement mode is great for iterative refinement. The wizard will see your existing structure and help you improve it.
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Add click handlers
            document.getElementById('mode-enhance').onclick = () => {
                modal.style.display = 'none';
                // BUILD 413: Route to Tree Agent (fixes Build 397 command frame routing)
                startWizard(true); // true = enhance mode
            };

            document.getElementById('mode-fresh').onclick = () => {
                modal.style.display = 'none';
                startWizard(false); // false = start fresh
            };
        }

        async function startWizard(enhanceMode = false) {
            // Reset wizard state
            wizardState = {
                active: true,
                conversation: [],
                questionsAsked: 0,
                fieldsCompleted: new Set(),
                totalFields: 0,
                awaitingResponse: false,
                workingTree: JSON.parse(JSON.stringify(capexTree)), // Deep copy
                patternKey: currentPattern,
                enhanceMode: enhanceMode,
                retryCount: 0 // Track recovery attempts
            };

            // Get pattern info
            const pattern = PATTERNS[currentPattern];
            const patternFields = pattern.fields || {};
            wizardState.totalFields = Object.keys(patternFields).length;

            // Get pattern info
            const modeLabel = enhanceMode ? 'âœ¨ Enhancing' : 'ğŸª„ Building';

            // BUILD 408: Clear old wizard history (still used internally for compatibility)
            const wizardChatHistory = document.getElementById('wizard-chat-history');
            if (wizardChatHistory) wizardChatHistory.innerHTML = '';
            updateWizardPreview();

            // BUILD 408: Use Tree Agent as primary UI (replaces old wizard modal)
            const agentTitle = `${modeLabel} ${pattern.name}`;
            if (typeof openTreeAgent === 'function') {
                openTreeAgent(agentTitle);
            } else {
                // Fallback to old modal if Tree Agent not available
                document.getElementById('wizard-title').textContent = `${modeLabel} Your ${pattern.name}`;
                document.getElementById('wizard-fields-total').textContent = wizardState.totalFields;
                document.getElementById('wizard-modal').style.display = 'flex';
            }

            // Hide chat bubble to prevent overlap with modal buttons
            const chatBubble = document.getElementById('chat-assistant-bubble');
            if (chatBubble) chatBubble.style.display = 'none';

            // Start conversation
            await wizardAsk();
        }

        // Add message to chat with optional clickable choices
        function addWizardMessage(role, content, choices = null) {
            // BUILD 419: Forward AI messages to Tree Agent if it's open
            // (User messages are already added by the Tree Agent send button handler)
            const agentFrame = document.getElementById('tree-agent-frame');
            if (role === 'ai' && agentFrame && agentFrame.classList.contains('open') && typeof addAgentMessage === 'function') {
                addAgentMessage('assistant', content);
            }

            const chatHistory = document.getElementById('wizard-chat-history');
            const messageDiv = document.createElement('div');

            if (role === 'ai') {
                // Neutral Slate Grey for AI (modern ChatGPT/Claude aesthetic)
                messageDiv.style.cssText = `
                    background: #2A2F3C;
                    color: #E2E2E2;
                    padding: 16px 20px;
                    border-radius: 12px;
                    border-top-left-radius: 2px;
                    max-width: 85%;
                    align-self: flex-start;
                    line-height: 1.6;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    border: 1px solid #3A3F4D;
                    font-size: 14px;
                `;

                // Parse content for [CHOICE:label] markers and convert to buttons
                let displayContent = content;
                const choiceMatches = content.match(/\[CHOICE:([^\]]+)\]/g);

                if (choiceMatches) {
                    // Remove choice markers from display text
                    displayContent = content.replace(/\[CHOICE:[^\]]+\]/g, '').trim();
                    messageDiv.innerHTML = displayContent.replace(/\n/g, '<br>');

                    // Create clickable choice buttons
                    const choicesDiv = document.createElement('div');
                    choicesDiv.style.cssText = `
                        display: flex;
                        flex-wrap: wrap;
                        gap: 8px;
                        margin-top: 12px;
                        padding-top: 12px;
                        border-top: 1px solid #3A3F4D;
                    `;

                    choiceMatches.forEach(match => {
                        const label = match.replace('[CHOICE:', '').replace(']', '');
                        const btn = document.createElement('button');
                        btn.textContent = label;
                        btn.style.cssText = `
                            padding: 8px 16px;
                            background: linear-gradient(135deg, #6366f1, #8b5cf6);
                            color: white;
                            border: none;
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 13px;
                            font-weight: 500;
                            transition: all 0.2s ease;
                            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
                        `;
                        btn.onmouseover = () => btn.style.transform = 'scale(1.05)';
                        btn.onmouseout = () => btn.style.transform = 'scale(1)';
                        btn.onclick = () => {
                            // Disable all choice buttons after selection
                            choicesDiv.querySelectorAll('button').forEach(b => {
                                b.disabled = true;
                                b.style.opacity = '0.5';
                                b.style.cursor = 'default';
                            });
                            btn.style.opacity = '1';
                            btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                            // Send the choice as user input
                            handleWizardChoice(label);
                        };
                        choicesDiv.appendChild(btn);
                    });

                    messageDiv.appendChild(choicesDiv);
                } else {
                    messageDiv.innerHTML = displayContent.replace(/\n/g, '<br>');
                }
            } else {
                // Vibrant Primary for User
                messageDiv.style.cssText = `
                    background: linear-gradient(135deg, #6366f1, #4f46e5);
                    color: white;
                    padding: 12px 18px;
                    border-radius: 12px;
                    border-bottom-right-radius: 2px;
                    max-width: 80%;
                    align-self: flex-end;
                    line-height: 1.5;
                    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
                    font-size: 14px;
                `;
                messageDiv.textContent = content;
            }

            // BUILD 408: Tree Agent is now primary UI
            // Add to Tree Agent first (primary), then old wizard (secondary/fallback)
            if (typeof addAgentMessage === 'function' && treeAgentState?.open) {
                const agentRole = role === 'ai' ? 'assistant' : 'user';
                addAgentMessage(agentRole, content);
            }

            // Also add to old wizard chat history (for compatibility/fallback)
            if (chatHistory) {
                chatHistory.appendChild(messageDiv);
                chatHistory.scrollTop = chatHistory.scrollHeight;
            }
        }

        // Handle wizard choice button click
        function handleWizardChoice(choice) {
            // Add user's choice as a message
            addWizardMessage('user', choice);

            // Add to conversation history
            wizardState.conversation.push({ role: 'user', content: choice });

            // Trigger next AI response
            wizardAsk();
        }

        // Ask AI for next question
        async function wizardAsk() {
            if (wizardState.awaitingResponse) return;
            wizardState.awaitingResponse = true;

            // Disable input while waiting
            document.getElementById('wizard-user-input').disabled = true;
            document.getElementById('wizard-send').disabled = true;

            try {
                const systemPrompt = buildWizardSystemPrompt();
                const conversationContext = wizardState.conversation.map(msg =>
                    `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`
                ).join('\n\n');

                const userPrompt = conversationContext ||
                    (wizardState.enhanceMode ?
                        "The user wants to enhance their existing tree. Acknowledge what they have and ask how you can help improve it." :
                        "Start the wizard conversation. Ask the user what they want to build.");

                console.log('ğŸª„ Wizard asking AI...');
                console.log('ğŸª„ System prompt length:', systemPrompt.length);
                console.log('ğŸª„ User prompt length:', userPrompt.length);

                // SMART MODEL SELECTION for large trees
                // Large trees (50+ items) should use fast models to avoid timeout/cutoff
                const itemCount = (wizardState.workingTree.children || []).reduce((acc, phase) =>
                    acc + (phase.items || []).length, 0);
                const isLargeTree = itemCount >= 50;

                // Check if user selected Deep Mode (user-sonnet, user-gemini, user-chatgpt)
                const aiModeInfo = parseUnifiedMode();
                let useDeepMode = aiModeInfo.mode === 'deep'; // Deep Mode = Extended Thinking

                // Check if we're in fallback mode (from previous cutoff error)
                const useFastFallback = wizardState.useFastFallback || false;

                if (isLargeTree && !useFastFallback) {
                    console.log(`ğŸª„ Large tree detected (${itemCount} items) - recommending fast model`);
                    // For large trees, warn but still try their selected mode first
                    if (useDeepMode) {
                        console.warn('âš ï¸ Deep Mode on large tree may timeout. Will auto-fallback to fast model if needed.');
                    }
                }

                if (useFastFallback) {
                    console.log('ğŸš€ Using fast fallback mode (previous response was cut off)');
                    useDeepMode = false; // Force fast mode
                }

                if (useDeepMode) {
                    console.log('ğŸ§  Wizard using Deep Mode (Extended Thinking enabled)');
                }

                const response = await callClaudeAPI(userPrompt, systemPrompt, 8000, useDeepMode); // Increased to 8000 for complex patterns (Film, Philosophy, etc.)

                console.log('ğŸª„ AI Raw Response:', response);

                // Guard against undefined response
                if (!response) {
                    throw new Error('AI returned empty response. The request may have timed out or failed silently.');
                }

                // Try to extract JSON if AI added text before/after
                let jsonStr = response.trim();

                // If response has markdown code blocks, extract JSON from them
                if (jsonStr.includes('```json')) {
                    const match = jsonStr.match(/```json\s*\n([\s\S]*?)\n```/);
                    if (match) {
                        jsonStr = match[1];
                        console.log('ğŸª„ Extracted from ```json block');
                    }
                } else if (jsonStr.includes('```')) {
                    const match = jsonStr.match(/```\s*\n([\s\S]*?)\n```/);
                    if (match) {
                        jsonStr = match[1];
                        console.log('ğŸª„ Extracted from ``` block');
                    }
                }

                // Find the FIRST complete JSON object using proper brace matching
                // This handles cases where AI adds text before/after the JSON
                const firstBrace = jsonStr.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response. AI may not be following instructions.');
                }

                if (firstBrace > 0) {
                    console.log('ğŸª„ Skipping text before JSON:', jsonStr.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonStr.length; i++) {
                    const char = jsonStr[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    console.error('ğŸª„ Incomplete JSON - Wizard response was cut off!');
                    console.error('ğŸª„ Full response length:', response.length);
                    console.error('ğŸª„ Response (first 500 chars):', response.substring(0, 500));
                    console.error('ğŸª„ Response (last 500 chars):', response.substring(Math.max(0, response.length - 500)));

                    // Check retry limit
                    wizardState.retryCount = (wizardState.retryCount || 0) + 1;
                    if (wizardState.retryCount > 3) {
                        throw new Error('Response was cut off multiple times. Try asking the wizard to add fewer items at once, or click "Finish & Apply" to save current progress.');
                    }

                    // SMART FALLBACK: After first cutoff, switch to fast mode
                    if (wizardState.retryCount === 1 && !wizardState.useFastFallback) {
                        console.log('ğŸš€ First cutoff - enabling fast fallback mode for subsequent requests');
                        wizardState.useFastFallback = true;
                        addWizardMessage('ai', "âš¡ Switching to fast mode for better reliability with your large project...");
                    }

                    // Try to recover by asking AI to simplify
                    console.log('ğŸª„ Attempting auto-recovery (attempt ' + wizardState.retryCount + '/3)...');

                    // Add a recovery message to conversation
                    wizardState.conversation.push({
                        role: 'system',
                        content: 'Your last response was cut off (too long). CRITICAL: Return ONLY a short message and treeUpdate: null. Do NOT include any tree data. Just ask a simple question.'
                    });

                    // Show user-friendly message
                    addWizardMessage('ai', "Oops! My response was too long. Let me try with a much shorter answer...");

                    // Retry with simplified prompt
                    document.getElementById('wizard-user-input').disabled = false;
                    document.getElementById('wizard-send').disabled = false;
                    wizardState.awaitingResponse = false;
                    setTimeout(() => wizardAsk(), 500);
                    return;
                }

                jsonStr = jsonStr.substring(firstBrace, endPos);

                if (endPos < response.length) {
                    console.log('ğŸª„ Skipping text after JSON:', response.substring(endPos, endPos + 50) + '...');
                }

                console.log('ğŸª„ Extracted JSON (first 200 chars):', jsonStr.substring(0, 200) + '...');
                console.log('ğŸª„ JSON length:', jsonStr.length);

                // Sanitize JSON: Fix control characters in string values
                // This handles cases where AI generates unescaped newlines/tabs in strings
                let parsed;
                try {
                    // First, try parsing as-is
                    parsed = JSON.parse(jsonStr);
                } catch (firstError) {
                    console.warn('ğŸª„ JSON parse failed, attempting sanitization...', firstError.message);

                    // Sanitize by escaping control characters within string values
                    // Strategy: Replace literal newlines/tabs/etc with escaped versions
                    // but only within quoted string values (not in JSON structure)

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonStr.length; i++) {
                        const char = jsonStr[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                // Other control characters - escape as unicode
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonStr = sanitized;
                    console.log('ğŸª„ Sanitized JSON:', jsonStr.substring(0, 200) + '...');

                    // Try parsing again after sanitization
                    parsed = JSON.parse(jsonStr);
                }

                // Validate required fields
                if (!parsed.message) {
                    throw new Error('AI response missing "message" field');
                }

                // Success! Reset retry count
                wizardState.retryCount = 0;

                // Add AI message to conversation history
                let messageWithChoices = parsed.message;
                const choiceCount = (parsed.message.match(/\[CHOICE:[^\]]+\]/g) || []).length;
                console.log('ğŸª„ AI message [CHOICE:] markers found:', choiceCount);

                // BUILD 400: Fallback - add default choices if AI forgot
                if (choiceCount === 0 && !parsed.done) {
                    console.log('ğŸª„ No choices found - adding defaults');
                    messageWithChoices += '\n\n[CHOICE:â• Add more][CHOICE:ğŸ“ More detail][CHOICE:âœ… Looks good][CHOICE:ğŸ”„ Change something]';
                }

                wizardState.conversation.push({role: 'assistant', content: messageWithChoices});
                addWizardMessage('ai', messageWithChoices);

                // Update tree if provided
                if (parsed.treeUpdate) {
                    console.log('ğŸª„ Applying tree update:', parsed.treeUpdate);
                    const aiSource = `ai-${aiModeInfo.model}`;  // e.g., 'ai-sonnet', 'ai-gemini', 'ai-chatgpt'
                    mergeTreeUpdate(parsed.treeUpdate, aiSource);
                    updateWizardPreview();
                }

                // Update progress
                if (parsed.fieldsUpdated && Array.isArray(parsed.fieldsUpdated)) {
                    parsed.fieldsUpdated.forEach(field => wizardState.fieldsCompleted.add(field));
                    document.getElementById('wizard-fields-complete').textContent = wizardState.fieldsCompleted.size;
                }

                // Update progress bar (from AI's progress field 0.0 to 1.0)
                if (parsed.progress !== undefined) {
                    const percentComplete = Math.round(parsed.progress * 100);
                    document.getElementById('wizard-progress-percent').textContent = `${percentComplete}%`;
                    document.getElementById('wizard-progress-bar').style.width = `${percentComplete}%`;

                    // BUILD 405: Also update Tree Agent progress
                    if (typeof updateAgentProgress === 'function') {
                        updateAgentProgress(percentComplete);
                    }
                }

                // Check if done
                if (parsed.done) {
                    document.getElementById('wizard-completion').style.display = 'block';
                    document.getElementById('wizard-progress-bar').style.width = '100%';
                    document.getElementById('wizard-progress-percent').textContent = '100%';

                    // BUILD 405: Update Tree Agent to 100%
                    if (typeof updateAgentProgress === 'function') {
                        updateAgentProgress(100, 'âœ“ Done!');
                    }
                }

            } catch (error) {
                console.error('ğŸª„ Wizard error details:', {
                    error: error.message,
                    stack: error.stack,
                    conversation: wizardState.conversation
                });

                // SMART FALLBACK: Detect timeout and auto-retry with fast mode
                const isTimeout = error.message?.includes('timeout') || error.message?.includes('10-second') || error.message?.includes('10s');

                if (isTimeout && !wizardState.useFastFallback) {
                    console.log('ğŸš€ Timeout detected - enabling fast fallback mode and retrying...');
                    wizardState.useFastFallback = true;
                    wizardState.retryCount = (wizardState.retryCount || 0) + 1;

                    if (wizardState.retryCount <= 2) {
                        addWizardMessage('ai', "âš¡ Request timed out. Switching to fast mode and trying again...");

                        // Retry with fast mode
                        document.getElementById('wizard-user-input').disabled = false;
                        document.getElementById('wizard-send').disabled = false;
                        wizardState.awaitingResponse = false;
                        setTimeout(() => wizardAsk(), 500);
                        return;
                    }
                }

                // Show error message in chat
                const errorMsg = error.message || 'Unknown error occurred';

                // Simplify timeout errors for users
                if (isTimeout) {
                    addWizardMessage('ai', `â±ï¸ Request timed out. Try:\n\n1. Switch to Gemini (Settings â†’ Provider) - no timeout limit\n2. Use Fast Mode (Haiku) - usually faster\n3. Ask me to make smaller changes at a time`);
                } else {
                    addWizardMessage('ai', `I'm having trouble: ${errorMsg}\n\nPlease check:\n1. Is your API key configured? (Settings â†’ API Key)\n2. Try refreshing the page\n3. Check browser console for details (F12)`);
                }
            }

            // Re-enable input
            document.getElementById('wizard-user-input').disabled = false;
            document.getElementById('wizard-send').disabled = false;
            document.getElementById('wizard-user-input').focus();
            wizardState.awaitingResponse = false;
        }

        // User sends message
        document.getElementById('wizard-send').addEventListener('click', async () => {
            const input = document.getElementById('wizard-user-input');
            const message = input.value.trim();

            if (!message || wizardState.awaitingResponse) return;

            // Add to conversation
            wizardState.conversation.push({role: 'user', content: message});
            addWizardMessage('user', message);
            wizardState.questionsAsked++;
            document.getElementById('wizard-question-count').textContent = wizardState.questionsAsked;

            // Clear input
            input.value = '';

            // Get AI response
            await wizardAsk();
        });

        // Build system prompt for wizard
        function buildWizardSystemPrompt() {
            const pattern = PATTERNS[wizardState.patternKey];
            const levels = pattern.levels;
            const fields = pattern.fields || {};

            // Build a summary of current tree (not full JSON to save tokens)
            const treeSummary = wizardState.workingTree.name || 'Empty';
            const phaseCount = (wizardState.workingTree.children || []).length;
            const itemCount = (wizardState.workingTree.children || []).reduce((acc, phase) =>
                acc + (phase.items || phase.children || phase.subItems || []).length, 0);

            // Build detailed existing structure summary for enhance mode
            let existingStructure = '';
            if (wizardState.enhanceMode && itemCount > 0) {
                existingStructure = '\n\nğŸŒ³ EXISTING TREE STRUCTURE (DO NOT DELETE - ADD TO THIS):\n\n';
                existingStructure += `**${wizardState.workingTree.name}**\n`;
                if (wizardState.workingTree.description) {
                    existingStructure += `Description: ${wizardState.workingTree.description}\n`;
                }
                existingStructure += '\n';

                (wizardState.workingTree.children || []).forEach((phase, idx) => {
                    existingStructure += `${levels.phase} ${idx + 1}: ${phase.name}`;
                    if (phase.subtitle) existingStructure += ` (${phase.subtitle})`;
                    existingStructure += `\n`;

                    const phaseItems = phase.items || phase.children || phase.subItems || [];
                    if (phaseItems.length > 0) {
                        phaseItems.forEach(item => {
                            existingStructure += `  - ${item.name}`;
                            if (item.description) {
                                existingStructure += `: ${item.description.substring(0, 60)}${item.description.length > 60 ? '...' : ''}`;
                            }
                            existingStructure += `\n`;

                            const itemSubtasks = item.subtasks || item.subItems || item.children || [];
                            if (itemSubtasks.length > 0) {
                                existingStructure += `    (${itemSubtasks.length} subtasks)\n`;
                            }
                        });
                    } else {
                        existingStructure += `  (no items yet)\n`;
                    }
                    existingStructure += '\n';
                });

                existingStructure += `Total: ${phaseCount} ${levels.phase.toLowerCase()}(s), ${itemCount} ${levels.item.toLowerCase()}(s)\n\n`;
                existingStructure += `ğŸ¯ YOUR MISSION: Help the user ENHANCE this existing tree by:\n`;
                existingStructure += `- Adding more detail to existing items\n`;
                existingStructure += `- Filling gaps or missing sections\n`;
                existingStructure += `- Expanding phases that seem incomplete\n`;
                existingStructure += `- Adding subtasks to items that need them\n\n`;
                existingStructure += `\nâš ï¸âš ï¸âš ï¸ CRITICAL - DO NOT ECHO THE ENTIRE TREE âš ï¸âš ï¸âš ï¸\n`;
                existingStructure += `The tree already has ${itemCount} items. Your treeUpdate MUST contain ONLY:\n`;
                existingStructure += `- NEW items you are ADDING (not existing ones)\n`;
                existingStructure += `- Items you are MODIFYING (with changes)\n`;
                existingStructure += `- DO NOT include unchanged items - they are preserved automatically\n`;
                existingStructure += `- If just asking a question with no changes, use treeUpdate: null\n`;
                existingStructure += `\nâŒ WRONG: Echoing all ${itemCount} items back (wastes tokens, causes cutoff)\n`;
                existingStructure += `âœ… RIGHT: Only new/changed items, or null if just asking\n`;
            }

            const modeInstruction = wizardState.enhanceMode ?
                `You are ENHANCING an existing ${pattern.name} project. The user already has a tree with ${itemCount} items. Help them improve, expand, or fill gaps.` :
                `You are BUILDING a complete ${pattern.name} project from scratch. Extract NECESSARY and SUFFICIENT data in MINIMUM questions.`;

            return `âš ï¸ CRITICAL OUTPUT FORMAT: You MUST return ONLY a valid JSON object. NO text before the opening {. NO text after the closing }. NO explanations. NO commentary. JUST JSON.

You are an EXPERT INFORMATION EXTRACTION WIZARD. ${modeInstruction}

CURRENT STATE:
- Pattern: ${pattern.name}
- Structure: ${levels.root} â†’ ${levels.phase} â†’ ${levels.item} â†’ ${levels.subtask}
- Fields: ${Object.keys(fields).join(', ') || 'none'}
- Completed Fields: ${Array.from(wizardState.fieldsCompleted).join(', ') || 'none'}
- Tree: ${treeSummary} (${phaseCount} phases, ${itemCount} items)${existingStructure}

ğŸ¯ CORE MISSION: Extract 100% of required information in â‰¤5 strategic questions

ğŸ–±ï¸ MOUSE-DRIVEN UI - CLICKABLE CHOICES (CRITICAL):
Every question MUST include 2-4 clickable options using [CHOICE:label] markers.
The user clicks to answer - no typing required!

Format your message like this:
"What type of project is this?
[CHOICE:ğŸ“Š Business/Strategy][CHOICE:ğŸ¨ Creative/Design][CHOICE:ğŸ“š Educational][CHOICE:ğŸ”§ Technical]"

CHOICE GUIDELINES:
- Use emoji + short label (max 20 chars)
- Offer 2-4 meaningful options that cover common cases
- Include a catch-all like "Something else" or "Custom"
- ALWAYS provide choices - never ask open-ended questions without options
- Choices should help BUILD the tree, not just categorize

EXAMPLE MESSAGES WITH CHOICES:

Turn 1 (Goal):
"What's the main purpose of this ${wizardState.patternKey}?
[CHOICE:ğŸ“‹ Planning/Organizing][CHOICE:ğŸ“ Documenting][CHOICE:ğŸ¯ Decision-making][CHOICE:ğŸ’¡ Brainstorming]"

Turn 2 (Scope):
"How many main phases should this have?
[CHOICE:3 phases (simple)][CHOICE:4-5 phases (standard)][CHOICE:6+ phases (complex)][CHOICE:Let me describe]"

Turn 3 (Details):
"I've built the structure. What should I focus on next?
[CHOICE:â• Add more items][CHOICE:ğŸ“ More detail][CHOICE:âœ… Looks good][CHOICE:ğŸ”„ Restructure]"

ğŸ“Š STRATEGIC QUESTIONING FRAMEWORK:

ğŸ¯ QUESTIONING ORDER (CRITICAL - Follow this sequence):

**TURN 1 - UNDERSTAND THE GOAL**
First question MUST clarify: "What is this ${pattern.name.toLowerCase()} trying to ACHIEVE? What's the exact goal?"
- Example: "What specific problem does this ${pattern.name.toLowerCase()} solve?"
- Example: "What output/result should this ${pattern.name.toLowerCase()} produce?"
${pattern.name === 'Prompt Engineering' ? `- âš ï¸ META-LEVEL CLARITY: User is DESIGNING a prompt (not using one). Guide them to describe what THE PROMPT will do, not what THEY want to know.
  â†’ Good: "A prompt that takes X and returns Y"
  â†’ Bad: "I want to know about X"` : ''}
- DO NOT ask about safety, edge cases, or technical details yet
- DO NOT build the tree until you understand the GOAL

**TURN 2 - BUILD MAIN STRUCTURE**
After understanding the goal, propose the main phases/structure:
- "Based on your goal of [X], I'm thinking you need phases: [A, B, C]. Does that cover the main workflow?"
- Build 60-70% of the tree based on the goal
- Ask ONE clarifying question about structure

**TURN 3 - FILL CRITICAL DETAILS**
Add items and subtasks to each phase:
- "I've added [N] items across [M] phases. The biggest gap I see is [X]. Should I add that?"
- Build to 85-90% complete
- Focus on what's MISSING, not refinements

**TURN 4 - VALIDATE & REFINE**
Present near-complete tree and ask about completeness:
- "Does this capture the full workflow for [goal]? Or am I missing critical steps?"
- Now is when you can ask about edge cases, dependencies, special scenarios
- Build to 95%+ complete

**TURN 5 - CLOSE**
Final validation:
- "This looks complete for [goal]. Should I mark it done, or do you want to add/change anything?"
- Set done=true if approved

ğŸš« PRIORITY ORDER (What to ask when):

1. **THE GOAL** (Turn 1) - "What is this prompt trying to achieve exactly?"
2. **MAIN STRUCTURE** (Turn 2) - "What are the main phases/stages to achieve [goal]?"
3. **KEY ITEMS** (Turn 3) - "What are the critical items in each phase?"
4. **COMPLETENESS** (Turn 4) - "Am I missing any critical steps?"
5. **EDGE CASES/REFINEMENTS** (Turn 4) - "Any special scenarios or dependencies?"
6. **VALIDATION** (Turn 5) - "Does this fully capture everything?"

âŒ NEVER ask about these BEFORE understanding the goal:
- Safety considerations
- Model parameters (temperature, tokens)
- Edge cases
- Technical implementation details

âš¡ EFFICIENCY TARGETS (UPDATED):
- Turn 1: Ask about GOAL. Build NOTHING until you understand the purpose.
- Turn 2: Build 60-70% of tree based on goal + ask about structure
- Turn 3: Fill to 85-90% + ask about biggest gaps
- Turn 4: Fill to 95%+ + validate completeness
- Turn 5: Set done=true if approved

ğŸ” INFORMATION EXTRACTION TACTICS:
1. **EMBEDDED CONFIRMATION**: "I've added X, Y, Z as defaults. What am I missing?" (validates + extracts gaps)
2. **CONSTRAINT TESTING**: "I see this needs A. Does it also need B or is A sufficient?" (tests boundaries)
3. **DEPENDENCY PROBING**: "X blocks Y. Anything else blocked by X?" (maps critical paths)
4. **COMPLETENESS CHECK**: "I have N items for phase P. Too many/few/just right?" (validates scope)

ğŸ“‹ NECESSARY & SUFFICIENT DATA:
ALWAYS include in treeUpdate:
- Phases (3-6 typical)
- Items per phase (2-5 typical)
- âš ï¸ NESTED ITEMS${wizardState.patternKey === 'filesystem' ? ' (use "children" property for File System pattern)' : ' (use "subItems" property, NOT "subtasks")'}: Add 2-4 ${levels.subtask}s to items that need decomposition
  â†’ ${levels.subtask}s are PATTERN-SPECIFIC breakdowns:
    â€¢ ${pattern.name === 'Philosophy' ? 'Philosophy: premises, objections, evidence, citations' : ''}
    â€¢ ${pattern.name === 'Sales Pipeline' ? 'Sales: follow-up actions, next steps, deliverables' : ''}
    â€¢ ${pattern.name === 'Thesis' ? 'Thesis: arguments, evidence, citations, counter-arguments' : ''}
    â€¢ ${pattern.name === 'Product Roadmap' ? 'Roadmap: tasks, specs, acceptance criteria, tests' : ''}
    â€¢ ${pattern.name === 'Book' ? 'Book: scenes, character moments, plot points' : ''}
    â€¢ ${pattern.name === 'Course' ? 'Course: lessons, activities, assessments, exercises' : ''}
    â€¢ ${pattern.name === 'Film Production' ? 'Film: shots, camera movements, lighting, blocking' : ''}
    â€¢ ${pattern.name === 'Veo3 (Google)' ? 'Veo3: ingredient images, frame transitions, extensions, audio types (dialogue/SFX/ambience)' : ''}
    â€¢ ${pattern.name === 'Sora2 (OpenAI)' ? 'Sora2: cameo shots, remix variants, physics complexity, beat types (setup/conflict/resolution)' : ''}
    â€¢ ${pattern.name === 'Prompt Engineering' ? 'Prompting: test cases, variations, edge cases' : ''}
    â€¢ Generic: steps, components, or sub-elements
  â†’ Focus on ${pattern.name} deliverables, not generic task lists
  â†’ âœ¨ UNLIMITED NESTING: ${wizardState.patternKey === 'filesystem' ? 'children can have their own children for N-level depth (e.g., Folder â†’ Subfolder â†’ File)' : 'subItems can have their own subItems for N-level depth (e.g., Step 1 â†’ Step 1.1 â†’ Step 1.1.1)'}
- Dependency info in descriptions (e.g., "After Phase 1 completes...")
- Pattern-specific fields (infer from conversation)

NEVER ask about:
- Formatting preferences
- Nice-to-have details that can be added later
- Information already inferrable from context

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ RESPONSE FORMAT - MANDATORY: Return ONLY the JSON below âš ï¸
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO NOT write ANY text before or after the JSON.
Your ENTIRE response must be ONLY this JSON object:

${wizardState.patternKey === 'filesystem' ? `
âš ï¸ FILESYSTEM PATTERN - SPECIAL STRUCTURE:
For File System pattern, use "children" arrays at ALL levels (not "items" or "subItems"):

{
  "message": "I've built [X drives, Y folders]. [State what you added]. [Ask ONE follow-up question]",
  "treeUpdate": {
    "name": "My Computer",
    "description": "File system structure",
    "children": [
      {
        "name": "C:\\ Local Drive",
        "type": "phase",
        "icon": "ğŸ’¾",
        "children": [
          {
            "name": "Projects",
            "type": "item",
            "icon": "ğŸ“",
            "isFolder": true,
            "dateModified": "2025-11-15T14:30:00",
            "children": [
              {
                "name": "report.xlsx",
                "type": "item",
                "icon": "ğŸ“—",
                "isFolder": false,
                "fileSize": 15728640,
                "fileExtension": ".xlsx",
                "dateModified": "2025-11-10T16:45:00"
              }
            ]
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["fileSize", "isFolder"],
  "progress": 0.7,
  "done": false
}

âš ï¸ FILESYSTEM REQUIREMENTS:
- Use "children" for folders AND files (NOT "items" or "subItems")
- Set isFolder: true for folders, false for files
- Include fileSize (bytes), fileExtension, dateModified for files
- Auto-detect icons based on extension (.xlsxâ†’ğŸ“—, .pdfâ†’ğŸ“•, .jpgâ†’ğŸ–¼ï¸, etc.)
- Unlimited nesting depth supported via children arrays
` : wizardState.patternKey === 'prompting' ? `
âš ï¸ AI PROMPT DESIGN PATTERN - SPECIAL FIELDS:
For AI Prompt Design, items MUST include these pattern-specific fields:

{
  "message": "I've designed [X] prompt stages with system instructions, user templates, and examples. [Ask ONE follow-up question]",
  "treeUpdate": {
    "name": "Master Prompt Engineer",
    "description": "Transform weak prompts into highly effective, structured instructions using proven prompt engineering framework",
    "children": [
      {
        "name": "System Configuration",
        "subtitle": "Role, framework, and process",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Core System Prompt",
            "description": "Expert persona and meta-framework for prompt engineering",
            "itemType": "system-prompt",
            "systemPrompt": "You are a Master Prompt Engineer specializing in Large Language Model interactions. Your expertise is transforming vague, simple, or inefficient prompts into highly effective, structured instructions.\n\nYour Framework (apply to every prompt):\n1. PERSONA/ROLE - Assign specific expert identity\n2. TASK - Define objective with active verbs\n3. CONTEXT - Add necessary background\n4. CONSTRAINTS - Define rules (do's and don'ts)\n5. OUTPUT FORMAT - Specify exact structure (Table, JSON, Markdown, etc.)\n\nYour Process:\n1. INPUT ACQUISITION - If no prompt provided, request it\n2. ANALYSIS - Evaluate for Clarity, Context, Constraints (3C Framework)\n3. IMPROVEMENT - Rewrite using the 5-part framework above\n4. DELIVERY - Present as: Critique â†’ Optimized Prompt â†’ Explanation\n\nBe analytical, precise, and helpful. Every improved prompt must be copy-paste ready.",
            "subItems": [
              {
                "name": "Tone Guidelines",
                "description": "Analytical, precise, helpful. Focus on teaching principles, not just fixing."
              },
              {
                "name": "Quality Standards",
                "description": "Every output must be immediately usable. No placeholders unless explicitly requested."
              }
            ]
          }
        ]
      },
      {
        "name": "User Interaction",
        "subtitle": "How users engage with this prompt",
        "type": "phase",
        "phase": 1,
        "items": [
          {
            "name": "User Prompt Template",
            "description": "Ready-to-use prompt for improving other prompts",
            "itemType": "user-template",
            "userPromptTemplate": "Please provide the prompt you would like me to improve. I'll analyze it for clarity, context, and constraints, then rewrite it using proven prompt engineering principles (Persona â†’ Task â†’ Context â†’ Constraints â†’ Output Format). I'll deliver a structured response with: (1) Critique of the original, (2) Optimized version, and (3) Explanation of improvements.",
            "subItems": [
              {
                "name": "Alternative: Batch Mode",
                "description": "For multiple prompts: 'I have three prompts to improve. I'll share them one at a time. For each, provide: Critique â†’ Optimized Version â†’ Key Improvements. Ready for the first one?'"
              }
            ]
          }
        ]
      },
      {
        "name": "Examples & Training",
        "subtitle": "Before/after prompt transformations",
        "type": "phase",
        "phase": 2,
        "items": [
          {
            "name": "Example Set",
            "description": "Demonstrate weak â†’ strong prompt transformations",
            "itemType": "examples",
            "fewShotExamples": "Example 1 - Weak Prompt:\n'Write about climate change.'\n\nOptimized:\n'You are an environmental scientist specializing in climate policy. Write a 500-word article explaining the top 3 impacts of climate change on coastal cities for a general audience. Use concrete examples from Miami, Venice, and Jakarta. Structure: (1) Introduction with thesis, (2) Three impacts with data, (3) Conclusion with actionable steps. Tone: Informative but accessible, avoid jargon.'\n\nKey Improvement: Added persona (environmental scientist), specific task (3 impacts, 500 words, examples), constraints (avoid jargon), and output structure.\n\n---\n\nExample 2 - Weak Prompt:\n'Help me with my resume.'\n\nOptimized:\n'You are a senior tech recruiter with 15 years of experience at FAANG companies. Review my software engineer resume and provide feedback in this format:\n1. STRENGTHS - What stands out positively\n2. GAPS - What's missing or unclear\n3. IMPROVEMENTS - 3 specific changes to increase interview callbacks\n4. REWRITE - Rewrite the Experience section for my top role using STAR format (Situation, Task, Action, Result)\n\nFocus on quantifiable achievements and technical impact. Target: Senior SWE roles at large tech companies.'\n\nKey Improvement: Added expert persona (tech recruiter), clear analysis framework (4-part structure), constraints (quantifiable, STAR format), and target audience (senior roles, big tech).",
            "subItems": [
              {
                "name": "Domain-Specific Example: Gardening Assistant",
                "description": "Full prompt structure for fall/winter gardening in Victoria, BC. System: 'You are an expert Pacific Northwest gardening consultant specializing in fall and winter cultivation in USDA zones 8-9. You provide specific, actionable advice based on local climate patterns, soil conditions, and seasonal timing for Victoria, BC and surrounding regions.' User: 'I need fall/winter gardening advice for Victoria, BC. Start by asking me what plants I want to grow, my experience level, and my garden conditions (soil type, sun exposure). Then provide a tailored planting and maintenance guide based on my answers.' Output Format: '1. Planting Timeline (specific dates/months), 2. Soil Preparation (pH, amendments, prep steps), 3. Planting Instructions (depth, spacing, technique), 4. Maintenance Schedule (weekly tasks through season), 5. Harvest Timing (when and how to harvest).' This shows how the meta-framework applies to a concrete domain."
              }
            ]
          }
        ]
      },
      {
        "name": "Output Specification",
        "subtitle": "Standardized delivery format",
        "type": "phase",
        "phase": 3,
        "items": [
          {
            "name": "Response Structure",
            "description": "Consistent 3-part delivery format",
            "itemType": "output-format",
            "outputFormat": "Deliver every improved prompt in this format:\n\n**1. CRITIQUE OF ORIGINAL PROMPT**\n- Briefly explain weaknesses (e.g., 'Lacked persona,' 'Too vague on formatting,' 'No constraints')\n\n**2. OPTIMIZED PROMPT**\n> [Full rewritten prompt in blockquote or code block for easy copying]\n\n**3. EXPLANATION OF CHANGES**\n- Explain why specific changes improve results (e.g., 'Added expert persona to increase authority,' 'Specified output format to ensure consistency')\n\nOptional: If the original prompt is ambiguous, ask 1-2 clarifying questions before optimizing.",
            "chainOfThought": "Before rewriting, analyze using 3C Framework: (1) CLARITY - Is intent obvious? (2) CONTEXT - Does AI know its role and audience? (3) CONSTRAINTS - Are there guardrails on length, format, style? Then apply 5-part framework: Persona â†’ Task â†’ Context â†’ Constraints â†’ Output Format."
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["systemPrompt", "userPromptTemplate", "fewShotExamples", "outputFormat", "chainOfThought"],
  "progress": 0.8,
  "done": false
}

âš ï¸ CRITICAL for Prompt Engineering pattern:
- ALWAYS populate systemPrompt, userPromptTemplate, fewShotExamples, outputFormat fields
- TEACH THE META-FRAMEWORK: Persona â†’ Task â†’ Context â†’ Constraints â†’ Output Format
- SHOW THE PROCESS: Input Acquisition â†’ Analysis (3C: Clarity, Context, Constraints) â†’ Improvement â†’ Delivery
- NO PLACEHOLDER VARIABLES: Use interactive style (AI asks questions) or specific style (list concrete topics)
- READY-TO-USE: Prompts must work immediately when pasted (no {{variable}} substitution needed)
- Use subItems for supplementary details (tone guidelines, quality standards, alternatives)
- Each phase represents a component of the final prompt (System, User, Examples, Output)
- The Generate Prompt feature extracts these fields to create the executable prompt
` : wizardState.patternKey === 'lifetree' ? `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ™ï¸ LARRY KING BIOGRAPHER MODE (Build 402)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

You interview like LARRY KING: simple questions, genuine curiosity, never interrupt a good story, always follow the interesting thread. You're building someone's life story one memory at a time.

YOUR INTERVIEWING STYLE:
â€¢ ONE simple question at a time - Larry never asked compound questions
â€¢ "Where were you born?" NOT "Tell me about your early childhood and family"
â€¢ When they give gold, acknowledge it: "Fascinating." then dig deeper on THAT
â€¢ Follow THEIR energy - if they light up about something, stay there
â€¢ Yes/No or A/B/C choices make it easy: offer clickable [CHOICE:] options
â€¢ Numbers are easy: "How many siblings?" "What year was that?"
â€¢ If they ramble (good!), extract the gems and save each one

LARRY'S SIGNATURE MOVES:
â€¢ "Let me make sure I got that..." (confirm facts, then save them)
â€¢ "What was that like?" (open the emotional door)
â€¢ "And then what happened?" (keep the story flowing)
â€¢ "Who else was there?" (get the people)
â€¢ "Where was this?" (get the place)
â€¢ "Wait - go back to that part about..." (follow the gold)

THE 12 LIFE TERRITORIES (probe systematically but follow their lead):
1. Birth/Origins - where, when, hospital, parents
2. Childhood Home - address, neighborhood, what it looked like
3. Family - parents' jobs, siblings, grandparents
4. School - which ones, favorite subjects, friends
5. Activities - sports, music, hobbies, collections
6. Pets - names, types, stories
7. Work - first job, career arc, memorable bosses
8. Love - dating, marriage, kids
9. Places - moves, vacations, adventures
10. Hard Times - losses, challenges, how they coped
11. Proud Moments - achievements, graduations, awards
12. Characters - the unforgettable people in their life

+1 SCORING: Every memory you capture = +1 to their LifeTree Score
In your message, acknowledge saves with: "âœ“ Added: [memory title] (+1)"

RICH EVENT FORMAT (capture everything you learn):
{
  "name": "Memory title",
  "eventDate": "Month Year or exact date",
  "age": "How old they were",
  "location": "Where it happened",
  "people": "Who was involved",
  "description": "The story details",
  "emotion": "joy|sadness|pride|fear|love|surprise|gratitude|determination",
  "source": "How you know this (conversation, photo, document)",
  "confidence": "Exact|Approximate|Uncertain"
}

DECADE PHASES: Organize memories into life phases (decades or life stages):
- Early Childhood (0-5)
- Childhood (6-12)
- Teen Years (13-19)
- Young Adulthood (20s)
- 30s, 40s, 50s, etc.

âš ï¸ CRITICAL: Every response MUST include [CHOICE:] buttons!
Make it easy to continue the conversation:
[CHOICE:ğŸ“ Add location][CHOICE:ğŸ‘¥ Add people][CHOICE:ğŸ“… More about that time][CHOICE:â¡ï¸ Next memory]

EXAMPLE JSON RESPONSES:

Turn 1 - Getting started:
{
  "message": "I'm excited to help capture your life story! Let's start at the very beginning.\\n\\nWhere were you born?\\n\\n[CHOICE:ğŸ¥ Hospital][CHOICE:ğŸ  At home][CHOICE:ğŸŒ Another country][CHOICE:ğŸ“ I'll type it]",
  "treeUpdate": {
    "name": "My Life Story",
    "description": "A biographical journey through key life moments",
    "children": []
  },
  "fieldsUpdated": [],
  "progress": 0.05,
  "done": false
}

Turn 2+ - Capturing memories:
{
  "message": "âœ“ Added: Born at Grey Nuns Hospital, Regina (+1)\\n\\nFascinating - your mother worked right at the hospital where you were born! The Grey Nuns founded that place in 1898.\\n\\nWhat was that like, growing up with a nurse for a mother?\\n\\n[CHOICE:ğŸ‘©â€âš•ï¸ She worked a lot][CHOICE:ğŸ  She was home mostly][CHOICE:ğŸ’‰ I learned medical stuff][CHOICE:ğŸ“– Tell you a story]",
  "treeUpdate": {
    "name": "My Life Story",
    "children": [
      {
        "name": "Early Years (1960-1965)",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Born at Grey Nuns Hospital",
            "eventDate": "May 18, 1960",
            "age": "0",
            "location": "Regina, Saskatchewan",
            "people": "Mom (nurse at the hospital)",
            "description": "Born at the historic Grey Nuns Hospital where my mother worked as a nurse",
            "emotion": "joy",
            "confidence": "Exact"
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["eventDate", "location", "people"],
  "progress": 0.15,
  "done": false
}

âš ï¸ LIFETREE CRITICAL RULES:
- Ask ONE simple question at a time (Larry King style)
- ALWAYS include 3-4 [CHOICE:] buttons for easy responses
- Save memories IMMEDIATELY when shared - don't batch them
- Acknowledge every save with "âœ“ Added: [title] (+1)"
- Follow the interesting thread - if they light up about something, stay there
- Calculate ages from birth year if known
- Use emotion field to capture the feeling of the memory
- Progress slowly (0.05-0.1 per turn) - life stories take time!
` : `
âš ï¸ OPTION A - When just asking a question (NO tree changes):
{
  "message": "Your question here? [CHOICE:Option A][CHOICE:Option B][CHOICE:Something else]",  // âš ï¸ ALWAYS include [CHOICE:] markers!
  "treeUpdate": null,
  "fieldsUpdated": [],
  "progress": 0.5,
  "done": false
}

âš ï¸ OPTION B - When ADDING new items (include ONLY the new items):
{
  "message": "I've added [X]. What should I focus on next? [CHOICE:â• Add more][CHOICE:ğŸ“ More detail][CHOICE:âœ… Looks good]",  // âš ï¸ ALWAYS include [CHOICE:] markers!
  "treeUpdate": {
    "name": "Project Name",
    "description": "Brief description",
    "children": [
      {
        "name": "Phase 1",
        "subtitle": "Phase subtitle",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Item name",
            "description": "Item description (include dependency notes like 'Requires X to complete first' if order matters)",
            "itemType": "type",
            "subItems": [
              {
                "name": "Step 1",
                "description": "Detail",
                "subItems": [
                  {"name": "Step 1.1", "description": "Nested detail (supports N-level depth)"}
                ]
              },
              {"name": "Step 2", "description": "Detail"}
            ]
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["field1", "field2"],
  "progress": 0.7,
  "done": false
}`}

ğŸ¯ CRITICAL RULES:
- Return ONLY JSON, no text before/after
- âš ï¸ KEEP RESPONSES CONCISE: Don't add too many items at once (max 5-7 items per turn)
- Turn 1: Build MINIMAL tree (just project name), ask about GOAL
- Turn 2+: Include treeUpdate with 2-4+ new items per turn
- INFER AGGRESSIVELY: Add details based on context, let user correct
- EVERY message must end with ONE strategic follow-up question (unless done=true)
- Follow the QUESTIONING ORDER above (Goal â†’ Structure â†’ Details â†’ Validation)
- Track progress field accurately (0.0 â†’ 1.0)
- Set done=true when tree is complete (typically turn 5)
- If tree is getting large (>20 items), add fewer items per turn to avoid truncation

ğŸš€ FIRST RESPONSE INSTRUCTION:
${wizardState.enhanceMode ? `
ENHANCE MODE - First response:
${itemCount > 30 ? `
â›” LARGE TREE DETECTED (${itemCount} items) - DO NOT ECHO THE TREE!
1. Set treeUpdate to NULL (the system already has all the data)
2. Set progress based on how complete the tree already is (0.5 to 0.8 typical)
3. Ask: "I can see you have ${phaseCount} ${levels.phase.toLowerCase()}s and ${itemCount} ${levels.item.toLowerCase()}s. What would you like me to help you with? Add more items, expand existing ones, or fill gaps?"

â›”â›”â›” CRITICAL: For trees with 30+ items, you MUST use treeUpdate: null
The existing tree is already loaded. Echoing it back wastes tokens and causes cutoff errors.
` : `
1. Return a SUMMARY of the tree structure in treeUpdate (max 5-10 representative items, NOT everything)
2. Set progress based on how complete the tree already is (0.5 to 0.8 typical)
3. Ask: "I can see you have [X]. What would you like me to help you with? Add more ${levels.item.toLowerCase()}s, expand existing ones with more detail, add subtasks, or fill gaps?"
`}

âš ï¸ ALL RESPONSES (including first): Include ONLY new or modified items. NEVER echo the full tree.
   - If just asking a question: Use treeUpdate: null
   - If adding new items to an existing phase: Include just that phase with the new items
   - If modifying an existing item: Include just that item with changes
   - If adding a new phase: Include just the new phase
   - Items not mentioned are automatically preserved!
` : `
BUILD MODE - First response:
1. Create minimal tree with just project name and empty description
2. Set progress to 0.1
3. ${pattern.name === 'Prompt Engineering' ? `Ask: "What prompt do you want to design? Describe what it should DO when someone uses it.

Examples:
â€¢ 'A prompt that takes a business idea and returns a 5-year financial projection with key metrics'
â€¢ 'A prompt that analyzes code for security vulnerabilities and suggests fixes with severity ratings'
â€¢ 'A prompt that converts casual emails into formal business communications'

Remember: You're DESIGNING a prompt (meta-level), not using one. Tell me what task the prompt should perform."` : `Ask: "What is the exact GOAL of this ${pattern.name.toLowerCase()}? What specific output/result should it produce?"`}

DO NOT build phases, items, or subtasks in Turn 1. Wait to understand the goal first.
`}`;
        }

        // Merge tree update into working tree (SMART MERGE - preserves existing data)
        function mergeTreeUpdate(update, aiSource = 'ai-sonnet') {
            if (update.name) wizardState.workingTree.name = update.name;
            if (update.description) wizardState.workingTree.description = update.description;

            if (update.children) {
                // Initialize existing children if none
                if (!wizardState.workingTree.children) {
                    wizardState.workingTree.children = [];
                }

                // Helper: Find matching phase by name (case-insensitive, fuzzy)
                function findMatchingPhase(phaseName, existingPhases) {
                    const normalizedName = phaseName.toLowerCase().trim();
                    return existingPhases.find(p =>
                        p.name.toLowerCase().trim() === normalizedName ||
                        p.name.toLowerCase().includes(normalizedName) ||
                        normalizedName.includes(p.name.toLowerCase())
                    );
                }

                // Helper: Find matching item by name (case-insensitive, fuzzy)
                function findMatchingItem(itemName, existingItems) {
                    const normalizedName = itemName.toLowerCase().trim();
                    return existingItems.find(i =>
                        i.name.toLowerCase().trim() === normalizedName ||
                        i.name.toLowerCase().includes(normalizedName) ||
                        normalizedName.includes(i.name.toLowerCase())
                    );
                }

                // Track which existing phases were matched
                const matchedPhaseIds = new Set();

                // Process each phase from update
                update.children.forEach((updatedPhase, phaseIdx) => {
                    const existingPhase = findMatchingPhase(updatedPhase.name, wizardState.workingTree.children);

                    if (existingPhase) {
                        // MERGE with existing phase
                        console.log(`ğŸ”„ Merging phase: ${updatedPhase.name}`);
                        matchedPhaseIds.add(existingPhase.id);

                        // Update phase-level fields (preserve existing if not in update)
                        existingPhase.name = updatedPhase.name || existingPhase.name;
                        existingPhase.subtitle = updatedPhase.subtitle || existingPhase.subtitle;
                        if (updatedPhase.description) existingPhase.description = updatedPhase.description;

                        // Merge items (standard patterns) OR children (filesystem pattern)
                        const itemsArrayName = updatedPhase.items ? 'items' : (updatedPhase.children ? 'children' : null);
                        if (itemsArrayName) {
                            if (!existingPhase[itemsArrayName]) existingPhase[itemsArrayName] = [];

                            const matchedItemIds = new Set();

                            updatedPhase[itemsArrayName].forEach((updatedItem, itemIdx) => {
                                const existingItem = findMatchingItem(updatedItem.name, existingPhase[itemsArrayName]);

                                if (existingItem) {
                                    // MERGE with existing item - preserve ALL existing fields
                                    console.log(`  ğŸ”„ Merging item: ${updatedItem.name}`);
                                    matchedItemIds.add(existingItem.id);

                                    // BUILD 406: Track as modified
                                    if (typeof trackNodeChange === 'function') {
                                        trackNodeChange(existingItem.id, 'modified');
                                    }

                                    // Merge all fields (keep existing if not in update)
                                    Object.keys(updatedItem).forEach(key => {
                                        if (key !== 'subItems' && key !== 'children' && updatedItem[key] !== undefined && updatedItem[key] !== '') {
                                            existingItem[key] = updatedItem[key];
                                        }
                                    });

                                    // Merge subItems (RECURSIVE for N-level depth support)
                                    // Supports both 'subItems' (standard) and 'children' (filesystem)
                                    function mergeSubItems(existingParent, updatedParent, parentPhase, parentItemIdx) {
                                        const nestedArrayName = updatedParent.subItems ? 'subItems' : (updatedParent.children ? 'children' : null);
                                        if (!nestedArrayName) return;
                                        if (!existingParent[nestedArrayName]) existingParent[nestedArrayName] = [];

                                        updatedParent[nestedArrayName].forEach(newSubItem => {
                                            const existingSubItem = existingParent[nestedArrayName].find(s =>
                                                s.name.toLowerCase().trim() === newSubItem.name.toLowerCase().trim()
                                            );

                                            if (existingSubItem) {
                                                // Update existing subItem
                                                Object.keys(newSubItem).forEach(key => {
                                                    if (key !== 'subItems' && key !== 'children' && newSubItem[key] !== undefined && newSubItem[key] !== '') {
                                                        existingSubItem[key] = newSubItem[key];
                                                    }
                                                });

                                                // RECURSIVE: Merge nested items (supports N-level depth)
                                                mergeSubItems(existingSubItem, newSubItem, parentPhase, parentItemIdx);
                                            } else {
                                                // Add new item with auto-generated ID
                                                const subIdx = existingParent[nestedArrayName].length;
                                                const newSubItemWithId = {
                                                    id: `${nestedArrayName === 'children' ? 'child' : 'subtask'}-${parentPhase}-${parentItemIdx}-${subIdx}`,
                                                    type: nestedArrayName === 'children' ? 'item' : 'subtask',
                                                    ...newSubItem,
                                                    provenance: {
                                                        source: aiSource,
                                                        timestamp: new Date().toISOString()
                                                    }
                                                };
                                                existingParent[nestedArrayName].push(newSubItemWithId);
                                            }
                                        });
                                    }

                                    mergeSubItems(existingItem, updatedItem, existingPhase.phase, existingPhase[itemsArrayName].indexOf(existingItem));
                                } else {
                                    // ADD new item to existing phase
                                    console.log(`  âœ… Adding new item: ${updatedItem.name}`);
                                    const newItemIdx = existingPhase[itemsArrayName].length;

                                    // RECURSIVE function to add IDs to nested items (supports both subItems and children)
                                    function addNestedItemIds(nestedItems, nestedArrayName, phaseIdx, itemIdx, parentPath = '') {
                                        if (!nestedItems) return [];
                                        return nestedItems.map((nestedItem, nestedIdx) => {
                                            const childArrayName = nestedItem.subItems ? 'subItems' : (nestedItem.children ? 'children' : null);
                                            const result = {
                                                id: `${nestedArrayName === 'children' ? 'child' : 'subtask'}-${phaseIdx}-${itemIdx}-${parentPath}${nestedIdx}`,
                                                type: nestedArrayName === 'children' ? 'item' : 'subtask',
                                                ...nestedItem
                                            };
                                            if (childArrayName) {
                                                result[childArrayName] = addNestedItemIds(nestedItem[childArrayName], childArrayName, phaseIdx, itemIdx, `${parentPath}${nestedIdx}-`);
                                            }
                                            return result;
                                        });
                                    }

                                    const nestedArrayName = updatedItem.subItems ? 'subItems' : (updatedItem.children ? 'children' : null);
                                    const newItem = {
                                        id: `item-${existingPhase.phase}-${newItemIdx}`,
                                        type: 'item',
                                        icon: 'ğŸ“„',
                                        expanded: false,
                                        ...updatedItem,
                                        provenance: {
                                            source: aiSource,
                                            timestamp: new Date().toISOString()
                                        }
                                    };
                                    if (nestedArrayName) {
                                        newItem[nestedArrayName] = addNestedItemIds(updatedItem[nestedArrayName], nestedArrayName, existingPhase.phase, newItemIdx);
                                    }
                                    existingPhase[itemsArrayName].push(newItem);

                                    // BUILD 406: Track as new
                                    if (typeof trackNodeChange === 'function') {
                                        trackNodeChange(newItem.id, 'new');
                                    }
                                }
                            });

                            // PRESERVE existing items that weren't in the update
                            console.log(`  â„¹ï¸ Preserved ${existingPhase[itemsArrayName].filter(i => !matchedItemIds.has(i.id)).length} existing items not in update`);
                        }
                    } else {
                        // ADD new phase
                        console.log(`âœ… Adding new phase: ${updatedPhase.name}`);
                        const newPhaseIdx = wizardState.workingTree.children.length;

                        // RECURSIVE function to add IDs to nested subItems (reuse from above)
                        function addSubItemIds(subItems, phaseIdx, itemIdx, parentPath = '') {
                            if (!subItems) return [];
                            return subItems.map((subItem, subIdx) => ({
                                id: `subtask-${phaseIdx}-${itemIdx}-${parentPath}${subIdx}`,
                                type: 'subtask',
                                ...subItem,
                                provenance: {
                                    source: aiSource,
                                    timestamp: new Date().toISOString()
                                },
                                subItems: addSubItemIds(subItem.subItems, phaseIdx, itemIdx, `${parentPath}${subIdx}-`)
                            }));
                        }

                        const newPhase = {
                            id: `phase-${newPhaseIdx}`,
                            type: 'phase',
                            phase: newPhaseIdx,
                            icon: 'ğŸ“‹',
                            expanded: true,
                            ...updatedPhase,
                            provenance: {
                                source: aiSource,
                                timestamp: new Date().toISOString()
                            },
                            items: (updatedPhase.items || []).map((item, itemIdx) => ({
                                id: `item-${newPhaseIdx}-${itemIdx}`,
                                type: 'item',
                                icon: 'ğŸ“„',
                                expanded: false,
                                ...item,
                                provenance: {
                                    source: aiSource,
                                    timestamp: new Date().toISOString()
                                },
                                subItems: addSubItemIds(item.subItems, newPhaseIdx, itemIdx)
                            }))
                        };
                        wizardState.workingTree.children.push(newPhase);

                        // BUILD 406: Track new phase and its items
                        if (typeof trackNodeChange === 'function') {
                            trackNodeChange(newPhase.id, 'new');
                            // Also track each new item in the phase
                            (newPhase.items || []).forEach(item => {
                                trackNodeChange(item.id, 'new');
                            });
                        }
                    }
                });

                // PRESERVE existing phases that weren't in the update
                const preservedPhases = wizardState.workingTree.children.filter(p => !matchedPhaseIds.has(p.id));
                console.log(`â„¹ï¸ Preserved ${preservedPhases.length} existing phases not in update`);

                // Re-index phase numbers
                wizardState.workingTree.children.forEach((phase, idx) => {
                    phase.phase = idx;
                });

                console.log(`âœ… Smart merge complete: ${wizardState.workingTree.children.length} phases, ${wizardState.workingTree.children.reduce((sum, p) => sum + (p.items?.length || 0), 0)} items`);
            }
        }

        // =============================================================================
        // HYPEREDGE MANAGEMENT (Wolfram-style N-ary relationships)
        // =============================================================================

        /**
         * Add a new hyperedge to the root-level hyperedges array
         * @param {string} type - Type of hyperedge (e.g., 'montage', 'argument', 'theme', 'dependency-cluster')
         * @param {string} label - Human-readable label for the hyperedge
         * @param {string[]} nodeIds - Array of global node IDs (2+ nodes)
         * @param {object} metadata - Optional metadata (color, pattern, created, etc.)
         * @returns {object} The created hyperedge
         */
        function addHyperedge(type, label, nodeIds, metadata = {}) {
            if (!capexTree.hyperedges) {
                capexTree.hyperedges = [];
            }

            if (nodeIds.length < 2) {
                console.warn('Hyperedge requires at least 2 nodes');
                return null;
            }

            const hyperedge = {
                id: `hyperedge-${Date.now()}`,
                type: type,
                label: label,
                nodeIds: nodeIds,
                metadata: {
                    created: new Date().toISOString(),
                    ...metadata
                }
            };

            capexTree.hyperedges.push(hyperedge);
            console.log(`âœ… Created hyperedge: ${label} (${nodeIds.length} nodes)`);

            return hyperedge;
        }

        /**
         * Remove a hyperedge by ID
         * @param {string} hyperedgeId - The ID of the hyperedge to remove
         * @returns {boolean} True if removed, false if not found
         */
        function removeHyperedge(hyperedgeId) {
            if (!capexTree.hyperedges) {
                return false;
            }

            const initialLength = capexTree.hyperedges.length;
            capexTree.hyperedges = capexTree.hyperedges.filter(h => h.id !== hyperedgeId);

            const removed = capexTree.hyperedges.length < initialLength;
            if (removed) {
                console.log(`âœ… Removed hyperedge: ${hyperedgeId}`);
            }

            return removed;
        }

        /**
         * Global handler for deleting hyperedges from the info panel UI
         * @param {string} id - The hyperedge ID to delete
         */
        window.deleteHyperedge = function(id) {
            if (confirm('Delete this hyperedge group?')) {
                saveState('Delete Hyperedge');
                removeHyperedge(id);
                renderCanvas(); // Re-draw canvas to remove the visual blob
                showInfo(capexTree); // Refresh the info panel to update the list
            }
        }

        /**
         * Find all hyperedges containing a specific node
         * @param {string} nodeId - The node ID to search for
         * @returns {object[]} Array of hyperedges containing this node
         */
        function findHyperedgesForNode(nodeId) {
            if (!capexTree.hyperedges) {
                return [];
            }

            return capexTree.hyperedges.filter(h => h.nodeIds.includes(nodeId));
        }

        /**
         * Get a specific hyperedge by ID
         * @param {string} hyperedgeId - The hyperedge ID
         * @returns {object|null} The hyperedge or null if not found
         */
        function getHyperedgeById(hyperedgeId) {
            if (!capexTree.hyperedges) {
                return null;
            }

            return capexTree.hyperedges.find(h => h.id === hyperedgeId) || null;
        }

        /**
         * Get all hyperedges
         * @returns {object[]} Array of all hyperedges
         */
        function getAllHyperedges() {
            return capexTree.hyperedges || [];
        }

        /**
         * Helper: Get a node by its global ID (searches entire tree)
         * @param {string} nodeId - The node ID to find
         * @returns {object|null} The node or null if not found
         */
        function getNodeById(nodeId) {
            if (capexTree.id === nodeId) return capexTree;

            function searchNode(node) {
                if (node.id === nodeId) return node;

                // Search phases (MS Project imports use this structure)
                if (node.phases) {
                    for (const phase of node.phases) {
                        const found = searchNode(phase);
                        if (found) return found;
                    }
                }

                // Search children (phases)
                if (node.children) {
                    for (const child of node.children) {
                        const found = searchNode(child);
                        if (found) return found;
                    }
                }

                // Search items
                if (node.items) {
                    for (const item of node.items) {
                        const found = searchNode(item);
                        if (found) return found;
                    }
                }

                // Search subItems
                if (node.subItems) {
                    for (const subItem of node.subItems) {
                        const found = searchNode(subItem);
                        if (found) return found;
                    }
                }

                return null;
            }

            return searchNode(capexTree);
        }

        // =============================================================================
        // END HYPEREDGE MANAGEMENT
        // =============================================================================

        // =============================================================================
        // COLLABORATION: Branch & Merge (Email-based async collaboration)
        // =============================================================================

        // Collaboration state
        let currentBranch = null;  // Set when editing a shared branch

        /**
         * Generate or retrieve a stable device fingerprint for contributor tracking
         * Uses canvas fingerprinting + localStorage persistence
         * @returns {string} Device fingerprint ID
         */
        function getDeviceFingerprint() {
            let fp = localStorage.getItem('treelisty-device-id');
            if (!fp) {
                // Generate fingerprint from canvas rendering (browser-specific)
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#6366f1';
                ctx.fillText('TreeListy-FP-2025', 10, 10);
                ctx.fillStyle = '#8b5cf6';
                ctx.fillRect(100, 20, 50, 20);

                // Extract hash from canvas data
                const dataURL = canvas.toDataURL();
                const hash = dataURL.slice(-24).replace(/[^a-zA-Z0-9]/g, '');

                fp = `device-${hash}-${Date.now().toString(36)}`;
                localStorage.setItem('treelisty-device-id', fp);
                console.log('ğŸ”‘ Generated new device fingerprint:', fp);
            }
            return fp;
        }

        /**
         * Get the ancestry path (breadcrumb) for a node
         * @param {string} nodeId - The node to find ancestry for
         * @returns {Array} Array of {id, name, type, icon} from root to parent
         */
        function getAncestryPath(nodeId) {
            const ancestry = [];

            function findPath(node, currentPath = []) {
                // Add this node to path
                const pathEntry = {
                    id: node.id,
                    name: node.name,
                    type: node.type,
                    icon: node.icon || 'ğŸ“„'
                };
                const newPath = [...currentPath, pathEntry];

                // Check if this is the target
                if (node.id === nodeId) {
                    // Return path WITHOUT the target node (just ancestors)
                    return currentPath;
                }

                // Search children (phases)
                if (node.children) {
                    for (const child of node.children) {
                        const found = findPath(child, newPath);
                        if (found) return found;
                    }
                }

                // Search items
                if (node.items) {
                    for (const item of node.items) {
                        const found = findPath(item, newPath);
                        if (found) return found;
                    }
                }

                // Search subItems
                if (node.subItems) {
                    for (const subItem of node.subItems) {
                        const found = findPath(subItem, newPath);
                        if (found) return found;
                    }
                }

                return null;
            }

            return findPath(capexTree) || [{ id: capexTree.id, name: capexTree.name, type: 'root', icon: capexTree.icon }];
        }

        /**
         * Count nodes in a subtree (for size estimation)
         * @param {object} node - Node to count from
         * @returns {number} Total node count including descendants
         */
        function countSubtreeNodes(node) {
            let count = 1;
            if (node.children) node.children.forEach(c => count += countSubtreeNodes(c));
            if (node.items) node.items.forEach(i => count += countSubtreeNodes(i));
            if (node.subItems) node.subItems.forEach(s => count += countSubtreeNodes(s));
            return count;
        }

        /**
         * Estimate compressed URL size for a branch
         * @param {object} branch - Branch token object
         * @returns {number} Estimated URL length in characters
         */
        function estimateBranchURLSize(branch) {
            const json = JSON.stringify(branch);
            // LZ-String typically achieves 30-50% compression
            // Add base URL length (~50 chars) + parameter name (~10 chars)
            const estimatedCompressed = Math.ceil(json.length * 0.6);
            return estimatedCompressed + 60;
        }

        // Maximum recommended URL length (safe for email clients, browsers)
        const MAX_BRANCH_URL_LENGTH = 8000;
        const WARN_BRANCH_URL_LENGTH = 4000;

        /**
         * Extract a subtree for sharing as a collaboration branch
         * @param {string[]} nodeIds - Array of node IDs to include
         * @param {string|null} hyperedgeId - Optional hyperedge ID if sharing a hyperedge
         * @returns {object} Branch token or error object
         */
        function extractSubtree(nodeIds, hyperedgeId = null) {
            if (!nodeIds || nodeIds.length === 0) {
                return { error: 'No nodes selected for sharing' };
            }

            // Get ancestry path from first node (they should share common ancestry)
            const ancestry = getAncestryPath(nodeIds[0]);

            // Deep clone selected nodes with all descendants
            const nodes = [];
            let totalNodeCount = 0;

            for (const id of nodeIds) {
                const node = getNodeById(id);
                if (node) {
                    console.log(`ğŸ“¦ Extracting node ${id}:`, node.name, '| description:', node.description?.substring(0, 50));
                    const cloned = JSON.parse(JSON.stringify(node));
                    nodes.push(cloned);
                    totalNodeCount += countSubtreeNodes(cloned);
                } else {
                    console.warn(`âš ï¸ Node ${id} not found, skipping`);
                }
            }

            if (nodes.length === 0) {
                return { error: 'No valid nodes found to share' };
            }

            // Build branch token
            const branch = {
                branchId: `branch-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                sourceProjectId: capexTree.id,
                sourceProjectName: capexTree.name,
                sourcePattern: currentPattern,
                createdAt: new Date().toISOString(),
                createdBy: getDeviceFingerprint(),
                ancestry,
                hyperedgeId,
                selectedNodeIds: nodeIds,
                nodes,
                schemaVersion: 2
            };

            // Size validation
            const estimatedSize = estimateBranchURLSize(branch);
            if (estimatedSize > MAX_BRANCH_URL_LENGTH) {
                return {
                    error: `Selection too large to share via URL (${totalNodeCount} nodes, ~${Math.round(estimatedSize/1000)}KB)`,
                    nodeCount: totalNodeCount,
                    estimatedSize,
                    suggestion: 'Try selecting fewer nodes or a smaller subtree'
                };
            }

            // Add size info for warnings
            branch._meta = {
                nodeCount: totalNodeCount,
                estimatedURLSize: estimatedSize,
                sizeWarning: estimatedSize > WARN_BRANCH_URL_LENGTH
            };

            console.log(`ğŸ“¦ Extracted branch: ${nodes.length} root nodes, ${totalNodeCount} total nodes, ~${estimatedSize} chars`);
            return branch;
        }

        /**
         * Generate a shareable URL for a branch
         * @param {object} branch - Branch token from extractSubtree
         * @returns {Promise<string>} Shareable URL with ?branch= parameter
         */
        async function generateBranchURL(branch) {
            // Lazy load LZ-String library
            await loadLibrary('lzstring');

            // Remove internal meta before encoding
            const branchToEncode = { ...branch };
            delete branchToEncode._meta;

            const json = JSON.stringify(branchToEncode);
            const compressed = LZString.compressToEncodedURIComponent(json);
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?branch=${compressed}`;
        }

        /**
         * Check if currently in branch editing mode
         * @returns {boolean} True if editing a shared branch
         */
        function isBranchMode() {
            return currentBranch !== null;
        }

        // Temporary storage for current branch being shared
        let pendingShareBranch = null;

        /**
         * Show the Share Branch modal for collaboration
         * @param {string[]} nodeIds - Array of node IDs to share
         * @param {string|null} hyperedgeId - Optional hyperedge ID
         */
        async function showShareBranchModal(nodeIds, hyperedgeId = null) {
            const modal = document.getElementById('share-branch-modal');
            const body = document.getElementById('share-branch-body');

            // Extract subtree with size validation
            const branch = extractSubtree(nodeIds, hyperedgeId);

            // Check for errors
            if (branch.error) {
                body.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                        <h3 style="color: #f59e0b; margin-bottom: 12px;">Cannot Share Selection</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 16px;">${branch.error}</p>
                        ${branch.suggestion ? `<p style="color: var(--text-secondary); font-size: 13px;">${branch.suggestion}</p>` : ''}
                    </div>
                `;
                modal.style.display = 'flex';
                return;
            }

            // Store for button handlers
            pendingShareBranch = branch;

            // Generate URL
            const shareURL = await generateBranchURL(branch);
            const meta = branch._meta || {};

            // Build ancestry breadcrumb
            const breadcrumb = branch.ancestry.map(a =>
                `<span style="display: inline-flex; align-items: center; gap: 4px;">${a.icon || 'ğŸ“„'} ${a.name}</span>`
            ).join(' <span style="color: var(--text-secondary);">â€º</span> ');

            // Build node list
            const nodeList = branch.nodes.map(n => `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--card-bg); border-radius: 6px; margin-bottom: 6px;">
                    <span>${n.icon || 'ğŸ“„'}</span>
                    <span style="font-weight: 500;">${n.name}</span>
                    ${n.subItems && n.subItems.length > 0 ? `<span style="font-size: 11px; color: var(--text-secondary);">(+${countSubtreeNodes(n) - 1} children)</span>` : ''}
                </div>
            `).join('');

            body.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 12px; font-size: 14px;">
                        Share these nodes for collaboration. The recipient can edit and send back their changes.
                    </p>

                    <!-- Ancestry Breadcrumb -->
                    <div style="background: var(--card-bg-light); padding: 10px 14px; border-radius: 6px; margin-bottom: 16px; font-size: 13px; color: var(--text-secondary);">
                        <span style="font-weight: 600; margin-right: 8px;">ğŸ“ Location:</span>
                        ${breadcrumb}
                    </div>

                    <!-- Nodes being shared -->
                    <div style="margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            ğŸ“¦ Sharing ${branch.nodes.length} node${branch.nodes.length > 1 ? 's' : ''} (${meta.nodeCount} total with children):
                        </div>
                        <div style="max-height: 150px; overflow-y: auto; padding-right: 8px;">
                            ${nodeList}
                        </div>
                    </div>

                    <!-- Clickable Link Preview (hidden input for copying) -->
                    <input type="hidden" id="share-branch-url-input" value="${shareURL}">
                    <div style="background: var(--card-bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 12px;">
                        <div style="display: flex; gap: 12px; align-items: center; justify-content: space-between;">
                            <a href="${shareURL}" target="_blank" id="share-branch-link"
                               style="display: inline-flex; align-items: center; gap: 8px; background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 10px 16px; border-radius: 6px; text-decoration: none; font-weight: 600; font-size: 13px;">
                                ğŸ”— Click to Preview Shared Content
                            </a>
                            <span style="font-size: 12px; color: var(--text-secondary);">
                                ğŸ“Š ${meta.nodeCount} nodes â€¢ ğŸ“ ${Math.round(shareURL.length/1000)}KB
                                ${meta.sizeWarning ? ' â€¢ <span style="color: #f59e0b;">âš ï¸ Large</span>' : ''}
                            </span>
                        </div>
                    </div>

                    <!-- Workflow Instructions -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #10b981; margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 10px; display: flex; align-items: center; gap: 8px; color: #10b981;">
                            <span>ğŸ“‹</span> Collaboration Workflow
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 13px;">
                            <div style="background: var(--card-bg); padding: 12px; border-radius: 6px;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px;">ğŸ‘¤ You (Sender):</div>
                                <ol style="margin-left: 16px; color: var(--text-secondary); line-height: 1.6;">
                                    <li>Click <strong>"Open Email App"</strong> or <strong>"Copy Email"</strong></li>
                                    <li>Send the email to your collaborator</li>
                                    <li>Wait for their response email</li>
                                    <li>Use <strong>File â†’ Merge Branch</strong> to paste their link</li>
                                </ol>
                            </div>
                            <div style="background: var(--card-bg); padding: 12px; border-radius: 6px;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px;">ğŸ‘¥ Collaborator (Recipient):</div>
                                <ol style="margin-left: 16px; color: var(--text-secondary); line-height: 1.6;">
                                    <li>Click the link in your email</li>
                                    <li>Edit the shared nodes as needed</li>
                                    <li>Click <strong>"Share Back"</strong> button</li>
                                    <li>Send the new link back via email</li>
                                </ol>
                            </div>
                        </div>
                    </div>

                    <!-- Important Notes -->
                    <div style="background: rgba(99, 102, 241, 0.1); padding: 12px 15px; border-radius: 6px; border-left: 3px solid #6366f1; font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
                        <strong style="color: #6366f1;">ğŸ’¡ Tip:</strong> When you receive changes back, go to <strong>File â†’ Merge Branch</strong> and paste the URL from their email to integrate their edits into your project.
                    </div>
                    <div style="background: rgba(245, 158, 11, 0.1); padding: 12px 15px; border-radius: 6px; border-left: 3px solid #f59e0b; font-size: 13px; color: var(--text-secondary);">
                        <strong style="color: #f59e0b;">âš ï¸ Multiple collaborators:</strong> If sharing with multiple people, merge their responses <strong>one at a time</strong>. Each merge replaces the shared nodes entirely â€” later merges will overwrite earlier ones.
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Select URL for easy copying
            setTimeout(() => {
                const urlInput = document.getElementById('share-branch-url-input');
                if (urlInput) urlInput.select();
            }, 100);
        }

        /**
         * Generate mailto link for collaboration email
         * @param {object} branch - Branch token
         * @param {string} shareURL - Shareable URL
         * @returns {string} mailto: link
         */
        function generateCollaborationEmail(branch, shareURL) {
            const subject = encodeURIComponent(
                `TreeListy Collaboration: ${branch.sourceProjectName}`
            );
            // Clear instructions with numbered steps
            const body = encodeURIComponent(
                `Hi,\n\n` +
                `I'd like your input on part of my TreeListy project "${branch.sourceProjectName}".\n\n` +
                `WHAT TO DO:\n` +
                `1. Click this link to open the shared content:\n` +
                `   ${shareURL}\n\n` +
                `2. Make your edits to the nodes\n` +
                `3. Click the "Share Back" button (purple bar at top)\n` +
                `4. Send me the new link from your email\n\n` +
                `I'll merge your changes into my project.\n\n` +
                `Thanks!`
            );
            return `mailto:?subject=${subject}&body=${body}`;
        }

        /**
         * Copy rich HTML email to clipboard (for pasting into email clients)
         * @param {object} branch - Branch token
         * @param {string} shareURL - Shareable URL
         */
        async function copyRichEmailToClipboard(branch, shareURL) {
            const htmlContent = `
                <p>Hi,</p>
                <p>I'd like your input on part of my TreeListy project "<strong>${branch.sourceProjectName}</strong>".</p>
                <p>I'm sharing ${branch.nodes.length} node${branch.nodes.length > 1 ? 's' : ''} for you to review and edit.</p>
                <p style="margin: 20px 0;">
                    <a href="${shareURL}" style="display: inline-block; background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: bold;">
                        ğŸ¤ Click to View & Edit
                    </a>
                </p>
                <p><strong>What to do:</strong></p>
                <ol style="color: #666; line-height: 1.6;">
                    <li>Click the button above to open the shared content</li>
                    <li>Make your edits to the nodes</li>
                    <li>Click the <strong>"Share Back"</strong> button (purple bar at top)</li>
                    <li>Send me the new link from your email</li>
                </ol>
                <p>I'll merge your changes into my project. Thanks!</p>
            `;

            const plainText = `Hi,

I'd like your input on part of my TreeListy project "${branch.sourceProjectName}".

WHAT TO DO:
1. Click this link to open the shared content:
   ${shareURL}

2. Make your edits to the nodes
3. Click the "Share Back" button (purple bar at top)
4. Send me the new link from your email

I'll merge your changes into my project.

Thanks!`;

            try {
                // Try to copy as rich HTML (works in modern browsers)
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const plainBlob = new Blob([plainText], { type: 'text/plain' });

                await navigator.clipboard.write([
                    new ClipboardItem({
                        'text/html': blob,
                        'text/plain': plainBlob
                    })
                ]);
                return true;
            } catch (err) {
                console.log('Rich copy failed, falling back to plain text:', err);
                // Fallback to plain text
                try {
                    await navigator.clipboard.writeText(plainText);
                    return true;
                } catch (err2) {
                    console.error('Clipboard write failed:', err2);
                    return false;
                }
            }
        }

        // Storage for pending merge operation (must be declared before IIFE)
        let pendingMergeBranch = null;

        // Initialize Share Branch modal event handlers
        // Use immediate execution with DOM check for reliability
        (function initCollaborationHandlers() {
            // If DOM not ready, wait for it
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initCollaborationHandlers);
                return;
            }

            // Close button
            document.getElementById('share-branch-close')?.addEventListener('click', () => {
                document.getElementById('share-branch-modal').style.display = 'none';
                pendingShareBranch = null;
            });

            // Copy URL button
            document.getElementById('share-branch-copy')?.addEventListener('click', async () => {
                const urlInput = document.getElementById('share-branch-url-input');
                if (urlInput) {
                    try {
                        await navigator.clipboard.writeText(urlInput.value);

                        // Visual feedback
                        const btn = document.getElementById('share-branch-copy');
                        const originalText = btn.textContent;
                        btn.textContent = 'âœ… Copied!';
                        btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                        setTimeout(() => {
                            btn.textContent = originalText;
                            btn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy URL:', err);
                    }
                }
            });

            // Email button (opens email app)
            document.getElementById('share-branch-email')?.addEventListener('click', () => {
                if (pendingShareBranch) {
                    const shareURL = document.getElementById('share-branch-url-input')?.value;
                    const mailtoLink = generateCollaborationEmail(pendingShareBranch, shareURL);
                    window.location.href = mailtoLink;
                }
            });

            // Copy Email button (copies rich HTML email to clipboard)
            document.getElementById('share-branch-copy-email')?.addEventListener('click', async () => {
                if (pendingShareBranch) {
                    const shareURL = document.getElementById('share-branch-url-input')?.value;
                    const success = await copyRichEmailToClipboard(pendingShareBranch, shareURL);

                    const btn = document.getElementById('share-branch-copy-email');
                    if (success) {
                        const originalText = btn.textContent;
                        btn.textContent = 'âœ… Copied!';
                        btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                        setTimeout(() => {
                            btn.textContent = originalText;
                            btn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                        }, 2000);
                    } else {
                        btn.textContent = 'âŒ Failed';
                        setTimeout(() => {
                            btn.textContent = 'ğŸ“§ Copy Email';
                        }, 2000);
                    }
                }
            });

            // Close on backdrop click
            document.getElementById('share-branch-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'share-branch-modal') {
                    document.getElementById('share-branch-modal').style.display = 'none';
                    pendingShareBranch = null;
                }
            });

            // =========== MERGE MODAL HANDLERS ===========

            // Cancel merge
            document.getElementById('merge-branch-cancel')?.addEventListener('click', () => {
                document.getElementById('merge-branch-modal').style.display = 'none';
                pendingMergeBranch = null;
            });

            // Accept merge
            const acceptBtn = document.getElementById('merge-branch-accept');
            console.log('ğŸ”€ merge-branch-accept button found:', !!acceptBtn);
            if (acceptBtn) {
                acceptBtn.addEventListener('click', () => {
                    console.log('ğŸ”€ Accept merge clicked, pendingMergeBranch:', !!pendingMergeBranch);
                    if (pendingMergeBranch) {
                        performBranchMerge(pendingMergeBranch);
                    } else {
                        console.error('ğŸ”€ No pendingMergeBranch set!');
                    }
                });
            } else {
                console.error('ğŸ”€ merge-branch-accept button NOT FOUND in DOM!');
            }

            // Close on backdrop click
            document.getElementById('merge-branch-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'merge-branch-modal') {
                    document.getElementById('merge-branch-modal').style.display = 'none';
                    pendingMergeBranch = null;
                }
            });

            // =========== BRANCH EDIT BANNER HANDLERS ===========

            // Share Back button
            document.getElementById('branch-share-back-btn')?.addEventListener('click', () => {
                shareBackBranch();
            });

            // Exit branch editing mode
            document.getElementById('branch-exit-btn')?.addEventListener('click', () => {
                exitBranchEditMode();
            });

            // =========== PASTE BRANCH URL MODAL HANDLERS ===========

            // Open paste branch modal
            document.getElementById('merge-branch-btn')?.addEventListener('click', () => {
                document.getElementById('paste-branch-modal').style.display = 'flex';
                document.getElementById('paste-branch-url-input').value = '';
                document.getElementById('paste-branch-url-input').focus();
            });

            // Cancel paste branch
            document.getElementById('paste-branch-cancel')?.addEventListener('click', () => {
                document.getElementById('paste-branch-modal').style.display = 'none';
            });

            // Parse and merge pasted URL
            document.getElementById('paste-branch-merge')?.addEventListener('click', () => {
                const urlInput = document.getElementById('paste-branch-url-input');
                const url = urlInput.value.trim();

                if (!url) {
                    showToast('âŒ Please paste a URL first', 'error');
                    return;
                }

                // Extract branch parameter from URL
                let branchParam = null;
                try {
                    const urlObj = new URL(url);
                    branchParam = urlObj.searchParams.get('branch');
                } catch (e) {
                    // Maybe they just pasted the branch parameter directly
                    if (url.includes('branch=')) {
                        branchParam = url.split('branch=')[1].split('&')[0];
                    }
                }

                if (!branchParam) {
                    showToast('âŒ Invalid URL - no branch parameter found', 'error');
                    return;
                }

                // Close paste modal
                document.getElementById('paste-branch-modal').style.display = 'none';

                // Parse and show merge modal
                const branch = parseBranchFromURL(branchParam);
                if (!branch) {
                    showToast('âŒ Failed to parse branch data', 'error');
                    return;
                }

                // Show appropriate modal based on branch type
                if (branch.isResponse) {
                    showMergeBranchModal(branch);
                } else {
                    // Original share - ask if they want to edit or merge
                    if (isOriginalBranchCreator(branch)) {
                        showToast('â„¹ï¸ This is your own shared branch', 'warning');
                    } else {
                        enterBranchEditMode(branch);
                    }
                }
            });

            // Close paste modal on backdrop click
            document.getElementById('paste-branch-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'paste-branch-modal') {
                    document.getElementById('paste-branch-modal').style.display = 'none';
                }
            });

            console.log('ğŸ¤ Collaboration event handlers initialized');
        })();

        // =====================================================
        // WATCH MODE - Live Collaboration Sync
        // =====================================================
        (function initWatchMode() {
            let watchInterval = null;
            let lastFileHash = null;
            let changesDetected = 0;
            let watchCollaboratorName = '';
            let watchFilePath = '';

            // Calculate simple hash of tree for change detection
            function getTreeHash(tree) {
                const str = JSON.stringify(tree);
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash.toString(16);
            }

            // Note: Watch mode uses the global showToast() function defined elsewhere

            // Update the status panel
            function updateWatchStatus() {
                const lastCheckEl = document.getElementById('watch-last-check');
                const currentFileEl = document.getElementById('watch-current-file');
                const collaboratorEl = document.getElementById('watch-collaborator-display');
                const changesEl = document.getElementById('watch-changes-count');

                if (lastCheckEl) lastCheckEl.textContent = new Date().toLocaleTimeString();
                if (currentFileEl) currentFileEl.textContent = watchFilePath.length > 40 ? '...' + watchFilePath.slice(-40) : watchFilePath;
                if (collaboratorEl) collaboratorEl.textContent = watchCollaboratorName || 'Not set';
                if (changesEl) changesEl.textContent = changesDetected > 0 ? `âœ… ${changesDetected} change(s) synced` : '';
            }

            // Fetch and check for updates from the watched file
            async function checkForUpdates() {
                if (!watchFilePath) return;

                try {
                    // For local files, we need to use the File System Access API
                    // For URLs, we can fetch directly
                    let newTree = null;

                    if (watchFilePath.startsWith('http')) {
                        // URL-based file (e.g., raw GitHub, public JSON endpoint)
                        const response = await fetch(watchFilePath + '?t=' + Date.now(), {
                            cache: 'no-store'
                        });
                        if (!response.ok) throw new Error('Failed to fetch');
                        newTree = await response.json();
                    } else {
                        // Local file - try to read using stored file handle
                        if (window.watchFileHandle) {
                            const file = await window.watchFileHandle.getFile();
                            const text = await file.text();
                            newTree = JSON.parse(text);
                        } else {
                            // No file handle stored - need to re-select
                            console.log('âš ï¸ No file handle - need to re-select file');
                            return;
                        }
                    }

                    // Calculate hash of new tree
                    const newHash = getTreeHash(newTree);

                    // Check if tree changed
                    if (lastFileHash && newHash !== lastFileHash) {
                        console.log('ğŸ‘ï¸ Change detected! Old hash:', lastFileHash, 'New hash:', newHash);
                        changesDetected++;

                        // Find who made the change
                        const lastContributor = findLastContributor(newTree);

                        // Only apply if someone else made the change
                        if (lastContributor && lastContributor !== watchCollaboratorName) {
                            // Apply the update
                            capexTree = newTree;
                            render();
                            if (viewMode === 'canvas') renderCanvas();

                            showToast(`ğŸ‘¥ ${lastContributor} made changes - synced!`, 'success');

                            // Flash the watch button to indicate sync
                            const btn = document.getElementById('watch-mode-btn');
                            if (btn) {
                                btn.style.animation = 'none';
                                btn.offsetHeight; // Trigger reflow
                                btn.style.animation = 'watchSync 0.5s ease-in-out 3';
                            }
                        } else {
                            // Our own save - just update hash
                            console.log('ğŸ‘ï¸ Self-save detected, skipping reload');
                        }
                    }

                    lastFileHash = newHash;
                    updateWatchStatus();

                } catch (error) {
                    console.error('ğŸ‘ï¸ Watch mode error:', error);
                    // Don't spam toasts, just log
                }
            }

            // Find the most recent contributor in the tree
            function findLastContributor(tree) {
                let latestContributor = null;
                let latestTime = 0;

                function scanNode(node) {
                    if (node.contributorTimestamp) {
                        const time = new Date(node.contributorTimestamp).getTime();
                        if (time > latestTime) {
                            latestTime = time;
                            latestContributor = node.contributor;
                        }
                    }
                    if (node.children) node.children.forEach(scanNode);
                    if (node.items) node.items.forEach(scanNode);
                    if (node.subItems) node.subItems.forEach(scanNode);
                }

                scanNode(tree);
                return latestContributor;
            }

            // Start watching
            async function startWatching() {
                const nameInput = document.getElementById('watch-collaborator-name');
                const pathInput = document.getElementById('watch-file-path');
                const intervalSelect = document.getElementById('watch-interval');

                watchCollaboratorName = nameInput?.value?.trim() || 'Anonymous';
                watchFilePath = pathInput?.value?.trim() || '';
                const interval = parseInt(intervalSelect?.value) || 10000;

                if (!watchFilePath) {
                    // No path entered - open file picker for local file
                    try {
                        const [fileHandle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'JSON Files',
                                accept: { 'application/json': ['.json'] }
                            }]
                        });
                        window.watchFileHandle = fileHandle;
                        watchFilePath = fileHandle.name;
                        pathInput.value = fileHandle.name;
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            showToast('âŒ Could not open file picker', 'error');
                        }
                        return;
                    }
                }

                // Initialize hash from current tree
                lastFileHash = getTreeHash(capexTree);
                changesDetected = 0;

                // Start polling
                watchInterval = setInterval(checkForUpdates, interval);

                // Update UI
                document.getElementById('watch-status-panel').style.display = 'block';
                document.getElementById('watch-mode-start').style.display = 'none';
                document.getElementById('watch-mode-stop').style.display = 'inline-flex';

                // Update button appearance
                const btn = document.getElementById('watch-mode-btn');
                if (btn) {
                    btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                    btn.dataset.icon = 'ğŸ‘ï¸';
                }

                updateWatchStatus();
                showToast(`ğŸ‘ï¸ Watching as "${watchCollaboratorName}"`, 'success');

                console.log('ğŸ‘ï¸ Watch Mode started:', { collaborator: watchCollaboratorName, file: watchFilePath, interval });
            }

            // Stop watching
            function stopWatching() {
                if (watchInterval) {
                    clearInterval(watchInterval);
                    watchInterval = null;
                }

                window.watchFileHandle = null;
                lastFileHash = null;

                // Update UI
                document.getElementById('watch-status-panel').style.display = 'none';
                document.getElementById('watch-mode-start').style.display = 'inline-flex';
                document.getElementById('watch-mode-stop').style.display = 'none';

                // Reset button appearance
                const btn = document.getElementById('watch-mode-btn');
                if (btn) {
                    btn.style.background = '';
                }

                showToast('â¹ï¸ Watch Mode stopped', 'info');
                console.log('ğŸ‘ï¸ Watch Mode stopped');
            }

            // Event listeners
            document.getElementById('watch-mode-btn')?.addEventListener('click', () => {
                document.getElementById('watch-mode-modal').style.display = 'flex';
                // Build 262: Populate team member buttons
                populateWatchModeTeamButtons();
            });

            document.getElementById('watch-mode-close')?.addEventListener('click', () => {
                document.getElementById('watch-mode-modal').style.display = 'none';
            });

            document.getElementById('watch-mode-start')?.addEventListener('click', startWatching);
            document.getElementById('watch-mode-stop')?.addEventListener('click', stopWatching);

            // Close on backdrop click
            document.getElementById('watch-mode-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'watch-mode-modal') {
                    document.getElementById('watch-mode-modal').style.display = 'none';
                }
            });

            // Add sync animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes watchSync {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.1); box-shadow: 0 0 20px rgba(16, 185, 129, 0.5); }
                }
            `;
            document.head.appendChild(style);

            // Expose for auto-save integration
            window.watchModeActive = () => watchInterval !== null;
            window.notifyWatchSave = () => {
                // Update hash after local save so we don't trigger self-reload
                lastFileHash = getTreeHash(capexTree);
            };

            console.log('ğŸ‘ï¸ Watch Mode initialized');
        })();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LIVE COLLABORATION SESSION MANAGEMENT (Build 222)
        // Host can share API keys with collaborators securely
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        (function initLiveCollabSessions() {
            // Session state
            let activeHostSession = null; // { token, expiresAt }
            let activeGuestSession = null; // { token, hostName, expiresAt }
            let hostImportedGdriveId = null; // Google Drive file ID if host imported from there
            let sessionStatusInterval = null;

            // Expose session token for AI calls
            window.getCollabSessionToken = () => activeGuestSession?.token || null;
            window.getCollabHostName = () => activeGuestSession?.hostName || null;
            window.isCollabGuest = () => activeGuestSession !== null;

            // Start a host session
            window.startHostSession = async function() {
                // Support both old Watch Mode and new Live Sync modal element IDs
                const btn = document.getElementById('start-api-session-btn') || document.getElementById('start-host-session-btn');
                if (!btn) return;

                const originalText = btn.innerHTML;
                btn.innerHTML = 'â³ Creating session...';
                btn.disabled = true;

                try {
                    // Get current API keys from storage
                    const apiKeys = {};

                    const anthropicKey = localStorage.getItem('anthropicApiKey');
                    const geminiKey = localStorage.getItem('geminiApiKey');
                    const openaiKey = localStorage.getItem('openaiApiKey');

                    if (anthropicKey) apiKeys.anthropic = anthropicKey;
                    if (geminiKey) apiKeys.gemini = geminiKey;
                    if (openaiKey) apiKeys.openai = openaiKey;

                    if (Object.keys(apiKeys).length === 0) {
                        showToast('âŒ No API keys configured. Set up your keys first (ğŸ”‘ button).', 'error');
                        btn.innerHTML = originalText;
                        btn.disabled = false;
                        return;
                    }

                    // Get host name from team or default
                    const team = typeof getProjectTeam === 'function' ? getProjectTeam() : null;
                    const hostName = team?.host?.name || 'Host';

                    // Create session on server
                    const response = await fetch('/.netlify/functions/collab-session', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'create',
                            hostName: hostName,
                            apiKeys: apiKeys
                        })
                    });

                    const result = await response.json();

                    if (!response.ok) {
                        throw new Error(result.error || 'Failed to create session');
                    }

                    // Store session
                    activeHostSession = {
                        token: result.sessionToken,
                        expiresAt: result.expiresAt
                    };

                    // Generate shareable link - include room ID if we're in a Firebase sync room
                    // BUILD 266: Put room first, then session for cleaner URLs
                    let shareLink = `${window.location.origin}${window.location.pathname}`;
                    const params = [];

                    // Include Firebase room ID if active
                    if (window.firebaseSyncState?.roomId) {
                        params.push(`room=${window.firebaseSyncState.roomId}`);
                        console.log('ğŸ”¥ Firebase room ID included in session link:', window.firebaseSyncState.roomId);
                    }

                    // Add session token
                    params.push(`session=${result.sessionToken}`);
                    shareLink += '?' + params.join('&');

                    // BUILD 266: Update the MAIN invite link in the Live Sync modal
                    const mainInviteLink = document.getElementById('sync-invite-link');
                    if (mainInviteLink) {
                        mainInviteLink.value = shareLink;
                    }

                    // Also update legacy elements for backwards compat
                    const legacyShareLink = document.getElementById('api-session-share-link') || document.getElementById('session-share-link');
                    if (legacyShareLink) legacyShareLink.value = shareLink;

                    // Update UI - support both element ID schemes
                    const startSection = document.getElementById('api-session-start') || document.getElementById('host-session-start');
                    const activeSection = document.getElementById('api-session-active') || document.getElementById('host-session-active');
                    if (startSection) startSection.style.display = 'none';
                    if (activeSection) activeSection.style.display = 'block';

                    updateSessionStatus();

                    // Start status polling
                    sessionStatusInterval = setInterval(updateSessionStatus, 30000);

                    showToast(`ğŸ”‘ API keys enabled! Guests will use your keys.`, 'success');
                    console.log('ğŸ”‘ Host session created:', result.sessionToken.substring(0, 8) + '...');

                } catch (error) {
                    console.error('Failed to create session:', error);
                    showToast(`âŒ ${error.message}`, 'error');
                } finally {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
            };

            // End host session
            window.endHostSession = async function() {
                if (!activeHostSession) return;

                try {
                    await fetch('/.netlify/functions/collab-session', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'revoke',
                            sessionToken: activeHostSession.token
                        })
                    });
                } catch (error) {
                    console.error('Failed to revoke session:', error);
                }

                // Clear session
                if (sessionStatusInterval) {
                    clearInterval(sessionStatusInterval);
                    sessionStatusInterval = null;
                }

                activeHostSession = null;

                // BUILD 266: Restore invite link to room-only (no session token)
                // BUILD 414: Include view state
                if (window.firebaseSyncState?.roomId) {
                    const mainInviteLink = document.getElementById('sync-invite-link');
                    if (mainInviteLink) {
                        mainInviteLink.value = window.generateShareURL ?
                            window.generateShareURL({ room: window.firebaseSyncState.roomId }) :
                            `${window.location.origin}${window.location.pathname}?room=${window.firebaseSyncState.roomId}`;
                    }
                }

                // Update UI - support both element ID schemes
                const startSection = document.getElementById('api-session-start') || document.getElementById('host-session-start');
                const activeSection = document.getElementById('api-session-active') || document.getElementById('host-session-active');
                if (startSection) startSection.style.display = 'block';
                if (activeSection) activeSection.style.display = 'none';

                showToast('â¹ï¸ API key sharing disabled', 'info');
                console.log('ğŸ”‘ Host session ended');
            };

            // Update session status display
            async function updateSessionStatus() {
                if (!activeHostSession) return;

                try {
                    const response = await fetch('/.netlify/functions/collab-session', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'status',
                            sessionToken: activeHostSession.token
                        })
                    });

                    const result = await response.json();

                    if (!result.active) {
                        // Session expired
                        endHostSession();
                        showToast('â° API key session expired', 'info');
                        return;
                    }

                    // Update display - support both element ID schemes
                    const expiresAt = new Date(result.expiresAt);
                    const expiresEl = document.getElementById('api-session-expires-at') || document.getElementById('session-expires-at');
                    const guestCountEl = document.getElementById('api-session-guest-count') || document.getElementById('session-guest-count');
                    if (expiresEl) expiresEl.textContent = expiresAt.toLocaleTimeString();
                    if (guestCountEl) guestCountEl.textContent = result.guestCount || 0;

                } catch (error) {
                    console.error('Failed to get session status:', error);
                }
            }

            // Copy API session link (new Live Sync modal)
            window.copyApiSessionLink = function() {
                const linkInput = document.getElementById('api-session-share-link');
                if (linkInput) {
                    linkInput.select();
                    document.execCommand('copy');
                    showToast('ğŸ“‹ Link copied! Guests will join room + use your API keys.', 'success');
                }
            };

            // Copy session link (legacy Watch Mode)
            window.copySessionLink = function() {
                const linkInput = document.getElementById('session-share-link');
                if (linkInput) {
                    linkInput.select();
                    document.execCommand('copy');
                    showToast('ğŸ“‹ Session link copied!', 'success');
                }
            };

            // Join as guest (called from URL parameter)
            window.joinCollabSession = async function(sessionToken) {
                try {
                    const response = await fetch('/.netlify/functions/collab-session', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'validate',
                            sessionToken: sessionToken
                        })
                    });

                    const result = await response.json();

                    if (!response.ok) {
                        throw new Error(result.error || 'Invalid session');
                    }

                    // Store guest session
                    activeGuestSession = {
                        token: sessionToken,
                        hostName: result.hostName,
                        expiresAt: result.expiresAt
                    };

                    // Update UI - support both old Watch Mode and new Live Sync modal
                    // Hide host section, show guest section in Watch Mode modal
                    const hostSection = document.getElementById('host-session-section');
                    const guestSection = document.getElementById('guest-session-section');
                    if (hostSection) hostSection.style.display = 'none';
                    if (guestSection) {
                        guestSection.style.display = 'block';
                        document.getElementById('guest-session-host').textContent = result.hostName;
                        document.getElementById('guest-session-expires').textContent = new Date(result.expiresAt).toLocaleTimeString();
                    }

                    // Update Live Sync modal guest display
                    const apiStartSection = document.getElementById('api-session-start');
                    const apiGuestSection = document.getElementById('api-guest-session');
                    if (apiStartSection) apiStartSection.style.display = 'none';
                    if (apiGuestSection) {
                        apiGuestSection.style.display = 'block';
                        const hostNameEl = document.getElementById('api-guest-host-name');
                        const expiresEl = document.getElementById('api-guest-expires');
                        if (hostNameEl) hostNameEl.textContent = result.hostName;
                        if (expiresEl) expiresEl.textContent = new Date(result.expiresAt).toLocaleTimeString();
                    }

                    // Show indicator in main UI
                    showGuestSessionIndicator(result.hostName);

                    showToast(`ğŸŸï¸ Using ${result.hostName}'s API keys!`, 'success');
                    console.log('ğŸŸï¸ Joined session as guest, host:', result.hostName);

                    return true;

                } catch (error) {
                    console.error('Failed to join session:', error);
                    showToast(`âŒ ${error.message}`, 'error');
                    return false;
                }
            };

            // Show guest indicator in main UI
            function showGuestSessionIndicator(hostName) {
                // Add indicator near API key button
                let indicator = document.getElementById('guest-session-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'guest-session-indicator';
                    indicator.style.cssText = `
                        position: fixed;
                        top: 12px;
                        right: 200px;
                        background: linear-gradient(135deg, #6366f1, #8b5cf6);
                        color: white;
                        padding: 6px 12px;
                        border-radius: 20px;
                        font-size: 12px;
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        z-index: 1000;
                        box-shadow: 0 2px 10px rgba(99, 102, 241, 0.3);
                    `;
                    document.body.appendChild(indicator);
                }
                indicator.innerHTML = `ğŸŸï¸ Using ${hostName}'s keys`;
                indicator.style.display = 'flex';
            }

            // Check for session parameter on load
            const urlParams = new URLSearchParams(window.location.search);
            const sessionParam = urlParams.get('session');

            if (sessionParam) {
                // Join session after app is ready
                // Note: gdrive parameter is handled separately by existing Google Drive loader
                // which runs at the same time - no need to duplicate tree loading here
                setTimeout(() => {
                    joinCollabSession(sessionParam);
                }, 1500); // Slightly delayed to let gdrive load first
            }

            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                if (activeHostSession) {
                    // Note: This is best-effort, may not complete
                    navigator.sendBeacon('/.netlify/functions/collab-session', JSON.stringify({
                        action: 'revoke',
                        sessionToken: activeHostSession.token
                    }));
                }
            });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HOST IMPORT FROM URL - Load tree from Google Drive or any JSON URL
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            window.hostImportFromURL = async function() {
                const urlInput = document.getElementById('host-import-url');
                let url = urlInput?.value?.trim();

                if (!url) {
                    showToast('ğŸ“¥ Please paste a Google Drive or JSON URL', 'info');
                    return;
                }

                // Check if it's a Google Drive link
                let isGoogleDrive = false;
                let gdriveFileId = null;

                if (url.includes('drive.google.com')) {
                    isGoogleDrive = true;

                    // Format: /file/d/FILE_ID/view
                    const fileMatch = url.match(/\/file\/d\/([^\/]+)/);
                    if (fileMatch) gdriveFileId = fileMatch[1];

                    // Format: id=FILE_ID
                    const idMatch = url.match(/id=([^&]+)/);
                    if (idMatch) gdriveFileId = idMatch[1];

                    // Format: /open?id=FILE_ID
                    const openMatch = url.match(/open\?id=([^&]+)/);
                    if (openMatch) gdriveFileId = openMatch[1];

                    if (gdriveFileId) {
                        hostImportedGdriveId = gdriveFileId;
                        console.log('ğŸ“¥ Google Drive file ID:', gdriveFileId);
                    }
                }

                // Convert Dropbox share links to direct download
                if (url.includes('dropbox.com')) {
                    url = url.replace('www.dropbox.com', 'dl.dropboxusercontent.com')
                             .replace('?dl=0', '').replace('?dl=1', '');
                    console.log('ğŸ“¥ Converted Dropbox URL');
                }

                showToast('ğŸ“¥ Loading tree from URL...', 'info');

                try {
                    let treeData;

                    if (isGoogleDrive && gdriveFileId) {
                        // Use our proxy for Google Drive to avoid CORS
                        const proxyUrl = `/.netlify/functions/gdrive-proxy?id=${gdriveFileId}`;
                        const response = await fetch(proxyUrl);
                        const result = await response.json();

                        if (!response.ok || result.error) {
                            throw new Error(result.error || 'Failed to fetch from Google Drive');
                        }
                        treeData = result;
                    } else {
                        // Direct fetch for other URLs
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
                        }

                        const text = await response.text();
                        try {
                            treeData = JSON.parse(text);
                        } catch (parseError) {
                            throw new Error('Invalid JSON file. Please check the URL points to a valid TreeListy JSON.');
                        }
                    }

                    // Load the tree into TreeListy
                    if (typeof loadTree === 'function') {
                        loadTree(treeData);
                        showToast(`âœ… Loaded: ${treeData.name || 'Imported tree'}`, 'success');
                        console.log('ğŸ“¥ Tree loaded from URL:', treeData.name);

                        // Update the tree name display
                        const treeNameDisplay = document.getElementById('session-tree-name');
                        if (treeNameDisplay) {
                            treeNameDisplay.textContent = treeData.name || 'Imported tree';
                        }
                    } else {
                        // Fallback - set capexTree directly
                        capexTree = treeData;
                        renderTree();
                        showToast(`âœ… Loaded: ${treeData.name || 'Imported tree'}`, 'success');
                    }

                    // Clear the input
                    urlInput.value = '';

                } catch (error) {
                    console.error('Failed to import from URL:', error);
                    showToast(`âŒ Import failed: ${error.message}`, 'error');
                }
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // EMAIL INVITATION FUNCTIONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Generate invitation email content
            function generateInviteEmail() {
                const hostName = document.getElementById('watch-collaborator-name')?.value?.trim() || 'Your collaborator';
                const sessionLink = document.getElementById('session-share-link')?.value || '';
                const treeName = capexTree?.name || 'a TreeListy project';
                const expiresAt = document.getElementById('session-expires-at')?.textContent || '4 hours';
                const hasGdrive = hostImportedGdriveId !== null;

                const subject = `ğŸŒ³ Join my TreeListy collaboration session - ${treeName}`;

                let body = `Hi!

${hostName} has invited you to collaborate on "${treeName}" in TreeListy.

ğŸ”— Click here to join:
${sessionLink}

âœ¨ What you get:
â€¢ Full access to AI features (using ${hostName}'s API keys)
â€¢ The project "${treeName}" will load automatically
â€¢ No API key setup required on your end

â° Session expires at: ${expiresAt}

Just click the link above to join instantly!`;

                if (!hasGdrive) {
                    body += `

ğŸ“ Note: If the project doesn't load, ask ${hostName} to share the Google Drive link separately.`;
                }

                body += `

---
TreeListy - Universal Project Decomposition
https://treelisty.netlify.app`;

                return { subject, body };
            }

            // Copy email text to clipboard
            window.copySessionInviteEmail = function() {
                const { subject, body } = generateInviteEmail();
                const fullText = `Subject: ${subject}\n\n${body}`;

                navigator.clipboard.writeText(fullText).then(() => {
                    showToast('ğŸ“‹ Email text copied!', 'success');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    showToast('âŒ Failed to copy', 'error');
                });
            };

            // Open mailto link
            window.openMailtoInvite = function() {
                const { subject, body } = generateInviteEmail();
                const mailto = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                window.open(mailto, '_blank');
            };

            // Send invite via email input
            window.sendSessionInvite = function() {
                const emailInput = document.getElementById('invite-email-input');
                const email = emailInput?.value?.trim();

                if (!email || !email.includes('@')) {
                    showToast('ğŸ“§ Please enter a valid email address', 'error');
                    return;
                }

                const { subject, body } = generateInviteEmail();
                const mailto = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                window.open(mailto, '_blank');

                // Clear input and show success
                emailInput.value = '';
                showToast(`ğŸ“§ Opening email to ${email}...`, 'success');
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ASYNC SHARE FUNCTIONS - Share Google Drive link (no API keys)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            let asyncGdriveFileId = null;

            // Generate TreeListy link from Google Drive URL
            window.generateAsyncShareLink = function() {
                const urlInput = document.getElementById('async-gdrive-url');
                const url = urlInput?.value?.trim();

                if (!url) {
                    showToast('â˜ï¸ Please paste a Google Drive share link', 'info');
                    return;
                }

                // Extract file ID from Google Drive URL
                let fileId = null;

                // Format: /file/d/FILE_ID/view
                const fileMatch = url.match(/\/file\/d\/([^\/]+)/);
                if (fileMatch) fileId = fileMatch[1];

                // Format: id=FILE_ID
                const idMatch = url.match(/id=([^&]+)/);
                if (idMatch) fileId = idMatch[1];

                // Format: /open?id=FILE_ID
                const openMatch = url.match(/open\?id=([^&]+)/);
                if (openMatch) fileId = openMatch[1];

                if (!fileId) {
                    showToast('âŒ Could not find file ID in URL. Please use a Google Drive share link.', 'error');
                    return;
                }

                asyncGdriveFileId = fileId;

                // Generate TreeListy link
                const shareLink = `${window.location.origin}${window.location.pathname}?gdrive=${fileId}`;
                document.getElementById('async-share-link').value = shareLink;
                document.getElementById('async-share-result').style.display = 'block';

                showToast('ğŸ”— TreeListy link generated!', 'success');
                console.log('ğŸ“§ Async share link created for file:', fileId);
            };

            // Copy async share link
            window.copyAsyncShareLink = function() {
                const link = document.getElementById('async-share-link')?.value;
                if (link) {
                    navigator.clipboard.writeText(link).then(() => {
                        showToast('ğŸ“‹ Link copied!', 'success');
                    });
                }
            };

            // Generate async invite email content
            function generateAsyncInviteEmail() {
                const hostName = document.getElementById('watch-collaborator-name')?.value?.trim() || 'Your collaborator';
                const shareLink = document.getElementById('async-share-link')?.value || '';
                const treeName = capexTree?.name || 'a TreeListy project';

                const subject = `ğŸŒ³ Collaborate on "${treeName}" in TreeListy`;

                const body = `Hi!

${hostName} has shared "${treeName}" with you in TreeListy.

ğŸ”— Click here to open it:
${shareLink}

ğŸ“ How async collaboration works:
1. Click the link above to open the tree in TreeListy
2. Make your edits and save to your own Google Drive
3. Share your updated link back when ready

ğŸ’¡ You'll need your own API key for AI features, or ask ${hostName} to start a Live Session if they want to share their keys.

---
TreeListy - Universal Project Decomposition
https://treelisty.netlify.app`;

                return { subject, body };
            }

            // Send async invite email
            window.sendAsyncInviteEmail = function() {
                const { subject, body } = generateAsyncInviteEmail();
                const mailto = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                window.open(mailto, '_blank');
            };

            // Copy async invite email text
            window.copyAsyncInviteEmail = function() {
                const { subject, body } = generateAsyncInviteEmail();
                const fullText = `Subject: ${subject}\n\n${body}`;

                navigator.clipboard.writeText(fullText).then(() => {
                    showToast('ğŸ“‹ Email text copied!', 'success');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    showToast('âŒ Failed to copy', 'error');
                });
            };

            console.log('ğŸ”‘ Live Collab Sessions initialized');
            console.log('ğŸ“§ Async Share initialized');
        })();

        // =============================================================================
        // FIREBASE LIVE SYNC (Build 231)
        // =============================================================================
        (function() {
            'use strict';

            // Firebase sync state
            let firebaseSyncState = {
                isConnected: false,
                roomId: null,
                userId: null,
                unsubscribe: null,
                lastSyncTimestamp: null,
                isSyncing: false,
                ignoreNextUpdate: false,  // Prevent echo when we push our own changes
                // BUILD 256: Track collaborator names for undo history
                collaboratorNames: {},  // userId -> display name
                myDisplayName: null,    // This user's display name
                lastEditor: null        // Who made the last edit
            };

            // Generate a random room ID
            function generateRoomId() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // No confusing chars (0/O, 1/I/L)
                let id = '';
                for (let i = 0; i < 6; i++) {
                    id += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return id;
            }

            // Update UI based on sync state
            function updateSyncUI() {
                const startSection = document.getElementById('sync-start-section');
                const activeSection = document.getElementById('sync-active-section');
                const syncBtn = document.getElementById('live-sync-btn');

                // Build 265: Also update legacy hidden elements for backwards compat
                const statusIndicator = document.getElementById('sync-status-indicator');
                const statusText = document.getElementById('sync-status-text');
                const userIdSection = document.getElementById('sync-user-id');
                const userIdValue = document.getElementById('sync-user-id-value');

                if (firebaseSyncState.isConnected && firebaseSyncState.roomId) {
                    // Connected to a room
                    startSection.style.display = 'none';
                    activeSection.style.display = 'block';

                    // Update room ID displays
                    document.getElementById('active-room-id').value = firebaseSyncState.roomId;
                    const roomIdDisplay = document.getElementById('active-room-id-display');
                    if (roomIdDisplay) roomIdDisplay.textContent = firebaseSyncState.roomId;

                    // Update invite link
                    const inviteLinkEl = document.getElementById('sync-invite-link');
                    if (inviteLinkEl && !inviteLinkEl.value) {
                        inviteLinkEl.value = `${window.location.origin}${window.location.pathname}?room=${firebaseSyncState.roomId}`;
                    }

                    // Update header button style
                    syncBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                    syncBtn.title = 'ğŸ”¥ Live Session Active - ' + firebaseSyncState.roomId;

                    // Legacy elements
                    if (statusIndicator) statusIndicator.style.background = '#10b981';
                    if (statusText) { statusText.textContent = 'Connected'; statusText.style.color = '#10b981'; }
                    if (userIdSection) userIdSection.style.display = 'block';
                    if (userIdValue) userIdValue.textContent = firebaseSyncState.userId?.substring(0, 8) + '...';
                } else {
                    // Not connected
                    startSection.style.display = 'block';
                    activeSection.style.display = 'none';
                    syncBtn.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
                    syncBtn.title = 'ğŸ”„ Live Collaboration';

                    // Reset create button
                    const createBtn = document.getElementById('create-sync-room-btn');
                    if (createBtn) {
                        createBtn.innerHTML = 'ğŸš€ Start Live Session';
                        createBtn.disabled = false;
                    }

                    // Legacy elements
                    if (statusIndicator) statusIndicator.style.background = '#6b7280';
                    if (statusText) { statusText.textContent = 'Not Connected'; statusText.style.color = 'var(--text-secondary)'; }
                    if (userIdSection) userIdSection.style.display = 'none';
                }
            }

            // Initialize Firebase auth
            async function initFirebaseAuth() {
                console.log('ğŸ”¥ initFirebaseAuth called, firebaseReady:', window.firebaseReady);

                // Wait for Firebase to be ready
                let attempts = 0;
                while (!window.firebaseReady && attempts < 50) {
                    await new Promise(r => setTimeout(r, 100));
                    attempts++;
                    if (attempts % 10 === 0) {
                        console.log('ğŸ”¥ Waiting for Firebase...', attempts);
                    }
                }

                if (!window.firebaseReady) {
                    console.error('ğŸ”¥ Firebase not ready after 5 seconds');
                    showToast('âŒ Firebase failed to load. Check console.', 'error');
                    return false;
                }

                console.log('ğŸ”¥ Firebase ready, signing in anonymously...');
                console.log('ğŸ”¥ firebaseAuth:', window.firebaseAuth);
                console.log('ğŸ”¥ firebaseSignInAnonymously:', typeof window.firebaseSignInAnonymously);

                try {
                    // Sign in anonymously
                    const result = await window.firebaseSignInAnonymously(window.firebaseAuth);
                    firebaseSyncState.userId = result.user.uid;
                    console.log('ğŸ”¥ Firebase anonymous auth successful:', firebaseSyncState.userId);
                    updateSyncUI();
                    return true;
                } catch (error) {
                    console.error('ğŸ”¥ Firebase auth error:', error);
                    showToast('âŒ Firebase auth failed: ' + error.message, 'error');
                    return false;
                }
            }

            // Create a new sync room
            let isCreatingRoom = false; // BUILD 267: Prevent double creation
            async function createSyncRoom() {
                console.log('ğŸ”¥ createSyncRoom called');

                // BUILD 267: Prevent double-click creating multiple rooms
                if (isCreatingRoom) {
                    console.log('ğŸ”¥ Already creating room, ignoring duplicate call');
                    return;
                }
                if (firebaseSyncState.isConnected && firebaseSyncState.roomId) {
                    console.log('ğŸ”¥ Already connected to room:', firebaseSyncState.roomId);
                    return;
                }
                isCreatingRoom = true;

                const btn = document.getElementById('create-sync-room-btn');
                if (btn) {
                    btn.innerHTML = 'â³ Creating...';
                    btn.disabled = true;
                }

                // Check if Firebase is ready
                if (!window.firebaseReady) {
                    console.error('ğŸ”¥ Firebase not ready yet');
                    showToast('â³ Firebase loading, please try again...', 'warning');
                    if (btn) { btn.innerHTML = 'ğŸš€ Start Live Session'; btn.disabled = false; }
                    isCreatingRoom = false;
                    return;
                }

                if (!firebaseSyncState.userId) {
                    console.log('ğŸ”¥ No user ID, authenticating...');
                    const authed = await initFirebaseAuth();
                    if (!authed) {
                        console.error('ğŸ”¥ Auth failed');
                        if (btn) { btn.innerHTML = 'ğŸš€ Start Live Session'; btn.disabled = false; }
                        isCreatingRoom = false;
                        return;
                    }
                }

                const roomId = generateRoomId();
                firebaseSyncState.roomId = roomId;
                console.log('ğŸ”¥ Creating room:', roomId);

                try {
                    // Create the room document with current tree data
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', roomId);
                    console.log('ğŸ”¥ Got room ref, setting doc...');

                    // BUILD 270: Include host in connectedUsers from the start
                    const initialConnectedUsers = {};
                    initialConnectedUsers[firebaseSyncState.userId] = {
                        name: firebaseSyncState.myDisplayName || 'Host',
                        joinedAt: Date.now(),
                        isHost: true
                    };

                    await window.firebaseSetDoc(roomRef, {
                        createdBy: firebaseSyncState.userId,
                        createdAt: window.firebaseServerTimestamp(),
                        lastUpdatedBy: firebaseSyncState.userId,
                        lastUpdatedAt: window.firebaseServerTimestamp(),
                        treeData: JSON.stringify(capexTree),
                        pattern: currentPattern,
                        projectName: capexTree?.name || 'Untitled',
                        // Build 265: Add chat messages array
                        chatMessages: [],
                        // Build 270: Include host in connected users
                        connectedUsers: initialConnectedUsers
                    });

                    console.log('ğŸ”¥ Room created:', roomId);

                    // Subscribe to changes
                    subscribeToRoom(roomId);
                    firebaseSyncState.isConnected = true;

                    // BUILD 268: Mark as host for floating chat
                    floatingChatState.isHost = true;
                    floatingChatState.previousUserCount = 1; // Reset counter

                    // Generate invite link with view state (BUILD 414)
                    const inviteLink = window.generateShareURL ?
                        window.generateShareURL({ room: roomId }) :
                        `${window.location.origin}${window.location.pathname}?room=${roomId}`;
                    document.getElementById('sync-invite-link').value = inviteLink;
                    document.getElementById('active-room-id-display').textContent = roomId;
                    document.getElementById('active-room-id').value = roomId;

                    // Update UI
                    updateSyncUI();

                    // Copy link to clipboard automatically
                    try {
                        await navigator.clipboard.writeText(inviteLink);
                        showToast('ğŸ”¥ Session started! Invite link copied to clipboard.', 'success');
                    } catch (e) {
                        showToast('ğŸ”¥ Session started! Room: ' + roomId, 'success');
                    }

                } catch (error) {
                    console.error('ğŸ”¥ Failed to create room:', error);
                    showToast('âŒ Failed to create room: ' + error.message, 'error');
                    firebaseSyncState.roomId = null;
                    if (btn) { btn.innerHTML = 'ğŸš€ Start Live Session'; btn.disabled = false; }
                } finally {
                    isCreatingRoom = false; // BUILD 267: Reset flag
                }
            }

            // Join an existing room
            async function joinSyncRoom(roomId) {
                if (!firebaseSyncState.userId) {
                    const authed = await initFirebaseAuth();
                    if (!authed) return;
                }

                roomId = roomId.toUpperCase().trim();
                if (!roomId || roomId.length < 4) {
                    showToast('âŒ Invalid room ID', 'error');
                    return;
                }

                try {
                    // Check if room exists
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', roomId);
                    const roomSnap = await window.firebaseGetDoc(roomRef);

                    if (!roomSnap.exists()) {
                        showToast('âŒ Room not found: ' + roomId, 'error');
                        return;
                    }

                    const roomData = roomSnap.data();
                    console.log('ğŸ”¥ Joining room:', roomId, roomData);

                    // Load the tree data from the room
                    if (roomData.treeData) {
                        const treeData = JSON.parse(roomData.treeData);

                        // Store room ID before reload
                        localStorage.setItem('firebase-pending-room', roomId);
                        localStorage.setItem('firebase-pending-tree', roomData.treeData);
                        if (roomData.pattern) {
                            localStorage.setItem('firebase-pending-pattern', roomData.pattern);
                        }

                        // Reload to apply tree (simplest way to re-render)
                        window.location.href = window.location.pathname + '?room=' + roomId;
                        return;
                    }

                    firebaseSyncState.roomId = roomId;
                    firebaseSyncState.isConnected = true;

                    // Subscribe to changes
                    subscribeToRoom(roomId);
                    updateSyncUI();

                    showToast('ğŸ”¥ Joined room: ' + roomId, 'success');

                } catch (error) {
                    console.error('ğŸ”¥ Failed to join room:', error);
                    showToast('âŒ Failed to join room: ' + error.message, 'error');
                }
            }

            // Subscribe to real-time updates from a room
            function subscribeToRoom(roomId) {
                if (firebaseSyncState.unsubscribe) {
                    firebaseSyncState.unsubscribe();
                }

                const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', roomId);

                firebaseSyncState.unsubscribe = window.firebaseOnSnapshot(roomRef, (doc) => {
                    if (!doc.exists()) {
                        console.log('ğŸ”¥ Room deleted');
                        leaveSyncRoom();
                        showToast('âš ï¸ Room was deleted', 'warning');
                        return;
                    }

                    const data = doc.data();

                    // BUILD 273/279: ALWAYS process presence updates regardless of who triggered
                    // This fixes the bug where host doesn't see guest join because lastUpdatedBy was host
                    if (data.connectedUsers) {
                        updateCollaboratorsUI(data.connectedUsers);
                    }

                    // BUILD 274: ALWAYS process chat messages regardless of who triggered
                    // This fixes the bug where guest doesn't receive host messages
                    if (data.chatMessages && Array.isArray(data.chatMessages)) {
                        updateChatUI(data.chatMessages);
                    }

                    // Skip tree updates if we just pushed this update
                    if (firebaseSyncState.ignoreNextUpdate) {
                        firebaseSyncState.ignoreNextUpdate = false;
                        console.log('ğŸ”¥ Ignoring our own tree update');
                        return;
                    }

                    // Skip tree updates if it's our own update
                    if (data.lastUpdatedBy === firebaseSyncState.userId) {
                        console.log('ğŸ”¥ Skipping own tree update');
                        return;
                    }

                    // Update tree from remote
                    if (data.treeData) {
                        try {
                            // BUILD 327: If we have pending local changes, flush them first
                            // This prevents losing local edits when remote updates arrive
                            if (window.firebaseHasPendingLocalChanges && window.firebaseHasPendingLocalChanges()) {
                                console.log('ğŸ”¥ Pending local changes detected, flushing before accepting remote...');
                                // Skip this remote update - our push will trigger a new one
                                // The user's changes take priority
                                if (window.firebaseFlushPendingChanges) {
                                    window.firebaseFlushPendingChanges();
                                }
                                return; // Don't overwrite local changes
                            }

                            const newTree = JSON.parse(data.treeData);
                            const editorId = data.lastUpdatedBy?.substring(0, 8) || 'Unknown';
                            console.log('ğŸ”¥ Received tree update from', editorId);

                            // BUILD 256: Save state BEFORE applying remote changes (enables undo)
                            const editorName = firebaseSyncState.collaboratorNames[data.lastUpdatedBy] || `User ${editorId}`;
                            if (typeof saveState === 'function') {
                                saveState(`Remote sync from ${editorName}`);
                            }

                            // BUILD 256: Update last editor display
                            firebaseSyncState.lastEditor = data.lastUpdatedBy;
                            const lastEditorEl = document.getElementById('sync-last-editor');
                            const lastEditorRow = document.getElementById('sync-last-editor-row');
                            if (lastEditorEl && lastEditorRow) {
                                lastEditorEl.textContent = editorName;
                                lastEditorRow.style.display = 'block';
                            }

                            // Update global tree
                            window.capexTree = newTree;

                            // Update pattern if changed
                            if (data.pattern && window.PATTERNS && window.PATTERNS[data.pattern]) {
                                window.currentPattern = data.pattern;
                                const patternSelect = document.getElementById('pattern-select');
                                if (patternSelect) patternSelect.value = data.pattern;
                            }

                            // Update tree name display
                            const treeNameDisplay = document.getElementById('tree-name-display');
                            if (treeNameDisplay) {
                                treeNameDisplay.textContent = newTree.name || 'Synced Tree';
                            }

                            // Trigger tree container re-render via custom event
                            window.dispatchEvent(new CustomEvent('treelisty-sync-update', { detail: newTree }));

                            // Update last sync time
                            firebaseSyncState.lastSyncTimestamp = Date.now();
                            const syncLastUpdate = document.getElementById('sync-last-update');
                            if (syncLastUpdate) {
                                syncLastUpdate.textContent = new Date().toLocaleTimeString();
                            }

                            showToast('ğŸ”„ Tree synced from collaborator', 'info');

                            // BUILD 257: Auto-save JSON if enabled
                            if (firebaseSyncState.autoSaveJSON && window.saveCollabJSON) {
                                setTimeout(() => window.saveCollabJSON(), 500); // Small delay to ensure tree is updated
                            }

                        } catch (e) {
                            console.error('ğŸ”¥ Failed to parse tree update:', e);
                        }
                    }

                    // BUILD 274: Chat messages and connected users now handled at top of snapshot (before early returns)
                }, (error) => {
                    console.error('ğŸ”¥ Snapshot error:', error);
                    showToast('âŒ Sync error: ' + error.message, 'error');
                });

                // BUILD 265: Register ourselves as connected
                registerAsConnected(roomId);

                console.log('ğŸ”¥ Subscribed to room:', roomId);
            }

            // BUILD 279: Register user as connected to room
            // Uses updateDoc (not setDoc) with dot notation - setDoc merge was silently failing
            async function registerAsConnected(roomId) {
                if (!firebaseSyncState.userId) return;

                try {
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', roomId);

                    // Use dot notation to add user without overwriting others
                    const updateData = {};
                    updateData[`connectedUsers.${firebaseSyncState.userId}`] = {
                        name: firebaseSyncState.myDisplayName || 'User',
                        joinedAt: Date.now()
                    };

                    // BUILD 278/279: Use updateDoc instead of setDoc - setDoc with merge was silently failing
                    await window.firebaseUpdateDoc(roomRef, updateData);
                    console.log('ğŸ”¥ Registered as connected:', firebaseSyncState.userId.substring(0, 8));
                } catch (e) {
                    console.error('ğŸ”¥ Failed to register as connected:', e.message);
                }
            }

            // Push local changes to the room
            async function pushTreeToRoom() {
                if (!firebaseSyncState.isConnected || !firebaseSyncState.roomId) {
                    return;
                }

                if (firebaseSyncState.isSyncing) {
                    console.log('ğŸ”¥ Already syncing, skipping');
                    return;
                }

                firebaseSyncState.isSyncing = true;
                firebaseSyncState.ignoreNextUpdate = true;

                try {
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', firebaseSyncState.roomId);
                    await window.firebaseSetDoc(roomRef, {
                        lastUpdatedBy: firebaseSyncState.userId,
                        lastUpdatedAt: window.firebaseServerTimestamp(),
                        treeData: JSON.stringify(capexTree),
                        pattern: currentPattern,
                        projectName: capexTree?.name || 'Untitled'
                    }, { merge: true });

                    console.log('ğŸ”¥ Pushed tree update');
                    document.getElementById('sync-last-update').textContent = new Date().toLocaleTimeString();

                    // BUILD 256: Update last editor to show "You"
                    const lastEditorEl = document.getElementById('sync-last-editor');
                    const lastEditorRow = document.getElementById('sync-last-editor-row');
                    if (lastEditorEl && lastEditorRow) {
                        lastEditorEl.textContent = 'You';
                        lastEditorRow.style.display = 'block';
                    }

                } catch (error) {
                    console.error('ğŸ”¥ Failed to push tree:', error);
                    firebaseSyncState.ignoreNextUpdate = false;
                } finally {
                    firebaseSyncState.isSyncing = false;
                }
            }

            // Leave the current room
            function leaveSyncRoom() {
                if (firebaseSyncState.unsubscribe) {
                    firebaseSyncState.unsubscribe();
                    firebaseSyncState.unsubscribe = null;
                }

                firebaseSyncState.isConnected = false;
                firebaseSyncState.roomId = null;
                updateSyncUI();

                // BUILD 268: Hide floating chat and reset state
                hideFloatingChat();
                floatingChatState.isHost = false;
                floatingChatState.previousUserCount = 1;
                floatingChatState.unreadCount = 0;

                // BUILD 268: Clear session API keys if guest used shared keys
                if (sessionStorage.getItem('session_api_keys')) {
                    localStorage.removeItem('anthropic_api_key');
                    localStorage.removeItem('gemini_api_key');
                    localStorage.removeItem('openai_api_key');
                    sessionStorage.removeItem('session_api_keys');
                    showToast('ğŸ”‘ Session API keys cleared', 'info');
                }

                showToast('ğŸ‘‹ Left sync room', 'info');
            }

            // Copy room ID to clipboard
            function copyRoomId() {
                const roomId = firebaseSyncState.roomId;
                if (roomId) {
                    navigator.clipboard.writeText(roomId).then(() => {
                        showToast('ğŸ“‹ Room ID copied: ' + roomId, 'success');
                    });
                }
            }

            // BUILD 256: Set display name for this user
            function setMyDisplayName(name) {
                firebaseSyncState.myDisplayName = name;
                // Store own name in collaboratorNames too
                if (firebaseSyncState.userId) {
                    firebaseSyncState.collaboratorNames[firebaseSyncState.userId] = name;
                }
                localStorage.setItem('treelisty_display_name', name);
                showToast(`âœï¸ Display name set to: ${name}`, 'success');
            }

            // BUILD 256: Set name for a collaborator (by their short ID)
            function setCollaboratorName(shortId, name) {
                // Find full userId that starts with shortId
                const fullId = Object.keys(firebaseSyncState.collaboratorNames).find(id => id.startsWith(shortId)) ||
                               firebaseSyncState.lastEditor?.startsWith(shortId) ? firebaseSyncState.lastEditor : null;

                if (fullId) {
                    firebaseSyncState.collaboratorNames[fullId] = name;
                    // Update display if this was the last editor
                    const lastEditorEl = document.getElementById('sync-last-editor');
                    if (lastEditorEl && firebaseSyncState.lastEditor === fullId) {
                        lastEditorEl.textContent = name;
                    }
                    showToast(`âœï¸ Named collaborator ${shortId} as: ${name}`, 'success');
                } else {
                    // Store for future use
                    firebaseSyncState.collaboratorNames[shortId] = name;
                    showToast(`âœï¸ Will name collaborator ${shortId} as: ${name}`, 'info');
                }
            }

            // Expose functions globally
            window.firebaseSyncState = firebaseSyncState;
            window.createFirebaseSyncRoom = createSyncRoom;
            window.joinFirebaseSyncRoom = joinSyncRoom;
            window.leaveFirebaseSyncRoom = leaveSyncRoom;
            window.pushTreeToFirebase = pushTreeToRoom;
            window.copyFirebaseRoomId = copyRoomId;
            window.setMyDisplayName = setMyDisplayName;           // BUILD 256
            window.setCollaboratorName = setCollaboratorName;     // BUILD 256

            // BUILD 322: Jitsi Voice Chat Integration
            // BUILD 324: Skip prejoin modal, pass display name
            window.startVoiceChat = function() {
                if (!firebaseSyncState.isConnected || !firebaseSyncState.roomId) {
                    showToast('âŒ No active collaboration session', 'error');
                    return;
                }

                // Create Jitsi Meet room URL using the session ID
                const roomId = firebaseSyncState.roomId;
                const jitsiRoomName = `treelisty-${roomId}`;

                // Get display name from collaboration session or use default
                const displayName = firebaseSyncState.myDisplayName || 'TreeListy User';
                const encodedName = encodeURIComponent(displayName);

                // Skip prejoin page and pass display name via URL config
                // Also start audio-only (no video) for lighter bandwidth
                const jitsiUrl = `https://meet.jit.si/${jitsiRoomName}#userInfo.displayName="${encodedName}"&config.prejoinConfig.enabled=false&config.startWithVideoMuted=true`;

                // Open in popup window for better UX
                const width = 800;
                const height = 600;
                const left = (screen.width - width) / 2;
                const top = (screen.height - height) / 2;

                const popup = window.open(
                    jitsiUrl,
                    'TreeListy Voice Chat',
                    `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=no,status=no,menubar=no,toolbar=no`
                );

                if (popup) {
                    showToast('ğŸ™ï¸ Voice chat opened - invite others to join!', 'success');

                    // Also send a chat message so others know voice chat is available
                    if (typeof sendChatMessage === 'function') {
                        sendChatMessage(`ğŸ™ï¸ Started voice chat! Click the Voice button to join.`);
                    }
                } else {
                    // Popup blocked - fall back to new tab
                    window.open(jitsiUrl, '_blank');
                    showToast('ğŸ™ï¸ Voice chat opened in new tab', 'info');
                }

                console.log('ğŸ™ï¸ Voice chat started:', jitsiUrl);
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 325: Scheduled Meeting Link System
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Meeting state storage
            let meetingState = {
                currentMeetingId: null,
                isHost: false,
                meetingUnsubscribe: null,
                backupInterval: null,
                waitingStartTime: null
            };

            // Generate unique 8-char meeting ID (MEET + 4 alphanumeric)
            function generateMeetingId() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // No ambiguous chars
                let result = 'MEET';
                for (let i = 0; i < 4; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            // Create a scheduled meeting and store tree in Firebase
            async function createScheduledMeeting() {
                console.log('ğŸ“… Creating scheduled meeting...');

                // 1. Authenticate if needed
                if (!firebaseSyncState.userId) {
                    const authed = await initFirebaseAuth();
                    if (!authed) {
                        showToast('âŒ Authentication required', 'error');
                        return null;
                    }
                }

                // 2. Generate meeting ID
                const meetingId = generateMeetingId();

                // 3. Get form values
                const meetingNameInput = document.getElementById('meeting-name-input');
                const meetingTimeInput = document.getElementById('meeting-time-input');
                const allowGuestEdits = document.getElementById('meeting-allow-edits')?.checked ?? true;
                const autoVoicePrompt = document.getElementById('meeting-voice-prompt')?.checked ?? true;
                const autoBackup = document.getElementById('meeting-auto-backup')?.checked ?? true;

                const meetingName = meetingNameInput?.value || capexTree.name || 'Scheduled Meeting';
                const scheduledTime = meetingTimeInput?.value ? new Date(meetingTimeInput.value) : null;

                try {
                    // 4. Create meeting document in Firestore
                    const meetingRef = window.firebaseDoc(window.firebaseDb, 'scheduledMeetings', meetingId);

                    await window.firebaseSetDoc(meetingRef, {
                        meetingId: meetingId,
                        roomId: null, // Set when meeting goes active

                        // Scheduling
                        scheduledAt: scheduledTime || window.firebaseServerTimestamp(),
                        createdAt: window.firebaseServerTimestamp(),
                        expiresAt: new Date(Date.now() + 48 * 60 * 60 * 1000), // 48h from now

                        // Host identification
                        hostId: firebaseSyncState.userId,
                        hostName: firebaseSyncState.myDisplayName || 'Host',
                        hostDeviceFingerprint: getDeviceFingerprint(),

                        // Meeting state
                        state: 'SCHEDULED',
                        stateChangedAt: window.firebaseServerTimestamp(),

                        // Tree bundle (bypasses URL size limit!)
                        treeData: JSON.stringify(capexTree),
                        pattern: currentPattern,
                        projectName: meetingName,

                        // Participants (empty initially)
                        participants: {},

                        // Settings
                        settings: {
                            allowGuestEdits: allowGuestEdits,
                            autoVoicePrompt: autoVoicePrompt,
                            autoBackup: autoBackup,
                            waitingMessage: `Waiting for ${firebaseSyncState.myDisplayName || 'host'} to start...`
                        }
                    });

                    console.log('ğŸ“… Meeting created:', meetingId);

                    // 5. Generate and display link
                    const meetingUrl = `${window.location.origin}${window.location.pathname}?meeting=${meetingId}`;

                    // Update modal UI
                    const linkInput = document.getElementById('meeting-link-url');
                    const createSection = document.getElementById('meeting-create-section');
                    const generatedSection = document.getElementById('meeting-generated-section');

                    if (linkInput) linkInput.value = meetingUrl;
                    if (createSection) createSection.style.display = 'none';
                    if (generatedSection) generatedSection.style.display = 'block';

                    // 6. Copy to clipboard
                    try {
                        await navigator.clipboard.writeText(meetingUrl);
                        showToast('ğŸ“… Meeting link created and copied!', 'success');
                    } catch (e) {
                        showToast('ğŸ“… Meeting link created! Copy it from the modal.', 'success');
                    }

                    // 7. Store locally for host re-identification
                    localStorage.setItem('treelisty:hosted-meeting', meetingId);

                    // Store in meeting state
                    meetingState.currentMeetingId = meetingId;
                    meetingState.isHost = true;

                    return meetingId;

                } catch (error) {
                    console.error('ğŸ“… Failed to create meeting:', error);
                    showToast('âŒ Failed to create meeting: ' + error.message, 'error');
                    return null;
                }
            }

            // Check if current user is the host of a meeting
            function isHostOfMeeting(meeting) {
                // Check Firebase UID
                if (meeting.hostId === firebaseSyncState.userId) return true;

                // Check device fingerprint (for reconnection after auth change)
                if (meeting.hostDeviceFingerprint === getDeviceFingerprint()) return true;

                // Check localStorage (host created meeting on this device)
                if (localStorage.getItem('treelisty:hosted-meeting') === meeting.meetingId) return true;

                return false;
            }

            // Handle ?meeting= URL parameter
            async function handleMeetingURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const meetingId = urlParams.get('meeting');

                if (!meetingId) return false;

                console.log('ğŸ“… Meeting URL detected:', meetingId);

                try {
                    // 1. Authenticate
                    if (!firebaseSyncState.userId) {
                        await initFirebaseAuth();
                    }

                    // 2. Fetch meeting data from Firebase
                    const meetingRef = window.firebaseDoc(window.firebaseDb, 'scheduledMeetings', meetingId);
                    const meetingSnap = await window.firebaseGetDoc(meetingRef);

                    if (!meetingSnap.exists()) {
                        showToast('âŒ Meeting not found or has expired', 'error');
                        // Clean URL
                        window.history.replaceState({}, '', window.location.pathname);
                        return false;
                    }

                    const meeting = meetingSnap.data();
                    console.log('ğŸ“… Meeting data loaded:', meeting.projectName, 'state:', meeting.state);

                    // 3. Check if this is the host reconnecting
                    const isHost = isHostOfMeeting(meeting);
                    meetingState.isHost = isHost;
                    meetingState.currentMeetingId = meetingId;

                    // 4. Register as participant
                    await registerMeetingParticipant(meetingId, isHost);

                    // 5. Handle based on current meeting state
                    // IMPORTANT: If meeting is ACTIVE, get tree from sync room (latest version)
                    // Only load from meeting document if waiting for host (original tree)
                    if (meeting.state === 'ACTIVE' && meeting.roomId) {
                        // Meeting already active - join the sync room directly
                        // The sync room has the LATEST tree, so don't load from meeting doc
                        console.log('ğŸ“… Meeting active, joining room for latest tree:', meeting.roomId);
                        await joinSyncRoom(meeting.roomId);

                        // Start backup interval if enabled
                        if (meeting.settings?.autoBackup) {
                            startMeetingBackupInterval();
                        }

                    } else {
                        // Meeting NOT active yet - load tree from meeting document
                        // (This is the original tree stored when meeting was created)
                        if (meeting.treeData) {
                            try {
                                const loadedTree = JSON.parse(meeting.treeData);
                                window.capexTree = loadedTree;

                                // Update pattern if specified
                                if (meeting.pattern && window.PATTERNS && window.PATTERNS[meeting.pattern]) {
                                    window.currentPattern = meeting.pattern;
                                    const patternSelect = document.getElementById('pattern-select');
                                    if (patternSelect) patternSelect.value = meeting.pattern;
                                }

                                // Update tree name display
                                const treeNameDisplay = document.getElementById('tree-name-display');
                                if (treeNameDisplay) {
                                    treeNameDisplay.textContent = loadedTree.name || meeting.projectName || 'Meeting Tree';
                                }

                                console.log('ğŸ“… Tree loaded from meeting document:', loadedTree.name);
                            } catch (e) {
                                console.error('ğŸ“… Failed to parse meeting tree:', e);
                                showToast('âŒ Failed to load meeting tree', 'error');
                                return false;
                            }
                        }

                        if (isHost) {
                            // Host arriving - activate the meeting
                            console.log('ğŸ“… Host detected, activating meeting...');
                            await activateMeeting(meetingId);
                        } else {
                            // Guest arrived before host - show waiting room
                            console.log('ğŸ“… Guest waiting for host...');
                            showWaitingRoom(meeting);
                            subscribeMeetingState(meetingId);
                        }
                    }

                    // 7. Download initial backup if enabled
                    if (meeting.settings?.autoBackup) {
                        setTimeout(() => {
                            downloadMeetingBackup('meeting-join');
                        }, 2000);
                    }

                    // Trigger re-render
                    setTimeout(() => {
                        const treeRenderer = window.getTreeRenderer && window.getTreeRenderer();
                        const canvasRenderer = window.getCanvasRenderer && window.getCanvasRenderer();
                        if (treeRenderer) treeRenderer();
                        const canvasContainer = document.getElementById('canvas-container');
                        if (canvasContainer && canvasContainer.classList.contains('active') && canvasRenderer) {
                            canvasRenderer();
                        }
                    }, 300);

                    return true;

                } catch (error) {
                    console.error('ğŸ“… Meeting join error:', error);
                    showToast('âŒ Failed to join meeting: ' + error.message, 'error');
                    return false;
                }
            }

            // Register user as meeting participant
            async function registerMeetingParticipant(meetingId, isHost) {
                try {
                    const meetingRef = window.firebaseDoc(window.firebaseDb, 'scheduledMeetings', meetingId);
                    const updateData = {};
                    updateData[`participants.${firebaseSyncState.userId}`] = {
                        name: firebaseSyncState.myDisplayName || (isHost ? 'Host' : 'Guest'),
                        role: isHost ? 'host' : 'guest',
                        joinedAt: Date.now(),
                        lastActiveAt: Date.now()
                    };
                    await window.firebaseUpdateDoc(meetingRef, updateData);
                    console.log('ğŸ“… Registered as participant');
                } catch (error) {
                    console.error('ğŸ“… Failed to register participant:', error);
                }
            }

            // Host activates the meeting (creates sync room)
            async function activateMeeting(meetingId) {
                console.log('ğŸ“… Activating meeting:', meetingId);

                // 1. Create a sync room
                const roomId = generateRoomId();
                firebaseSyncState.roomId = roomId;

                try {
                    // 2. Create sync room document
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', roomId);
                    const initialConnectedUsers = {};
                    initialConnectedUsers[firebaseSyncState.userId] = {
                        name: firebaseSyncState.myDisplayName || 'Host',
                        joinedAt: Date.now(),
                        isHost: true
                    };

                    await window.firebaseSetDoc(roomRef, {
                        createdBy: firebaseSyncState.userId,
                        createdAt: window.firebaseServerTimestamp(),
                        lastUpdatedBy: firebaseSyncState.userId,
                        lastUpdatedAt: window.firebaseServerTimestamp(),
                        treeData: JSON.stringify(capexTree),
                        pattern: currentPattern,
                        projectName: capexTree?.name || 'Meeting',
                        chatMessages: [],
                        connectedUsers: initialConnectedUsers,
                        meetingId: meetingId,
                        meetingState: 'ACTIVE'
                    });

                    // 3. Update meeting document with room ID and state
                    const meetingRef = window.firebaseDoc(window.firebaseDb, 'scheduledMeetings', meetingId);
                    await window.firebaseUpdateDoc(meetingRef, {
                        roomId: roomId,
                        state: 'ACTIVE',
                        stateChangedAt: window.firebaseServerTimestamp()
                    });

                    // 4. Subscribe to room
                    subscribeToRoom(roomId);
                    firebaseSyncState.isConnected = true;
                    floatingChatState.isHost = true;

                    // 5. Update UI
                    updateSyncUI();
                    showFloatingChat();
                    hideWaitingRoom();

                    // 6. Start backup interval
                    const meetingSnap = await window.firebaseGetDoc(meetingRef);
                    if (meetingSnap.exists() && meetingSnap.data().settings?.autoBackup) {
                        startMeetingBackupInterval();
                    }

                    showToast('ğŸ“… Meeting started! Waiting participants will auto-join.', 'success');
                    console.log('ğŸ“… Meeting activated, room:', roomId);

                } catch (error) {
                    console.error('ğŸ“… Failed to activate meeting:', error);
                    showToast('âŒ Failed to start meeting: ' + error.message, 'error');
                }
            }

            // Subscribe to meeting state changes (for waiting guests)
            function subscribeMeetingState(meetingId) {
                console.log('ğŸ“… Subscribing to meeting state:', meetingId);

                const meetingRef = window.firebaseDoc(window.firebaseDb, 'scheduledMeetings', meetingId);

                meetingState.meetingUnsubscribe = window.firebaseOnSnapshot(meetingRef, async (doc) => {
                    if (!doc.exists()) {
                        showToast('âš ï¸ Meeting was cancelled', 'warning');
                        hideWaitingRoom();
                        return;
                    }

                    const meeting = doc.data();
                    console.log('ğŸ“… Meeting state update:', meeting.state);

                    if (meeting.state === 'ACTIVE' && meeting.roomId) {
                        // Host arrived! Join the sync room
                        hideWaitingRoom();

                        showToast('ğŸ‰ Host has joined! Connecting to live session...', 'success');

                        // Unsubscribe from meeting state (we'll use room subscription now)
                        if (meetingState.meetingUnsubscribe) {
                            meetingState.meetingUnsubscribe();
                            meetingState.meetingUnsubscribe = null;
                        }

                        // Join the sync room
                        await joinSyncRoom(meeting.roomId);

                        // Start backup interval if enabled
                        if (meeting.settings?.autoBackup) {
                            startMeetingBackupInterval();
                        }

                        // Prompt for voice if enabled
                        if (meeting.settings?.autoVoicePrompt) {
                            setTimeout(() => showVoicePrompt(), 2000);
                        }
                    }

                    if (meeting.state === 'ENDED') {
                        showToast('ğŸ“… Meeting has ended', 'info');
                        hideWaitingRoom();
                        stopMeetingBackupInterval();
                    }
                });
            }

            // Show waiting room UI
            function showWaitingRoom(meeting) {
                const banner = document.getElementById('waiting-room-banner');
                if (!banner) {
                    console.warn('ğŸ“… Waiting room banner not found');
                    return;
                }

                const statusEl = document.getElementById('waiting-status');
                const messageEl = document.getElementById('waiting-message');

                banner.style.display = 'flex';
                if (statusEl) {
                    statusEl.textContent = `â³ Waiting for ${meeting.hostName || 'host'} to start the meeting...`;
                }
                if (messageEl) {
                    const editMsg = meeting.settings?.allowGuestEdits
                        ? 'You can start editing - changes will sync when host arrives.'
                        : 'View only until host arrives.';
                    messageEl.textContent = editMsg;
                }

                meetingState.waitingStartTime = Date.now();

                // Update waiting timer periodically
                updateWaitingTimer();
            }

            function hideWaitingRoom() {
                const banner = document.getElementById('waiting-room-banner');
                if (banner) {
                    banner.style.display = 'none';
                }
                meetingState.waitingStartTime = null;
            }

            // Update waiting timer display
            function updateWaitingTimer() {
                if (!meetingState.waitingStartTime) return;

                const timerEl = document.getElementById('waiting-timer');
                if (!timerEl) return;

                const elapsed = Math.floor((Date.now() - meetingState.waitingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                timerEl.textContent = `(${minutes}:${seconds.toString().padStart(2, '0')})`;

                // Continue updating
                setTimeout(updateWaitingTimer, 1000);
            }

            // Show voice prompt toast
            function showVoicePrompt() {
                const prompt = document.getElementById('voice-prompt-toast');
                if (!prompt) return;

                prompt.style.display = 'flex';
                prompt.classList.add('slide-in');

                // Auto-dismiss after 15 seconds
                setTimeout(() => {
                    if (prompt.style.display !== 'none') {
                        dismissVoicePrompt();
                    }
                }, 15000);
            }

            function acceptVoicePrompt() {
                const prompt = document.getElementById('voice-prompt-toast');
                if (prompt) prompt.style.display = 'none';
                window.startVoiceChat();
            }

            function dismissVoicePrompt() {
                const prompt = document.getElementById('voice-prompt-toast');
                if (!prompt) return;

                prompt.classList.add('slide-out');
                setTimeout(() => {
                    prompt.style.display = 'none';
                    prompt.classList.remove('slide-out', 'slide-in');
                }, 300);
            }

            // Download JSON backup with meeting context
            function downloadMeetingBackup(trigger = 'manual') {
                if (typeof capexTree === 'undefined') return;

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const meetingId = meetingState.currentMeetingId || 'adhoc';
                const safeName = (capexTree.name || 'meeting-tree').replace(/[^a-z0-9]/gi, '-').toLowerCase();

                const filename = `treelisty-meeting-${meetingId}-${safeName}-${trigger}-${timestamp}.json`;

                // Add metadata to backup
                const backupData = {
                    ...capexTree,
                    _meetingBackup: {
                        meetingId: meetingId,
                        trigger: trigger,
                        timestamp: new Date().toISOString(),
                        participants: Object.keys(firebaseSyncState.collaboratorNames || {}),
                        isHost: meetingState.isHost
                    }
                };

                const dataStr = JSON.stringify(backupData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('ğŸ’¾ Meeting backup saved:', filename);
                showToast(`ğŸ’¾ Backup saved: ${filename.substring(0, 40)}...`, 'success');
            }

            // Start periodic backup interval (every 5 minutes)
            function startMeetingBackupInterval() {
                if (meetingState.backupInterval) return;

                console.log('ğŸ’¾ Starting periodic backup (every 5 min)');
                meetingState.backupInterval = setInterval(() => {
                    downloadMeetingBackup('periodic');
                }, 5 * 60 * 1000); // Every 5 minutes
            }

            // Stop periodic backup
            function stopMeetingBackupInterval() {
                if (meetingState.backupInterval) {
                    clearInterval(meetingState.backupInterval);
                    meetingState.backupInterval = null;
                    console.log('ğŸ’¾ Stopped periodic backup');
                }
            }

            // Show meeting link modal
            function showMeetingModal() {
                const modal = document.getElementById('meeting-link-modal');
                if (modal) {
                    modal.style.display = 'flex';
                    // Reset to create view
                    const createSection = document.getElementById('meeting-create-section');
                    const generatedSection = document.getElementById('meeting-generated-section');
                    if (createSection) createSection.style.display = 'block';
                    if (generatedSection) generatedSection.style.display = 'none';
                    // Pre-fill meeting name
                    const nameInput = document.getElementById('meeting-name-input');
                    if (nameInput) nameInput.value = capexTree.name || '';
                }
            }

            function closeMeetingModal() {
                const modal = document.getElementById('meeting-link-modal');
                if (modal) modal.style.display = 'none';
            }

            function copyMeetingLink() {
                const linkInput = document.getElementById('meeting-link-url');
                if (linkInput) {
                    navigator.clipboard.writeText(linkInput.value)
                        .then(() => showToast('ğŸ“‹ Meeting link copied!', 'success'))
                        .catch(() => {
                            linkInput.select();
                            document.execCommand('copy');
                            showToast('ğŸ“‹ Meeting link copied!', 'success');
                        });
                }
            }

            // Expose meeting functions globally
            window.createScheduledMeeting = createScheduledMeeting;
            window.handleMeetingURL = handleMeetingURL;
            window.showMeetingModal = showMeetingModal;
            window.closeMeetingModal = closeMeetingModal;
            window.copyMeetingLink = copyMeetingLink;
            window.downloadMeetingBackup = downloadMeetingBackup;
            window.acceptVoicePrompt = acceptVoicePrompt;
            window.dismissVoicePrompt = dismissVoicePrompt;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // END BUILD 325: Scheduled Meeting Link System
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // BUILD 257: Manual JSON save during collaboration
            window.saveCollabJSON = function() {
                if (typeof capexTree === 'undefined') {
                    showToast('âŒ No tree data to save', 'error');
                    return;
                }

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const safeName = (capexTree.name || 'collab-tree').replace(/[^a-z0-9]/gi, '-').toLowerCase();
                const filename = `treelisty-${currentPattern}-${safeName}-${timestamp}.json`;

                const dataStr = JSON.stringify(capexTree, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                showToast(`ğŸ’¾ Saved: ${filename}`, 'success');
            };

            // BUILD 257: Toggle auto-save JSON on every sync
            window.toggleCollabAutoSave = function(enabled) {
                firebaseSyncState.autoSaveJSON = enabled;
                localStorage.setItem('treelisty_collab_autosave', enabled ? 'true' : 'false');
                showToast(enabled ? 'âœ… Auto-save JSON enabled' : 'â¸ï¸ Auto-save JSON disabled', 'info');
            };

            // BUILD 257: Check auto-save setting and restore checkbox state
            firebaseSyncState.autoSaveJSON = localStorage.getItem('treelisty_collab_autosave') === 'true';

            // BUILD 265: Copy invite link
            window.copySyncInviteLink = async function() {
                const linkInput = document.getElementById('sync-invite-link');
                if (linkInput && linkInput.value) {
                    try {
                        await navigator.clipboard.writeText(linkInput.value);
                        showToast('ğŸ“‹ Invite link copied!', 'success');
                    } catch (e) {
                        linkInput.select();
                        document.execCommand('copy');
                        showToast('ğŸ“‹ Invite link copied!', 'success');
                    }
                }
            };

            // BUILD 351: Copy just the session code (easier to share verbally)
            window.copySessionCode = async function() {
                const roomId = firebaseSyncState.roomId || document.getElementById('active-room-id')?.value || '';
                if (roomId) {
                    try {
                        await navigator.clipboard.writeText(roomId);
                        showToast(`ğŸ“‹ Code copied: ${roomId}`, 'success');
                        // Brief visual feedback on the code display
                        const codeDisplay = document.getElementById('active-room-id-display');
                        if (codeDisplay) {
                            const originalBg = codeDisplay.style.background;
                            codeDisplay.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                            codeDisplay.style.color = 'white';
                            setTimeout(() => {
                                codeDisplay.style.background = originalBg || 'var(--bg)';
                                codeDisplay.style.color = 'var(--text-primary)';
                            }, 500);
                        }
                    } catch (e) {
                        // Fallback for older browsers
                        const tempInput = document.createElement('input');
                        tempInput.value = roomId;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);
                        showToast(`ğŸ“‹ Code copied: ${roomId}`, 'success');
                    }
                }
            };

            // BUILD 265: Email invite link
            window.emailSyncInvite = function() {
                const roomId = firebaseSyncState.roomId || '';
                const inviteLink = document.getElementById('sync-invite-link')?.value || '';
                const projectName = capexTree?.name || 'TreeListy Project';

                const subject = encodeURIComponent(`Join my TreeListy session: ${projectName}`);
                const body = encodeURIComponent(
                    `Hi!\n\n` +
                    `I'd like to collaborate with you on "${projectName}" in TreeListy.\n\n` +
                    `Click this link to join my live session:\n${inviteLink}\n\n` +
                    `Room Code: ${roomId}\n\n` +
                    `See you there!`
                );

                window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');
            };

            // BUILD 281: toggleApiKeySharing removed - guests enter keys manually

            // BUILD 265: Send chat message
            window.sendSyncChatMessage = async function() {
                const input = document.getElementById('sync-chat-input');
                const message = input?.value?.trim();
                if (!message || !firebaseSyncState.roomId) return;

                input.value = '';
                await window.sendSyncChatMessageText(message);
            };

            // BUILD 268: Send chat message with text directly (for floating chat and API key sharing)
            window.sendSyncChatMessageText = async function(message, metadata = null) {
                if (!message || !firebaseSyncState.roomId) return;

                const chatMsg = {
                    userId: firebaseSyncState.userId?.substring(0, 8) || 'anon',
                    name: firebaseSyncState.myDisplayName || 'User',
                    text: message,
                    timestamp: Date.now(),
                    ...(metadata && { metadata })
                };

                // Add to local display immediately (both modal and floating)
                addChatMessageToUI(chatMsg);

                // Push to Firebase (store in room doc)
                try {
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', firebaseSyncState.roomId);
                    const roomSnap = await window.firebaseGetDoc(roomRef);
                    if (roomSnap.exists()) {
                        const data = roomSnap.data();
                        const messages = data.chatMessages || [];
                        messages.push(chatMsg);
                        // Keep only last 50 messages
                        if (messages.length > 50) messages.shift();
                        await window.firebaseSetDoc(roomRef, { chatMessages: messages }, { merge: true });
                    }
                } catch (e) {
                    console.error('ğŸ”¥ Failed to send chat message:', e);
                }
            };

            // BUILD 265: Add chat message to UI (modal)
            function addChatMessageToUI(msg) {
                const container = document.getElementById('sync-chat-messages');
                if (container) {
                    // Remove "no messages" placeholder
                    const placeholder = container.querySelector('div[style*="text-align: center"]');
                    if (placeholder) placeholder.remove();

                    const isMe = msg.userId === firebaseSyncState.userId?.substring(0, 8);
                    const msgEl = document.createElement('div');
                    msgEl.style.cssText = `margin-bottom: 6px; ${isMe ? 'text-align: right;' : ''}`;
                    msgEl.innerHTML = `
                        <span style="font-weight: 600; color: ${isMe ? '#10b981' : '#6366f1'};">${msg.name || 'User'}:</span>
                        <span style="color: var(--text-primary);">${msg.text}</span>
                    `;
                    container.appendChild(msgEl);
                    container.scrollTop = container.scrollHeight;
                }

                // BUILD 268: Also add to floating chat
                addMessageToFloatingChat(msg);
            }

            // BUILD 268: Track floating chat state
            let floatingChatState = {
                isExpanded: true,
                unreadCount: 0,
                lastMessageCount: 0,
                previousUserCount: 1,
                isHost: false,
                // BUILD 272: Draggable state
                isDragging: false,
                dragOffsetX: 0,
                dragOffsetY: 0
            };

            // BUILD 272: Make floating chat draggable
            function initFloatingChatDrag() {
                const chatBox = document.getElementById('floating-collab-chat');
                const header = document.getElementById('floating-chat-header');
                if (!chatBox || !header) return;

                header.style.cursor = 'move';

                let dragStartX = 0, dragStartY = 0;
                let hasMoved = false;

                header.addEventListener('mousedown', (e) => {
                    // Don't start drag if clicking on toggle arrow
                    if (e.target.id === 'floating-chat-toggle') {
                        return;
                    }
                    floatingChatState.isDragging = true;
                    hasMoved = false;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    const rect = chatBox.getBoundingClientRect();
                    floatingChatState.dragOffsetX = e.clientX - rect.left;
                    floatingChatState.dragOffsetY = e.clientY - rect.top;
                    chatBox.style.transition = 'none';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!floatingChatState.isDragging) return;
                    const chatBox = document.getElementById('floating-collab-chat');
                    if (!chatBox) return;

                    // Check if actually moved (more than 5px)
                    const dx = Math.abs(e.clientX - dragStartX);
                    const dy = Math.abs(e.clientY - dragStartY);
                    if (dx > 5 || dy > 5) {
                        hasMoved = true;
                    }

                    let newX = e.clientX - floatingChatState.dragOffsetX;
                    let newY = e.clientY - floatingChatState.dragOffsetY;

                    // Keep within viewport
                    const maxX = window.innerWidth - chatBox.offsetWidth;
                    const maxY = window.innerHeight - chatBox.offsetHeight;
                    newX = Math.max(0, Math.min(newX, maxX));
                    newY = Math.max(0, Math.min(newY, maxY));

                    // Switch from bottom/right positioning to top/left
                    chatBox.style.bottom = 'auto';
                    chatBox.style.right = 'auto';
                    chatBox.style.left = newX + 'px';
                    chatBox.style.top = newY + 'px';
                });

                document.addEventListener('mouseup', () => {
                    if (floatingChatState.isDragging) {
                        floatingChatState.isDragging = false;
                        const chatBox = document.getElementById('floating-collab-chat');
                        if (chatBox) chatBox.style.transition = '';

                        // If didn't actually move, allow the click to toggle
                        if (!hasMoved) {
                            window.toggleFloatingChat();
                        }
                    }
                });
            }

            // Initialize drag on DOM ready
            document.addEventListener('DOMContentLoaded', initFloatingChatDrag);

            // BUILD 268: Toggle floating chat expand/collapse
            // BUILD 272: Updated to prevent toggle during drag
            window.toggleFloatingChat = function() {
                // Don't toggle if we were just dragging
                if (floatingChatState.isDragging) return;

                const body = document.getElementById('floating-chat-body');
                const toggle = document.getElementById('floating-chat-toggle');
                if (!body || !toggle) return;

                floatingChatState.isExpanded = !floatingChatState.isExpanded;
                if (floatingChatState.isExpanded) {
                    body.style.maxHeight = '350px';
                    toggle.textContent = 'â–¼';
                    // Clear unread when expanded
                    floatingChatState.unreadCount = 0;
                    const badge = document.getElementById('floating-unread-badge');
                    if (badge) badge.style.display = 'none';
                } else {
                    body.style.maxHeight = '0';
                    toggle.textContent = 'â–²';
                }
            };

            // BUILD 279: Show floating chat box
            function showFloatingChat() {
                const chatBox = document.getElementById('floating-collab-chat');
                if (chatBox) {
                    chatBox.style.display = 'block';
                }
            }

            // BUILD 268: Hide floating chat box
            function hideFloatingChat() {
                const chatBox = document.getElementById('floating-collab-chat');
                if (chatBox) chatBox.style.display = 'none';
            }

            // BUILD 268: Send message from floating chat
            window.sendFloatingChatMessage = function() {
                const input = document.getElementById('floating-chat-input');
                if (!input || !input.value.trim()) return;

                // Reuse existing sendSyncChatMessage but with floating input
                const text = input.value.trim();
                input.value = '';

                // Call the existing chat send function
                if (window.sendSyncChatMessageText) {
                    window.sendSyncChatMessageText(text);
                } else {
                    // Fallback: set the modal input and send
                    const modalInput = document.getElementById('sync-chat-input');
                    if (modalInput) {
                        modalInput.value = text;
                        window.sendSyncChatMessage();
                    }
                }
            };

            // BUILD 281: shareApiKeysInChat removed - guests enter keys manually via chat

            // BUILD 268/281: Update floating chat with new message (API key special handling removed)
            function addMessageToFloatingChat(msg) {
                const container = document.getElementById('floating-chat-messages');
                if (!container) return;

                // Remove "no messages" placeholder
                const placeholder = container.querySelector('div[style*="text-align: center"]');
                if (placeholder) placeholder.remove();

                const isMe = msg.userId === firebaseSyncState.userId?.substring(0, 8);
                const msgEl = document.createElement('div');
                msgEl.style.cssText = `margin-bottom: 6px; ${isMe ? 'text-align: right;' : ''}`;

                msgEl.innerHTML = `
                    <span style="font-weight: 600; color: ${isMe ? '#10b981' : '#6366f1'}; font-size: 11px;">${msg.name || 'User'}:</span>
                    <span style="color: var(--text-primary); font-size: 11px;">${msg.text}</span>
                `;

                container.appendChild(msgEl);
                container.scrollTop = container.scrollHeight;

                // Update unread count if chat is collapsed
                if (!floatingChatState.isExpanded && !isMe) {
                    floatingChatState.unreadCount++;
                    const badge = document.getElementById('floating-unread-badge');
                    if (badge) {
                        badge.textContent = floatingChatState.unreadCount;
                        badge.style.display = 'inline';
                    }
                }
            }

            // BUILD 281: applySharedApiKeys removed - guests enter API keys manually

            // BUILD 268: Update floating chat collaborators list
            function updateFloatingCollabList(connectedUsers) {
                const listEl = document.getElementById('floating-collab-list');
                const countEl = document.getElementById('floating-user-count');
                if (!listEl) return;

                const users = Object.entries(connectedUsers || {});
                const count = users.length || 1;

                if (countEl) countEl.textContent = count;

                // Rebuild badges (compact version)
                listEl.innerHTML = '';

                // Add self first (smaller badge)
                const selfBadge = document.createElement('div');
                selfBadge.style.cssText = 'display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 12px; font-size: 10px; font-weight: 600; color: white;';
                selfBadge.innerHTML = `<span>ğŸ‘‘</span> You`;
                listEl.appendChild(selfBadge);

                // Add others
                users.forEach(([id, user]) => {
                    if (id === firebaseSyncState.userId) return;
                    const badge = document.createElement('div');
                    badge.style.cssText = 'display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; background: linear-gradient(135deg, #6366f1, #8b5cf6); border-radius: 12px; font-size: 10px; font-weight: 600; color: white;';
                    badge.innerHTML = `<span>ğŸ‘¤</span> ${user.name || id.substring(0, 6)}`;
                    listEl.appendChild(badge);
                });
            }

            // BUILD 265: Update collaborators list in UI
            function updateCollaboratorsUI(connectedUsers) {
                const listEl = document.getElementById('sync-collaborators-list');
                const countEl = document.getElementById('sync-user-count');
                if (!listEl) return;

                const users = Object.entries(connectedUsers || {});
                const count = users.length || 1;

                if (countEl) countEl.textContent = `${count} user${count !== 1 ? 's' : ''}`;

                // Rebuild collaborator badges
                listEl.innerHTML = '';

                // Add self first
                const selfBadge = document.createElement('div');
                selfBadge.className = 'collab-badge';
                selfBadge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 20px; font-size: 12px; font-weight: 600; color: white;';
                selfBadge.innerHTML = `<span>ğŸ‘‘</span> ${firebaseSyncState.myDisplayName || 'You'}`;
                listEl.appendChild(selfBadge);

                // Add others
                users.forEach(([id, user]) => {
                    if (id === firebaseSyncState.userId) return; // Skip self
                    const badge = document.createElement('div');
                    badge.className = 'collab-badge';
                    badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: linear-gradient(135deg, #6366f1, #8b5cf6); border-radius: 20px; font-size: 12px; font-weight: 600; color: white;';
                    badge.innerHTML = `<span>ğŸ‘¤</span> ${user.name || id.substring(0, 6)}`;
                    listEl.appendChild(badge);
                });

                // BUILD 268: Also update floating chat
                updateFloatingCollabList(connectedUsers);

                // BUILD 279: Auto-show floating chat when 2+ users in room (for BOTH host and guest)
                const otherUsers = users.filter(([id]) => id !== firebaseSyncState.userId);
                const chatBox = document.getElementById('floating-collab-chat');
                const isFloatingChatVisible = chatBox && chatBox.style.display !== 'none';

                // Auto-show floating chat when there are 2+ users (both host and guest)
                if (count >= 2) {
                    // Always ensure floating chat is shown (idempotent)
                    if (!isFloatingChatVisible) {
                        // Close the modal for host
                        if (floatingChatState.isHost) {
                            const modal = document.getElementById('live-sync-modal');
                            if (modal) modal.style.display = 'none';
                        }
                        showFloatingChat();
                    }

                    // Show toast for new arrivals (only once)
                    if (floatingChatState.previousUserCount < count && otherUsers.length > 0) {
                        const newUser = otherUsers[otherUsers.length - 1][1]?.name || 'A collaborator';
                        showToast(`ğŸ‘‹ ${newUser} joined the session!`, 'success');
                    }
                }

                // Track previous count for next update
                floatingChatState.previousUserCount = count;
            }

            // BUILD 274: Update chat UI (both modal and floating) - extracted for early processing
            function updateChatUI(chatMessages) {
                // Update modal chat (if element still exists - was removed in Build 272)
                const modalContainer = document.getElementById('sync-chat-messages');
                if (modalContainer) {
                    modalContainer.innerHTML = '';
                    if (chatMessages.length === 0) {
                        modalContainer.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 30px 0;">No messages yet</div>';
                    } else {
                        chatMessages.forEach(msg => {
                            const isMe = msg.userId === firebaseSyncState.userId?.substring(0, 8);
                            const msgEl = document.createElement('div');
                            msgEl.style.cssText = `margin-bottom: 6px; ${isMe ? 'text-align: right;' : ''}`;
                            msgEl.innerHTML = `
                                <span style="font-weight: 600; color: ${isMe ? '#10b981' : '#6366f1'};">${msg.name || 'User'}:</span>
                                <span style="color: var(--text-primary);">${msg.text}</span>
                            `;
                            modalContainer.appendChild(msgEl);
                        });
                        modalContainer.scrollTop = modalContainer.scrollHeight;
                    }
                }

                // Update floating chat
                const floatingContainer = document.getElementById('floating-chat-messages');
                if (floatingContainer) {
                    floatingContainer.innerHTML = '';
                    if (chatMessages.length === 0) {
                        floatingContainer.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 50px 0; font-size: 12px;">No messages yet</div>';
                    } else {
                        chatMessages.forEach(msg => addMessageToFloatingChat(msg));
                    }
                }
            }

            window.initFirebaseAuthIfNeeded = async function() {
                if (!firebaseSyncState.userId) {
                    await initFirebaseAuth();
                }
            };

            // Initialize on DOM ready
            document.addEventListener('DOMContentLoaded', () => {
                // Live Sync button
                document.getElementById('live-sync-btn')?.addEventListener('click', () => {
                    document.getElementById('live-sync-modal').style.display = 'flex';
                    // Auto-init auth when modal opens
                    if (!firebaseSyncState.userId) {
                        initFirebaseAuth();
                    }
                    // BUILD 257: Restore auto-save checkbox state
                    const autoSaveCheckbox = document.getElementById('collab-auto-save-json');
                    if (autoSaveCheckbox) {
                        autoSaveCheckbox.checked = firebaseSyncState.autoSaveJSON;
                    }
                });

                // Close button
                document.getElementById('live-sync-close')?.addEventListener('click', () => {
                    document.getElementById('live-sync-modal').style.display = 'none';
                });

                // Create room button
                document.getElementById('create-sync-room-btn')?.addEventListener('click', createSyncRoom);

                // Join room button
                document.getElementById('join-sync-room-btn')?.addEventListener('click', () => {
                    const roomId = document.getElementById('join-room-id')?.value;
                    joinSyncRoom(roomId);
                });

                // Leave room button
                document.getElementById('leave-sync-room-btn')?.addEventListener('click', leaveSyncRoom);

                // Copy room ID button
                document.getElementById('copy-room-id-btn')?.addEventListener('click', copyRoomId);

                // Close modal on outside click
                document.getElementById('live-sync-modal')?.addEventListener('click', (e) => {
                    if (e.target.id === 'live-sync-modal') {
                        document.getElementById('live-sync-modal').style.display = 'none';
                    }
                });

                // BUILD 329: Check for pending update restore FIRST (highest priority)
                const pendingUpdate = localStorage.getItem('treelisty:pending-update');
                if (pendingUpdate) {
                    console.log('ğŸ”„ Restoring tree state after update...');
                    try {
                        const updateState = JSON.parse(pendingUpdate);
                        localStorage.removeItem('treelisty:pending-update');

                        // Only restore if recent (within 30 seconds)
                        if (Date.now() - updateState.timestamp < 30000) {
                            setTimeout(() => {
                                try {
                                    // Restore tree
                                    window.capexTree = updateState.tree;

                                    // Restore pattern
                                    if (updateState.pattern && window.PATTERNS && window.PATTERNS[updateState.pattern]) {
                                        window.currentPattern = updateState.pattern;
                                        const patternSelect = document.getElementById('pattern-select');
                                        if (patternSelect) patternSelect.value = updateState.pattern;
                                    }

                                    // Update tree name display
                                    const treeNameDisplay = document.getElementById('tree-name-display');
                                    if (treeNameDisplay && updateState.tree.name) {
                                        treeNameDisplay.textContent = updateState.tree.name;
                                    }

                                    // Restore view state
                                    const vs = updateState.tree.viewState;
                                    if (vs) {
                                        // Restore view mode
                                        if (vs.viewMode && vs.viewMode !== viewMode) {
                                            const toggleBtn = document.getElementById('toggle-canvas-btn');
                                            if (toggleBtn && vs.viewMode === 'canvas' && viewMode === 'tree') {
                                                toggleBtn.click();
                                            } else if (toggleBtn && vs.viewMode === 'tree' && viewMode === 'canvas') {
                                                toggleBtn.click();
                                            }
                                        }
                                    }

                                    // Re-render
                                    const treeRenderer = window.getTreeRenderer && window.getTreeRenderer();
                                    if (treeRenderer) treeRenderer();

                                    // Reconnect to sync room if was in one
                                    if (updateState.roomId) {
                                        console.log('ğŸ”¥ Reconnecting to sync room:', updateState.roomId);
                                        initFirebaseAuth().then(() => {
                                            firebaseSyncState.roomId = updateState.roomId;
                                            firebaseSyncState.isConnected = true;
                                            subscribeToRoom(updateState.roomId);
                                            updateSyncUI();
                                            showFloatingChat();
                                        });
                                    }

                                    showToast('âœ… Updated to Build ' + (window.TREELISTY_VERSION?.build || 'latest') + ' - tree restored!', 'success');
                                    console.log('âœ… Tree state restored after update');
                                } catch (e) {
                                    console.error('âŒ Failed to restore tree after update:', e);
                                }
                            }, 500);
                            return; // Skip other initialization paths
                        }
                    } catch (e) {
                        console.warn('âš ï¸ Could not restore pending update:', e);
                        localStorage.removeItem('treelisty:pending-update');
                    }
                }

                // BUILD 325: Check for ?meeting= URL parameter FIRST (has priority)
                const urlParams = new URLSearchParams(window.location.search);
                const meetingParam = urlParams.get('meeting');
                if (meetingParam) {
                    console.log('ğŸ“… Meeting URL detected:', meetingParam);
                    // Wait for Firebase and app to initialize, then handle meeting
                    setTimeout(async () => {
                        await window.handleMeetingURL();
                    }, 1500);
                }

                // Check for ?room= URL parameter
                const roomParam = urlParams.get('room');
                if (roomParam && !meetingParam) {
                    console.log('ğŸ”¥ Room ID in URL:', roomParam);

                    // Check if we have pending tree data from a join
                    const pendingRoom = localStorage.getItem('firebase-pending-room');
                    const pendingTree = localStorage.getItem('firebase-pending-tree');

                    if (pendingRoom === roomParam && pendingTree) {
                        console.log('ğŸ”¥ Loading pending tree data...');
                        // Clear pending data
                        localStorage.removeItem('firebase-pending-room');
                        localStorage.removeItem('firebase-pending-tree');
                        const pendingPattern = localStorage.getItem('firebase-pending-pattern');
                        localStorage.removeItem('firebase-pending-pattern');

                        // Apply tree data to global capexTree (wait for app to initialize)
                        setTimeout(() => {
                            try {
                                const treeData = JSON.parse(pendingTree);
                                window.capexTree = treeData;

                                // Update pattern if present
                                if (pendingPattern && window.PATTERNS && window.PATTERNS[pendingPattern]) {
                                    window.currentPattern = pendingPattern;
                                    const patternSelect = document.getElementById('pattern-select');
                                    if (patternSelect) patternSelect.value = pendingPattern;
                                }

                                // Update tree name display
                                const treeNameDisplay = document.getElementById('tree-name-display');
                                if (treeNameDisplay) {
                                    treeNameDisplay.textContent = treeData.name || 'Synced Tree';
                                }

                                // Re-render the tree views using exposed getters
                                const treeRenderer = window.getTreeRenderer && window.getTreeRenderer();
                                const canvasRenderer = window.getCanvasRenderer && window.getCanvasRenderer();
                                if (treeRenderer) treeRenderer();
                                const canvasContainer = document.getElementById('canvas-container');
                                if (canvasContainer && canvasContainer.classList.contains('active') && canvasRenderer) {
                                    canvasRenderer();
                                }

                                // Mark as changed so it gets saved to localStorage
                                if (window.treeManager && window.treeManager.markAsChanged) {
                                    window.treeManager.markAsChanged();
                                    // Also do an immediate save
                                    window.treeManager.save(window.capexTree, { silent: true });
                                    console.log('ğŸ”¥ Synced tree saved to localStorage');
                                }

                                console.log('ğŸ”¥ Tree data applied and rendered, now subscribing...');
                                showToast('ğŸ”¥ Joined room: ' + roomParam, 'success');
                            } catch (e) {
                                console.error('ğŸ”¥ Failed to apply pending tree:', e);
                            }

                            // Now authenticate and subscribe
                            initFirebaseAuth().then(() => {
                                firebaseSyncState.roomId = roomParam;
                                firebaseSyncState.isConnected = true;
                                subscribeToRoom(roomParam);
                                updateSyncUI();

                                // BUILD 268: Show floating chat for guests (not host)
                                floatingChatState.isHost = false;
                                floatingChatState.previousUserCount = 1;
                                showFloatingChat();
                            });
                        }, 500);
                    } else {
                        // No pending data, do a fresh join
                        setTimeout(() => {
                            initFirebaseAuth().then(() => {
                                joinSyncRoom(roomParam);
                            });
                        }, 1000);
                    }
                }

                console.log('ğŸ”¥ Firebase Live Sync initialized');
            });

            // Hook into tree changes to auto-sync
            // We'll create a debounced sync function that watches the save indicator
            let syncDebounceTimer = null;
            let lastTreeHash = null;
            // BUILD 327: Track pending local changes to prevent loss during remote sync
            let hasPendingLocalChanges = false;

            // Expose hasPendingLocalChanges for snapshot handler
            window.firebaseHasPendingLocalChanges = () => hasPendingLocalChanges;
            window.firebaseFlushPendingChanges = async () => {
                if (hasPendingLocalChanges && syncDebounceTimer) {
                    clearTimeout(syncDebounceTimer);
                    syncDebounceTimer = null;
                    hasPendingLocalChanges = false;
                    console.log('ğŸ”¥ Flushing pending local changes before accepting remote...');
                    await pushTreeToRoom();
                }
            };

            // Simple hash function for tree comparison
            function simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash |= 0;
                }
                return hash;
            }

            // Check for tree changes periodically
            setInterval(() => {
                if (!firebaseSyncState.isConnected || !window.capexTree) return;

                const treeStr = JSON.stringify(window.capexTree);
                const currentHash = simpleHash(treeStr);

                if (lastTreeHash !== null && currentHash !== lastTreeHash) {
                    // Tree changed, debounce sync
                    clearTimeout(syncDebounceTimer);
                    hasPendingLocalChanges = true; // BUILD 327: Mark changes as pending
                    syncDebounceTimer = setTimeout(() => {
                        console.log('ğŸ”¥ Tree change detected, syncing...');
                        hasPendingLocalChanges = false; // BUILD 327: Clear pending flag after push
                        pushTreeToRoom();
                    }, 500);
                }

                lastTreeHash = currentHash;
            }, 2000); // Check every 2 seconds

        })();

        /**
         * Parse a branch from URL parameter
         * @param {string} compressedBranch - LZString compressed branch data
         * @returns {object|null} Parsed branch or null on error
         */
        function parseBranchFromURL(compressedBranch) {
            try {
                const decompressed = LZString.decompressFromEncodedURIComponent(compressedBranch);
                if (!decompressed) {
                    console.error('âŒ Failed to decompress branch data');
                    return null;
                }
                const branch = JSON.parse(decompressed);
                console.log('ğŸ“¦ Parsed branch:', {
                    branchId: branch.branchId,
                    sourceProject: branch.sourceProjectName,
                    nodeCount: branch.nodes?.length,
                    createdBy: branch.createdBy
                });
                return branch;
            } catch (error) {
                console.error('âŒ Failed to parse branch:', error);
                return null;
            }
        }

        /**
         * Check if the current device is the original branch creator
         * @param {object} branch - Branch to check
         * @returns {boolean} True if this device created the branch
         */
        function isOriginalBranchCreator(branch) {
            const myFingerprint = getDeviceFingerprint();
            return branch.createdBy === myFingerprint;
        }

        /**
         * Enter branch editing mode (for collaborators)
         * @param {object} branch - The branch being edited
         */
        function enterBranchEditMode(branch) {
            currentBranch = branch;

            // Create a temporary tree from the branch nodes
            const tempTree = {
                id: `branch-edit-${branch.branchId}`,
                name: `Editing: ${branch.nodes[0]?.name || 'Shared Branch'}`,
                type: 'root',
                icon: 'ğŸ¤',
                description: `Shared from "${branch.sourceProjectName}" for collaboration`,
                pattern: { key: branch.sourcePattern },
                children: []
            };

            // If single node, wrap appropriately
            if (branch.nodes.length === 1 && branch.nodes[0].type === 'phase') {
                tempTree.children = branch.nodes;
            } else {
                // Create a container phase for the shared items
                tempTree.children = [{
                    id: 'shared-phase',
                    name: 'Shared Content',
                    type: 'phase',
                    icon: 'ğŸ“¦',
                    phaseNumber: 0,
                    expanded: true,
                    items: branch.nodes.filter(n => n.type === 'item' || n.type === 'subtask'),
                    showInCanvas: true
                }];
                // Also add any phases directly
                const phases = branch.nodes.filter(n => n.type === 'phase');
                if (phases.length > 0) {
                    tempTree.children = phases;
                }
            }

            // Set pattern
            if (branch.sourcePattern && PATTERNS[branch.sourcePattern]) {
                currentPattern = branch.sourcePattern;
            }

            // Load the branch as the current tree
            capexTree = tempTree;

            // Show the editing banner
            const banner = document.getElementById('branch-edit-banner');
            const info = document.getElementById('branch-edit-info');
            if (banner && info) {
                info.textContent = `From: ${branch.sourceProjectName} â€¢ ${branch.nodes.length} node(s)`;
                banner.style.display = 'block';

                // Adjust tree container to account for banner
                const treeContainer = document.querySelector('.tree-view-container');
                if (treeContainer) {
                    treeContainer.style.marginTop = '50px';
                }
            }

            // Render
            render();
            if (viewMode === 'canvas') {
                renderCanvas();
            }

            console.log('ğŸ¤ Entered branch editing mode:', branch.branchId);
        }

        /**
         * Exit branch editing mode
         */
        function exitBranchEditMode() {
            if (!currentBranch) return;

            if (confirm('Exit editing mode? Any unsaved changes will be lost.\n\nTip: Use "Share Back" to send your changes before exiting.')) {
                currentBranch = null;

                // Hide banner
                const banner = document.getElementById('branch-edit-banner');
                if (banner) {
                    banner.style.display = 'none';
                }

                // Reset tree container margin
                const treeContainer = document.querySelector('.tree-view-container');
                if (treeContainer) {
                    treeContainer.style.marginTop = '0';
                }

                // Load default tree
                capexTree = JSON.parse(JSON.stringify(defaultCapexTree));
                render();
                if (viewMode === 'canvas') {
                    renderCanvas();
                }

                // Clear URL parameter
                window.history.replaceState({}, document.title, window.location.pathname);

                console.log('ğŸ‘‹ Exited branch editing mode');
            }
        }

        /**
         * Share back the edited branch to the original creator
         */
        async function shareBackBranch() {
            if (!currentBranch) {
                console.error('âŒ No branch to share back');
                return;
            }

            // Extract the edited nodes from current tree
            const editedNodes = [];

            // Collect all items and subtasks from the current tree
            function collectNodes(node) {
                if (node.type === 'item' || node.type === 'subtask' || node.type === 'phase') {
                    editedNodes.push(JSON.parse(JSON.stringify(node)));
                }
                if (node.children) node.children.forEach(collectNodes);
                if (node.items) node.items.forEach(collectNodes);
                if (node.subItems) node.subItems.forEach(collectNodes);
            }

            capexTree.children?.forEach(collectNodes);

            // Create a response branch
            const responseBranch = {
                ...currentBranch,
                branchId: `response-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                editedBy: getDeviceFingerprint(),
                editedAt: new Date().toISOString(),
                originalBranchId: currentBranch.branchId,
                nodes: editedNodes.length > 0 ? editedNodes : capexTree.children || [],
                isResponse: true
            };

            // Generate URL
            const shareURL = await generateBranchURL(responseBranch);

            // Show the share modal with response context
            showShareBackModal(responseBranch, shareURL);
        }

        /**
         * Show the Share Back modal
         * @param {object} branch - Response branch
         * @param {string} shareURL - Shareable URL
         */
        function showShareBackModal(branch, shareURL) {
            const modal = document.getElementById('share-branch-modal');
            const body = document.getElementById('share-branch-body');

            // Count edited nodes
            let totalNodes = 0;
            function countNodes(n) {
                totalNodes++;
                if (n.items) n.items.forEach(countNodes);
                if (n.subItems) n.subItems.forEach(countNodes);
                if (n.children) n.children.forEach(countNodes);
            }
            branch.nodes.forEach(countNodes);

            body.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #6366f1; margin-bottom: 20px;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #6366f1;">
                            <span>ğŸ“¤</span> Sending Back Your Edits
                        </div>
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 0;">
                            Send this link to the original author so they can merge your changes into their project.
                        </p>
                    </div>

                    <!-- Stats -->
                    <div style="display: flex; gap: 20px; font-size: 13px; color: var(--text-secondary); margin-bottom: 16px; padding: 12px; background: var(--card-bg); border-radius: 6px;">
                        <div>ğŸ“Š ${totalNodes} nodes</div>
                        <div>ğŸ“ ${shareURL.length.toLocaleString()} characters</div>
                        <div>ğŸ  Original: ${branch.sourceProjectName}</div>
                    </div>

                    <!-- URL Input -->
                    <div style="background: var(--card-bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 12px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="share-branch-url-input" readonly
                                   style="flex: 1; background: var(--card-bg); border: 1px solid var(--border); color: var(--text-primary); padding: 10px; border-radius: 6px; font-family: monospace; font-size: 11px; user-select: all;"
                                   value="${shareURL}">
                        </div>
                    </div>

                    <!-- Instructions -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #10b981;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #10b981;">
                            <span>âœ…</span> Next Steps
                        </div>
                        <ol style="margin-left: 20px; color: var(--text-secondary); font-size: 13px; line-height: 1.8;">
                            <li>Copy the URL or click "Open Email"</li>
                            <li>Send to the original author</li>
                            <li>They'll see your changes and can merge them</li>
                        </ol>
                    </div>
                </div>
            `;

            // Store for email button
            pendingShareBranch = branch;

            modal.style.display = 'flex';

            // Select URL
            setTimeout(() => {
                const urlInput = document.getElementById('share-branch-url-input');
                if (urlInput) urlInput.select();
            }, 100);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MCP BRIDGE - CLAUDE CODE INTEGRATION (Build 518, Auto-Connect Build 520)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // MCP Auto-Connect defaults (Build 520)
        const MCP_STORAGE_KEY = 'treelisty_mcp_config';
        const MCP_DEFAULT_PORT = 3456;
        const MCP_DEFAULT_TOKEN = 'treelisty-local';

        // MCP Bridge state
        const mcpBridgeState = {
            client: null,
            handler: null,
            status: 'disconnected', // disconnected | connecting | connected
            port: null,
            token: null,
            activityLog: [],
            // Build 522: Agent Dispatch Inbox
            inbox: [],           // Completed tasks with proposed_ops awaiting user action
            activeTasks: [],     // Tasks currently being processed by Claude Code
            taskProgress: {}     // taskId -> { message, percent }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 614: Work Status Panel - Visibility into background work
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const workStatusState = {
            // Active operations
            active: [],  // { id, type, title, provider, startedAt, progress, progressMessage, cancellable }

            // Queued operations
            queued: [],  // { id, type, title, queuedAt, dependsOn }

            // Completed (recent, max 10)
            completed: [],  // { id, type, title, completedAt, duration, hasResults, resultsSeen }

            // Session statistics
            stats: {
                apiCalls: 0,
                tokensUsed: 0,
                estimatedCost: 0,
                tasksCompleted: 0,
                totalDuration: 0,
                sessionStart: Date.now()
            }
        };

        // Work Status: Add active task
        function workStatusAddActive(task) {
            const existing = workStatusState.active.find(t => t.id === task.id);
            if (!existing) {
                workStatusState.active.push({
                    id: task.id,
                    type: task.type || 'agent',
                    title: task.title || 'Working...',
                    provider: task.provider || 'mcp',
                    startedAt: Date.now(),
                    progress: 0,
                    progressMessage: task.message || 'Starting...',
                    cancellable: task.cancellable !== false
                });
            }
            updateWorkStatusUI();
        }

        // Work Status: Update progress
        function workStatusUpdateProgress(taskId, progress, message) {
            const task = workStatusState.active.find(t => t.id === taskId);
            if (task) {
                task.progress = progress;
                task.progressMessage = message || task.progressMessage;
            }
            updateWorkStatusUI();
        }

        // Work Status: Complete task
        function workStatusComplete(taskId, hasResults = false) {
            const task = workStatusState.active.find(t => t.id === taskId);
            if (task) {
                const duration = Date.now() - task.startedAt;
                workStatusState.completed.unshift({
                    id: taskId,
                    type: task.type,
                    title: task.title,
                    completedAt: Date.now(),
                    duration: duration,
                    hasResults: hasResults,
                    resultsSeen: false
                });
                // Keep max 10 completed
                if (workStatusState.completed.length > 10) {
                    workStatusState.completed.pop();
                }
                workStatusState.active = workStatusState.active.filter(t => t.id !== taskId);
                workStatusState.stats.tasksCompleted++;
                workStatusState.stats.totalDuration += duration;
            }
            updateWorkStatusUI();
        }

        // Work Status: Track API call
        function workStatusTrackAPI(provider, tokens = 0, cost = 0) {
            workStatusState.stats.apiCalls++;
            workStatusState.stats.tokensUsed += tokens;
            workStatusState.stats.estimatedCost += cost;
            updateWorkStatusUI();
        }

        // Work Status: Update UI
        function updateWorkStatusUI() {
            const btn = document.getElementById('work-status-btn');
            const badge = document.getElementById('work-status-badge');

            if (!btn || !badge) return;

            const activeCount = workStatusState.active.length;
            const needsReview = workStatusState.completed.filter(t => t.hasResults && !t.resultsSeen).length;
            const inboxCount = mcpBridgeState.inbox.length;

            // Update badge
            const totalCount = activeCount + inboxCount;
            badge.textContent = totalCount;
            badge.style.display = totalCount > 0 ? 'flex' : 'none';

            // Update button style based on state
            if (activeCount > 0) {
                btn.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
                btn.classList.add('pulse-animation');
            } else if (inboxCount > 0) {
                btn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                btn.classList.remove('pulse-animation');
            } else {
                btn.style.background = 'linear-gradient(135deg, #6b7280, #4b5563)';
                btn.classList.remove('pulse-animation');
            }

            // Update panel if open
            if (document.getElementById('work-status-modal')?.style.display === 'flex') {
                renderWorkStatusPanel();
            }
        }

        // Work Status: Render panel contents
        function renderWorkStatusPanel() {
            const activeList = document.getElementById('work-status-active-list');
            const completedList = document.getElementById('work-status-completed-list');
            const statsEl = document.getElementById('work-status-stats');

            if (!activeList) return;

            // Render active tasks
            if (workStatusState.active.length === 0 && mcpBridgeState.activeTasks.length === 0) {
                activeList.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; padding: 12px;">No active tasks</div>';
            } else {
                let html = '';

                // Include MCP active tasks
                mcpBridgeState.activeTasks.forEach(taskId => {
                    const progress = mcpBridgeState.taskProgress[taskId] || {};
                    html += `
                        <div style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 8px; border-left: 3px solid #3b82f6;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-weight: 500;">ğŸ¤– ${escapeHtml(progress.message || 'Agent Task')}</span>
                                <span style="font-size: 11px; color: var(--text-secondary);">MCP</span>
                            </div>
                            <div style="background: var(--border); border-radius: 4px; height: 6px; overflow: hidden;">
                                <div style="background: #3b82f6; height: 100%; width: ${progress.percent || 0}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px;">${progress.percent || 0}% complete</div>
                        </div>
                    `;
                });

                // Include workStatusState active tasks
                workStatusState.active.forEach(task => {
                    const elapsed = Math.round((Date.now() - task.startedAt) / 1000);
                    const icon = task.type === 'research' ? 'ğŸ”' : task.type === 'sync' ? 'ğŸ“§' : task.type === 'ai-call' ? 'ğŸ§ ' : 'âš¡';
                    html += `
                        <div style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 8px; border-left: 3px solid #3b82f6;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-weight: 500;">${icon} ${escapeHtml(task.title)}</span>
                                <span style="font-size: 11px; color: var(--text-secondary);">${elapsed}s</span>
                            </div>
                            <div style="background: var(--border); border-radius: 4px; height: 6px; overflow: hidden;">
                                <div style="background: #3b82f6; height: 100%; width: ${task.progress}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px;">${escapeHtml(task.progressMessage)}</div>
                        </div>
                    `;
                });

                activeList.innerHTML = html;
            }

            // Render completed tasks + inbox items
            if (completedList) {
                let html = '';

                // Show inbox items first (need approval)
                mcpBridgeState.inbox.forEach((item, idx) => {
                    const opsCount = item.result?.proposed_ops?.length || 0;
                    const ago = formatTimeAgo(item.receivedAt);
                    html += `
                        <div style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 8px; border-left: 3px solid #f59e0b;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: 500;">ğŸ“¥ ${opsCount} proposed change${opsCount !== 1 ? 's' : ''}</span>
                                <span style="font-size: 11px; color: var(--text-secondary);">${ago}</span>
                            </div>
                            <button onclick="showInboxModal()" style="margin-top: 8px; padding: 4px 12px; background: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Review in Inbox</button>
                        </div>
                    `;
                });

                // Show recent completed
                workStatusState.completed.slice(0, 5).forEach(task => {
                    const ago = formatTimeAgo(task.completedAt);
                    const durationSec = Math.round(task.duration / 1000);
                    html += `
                        <div style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 8px; border-left: 3px solid #22c55e;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: 500;">âœ… ${escapeHtml(task.title)}</span>
                                <span style="font-size: 11px; color: var(--text-secondary);">${ago}</span>
                            </div>
                            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px;">Completed in ${durationSec}s</div>
                        </div>
                    `;
                });

                if (html === '') {
                    html = '<div style="color: var(--text-secondary); font-style: italic; padding: 12px;">No recent activity</div>';
                }

                completedList.innerHTML = html;
            }

            // Render stats
            if (statsEl) {
                const avgTime = workStatusState.stats.tasksCompleted > 0
                    ? Math.round(workStatusState.stats.totalDuration / workStatusState.stats.tasksCompleted / 1000)
                    : 0;
                statsEl.innerHTML = `
                    API Calls: ${workStatusState.stats.apiCalls} â€¢
                    Tokens: ~${(workStatusState.stats.tokensUsed / 1000).toFixed(1)}k â€¢
                    Tasks: ${workStatusState.stats.tasksCompleted} â€¢
                    Avg: ${avgTime}s
                `;
            }
        }

        // Helper: Format time ago
        function formatTimeAgo(timestamp) {
            const seconds = Math.round((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.round(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.round(seconds / 3600)}h ago`;
            return `${Math.round(seconds / 86400)}d ago`;
        }

        // Show Work Status Modal
        function showWorkStatusModal() {
            const modal = document.getElementById('work-status-modal');
            if (modal) {
                modal.style.display = 'flex';
                renderWorkStatusPanel();
            }
        }

        // Build 522: Handle task events from MCP bridge
        function handleMCPTaskEvent(event) {
            console.log('[MCP Task]', event.type, event);

            switch (event.type) {
                case 'task.submitted':
                case 'task_queued':
                    // Task was accepted into queue
                    showToast(`ğŸ¤– Task queued (#${event.position || 1})`, 'success', 2000);
                    break;

                case 'task_claimed':
                    // Claude Code started working on task
                    mcpBridgeState.activeTasks.push(event.taskId);
                    mcpBridgeState.taskProgress[event.taskId] = {
                        message: event.taskSummary || 'Starting...',
                        percent: 0,
                        type: event.taskType || 'unknown'
                    };
                    // BUILD 614: Track in Work Status
                    workStatusAddActive({
                        id: event.taskId,
                        type: event.taskType || 'mcp_task',
                        title: event.taskSummary || 'MCP Task',
                        provider: 'Claude Code',
                        cancellable: false
                    });
                    // Show descriptive toast for dev requests
                    if (event.taskType === 'dev_request') {
                        const summary = event.taskSummary || 'new capability';
                        showToast(`ğŸ”§ Claude Code implementing: ${summary.substring(0, 50)}${summary.length > 50 ? '...' : ''}`, 'info', 5000);
                    } else {
                        showToast('ğŸ¤– Claude Code is working...', 'info', 2000);
                    }
                    updateInboxUI();
                    updateWorkStatusUI();
                    break;

                case 'task_progress':
                    // Progress update
                    mcpBridgeState.taskProgress[event.taskId] = {
                        message: event.message,
                        percent: event.percent || 0
                    };
                    // BUILD 614: Track progress in Work Status
                    workStatusUpdateProgress(event.taskId, event.percent || 0, event.message);
                    updateInboxUI();
                    updateWorkStatusUI();
                    break;

                case 'task_completed':
                    // Task completed with proposed operations
                    mcpBridgeState.activeTasks = mcpBridgeState.activeTasks.filter(id => id !== event.taskId);
                    const completedTaskInfo = mcpBridgeState.taskProgress[event.taskId];
                    delete mcpBridgeState.taskProgress[event.taskId];

                    // BUILD 614: Mark complete in Work Status
                    const hasInboxResults = event.taskType !== 'dev_request' && event.result?.proposed_ops?.length > 0;
                    workStatusComplete(event.taskId, hasInboxResults);

                    // Add to inbox (unless it's a dev_request which doesn't need inbox review)
                    if (event.taskType !== 'dev_request') {
                        mcpBridgeState.inbox.push({
                            taskId: event.taskId,
                            result: event.result,
                            receivedAt: Date.now()
                        });
                    }

                    // Notify user based on task type
                    if (event.taskType === 'dev_request') {
                        const buildNum = event.result?.buildNumber || 'new';
                        showToast(`âœ… Build ${buildNum} deployed! Refresh to get new capabilities.`, 'success', 8000);
                    } else {
                        const opsCount = event.result?.proposed_ops?.length || 0;
                        showToast(`ğŸ“¥ Task complete! ${opsCount} proposed change${opsCount !== 1 ? 's' : ''} in Inbox`, 'success');
                    }
                    updateInboxUI();
                    updateWorkStatusUI();
                    break;

                // BUILD 534: Handle file open result from MCP Bridge
                case 'open_file_result':
                    if (event.success) {
                        showToast('ğŸ“‚ File opened!', 'success', 2000);
                    } else {
                        showToast(`âŒ Failed to open: ${event.error || 'Unknown error'}`, 'error');
                        console.error('[MCP] File open failed:', event.error, event.filePath);
                    }
                    break;
            }
        }

        // Build 522: Update Inbox UI
        function updateInboxUI() {
            // BUILD 553: Local escapeHtml helper (main one is defined later in file)
            const escapeHtml = (text) => {
                const div = document.createElement('div');
                div.textContent = text || '';
                return div.innerHTML;
            };

            const badge = document.getElementById('inbox-badge');
            if (badge) {
                const count = mcpBridgeState.inbox.length;
                badge.textContent = count;
                badge.style.display = count > 0 ? 'flex' : 'none';
            }

            // Update active task indicator
            const activeIndicator = document.getElementById('active-task-indicator');
            if (activeIndicator) {
                const hasActive = mcpBridgeState.activeTasks.length > 0;
                activeIndicator.style.display = hasActive ? 'flex' : 'none';
                if (hasActive) {
                    const progress = Object.values(mcpBridgeState.taskProgress)[0];
                    if (progress) {
                        activeIndicator.querySelector('.task-message').textContent = progress.message;
                    }
                }
            }

            // Update modal if open
            if (document.getElementById('inbox-modal')?.style.display === 'flex') {
                renderInboxItems();
            }
        }

        // Build 522: Show Inbox Modal
        function showInboxModal() {
            document.getElementById('inbox-modal').style.display = 'flex';
            renderInboxItems();
        }
        window.showInboxModal = showInboxModal;

        // Build 522: Render inbox items
        function renderInboxItems() {
            const activeSection = document.getElementById('inbox-active-tasks');
            const activeList = document.getElementById('inbox-active-list');
            const itemsList = document.getElementById('inbox-items-list');

            // Render active tasks
            if (mcpBridgeState.activeTasks.length > 0) {
                activeSection.style.display = 'block';
                activeList.innerHTML = mcpBridgeState.activeTasks.map(taskId => {
                    const progress = mcpBridgeState.taskProgress[taskId] || { message: 'Working...', percent: 0 };
                    return `
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span>${progress.message}</span>
                                <span style="color: var(--text-secondary);">${progress.percent}%</span>
                            </div>
                            <div style="background: var(--border); height: 4px; border-radius: 2px; overflow: hidden;">
                                <div style="background: #8b5cf6; height: 100%; width: ${progress.percent}%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                activeSection.style.display = 'none';
            }

            // Render completed tasks in inbox
            if (mcpBridgeState.inbox.length === 0) {
                itemsList.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                        <div style="font-size: 32px; margin-bottom: 12px;">ğŸ“­</div>
                        <p style="margin: 0;">No proposed changes</p>
                        <p style="margin: 8px 0 0 0; font-size: 12px;">When Claude Code completes tasks, proposed changes will appear here for your review.</p>
                    </div>
                `;
                return;
            }

            itemsList.innerHTML = mcpBridgeState.inbox.map((item, index) => {
                const result = item.result;
                const opsCount = result?.proposed_ops?.length || 0;
                const summary = result?.summary || 'No summary';
                const sources = result?.sources || [];

                return `
                    <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">
                            ${opsCount} proposed operation${opsCount !== 1 ? 's' : ''}
                        </div>
                        <p style="font-size: 13px; color: var(--text-secondary); margin: 0 0 12px 0; line-height: 1.5;">
                            ${escapeHtml(summary)}
                        </p>
                        ${sources.length > 0 ? `
                            <details style="margin-bottom: 12px;">
                                <summary style="cursor: pointer; font-size: 12px; color: var(--text-secondary);">Sources (${sources.length})</summary>
                                <div style="padding: 8px; font-size: 11px; background: var(--card-bg); border-radius: 4px; margin-top: 4px;">
                                    ${sources.map(s => `<div style="word-break: break-all;">${escapeHtml(s)}</div>`).join('')}
                                </div>
                            </details>
                        ` : ''}
                        <details style="margin-bottom: 12px;">
                            <summary style="cursor: pointer; font-size: 12px; color: var(--text-secondary);">Preview operations</summary>
                            <div style="padding: 8px; font-size: 11px; font-family: monospace; background: var(--card-bg); border-radius: 4px; margin-top: 4px; max-height: 200px; overflow-y: auto;">
                                ${result.proposed_ops.map(op => `<div style="margin-bottom: 4px;">${escapeHtml(JSON.stringify(op))}</div>`).join('')}
                            </div>
                        </details>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="window.approveInboxItem(${index})" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                âœ“ Apply All
                            </button>
                            <button onclick="window.rejectInboxItem(${index})" style="padding: 10px 16px; background: var(--bg); color: var(--text-secondary); border: 1px solid var(--border); border-radius: 6px; cursor: pointer;">
                                âœ• Reject
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Build 522: Apply inbox item operations
        function approveInboxItem(index) {
            // BUILD 554: Local findNodeById helper (main one is defined later in file)
            function findNodeByIdInbox(nodeId) {
                function search(node) {
                    if (!node) return null;
                    if (node.id === nodeId) return node;
                    for (const arr of [node.children, node.items, node.subItems]) {
                        if (arr && Array.isArray(arr)) {
                            for (const child of arr) {
                                const found = search(child);
                                if (found) return found;
                            }
                        }
                    }
                    return null;
                }
                return typeof capexTree !== 'undefined' && capexTree ? search(capexTree) : null;
            }

            const item = mcpBridgeState.inbox[index];
            if (!item) return;

            const ops = item.result?.proposed_ops || [];
            let successCount = 0;
            let errorCount = 0;

            // Save undo state
            saveState('Apply agent operations');

            for (const op of ops) {
                try {
                    switch (op.op) {
                        case 'create_node':
                            const newNode = createNode(op.parentId || 'root', op.data || {});
                            if (newNode) successCount++;
                            break;

                        case 'update_node':
                            const nodeToUpdate = findNodeByIdInbox(op.nodeId);
                            if (nodeToUpdate && op.data) {
                                Object.assign(nodeToUpdate, op.data);
                                successCount++;
                            }
                            break;

                        case 'set_field':
                            const nodeForField = findNodeByIdInbox(op.nodeId);
                            if (nodeForField && op.field) {
                                nodeForField[op.field] = op.value;
                                successCount++;
                            }
                            break;

                        case 'delete_node':
                            if (deleteNodeById(op.nodeId)) {
                                successCount++;
                            }
                            break;

                        default:
                            console.warn('[Inbox] Unknown op:', op.op);
                    }
                } catch (err) {
                    console.error('[Inbox] Op failed:', err);
                    errorCount++;
                }
            }

            // Remove from inbox
            mcpBridgeState.inbox.splice(index, 1);

            // Acknowledge to bridge
            if (mcpBridgeState.client?.acknowledgeTask) {
                mcpBridgeState.client.acknowledgeTask(item.taskId, 'approved');
            }

            // Refresh
            render();
            renderInboxItems();
            updateInboxUI();

            showToast(`Applied ${successCount} operation${successCount !== 1 ? 's' : ''}${errorCount > 0 ? ` (${errorCount} failed)` : ''}`, 'success');
        }
        window.approveInboxItem = approveInboxItem;

        // Build 522: Reject inbox item
        function rejectInboxItem(index) {
            const item = mcpBridgeState.inbox[index];
            if (!item) return;

            // Remove from inbox
            mcpBridgeState.inbox.splice(index, 1);

            // Acknowledge to bridge
            if (mcpBridgeState.client?.acknowledgeTask) {
                mcpBridgeState.client.acknowledgeTask(item.taskId, 'rejected');
            }

            renderInboxItems();
            updateInboxUI();

            showToast('Proposed changes rejected', 'info');
        }
        window.rejectInboxItem = rejectInboxItem;

        // Build 522: Submit task to Claude Code
        function submitAgentTask(prompt, options = {}) {
            if (!mcpBridgeState.client?.isConnected) {
                showToast('Not connected to Claude Code', 'error');
                return false;
            }

            const selectedNode = getSelectedNode();

            try {
                mcpBridgeState.client.submitTask({
                    agentId: options.agentId || 'research',
                    prompt: prompt,
                    targetNodeId: selectedNode?.id,
                    treeContext: {
                        selectedNode: selectedNode ? { id: selectedNode.id, name: selectedNode.name } : null,
                        treeNodeCount: countNodes()
                    },
                    requestedCapabilities: options.capabilities || ['webSearch', 'treeWrite'],
                    options: options
                });
                return true;
            } catch (err) {
                console.error('[Agent] Submit failed:', err);
                showToast('Failed to submit task: ' + err.message, 'error');
                return false;
            }
        }
        window.submitAgentTask = submitAgentTask;

        // BUILD 547: Email Reader Modal Functions
        let emailReaderState = {
            currentThread: null,
            currentMessageIndex: 0,
            messages: []
        };

        function openEmailReaderModal(node) {
            console.log('[Email Reader] openEmailReaderModal called with:', node);
            if (!node) {
                console.log('[Email Reader] No node provided');
                showToast('No node selected', 'warning');
                return;
            }

            // BUILD 553: Check if this is an email node - match condition in info panel (line 26830)
            // Also check description (used as fallback in updateEmailReaderContent)
            const hasEmailData = node.emailBody || node.fullBody || node.threadId || node.description || node.subItems?.length > 0;
            console.log('[Email Reader] hasEmailData:', hasEmailData, {
                emailBody: !!node.emailBody,
                fullBody: !!node.fullBody,
                threadId: !!node.threadId,
                description: !!node.description,
                subItemsLength: node.subItems?.length
            });
            if (!hasEmailData) {
                showToast('No email content to display', 'warning');
                return;
            }

            emailReaderState.currentThread = node;
            // BUILD 553: Use subItems if they exist and have content, otherwise use node itself
            emailReaderState.messages = (node.subItems && node.subItems.length > 0) ? node.subItems : [node];
            emailReaderState.currentMessageIndex = 0;

            updateEmailReaderContent();
            document.getElementById('email-reader-modal').style.display = 'flex';
        }
        window.openEmailReaderModal = openEmailReaderModal;

        function closeEmailReaderModal() {
            document.getElementById('email-reader-modal').style.display = 'none';
            emailReaderState.currentThread = null;
        }
        window.closeEmailReaderModal = closeEmailReaderModal;

        function updateEmailReaderContent() {
            const thread = emailReaderState.currentThread;
            const messages = emailReaderState.messages;
            const idx = emailReaderState.currentMessageIndex;
            const msg = messages[idx];

            if (!thread || !msg) return;

            // BUILD 553: Local escapeHtml helper (main one is defined later in file)
            const escapeHtml = (text) => {
                const div = document.createElement('div');
                div.textContent = text || '';
                return div.innerHTML;
            };

            // Update header
            document.getElementById('email-reader-title').textContent = 'ğŸ“§ ' + (thread.subjectLine || thread.name || 'Email');
            document.getElementById('email-reader-subject').textContent = thread.subjectLine || thread.name || '(No Subject)';

            // Date formatting
            const dateStr = msg.timestamp || msg.dateTime || thread.sendDateTime || thread.sendDate || '';
            let formattedDate = dateStr;
            try {
                if (dateStr) {
                    const d = new Date(dateStr);
                    if (!isNaN(d)) {
                        formattedDate = d.toLocaleDateString('en-US', {
                            month: 'short', day: 'numeric', year: 'numeric',
                            hour: 'numeric', minute: '2-digit'
                        });
                    }
                }
            } catch (e) {}
            document.getElementById('email-reader-date').textContent = formattedDate;

            // Sender/recipient
            document.getElementById('email-reader-from').textContent = msg.sender || thread.senderEmail || 'Unknown';
            document.getElementById('email-reader-to').textContent = msg.recipient || thread.recipientEmail || 'Unknown';

            // CC
            const cc = thread.ccEmail || '';
            const ccRow = document.getElementById('email-reader-cc-row');
            if (cc) {
                document.getElementById('email-reader-cc').textContent = cc;
                ccRow.style.display = 'block';
            } else {
                ccRow.style.display = 'none';
            }

            // Body - prefer HTML if available, fall back to plain text
            // BUILD 549: Apply linkifyText to make URLs clickable
            const bodyEl = document.getElementById('email-reader-body');
            const htmlBody = msg.htmlBody || thread.htmlBody;
            const plainBody = msg.fullBody || msg.description || thread.emailBody || '';

            if (htmlBody && htmlBody !== plainBody) {
                // Render HTML safely (basic sanitization - remove script tags)
                const sanitized = htmlBody
                    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                    .replace(/on\w+\s*=/gi, 'data-disabled-');
                bodyEl.innerHTML = sanitized;
                bodyEl.style.whiteSpace = 'normal';
            } else {
                // Plain text - escape HTML then linkify URLs
                const escaped = escapeHtml(plainBody);
                bodyEl.innerHTML = linkifyText(escaped);
                bodyEl.style.whiteSpace = 'pre-wrap';
            }

            // Attachments
            const attachments = msg.attachments || thread.attachments || [];
            const attachmentsDiv = document.getElementById('email-reader-attachments');
            const attachmentList = document.getElementById('email-reader-attachment-list');

            if (attachments.length > 0) {
                attachmentsDiv.style.display = 'block';
                attachmentList.innerHTML = attachments.map(att => {
                    const sizeStr = att.size > 1024*1024
                        ? (att.size / (1024*1024)).toFixed(1) + ' MB'
                        : att.size > 1024
                            ? Math.round(att.size / 1024) + ' KB'
                            : att.size + ' B';
                    return `<div style="background: var(--bg); border: 1px solid var(--border); border-radius: 6px; padding: 8px 12px; font-size: 12px; display: flex; align-items: center; gap: 6px;">
                        <span>ğŸ“</span>
                        <span>${escapeHtml(att.filename)}</span>
                        <span style="color: var(--text-secondary);">(${sizeStr})</span>
                    </div>`;
                }).join('');
            } else {
                attachmentsDiv.style.display = 'none';
            }

            // Thread navigation
            const threadNav = document.getElementById('email-reader-thread-nav');
            if (messages.length > 1) {
                threadNav.style.display = 'block';
                document.getElementById('email-reader-thread-info').textContent = `Message ${idx + 1} of ${messages.length}`;
                document.getElementById('email-reader-prev').disabled = idx === 0;
                document.getElementById('email-reader-next').disabled = idx === messages.length - 1;
            } else {
                threadNav.style.display = 'none';
            }
        }

        function emailReaderPrev() {
            if (emailReaderState.currentMessageIndex > 0) {
                emailReaderState.currentMessageIndex--;
                updateEmailReaderContent();
            }
        }
        window.emailReaderPrev = emailReaderPrev;

        function emailReaderNext() {
            if (emailReaderState.currentMessageIndex < emailReaderState.messages.length - 1) {
                emailReaderState.currentMessageIndex++;
                updateEmailReaderContent();
            }
        }
        window.emailReaderNext = emailReaderNext;

        function emailReaderOpenInGmail() {
            const thread = emailReaderState.currentThread;
            if (thread?.threadId) {
                // Gmail URL format: https://mail.google.com/mail/u/0/#inbox/threadId
                const gmailUrl = `https://mail.google.com/mail/u/0/#inbox/${thread.threadId}`;
                window.open(gmailUrl, '_blank');
            } else {
                showToast('No thread ID available', 'warning');
            }
        }
        window.emailReaderOpenInGmail = emailReaderOpenInGmail;

        // BUILD 548: Reply via Gmail compose
        function emailReaderReply() {
            const thread = emailReaderState.currentThread;
            const msg = emailReaderState.messages[emailReaderState.currentMessageIndex];

            if (!thread && !msg) {
                showToast('No email to reply to', 'warning');
                return;
            }

            // Get reply-to address (prefer sender of current message, fall back to thread sender)
            const replyTo = msg?.sender || thread?.senderEmail || '';
            const subject = thread?.subjectLine || thread?.name || 'Re: ';

            // Ensure subject has "Re:" prefix
            const replySubject = subject.toLowerCase().startsWith('re:')
                ? subject
                : `Re: ${subject}`;

            // Gmail compose URL with pre-filled fields
            const params = new URLSearchParams({
                view: 'cm',
                fs: '1',
                tf: '1',
                to: replyTo,
                su: replySubject
            });

            const gmailUrl = `https://mail.google.com/mail/?${params.toString()}`;
            window.open(gmailUrl, '_blank');
            showToast('Opening Gmail compose...', 'success');
        }
        window.emailReaderReply = emailReaderReply;

        // BUILD 548: Forward via Gmail compose
        function emailReaderForward() {
            const thread = emailReaderState.currentThread;

            if (!thread) {
                showToast('No email to forward', 'warning');
                return;
            }

            const subject = thread?.subjectLine || thread?.name || 'Fwd: ';

            // Ensure subject has "Fwd:" prefix
            const fwdSubject = subject.toLowerCase().startsWith('fwd:')
                ? subject
                : `Fwd: ${subject}`;

            // Get email body for quote (truncate if too long)
            const body = thread?.emailBody || '';
            const truncatedBody = body.length > 1000 ? body.substring(0, 1000) + '...' : body;
            const forwardBody = `\n\n---------- Forwarded message ----------\nFrom: ${thread?.senderEmail || ''}\nDate: ${thread?.sendDate || ''}\nSubject: ${thread?.subjectLine || ''}\nTo: ${thread?.recipientEmail || ''}\n\n${truncatedBody}`;

            // Gmail compose URL with pre-filled fields
            const params = new URLSearchParams({
                view: 'cm',
                fs: '1',
                tf: '1',
                su: fwdSubject,
                body: forwardBody
            });

            const gmailUrl = `https://mail.google.com/mail/?${params.toString()}`;
            window.open(gmailUrl, '_blank');
            showToast('Opening Gmail forward...', 'success');
        }
        window.emailReaderForward = emailReaderForward;

        // BUILD 549: Reply from Info Panel (node passed directly)
        function emailReaderReplyFromNode(node) {
            if (!node) {
                showToast('No email to reply to', 'warning');
                return;
            }

            const replyTo = node.senderEmail || '';
            const subject = node.subjectLine || node.name || 'Re: ';
            const replySubject = subject.toLowerCase().startsWith('re:') ? subject : `Re: ${subject}`;

            const params = new URLSearchParams({
                view: 'cm',
                fs: '1',
                tf: '1',
                to: replyTo,
                su: replySubject
            });

            const gmailUrl = `https://mail.google.com/mail/?${params.toString()}`;
            window.open(gmailUrl, '_blank');
            showToast('Opening Gmail compose...', 'success');
        }
        window.emailReaderReplyFromNode = emailReaderReplyFromNode;

        // BUILD 549: Forward from Info Panel (node passed directly)
        function emailReaderForwardFromNode(node) {
            if (!node) {
                showToast('No email to forward', 'warning');
                return;
            }

            const subject = node.subjectLine || node.name || 'Fwd: ';
            const fwdSubject = subject.toLowerCase().startsWith('fwd:') ? subject : `Fwd: ${subject}`;

            const body = node.emailBody || node.description || '';
            const truncatedBody = body.length > 1000 ? body.substring(0, 1000) + '...' : body;
            const forwardBody = `\n\n---------- Forwarded message ----------\nFrom: ${node.senderEmail || ''}\nDate: ${node.sendDate || ''}\nSubject: ${node.subjectLine || ''}\nTo: ${node.recipientEmail || ''}\n\n${truncatedBody}`;

            const params = new URLSearchParams({
                view: 'cm',
                fs: '1',
                tf: '1',
                su: fwdSubject,
                body: forwardBody
            });

            const gmailUrl = `https://mail.google.com/mail/?${params.toString()}`;
            window.open(gmailUrl, '_blank');
            showToast('Opening Gmail forward...', 'success');
        }
        window.emailReaderForwardFromNode = emailReaderForwardFromNode;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 550: Gmail Sync Functions (Bidirectional Sync Phase 1)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Pending Gmail actions (for undo functionality)
        const pendingGmailActions = new Map();

        // Action ledger for idempotency (prevent duplicate actions)
        const gmailActionLedger = new Map();

        /**
         * BUILD 553: Local findNodeById helper (main one is defined later in file)
         * Used by Gmail sync functions which are defined earlier than the main findNodeById
         */
        function findNodeByIdLocal(nodeId) {
            function search(node) {
                if (!node) return null;
                if (node.id === nodeId) return node;
                for (const arr of [node.children, node.items, node.subItems]) {
                    if (arr && Array.isArray(arr)) {
                        for (const child of arr) {
                            const found = search(child);
                            if (found) return found;
                        }
                    }
                }
                return null;
            }
            return typeof capexTree !== 'undefined' && capexTree ? search(capexTree) : null;
        }

        /**
         * Check if MCP Bridge is connected
         * BUILD 553: Fix - use 'status' property and check client.socket.readyState
         */
        function isMCPBridgeConnected() {
            return mcpBridgeState?.status === 'connected' &&
                   mcpBridgeState?.client?.socket?.readyState === WebSocket.OPEN;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 561: Tree Type Detection & Refresh Button
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Detect if current tree is Gmail, GDrive, or regular
         * @returns {string} 'gmail' | 'gdrive' | 'local' | null
         */
        function detectTreeType() {
            if (!capexTree || !capexTree.children) return null;

            // Check first few items for type indicators
            let gmailCount = 0;
            let gdriveCount = 0;
            let totalChecked = 0;

            function checkNode(node) {
                if (totalChecked > 20) return; // Sample limit
                totalChecked++;

                // Gmail indicators
                if (node.threadId || node.senderEmail || node.emailBody) {
                    gmailCount++;
                }
                // GDrive indicators
                if (node.fileUrl || node.mimeType || node.driveId || (node.webViewLink && node.webViewLink.includes('drive.google'))) {
                    gdriveCount++;
                }

                // Check children
                const children = node.items || node.children || node.subItems || [];
                children.forEach(child => checkNode(child));
            }

            capexTree.children.forEach(phase => checkNode(phase));

            // Determine tree type based on counts
            if (gmailCount > 3) return 'gmail';
            if (gdriveCount > 3) return 'gdrive';
            if (capexTree.name?.toLowerCase().includes('gmail') || capexTree.name?.toLowerCase().includes('email')) return 'gmail';
            if (capexTree.name?.toLowerCase().includes('drive') || capexTree.name?.toLowerCase().includes('google drive')) return 'gdrive';

            return 'local';
        }

        /**
         * Update the refresh button visibility based on tree type
         */
        function updateTreeRefreshButton() {
            const btn = document.getElementById('tree-refresh-btn');
            const iconEl = document.getElementById('tree-refresh-icon');
            const labelEl = document.getElementById('tree-refresh-label');
            if (!btn) return;

            const treeType = detectTreeType();
            window.currentTreeType = treeType; // Store for refresh action

            if (treeType === 'gmail') {
                btn.style.display = 'flex';
                btn.style.background = 'linear-gradient(135deg, #ea4335, #c5221f)';
                btn.title = 'Refresh Gmail - Run export script to get latest emails';
                if (iconEl) iconEl.textContent = 'ğŸ“§';
                if (labelEl) labelEl.textContent = 'Refresh Gmail';
            } else if (treeType === 'gdrive') {
                btn.style.display = 'flex';
                btn.style.background = 'linear-gradient(135deg, #4285f4, #1a73e8)';
                btn.title = 'Refresh Google Drive - Run export script to get latest files';
                if (iconEl) iconEl.textContent = 'ğŸ“';
                if (labelEl) labelEl.textContent = 'Refresh Drive';
            } else {
                btn.style.display = 'none';
            }
        }

        /**
         * Refresh the current tree (dispatches to appropriate sync command)
         * BUILD 561: Enhanced with status feedback and auto-import
         */
        async function refreshCurrentTree() {
            const treeType = window.currentTreeType || detectTreeType();
            const btn = document.getElementById('tree-refresh-btn');
            const labelEl = document.getElementById('tree-refresh-label');
            const originalLabel = labelEl?.textContent || 'Refresh';

            // Store current thread IDs for diff
            const beforeThreadIds = new Set();
            if (capexTree?.children) {
                const collectThreadIds = (node) => {
                    if (node.threadId) beforeThreadIds.add(node.threadId);
                    (node.items || node.children || node.subItems || []).forEach(collectThreadIds);
                };
                capexTree.children.forEach(collectThreadIds);
            }

            if (treeType === 'gmail') {
                // Check MCP Bridge connection
                if (!isMCPBridgeConnected()) {
                    showToast('MCP Bridge not connected. Run: python export_gmail_to_treelisty.py', 'info');
                    return;
                }

                // Update button to show refreshing status
                if (btn) {
                    btn.disabled = true;
                    btn.style.opacity = '0.7';
                }
                if (labelEl) labelEl.textContent = 'Refreshing...';
                showToast('Refreshing Gmail...', 'info');

                try {
                    // Call gmail_refresh via MCP Bridge
                    const result = await sendGmailAction('gmail_refresh', {
                        max_threads: 100,
                        days_back: 7
                    });

                    if (result?.success && result?.filename) {
                        // Store beforeThreadIds for hyperedge creation after import
                        window._gmailRefreshBeforeIds = beforeThreadIds;
                        window._gmailRefreshFilename = result.filename;

                        const newCount = result.threadCount - beforeThreadIds.size;
                        const newMsg = newCount > 0 ? ` (${newCount} new)` : '';

                        showToast(`Exported ${result.threadCount} threads${newMsg}. Loading...`, 'success');

                        // Create a notification with import instructions
                        const notification = document.createElement('div');
                        notification.style.cssText = 'position: fixed; top: 80px; right: 20px; padding: 16px 20px; background: linear-gradient(135deg, #10b981, #059669); color: white; border-radius: 12px; z-index: 10000; max-width: 350px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);';
                        notification.innerHTML = `
                            <div style="font-weight: 600; margin-bottom: 8px;">Gmail Refresh Complete${newMsg}</div>
                            <div style="font-size: 13px; margin-bottom: 12px;">Exported ${result.threadCount} threads to:<br><code style="background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 4px;">${result.filename}</code></div>
                            <div style="display: flex; gap: 8px;">
                                <button onclick="document.getElementById('load-json-input')?.click(); this.parentElement.parentElement.remove();" style="padding: 8px 14px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; color: white; cursor: pointer; font-size: 12px; font-weight: 500;">Import File</button>
                                <button onclick="this.parentElement.parentElement.remove();" style="padding: 8px 14px; background: transparent; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: rgba(255,255,255,0.8); cursor: pointer; font-size: 12px;">Dismiss</button>
                            </div>
                        `;
                        document.body.appendChild(notification);
                        setTimeout(() => notification.remove(), 30000);

                    } else {
                        showToast(result?.message || 'Refresh failed', 'error');
                    }
                } catch (err) {
                    showToast(`Refresh error: ${err.message}`, 'error');
                } finally {
                    // Reset button
                    if (btn) {
                        btn.disabled = false;
                        btn.style.opacity = '1';
                    }
                    if (labelEl) labelEl.textContent = originalLabel;
                }

            } else if (treeType === 'gdrive') {
                // Execute sync_drive command
                if (typeof COMMAND_REGISTRY !== 'undefined' && COMMAND_REGISTRY['sync_drive']) {
                    COMMAND_REGISTRY['sync_drive']().then(result => {
                        if (result?.message) {
                            showToast(result.message.replace(/\*\*/g, '').substring(0, 100), 'info');
                        }
                    });
                } else {
                    showToast('Run: python export_google_drive_to_treelisty.py', 'info');
                }
            } else {
                showToast('This tree has no external refresh source', 'info');
            }
        }

        /**
         * Send Gmail action to MCP Bridge
         */
        async function sendGmailAction(toolName, params) {
            if (!isMCPBridgeConnected()) {
                showToast('MCP Bridge not connected. Start bridge and reconnect.', 'error');
                return { success: false, error: 'not_connected' };
            }

            return new Promise((resolve) => {
                const requestId = `gmail-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

                // Store resolver for this request
                if (!window.pendingMCPRequests) window.pendingMCPRequests = new Map();
                window.pendingMCPRequests.set(requestId, resolve);

                // BUILD 557: Add debug logging for Gmail requests
                const request = {
                    jsonrpc: '2.0',
                    id: requestId,
                    method: toolName,
                    params: params
                };
                console.log('[Gmail] Sending request:', toolName, requestId);

                // Send request - BUILD 555: Use client.socket (client is TreeListyMCPClient)
                mcpBridgeState.client.socket.send(JSON.stringify(request));

                // Timeout after 30 seconds
                setTimeout(() => {
                    if (window.pendingMCPRequests.has(requestId)) {
                        console.log('[Gmail] Request timed out:', requestId);
                        window.pendingMCPRequests.delete(requestId);
                        resolve({ success: false, error: 'timeout' });
                    }
                }, 30000);
            });
        }

        /**
         * Send extension request to MCP Bridge (Build 564)
         * Routes to Chrome extension via bridge WebSocket
         */
        async function sendExtensionRequest(action, params = {}) {
            if (!isMCPBridgeConnected()) {
                return { connected: false, error: 'not_connected' };
            }

            return new Promise((resolve) => {
                const requestId = `ext-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

                // Store resolver for this request
                if (!window.pendingExtensionRequests) window.pendingExtensionRequests = new Map();
                window.pendingExtensionRequests.set(requestId, resolve);

                const request = {
                    type: 'extension_request',
                    id: requestId,
                    action: action,
                    params: params
                };
                console.log('[Extension] Sending request:', action, requestId);

                mcpBridgeState.client.socket.send(JSON.stringify(request));

                // Timeout after 15 seconds
                setTimeout(() => {
                    if (window.pendingExtensionRequests.has(requestId)) {
                        console.log('[Extension] Request timed out:', requestId);
                        window.pendingExtensionRequests.delete(requestId);
                        resolve({ success: false, error: 'timeout' });
                    }
                }, 15000);
            });
        }

        /**
         * Display screenshot in TreeBeard chat (Build 564)
         * User sees image before any AI processing
         */
        function displayScreenshotInChat(dataUrl, provenance = {}) {
            const chatOutput = document.getElementById('chat-assistant-output');
            if (!chatOutput) return;

            const container = document.createElement('div');
            container.className = 'chat-message system screenshot-message';
            container.style.cssText = `
                margin: 12px 0;
                padding: 12px;
                background: rgba(139, 92, 246, 0.05);
                border: 1px solid rgba(139, 92, 246, 0.2);
                border-radius: 12px;
            `;

            const header = document.createElement('div');
            header.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
                font-size: 12px;
                color: var(--text-secondary, #888);
            `;
            header.innerHTML = `
                <span>ğŸ“· ${provenance.domain || 'Screenshot'}</span>
                <span>${provenance.capturedAt ? new Date(provenance.capturedAt).toLocaleTimeString() : ''}</span>
            `;
            container.appendChild(header);

            const img = document.createElement('img');
            img.src = dataUrl;
            img.alt = `Screenshot of ${provenance.tabTitle || 'browser tab'}`;
            img.style.cssText = `
                max-width: 100%;
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                cursor: pointer;
            `;
            img.onclick = () => {
                // Open in new tab for full view
                const win = window.open();
                win.document.write(`<img src="${dataUrl}" style="max-width:100%">`);
            };
            container.appendChild(img);

            if (provenance.dimensions) {
                const dims = document.createElement('div');
                dims.style.cssText = `
                    font-size: 11px;
                    color: var(--text-secondary, #666);
                    margin-top: 6px;
                `;
                dims.textContent = `${provenance.dimensions.width}Ã—${provenance.dimensions.height}px`;
                container.appendChild(dims);
            }

            chatOutput.appendChild(container);
            chatOutput.scrollTop = chatOutput.scrollHeight;
        }

        /**
         * Analyze screenshot with vision AI (Build 564)
         * Sends the captured screenshot to the AI for analysis
         */
        async function analyzeScreenshotWithVision(captureResult) {
            if (!captureResult?.screenshot) {
                addMessage('âŒ No screenshot available to analyze', 'system');
                return;
            }

            addMessage('ğŸ” Analyzing screenshot with vision...', 'system');

            try {
                // Get current AI provider
                const provider = document.getElementById('ai-provider-select')?.value || 'claude';

                // Build the vision prompt
                const prompt = "Please analyze this screenshot and describe what you see. Focus on the main content, layout, and any notable elements.";

                // For Claude, use the image in the message
                if (provider === 'claude') {
                    const response = await callClaudeWithVision(prompt, captureResult.screenshot);
                    addMessage(response, 'assistant');
                } else {
                    // For other providers, describe what we captured
                    addMessage(`ğŸ“· Screenshot captured from **${captureResult.provenance?.domain}**\n\n` +
                        `Title: ${captureResult.provenance?.tabTitle || 'Unknown'}\n` +
                        `Size: ${captureResult.provenance?.dimensions?.width}Ã—${captureResult.provenance?.dimensions?.height}px\n\n` +
                        `_Vision analysis requires Claude as the AI provider._`, 'assistant');
                }
            } catch (err) {
                console.error('[Vision] Analysis error:', err);
                addMessage(`âŒ Vision analysis failed: ${err.message}`, 'system');
            }
        }

        /**
         * Call Claude API with vision (image analysis)
         */
        async function callClaudeWithVision(prompt, imageDataUrl) {
            const apiKey = window.CLAUDE_API_KEY || localStorage.getItem('claude_api_key');
            if (!apiKey) {
                throw new Error('Claude API key not configured');
            }

            // Extract base64 and media type from data URL
            const matches = imageDataUrl.match(/^data:([^;]+);base64,(.+)$/);
            if (!matches) {
                throw new Error('Invalid image data format');
            }
            const mediaType = matches[1];
            const base64Data = matches[2];

            const response = await fetch('/.netlify/functions/claude-proxy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 1024,
                    messages: [{
                        role: 'user',
                        content: [
                            {
                                type: 'image',
                                source: {
                                    type: 'base64',
                                    media_type: mediaType,
                                    data: base64Data
                                }
                            },
                            {
                                type: 'text',
                                text: prompt
                            }
                        ]
                    }]
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`API error: ${error}`);
            }

            const data = await response.json();
            return data.content?.[0]?.text || 'No response from vision analysis';
        }

        /**
         * Show undo toast with countdown
         */
        function showUndoToast(action, threadId, nodeId, undoCallback, duration = 10000) {
            const toastId = `undo-${threadId}`;

            // Create toast element
            const toast = document.createElement('div');
            toast.id = toastId;
            toast.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #1e1e2e, #2d2d3d);
                border: 1px solid rgba(139, 92, 246, 0.3);
                border-radius: 12px;
                padding: 12px 20px;
                display: flex;
                align-items: center;
                gap: 16px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.4);
                z-index: 10000;
                font-family: inherit;
            `;

            const startTime = Date.now();

            toast.innerHTML = `
                <span style="color: white; font-size: 14px;">${action}</span>
                <div style="width: 80px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
                    <div id="${toastId}-progress" style="width: 100%; height: 100%; background: #8b5cf6; transition: width 0.1s linear;"></div>
                </div>
                <span id="${toastId}-countdown" style="color: var(--text-secondary); font-size: 12px; min-width: 20px;">10s</span>
                <button onclick="cancelGmailAction('${threadId}')" style="padding: 6px 12px; background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444; border-radius: 6px; color: #ef4444; cursor: pointer; font-size: 12px; font-weight: 500;">
                    Undo
                </button>
                <button onclick="document.getElementById('${toastId}')?.remove()" style="background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 16px; padding: 4px;">Ã—</button>
            `;

            document.body.appendChild(toast);

            // Update countdown
            const progressBar = document.getElementById(`${toastId}-progress`);
            const countdown = document.getElementById(`${toastId}-countdown`);

            const updateInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, duration - elapsed);
                const percent = (remaining / duration) * 100;

                if (progressBar) progressBar.style.width = `${percent}%`;
                if (countdown) countdown.textContent = `${Math.ceil(remaining / 1000)}s`;

                if (remaining <= 0) {
                    clearInterval(updateInterval);
                    toast.remove();
                }
            }, 100);

            // Store for cancellation
            pendingGmailActions.set(threadId, {
                toastId,
                updateInterval,
                undoCallback,
                toast
            });
        }

        /**
         * Cancel a pending Gmail action (undo)
         */
        function cancelGmailAction(threadId) {
            const pending = pendingGmailActions.get(threadId);
            if (pending) {
                clearInterval(pending.updateInterval);
                pending.toast?.remove();
                pending.undoCallback?.();
                pendingGmailActions.delete(threadId);
                showToast('Action cancelled', 'info');
            }
        }
        window.cancelGmailAction = cancelGmailAction;

        /**
         * Execute Gmail action after undo window expires
         */
        async function executeGmailAction(toolName, params, threadId) {
            // Check idempotency - don't repeat same action within 60 seconds
            const dedupeKey = `${toolName}-${threadId}-${Math.floor(Date.now() / 60000)}`;
            if (gmailActionLedger.has(dedupeKey)) {
                console.log('[Gmail] Skipping duplicate action:', dedupeKey);
                return { success: true, message: 'Already executed' };
            }

            const result = await sendGmailAction(toolName, params);

            if (result.success) {
                // Record in ledger
                gmailActionLedger.set(dedupeKey, {
                    timestamp: Date.now(),
                    result: 'success'
                });

                // Clean old ledger entries (keep last 100)
                if (gmailActionLedger.size > 100) {
                    const oldest = [...gmailActionLedger.keys()][0];
                    gmailActionLedger.delete(oldest);
                }
            }

            return result;
        }

        /**
         * Gmail Sync: Archive thread
         */
        function gmailSyncArchive(threadId, nodeId, buttonEl) {
            if (!threadId) {
                showToast('No thread ID', 'warning');
                return;
            }

            // BUILD 553: Button feedback
            const originalText = buttonEl?.textContent;
            if (buttonEl) {
                buttonEl.textContent = 'â³ Queued...';
                buttonEl.disabled = true;
                buttonEl.style.opacity = '0.7';
            }

            // Optimistic UI - ghost the node
            const node = findNodeByIdLocal(nodeId);
            if (node) {
                node._gmailSyncPending = 'archive';
                render();
            }

            // Show undo toast
            showUndoToast('Archived email', threadId, nodeId, () => {
                // Undo callback - restore node and button
                if (node) {
                    delete node._gmailSyncPending;
                    render();
                }
                if (buttonEl) {
                    buttonEl.textContent = originalText;
                    buttonEl.disabled = false;
                    buttonEl.style.opacity = '1';
                }
            });

            // Execute after delay
            setTimeout(async () => {
                if (!pendingGmailActions.has(threadId)) return; // Was cancelled

                pendingGmailActions.delete(threadId);

                const result = await executeGmailAction('gmail_archive', { thread_id: threadId }, threadId);

                if (result.success) {
                    if (node) {
                        node._gmailSynced = 'archived';
                        delete node._gmailSyncPending;
                    }
                    showToast('Archived in Gmail', 'success');
                } else {
                    if (node) delete node._gmailSyncPending;
                    showToast(`Archive failed: ${result.error || result.message}`, 'error');
                }
                render();
            }, 10000);
        }
        window.gmailSyncArchive = gmailSyncArchive;

        /**
         * Gmail Sync: Trash thread
         */
        function gmailSyncTrash(threadId, nodeId, buttonEl) {
            if (!threadId) {
                showToast('No thread ID', 'warning');
                return;
            }

            // BUILD 553: Button feedback
            const originalText = buttonEl?.textContent;
            if (buttonEl) {
                buttonEl.textContent = 'â³ Queued...';
                buttonEl.disabled = true;
                buttonEl.style.opacity = '0.7';
            }

            const node = findNodeByIdLocal(nodeId);
            if (node) {
                node._gmailSyncPending = 'trash';
                render();
            }

            showUndoToast('Moved to trash', threadId, nodeId, () => {
                if (node) {
                    delete node._gmailSyncPending;
                    render();
                }
                if (buttonEl) {
                    buttonEl.textContent = originalText;
                    buttonEl.disabled = false;
                    buttonEl.style.opacity = '1';
                }
            });

            setTimeout(async () => {
                if (!pendingGmailActions.has(threadId)) return;

                pendingGmailActions.delete(threadId);

                const result = await executeGmailAction('gmail_trash', { thread_id: threadId }, threadId);

                if (result.success) {
                    if (node) {
                        node._gmailSynced = 'trashed';
                        delete node._gmailSyncPending;
                    }
                    showToast('Moved to Gmail trash', 'success');
                } else {
                    if (node) delete node._gmailSyncPending;
                    showToast(`Trash failed: ${result.error || result.message}`, 'error');
                }
                render();
            }, 10000);
        }
        window.gmailSyncTrash = gmailSyncTrash;

        /**
         * Gmail Sync: Star thread
         */
        function gmailSyncStar(threadId, nodeId, buttonEl) {
            if (!threadId) {
                showToast('No thread ID', 'warning');
                return;
            }

            // BUILD 553: Button feedback
            const originalText = buttonEl?.textContent;
            if (buttonEl) {
                buttonEl.textContent = 'â³ Queued...';
                buttonEl.disabled = true;
                buttonEl.style.opacity = '0.7';
            }

            const node = findNodeByIdLocal(nodeId);
            if (node) {
                node._gmailSyncPending = 'star';
                render();
            }

            showUndoToast('Starred email', threadId, nodeId, () => {
                if (node) {
                    delete node._gmailSyncPending;
                    render();
                }
                if (buttonEl) {
                    buttonEl.textContent = originalText;
                    buttonEl.disabled = false;
                    buttonEl.style.opacity = '1';
                }
            });

            setTimeout(async () => {
                if (!pendingGmailActions.has(threadId)) return;

                pendingGmailActions.delete(threadId);

                const result = await executeGmailAction('gmail_star', { thread_id: threadId, starred: true }, threadId);

                if (result.success) {
                    if (node) {
                        node._gmailSynced = 'starred';
                        node.icon = 'â­';
                        delete node._gmailSyncPending;
                    }
                    showToast('Starred in Gmail', 'success');
                } else {
                    if (node) delete node._gmailSyncPending;
                    showToast(`Star failed: ${result.error || result.message}`, 'error');
                }
                render();
            }, 10000);
        }
        window.gmailSyncStar = gmailSyncStar;

        /**
         * Gmail Sync: Mark as read
         */
        function gmailSyncMarkRead(threadId, nodeId, buttonEl) {
            if (!threadId) {
                showToast('No thread ID', 'warning');
                return;
            }

            // BUILD 553: Button feedback
            const originalText = buttonEl?.textContent;
            if (buttonEl) {
                buttonEl.textContent = 'â³ Queued...';
                buttonEl.disabled = true;
                buttonEl.style.opacity = '0.7';
            }

            const node = findNodeByIdLocal(nodeId);
            if (node) {
                node._gmailSyncPending = 'mark_read';
                render();
            }

            showUndoToast('Marked as read', threadId, nodeId, () => {
                if (node) {
                    delete node._gmailSyncPending;
                    render();
                }
                if (buttonEl) {
                    buttonEl.textContent = originalText;
                    buttonEl.disabled = false;
                    buttonEl.style.opacity = '1';
                }
            });

            setTimeout(async () => {
                if (!pendingGmailActions.has(threadId)) return;

                pendingGmailActions.delete(threadId);

                const result = await executeGmailAction('gmail_mark_read', { thread_id: threadId, read: true }, threadId);

                if (result.success) {
                    if (node) {
                        node._gmailSynced = 'read';
                        delete node._gmailSyncPending;
                    }
                    showToast('Marked as read in Gmail', 'success');
                } else {
                    if (node) delete node._gmailSyncPending;
                    showToast(`Mark read failed: ${result.error || result.message}`, 'error');
                }
                render();
            }, 10000);
        }
        window.gmailSyncMarkRead = gmailSyncMarkRead;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 551: Draft Composition (Gmail Bidirectional Sync Phase 2)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // IndexedDB for draft storage
        const DRAFT_DB_NAME = 'TreeListyDrafts';
        const DRAFT_DB_VERSION = 1;
        const DRAFT_STORE_NAME = 'drafts';
        let draftDB = null;

        // Auto-save debounce timers
        const draftAutoSaveTimers = new Map();
        const DRAFT_AUTO_SAVE_DELAY = 2000; // 2 seconds

        // Pending conflict resolution
        let pendingConflictResolution = null;

        /**
         * Initialize IndexedDB for draft storage
         */
        async function initDraftDB() {
            return new Promise((resolve, reject) => {
                if (draftDB) {
                    resolve(draftDB);
                    return;
                }

                const request = indexedDB.open(DRAFT_DB_NAME, DRAFT_DB_VERSION);

                request.onerror = () => {
                    console.warn('[Drafts] IndexedDB not available, using localStorage fallback');
                    resolve(null);
                };

                request.onsuccess = (event) => {
                    draftDB = event.target.result;
                    console.log('[Drafts] IndexedDB initialized');
                    resolve(draftDB);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(DRAFT_STORE_NAME)) {
                        const store = db.createObjectStore(DRAFT_STORE_NAME, { keyPath: 'id' });
                        store.createIndex('threadId', 'threadId', { unique: false });
                        store.createIndex('nodeId', 'nodeId', { unique: false });
                        store.createIndex('lastModified', 'lastModified', { unique: false });
                    }
                };
            });
        }

        /**
         * Save draft to IndexedDB (or localStorage fallback)
         */
        async function saveDraftLocal(draft) {
            await initDraftDB();

            const draftData = {
                id: draft.nodeId || `draft-${Date.now()}`,
                nodeId: draft.nodeId,
                threadId: draft.threadId,
                to: draft.to || '',
                cc: draft.cc || '',
                bcc: draft.bcc || '',
                subject: draft.subject || '',
                body: draft.body || '',
                gmailDraftId: draft.gmailDraftId || null,
                historyId: draft.historyId || null,
                syncStatus: draft.syncStatus || 'local',
                lastModified: Date.now(),
                lastFetched: draft.lastFetched || null
            };

            if (draftDB) {
                return new Promise((resolve, reject) => {
                    const tx = draftDB.transaction(DRAFT_STORE_NAME, 'readwrite');
                    const store = tx.objectStore(DRAFT_STORE_NAME);
                    const request = store.put(draftData);
                    request.onsuccess = () => resolve(draftData);
                    request.onerror = () => reject(request.error);
                });
            } else {
                // localStorage fallback
                try {
                    const drafts = JSON.parse(localStorage.getItem('treelisty_drafts') || '{}');
                    drafts[draftData.id] = draftData;
                    localStorage.setItem('treelisty_drafts', JSON.stringify(drafts));
                    return draftData;
                } catch (e) {
                    console.error('[Drafts] Failed to save to localStorage:', e);
                    return null;
                }
            }
        }

        /**
         * Get draft from IndexedDB (or localStorage fallback)
         */
        async function getDraftLocal(nodeId) {
            await initDraftDB();

            if (draftDB) {
                return new Promise((resolve) => {
                    const tx = draftDB.transaction(DRAFT_STORE_NAME, 'readonly');
                    const store = tx.objectStore(DRAFT_STORE_NAME);
                    const request = store.get(nodeId);
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => resolve(null);
                });
            } else {
                try {
                    const drafts = JSON.parse(localStorage.getItem('treelisty_drafts') || '{}');
                    return drafts[nodeId] || null;
                } catch (e) {
                    return null;
                }
            }
        }

        /**
         * Delete draft from IndexedDB (or localStorage fallback)
         */
        async function deleteDraftLocal(nodeId) {
            await initDraftDB();

            if (draftDB) {
                return new Promise((resolve) => {
                    const tx = draftDB.transaction(DRAFT_STORE_NAME, 'readwrite');
                    const store = tx.objectStore(DRAFT_STORE_NAME);
                    const request = store.delete(nodeId);
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => resolve(false);
                });
            } else {
                try {
                    const drafts = JSON.parse(localStorage.getItem('treelisty_drafts') || '{}');
                    delete drafts[nodeId];
                    localStorage.setItem('treelisty_drafts', JSON.stringify(drafts));
                    return true;
                } catch (e) {
                    return false;
                }
            }
        }

        /**
         * Auto-save draft from Quick Reply box (debounced)
         */
        function draftAutoSave(nodeId, threadId, body) {
            // Clear existing timer
            if (draftAutoSaveTimers.has(nodeId)) {
                clearTimeout(draftAutoSaveTimers.get(nodeId));
            }

            // Update draft status indicator
            const statusEl = document.getElementById(`draft-status-${nodeId}`);
            if (statusEl) {
                statusEl.textContent = 'saving...';
                statusEl.style.background = 'rgba(245, 158, 11, 0.3)';
            }

            // Debounced save
            const timer = setTimeout(async () => {
                const node = findNodeByIdLocal(nodeId);
                const draft = {
                    nodeId,
                    threadId,
                    body,
                    to: node?.senderEmail || '',
                    subject: node?.name ? `Re: ${node.name}` : 'Re: '
                };

                await saveDraftLocal(draft);

                if (statusEl) {
                    statusEl.textContent = 'local';
                    statusEl.style.background = 'rgba(100,100,100,0.3)';
                }

                draftAutoSaveTimers.delete(nodeId);
            }, DRAFT_AUTO_SAVE_DELAY);

            draftAutoSaveTimers.set(nodeId, timer);
        }
        window.draftAutoSave = draftAutoSave;

        /**
         * Open compose modal with node context
         */
        async function openComposeModal(nodeId, threadId) {
            const node = findNodeByIdLocal(nodeId);
            if (!node) {
                showToast('Node not found', 'error');
                return;
            }

            // Get existing draft
            const existingDraft = await getDraftLocal(nodeId);

            // Populate modal fields
            document.getElementById('compose-node-id').value = nodeId;
            document.getElementById('compose-thread-id').value = threadId;
            document.getElementById('compose-draft-id').value = existingDraft?.gmailDraftId || '';
            document.getElementById('compose-history-id').value = existingDraft?.historyId || '';

            document.getElementById('compose-to').value = existingDraft?.to || node.senderEmail || '';
            document.getElementById('compose-cc').value = existingDraft?.cc || '';
            document.getElementById('compose-bcc').value = existingDraft?.bcc || '';
            document.getElementById('compose-subject').value = existingDraft?.subject || (node.name ? `Re: ${node.name}` : 'Re: ');

            // Get body from existing draft or quick reply
            const quickReplyEl = document.getElementById(`quick-reply-${nodeId}`);
            document.getElementById('compose-body').value = existingDraft?.body || quickReplyEl?.value || '';

            // Update title
            document.getElementById('compose-modal-title').textContent = existingDraft?.gmailDraftId
                ? 'âœï¸ Edit Draft'
                : 'âœï¸ Compose Reply';

            // Update status
            updateComposeStatus(existingDraft?.syncStatus || 'local');

            // Show modal
            document.getElementById('compose-modal').style.display = 'flex';
        }
        window.openComposeModal = openComposeModal;

        /**
         * Close compose modal
         */
        function closeComposeModal() {
            document.getElementById('compose-modal').style.display = 'none';
        }
        window.closeComposeModal = closeComposeModal;

        /**
         * Auto-save from compose modal (debounced)
         */
        let composeAutoSaveTimer = null;
        function composeAutoSave() {
            if (composeAutoSaveTimer) clearTimeout(composeAutoSaveTimer);

            updateComposeStatus('saving');

            composeAutoSaveTimer = setTimeout(async () => {
                const nodeId = document.getElementById('compose-node-id').value;
                const draft = {
                    nodeId,
                    threadId: document.getElementById('compose-thread-id').value,
                    to: document.getElementById('compose-to').value,
                    cc: document.getElementById('compose-cc').value,
                    bcc: document.getElementById('compose-bcc').value,
                    subject: document.getElementById('compose-subject').value,
                    body: document.getElementById('compose-body').value,
                    gmailDraftId: document.getElementById('compose-draft-id').value || null,
                    historyId: document.getElementById('compose-history-id').value || null
                };

                await saveDraftLocal(draft);
                updateComposeStatus('local');
            }, DRAFT_AUTO_SAVE_DELAY);
        }
        window.composeAutoSave = composeAutoSave;

        /**
         * Update compose modal status indicator
         */
        function updateComposeStatus(status) {
            const iconEl = document.getElementById('compose-status-icon');
            const textEl = document.getElementById('compose-status-text');

            switch (status) {
                case 'saving':
                    iconEl.textContent = 'â³';
                    textEl.textContent = 'Saving...';
                    break;
                case 'local':
                    iconEl.textContent = 'ğŸ’¾';
                    textEl.textContent = 'Local draft (auto-saved)';
                    break;
                case 'synced':
                    iconEl.textContent = 'â˜ï¸';
                    textEl.textContent = 'Synced to Gmail';
                    break;
                case 'syncing':
                    iconEl.textContent = 'ğŸ”„';
                    textEl.textContent = 'Syncing to Gmail...';
                    break;
                case 'error':
                    iconEl.textContent = 'âš ï¸';
                    textEl.textContent = 'Sync failed';
                    break;
            }
        }

        /**
         * Save draft to Gmail from Info Panel
         * BUILD 558: Add button feedback for better UX
         */
        async function saveDraftToGmail(nodeId, threadId, buttonEl) {
            if (!isMCPBridgeConnected()) {
                showToast('MCP Bridge not connected', 'error');
                return;
            }

            const quickReplyEl = document.getElementById(`quick-reply-${nodeId}`);
            const body = quickReplyEl?.value?.trim();

            if (!body) {
                showToast('Please enter a message', 'warning');
                return;
            }

            // BUILD 558: Button feedback
            const originalText = buttonEl?.textContent;
            if (buttonEl) {
                buttonEl.textContent = 'â³ Saving...';
                buttonEl.disabled = true;
                buttonEl.style.opacity = '0.7';
            }

            const node = findNodeByIdLocal(nodeId);
            const draft = {
                nodeId,
                threadId,
                to: node?.senderEmail || '',
                subject: node?.name ? `Re: ${node.name}` : 'Re: ',
                body
            };

            try {
                // Check for existing draft with conflict detection
                const localDraft = await getDraftLocal(nodeId);
                if (localDraft?.gmailDraftId) {
                    await checkAndSaveDraftWithConflictDetection(localDraft, draft);
                } else {
                    await createNewGmailDraft(draft);
                }
            } finally {
                // Restore button state
                if (buttonEl) {
                    buttonEl.textContent = originalText || 'Save to Gmail';
                    buttonEl.disabled = false;
                    buttonEl.style.opacity = '1';
                }
            }
        }
        window.saveDraftToGmail = saveDraftToGmail;

        /**
         * Save draft to Gmail from compose modal
         */
        async function saveDraftToGmailFromModal() {
            if (!isMCPBridgeConnected()) {
                showToast('MCP Bridge not connected', 'error');
                return;
            }

            const nodeId = document.getElementById('compose-node-id').value;
            const draft = {
                nodeId,
                threadId: document.getElementById('compose-thread-id').value,
                to: document.getElementById('compose-to').value,
                cc: document.getElementById('compose-cc').value,
                bcc: document.getElementById('compose-bcc').value,
                subject: document.getElementById('compose-subject').value,
                body: document.getElementById('compose-body').value,
                gmailDraftId: document.getElementById('compose-draft-id').value || null,
                historyId: document.getElementById('compose-history-id').value || null
            };

            if (!draft.to || !draft.body) {
                showToast('Please fill in recipient and message', 'warning');
                return;
            }

            updateComposeStatus('syncing');

            if (draft.gmailDraftId) {
                await checkAndSaveDraftWithConflictDetection(draft, draft);
            } else {
                await createNewGmailDraft(draft);
            }
        }
        window.saveDraftToGmailFromModal = saveDraftToGmailFromModal;

        /**
         * Create new Gmail draft via MCP Bridge
         */
        async function createNewGmailDraft(draft) {
            const result = await sendGmailAction('gmail_create_draft', {
                thread_id: draft.threadId,
                to: draft.to,
                subject: draft.subject,
                body: draft.body,
                cc: draft.cc || undefined,
                bcc: draft.bcc || undefined
            });

            if (result.success && result.draftId) {
                // Update local draft with Gmail draft ID
                draft.gmailDraftId = result.draftId;
                draft.syncStatus = 'synced';
                draft.lastFetched = Date.now();
                await saveDraftLocal(draft);

                // Update modal if open
                document.getElementById('compose-draft-id').value = result.draftId;
                updateComposeStatus('synced');

                // Update Info Panel status
                const statusEl = document.getElementById(`draft-status-${draft.nodeId}`);
                if (statusEl) {
                    statusEl.textContent = 'synced';
                    statusEl.style.background = 'rgba(16, 185, 129, 0.3)';
                }

                showToast('Draft saved to Gmail', 'success');
            } else {
                updateComposeStatus('error');
                showToast(result.error || 'Failed to save draft', 'error');
            }
        }

        /**
         * Check for conflicts and update existing Gmail draft
         */
        async function checkAndSaveDraftWithConflictDetection(existingDraft, newDraft) {
            // Fetch current draft from Gmail
            const remoteResult = await sendGmailAction('gmail_get_draft', {
                draft_id: existingDraft.gmailDraftId
            });

            if (!remoteResult.success) {
                // Draft may have been deleted/sent - create new
                if (remoteResult.error?.includes('not found')) {
                    showToast('Previous draft was sent/deleted. Creating new draft...', 'info');
                    newDraft.gmailDraftId = null;
                    await createNewGmailDraft(newDraft);
                } else {
                    updateComposeStatus('error');
                    showToast(remoteResult.error || 'Failed to check draft', 'error');
                }
                return;
            }

            // Check for conflict (historyId changed)
            if (existingDraft.historyId && remoteResult.historyId !== existingDraft.historyId) {
                // Conflict detected - show resolution modal
                pendingConflictResolution = { existingDraft, newDraft, remoteDraft: remoteResult };
                document.getElementById('conflict-gmail-preview').textContent = remoteResult.body?.substring(0, 300) || '(empty)';
                document.getElementById('conflict-local-preview').textContent = newDraft.body?.substring(0, 300) || '(empty)';
                document.getElementById('draft-conflict-modal').style.display = 'flex';
                return;
            }

            // No conflict - update draft
            await updateExistingGmailDraft(newDraft);
        }

        /**
         * Update existing Gmail draft
         */
        async function updateExistingGmailDraft(draft) {
            const result = await sendGmailAction('gmail_update_draft', {
                draft_id: draft.gmailDraftId,
                to: draft.to,
                subject: draft.subject,
                body: draft.body,
                cc: draft.cc || undefined,
                bcc: draft.bcc || undefined
            });

            if (result.success) {
                draft.syncStatus = 'synced';
                draft.lastFetched = Date.now();
                await saveDraftLocal(draft);

                updateComposeStatus('synced');

                const statusEl = document.getElementById(`draft-status-${draft.nodeId}`);
                if (statusEl) {
                    statusEl.textContent = 'synced';
                    statusEl.style.background = 'rgba(16, 185, 129, 0.3)';
                }

                showToast('Draft updated in Gmail', 'success');
            } else {
                updateComposeStatus('error');
                showToast(result.error || 'Failed to update draft', 'error');
            }
        }

        /**
         * Resolve draft conflict
         */
        async function resolveConflict(choice) {
            if (!pendingConflictResolution) return;

            const { existingDraft, newDraft, remoteDraft } = pendingConflictResolution;

            closeDraftConflictModal();

            if (choice === 'discard') {
                // Keep Gmail version - update local with remote content
                const updated = {
                    ...existingDraft,
                    body: remoteDraft.body,
                    to: remoteDraft.to,
                    subject: remoteDraft.subject,
                    cc: remoteDraft.cc,
                    bcc: remoteDraft.bcc,
                    historyId: remoteDraft.historyId,
                    lastFetched: Date.now()
                };
                await saveDraftLocal(updated);

                // Update modal if open
                document.getElementById('compose-body').value = remoteDraft.body || '';
                document.getElementById('compose-to').value = remoteDraft.to || '';
                document.getElementById('compose-subject').value = remoteDraft.subject || '';
                updateComposeStatus('synced');

                showToast('Reverted to Gmail version', 'info');
            } else if (choice === 'overwrite') {
                // Keep local version - force update to Gmail
                newDraft.historyId = remoteDraft.historyId; // Update historyId to prevent loop
                await updateExistingGmailDraft(newDraft);
            }

            pendingConflictResolution = null;
        }
        window.resolveConflict = resolveConflict;

        /**
         * Close draft conflict modal
         */
        function closeDraftConflictModal() {
            document.getElementById('draft-conflict-modal').style.display = 'none';
        }
        window.closeDraftConflictModal = closeDraftConflictModal;

        /**
         * Discard draft
         */
        async function discardDraft() {
            const nodeId = document.getElementById('compose-node-id').value;
            const gmailDraftId = document.getElementById('compose-draft-id').value;

            // Confirm
            if (!confirm('Discard this draft? This cannot be undone.')) return;

            // Delete from Gmail if synced
            if (gmailDraftId && isMCPBridgeConnected()) {
                await sendGmailAction('gmail_delete_draft', { draft_id: gmailDraftId });
            }

            // Delete local
            await deleteDraftLocal(nodeId);

            // Clear quick reply
            const quickReplyEl = document.getElementById(`quick-reply-${nodeId}`);
            if (quickReplyEl) quickReplyEl.value = '';

            // Update status
            const statusEl = document.getElementById(`draft-status-${nodeId}`);
            if (statusEl) {
                statusEl.textContent = 'local';
                statusEl.style.background = 'rgba(100,100,100,0.3)';
            }

            closeComposeModal();
            showToast('Draft discarded', 'info');
        }
        window.discardDraft = discardDraft;

        // Initialize IndexedDB on load
        initDraftDB();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 552: Batch Gmail Operations + Send (Phase 3)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Rate limiting queue for batch operations
        const gmailRateLimitQueue = {
            queue: [],
            processing: false,
            concurrency: 2,
            baseDelay: 500,
            maxDelay: 5000,
            currentDelay: 500,
            consecutiveErrors: 0
        };

        /**
         * Show batch preview modal
         */
        function showBatchPreviewModal(action, emails) {
            const actionLabels = {
                archive: { emoji: 'ğŸ“¥', text: 'Archive', color: '#3b82f6' },
                trash: { emoji: 'ğŸ—‘ï¸', text: 'Move to Trash', color: '#ef4444' },
                star: { emoji: 'â­', text: 'Star', color: '#f59e0b' },
                mark_read: { emoji: 'âœ“', text: 'Mark as Read', color: '#10b981' }
            };

            const config = actionLabels[action] || actionLabels.archive;

            // Update header
            document.getElementById('batch-preview-title').textContent = `${config.emoji} ${config.text} Preview`;
            document.getElementById('batch-preview-header').style.background =
                `linear-gradient(135deg, ${config.color}, ${config.color}aa)`;

            // Update summary
            document.getElementById('batch-preview-summary').innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <span style="font-size: 24px;">${config.emoji}</span>
                    <div>
                        <div style="font-size: 16px; font-weight: 600; color: var(--text-primary);">
                            ${config.text} ${emails.length} email${emails.length !== 1 ? 's' : ''}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                            This action will be applied to Gmail via MCP Bridge
                        </div>
                    </div>
                </div>
            `;

            // Update confirm button color
            const confirmBtn = document.getElementById('batch-confirm-btn');
            confirmBtn.style.borderColor = config.color;
            confirmBtn.style.color = config.color;
            confirmBtn.style.background = `${config.color}20`;
            confirmBtn.textContent = `${config.emoji} ${config.text} All`;

            // Show email list (max 10)
            const listEl = document.getElementById('batch-preview-list');
            listEl.innerHTML = emails.slice(0, 10).map(email => `
                <div style="padding: 10px 12px; background: rgba(0,0,0,0.2); border-radius: 8px; display: flex; align-items: center; gap: 12px;">
                    <span style="font-size: 16px;">${email.unread ? 'ğŸ“§' : 'ğŸ“¨'}</span>
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-size: 13px; font-weight: 500; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            ${email.name || '(No subject)'}
                        </div>
                        <div style="font-size: 11px; color: var(--text-secondary);">
                            ${email.senderEmail || 'Unknown sender'}
                        </div>
                    </div>
                </div>
            `).join('');

            // Show "and X more" if needed
            const moreEl = document.getElementById('batch-preview-more');
            if (emails.length > 10) {
                moreEl.textContent = `... and ${emails.length - 10} more`;
                moreEl.style.display = 'block';
            } else {
                moreEl.style.display = 'none';
            }

            // Reset progress
            document.getElementById('batch-progress').style.display = 'none';
            document.getElementById('batch-progress-bar').style.width = '0%';

            // Show modal
            document.getElementById('batch-preview-modal').style.display = 'flex';
        }
        window.showBatchPreviewModal = showBatchPreviewModal;

        /**
         * Close batch preview modal
         */
        function closeBatchPreviewModal() {
            document.getElementById('batch-preview-modal').style.display = 'none';
            window.pendingBatchAction = null;
        }
        window.closeBatchPreviewModal = closeBatchPreviewModal;

        /**
         * Execute batch action with rate limiting
         */
        async function executeBatchAction() {
            const pending = window.pendingBatchAction;
            if (!pending) return;

            const { action, emails } = pending;
            const toolMap = {
                archive: 'gmail_archive',
                trash: 'gmail_trash',
                star: 'gmail_star',
                mark_read: 'gmail_mark_read'
            };

            const toolName = toolMap[action];
            if (!toolName) {
                showToast('Unknown action', 'error');
                return;
            }

            // Show progress
            document.getElementById('batch-progress').style.display = 'flex';
            document.getElementById('batch-confirm-btn').disabled = true;
            document.getElementById('batch-confirm-btn').textContent = 'Processing...';

            let completed = 0;
            let failed = 0;
            const total = emails.length;

            // Process with rate limiting (concurrency 2, backoff on errors)
            const processEmail = async (email) => {
                try {
                    // Add jitter to prevent thundering herd
                    const jitter = Math.random() * 200;
                    await new Promise(r => setTimeout(r, gmailRateLimitQueue.currentDelay + jitter));

                    const result = await executeGmailAction(toolName, { thread_id: email.threadId }, email.threadId);

                    if (result.success) {
                        completed++;
                        gmailRateLimitQueue.consecutiveErrors = 0;
                        gmailRateLimitQueue.currentDelay = gmailRateLimitQueue.baseDelay;

                        // Update node state
                        if (action === 'archive') email._gmailSynced = 'archived';
                        else if (action === 'trash') email._gmailSynced = 'trashed';
                        else if (action === 'star') email.starred = true;
                        else if (action === 'mark_read') email.unread = false;
                    } else {
                        failed++;
                        gmailRateLimitQueue.consecutiveErrors++;
                        // Exponential backoff with max
                        gmailRateLimitQueue.currentDelay = Math.min(
                            gmailRateLimitQueue.currentDelay * 2,
                            gmailRateLimitQueue.maxDelay
                        );
                    }
                } catch (err) {
                    failed++;
                    gmailRateLimitQueue.consecutiveErrors++;
                    gmailRateLimitQueue.currentDelay = Math.min(
                        gmailRateLimitQueue.currentDelay * 2,
                        gmailRateLimitQueue.maxDelay
                    );
                }

                // Update progress
                const progress = ((completed + failed) / total) * 100;
                document.getElementById('batch-progress-bar').style.width = `${progress}%`;
                document.getElementById('batch-progress-text').textContent = `${completed + failed}/${total}`;
            };

            // Process in batches of 2 (concurrency limit)
            for (let i = 0; i < emails.length; i += gmailRateLimitQueue.concurrency) {
                const batch = emails.slice(i, i + gmailRateLimitQueue.concurrency);
                await Promise.all(batch.map(processEmail));
            }

            // Done
            closeBatchPreviewModal();
            render();

            if (failed === 0) {
                showToast(`âœ… ${completed} emails processed successfully`, 'success');
            } else {
                showToast(`âš ï¸ ${completed} succeeded, ${failed} failed`, 'warning');
            }
        }
        window.executeBatchAction = executeBatchAction;

        /**
         * Show send confirmation modal
         */
        function showSendConfirmModal() {
            const to = document.getElementById('compose-to').value;
            const subject = document.getElementById('compose-subject').value;

            if (!to || !document.getElementById('compose-body').value) {
                showToast('Please fill in recipient and message', 'warning');
                return;
            }

            document.getElementById('send-confirm-to').textContent = to;
            document.getElementById('send-confirm-subject').textContent = subject || '(No subject)';
            document.getElementById('send-confirm-modal').style.display = 'flex';
        }
        window.showSendConfirmModal = showSendConfirmModal;

        /**
         * Close send confirmation modal
         */
        function closeSendConfirmModal() {
            document.getElementById('send-confirm-modal').style.display = 'none';
        }
        window.closeSendConfirmModal = closeSendConfirmModal;

        /**
         * Confirm and send draft
         */
        async function confirmSendDraft() {
            if (!isMCPBridgeConnected()) {
                showToast('MCP Bridge not connected', 'error');
                closeSendConfirmModal();
                return;
            }

            const nodeId = document.getElementById('compose-node-id').value;
            const draftId = document.getElementById('compose-draft-id').value;

            closeSendConfirmModal();
            updateComposeStatus('syncing');

            // If draft exists in Gmail, send it; otherwise create and send
            if (draftId) {
                const result = await sendGmailAction('gmail_send_draft', { draft_id: draftId });
                if (result.success) {
                    // Delete local draft
                    await deleteDraftLocal(nodeId);

                    // Clear compose
                    document.getElementById('compose-body').value = '';
                    document.getElementById('compose-draft-id').value = '';

                    closeComposeModal();
                    showToast('ğŸ“¤ Email sent successfully!', 'success');

                    // Update node state
                    const node = findNodeByIdLocal(nodeId);
                    if (node) {
                        node._gmailSynced = 'replied';
                        render();
                    }
                } else {
                    updateComposeStatus('error');
                    showToast(result.error || 'Failed to send', 'error');
                }
            } else {
                // Create draft and send immediately
                const draft = {
                    threadId: document.getElementById('compose-thread-id').value,
                    to: document.getElementById('compose-to').value,
                    cc: document.getElementById('compose-cc').value,
                    bcc: document.getElementById('compose-bcc').value,
                    subject: document.getElementById('compose-subject').value,
                    body: document.getElementById('compose-body').value
                };

                // Create draft first
                const createResult = await sendGmailAction('gmail_create_draft', {
                    thread_id: draft.threadId,
                    to: draft.to,
                    subject: draft.subject,
                    body: draft.body,
                    cc: draft.cc || undefined,
                    bcc: draft.bcc || undefined
                });

                if (createResult.success && createResult.draftId) {
                    // Now send it
                    const sendResult = await sendGmailAction('gmail_send_draft', { draft_id: createResult.draftId });
                    if (sendResult.success) {
                        await deleteDraftLocal(nodeId);
                        closeComposeModal();
                        showToast('ğŸ“¤ Email sent successfully!', 'success');

                        const node = findNodeByIdLocal(nodeId);
                        if (node) {
                            node._gmailSynced = 'replied';
                            render();
                        }
                    } else {
                        updateComposeStatus('error');
                        showToast(sendResult.error || 'Failed to send', 'error');
                    }
                } else {
                    updateComposeStatus('error');
                    showToast(createResult.error || 'Failed to create draft', 'error');
                }
            }
        }
        window.confirmSendDraft = confirmSendDraft;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // End Gmail Sync Functions
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Helper functions for MCP config persistence (Build 520)
        function saveMCPConfig(port, token) {
            try {
                localStorage.setItem(MCP_STORAGE_KEY, JSON.stringify({ port, token, savedAt: Date.now() }));
            } catch (e) {
                console.warn('[MCP] Failed to save config:', e);
            }
        }

        function loadMCPConfig() {
            try {
                const saved = localStorage.getItem(MCP_STORAGE_KEY);
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.warn('[MCP] Failed to load config:', e);
            }
            return null;
        }

        function clearMCPConfig() {
            try {
                localStorage.removeItem(MCP_STORAGE_KEY);
            } catch (e) {
                console.warn('[MCP] Failed to clear config:', e);
            }
        }

        /**
         * TreeListy MCP Bridge Client
         * WebSocket client for connecting to the MCP bridge (spawned by Claude Code)
         */
        class TreeListyMCPClient {
            constructor(options = {}) {
                this.options = {
                    reconnectInterval: 5000,
                    maxReconnectAttempts: 10,
                    requestTimeout: 30000,
                    ...options
                };

                this.socket = null;
                this.tabId = 'tab-' + Math.random().toString(36).substr(2, 9);
                this.requestId = 0;
                this.pendingRequests = new Map();
                this.reconnectAttempts = 0;
                this.isConnected = false;
                this.connectionInfo = null;

                // Event handlers
                this.onConnect = null;
                this.onDisconnect = null;
                this.onError = null;
                this.onRequest = null;
                this.onTaskEvent = null; // Build 522: Agent Dispatch events
            }

            async connect(port, token) {
                return new Promise((resolve, reject) => {
                    const url = `ws://localhost:${port}/?token=${encodeURIComponent(token)}&tabId=${this.tabId}`;

                    try {
                        this.socket = new WebSocket(url);
                    } catch (err) {
                        reject(new Error(`Failed to create WebSocket: ${err.message}`));
                        return;
                    }

                    const timeout = setTimeout(() => {
                        reject(new Error('Connection timeout'));
                        this.socket?.close();
                    }, 10000);

                    this.socket.onopen = () => {
                        clearTimeout(timeout);
                        this.isConnected = true;
                        this.reconnectAttempts = 0;
                        this.connectionInfo = { port, token };

                        console.log('[MCP Bridge] Connected to Claude Code');

                        if (this.onConnect) this.onConnect();
                        resolve();
                    };

                    this.socket.onclose = (event) => {
                        clearTimeout(timeout);
                        this.isConnected = false;

                        console.log('[MCP Bridge] Disconnected:', event.code, event.reason);

                        for (const [id, { reject }] of this.pendingRequests) {
                            reject(new Error('Connection closed'));
                        }
                        this.pendingRequests.clear();

                        if (this.onDisconnect) this.onDisconnect(event.code, event.reason);

                        if (this.connectionInfo && this.reconnectAttempts < this.options.maxReconnectAttempts) {
                            this.scheduleReconnect();
                        }
                    };

                    this.socket.onerror = (err) => {
                        console.error('[MCP Bridge] Error:', err);
                        if (this.onError) this.onError(err);
                    };

                    this.socket.onmessage = (event) => {
                        this.handleMessage(event.data);
                    };
                });
            }

            scheduleReconnect() {
                this.reconnectAttempts++;
                console.log(`[MCP Bridge] Reconnecting in ${this.options.reconnectInterval}ms (attempt ${this.reconnectAttempts})`);

                setTimeout(() => {
                    if (!this.isConnected && this.connectionInfo) {
                        this.connect(this.connectionInfo.port, this.connectionInfo.token).catch(err => {
                            console.error('[MCP Bridge] Reconnect failed:', err.message);
                        });
                    }
                }, this.options.reconnectInterval);
            }

            handleMessage(data) {
                try {
                    const message = JSON.parse(data);

                    // Handle task events from bridge (Build 522: Agent Dispatch)
                    if (message.type && message.type.startsWith('task')) {
                        if (this.onTaskEvent) {
                            this.onTaskEvent(message);
                        }
                        return;
                    }

                    if (message.id && this.pendingRequests.has(message.id)) {
                        const { resolve, reject } = this.pendingRequests.get(message.id);
                        this.pendingRequests.delete(message.id);

                        if (message.error) {
                            reject(new Error(message.error.message || 'Unknown error'));
                        } else {
                            resolve(message.result);
                        }
                        return;
                    }

                    // BUILD 556: Handle Gmail responses (stored in window.pendingMCPRequests)
                    if (message.id && window.pendingMCPRequests && window.pendingMCPRequests.has(message.id)) {
                        console.log('[Gmail] Received response for:', message.id, message.result || message.error);
                        const resolve = window.pendingMCPRequests.get(message.id);
                        window.pendingMCPRequests.delete(message.id);

                        if (message.error) {
                            resolve({ success: false, error: message.error.message || 'Unknown error' });
                        } else {
                            resolve(message.result);
                        }
                        return;
                    }

                    // BUILD 564: Handle extension responses
                    if (message.type === 'extension_result' && message.requestId) {
                        console.log('[Extension] Received result for:', message.requestId);
                        if (window.pendingExtensionRequests && window.pendingExtensionRequests.has(message.requestId)) {
                            const resolve = window.pendingExtensionRequests.get(message.requestId);
                            window.pendingExtensionRequests.delete(message.requestId);

                            if (message.error) {
                                resolve({ success: false, error: message.error });
                            } else {
                                resolve(message.result);
                            }
                        }
                        return;
                    }

                    // BUILD 564: Handle extension connection notifications
                    if (message.type === 'extension_connected') {
                        console.log('[Extension] Connected:', message.clientId, message.capabilities);
                        showToast(`ğŸ“· Screen capture extension connected`, 'success');
                        return;
                    }

                    if (message.type === 'extension_disconnected') {
                        console.log('[Extension] Disconnected:', message.clientId);
                        showToast(`ğŸ“· Screen capture extension disconnected`, 'info');
                        return;
                    }

                    // BUILD 564: Handle manual capture from extension (user clicked extension icon)
                    if (message.type === 'extension_capture') {
                        console.log('[Extension] Manual capture received');
                        if (message.result?.success && message.result?.screenshot) {
                            displayScreenshotInChat(message.result.screenshot, message.result.provenance);
                            window._lastScreenCapture = message.result;
                        }
                        return;
                    }

                    // BUILD 557: Log unhandled messages for debugging
                    if (message.id && message.id.startsWith('gmail-')) {
                        console.log('[Gmail] Received response but no pending request:', message.id);
                    }

                    // Incoming request from Claude Code
                    if (message.method && this.onRequest) {
                        this.handleIncomingRequest(message);
                    }

                } catch (err) {
                    console.error('[MCP Bridge] Failed to parse message:', err);
                }
            }

            async handleIncomingRequest(request) {
                try {
                    const result = await this.onRequest(request.method, request.params || {});

                    const response = {
                        jsonrpc: '2.0',
                        id: request.id,
                        result
                    };
                    this.socket.send(JSON.stringify(response));

                } catch (err) {
                    const response = {
                        jsonrpc: '2.0',
                        id: request.id,
                        error: { code: -32000, message: err.message }
                    };
                    this.socket.send(JSON.stringify(response));
                }
            }

            disconnect() {
                this.connectionInfo = null;
                if (this.socket) {
                    this.socket.close(1000, 'Client disconnect');
                    this.socket = null;
                }
                this.isConnected = false;
            }

            getStatus() {
                return {
                    connected: this.isConnected,
                    tabId: this.tabId,
                    pendingRequests: this.pendingRequests.size,
                    reconnectAttempts: this.reconnectAttempts
                };
            }

            // Build 522: Submit task to Claude Code via bridge
            submitTask(taskData) {
                if (!this.isConnected || !this.socket) {
                    throw new Error('Not connected to bridge');
                }
                this.socket.send(JSON.stringify({
                    type: 'task.submit',
                    ...taskData
                }));
            }

            // Build 522: Acknowledge task result (approve/reject)
            acknowledgeTask(taskId, action, selectedOps = null) {
                if (!this.isConnected || !this.socket) {
                    throw new Error('Not connected to bridge');
                }
                this.socket.send(JSON.stringify({
                    type: 'task.acknowledge',
                    taskId,
                    action,
                    selectedOps
                }));
            }
        }

        /**
         * TreeListy MCP Handler
         * Handles incoming requests from Claude Code and maps them to TreeListy functions
         */
        class TreeListyMCPHandler {
            constructor() {
                this.activeTransaction = null;
                this.transactionChanges = [];
                this.transactionSnapshot = null; // Deep clone at txn start for rollback
            }

            async handleRequest(method, params) {
                // Log activity
                mcpBridgeState.activityLog.push({
                    timestamp: new Date().toISOString(),
                    method,
                    params: { ...params, _truncated: true }
                });

                // Keep log size manageable
                if (mcpBridgeState.activityLog.length > 100) {
                    mcpBridgeState.activityLog = mcpBridgeState.activityLog.slice(-50);
                }

                switch (method) {
                    case 'tools/call':
                        return this.handleToolCall(params);
                    case 'get_tree':
                        return this.getTree(params);
                    case 'get_tree_metadata':
                        return this.getTreeMetadata(params);
                    case 'get_subtree':
                        return this.getSubtree(params);
                    case 'get_node':
                        return this.getNode(params);
                    case 'create_node':
                        return this.createNode(params);
                    case 'update_node':
                        return this.updateNode(params);
                    case 'delete_node':
                        return this.deleteNode(params);
                    case 'search_nodes':
                        return this.searchNodes(params);
                    case 'import_structured_content':
                        return this.importStructuredContent(params);
                    case 'begin_transaction':
                        return this.beginTransaction(params);
                    case 'commit_transaction':
                        return this.commitTransaction(params);
                    case 'rollback_transaction':
                        return this.rollbackTransaction(params);
                    case 'get_pattern_schema':
                        return this.getPatternSchema(params);
                    case 'get_activity_log':
                        return this.getActivityLog(params);
                    // Structure Operations (Build 520)
                    case 'move_node':
                        return this.moveNode(params);
                    case 'reorder_node':
                        return this.reorderNode(params);
                    case 'duplicate_node':
                        return this.duplicateNode(params);
                    case 'bulk_update':
                        return this.bulkUpdate(params);
                    case 'bulk_create':
                        return this.bulkCreate(params);
                    case 'bulk_delete':
                        return this.bulkDelete(params);
                    // UI Control Operations (Build 520)
                    case 'select_node':
                        return this.selectNode(params);
                    case 'get_selected_node':
                        return this.getSelectedNode(params);
                    case 'expand_node':
                        return this.expandNode(params);
                    case 'collapse_node':
                        return this.collapseNode(params);
                    case 'set_view':
                        return this.setView(params);
                    case 'get_view':
                        return this.getView(params);
                    case 'scroll_to_node':
                        return this.scrollToNode(params);
                    case 'undo':
                        return this.undoAction(params);
                    case 'redo':
                        return this.redoAction(params);
                    case 'get_undo_stack_info':
                        return this.getUndoStackInfo(params);
                    // Capability Operations (Build 544)
                    case 'list_capabilities':
                        return this.listCapabilities(params);
                    case 'get_capability':
                        return this.getCapability(params);
                    case 'create_capability':
                        return this.createCapability(params);
                    case 'match_capability':
                        return this.matchCapability(params);
                    case 'update_capability_status':
                        return this.updateCapabilityStatus(params);
                    // RAG Operations (Build 546)
                    case 'retrieve_context':
                        return this.retrieveContext(params);
                    default:
                        throw new Error(`Unknown method: ${method}`);
                }
            }

            handleToolCall(params) {
                const { name, arguments: args } = params;
                return this.handleRequest(name, args || {});
            }

            // Tree Adapter: Convert native schema to agent-friendly children[]
            // Introspection-based: detects which child key exists rather than assuming by depth
            toAgentFormat(node, depth = 0, maxDepth = Infinity) {
                if (depth >= maxDepth) {
                    return { ...node, children: [] };
                }

                // Introspection: detect which child key exists in this node
                const children = node.children || node.items || node.subItems || node.subtasks || [];

                const result = { ...node };
                delete result.children;
                delete result.items;
                delete result.subItems;
                delete result.subtasks;

                result.children = (children || []).map(child =>
                    this.toAgentFormat(child, depth + 1, maxDepth)
                );

                return result;
            }

            // Tree Adapter: Convert agent children[] back to native schema
            // Pattern-aware: Filesystem always uses children[], others use 4-level schema
            fromAgentFormat(agentNode, parentType, patternKey = null) {
                // Determine pattern from tree root if not provided
                const pattern = patternKey || (capexTree.pattern && capexTree.pattern.key) || 'generic';

                // Filesystem pattern: always use children[] at every level
                const useUniformChildren = pattern === 'filesystem';

                const childKey = useUniformChildren ? 'children' :
                                 (parentType === 'root' ? 'children' :
                                  parentType === 'phase' ? 'items' : 'subtasks');

                const { children, ...rest } = agentNode;
                const result = {
                    ...rest,
                    id: rest.id || this.generateId()
                };

                if (children && children.length > 0) {
                    // For filesystem, preserve type from node; for others, infer from parent
                    const childType = useUniformChildren ? (rest.type || 'folder') :
                                      (parentType === 'root' ? 'phase' :
                                       parentType === 'phase' ? 'item' : 'subtask');
                    result[childKey] = children.map(child => {
                        child.type = child.type || childType;
                        return this.fromAgentFormat(child, child.type, pattern);
                    });
                }

                return result;
            }

            generateId() {
                return 'mcp-' + Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 5);
            }

            findNodeById(id) {
                function search(node) {
                    if (node.id === id) return node;
                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    for (const child of children) {
                        const found = search(child);
                        if (found) return found;
                    }
                    return null;
                }
                return search(capexTree);
            }

            findParentOf(nodeId) {
                function search(parent, node) {
                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    for (const child of children) {
                        if (child.id === nodeId) return node;
                        const found = search(node, child);
                        if (found) return found;
                    }
                    return null;
                }
                return search(null, capexTree);
            }

            countNodes(node) {
                let count = 1;
                const children = node.children || node.items || node.subItems || node.subtasks || [];
                for (const child of children) {
                    count += this.countNodes(child);
                }
                return count;
            }

            hashTree(tree) {
                const str = JSON.stringify(tree);
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(16);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Tool Implementations
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            getTree(params) {
                const format = params.format || 'agent';
                if (format === 'native') {
                    return capexTree;
                }
                return this.toAgentFormat(capexTree);
            }

            getTreeMetadata(params) {
                return {
                    id: capexTree.id,
                    name: capexTree.name,
                    pattern: capexTree.pattern?.key,
                    nodeCount: this.countNodes(capexTree),
                    lastModified: new Date().toISOString(),
                    hash: this.hashTree(capexTree)
                };
            }

            getSubtree(params) {
                const { nodeId, depth = 3, format = 'agent' } = params;
                const node = this.findNodeById(nodeId);
                if (!node) throw new Error(`Node not found: ${nodeId}`);

                if (format === 'native') return node;
                return this.toAgentFormat(node, 0, depth);
            }

            getNode(params) {
                const { node_id } = params;
                const node = this.findNodeById(node_id);
                if (!node) throw new Error(`Node not found: ${node_id}`);
                return this.toAgentFormat(node, 0, 1);
            }

            createNode(params) {
                const { parent_id, node_data, position } = params;

                const parent = this.findNodeById(parent_id);
                if (!parent) throw new Error(`Parent not found: ${parent_id}`);

                // Pattern-aware child key and type determination
                const pattern = (capexTree.pattern && capexTree.pattern.key) || 'generic';
                const useUniformChildren = pattern === 'filesystem';

                const childKey = useUniformChildren ? 'children' :
                                 (parent.type === 'root' ? 'children' :
                                  parent.type === 'phase' ? 'items' : 'subtasks');

                if (!parent[childKey]) parent[childKey] = [];

                // Create the new node (filesystem uses type from data, others infer from parent)
                const defaultType = useUniformChildren ? (node_data.type || 'folder') :
                                    (parent.type === 'root' ? 'phase' :
                                     parent.type === 'phase' ? 'item' : 'subtask');
                const newNode = {
                    id: node_data.id || this.generateId(),
                    nodeGuid: node_data.nodeGuid || generateNodeGuid(), // Atlas: stable identity
                    name: node_data.name || 'New Node',
                    type: defaultType,
                    description: node_data.description || '',
                    ...node_data
                };

                // Insert at position or end
                if (typeof position === 'number' && position >= 0) {
                    parent[childKey].splice(position, 0, newNode);
                } else {
                    parent[childKey].push(newNode);
                }

                // Track for transaction or save immediately
                if (this.activeTransaction) {
                    this.transactionChanges.push({ type: 'create', nodeId: newNode.id });
                } else {
                    saveState('MCP: Created node');
                    render();
                }

                showToast(`ğŸ¤– Claude created: ${newNode.name}`, 'info');
                return { nodeId: newNode.id };
            }

            updateNode(params) {
                const { node_id, updates } = params;

                const node = this.findNodeById(node_id);
                if (!node) throw new Error(`Node not found: ${node_id}`);

                // Apply updates (but protect system fields)
                const protectedFields = ['id', 'type', 'children', 'items', 'subItems', 'subtasks'];
                for (const [key, value] of Object.entries(updates)) {
                    if (!protectedFields.includes(key)) {
                        node[key] = value;
                    }
                }

                if (this.activeTransaction) {
                    this.transactionChanges.push({ type: 'update', nodeId });
                } else {
                    saveState('MCP: Updated node');
                    render();
                }

                showToast(`ğŸ¤– Claude updated: ${node.name}`, 'info');
                return { success: true };
            }

            deleteNode(params) {
                const { node_id } = params;

                if (node_id === 'root' || node_id === capexTree.id) {
                    throw new Error('Cannot delete root node');
                }

                const parent = this.findParentOf(node_id);
                if (!parent) throw new Error(`Node not found: ${node_id}`);

                // Find and remove from correct array
                const childKeys = ['children', 'items', 'subItems', 'subtasks'];
                let deleted = false;
                for (const key of childKeys) {
                    if (parent[key]) {
                        const idx = parent[key].findIndex(c => c.id === node_id);
                        if (idx >= 0) {
                            parent[key].splice(idx, 1);
                            deleted = true;
                            break;
                        }
                    }
                }

                if (!deleted) throw new Error(`Failed to delete node: ${nodeId}`);

                if (this.activeTransaction) {
                    this.transactionChanges.push({ type: 'delete', nodeId });
                } else {
                    saveState('MCP: Deleted node');
                    render();
                }

                showToast(`ğŸ¤– Claude deleted node`, 'info');
                return { success: true };
            }

            searchNodes(params) {
                const { query, fields = ['name', 'description'], type } = params;
                const results = [];
                const lowerQuery = query.toLowerCase();

                function search(node) {
                    let matches = false;
                    for (const field of fields) {
                        if (node[field] && String(node[field]).toLowerCase().includes(lowerQuery)) {
                            matches = true;
                            break;
                        }
                    }

                    if (matches && (!type || node.type === type)) {
                        results.push(node);
                    }

                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    children.forEach(search);
                }

                search(capexTree);
                return results.map(n => this.toAgentFormat(n, 0, 1));
            }

            importStructuredContent(params) {
                const { parentId, content, source } = params;

                const parent = this.findNodeById(parentId);
                if (!parent) throw new Error(`Parent not found: ${parentId}`);

                // Get pattern for schema-aware conversion
                const pattern = (capexTree.pattern && capexTree.pattern.key) || 'generic';

                // Convert from agent format to native
                const nativeContent = this.fromAgentFormat(content, parent.type, pattern);

                // Tag with provenance
                function tagNodes(node) {
                    node._provenance = {
                        source: source || 'mcp-import',
                        actor: 'claude-code',
                        timestamp: Date.now()
                    };
                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    children.forEach(tagNodes);
                }
                tagNodes(nativeContent);

                // Add to parent (pattern-aware child key)
                const useUniformChildren = pattern === 'filesystem';
                const childKey = useUniformChildren ? 'children' :
                                 (parent.type === 'root' ? 'children' :
                                  parent.type === 'phase' ? 'items' : 'subtasks');
                if (!parent[childKey]) parent[childKey] = [];
                parent[childKey].push(nativeContent);

                // Collect all node IDs
                const nodeIds = [];
                function collectIds(node) {
                    nodeIds.push(node.id);
                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    children.forEach(collectIds);
                }
                collectIds(nativeContent);

                if (this.activeTransaction) {
                    this.transactionChanges.push({ type: 'import', nodeIds });
                } else {
                    saveState('MCP: Imported content');
                    render();
                }

                showToast(`ğŸ¤– Claude imported ${nodeIds.length} nodes`, 'success');
                return { nodeIds };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Transaction Operations
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            beginTransaction(params) {
                if (this.activeTransaction) {
                    throw new Error('Transaction already active');
                }

                // Deep clone tree state for potential rollback
                this.transactionSnapshot = JSON.parse(JSON.stringify(capexTree));

                this.activeTransaction = {
                    id: 'txn-' + Math.random().toString(36).substr(2, 9),
                    startTime: Date.now()
                };
                this.transactionChanges = [];

                return { transactionId: this.activeTransaction.id };
            }

            commitTransaction(params) {
                const { transactionId } = params;

                if (!this.activeTransaction) {
                    throw new Error('No active transaction');
                }

                if (this.activeTransaction.id !== transactionId) {
                    throw new Error('Transaction ID mismatch');
                }

                saveState(`MCP: Transaction (${this.transactionChanges.length} changes)`);
                render();

                const result = {
                    transactionId: this.activeTransaction.id,
                    changes: this.transactionChanges.length,
                    durationMs: Date.now() - this.activeTransaction.startTime
                };

                this.activeTransaction = null;
                this.transactionChanges = [];
                this.transactionSnapshot = null; // Clear snapshot on commit

                showToast(`ğŸ¤– Claude committed ${result.changes} changes`, 'success');
                return result;
            }

            rollbackTransaction(params) {
                if (!this.activeTransaction) {
                    throw new Error('No active transaction');
                }

                const result = {
                    transactionId: this.activeTransaction.id,
                    rolledBackChanges: this.transactionChanges.length
                };

                // Restore from transaction snapshot (not global undo stack)
                if (this.transactionSnapshot) {
                    // Restore tree state to pre-transaction snapshot
                    Object.keys(capexTree).forEach(key => delete capexTree[key]);
                    Object.assign(capexTree, this.transactionSnapshot);
                    this.transactionSnapshot = null;
                    render();
                }

                this.activeTransaction = null;
                this.transactionChanges = [];

                showToast(`ğŸ¤– Claude rolled back ${result.rolledBackChanges} changes`, 'warning');
                return result;
            }

            getPatternSchema(params) {
                const { pattern } = params;
                if (typeof PATTERNS !== 'undefined' && PATTERNS[pattern]) {
                    return PATTERNS[pattern];
                }
                return null;
            }

            getActivityLog(params) {
                const { limit = 50, since } = params;
                let log = mcpBridgeState.activityLog;

                if (since) {
                    log = log.filter(entry => new Date(entry.timestamp) > new Date(since));
                }

                return log.slice(-limit);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Structure Operations (Build 520)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            moveNode(params) {
                const { node_id, new_parent_id, position } = params;

                if (node_id === 'root' || node_id === capexTree.id) {
                    throw new Error('Cannot move root node');
                }

                const node = this.findNodeById(node_id);
                if (!node) throw new Error(`Node not found: ${node_id}`);

                const oldParent = this.findParentOf(node_id);
                if (!oldParent) throw new Error(`Cannot find parent of node: ${node_id}`);

                const newParent = this.findNodeById(new_parent_id);
                if (!newParent) throw new Error(`New parent not found: ${new_parent_id}`);

                // Prevent moving a node into its own descendants
                const isDescendant = (ancestorId, nodeToCheck) => {
                    const children = nodeToCheck.children || nodeToCheck.items || nodeToCheck.subItems || nodeToCheck.subtasks || [];
                    for (const child of children) {
                        if (child.id === ancestorId || isDescendant(ancestorId, child)) return true;
                    }
                    return false;
                };
                if (isDescendant(new_parent_id, node)) {
                    throw new Error('Cannot move node into its own descendant');
                }

                // Remove from old parent
                const childKeys = ['children', 'items', 'subItems', 'subtasks'];
                for (const key of childKeys) {
                    if (oldParent[key]) {
                        const idx = oldParent[key].findIndex(c => c.id === node_id);
                        if (idx >= 0) {
                            oldParent[key].splice(idx, 1);
                            break;
                        }
                    }
                }

                // Add to new parent (pattern-aware child key)
                const pattern = (capexTree.pattern && capexTree.pattern.key) || 'generic';
                const useUniformChildren = pattern === 'filesystem';
                const newChildKey = useUniformChildren ? 'children' :
                                    (newParent.type === 'root' ? 'children' :
                                     newParent.type === 'phase' ? 'items' : 'subtasks');

                if (!newParent[newChildKey]) newParent[newChildKey] = [];

                // Update node type based on new depth (unless filesystem pattern)
                if (!useUniformChildren) {
                    node.type = newParent.type === 'root' ? 'phase' :
                                newParent.type === 'phase' ? 'item' : 'subtask';
                }

                if (typeof position === 'number' && position >= 0) {
                    newParent[newChildKey].splice(position, 0, node);
                } else {
                    newParent[newChildKey].push(node);
                }

                if (this.activeTransaction) {
                    this.transactionChanges.push({ type: 'move', nodeId: node_id });
                } else {
                    saveState('MCP: Moved node');
                    render();
                }

                showToast(`ğŸ¤– Claude moved: ${node.name}`, 'info');
                return { success: true, newParentId: new_parent_id };
            }

            reorderNode(params) {
                const { node_id, position } = params;

                const parent = this.findParentOf(node_id);
                if (!parent) throw new Error(`Node not found or is root: ${node_id}`);

                const childKeys = ['children', 'items', 'subItems', 'subtasks'];
                let moved = false;

                for (const key of childKeys) {
                    if (parent[key]) {
                        const idx = parent[key].findIndex(c => c.id === node_id);
                        if (idx >= 0) {
                            const [node] = parent[key].splice(idx, 1);
                            const newPos = Math.min(position, parent[key].length);
                            parent[key].splice(newPos, 0, node);
                            moved = true;
                            break;
                        }
                    }
                }

                if (!moved) throw new Error(`Failed to reorder node: ${node_id}`);

                if (this.activeTransaction) {
                    this.transactionChanges.push({ type: 'reorder', nodeId: node_id });
                } else {
                    saveState('MCP: Reordered node');
                    render();
                }

                showToast(`ğŸ¤– Claude reordered node`, 'info');
                return { success: true, newPosition: position };
            }

            duplicateNode(params) {
                const { node_id, new_parent_id, include_children = true } = params;

                const sourceNode = this.findNodeById(node_id);
                if (!sourceNode) throw new Error(`Node not found: ${node_id}`);

                const targetParent = new_parent_id
                    ? this.findNodeById(new_parent_id)
                    : this.findParentOf(node_id);
                if (!targetParent) throw new Error(`Target parent not found`);

                // Deep clone with new IDs
                const cloneWithNewIds = (node, depth = 0) => {
                    const clone = { ...node };
                    clone.id = this.generateId();
                    clone.name = depth === 0 ? `${node.name} (copy)` : node.name;

                    if (include_children) {
                        const childKeys = ['children', 'items', 'subItems', 'subtasks'];
                        for (const key of childKeys) {
                            if (clone[key] && Array.isArray(clone[key])) {
                                clone[key] = clone[key].map(child => cloneWithNewIds(child, depth + 1));
                            }
                        }
                    } else {
                        // Remove children if not including
                        delete clone.children;
                        delete clone.items;
                        delete clone.subItems;
                        delete clone.subtasks;
                    }

                    return clone;
                };

                const clonedNode = cloneWithNewIds(sourceNode);

                // Add to target parent
                const pattern = (capexTree.pattern && capexTree.pattern.key) || 'generic';
                const useUniformChildren = pattern === 'filesystem';
                const childKey = useUniformChildren ? 'children' :
                                 (targetParent.type === 'root' ? 'children' :
                                  targetParent.type === 'phase' ? 'items' : 'subtasks');

                if (!targetParent[childKey]) targetParent[childKey] = [];
                targetParent[childKey].push(clonedNode);

                // Count duplicated nodes
                const countDuplicates = (node) => {
                    let count = 1;
                    const childKeys = ['children', 'items', 'subItems', 'subtasks'];
                    for (const key of childKeys) {
                        if (node[key]) count += node[key].reduce((sum, c) => sum + countDuplicates(c), 0);
                    }
                    return count;
                };
                const duplicatedCount = countDuplicates(clonedNode);

                if (this.activeTransaction) {
                    this.transactionChanges.push({ type: 'duplicate', nodeId: clonedNode.id });
                } else {
                    saveState('MCP: Duplicated node');
                    render();
                }

                showToast(`ğŸ¤– Claude duplicated ${duplicatedCount} nodes`, 'info');
                return { newNodeId: clonedNode.id, duplicatedCount };
            }

            bulkUpdate(params) {
                const { updates } = params;
                const results = [];
                const protectedFields = ['id', 'type', 'children', 'items', 'subItems', 'subtasks'];

                for (const { node_id, updates: nodeUpdates } of updates) {
                    const node = this.findNodeById(node_id);
                    if (node) {
                        for (const [key, value] of Object.entries(nodeUpdates)) {
                            if (!protectedFields.includes(key)) {
                                node[key] = value;
                            }
                        }
                        results.push({ nodeId: node_id, success: true });
                    } else {
                        results.push({ nodeId: node_id, success: false, error: 'Not found' });
                    }
                }

                if (this.activeTransaction) {
                    this.transactionChanges.push({ type: 'bulkUpdate', count: results.length });
                } else {
                    saveState(`MCP: Bulk updated ${results.filter(r => r.success).length} nodes`);
                    render();
                }

                showToast(`ğŸ¤– Claude bulk updated ${results.filter(r => r.success).length} nodes`, 'info');
                return { results, successCount: results.filter(r => r.success).length };
            }

            bulkCreate(params) {
                const { parent_id, nodes } = params;

                const parent = this.findNodeById(parent_id);
                if (!parent) throw new Error(`Parent not found: ${parent_id}`);

                const pattern = (capexTree.pattern && capexTree.pattern.key) || 'generic';
                const useUniformChildren = pattern === 'filesystem';
                const childKey = useUniformChildren ? 'children' :
                                 (parent.type === 'root' ? 'children' :
                                  parent.type === 'phase' ? 'items' : 'subtasks');

                if (!parent[childKey]) parent[childKey] = [];

                const createdIds = [];
                const defaultType = useUniformChildren ? 'folder' :
                                    (parent.type === 'root' ? 'phase' :
                                     parent.type === 'phase' ? 'item' : 'subtask');

                for (const nodeData of nodes) {
                    const newNode = {
                        id: nodeData.id || this.generateId(),
                        name: nodeData.name || 'New Node',
                        type: nodeData.type || defaultType,
                        description: nodeData.description || '',
                        ...nodeData
                    };
                    parent[childKey].push(newNode);
                    createdIds.push(newNode.id);
                }

                if (this.activeTransaction) {
                    this.transactionChanges.push({ type: 'bulkCreate', count: createdIds.length });
                } else {
                    saveState(`MCP: Bulk created ${createdIds.length} nodes`);
                    render();
                }

                showToast(`ğŸ¤– Claude created ${createdIds.length} nodes`, 'success');
                return { nodeIds: createdIds, count: createdIds.length };
            }

            bulkDelete(params) {
                const { node_ids } = params;
                const results = [];

                for (const nodeId of node_ids) {
                    if (nodeId === 'root' || nodeId === capexTree.id) {
                        results.push({ nodeId, success: false, error: 'Cannot delete root' });
                        continue;
                    }

                    const parent = this.findParentOf(nodeId);
                    if (!parent) {
                        results.push({ nodeId, success: false, error: 'Not found' });
                        continue;
                    }

                    const childKeys = ['children', 'items', 'subItems', 'subtasks'];
                    let deleted = false;
                    for (const key of childKeys) {
                        if (parent[key]) {
                            const idx = parent[key].findIndex(c => c.id === nodeId);
                            if (idx >= 0) {
                                parent[key].splice(idx, 1);
                                deleted = true;
                                break;
                            }
                        }
                    }

                    results.push({ nodeId, success: deleted, error: deleted ? null : 'Delete failed' });
                }

                if (this.activeTransaction) {
                    this.transactionChanges.push({ type: 'bulkDelete', count: results.filter(r => r.success).length });
                } else {
                    saveState(`MCP: Bulk deleted ${results.filter(r => r.success).length} nodes`);
                    render();
                }

                showToast(`ğŸ¤– Claude deleted ${results.filter(r => r.success).length} nodes`, 'info');
                return { results, successCount: results.filter(r => r.success).length };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // UI Control Operations (Build 520)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            selectNode(params) {
                const { node_id } = params;

                const node = this.findNodeById(node_id);
                if (!node) throw new Error(`Node not found: ${node_id}`);

                // Use TreeListy's existing selection mechanism
                if (typeof selectNodeById === 'function') {
                    selectNodeById(node_id);
                } else if (typeof window.selectNodeById === 'function') {
                    window.selectNodeById(node_id);
                } else {
                    // Fallback: set selected state manually
                    if (typeof selectedItem !== 'undefined') {
                        selectedItem = node;
                    }
                    if (typeof window.selectedItem !== 'undefined') {
                        window.selectedItem = node;
                    }
                }

                // Scroll to make visible
                this.scrollToNode({ node_id });

                showToast(`ğŸ¤– Claude selected: ${node.name}`, 'info');
                return { success: true, nodeName: node.name };
            }

            getSelectedNode(params) {
                let selected = null;

                if (typeof selectedItem !== 'undefined' && selectedItem) {
                    selected = selectedItem;
                } else if (typeof window.selectedItem !== 'undefined' && window.selectedItem) {
                    selected = window.selectedItem;
                }

                if (!selected) {
                    return { selected: false, node: null };
                }

                return { selected: true, node: this.toAgentFormat(selected, 0, 1) };
            }

            expandNode(params) {
                const { node_id, recursive = false } = params;

                const node = this.findNodeById(node_id);
                if (!node) throw new Error(`Node not found: ${node_id}`);

                const expandNodeRecursive = (n) => {
                    n.collapsed = false;
                    if (recursive) {
                        const children = n.children || n.items || n.subItems || n.subtasks || [];
                        children.forEach(expandNodeRecursive);
                    }
                };

                expandNodeRecursive(node);
                render();

                showToast(`ğŸ¤– Claude expanded: ${node.name}${recursive ? ' (recursive)' : ''}`, 'info');
                return { success: true };
            }

            collapseNode(params) {
                const { node_id, recursive = false } = params;

                const node = this.findNodeById(node_id);
                if (!node) throw new Error(`Node not found: ${node_id}`);

                const collapseNodeRecursive = (n) => {
                    n.collapsed = true;
                    if (recursive) {
                        const children = n.children || n.items || n.subItems || n.subtasks || [];
                        children.forEach(collapseNodeRecursive);
                    }
                };

                collapseNodeRecursive(node);
                render();

                showToast(`ğŸ¤– Claude collapsed: ${node.name}${recursive ? ' (recursive)' : ''}`, 'info');
                return { success: true };
            }

            setView(params) {
                const { view } = params;
                const validViews = ['tree', 'canvas', '3d', 'gantt', 'calendar'];

                if (!validViews.includes(view)) {
                    throw new Error(`Invalid view: ${view}. Must be one of: ${validViews.join(', ')}`);
                }

                // Build 521: Click the view buttons to properly switch views
                const viewButtonMap = {
                    'tree': 'view-tree-btn',
                    'canvas': 'view-canvas-btn',
                    '3d': 'view-3d-btn',
                    'gantt': 'view-gantt-btn',
                    'calendar': 'view-calendar-btn'
                };

                const btnId = viewButtonMap[view];
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.click();
                    showToast(`ğŸ¤– Claude switched to ${view} view`, 'info');
                    return { success: true, view };
                }

                // Fallback: try toggle functions directly
                if (view === '3d' && typeof toggle3DView === 'function') {
                    toggle3DView();
                } else if (view === 'gantt' && typeof toggleGanttView === 'function') {
                    toggleGanttView();
                } else if (view === 'canvas' && typeof toggleCanvasView === 'function') {
                    toggleCanvasView();
                } else if (view === 'calendar' && typeof toggleCalendarView === 'function') {
                    toggleCalendarView();
                } else if (view === 'tree') {
                    // For tree view, hide other views
                    if (typeof viewMode !== 'undefined') viewMode = 'tree';
                    if (typeof render === 'function') render();
                }

                showToast(`ğŸ¤– Claude switched to ${view} view`, 'info');
                return { success: true, view };
            }

            getView(params) {
                let currentView = 'tree';

                if (typeof viewMode !== 'undefined') {
                    currentView = viewMode;
                } else if (typeof window.viewMode !== 'undefined') {
                    currentView = window.viewMode;
                }

                return { view: currentView };
            }

            scrollToNode(params) {
                const { node_id } = params;

                const node = this.findNodeById(node_id);
                if (!node) throw new Error(`Node not found: ${node_id}`);

                // Try TreeListy's scroll function
                if (typeof scrollToNode === 'function') {
                    scrollToNode(node_id);
                } else if (typeof window.scrollToNode === 'function') {
                    window.scrollToNode(node_id);
                } else {
                    // Fallback: find DOM element and scroll
                    const el = document.querySelector(`[data-node-id="${node_id}"]`) ||
                               document.getElementById(`node-${node_id}`);
                    if (el) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }

                return { success: true };
            }

            undoAction(params) {
                if (typeof undo === 'function') {
                    undo();
                } else if (typeof window.undo === 'function') {
                    window.undo();
                } else {
                    throw new Error('Undo function not available');
                }

                showToast(`ğŸ¤– Claude triggered undo`, 'info');
                return { success: true };
            }

            redoAction(params) {
                if (typeof redo === 'function') {
                    redo();
                } else if (typeof window.redo === 'function') {
                    window.redo();
                } else {
                    throw new Error('Redo function not available');
                }

                showToast(`ğŸ¤– Claude triggered redo`, 'info');
                return { success: true };
            }

            getUndoStackInfo(params) {
                let undoCount = 0;
                let redoCount = 0;

                if (typeof undoStack !== 'undefined' && Array.isArray(undoStack)) {
                    undoCount = undoStack.length;
                } else if (typeof window.undoStack !== 'undefined' && Array.isArray(window.undoStack)) {
                    undoCount = window.undoStack.length;
                }

                if (typeof redoStack !== 'undefined' && Array.isArray(redoStack)) {
                    redoCount = redoStack.length;
                } else if (typeof window.redoStack !== 'undefined' && Array.isArray(window.redoStack)) {
                    redoCount = window.redoStack.length;
                }

                return {
                    canUndo: undoCount > 0,
                    canRedo: redoCount > 0,
                    undoCount,
                    redoCount
                };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Capability Operations (Build 544)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            listCapabilities(params) {
                const { site_filter, status_filter } = params || {};
                const capabilities = findCapabilityNodes(capexTree);

                let filtered = capabilities;

                if (site_filter) {
                    filtered = filtered.filter(c => c.site && c.site.includes(site_filter));
                }

                if (status_filter) {
                    filtered = filtered.filter(c => c.status === status_filter);
                }

                return {
                    capabilities: filtered.map(c => ({
                        id: c.id,
                        name: c.name,
                        site: c.site,
                        goal: c.goal,
                        allow: c.allow || ['read', 'navigate'],
                        status: c.status || 'untested',
                        lastSuccessAt: c.lastSuccessAt,
                        failureStreak: c.failureStreak || 0
                    })),
                    count: filtered.length
                };
            }

            getCapability(params) {
                const { capability_id } = params;
                if (!capability_id) {
                    throw new Error('capability_id is required');
                }

                const node = this.findNodeById(capability_id);
                if (!node || node.type !== 'capability') {
                    throw new Error(`Capability not found: ${capability_id}`);
                }

                return node;
            }

            createCapability(params) {
                const { parent_id, name, site, goal, allow, examples, aliases, profileHint, selectors } = params;

                if (!parent_id) throw new Error('parent_id is required');
                if (!name) throw new Error('name is required');
                if (!site) throw new Error('site is required');
                if (!goal) throw new Error('goal is required');

                const parent = this.findNodeById(parent_id);
                if (!parent) throw new Error(`Parent not found: ${parent_id}`);

                // Create capability node using schema
                const capabilityData = {
                    name,
                    site,
                    goal,
                    allow: allow || CAPABILITY_PERMISSIONS_MVP,
                    examples: examples || [],
                    aliases: aliases || [],
                    profileHint: profileHint || null,
                    selectors: selectors || {}
                };

                const validationResult = CAPABILITY_SCHEMA.validate(capabilityData);
                if (!validationResult.valid) {
                    throw new Error(`Invalid capability: ${validationResult.errors.join(', ')}`);
                }

                const newNode = CAPABILITY_SCHEMA.create(capabilityData);

                // Add to parent
                const childKey = parent.children ? 'children' :
                                 parent.items ? 'items' :
                                 parent.subtasks ? 'subtasks' : 'children';

                if (!parent[childKey]) parent[childKey] = [];
                parent[childKey].push(newNode);

                saveState('Create capability: ' + name);
                render();

                return { success: true, node: newNode };
            }

            matchCapability(params) {
                const { intent } = params;
                if (!intent) throw new Error('intent is required');

                const capabilities = findCapabilityNodes(capexTree);
                const match = matchIntentToCapability(intent, capabilities);

                if (!match) {
                    return { found: false, message: 'No matching capability found' };
                }

                return {
                    found: true,
                    capability: {
                        id: match.id,
                        name: match.name,
                        site: match.site,
                        goal: match.goal,
                        allow: match.allow || ['read', 'navigate'],
                        examples: match.examples || [],
                        selectors: match.selectors || {}
                    }
                };
            }

            updateCapabilityStatus(params) {
                const { capability_id, status, failureStreak } = params;

                if (!capability_id) throw new Error('capability_id is required');

                const node = this.findNodeById(capability_id);
                if (!node || node.type !== 'capability') {
                    throw new Error(`Capability not found: ${capability_id}`);
                }

                const validStatuses = ['healthy', 'degraded', 'broken', 'untested'];
                if (status && !validStatuses.includes(status)) {
                    throw new Error(`Invalid status: ${status}. Must be one of: ${validStatuses.join(', ')}`);
                }

                if (status) node.status = status;
                if (typeof failureStreak === 'number') node.failureStreak = failureStreak;
                if (status === 'healthy') {
                    node.lastSuccessAt = new Date().toISOString();
                    node.failureStreak = 0;
                }

                saveState('Update capability status: ' + node.name);
                render();

                return { success: true, node };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RAG Operations (Build 546)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            retrieveContext(params) {
                const {
                    query,
                    max_results = 10,
                    include_context = true,
                    pattern_filter = null,
                    source_filter = null
                } = params;

                if (!query) throw new Error('query is required');

                const results = [];
                const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 1);

                // Recursive search function
                const searchNode = (node, path = [], depth = 0) => {
                    if (!node) return;

                    // Apply pattern filter
                    if (pattern_filter && node.pattern?.key !== pattern_filter) {
                        // Still search children, pattern might be at different levels
                    }

                    // Apply source filter
                    if (source_filter) {
                        const sourceUri = node._rag?.source?.uri || node.sourceUrl || '';
                        const sourceName = node._rag?.source?.name || node.sourceName || '';
                        if (!sourceUri.includes(source_filter) && !sourceName.includes(source_filter)) {
                            // Still search children
                        }
                    }

                    // Build searchable text from node
                    const searchText = [
                        node.name || '',
                        node.title || '',
                        node.description || '',
                        node.content || '',
                        node.summary || ''
                    ].join(' ').toLowerCase();

                    // Calculate relevance based on term matches
                    const matchedTerms = terms.filter(t => searchText.includes(t));
                    const relevance = terms.length > 0 ? matchedTerms.length / terms.length : 0;

                    if (relevance > 0) {
                        // Build context path
                        const contextPath = include_context ? path.map(p => p.name || p.title || 'Untitled') : [];

                        // Extract excerpt around first match
                        let excerpt = node.description || node.content || node.summary || '';
                        if (excerpt.length > 300) {
                            const firstTerm = matchedTerms[0];
                            const idx = excerpt.toLowerCase().indexOf(firstTerm);
                            if (idx > 50) {
                                excerpt = '...' + excerpt.substring(idx - 50, idx + 250) + '...';
                            } else {
                                excerpt = excerpt.substring(0, 300) + '...';
                            }
                        }

                        results.push({
                            nodeId: node.id,
                            name: node.name || node.title || 'Untitled',
                            path: contextPath,
                            pathString: contextPath.length > 0 ? contextPath.join(' > ') : null,
                            excerpt: excerpt,
                            relevance: relevance,
                            matchedTerms: matchedTerms,
                            depth: depth,
                            source: node._rag?.source?.uri || node.sourceUrl || null,
                            type: node.type || null
                        });
                    }

                    // Recurse into children
                    const children = node.children || node.items || node.subtasks || node.subItems || [];
                    children.forEach(child => searchNode(child, [...path, node], depth + 1));
                };

                // Start search from tree root
                searchNode(capexTree);

                // Sort by relevance (descending), then by depth (shallower first)
                results.sort((a, b) => {
                    if (b.relevance !== a.relevance) return b.relevance - a.relevance;
                    return a.depth - b.depth;
                });

                // Limit results
                const topResults = results.slice(0, max_results);

                // Assemble context string for LLM consumption
                let contextString = '';
                topResults.forEach((r, i) => {
                    contextString += `[${i + 1}] ${r.pathString ? r.pathString + ' > ' : ''}${r.name}\n`;
                    if (r.excerpt) {
                        contextString += `${r.excerpt}\n`;
                    }
                    contextString += '\n';
                });

                return {
                    query: query,
                    totalMatches: results.length,
                    results: topResults,
                    context: contextString.trim(),
                    metadata: {
                        termsSearched: terms,
                        maxResults: max_results,
                        includeContext: include_context,
                        patternFilter: pattern_filter,
                        sourceFilter: source_filter
                    }
                };
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MCP Bridge Connection Management
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initMCPBridge(port, token) {
            mcpBridgeState.port = port;
            mcpBridgeState.token = token;
            mcpBridgeState.status = 'connecting';
            updateMCPStatusUI();

            mcpBridgeState.client = new TreeListyMCPClient();
            mcpBridgeState.handler = new TreeListyMCPHandler();

            mcpBridgeState.client.onRequest = async (method, params) => {
                return await mcpBridgeState.handler.handleRequest(method, params);
            };

            mcpBridgeState.client.onConnect = () => {
                mcpBridgeState.status = 'connected';
                updateMCPStatusUI();
                showToast('ğŸ¤– Claude Code connected!', 'success');
            };

            mcpBridgeState.client.onDisconnect = (code, reason) => {
                mcpBridgeState.status = 'disconnected';
                updateMCPStatusUI();
                if (code !== 1000) {
                    showToast('ğŸ¤– Claude Code disconnected', 'warning');
                }
            };

            mcpBridgeState.client.onError = (err) => {
                console.error('[MCP] Connection error:', err);
            };

            // Build 522: Wire up task event handler
            mcpBridgeState.client.onTaskEvent = handleMCPTaskEvent;

            return mcpBridgeState.client.connect(port, token);
        }

        function disconnectMCPBridge() {
            if (mcpBridgeState.client) {
                mcpBridgeState.client.disconnect();
                mcpBridgeState.client = null;
            }
            mcpBridgeState.status = 'disconnected';
            updateMCPStatusUI();
        }

        function updateMCPStatusUI() {
            const btn = document.getElementById('mcp-bridge-btn');
            const startSection = document.getElementById('mcp-start-section');
            const connectedSection = document.getElementById('mcp-connected-section');
            const connectBtn = document.getElementById('mcp-connect-btn');
            const inboxBtn = document.getElementById('inbox-btn'); // Build 522

            const status = mcpBridgeState.status;

            // Update header button
            if (btn) {
                if (status === 'connected') {
                    btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                    btn.textContent = 'ğŸ¤– Claude';
                    btn.title = 'Claude Code connected - click to manage';
                } else if (status === 'connecting') {
                    btn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                    btn.textContent = 'ğŸ¤– ...';
                    btn.title = 'Connecting to Claude Code...';
                } else {
                    btn.style.background = 'linear-gradient(135deg, #6b7280, #4b5563)';
                    btn.textContent = 'ğŸ¤– MCP';
                    btn.title = 'Connect to Claude Code - click to connect';
                }
            }

            // Build 522: Show/hide Inbox button based on connection
            if (inboxBtn) {
                inboxBtn.style.display = (status === 'connected') ? 'inline-flex' : 'none';
                updateInboxUI();
            }

            // Update modal sections
            if (startSection && connectedSection) {
                if (status === 'connected') {
                    startSection.style.display = 'none';
                    connectedSection.style.display = 'block';

                    // Update connection info
                    const portEl = document.getElementById('mcp-connected-port');
                    const tabIdEl = document.getElementById('mcp-connected-tabid');
                    if (portEl) portEl.textContent = mcpBridgeState.port || '--';
                    if (tabIdEl && mcpBridgeState.client) tabIdEl.textContent = mcpBridgeState.client.tabId || '--';

                    // Update activity log
                    updateMCPActivityLog();
                } else {
                    startSection.style.display = 'block';
                    connectedSection.style.display = 'none';
                }
            }

            // Update connect button state
            if (connectBtn) {
                if (status === 'connecting') {
                    connectBtn.disabled = true;
                    connectBtn.innerHTML = '<span style="display: inline-block; animation: spin 1s linear infinite;">â³</span> Connecting...';
                } else {
                    connectBtn.disabled = false;
                    connectBtn.innerHTML = 'ğŸ”— Connect';
                }
            }
        }

        function updateMCPActivityLog() {
            const logEl = document.getElementById('mcp-activity-log');
            if (!logEl) return;

            const logs = mcpBridgeState.activityLog || [];
            if (logs.length === 0) {
                logEl.innerHTML = '<div style="color: var(--text-secondary);">No activity yet...</div>';
                return;
            }

            // Show last 10 entries
            const recentLogs = logs.slice(-10).reverse();
            logEl.innerHTML = recentLogs.map(log => {
                const time = new Date(log.timestamp).toLocaleTimeString();
                return `<div style="padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.05);"><span style="color: #8b5cf6;">${time}</span> <span style="color: #10b981;">${log.method}</span></div>`;
            }).join('');
        }

        function showMCPConnectModal() {
            const modal = document.getElementById('mcp-connect-modal');
            if (modal) {
                modal.style.display = 'flex';
                updateMCPStatusUI();

                // Pre-fill with saved config, current state, or defaults
                const portInput = document.getElementById('mcp-port-input');
                const tokenInput = document.getElementById('mcp-token-input');
                const saved = loadMCPConfig();

                if (portInput) {
                    portInput.value = mcpBridgeState.port || saved?.port || MCP_DEFAULT_PORT;
                }
                if (tokenInput) {
                    tokenInput.value = mcpBridgeState.token || saved?.token || MCP_DEFAULT_TOKEN;
                }
            }
        }

        function connectMCPFromModal() {
            const portInput = document.getElementById('mcp-port-input');
            const tokenInput = document.getElementById('mcp-token-input');

            const port = parseInt(portInput?.value) || MCP_DEFAULT_PORT;
            const token = tokenInput?.value?.trim() || MCP_DEFAULT_TOKEN;

            // Use defaults if empty
            if (!portInput?.value) {
                portInput.value = MCP_DEFAULT_PORT;
            }
            if (!tokenInput?.value) {
                tokenInput.value = MCP_DEFAULT_TOKEN;
            }

            initMCPBridge(port, token).then(() => {
                console.log('[MCP] Connected successfully');
                // Save config for auto-reconnect
                saveMCPConfig(port, token);
                // Clear token input for security
                if (tokenInput) tokenInput.value = '';
            }).catch(err => {
                showToast(`ğŸ¤– Connection failed: ${err.message}`, 'error');
                mcpBridgeState.status = 'disconnected';
                updateMCPStatusUI();
            });
        }

        function disconnectMCPFromModal() {
            disconnectMCPBridge();
            showToast('ğŸ¤– Disconnected from Claude Code', 'info');
        }

        // Expose MCP functions globally
        window.mcpBridgeState = mcpBridgeState;
        window.initMCPBridge = initMCPBridge;
        window.disconnectMCPBridge = disconnectMCPBridge;
        window.showMCPConnectModal = showMCPConnectModal;
        window.connectMCPFromModal = connectMCPFromModal;
        window.disconnectMCPFromModal = disconnectMCPFromModal;
        window.updateMCPActivityLog = updateMCPActivityLog;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MCP Auto-Connect (Build 520)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Silent auto-connect attempt
        async function attemptMCPAutoConnect() {
            // Don't auto-connect if already connected
            if (mcpBridgeState.status === 'connected') {
                return;
            }

            // Check URL params first: ?mcp=auto or ?mcp=port:token
            const urlParams = new URLSearchParams(window.location.search);
            const mcpParam = urlParams.get('mcp');

            let port = MCP_DEFAULT_PORT;
            let token = MCP_DEFAULT_TOKEN;

            if (mcpParam) {
                if (mcpParam === 'auto') {
                    // Use defaults
                    console.log('[MCP] Auto-connect triggered via URL param');
                } else if (mcpParam.includes(':')) {
                    // Parse port:token format
                    const [p, t] = mcpParam.split(':');
                    port = parseInt(p, 10) || MCP_DEFAULT_PORT;
                    token = t || MCP_DEFAULT_TOKEN;
                    console.log('[MCP] Custom config from URL:', port);
                }
            } else {
                // Try saved config, fall back to defaults
                const saved = loadMCPConfig();
                if (saved) {
                    port = saved.port || MCP_DEFAULT_PORT;
                    token = saved.token || MCP_DEFAULT_TOKEN;
                    console.log('[MCP] Using saved config, port:', port);
                } else {
                    console.log('[MCP] Trying default config, port:', port);
                }
            }

            // Attempt silent connection
            mcpBridgeState.status = 'connecting';
            updateMCPStatusUI();

            try {
                mcpBridgeState.client = new TreeListyMCPClient({
                    reconnectOnClose: true,
                    maxReconnectAttempts: 2  // Limited retries for auto-connect
                });
                mcpBridgeState.handler = new TreeListyMCPHandler();

                mcpBridgeState.client.onRequest = async (method, params) => {
                    return await mcpBridgeState.handler.handleRequest(method, params);
                };

                mcpBridgeState.client.onConnect = () => {
                    mcpBridgeState.status = 'connected';
                    mcpBridgeState.port = port;
                    mcpBridgeState.token = token;
                    updateMCPStatusUI();
                    saveMCPConfig(port, token);
                    console.log('[MCP] Auto-connected successfully');
                    // Subtle success indicator - no intrusive toast
                    showToast('ğŸ¤– Claude Code connected', 'success', 2000);
                };

                mcpBridgeState.client.onDisconnect = (code, reason) => {
                    mcpBridgeState.status = 'disconnected';
                    updateMCPStatusUI();
                    // Silent on auto-disconnect, no toast
                };

                mcpBridgeState.client.onError = (err) => {
                    // Silent error for auto-connect
                    console.log('[MCP] Auto-connect failed (bridge not running?)');
                };

                // Build 522: Wire up task event handler
                mcpBridgeState.client.onTaskEvent = handleMCPTaskEvent;

                // Short timeout for auto-connect
                await Promise.race([
                    mcpBridgeState.client.connect(port, token),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 3000))
                ]);

            } catch (err) {
                // Silent failure - bridge probably not running
                console.log('[MCP] Auto-connect skipped:', err.message);
                mcpBridgeState.status = 'disconnected';
                mcpBridgeState.client = null;
                updateMCPStatusUI();
                // No toast, no error - just show disconnected status
            }
        }

        // Override disconnect to clear saved config
        const originalDisconnect = disconnectMCPBridge;
        function disconnectMCPBridgeWithClear() {
            clearMCPConfig();
            originalDisconnect();
        }
        window.disconnectMCPBridge = disconnectMCPBridgeWithClear;

        // Expose auto-connect
        window.attemptMCPAutoConnect = attemptMCPAutoConnect;

        // Initialize MCP button and attempt auto-connect after DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            updateMCPStatusUI();

            // Delay auto-connect slightly to let page settle
            // Works in both browser and PWA mode - PWA can still connect to localhost
            setTimeout(() => {
                attemptMCPAutoConnect();
            }, 1000);
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // IMAGEN 4 - AI IMAGE GENERATION (Build 218)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Image style presets for Imagen 4
        const IMAGEN_STYLES = {
            whiteboard: {
                name: 'ğŸ“ Whiteboard Sketch',
                prompt: 'Hand-drawn cartoon whiteboard sketch style, dry-erase markers on glossy white surface with slight smudges and imperfect lines. Stick-figure characters with expressive faces and speech bubbles. Chunky arrows in blue red and green marker connecting ideas. Key concepts inside wobbly rectangles or circled in red. Doodle icons like lightbulbs gears checkmarks scattered as visual punctuation. Visible marker cap in corner for authenticity. Left-to-right flow with numbered steps and branching paths. Handwritten-style lettering with uneven baselines and occasional ALL-CAPS emphasis. Friendly irreverent tone like a colleague sketching during a brainstorm.',
                description: 'Meeting whiteboard with markers and doodles'
            },
            meeting: {
                name: 'ğŸ¤ Meeting Sketch',
                prompt: 'Whiteboard surface with black marker flowchart boxes connected by curved arrows, bright yellow and pink sticky notes clustered around corners. Bold "START" lettering left side, green checkmark "DONE" right side. Red marker circles highlighting decision points. Simple stick figures drawn pointing upward. Faded coffee ring stain lower right, slightly smudged marker lines, warm fluorescent lighting casting subtle shadows.',
                description: 'Collaborative meeting room style'
            },
            infographic: {
                name: 'ğŸ“Š Infographic',
                prompt: 'Crisp vector graphics with navy blue, teal, and orange color scheme, clean white background with subtle grid lines, geometric bar charts and pie segments, minimalist sans-serif typography, balanced asymmetrical layout with generous white space, sharp edges and perfectly aligned elements, corporate presentation aesthetic',
                description: 'Professional data visualization'
            },
            cartoon: {
                name: 'ğŸ¨ Friendly Cartoon',
                prompt: 'Soft rounded characters with oversized friendly eyes and gentle smiles, painted in warm peach, mint green, and lavender pastels. Smooth brushstroke textures with subtle paper grain, diffused golden lighting creating gentle shadows. Slightly imperfect hand-drawn line quality with organic curves and asymmetrical charm typical of beloved children\'s storybooks.',
                description: 'Approachable cartoon style'
            },
            tech: {
                name: 'ğŸ’» Tech/Digital',
                prompt: 'Deep charcoal to midnight blue gradient background with subtle scan lines, electric cyan and violet neon light strips casting soft glows, sleek matte black surfaces with fingerprint smudges, floating holographic interface panels with slight transparency, cool LED reflections on brushed metal textures, atmospheric depth with gentle light bloom',
                description: 'Futuristic technology theme'
            },
            nature: {
                name: 'ğŸŒ¿ Nature/Organic',
                prompt: 'Soft watercolor washes bleeding into textured paper, warm ochre and sage green pigments, delicate botanical forms with visible brush strokes, gentle morning light filtering through leaves, subtle paper grain texture, hand-painted imperfections with organic edge bleeding, peaceful garden atmosphere with dappled shadows',
                description: 'Natural organic aesthetic'
            },
            minimal: {
                name: 'â¬œ Minimalist',
                prompt: 'Stark white background with vast empty space, single bold geometric shape in muted sage green or charcoal gray, crisp shadow casting subtle depth, pristine surfaces with barely visible texture, soft diffused lighting from above, perfectly aligned elements with breathing room, serene gallery-like atmosphere',
                description: 'Clean minimal design'
            },
            isometric: {
                name: 'ğŸ—ï¸ Isometric 3D',
                prompt: 'Crisp isometric 3D perspective at 30-degree angles, bold saturated colors with subtle gradients, clean geometric shapes casting soft drop shadows on white background, technical blueprint precision with rounded edges, smooth matte surfaces, organized grid composition, bright even lighting like modern mobile game interface',
                description: '3D isometric view'
            },
            academic: {
                name: 'ğŸ“š Academic/Scholarly',
                prompt: 'Detailed copper engraving with fine cross-hatching on aged cream paper, warm sepia and burnt umber tones, crisp black ink lines, subtle paper texture with faint foxing spots, classical diagram layout with numbered annotations, ornate serif typography, soft diffused lighting creating gentle shadows',
                description: 'Traditional scholarly look'
            },
            historical: {
                name: 'ğŸ“œ Historical Photo',
                prompt: 'Photorealistic historical photograph, authentic period-accurate costumes and settings, dramatic chiaroscuro lighting like Rembrandt paintings, rich warm tones with subtle film grain, detailed textures on fabric metal and skin, atmospheric depth with soft background bokeh, museum-quality historical recreation, cinematic composition with natural poses',
                description: 'Realistic historical imagery'
            },
            portrait: {
                name: 'ğŸ–¼ï¸ Classical Portrait',
                prompt: 'Oil painting portrait in the style of Renaissance masters, rich impasto brushwork with visible texture, warm candlelit golden-hour lighting on face, detailed fabric folds and jewelry highlights, subtle sfumato blending on skin tones, dark moody background with vignette, dignified noble composition, museum masterpiece quality',
                description: 'Fine art portrait style'
            },
            documentary: {
                name: 'ğŸ“· Documentary',
                prompt: 'Authentic documentary photography style, natural available light with genuine shadows, candid unstaged moment captured mid-action, shallow depth of field with subject in sharp focus, subtle film grain and slightly desaturated colors, photojournalistic composition, raw emotional authenticity',
                description: 'Authentic documentary look'
            }
        };

        /**
         * Show Imagen 4 modal for generating images from selected nodes
         * @param {Array} nodes - Array of nodes to generate image from
         */
        function showImagenModal(nodes) {
            // Check for Gemini API key
            const geminiKey = localStorage.getItem('gemini_api_key');
            if (!geminiKey) {
                alert('ğŸ”‘ Gemini API key required for image generation.\n\nGo to Settings (ğŸ”‘ button) and add your Gemini API key.');
                return;
            }

            // Get current pattern context
            const pattern = PATTERNS[currentPattern] || PATTERNS.generic;
            const patternName = pattern.name;

            // Generate rich context from nodes
            const nodeContext = nodes.map(n => {
                let text = `${n.icon || 'ğŸ“„'} ${n.name}`;
                if (n.description) text += `: ${n.description}`;
                return text;
            }).join('\n');

            // Build style selector HTML
            const styleOptions = Object.entries(IMAGEN_STYLES).map(([key, style]) =>
                `<button type="button" class="imagen-style-btn" data-style="${key}" title="${style.description}" style="padding: 8px 12px; border: 2px solid var(--border); border-radius: 8px; background: var(--card-bg); color: var(--text-primary); cursor: pointer; font-size: 12px; transition: all 0.2s;">${style.name}</button>`
            ).join('');

            // Remove existing modal
            const existing = document.getElementById('imagen-modal');
            if (existing) existing.remove();

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'imagen-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            modal.innerHTML = `
                <div style="background: var(--card-bg); border-radius: 16px; max-width: 750px; width: 95%; max-height: 90vh; overflow-y: auto; border: 2px solid var(--border); box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);">
                    <div style="padding: 20px 24px; border-bottom: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <h2 style="margin: 0; font-size: 18px; display: flex; align-items: center; gap: 10px;">
                                ğŸŒ Generate Image with Nano Banana
                            </h2>
                            <button id="imagen-close" style="background: transparent; border: none; color: var(--text-secondary); font-size: 24px; cursor: pointer; padding: 4px 8px;">&times;</button>
                        </div>
                    </div>

                    <div style="padding: 20px 24px;">
                        <!-- Node Context -->
                        <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); padding: 14px; border-radius: 10px; margin-bottom: 16px; border-left: 3px solid #6366f1;">
                            <div style="font-weight: 600; margin-bottom: 6px; color: #6366f1; font-size: 12px;">${pattern.icon} ${patternName} â€¢ ${nodes.length} node${nodes.length > 1 ? 's' : ''}</div>
                            <div style="font-size: 12px; color: var(--text-secondary); white-space: pre-line; max-height: 80px; overflow-y: auto; line-height: 1.5;">${nodeContext}</div>
                        </div>

                        <!-- Style Presets -->
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 10px; font-size: 13px;">ğŸ­ Visual Style</label>
                            <div id="imagen-styles" style="display: flex; flex-wrap: wrap; gap: 8px;">
                                ${styleOptions}
                            </div>
                        </div>

                        <!-- AI Enhance Button -->
                        <div style="margin-bottom: 16px;">
                            <button id="imagen-ai-enhance" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                                âœ¨ AI Craft Prompt (uses your selected style + node context)
                            </button>
                        </div>

                        <!-- Prompt Input -->
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 13px;">Image Prompt <span style="font-weight: normal; color: var(--text-secondary);">(15-25 words ideal)</span></label>
                            <textarea id="imagen-prompt" placeholder="Select a style and click 'AI Craft Prompt' for best results..." style="width: 100%; min-height: 80px; padding: 12px; border-radius: 8px; border: 2px solid var(--border); background: var(--card-bg); color: var(--text-primary); font-size: 13px; resize: vertical; line-height: 1.5;"></textarea>
                            <div style="display: flex; justify-content: space-between; margin-top: 6px; font-size: 11px; color: var(--text-secondary);">
                                <span id="imagen-word-count">0 words</span>
                                <span>ğŸ’¡ Tip: Subject first, then style, then lighting</span>
                            </div>
                        </div>

                        <!-- Options Row -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 12px;">ğŸ“ Aspect Ratio</label>
                                <select id="imagen-aspect" style="width: 100%; padding: 10px; border-radius: 8px; border: 2px solid var(--border); background: var(--card-bg); color: var(--text-primary); font-size: 13px;">
                                    <option value="16:9" selected>16:9 (Widescreen)</option>
                                    <option value="1:1">1:1 (Square)</option>
                                    <option value="4:3">4:3 (Standard)</option>
                                    <option value="3:4">3:4 (Portrait)</option>
                                    <option value="9:16">9:16 (Tall)</option>
                                </select>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 12px;">ğŸ–¼ï¸ Model</label>
                                <select id="imagen-model" style="width: 100%; padding: 10px; border-radius: 8px; border: 2px solid var(--border); background: var(--card-bg); color: var(--text-primary); font-size: 13px;">
                                    <option value="gemini-3-flash-preview" selected>ğŸŒ Nano Banana (Gemini 3 Flash)</option>
                                    <option value="gemini-2.0-flash-preview-image-generation">ğŸŒ Nano Banana Legacy (Gemini 2.0)</option>
                                    <option value="imagen-4.0-generate-001">ğŸ¨ Imagen 4 Standard</option>
                                    <option value="imagen-4.0-ultra-generate-001">âœ¨ Imagen 4 Ultra</option>
                                </select>
                            </div>
                        </div>

                        <!-- Resolution (for Nano Banana Pro) -->
                        <div id="imagen-resolution-row" style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 12px;">ğŸ“º Resolution</label>
                            <div style="display: flex; gap: 8px;">
                                <button type="button" class="imagen-res-btn" data-res="1K" style="flex: 1; padding: 8px; border: 2px solid var(--border); border-radius: 8px; background: var(--card-bg); color: var(--text-primary); cursor: pointer; font-size: 12px;">1K</button>
                                <button type="button" class="imagen-res-btn selected" data-res="2K" style="flex: 1; padding: 8px; border: 2px solid #6366f1; border-radius: 8px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2)); color: var(--text-primary); cursor: pointer; font-size: 12px;">2K</button>
                                <button type="button" class="imagen-res-btn" data-res="4K" style="flex: 1; padding: 8px; border: 2px solid var(--border); border-radius: 8px; background: var(--card-bg); color: var(--text-primary); cursor: pointer; font-size: 12px;">4K ($$$)</button>
                            </div>
                        </div>

                        <!-- Generate Button -->
                        <button id="imagen-generate" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 12px; font-size: 15px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸŒ Generate with Nano Banana
                        </button>

                        <!-- Results Container -->
                        <div id="imagen-results" style="margin-top: 20px; display: none;">
                            <div style="font-weight: 600; margin-bottom: 12px; font-size: 14px;">Generated Images <span style="font-weight: normal; color: var(--text-secondary);">(click to preview)</span></div>
                            <div id="imagen-images" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;"></div>
                        </div>

                        <!-- Error Container -->
                        <div id="imagen-error" style="margin-top: 20px; display: none; background: rgba(239, 68, 68, 0.1); padding: 16px; border-radius: 8px; border-left: 3px solid #ef4444; color: #ef4444;"></div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Store selected nodes and style for AI enhance
            modal.dataset.nodeIds = JSON.stringify(nodes.map(n => n.id));
            modal.dataset.selectedStyle = 'whiteboard'; // default

            // Style button click handlers
            const styleButtons = modal.querySelectorAll('.imagen-style-btn');
            styleButtons.forEach(btn => {
                btn.onclick = () => {
                    // Remove selection from all
                    styleButtons.forEach(b => {
                        b.style.background = 'var(--card-bg)';
                        b.style.borderColor = 'var(--border)';
                    });
                    // Select this one
                    btn.style.background = 'linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2))';
                    btn.style.borderColor = '#6366f1';
                    modal.dataset.selectedStyle = btn.dataset.style;
                };
            });

            // Select first style by default
            if (styleButtons.length > 0) {
                styleButtons[0].click();
            }

            // Word count updater
            const promptTextarea = document.getElementById('imagen-prompt');
            const wordCountSpan = document.getElementById('imagen-word-count');
            promptTextarea.oninput = () => {
                const words = promptTextarea.value.trim().split(/\s+/).filter(w => w.length > 0).length;
                wordCountSpan.textContent = `${words} words`;
                wordCountSpan.style.color = words >= 15 && words <= 25 ? '#10b981' : 'var(--text-secondary)';
            };

            // AI Enhance button handler
            document.getElementById('imagen-ai-enhance').onclick = () => aiCraftImagenPrompt(nodes, modal.dataset.selectedStyle);

            // Resolution button handlers
            modal.dataset.selectedRes = '2K'; // default
            const resButtons = modal.querySelectorAll('.imagen-res-btn');
            resButtons.forEach(btn => {
                btn.onclick = () => {
                    resButtons.forEach(b => {
                        b.style.background = 'var(--card-bg)';
                        b.style.borderColor = 'var(--border)';
                    });
                    btn.style.background = 'linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2))';
                    btn.style.borderColor = '#6366f1';
                    modal.dataset.selectedRes = btn.dataset.res;
                };
            });

            // Model change handler - update button text (Build 261: Fixed Imagen 4 models)
            const modelSelect = document.getElementById('imagen-model');
            const generateBtn = document.getElementById('imagen-generate');
            const resolutionRow = document.getElementById('imagen-resolution-row');

            modelSelect.onchange = () => {
                const model = modelSelect.value;
                if (model.includes('gemini-3-flash')) {
                    generateBtn.textContent = 'ğŸŒ Generate with Nano Banana';
                    generateBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                    resolutionRow.style.display = 'none';
                } else if (model.includes('gemini-2.0-flash')) {
                    generateBtn.textContent = 'ğŸŒ Generate with Nano Banana Legacy';
                    generateBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                    resolutionRow.style.display = 'none';
                } else if (model.includes('ultra')) {
                    generateBtn.textContent = 'âœ¨ Generate with Imagen 4 Ultra';
                    generateBtn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
                    resolutionRow.style.display = 'none';
                } else {
                    generateBtn.textContent = 'ğŸ¨ Generate with Imagen 4';
                    generateBtn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
                    resolutionRow.style.display = 'none';
                }
            };
            // Hide resolution row by default (Nano Banana Flash selected)
            resolutionRow.style.display = 'none';

            // Close handlers
            document.getElementById('imagen-close').onclick = () => modal.remove();
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

            // Generate handler
            document.getElementById('imagen-generate').onclick = () => generateImagenImage(nodes);
        }

        /**
         * Use AI to craft an optimized Imagen 4 prompt
         * @param {Array} nodes - Selected nodes
         * @param {string} styleKey - Selected style key
         */
        async function aiCraftImagenPrompt(nodes, styleKey) {
            const style = IMAGEN_STYLES[styleKey] || IMAGEN_STYLES.whiteboard;
            const pattern = PATTERNS[currentPattern] || PATTERNS.generic;
            const enhanceBtn = document.getElementById('imagen-ai-enhance');
            const promptTextarea = document.getElementById('imagen-prompt');

            // Build node context
            const nodeContext = nodes.map(n => {
                let text = n.name;
                if (n.description) text += ` - ${n.description}`;
                if (n.itemType) text += ` (${n.itemType})`;
                return text;
            }).join('; ');

            // Show loading
            enhanceBtn.disabled = true;
            enhanceBtn.innerHTML = 'âœ¨ Crafting prompt...';

            try {
                // Use Gemini to craft the prompt
                const geminiKey = localStorage.getItem('gemini_api_key');
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=${geminiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `You are an expert at writing image generation prompts.

Write ONE complete image prompt (exactly 15-25 words) to visualize this:

SUBJECT: ${nodeContext}
PATTERN: ${pattern.name}
STYLE: ${style.name} - ${style.prompt}

REQUIREMENTS:
1. Start with the main subject/scene description
2. Include visual style keywords from above
3. Add lighting, mood, composition details
4. Must be 15-25 words total
5. Write a COMPLETE sentence, not just a word or name

EXAMPLE FORMAT: "A [subject] in [setting], [style description], [lighting], [mood/atmosphere], [composition details]"

OUTPUT: Write ONLY the prompt. No quotes. No explanation. Just the 15-25 word image prompt.`
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.9,
                            maxOutputTokens: 150,
                            topP: 0.95
                        }
                    })
                });

                const data = await response.json();
                let craftedPrompt = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

                // Remove any quotes that might have been added
                craftedPrompt = craftedPrompt?.replace(/^["']|["']$/g, '');

                if (craftedPrompt) {
                    promptTextarea.value = craftedPrompt;
                    promptTextarea.dispatchEvent(new Event('input')); // Update word count
                    showToast('âœ¨ AI crafted your prompt!');
                } else {
                    throw new Error('No prompt generated');
                }

            } catch (error) {
                console.error('AI prompt craft error:', error);
                // Fallback to a template-based prompt
                const subjects = nodes.map(n => n.name).join(' and ');
                promptTextarea.value = `${subjects} visualized as ${style.name.replace(/[ğŸ“ğŸ“ŠğŸ¨ğŸ’»ğŸŒ¿â¬œğŸ—ï¸ğŸ“š]/g, '').trim()}, ${style.prompt.split(',').slice(0, 3).join(', ')}`;
                promptTextarea.dispatchEvent(new Event('input'));
                showToast('Used template prompt (AI unavailable)');
            } finally {
                enhanceBtn.disabled = false;
                enhanceBtn.innerHTML = 'âœ¨ AI Craft Prompt (uses your selected style + node context)';
            }
        }

        /**
         * Call Nano Banana (Gemini) or Imagen 4 API to generate images
         * @param {Array} nodes - Nodes to potentially attach the image to
         */
        async function generateImagenImage(nodes) {
            const prompt = document.getElementById('imagen-prompt').value.trim();
            const aspectRatio = document.getElementById('imagen-aspect').value;
            const modelId = document.getElementById('imagen-model').value;
            const geminiKey = localStorage.getItem('gemini_api_key');
            const modal = document.getElementById('imagen-modal');
            const resolution = modal?.dataset?.selectedRes || '2K';

            if (!prompt) {
                alert('Please enter an image prompt');
                return;
            }

            const generateBtn = document.getElementById('imagen-generate');
            const resultsDiv = document.getElementById('imagen-results');
            const imagesDiv = document.getElementById('imagen-images');
            const errorDiv = document.getElementById('imagen-error');

            // Determine model type for loading message
            const isNanoBanana = modelId.includes('gemini-3') || modelId.includes('gemini-2.0');
            const loadingText = isNanoBanana ? 'Generating with Nano Banana...' : 'Generating with Imagen 4...';

            // Show loading state
            generateBtn.disabled = true;
            generateBtn.innerHTML = `<span class="spinner" style="border: 2px solid transparent; border-top: 2px solid white; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: inline-block;"></span> ${loadingText}`;
            resultsDiv.style.display = 'none';
            errorDiv.style.display = 'none';

            try {
                let images = [];

                if (isNanoBanana) {
                    // BUILD 317: Nano Banana uses Gemini generateContent endpoint
                    console.log(`ğŸŒ Using Nano Banana model: ${modelId}`);

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${geminiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: `Generate an image: ${prompt}`
                                }]
                            }],
                            generationConfig: {
                                responseModalities: ['TEXT', 'IMAGE']
                            }
                        })
                    });

                    const data = await response.json();
                    console.log('Nano Banana response:', data);

                    if (!response.ok) {
                        throw new Error(data.error?.message || `API error: ${response.status}`);
                    }

                    // Extract images from Gemini response (inline_data format)
                    if (data.candidates && data.candidates[0]?.content?.parts) {
                        data.candidates[0].content.parts.forEach(part => {
                            if (part.inlineData?.data) {
                                images.push(part.inlineData.data);
                            }
                        });
                    }

                    if (images.length === 0) {
                        throw new Error('No images generated. Nano Banana may have declined the prompt. Try a different description.');
                    }
                } else {
                    // Imagen 4 uses predict endpoint
                    console.log(`ğŸ¨ Using Imagen 4 model: ${modelId}`);

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:predict?key=${geminiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            instances: [{ prompt: prompt }],
                            parameters: {
                                sampleCount: 4,
                                aspectRatio: aspectRatio,
                                personGeneration: 'allow_adult'
                            }
                        })
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error?.message || `API error: ${response.status}`);
                    }

                    // Extract images from Imagen 4 response
                    if (!data.predictions || data.predictions.length === 0) {
                        throw new Error('No images generated. Try a different prompt.');
                    }

                    data.predictions.forEach(pred => {
                        if (pred.bytesBase64Encoded) {
                            images.push(pred.bytesBase64Encoded);
                        }
                    });
                }

                // Display images
                imagesDiv.innerHTML = '';
                images.forEach((base64, idx) => {
                    const imgContainer = document.createElement('div');
                    imgContainer.style.cssText = 'position: relative; border-radius: 12px; overflow: hidden; border: 2px solid var(--border); cursor: pointer;';

                    const img = document.createElement('img');
                    img.src = `data:image/png;base64,${base64}`;
                    img.style.cssText = 'width: 100%; height: auto; display: block;';
                    img.alt = `Generated image ${idx + 1}`;

                    // Click image to view full-size
                    img.onclick = (e) => {
                        e.stopPropagation();
                        showImagePreview(base64, prompt, nodes, idx + 1);
                    };

                    // Hover hint
                    const viewHint = document.createElement('div');
                    viewHint.textContent = 'ğŸ” Click to view full size';
                    viewHint.style.cssText = `
                        position: absolute;
                        top: 8px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0,0,0,0.7);
                        color: white;
                        padding: 4px 12px;
                        border-radius: 12px;
                        font-size: 11px;
                        opacity: 0;
                        transition: opacity 0.2s;
                        pointer-events: none;
                    `;

                    // Add "Attach to Node" button
                    const attachBtn = document.createElement('button');
                    attachBtn.textContent = 'ğŸ“ Attach';
                    attachBtn.style.cssText = `
                        position: absolute;
                        bottom: 8px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0,0,0,0.8);
                        color: white;
                        border: none;
                        padding: 6px 14px;
                        border-radius: 20px;
                        font-size: 11px;
                        cursor: pointer;
                        opacity: 0;
                        transition: opacity 0.2s;
                    `;
                    imgContainer.onmouseenter = () => {
                        attachBtn.style.opacity = '1';
                        viewHint.style.opacity = '1';
                    };
                    imgContainer.onmouseleave = () => {
                        attachBtn.style.opacity = '0';
                        viewHint.style.opacity = '0';
                    };

                    attachBtn.onclick = (e) => {
                        e.stopPropagation();
                        attachImageToNode(nodes[0], base64, prompt);
                        const modal = document.getElementById('imagen-modal');
                        if (modal) modal.remove();
                    };

                    imgContainer.appendChild(img);
                    imgContainer.appendChild(viewHint);
                    imgContainer.appendChild(attachBtn);
                    imagesDiv.appendChild(imgContainer);
                });

                resultsDiv.style.display = 'block';

            } catch (error) {
                console.error('Imagen error:', error);
                errorDiv.textContent = `Error: ${error.message}`;
                errorDiv.style.display = 'block';
            } finally {
                generateBtn.disabled = false;
                // Build 261: Restore button text based on selected Imagen 4 model
                const currentModel = document.getElementById('imagen-model').value;
                if (currentModel.includes('ultra')) {
                    generateBtn.innerHTML = 'âœ¨ Generate with Imagen 4 Ultra';
                } else if (currentModel.includes('fast')) {
                    generateBtn.innerHTML = 'âš¡ Generate with Imagen 4 Fast';
                } else {
                    generateBtn.innerHTML = 'ğŸ¨ Generate with Imagen 4';
                }
            }
        }

        /**
         * Attach generated image to a node
         * @param {object} node - The node to attach image to
         * @param {string} base64 - Base64 encoded image data
         * @param {string} prompt - The prompt used to generate the image
         */
        function attachImageToNode(node, base64, prompt) {
            const modelId = document.getElementById('imagen-model')?.value || 'unknown';
            const modelName = modelId.includes('gemini-3') ? 'Nano Banana Pro' :
                             modelId.includes('gemini-2') ? 'Nano Banana' : 'Imagen 4';
            // Store image data in node
            node.generatedImage = {
                data: base64,
                prompt: prompt,
                model: modelName,
                generatedAt: new Date().toISOString()
            };

            // Save state for undo
            if (typeof saveState === 'function') {
                saveState('Attach generated image');
            }

            // Re-render to show image
            if (typeof renderCanvas === 'function') {
                renderCanvas();
            }
            if (typeof renderTree === 'function') {
                renderTree();
            }

            // Show confirmation
            showToast(`ğŸ¨ Image attached to "${node.name}"`);
        }

        /**
         * Show full-size image preview with options to attach or download
         * @param {string} base64 - Base64 encoded image data
         * @param {string} prompt - The prompt used to generate the image
         * @param {Array} nodes - Nodes to potentially attach to
         * @param {number} imageNum - Image number (1-4)
         */
        function showImagePreview(base64, prompt, nodes, imageNum) {
            // Remove existing preview
            const existing = document.getElementById('imagen-preview');
            if (existing) existing.remove();

            const preview = document.createElement('div');
            preview.id = 'imagen-preview';
            preview.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.95);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 10002;
                padding: 20px;
                box-sizing: border-box;
            `;

            preview.innerHTML = `
                <div style="position: absolute; top: 20px; right: 20px; display: flex; gap: 12px;">
                    <button id="preview-download" style="background: #3b82f6; color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
                        ğŸ’¾ Download
                    </button>
                    <button id="preview-attach" style="background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
                        ğŸ“ Attach to Node
                    </button>
                    <button id="preview-close" style="background: #6b7280; color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 14px; cursor: pointer;">
                        âœ• Close
                    </button>
                </div>

                <div style="flex: 1; display: flex; align-items: center; justify-content: center; max-height: calc(100vh - 180px); width: 100%;">
                    <img src="data:image/png;base64,${base64}" style="max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 8px; box-shadow: 0 25px 50px rgba(0,0,0,0.5);" alt="Generated image ${imageNum}">
                </div>

                <div style="position: absolute; bottom: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.8); padding: 16px 20px; border-radius: 12px; max-width: 800px; margin: 0 auto;">
                    <div style="font-size: 12px; color: #9ca3af; margin-bottom: 4px;">Image ${imageNum} â€¢ Imagen 4 â€¢ Prompt:</div>
                    <div style="font-size: 13px; color: white; line-height: 1.5; max-height: 60px; overflow-y: auto;">${prompt}</div>
                </div>
            `;

            document.body.appendChild(preview);

            // Event handlers
            document.getElementById('preview-close').onclick = () => preview.remove();
            preview.onclick = (e) => { if (e.target === preview) preview.remove(); };

            document.getElementById('preview-download').onclick = () => {
                const link = document.createElement('a');
                link.href = `data:image/png;base64,${base64}`;
                link.download = `treelisty-imagen-${Date.now()}.png`;
                link.click();
                showToast('ğŸ’¾ Image downloaded');
            };

            document.getElementById('preview-attach').onclick = () => {
                attachImageToNode(nodes[0], base64, prompt);
                preview.remove();
                const modal = document.getElementById('imagen-modal');
                if (modal) modal.remove();
            };

            // Keyboard shortcuts
            const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                    preview.remove();
                    document.removeEventListener('keydown', handleKeydown);
                }
            };
            document.addEventListener('keydown', handleKeydown);
        }

        /**
         * Show a toast notification
         * @param {string} message - Message to display
         */
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: #10b981;
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10001;
                animation: fadeInUp 0.3s ease;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        /**
         * Show merge modal for incoming edited branch
         * @param {object} branch - The edited branch to potentially merge
         */
        function showMergeBranchModal(branch) {
            const modal = document.getElementById('merge-branch-modal');
            const body = document.getElementById('merge-branch-body');

            // Check if current project matches the source project
            const projectMismatch = capexTree.id !== branch.sourceProjectId &&
                                    capexTree.name !== branch.sourceProjectName;

            // Store branch for later (needed if user loads correct project)
            pendingMergeBranch = branch;

            // If project doesn't match, show warning modal instead
            if (projectMismatch) {
                body.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.1)); padding: 20px; border-radius: 8px; border-left: 3px solid #ef4444; margin-bottom: 20px;">
                            <div style="font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; color: #ef4444; font-size: 16px;">
                                <span>âš ï¸</span> Wrong Project Loaded
                            </div>
                            <p style="color: var(--text-secondary); font-size: 14px; margin: 0 0 12px 0;">
                                This collaboration response was created from a different project. You need to load the original project first.
                            </p>
                        </div>

                        <!-- Project Comparison -->
                        <div style="background: var(--card-bg); padding: 15px; border-radius: 8px; margin-bottom: 16px;">
                            <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 16px; font-size: 13px;">
                                <span style="color: var(--text-secondary);">Expected project:</span>
                                <span style="font-weight: 600; color: #10b981;">"${branch.sourceProjectName}"</span>

                                <span style="color: var(--text-secondary);">Currently loaded:</span>
                                <span style="font-weight: 600; color: #ef4444;">"${capexTree.name}"</span>
                            </div>
                        </div>

                        <!-- Instructions -->
                        <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #6366f1;">
                            <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #6366f1;">
                                <span>ğŸ“‹</span> How to Merge
                            </div>
                            <ol style="margin-left: 20px; color: var(--text-secondary); font-size: 13px; line-height: 1.8;">
                                <li>Close this modal</li>
                                <li>Load the project <strong>"${branch.sourceProjectName}"</strong> (File â†’ Open JSON)</li>
                                <li>Go to <strong>File â†’ Merge Branch</strong> and paste the URL from your email</li>
                                <li>The merge will proceed correctly</li>
                            </ol>
                        </div>

                        <!-- Alternative: Force merge anyway -->
                        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
                            <p style="color: var(--text-secondary); font-size: 12px; margin-bottom: 8px;">
                                <strong>Alternative:</strong> If you want to add these nodes to the current project anyway, you can force the merge.
                                The nodes will be added but may not replace the originals.
                            </p>
                        </div>
                    </div>
                `;

                // Update buttons for mismatch state
                const acceptBtn = document.getElementById('merge-branch-accept');
                if (acceptBtn) {
                    acceptBtn.textContent = 'âš¡ Force Merge Anyway';
                    acceptBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                }

                modal.style.display = 'flex';
                return;
            }

            // Count nodes
            let totalNodes = 0;
            function countNodes(n) {
                totalNodes++;
                if (n.items) n.items.forEach(countNodes);
                if (n.subItems) n.subItems.forEach(countNodes);
                if (n.children) n.children.forEach(countNodes);
            }
            branch.nodes.forEach(countNodes);

            // Build ancestry breadcrumb
            const breadcrumb = branch.ancestry?.map(a =>
                `<span style="display: inline-flex; align-items: center; gap: 4px;">${a.icon || 'ğŸ“„'} ${a.name}</span>`
            ).join(' <span style="color: var(--text-secondary);">â€º</span> ') || 'Root';

            // Build node preview
            const nodePreview = branch.nodes.slice(0, 5).map(n => `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--card-bg); border-radius: 6px; margin-bottom: 6px;">
                    <span>${n.icon || 'ğŸ“„'}</span>
                    <span style="font-weight: 500;">${n.name}</span>
                    <span style="font-size: 11px; color: var(--text-secondary);">(${n.type})</span>
                </div>
            `).join('');

            body.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(217, 119, 6, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #f59e0b; margin-bottom: 20px;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #f59e0b;">
                            <span>ğŸ”€</span> Incoming Collaboration Changes
                        </div>
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 0;">
                            A collaborator has edited your shared branch and sent back changes for you to merge.
                        </p>
                    </div>

                    <!-- Branch Info -->
                    <div style="background: var(--card-bg); padding: 15px; border-radius: 8px; margin-bottom: 16px;">
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 16px; font-size: 13px;">
                            <span style="color: var(--text-secondary);">Original Location:</span>
                            <span>${breadcrumb}</span>

                            <span style="color: var(--text-secondary);">Edited by:</span>
                            <span style="font-family: monospace; font-size: 11px;">${branch.editedBy || 'Unknown'}</span>

                            <span style="color: var(--text-secondary);">Edited at:</span>
                            <span>${branch.editedAt ? new Date(branch.editedAt).toLocaleString() : 'Unknown'}</span>

                            <span style="color: var(--text-secondary);">Nodes:</span>
                            <span>${totalNodes} total</span>
                        </div>
                    </div>

                    <!-- Node Preview -->
                    <div style="margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            ğŸ“¦ Changed Nodes (preview):
                        </div>
                        <div style="max-height: 200px; overflow-y: auto; padding-right: 8px;">
                            ${nodePreview}
                            ${branch.nodes.length > 5 ? `<div style="color: var(--text-secondary); font-size: 12px; padding: 8px;">...and ${branch.nodes.length - 5} more</div>` : ''}
                        </div>
                    </div>

                    <!-- Warning -->
                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #ef4444;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #ef4444;">
                            <span>âš ï¸</span> Merge Warning
                        </div>
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 0;">
                            Merging will <strong>replace</strong> the original nodes at the specified location with the edited versions.
                            This action can be undone using Ctrl+Z.
                        </p>
                    </div>
                </div>
            `;

            // Reset button state (in case previous modal showed mismatch warning)
            const acceptBtn = document.getElementById('merge-branch-accept');
            if (acceptBtn) {
                acceptBtn.textContent = 'âœ… Accept & Merge Changes';
                acceptBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
            }

            modal.style.display = 'flex';
        }

        /**
         * Perform the actual merge of a branch into the tree
         * @param {object} branch - The branch to merge
         */
        function performBranchMerge(branch) {
            if (!branch || !branch.nodes || branch.nodes.length === 0) {
                console.error('âŒ Invalid branch for merge');
                return;
            }

            console.log('ğŸ”€ Starting merge with branch:', branch.branchId);
            console.log('ğŸ”€ Branch nodes:', branch.nodes.map(n => ({ id: n.id, name: n.name, desc: n.description?.substring(0, 30) })));

            // Save undo state
            saveState('Merge collaboration branch');

            // Find the insertion point using ancestry
            const ancestry = branch.ancestry || [];
            let insertionParent = capexTree;

            // Navigate to the parent location
            for (const ancestor of ancestry) {
                if (ancestor.id === capexTree.id) continue; // Skip root

                const found = findNodeInTree(insertionParent, ancestor.id);
                if (found) {
                    insertionParent = found;
                } else {
                    console.warn(`âš ï¸ Could not find ancestor ${ancestor.id}, merging at current level`);
                    break;
                }
            }

            // For each node in the branch, find and replace or add
            for (const incomingNode of branch.nodes) {
                const existingNode = findNodeInTree(capexTree, incomingNode.id);
                console.log('ğŸ”€ Processing:', incomingNode.id, '| existing:', !!existingNode);

                if (existingNode) {
                    console.log('ğŸ”€ Before merge - existing:', existingNode.name, '| desc:', existingNode.description?.substring(0, 30));
                    console.log('ğŸ”€ Incoming:', incomingNode.name, '| desc:', incomingNode.description?.substring(0, 30));

                    // Deep merge: replace all properties from incoming node
                    // This preserves the object reference but updates all content
                    for (const key of Object.keys(existingNode)) {
                        if (key !== 'id') { // Never change ID
                            delete existingNode[key];
                        }
                    }
                    for (const key of Object.keys(incomingNode)) {
                        existingNode[key] = JSON.parse(JSON.stringify(incomingNode[key]));
                    }
                    console.log('ğŸ”€ After merge:', existingNode.name, '| desc:', existingNode.description?.substring(0, 30));
                    console.log(`âœ… Updated existing node: ${incomingNode.name}`);
                } else {
                    // Add as new node to insertion parent
                    if (incomingNode.type === 'phase') {
                        insertionParent.children = insertionParent.children || [];
                        insertionParent.children.push(incomingNode);
                    } else if (incomingNode.type === 'item') {
                        // Find appropriate phase or add to first phase
                        const targetPhase = insertionParent.children?.[0] || insertionParent;
                        targetPhase.items = targetPhase.items || [];
                        targetPhase.items.push(incomingNode);
                    } else {
                        // Subtask - find parent item
                        const parentItem = findParentForSubtask(capexTree, branch.selectedNodeIds);
                        if (parentItem) {
                            parentItem.subItems = parentItem.subItems || [];
                            parentItem.subItems.push(incomingNode);
                        }
                    }
                    console.log(`â• Added new node: ${incomingNode.name}`);
                }
            }

            // Close modal
            document.getElementById('merge-branch-modal').style.display = 'none';
            pendingMergeBranch = null;

            // Clear URL parameter
            window.history.replaceState({}, document.title, window.location.pathname);

            // Re-render
            render();
            if (viewMode === 'canvas') {
                renderCanvas();
            }

            // Show success toast
            showToast('âœ… Changes merged successfully!', 'success');

            console.log('ğŸ”€ Branch merge completed:', branch.branchId);
        }

        /**
         * Find a node in the tree by ID
         * @param {object} node - Starting node
         * @param {string} id - ID to find
         * @returns {object|null} Found node or null
         */
        function findNodeInTree(node, id) {
            if (node.id === id) return node;

            if (node.children) {
                for (const child of node.children) {
                    const found = findNodeInTree(child, id);
                    if (found) return found;
                }
            }
            if (node.items) {
                for (const item of node.items) {
                    const found = findNodeInTree(item, id);
                    if (found) return found;
                }
            }
            if (node.subItems) {
                for (const subItem of node.subItems) {
                    const found = findNodeInTree(subItem, id);
                    if (found) return found;
                }
            }

            return null;
        }

        /**
         * Find parent item for a subtask
         * @param {object} tree - Tree to search
         * @param {string[]} nodeIds - Original node IDs
         * @returns {object|null} Parent item or null
         */
        function findParentForSubtask(tree, nodeIds) {
            // Try to find based on original selection
            // For now, return first item in tree
            if (tree.children?.[0]?.items?.[0]) {
                return tree.children[0].items[0];
            }
            return null;
        }

        /**
         * Show a toast notification
         * @param {string} message - Message to show
         * @param {string} type - 'success', 'error', 'warning'
         */
        function showToast(message, type = 'success') {
            const colors = {
                success: 'linear-gradient(135deg, #10b981, #059669)',
                error: 'linear-gradient(135deg, #ef4444, #dc2626)',
                warning: 'linear-gradient(135deg, #f59e0b, #d97706)'
            };

            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: ${colors[type] || colors.success};
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10001;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            document.body.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        /**
         * Handle branch URL on page load
         * Called from the main URL loading function
         */
        function handleBranchURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const branchParam = urlParams.get('branch');

            if (!branchParam) return false;

            console.log('ğŸ”— Branch URL detected, parsing...');

            const branch = parseBranchFromURL(branchParam);
            if (!branch) {
                showToast('âŒ Invalid branch URL', 'error');
                return false;
            }

            // Determine if this is a response (edited branch) or original share
            if (branch.isResponse) {
                // This is an edited branch being sent back - show merge dialog
                console.log('ğŸ“¥ Received edited branch for merge');
                showMergeBranchModal(branch);
            } else if (isOriginalBranchCreator(branch)) {
                // Creator opened their own branch link - just show info
                showToast('â„¹ï¸ This is your own shared branch', 'warning');
            } else {
                // Collaborator opening branch to edit
                console.log('ğŸ¤ Collaborator opening branch for editing');
                enterBranchEditMode(branch);
            }

            return true;
        }

        // =============================================================================
        // END COLLABORATION
        // =============================================================================

        // Update tree preview - copy working tree to main tree and render in real-time
        function updateWizardPreview() {
            // Copy working tree to main tree
            capexTree = JSON.parse(JSON.stringify(wizardState.workingTree));

            // Render to show real-time updates on the left
            render();

            console.log('âœ… Tree updated in real-time:', {
                name: capexTree.name,
                phases: capexTree.children?.length || 0,
                items: capexTree.children?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0
            });

            return;

            const preview = document.getElementById('wizard-tree-preview');
            const tree = wizardState.workingTree;

            let html = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 10px; color: var(--treeplex-primary); border-bottom: 2px solid var(--treeplex-primary); padding-bottom: 8px;">
                ${tree.icon || 'ğŸŒ³'} ${tree.name || 'Untitled Project'}
            </div>`;

            if (tree.description) {
                html += `<div style="color: var(--text-secondary); margin-bottom: 20px; font-size: 13px; font-style: italic;">
                    ${tree.description}
                </div>`;
            }

            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    // Phase header with background
                    html += `<div style="margin-bottom: 20px; border-left: 3px solid var(--treeplex-primary); padding-left: 12px;">
                        <div style="font-weight: 600; font-size: 14px; color: var(--treeplex-primary); margin-bottom: 8px;">
                            ${phase.icon || 'ğŸ“‹'} ${phase.name}
                            ${phase.subtitle ? `<div style="color: var(--text-secondary); font-weight: 400; font-size: 12px; margin-top: 2px;">${phase.subtitle}</div>` : ''}
                        </div>`;

                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            // Item
                            html += `<div style="margin-left: 15px; margin-bottom: 10px; padding: 8px; background: var(--card-bg-light); border-radius: 6px;">
                                <div style="color: var(--text-primary); font-weight: 500; font-size: 13px;">
                                    ${item.icon || 'ğŸ“„'} ${item.name}
                                </div>`;

                            // Item description
                            if (item.description) {
                                html += `<div style="color: var(--text-secondary); font-size: 11px; margin-top: 4px; margin-left: 20px;">
                                    ${item.description}
                                </div>`;
                            }

                            // Dependencies (if present - for backward compatibility)
                            if (item.dependencies) {
                                // Handle both array and string formats
                                const depText = Array.isArray(item.dependencies)
                                    ? item.dependencies.join(', ')
                                    : item.dependencies;
                                if (depText && depText.length > 0) {
                                    html += `<div style="color: #f59e0b; font-size: 11px; margin-top: 4px; margin-left: 20px;">
                                        âš ï¸ Depends on: ${depText}
                                    </div>`;
                                }
                            }

                            // Subtasks
                            if (item.subtasks && item.subtasks.length > 0) {
                                html += `<div style="margin-left: 20px; margin-top: 6px;">`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    html += `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 3px;">
                                        â–¸ ${subtask.name}${subtask.description ? ': ' + subtask.description : ''}
                                    </div>`;
                                });
                                html += `</div>`;
                            }

                            html += `</div>`; // End item
                        });
                    }

                    html += `</div>`; // End phase
                });
            } else {
                html += `<div style="color: var(--text-secondary); text-align: center; margin-top: 40px; padding: 40px 20px; border: 2px dashed var(--border); border-radius: 8px;">
                    <div style="font-size: 24px; margin-bottom: 10px;">ğŸŒ±</div>
                    <div>Waiting for conversation to start building the tree...</div>
                </div>`;
            }

            preview.innerHTML = html;
        }

        // Finish wizard (old modal button - still kept for compatibility)
        document.getElementById('wizard-done').addEventListener('click', () => {
            // Save state for undo
            saveState('AI Wizard: Apply changes');

            // Apply working tree to main tree (deep copy to prevent reference issues)
            capexTree = JSON.parse(JSON.stringify(wizardState.workingTree));
            currentPattern = wizardState.patternKey;

            // Close modal
            document.getElementById('wizard-modal').style.display = 'none';

            // BUILD 408: Also close Tree Agent if open
            if (typeof closeTreeAgent === 'function') {
                closeTreeAgent(true);
            }

            // Restore chat bubble
            const chatBubbleRestore = document.getElementById('chat-assistant-bubble');
            if (chatBubbleRestore) chatBubbleRestore.style.display = 'flex';

            // Render updated tree
            render();

            console.log('ğŸª„ Wizard complete! Tree applied.');
        });

        // Cancel wizard (old modal button - still kept for compatibility)
        document.getElementById('wizard-cancel').addEventListener('click', () => {
            if (confirm('Are you sure? Your progress will be lost.')) {
                document.getElementById('wizard-modal').style.display = 'none';

                // BUILD 408: Also close Tree Agent if open
                if (typeof closeTreeAgent === 'function') {
                    closeTreeAgent(true);
                }

                // Restore chat bubble
                const chatBubble = document.getElementById('chat-assistant-bubble');
                if (chatBubble) chatBubble.style.display = 'flex';
            }
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 405: LIVE TREE AGENT (Chat Builder Redesign)
        // Floating frame with real-time tree building visualization
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Tree Agent State
        window.treeAgentState = {
            open: false,
            minimized: false,
            position: { x: 20, y: 80 } // Default top-left
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 406: NODE CHANGE TRACKING (Visual Highlighting)
        // Track recently changed nodes for visual feedback in tree view
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Map of nodeId â†’ { type: 'new'|'modified', timestamp: Date.now() }
        window.recentlyChangedNodes = new Map();

        // Track a node as changed
        function trackNodeChange(nodeId, changeType = 'new') {
            if (!nodeId) return;
            window.recentlyChangedNodes.set(nodeId, {
                type: changeType,
                timestamp: Date.now()
            });
            console.log(`âœ¨ Node tracked: ${nodeId} (${changeType})`);
        }
        window.trackNodeChange = trackNodeChange;

        // Check if a node has recent changes (within last 5 seconds)
        function hasRecentChange(nodeId) {
            const change = window.recentlyChangedNodes.get(nodeId);
            if (!change) return null;
            if (Date.now() - change.timestamp > 5000) {
                window.recentlyChangedNodes.delete(nodeId);
                return null;
            }
            return change;
        }
        window.hasRecentChange = hasRecentChange;

        // Clear all tracked changes
        function clearTrackedChanges() {
            window.recentlyChangedNodes.clear();
        }
        window.clearTrackedChanges = clearTrackedChanges;

        // Auto-cleanup old changes every 3 seconds
        setInterval(() => {
            const now = Date.now();
            for (const [nodeId, change] of window.recentlyChangedNodes) {
                if (now - change.timestamp > 5000) {
                    window.recentlyChangedNodes.delete(nodeId);
                }
            }
        }, 3000);

        // Open the Tree Agent frame
        function openTreeAgent(title = 'Building Tree...') {
            const frame = document.getElementById('tree-agent-frame');
            if (!frame) return;

            // Set title
            document.getElementById('agent-title').textContent = title;

            // Reset progress
            document.getElementById('agent-progress-fill').style.width = '0%';
            document.getElementById('agent-progress-text').textContent = '0%';

            // Clear messages
            document.getElementById('agent-messages').innerHTML = '';

            // Show frame
            frame.classList.add('open');
            frame.classList.remove('minimized');
            treeAgentState.open = true;
            treeAgentState.minimized = false;

            // Hide chat bubble to prevent overlap
            const chatBubble = document.getElementById('chat-assistant-bubble');
            if (chatBubble) chatBubble.style.display = 'none';

            console.log('ğŸ¤– Tree Agent opened');
        }
        window.openTreeAgent = openTreeAgent;

        // Close the Tree Agent frame
        function closeTreeAgent(forceClose = false) {
            const frame = document.getElementById('tree-agent-frame');
            if (!frame) return;

            // If active session, confirm close
            if (!forceClose && wizardState?.active && !wizardState?.conversation?.length === 0) {
                if (!confirm('Close the Tree Agent? Your conversation will be preserved.')) {
                    return;
                }
            }

            frame.classList.remove('open', 'minimized');
            treeAgentState.open = false;
            treeAgentState.minimized = false;

            // Restore chat bubble
            const chatBubble = document.getElementById('chat-assistant-bubble');
            if (chatBubble) chatBubble.style.display = 'flex';

            console.log('ğŸ¤– Tree Agent closed');
        }
        window.closeTreeAgent = closeTreeAgent;

        // Toggle minimize state
        function toggleTreeAgentMinimize() {
            const frame = document.getElementById('tree-agent-frame');
            if (!frame || !treeAgentState.open) return;

            treeAgentState.minimized = !treeAgentState.minimized;
            frame.classList.toggle('minimized', treeAgentState.minimized);

            console.log('ğŸ¤– Tree Agent', treeAgentState.minimized ? 'minimized' : 'expanded');
        }
        window.toggleTreeAgentMinimize = toggleTreeAgentMinimize;

        // Add a message to the Tree Agent chat
        function addAgentMessage(role, content, choices = null) {
            const messagesDiv = document.getElementById('agent-messages');
            if (!messagesDiv) return;

            const msgDiv = document.createElement('div');
            msgDiv.className = `agent-message ${role}`;

            // Parse content for [CHOICE:] markers
            let displayContent = content;
            const choiceMatches = content.match(/\[CHOICE:([^\]]+)\]/g);

            if (choiceMatches) {
                displayContent = content.replace(/\[CHOICE:[^\]]+\]/g, '').trim();
            }

            msgDiv.innerHTML = displayContent.replace(/\n/g, '<br>');
            messagesDiv.appendChild(msgDiv);

            // Add choice buttons if present
            if (choiceMatches && choiceMatches.length > 0) {
                // Remove any existing choices
                const existingChoices = messagesDiv.parentElement.querySelector('.agent-choices');
                if (existingChoices) existingChoices.innerHTML = '';

                // Create choice container if it doesn't exist
                let choicesDiv = messagesDiv.parentElement.querySelector('.agent-choices');
                if (!choicesDiv) {
                    choicesDiv = document.createElement('div');
                    choicesDiv.className = 'agent-choices';
                    messagesDiv.parentElement.insertBefore(choicesDiv, messagesDiv.nextSibling);
                }

                choiceMatches.forEach(match => {
                    const label = match.replace('[CHOICE:', '').replace(']', '');
                    const btn = document.createElement('button');
                    btn.className = 'agent-choice-btn';
                    btn.textContent = label;
                    btn.addEventListener('click', () => {
                        // Handle choice selection
                        handleAgentChoice(label);
                    });
                    choicesDiv.appendChild(btn);
                });
            }

            // Auto-scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        window.addAgentMessage = addAgentMessage;

        // Handle choice selection in Tree Agent
        function handleAgentChoice(choice) {
            // Add user message showing the choice
            addAgentMessage('user', choice);

            // Clear choice buttons
            const choicesDiv = document.querySelector('#tree-agent-frame .agent-choices');
            if (choicesDiv) choicesDiv.innerHTML = '';

            // Forward to wizard handler if active
            if (wizardState?.active) {
                handleWizardChoice(choice);
            }
        }
        window.handleAgentChoice = handleAgentChoice;

        // Update Tree Agent progress
        function updateAgentProgress(percent, text = null) {
            const fill = document.getElementById('agent-progress-fill');
            const textEl = document.getElementById('agent-progress-text');
            if (fill) fill.style.width = `${percent}%`;
            if (textEl) textEl.textContent = text || `${Math.round(percent)}%`;
        }
        window.updateAgentProgress = updateAgentProgress;

        // Tree Agent event listeners
        // BUILD 418: Defer event listener attachment until ALL elements exist
        function initAgentEventListeners() {
            // Check for the LAST element in the frame to ensure all are ready
            const finishBtn = document.getElementById('agent-finish-btn');
            if (!finishBtn) {
                // Elements not ready yet, defer
                setTimeout(initAgentEventListeners, 100);
                return;
            }

            document.getElementById('agent-minimize-btn')?.addEventListener('click', toggleTreeAgentMinimize);
            document.getElementById('agent-close-btn')?.addEventListener('click', () => closeTreeAgent(false));

            document.getElementById('agent-cancel-btn')?.addEventListener('click', () => {
                if (confirm('Cancel the current session? Your progress will be lost.')) {
                    closeTreeAgent(true);
                    // Reset wizard state
                    if (wizardState) wizardState.active = false;
                }
            });

            document.getElementById('agent-finish-btn')?.addEventListener('click', () => {
                if (wizardState?.workingTree) {
                    // Save state for undo
                    saveState('Tree Agent: Apply changes');

                    // Apply working tree to main tree
                    capexTree = JSON.parse(JSON.stringify(wizardState.workingTree));
                    currentPattern = wizardState.patternKey || currentPattern;

                    // Close agent
                    closeTreeAgent(true);

                    // Reset wizard state
                    if (wizardState) wizardState.active = false;

                    // Render updated tree
                    render();

                    showToast('âœ… Tree changes applied!', 'success');
                    console.log('ğŸ¤– Tree Agent: Changes applied');
                } else {
                    closeTreeAgent(true);
                }
            });

            console.log('ğŸ¤– Tree Agent event listeners attached');
        }
        initAgentEventListeners();

        // Send button handler - also deferred
        function initAgentSendButton() {
            const sendBtn = document.getElementById('agent-send-btn');
            if (!sendBtn) {
                setTimeout(initAgentSendButton, 100);
                return;
            }
            sendBtn.addEventListener('click', () => {
                const input = document.getElementById('agent-input');
                if (input && input.value.trim()) {
                    const text = input.value.trim();
                    input.value = '';

                    // Add user message
                    addAgentMessage('user', text);

                    // Forward to wizard if active
                    if (wizardState?.active) {
                        handleWizardChoice(text);
                    }
                }
            });

            // Enter key handler
            document.getElementById('agent-input')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    document.getElementById('agent-send-btn')?.click();
                }
            });

            // Voice input button (placeholder for future implementation)
            document.getElementById('agent-voice-btn')?.addEventListener('click', () => {
                showToast('ğŸ¤ Voice input coming soon!', 'info');
            });

            console.log('ğŸ¤– Tree Agent send button initialized');
        }
        initAgentSendButton();

        // BUILD 427: Initialize Debate Mode
        initDebatePanel();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 407: DRAGGABLE AGENT FRAME + POSITION PERSISTENCE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Load saved position from localStorage
        function loadAgentPosition() {
            try {
                const saved = localStorage.getItem('treeAgentPosition');
                if (saved) {
                    const pos = JSON.parse(saved);
                    treeAgentState.position = pos;
                    const frame = document.getElementById('tree-agent-frame');
                    if (frame) {
                        frame.style.left = `${pos.x}px`;
                        frame.style.top = `${pos.y}px`;
                    }
                }
            } catch (e) {
                console.log('Could not load agent position:', e);
            }
        }

        // Save position to localStorage
        function saveAgentPosition() {
            try {
                localStorage.setItem('treeAgentPosition', JSON.stringify(treeAgentState.position));
            } catch (e) {
                console.log('Could not save agent position:', e);
            }
        }

        // Reset position to default
        function resetAgentPosition() {
            treeAgentState.position = { x: 20, y: 80 };
            const frame = document.getElementById('tree-agent-frame');
            if (frame) {
                frame.style.left = '20px';
                frame.style.top = '80px';
            }
            saveAgentPosition();
            showToast('ğŸ“ Position reset', 'info');
        }
        window.resetAgentPosition = resetAgentPosition;

        // Make the agent frame draggable
        // BUILD 417: Defer initialization until DOM is ready (element is at end of HTML)
        function initAgentDrag() {
            const frame = document.getElementById('tree-agent-frame');
            const header = frame?.querySelector('.agent-header');
            if (!frame || !header) {
                // Element not yet in DOM, retry after a short delay
                console.log('ğŸ¤– Tree Agent frame not ready, deferring drag init...');
                setTimeout(initAgentDrag, 100);
                return;
            }

            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            header.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on buttons
                if (e.target.closest('.agent-btn')) return;

                isDragging = true;
                dragOffset.x = e.clientX - frame.offsetLeft;
                dragOffset.y = e.clientY - frame.offsetTop;
                frame.style.transition = 'none';
                header.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const newX = Math.max(0, Math.min(window.innerWidth - frame.offsetWidth, e.clientX - dragOffset.x));
                const newY = Math.max(0, Math.min(window.innerHeight - frame.offsetHeight, e.clientY - dragOffset.y));

                frame.style.left = `${newX}px`;
                frame.style.top = `${newY}px`;
                treeAgentState.position = { x: newX, y: newY };
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    frame.style.transition = '';
                    header.style.cursor = 'grab';
                    saveAgentPosition();
                }
            });

            // Double-click to reset position
            header.addEventListener('dblclick', (e) => {
                if (e.target.closest('.agent-btn')) return;
                resetAgentPosition();
            });

            // Touch support for mobile
            header.addEventListener('touchstart', (e) => {
                if (e.target.closest('.agent-btn')) return;
                const touch = e.touches[0];
                isDragging = true;
                dragOffset.x = touch.clientX - frame.offsetLeft;
                dragOffset.y = touch.clientY - frame.offsetTop;
                frame.style.transition = 'none';
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const newX = Math.max(0, Math.min(window.innerWidth - frame.offsetWidth, touch.clientX - dragOffset.x));
                const newY = Math.max(0, Math.min(window.innerHeight - frame.offsetHeight, touch.clientY - dragOffset.y));
                frame.style.left = `${newX}px`;
                frame.style.top = `${newY}px`;
                treeAgentState.position = { x: newX, y: newY };
            }, { passive: true });

            document.addEventListener('touchend', () => {
                if (isDragging) {
                    isDragging = false;
                    frame.style.transition = '';
                    saveAgentPosition();
                }
            });

            // Load saved position on init
            loadAgentPosition();

            console.log('ğŸ¤– BUILD 407: Draggable agent frame initialized');
        }
        // Start the deferred initialization
        initAgentDrag();

        console.log('ğŸ¤– BUILD 405-407: Tree Agent fully initialized');

        // Auto-Enhance: Run AI Review then enhance tree automatically
        async function runAutoEnhance() {
            // Check if tree has content
            if (!hasExistingContent()) {
                alert('âš ï¸ Your tree is empty.\n\nPlease add some content first, then use Auto-Enhance.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            try {
                // Open wizard modal first
                document.getElementById('wizard-modal').style.display = 'flex';

                // Hide chat bubble to prevent overlap with modal buttons
                const chatBubble = document.getElementById('chat-assistant-bubble');
                if (chatBubble) chatBubble.style.display = 'none';

                // Show loading state in wizard
                const chatHistory = document.getElementById('wizard-chat-history');
                chatHistory.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">ğŸ” Step 1/2: Analyzing your tree for improvements...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Using your preferred AI model for review</p>
                    </div>
                `;

                // Step 1: Run AI Review to get suggestions
                const pattern = PATTERNS[currentPattern];
                const tree = capexTree;
                const reviewPrompt = buildReviewPrompt(tree, pattern);

                // Get current AI mode (respect user's choice of Gemini or ChatGPT)
                const currentAIMode = document.getElementById('unified-ai-mode-select').value;

                // Use user's selected model for review
                const reviewExperts = {
                    philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments. Review for logical validity, premise strength, and dialectical completeness.',
                    sales: 'You are a sales strategist with 20 years of enterprise B2B experience. Review for pipeline health, deal qualification, and revenue optimization.',
                    thesis: 'You are an academic advisor helping graduate students structure rigorous research. Review for argument progression, citation quality, and scholarly standards.',
                    roadmap: 'You are a product manager experienced in agile development and feature prioritization. Review for execution readiness, story completeness, and technical feasibility.',
                    prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude, GPT-4, and other LLMs. Review for prompt clarity, few-shot example quality, output format specification, and edge case handling.',
                    book: 'You are a professional fiction editor and writing coach. Review for narrative flow, character development, and pacing.',
                    film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway). Review for visual storytelling, shot composition, and production feasibility.',
                    course: 'You are an instructional designer with expertise in curriculum development. Review for learning progression, assessment alignment, and instructional scaffolding.',
                    dialogue: 'You are a debate coach and rhetoric expert specializing in argumentation theory, logical fallacies, and persuasive communication. Review for argument strength, rhetorical effectiveness, fallacy identification, and evidence quality.',
                    generic: `You are an expert ${pattern.name} analyst. Review the provided tree structure for completeness, redundancies, logical flow, and alignment with ${pattern.name} best practices.`
                };

                const expertPersona = reviewExperts[currentPattern] || reviewExperts.generic;

                console.log(`ğŸ”„ Auto-Enhance: Running AI Review with ${currentAIMode}...`);

                const reviewResponse = await callClaudeAPI(
                    reviewPrompt,
                    expertPersona + ' Provide specific, actionable suggestions.',
                    4096,
                    false // No extended thinking for faster review
                );

                // Extract improvements section
                const improvements = extractSection(reviewResponse, 'IMPROVEMENTS');

                if (!improvements) {
                    alert('âŒ No improvements were suggested.\n\nYour tree appears complete!');
                    document.getElementById('wizard-modal').style.display = 'none';
                    // Restore chat bubble
                    const chatBubble = document.getElementById('chat-assistant-bubble');
                    if (chatBubble) chatBubble.style.display = 'flex';
                    return;
                }

                console.log('âœ… Got improvements:', improvements.substring(0, 200) + '...');

                // Step 2: Start wizard in enhance mode with improvements
                chatHistory.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">âœ¨ Step 2/2: Starting enhancement wizard...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Using Sonnet for high-quality enhancements</p>
                    </div>
                `;

                // Force Sonnet for wizard enhancements (better quality)
                const originalAIMode = currentAIMode;
                document.getElementById('unified-ai-mode-select').value = 'server-sonnet';

                // Start wizard in enhance mode
                await startWizard(true); // true = enhance mode

                // Restore original AI mode selection
                document.getElementById('unified-ai-mode-select').value = originalAIMode;

                // Automatically send improvements as first message
                setTimeout(() => {
                    const userInput = document.getElementById('wizard-user-input');
                    const sendBtn = document.getElementById('wizard-send');

                    userInput.value = improvements;
                    sendBtn.click();
                }, 500);

                console.log('ğŸ”„ Auto-Enhance workflow started successfully!');

            } catch (error) {
                console.error('âŒ Auto-Enhance error:', error);
                alert(`âŒ Auto-Enhance failed:\n\n${error.message}`);

                // Clear loading state and close modal
                document.getElementById('wizard-chat-history').innerHTML = '';
                document.getElementById('wizard-modal').style.display = 'none';
                // Restore chat bubble
                const chatBubble = document.getElementById('chat-assistant-bubble');
                if (chatBubble) chatBubble.style.display = 'flex';
            }
        }

        // Toolbar button handler
        document.getElementById('auto-enhance-btn').addEventListener('click', runAutoEnhance);

        // Wizard footer button handler
        document.getElementById('wizard-auto-enhance').addEventListener('click', runAutoEnhance);

        // =============================================================================
        // GENERATE PROMPT SYSTEM
        // =============================================================================

        // Generate Prompt button
        document.getElementById('generate-prompt-btn').addEventListener('click', () => {
            const promptText = generatePromptFromTree();

            // Some patterns (like film) handle display asynchronously via style selectors
            // and return null - don't show modal in that case
            if (promptText !== null && promptText !== undefined) {
                document.getElementById('generated-prompt-text').value = promptText;
                document.getElementById('generate-prompt-modal').style.display = 'flex';
            }
            // If null, the pattern is handling its own display logic (e.g., style selector first)
        });

        // Close prompt modal
        document.getElementById('close-prompt-modal').addEventListener('click', () => {
            document.getElementById('generate-prompt-modal').style.display = 'none';
        });

        // Copy prompt to clipboard
        document.getElementById('copy-prompt-btn').addEventListener('click', async () => {
            const textArea = document.getElementById('generated-prompt-text');
            try {
                await navigator.clipboard.writeText(textArea.value);
                const successMsg = document.getElementById('copy-success-message');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                textArea.select();
                document.execCommand('copy');
                const successMsg = document.getElementById('copy-success-message');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            }
        });

        // Generate prompt from tree structure
        function generatePromptFromTree() {
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;
            const tree = capexTree;

            let prompt = '';

            // Header based on pattern
            if (currentPattern === 'prompting') {
                prompt += generateAIPromptDesignPrompt(tree, pattern);
            } else {
                prompt += generateGenericPrompt(tree, pattern);
            }

            return prompt;
        }

        // Generate EXECUTABLE AI Prompt (not meta-description)
        // Synthesizes tree into ONE complete, copy-paste ready prompt
        function generateAIPromptDesignPrompt(tree, pattern) {
            // Collect all items to synthesize into one unified prompt
            const allItems = [];
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach(item => {
                            allItems.push({ ...item, phaseName: phase.name });
                        });
                    }
                });
            }

            if (allItems.length === 0) {
                return `*No prompts defined yet. Add items to your tree.*\n`;
            }

            // Extract components from first item (primary prompt)
            const firstItem = allItems[0];
            const systemPrompts = allItems.map(item => item.systemPrompt).filter(sp => sp && sp.length > 0);
            const userTemplates = allItems.map(item => item.userPromptTemplate).filter(ut => ut && ut.length > 0);
            const exampleItems = allItems.filter(item => item.fewShotExamples && item.fewShotExamples.length > 0);
            const formatItems = allItems.filter(item => item.outputFormat && item.outputFormat.length > 0);
            const cotItems = allItems.filter(item => item.chainOfThought && item.chainOfThought.length > 0);
            const structuralItems = allItems.filter(item => item.structuralTags && item.structuralTags.length > 0);

            // Build CLEAN EXECUTABLE prompt (no meta-instructions, just the raw prompt)
            let actualPrompt = '';

            // Add system context at the top (like a system message)
            if (systemPrompts.length > 0) {
                actualPrompt += `${systemPrompts[0]}\n\n---\n\n`;
            }

            // Add the main user instruction
            if (userTemplates.length > 0) {
                actualPrompt += userTemplates[0];
            } else {
                actualPrompt += `${tree.description || tree.name}`;
            }

            // Add few-shot examples inline if present
            if (exampleItems.length > 0) {
                actualPrompt += `\n\nHere are examples of the expected behavior:\n\n`;
                actualPrompt += exampleItems[0].fewShotExamples;
            }

            // Add output format specification
            if (formatItems.length > 0) {
                actualPrompt += `\n\n${formatItems[0].outputFormat}`;
            }

            // Add chain-of-thought instructions
            if (cotItems.length > 0) {
                actualPrompt += `\n\n${cotItems[0].chainOfThought}`;
            }

            // Add structural tags if present (Anthropic XML patterns)
            if (structuralItems.length > 0) {
                actualPrompt += `\n\n${structuralItems[0].structuralTags}`;
            }

            // RETURN CLEAN PROMPT - Ready to paste directly into AI chat
            // No markdown, no explanations, no meta-instructions
            return actualPrompt;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 122: TWO-STYLE VIDEO PROMPT GENERATOR
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Feature: Generate AI video prompts in two styles:
        //   1. Explainer/Documentary - Clean, educational, logical
        //   2. Narrative/Story - Character-driven, emotional, hero's journey
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function generateAIVideoPrompts(tree, pattern, style = null) {
            // If no style specified, show style selector and return
            if (!style) {
                showVideoStyleSelector((selectedStyle) => {
                    const prompt = generateAIVideoPrompts(tree, pattern, selectedStyle);
                    // Show the prompt in the modal (consistent with other patterns)
                    document.getElementById('generated-prompt-text').value = prompt;
                    document.getElementById('generate-prompt-modal').style.display = 'flex';
                });
                return null; // Will be called again with style
            }

            // 1. Determine the 'Hero' of the story (for Narrative mode)
            const hero = findProjectHero(tree);

            let output = `# ${tree.icon || 'ğŸ¬'} ${tree.name || 'Video Production'}\n\n`;
            output += `**Style:** ${style === 'narrative' ? 'ğŸ­ Narrative / Story Mode' : 'ğŸ“Š Explainer / Documentary Mode'}\n`;
            output += `**Format:** Copy-paste ready for Sora / Veo / Runway\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Hero info for narrative mode
            if (style === 'narrative') {
                output += `**Hero:** ${hero}\n`;
                output += `**Story Arc:** Three-act structure following the project completion journey\n\n`;
            }

            output += `---\n\n`;

            // Process Phases/Acts
            if (tree.children && tree.children.length > 0) {
                let previousScene = null;

                tree.children.forEach((phase, phaseIdx) => {
                    // Map Phase to Story Act (for narrative)
                    const actLabel = getStoryActLabel(phaseIdx, tree.children.length);

                    output += `## ${phase.name}`;
                    if (style === 'narrative') {
                        output += ` (${actLabel})`;
                    } else {
                        output += ` (Phase ${phaseIdx + 1})`;
                    }
                    output += `\n\n`;

                    if (phase.subtitle || phase.description) {
                        output += `*${phase.subtitle || phase.description}*\n\n`;
                    }

                    // Process Items/Scenes
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            const sceneNumber = `${phaseIdx + 1}.${itemIdx + 1}`;

                            // Generate the prompt based on style
                            const promptText = style === 'narrative'
                                ? synthesizeNarrativePrompt(item, hero, actLabel, previousScene)
                                : synthesizeExplainerPrompt(item);

                            output += `### Scene ${sceneNumber}: ${item.name}\n\n`;
                            output += `**Platform:** ${item.aiPlatform || 'Sora (OpenAI)'}\n\n`;
                            output += `**Prompt:**\n\`\`\`\n${promptText}\n\`\`\`\n\n`;

                            // Technical specs
                            const specs = [];
                            if (item.duration) specs.push(`Duration: ${item.duration}`);
                            if (item.aspectRatio) specs.push(`Aspect: ${item.aspectRatio}`);
                            if (item.visualStyle) specs.push(`Style: ${item.visualStyle}`);
                            if (specs.length > 0) {
                                output += `**Tech:** ${specs.join(' â€¢ ')}\n\n`;
                            }

                            output += `---\n\n`;

                            // Store for continuity
                            previousScene = item;
                        });
                    }
                });
            }

            // Usage instructions
            output += `\n## ğŸ“‹ Usage Instructions\n\n`;
            output += `1. Copy the prompt text (inside the code block)\n`;
            output += `2. Paste into your AI video platform:\n`;
            output += `   - **Sora** (OpenAI): Best for photorealistic, cinematic shots\n`;
            output += `   - **Veo 3** (Google): Great for consistent styles, longer clips\n`;
            output += `   - **Runway Gen-3**: Fast iteration, good for prototyping\n`;
            output += `   - **Pika 2.0**: Stylized, artistic effects\n`;
            output += `3. Adjust technical settings (duration, aspect ratio) as specified\n`;
            output += `4. Generate and review results\n`;
            output += `5. Iterate: Use the Notes section to refine prompts\n\n`;

            output += `---\n\n`;
            output += `**ğŸ’¡ Pro Tip:** ${style === 'narrative'
                ? 'Narrative videos work best for marketing, storytelling, and emotional connection. Consider adding background music and voiceover narration!'
                : 'Explainer videos work best for investor presentations, team onboarding, and educational content. Keep pacing consistent and visuals clean!'
            }\n`;

            return output;
        }

        // Helper: Find the Hero (Main Character)
        function findProjectHero(tree) {
            // Strategy 1: Find most frequently assigned person
            const assignees = {};

            function traverseTree(node) {
                if (node.pmAssignee && node.pmAssignee !== 'Unassigned') {
                    assignees[node.pmAssignee] = (assignees[node.pmAssignee] || 0) + 1;
                }
                if (node.children) {
                    node.children.forEach(child => traverseTree(child));
                }
                if (node.items) {
                    node.items.forEach(item => traverseTree(item));
                }
                if (node.subItems || node.subtasks) {
                    (node.subItems || node.subtasks).forEach(sub => traverseTree(sub));
                }
            }

            traverseTree(tree);

            // Return most frequent assignee
            const sorted = Object.entries(assignees).sort((a, b) => b[1] - a[1]);
            if (sorted.length > 0) return sorted[0][0];

            // Strategy 2: Extract name from descriptions
            function getAllText(node) {
                let text = (node.name || '') + ' ' + (node.description || '');
                if (node.children) {
                    node.children.forEach(child => text += ' ' + getAllText(child));
                }
                if (node.items) {
                    node.items.forEach(item => text += ' ' + getAllText(item));
                }
                return text;
            }

            const allText = getAllText(tree);
            const nameMatch = allText.match(/\b([A-Z][a-z]+ [A-Z][a-z]+)\b/);
            if (nameMatch) return nameMatch[1];

            // Strategy 3: Use tree owner or default
            return tree.owner || tree.createdBy || "The Project Lead";
        }

        // Helper: Map Phases to Story Acts
        function getStoryActLabel(index, total) {
            if (total <= 1) return "The Journey";
            const position = index / (total - 1);
            if (position < 0.4) return "Act I: The Challenge";
            if (position < 0.75) return "Act II: The Struggle";
            return "Act III: The Triumph";
        }

        // Style 1: Explainer / Documentary
        function synthesizeExplainerPrompt(item) {
            const visualSubject = item.name;
            const details = item.description || "Project details";

            // Financial context
            let financialGraphic = "";
            if (item.cost) {
                const costM = (item.cost / 1000000).toFixed(1);
                financialGraphic = `Budget graphic showing $${costM}M overlaid on screen.`;
            } else if (item.dealValue) {
                const valueM = (item.dealValue / 1000000).toFixed(1);
                financialGraphic = `Deal value of $${valueM}M displayed as infographic.`;
            } else if (item.investment) {
                const investM = (item.investment / 1000000).toFixed(1);
                financialGraphic = `Investment: $${investM}M shown in clean typography.`;
            }

            // Timeline context
            let timelineGraphic = "";
            if (item.leadTime) {
                timelineGraphic = `Timeline graphic animating: ${item.leadTime}.`;
            } else if (item.engineeringEstimate) {
                timelineGraphic = `Duration overlay: ${item.engineeringEstimate}.`;
            } else if (item.duration) {
                timelineGraphic = `Timeline: ${item.duration}.`;
            }

            // Location/Setting
            let setting = "Modern office environment or construction site";
            if (item.location) {
                setting = item.location;
            } else if (details.toLowerCase().includes('office')) {
                setting = "Modern glass office with city view";
            } else if (details.toLowerCase().includes('site') || details.toLowerCase().includes('land')) {
                setting = "Construction site or development location";
            } else if (details.toLowerCase().includes('lab') || details.toLowerCase().includes('research')) {
                setting = "Clean research laboratory";
            }

            return `Style: High-end Corporate Documentary. Photorealistic. 8k resolution.
Shot: Slow tracking shot or aerial drone view establishing the scope.
Subject: ${visualSubject}.
Action: ${details}. The visualization builds itself on screen with clean architectural lines.
Overlay Graphics: ${financialGraphic} ${timelineGraphic}
Setting: ${setting}.
Lighting: Bright, clean, clinical, "Apple store" aesthetic with soft shadows.
Mood: Competent, organized, futuristic, inspiring confidence.
Camera: Steady, professional gimbal movement. Wide to medium shots.`;
        }

        // Style 2: Narrative / Story
        function synthesizeNarrativePrompt(item, hero, act, previousScene) {
            const action = item.description || "working on the task";

            // Get dynamic mood based on context
            const moodData = getNarrativeMood(item, act);
            const mood = moodData.mood;
            const lighting = moodData.lighting;

            // Get appropriate setting
            const setting = getNarrativeSetting(item, act);

            // Emotional stakes
            const stakes = getEmotionalStakes(item);

            // Continuity from previous scene
            let continuity = "";
            if (previousScene) {
                continuity = `\nContinuity: Previous scene: "${previousScene.name}". This scene shows the consequence/progress of that action.`;
            }

            // Character details
            const characterDesc = `${hero} (30s-40s, professional, determined expression)`;

            return `Style: Cinematic Movie Scene. Anamorphic lens. Film grain.
Character: ${characterDesc}
Setting: ${setting}
Action: ${hero} is ${action}. ${mood}. ${stakes}${continuity}
Detail: Close-up on ${hero}'s face showing ${getEmotionalExpression(mood)}. Show determination and professionalism.
Lighting: ${lighting}. Cinematic contrast with dramatic shadows.
Mood: ${mood}. High stakes atmosphere.
Camera: Dynamic - Start wide, dolly in to close-up, or handheld for intensity.`;
        }

        // Helper: Dynamic Mood Detection
        function getNarrativeMood(item, act) {
            let mood = "Determined and focused";
            let lighting = "Natural daylight through windows";

            // Act-based default
            if (act.includes("Challenge")) {
                mood = "Optimistic but focused, ready to take on the world";
                lighting = "Morning sun streaming through windows, golden and hopeful";
            } else if (act.includes("Struggle")) {
                mood = "Stressed, high stakes, late night problem-solving";
                lighting = "Dark office, blue screen glow, single desk lamp, shadows";
            } else if (act.includes("Triumph")) {
                mood = "Relieved, celebratory, breakthrough moment";
                lighting = "Golden hour, warm sunset, victorious warm tones";
            }

            // Override with cost/value signals (high stakes)
            const monetaryValue = item.cost || item.dealValue || item.investment || 0;
            if (monetaryValue > 10000000) {
                mood = "Extreme pressure, multi-million dollar stakes, intense focus";
                lighting = "Dramatic boardroom lighting, spotlight effect, high contrast";
            } else if (monetaryValue > 5000000) {
                mood = "High pressure, massive responsibility, calculated decisions";
                lighting = "Serious office lighting, professional intensity";
            }

            // Override with status signals (crisis)
            if (item.pmStatus === 'Blocked' || item.pmBlockingIssue) {
                mood = "Crisis mode, urgent problem-solving, racing against time";
                lighting = "Harsh fluorescent, emergency meeting, red alert tones";
            }

            // Override with risk signals
            if (item.technicalRisk === 'High' || item.riskLevel === 'high') {
                mood = "Cautious, careful analysis, aware of dangers";
                lighting = "Moody, dramatic shadows, tension in the frame";
            }

            // Dependencies = coordination stress
            if (item.dependencies && item.dependencies.length > 3) {
                mood = "Coordination stress, juggling multiple priorities, multitasking energy";
            }

            return { mood, lighting };
        }

        // Helper: Setting Detection
        function getNarrativeSetting(item, act) {
            // Check if explicit setting exists
            if (item.location) return item.location;
            if (item.sceneSetting) return item.sceneSetting;

            // Infer from description
            const desc = (item.name + ' ' + (item.description || '')).toLowerCase();

            if (desc.includes('site') || desc.includes('construction') || desc.includes('land')) {
                return "Active construction site, equipment in background, dirt and machinery";
            }
            if (desc.includes('office') || desc.includes('meeting')) {
                return "Modern glass office, city skyline visible, professional environment";
            }
            if (desc.includes('lab') || desc.includes('research')) {
                return "Clean research laboratory, high-tech equipment, sterile environment";
            }
            if (desc.includes('field') || desc.includes('outdoor')) {
                return "Outdoor location, natural environment, sky visible";
            }

            // Default based on act
            if (act.includes("Challenge")) {
                return "Modern office conference room, early morning, project plans visible";
            } else if (act.includes("Struggle")) {
                return "Office late at night, desks cluttered with documents, pressure visible";
            } else if (act.includes("Triumph")) {
                return "Office or construction site, celebrating success, relieved atmosphere";
            }

            return "Professional office or work environment";
        }

        // Helper: Emotional Stakes
        function getEmotionalStakes(item) {
            const monetaryValue = item.cost || item.dealValue || item.investment || 0;
            const timeline = item.leadTime || item.engineeringEstimate || item.duration || "";

            if (monetaryValue > 5000000) {
                return `Career-defining moment. Millions on the line.`;
            }
            if (monetaryValue > 1000000) {
                return `Major project milestone. Success matters.`;
            }
            if (timeline.includes('month') && parseInt(timeline) < 6) {
                return `Tight deadline. Time pressure evident.`;
            }
            if (item.dependencies && item.dependencies.length > 2) {
                return `Complex dependencies. Everything must align.`;
            }

            return `Professional commitment. Doing this right matters.`;
        }

        // Helper: Emotional Expression
        function getEmotionalExpression(mood) {
            if (mood.includes("Optimistic")) return "hope mixed with determination";
            if (mood.includes("Stressed") || mood.includes("Crisis")) return "stress and urgent focus";
            if (mood.includes("Relieved") || mood.includes("celebratory")) return "relief and satisfaction";
            if (mood.includes("pressure")) return "intense concentration under pressure";
            if (mood.includes("Cautious")) return "careful calculation and wariness";
            return "professional determination and focus";
        }

        // UI: Style Selector Modal
        function showVideoStyleSelector(callback) {
            // Remove any existing modal
            const existingModal = document.querySelector('.video-style-modal');
            if (existingModal) existingModal.remove();

            const modalHTML = `
                <div class="modal-overlay video-style-modal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.85);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                ">
                    <div class="modal-content" style="
                        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                        border-radius: 16px;
                        padding: 32px;
                        max-width: 800px;
                        width: 90%;
                        color: #e4e4e7;
                        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
                    ">
                        <h2 style="
                            font-size: 28px;
                            margin-bottom: 8px;
                            background: linear-gradient(135deg, #60a5fa, #a78bfa);
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                            background-clip: text;
                        ">ğŸ¬ Choose Video Style</h2>

                        <p style="color: #9ca3af; margin-bottom: 24px; font-size: 14px;">
                            Generate AI video prompts in two different styles. Same project data, different storytelling approaches.
                        </p>

                        <div class="style-options" style="
                            display: grid;
                            grid-template-columns: 1fr 1fr;
                            gap: 20px;
                            margin-bottom: 24px;
                        ">
                            <div class="style-card" data-style="explainer" style="
                                background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                                border-radius: 12px;
                                padding: 24px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                border: 2px solid transparent;
                            ">
                                <div class="style-icon" style="font-size: 48px; margin-bottom: 12px;">ğŸ“Š</div>
                                <h3 style="font-size: 18px; margin-bottom: 12px; color: #fff;">Explainer / Documentary</h3>
                                <p style="font-size: 13px; margin-bottom: 16px; color: #dbeafe; line-height: 1.5;">
                                    Clean, professional, educational. Shows the project plan logically step-by-step.
                                </p>
                                <ul style="font-size: 12px; color: #dbeafe; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 6px;">âœ… Investor presentations</li>
                                    <li style="margin-bottom: 6px;">âœ… Team onboarding</li>
                                    <li style="margin-bottom: 6px;">âœ… Status updates</li>
                                    <li>âœ… Educational content</li>
                                </ul>
                            </div>

                            <div class="style-card" data-style="narrative" style="
                                background: linear-gradient(135deg, #8b5cf6, #6d28d9);
                                border-radius: 12px;
                                padding: 24px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                border: 2px solid transparent;
                            ">
                                <div class="style-icon" style="font-size: 48px; margin-bottom: 12px;">ğŸ­</div>
                                <h3 style="font-size: 18px; margin-bottom: 12px; color: #fff;">Narrative / Story</h3>
                                <p style="font-size: 13px; margin-bottom: 16px; color: #ede9fe; line-height: 1.5;">
                                    Character-driven drama. Shows someone completing the project successfully with emotional stakes.
                                </p>
                                <ul style="font-size: 12px; color: #ede9fe; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 6px;">âœ… Marketing videos</li>
                                    <li style="margin-bottom: 6px;">âœ… Hero's journey arc</li>
                                    <li style="margin-bottom: 6px;">âœ… Emotional storytelling</li>
                                    <li>âœ… Brand building</li>
                                </ul>
                            </div>
                        </div>

                        <p style="
                            text-align: center;
                            color: #60a5fa;
                            font-size: 13px;
                            margin-bottom: 16px;
                        ">ğŸ’¡ Tip: Both styles use the same project data</p>

                        <button class="modal-cancel" style="
                            width: 100%;
                            padding: 12px;
                            background: #374151;
                            color: #e4e4e7;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            transition: all 0.2s;
                        ">Cancel</button>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // Add hover effects
            const styleCards = document.querySelectorAll('.style-card');
            styleCards.forEach(card => {
                card.addEventListener('mouseenter', () => {
                    card.style.transform = 'scale(1.05)';
                    card.style.borderColor = '#60a5fa';
                    card.style.boxShadow = '0 10px 30px rgba(96, 165, 250, 0.3)';
                });
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'scale(1)';
                    card.style.borderColor = 'transparent';
                    card.style.boxShadow = 'none';
                });

                // Click handler
                card.addEventListener('click', () => {
                    const style = card.dataset.style;
                    document.querySelector('.video-style-modal').remove();
                    callback(style);
                });
            });

            // Cancel button
            document.querySelector('.modal-cancel').addEventListener('click', () => {
                document.querySelector('.video-style-modal').remove();
            });

            // Click outside to close
            document.querySelector('.video-style-modal').addEventListener('click', (e) => {
                if (e.target.classList.contains('video-style-modal')) {
                    document.querySelector('.video-style-modal').remove();
                }
            });
        }

        // UI: Display Generated Prompt
        function displayGeneratedPrompt(prompt, title) {
            // Copy to clipboard
            navigator.clipboard.writeText(prompt).then(() => {
                showNotification(`âœ… ${title} - Prompt copied to clipboard!`);
            }).catch(() => {
                // Fallback: show in console if clipboard fails
                console.log('=== GENERATED PROMPT ===');
                console.log(prompt);
                showNotification(`âœ… ${title} - See console for prompt`);
            });
        }

        // Synthesize all video fields into one cohesive professional prompt
        // Based on Sora/Veo3 best practices: comprehensive, detailed, cinematographic
        function synthesizeVideoPrompt(item) {
            let sections = [];

            // SECTION 1: CORE SCENE DESCRIPTION
            let sceneDesc = '';
            if (item.videoPrompt) {
                sceneDesc = item.videoPrompt;
            } else if (item.description) {
                sceneDesc = item.description;
            } else {
                sceneDesc = item.name;
            }
            sections.push(sceneDesc);

            // SECTION 2: CAMERA SPECIFICATIONS
            const cameraSpecs = [];

            // Camera movement (critical for Sora/Veo3)
            if (item.cameraMovement && item.cameraMovement !== 'Static') {
                const movement = item.cameraMovement.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(movement)) {
                    cameraSpecs.push(`${movement} camera`);
                }
            } else if (!sceneDesc.toLowerCase().includes('camera')) {
                cameraSpecs.push('static camera');
            }

            // Motion intensity affects pacing
            if (item.motionIntensity) {
                const intensity = item.motionIntensity.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(intensity) && !sceneDesc.toLowerCase().includes('motion')) {
                    cameraSpecs.push(`${intensity} motion`);
                }
            }

            if (cameraSpecs.length > 0) {
                sections.push(cameraSpecs.join(', '));
            }

            // SECTION 3: LIGHTING & ATMOSPHERE
            const lightingDetails = [];

            if (item.lightingMood) {
                const mood = item.lightingMood.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(mood) && !sceneDesc.toLowerCase().includes('light')) {
                    lightingDetails.push(`${mood} lighting`);
                }
            }

            // Visual style affects overall aesthetic
            if (item.visualStyle && item.visualStyle !== 'Photorealistic') {
                const style = item.visualStyle.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(style)) {
                    lightingDetails.push(`${style} aesthetic`);
                }
            }

            if (lightingDetails.length > 0) {
                sections.push(lightingDetails.join(', '));
            }

            // SECTION 4: TECHNICAL FORMAT (professional cinematography language)
            const technicalDetails = [];

            // Aspect ratio implies framing
            if (item.aspectRatio) {
                const ratio = item.aspectRatio;
                if (ratio.includes('16:9')) {
                    if (!sceneDesc.toLowerCase().includes('widescreen') && !sceneDesc.toLowerCase().includes('cinematic')) {
                        technicalDetails.push('widescreen composition');
                    }
                } else if (ratio.includes('9:16')) {
                    if (!sceneDesc.toLowerCase().includes('vertical')) {
                        technicalDetails.push('vertical framing');
                    }
                } else if (ratio.includes('2.39')) {
                    if (!sceneDesc.toLowerCase().includes('cinematic')) {
                        technicalDetails.push('anamorphic widescreen');
                    }
                }
            }

            if (technicalDetails.length > 0) {
                sections.push(technicalDetails.join(', '));
            }

            // SYNTHESIZE: Build comprehensive prompt
            let finalPrompt = sections.filter(s => s && s.length > 0).join('. ');

            // Ensure professional formatting
            if (!finalPrompt.endsWith('.') && !finalPrompt.endsWith('!') && !finalPrompt.endsWith('?')) {
                finalPrompt += '.';
            }

            // QUALITY CHECK: Professional prompts should be detailed (100+ chars minimum)
            // If still too short, add generic cinematography guidance
            if (finalPrompt.length < 100) {
                const defaultEnhancements = [];

                if (!finalPrompt.toLowerCase().includes('focus')) {
                    defaultEnhancements.push('sharp focus on subject');
                }

                if (!finalPrompt.toLowerCase().includes('detail')) {
                    defaultEnhancements.push('high attention to detail');
                }

                if (item.duration && item.duration.includes('seconds')) {
                    const seconds = item.duration.match(/\d+/)?.[0];
                    if (seconds) {
                        defaultEnhancements.push(`${seconds}-second clip`);
                    }
                }

                if (defaultEnhancements.length > 0) {
                    finalPrompt += ` ${defaultEnhancements.join(', ')}.`;
                }
            }

            return finalPrompt;
        }

        // Generate Product Roadmap prompt (sprint-ready, execution-focused)
        function generateRoadmapPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ğŸš€'} ${tree.name || 'Product Roadmap'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate roadmap metrics
            let totalStoryPoints = 0;
            let highImpactFeatures = 0;
            let highRiskFeatures = 0;
            let totalFeatures = 0;
            const quarterMetrics = [];

            if (tree.children) {
                tree.children.forEach(quarter => {
                    if (quarter.type === 'phase' && quarter.items) {
                        let quarterPoints = 0;
                        let quarterHighImpact = 0;
                        let quarterHighRisk = 0;

                        quarter.items.forEach(feature => {
                            quarterPoints += feature.storyPoints || 0;
                            if (feature.userImpact === 'High' || feature.userImpact === 'Critical') {
                                quarterHighImpact++;
                            }
                            if (feature.technicalRisk === 'High') {
                                quarterHighRisk++;
                            }
                        });

                        quarterMetrics.push({
                            name: quarter.name || `Quarter ${quarter.phase + 1}`,
                            subtitle: quarter.subtitle,
                            features: quarter.items.length,
                            points: quarterPoints,
                            highImpact: quarterHighImpact,
                            highRisk: quarterHighRisk
                        });

                        totalStoryPoints += quarterPoints;
                        totalFeatures += quarter.items.length;
                        highImpactFeatures += quarterHighImpact;
                        highRiskFeatures += quarterHighRisk;
                    }
                });
            }

            // Roadmap Summary
            output += `## ğŸ“Š Roadmap Summary\n\n`;
            output += `**Delivery Capacity:**\n`;
            output += `- Total Features: ${totalFeatures}\n`;
            output += `- Total Story Points: ${totalStoryPoints}\n`;
            output += `- Average Feature Size: ${Math.round(totalStoryPoints / totalFeatures)} points\n`;
            output += `- High-Impact Features: ${highImpactFeatures} (${Math.round(highImpactFeatures / totalFeatures * 100)}%)\n`;
            output += `- High-Risk Features: ${highRiskFeatures} (${Math.round(highRiskFeatures / totalFeatures * 100)}%)\n\n`;

            // Quarterly Planning
            output += `## ğŸ“… Quarterly Planning\n\n`;
            quarterMetrics.forEach((q, idx) => {
                output += `### ${q.name}${q.subtitle ? ` â€” ${q.subtitle}` : ''}\n`;
                output += `- Features: ${q.features} (${q.points} story points)\n`;
                output += `- Velocity Target: ${Math.round(q.points / 6)} points/sprint (6 sprints)\n`;
                output += `- High Impact: ${q.highImpact} features\n`;
                output += `- High Risk: ${q.highRisk} features (${q.highRisk > 0 ? 'requires spike work' : 'low risk quarter'})\n\n`;
            });

            // Feature Details
            output += `---\n\n## ğŸš€ Feature Specifications\n\n`;

            if (tree.children) {
                tree.children.forEach((quarter, qIdx) => {
                    if (quarter.type === 'phase' && quarter.items && quarter.items.length > 0) {
                        output += `### ${quarter.name || `Quarter ${qIdx + 1}`}\n\n`;

                        quarter.items.forEach((feature, fIdx) => {
                            const storyPoints = feature.storyPoints || 0;
                            const userImpact = feature.userImpact || 'Medium';
                            const techRisk = feature.technicalRisk || 'Medium';

                            // Impact/Risk emoji indicators
                            const impactEmoji = userImpact === 'Critical' ? 'ğŸ”¥' : userImpact === 'High' ? 'âš¡' : userImpact === 'Medium' ? 'ğŸ“Š' : 'ğŸ“‰';
                            const riskEmoji = techRisk === 'High' ? 'âš ï¸' : techRisk === 'Medium' ? 'âš¡' : 'âœ…';

                            output += `#### ${fIdx + 1}. ${feature.name}\n\n`;

                            // Feature card
                            output += `**Feature Overview:**\n`;
                            output += `- ${impactEmoji} User Impact: ${userImpact}\n`;
                            output += `- ${riskEmoji} Technical Risk: ${techRisk}\n`;
                            output += `- ğŸ“ Story Points: ${storyPoints} (${Math.ceil(storyPoints / 3)} sprints)\n`;
                            if (feature.engineeringEstimate) {
                                output += `- â±ï¸ Engineering Estimate: ${feature.engineeringEstimate}\n`;
                            }
                            if (feature.featureFlag) {
                                output += `- ğŸš© Feature Flag: \`${feature.featureFlag}\`\n`;
                            }
                            output += `\n`;

                            if (feature.description) {
                                output += `**What it does:**\n${feature.description}\n\n`;
                            }

                            // Implementation tasks
                            if (feature.children && feature.children.length > 0) {
                                output += `**Implementation Tasks:**\n`;
                                feature.children.forEach((task, tIdx) => {
                                    output += `${tIdx + 1}. ${task.name}`;
                                    if (task.storyPoints) {
                                        output += ` (${task.storyPoints} pts)`;
                                    }
                                    output += `\n`;
                                    if (task.description) {
                                        output += `   ${task.description}\n`;
                                    }
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (feature.dependencies && feature.dependencies.length > 0) {
                                output += `**âš ï¸ Blocking Dependencies:** ${feature.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Execution Recommendations
            output += `## âš¡ Execution Recommendations\n\n`;
            output += `**Sprint Planning:**\n`;
            const avgVelocity = Math.round(totalStoryPoints / (quarterMetrics.length * 6)); // Assume 6 sprints per quarter
            output += `- Target Velocity: ${avgVelocity} story points per sprint\n`;
            output += `- High-risk features: Start with spike/POC stories (1-2 sprints)\n`;
            output += `- Critical user impact: Prioritize for early quarters\n`;
            output += `- Feature flags: Use for all features >5 story points\n\n`;

            output += `**Risk Mitigation:**\n`;
            output += `1. Technical Spikes: Create 2-point spike stories for high-risk features\n`;
            output += `2. Dependency Management: Resolve blocking dependencies 1 sprint ahead\n`;
            output += `3. Incremental Delivery: Break large features (>8 points) into smaller releases\n`;
            output += `4. User Validation: Beta test high-impact features before GA\n`;
            output += `5. Monitoring: Set up dashboards and alerts for each feature flag\n\n`;

            output += `**Release Strategy:**\n`;
            output += `- Feature Flags: All features behind flags for safe rollout\n`;
            output += `- Phased Rollout: 10% â†’ 50% â†’ 100% over 2 weeks\n`;
            output += `- Rollback Plan: Document rollback procedures in each PR\n`;
            output += `- Success Metrics: Define KPIs before development starts\n\n`;

            output += `---\n\n`;
            output += `**ğŸ’¡ AI Prompt Usage - Actionable Deliverables:**\n`;
            output += `\n`;
            output += `**For Product Managers:**\n`;
            output += `- "Generate PRD (Product Requirements Document) for [feature name]"\n`;
            output += `- "Create user stories with acceptance criteria for [feature]"\n`;
            output += `- "Write launch email announcing [feature] to customers"\n`;
            output += `- "Design A/B test plan to validate [feature] impact"\n\n`;
            output += `**For Engineering:**\n`;
            output += `- "Create technical design doc for [feature] with architecture diagrams"\n`;
            output += `- "Write API specification (OpenAPI/Swagger) for [feature] endpoints"\n`;
            output += `- "Generate test plan covering happy path, edge cases, and error scenarios"\n`;
            output += `- "Draft database migration script for [feature] schema changes"\n\n`;
            output += `**For Research:**\n`;
            output += `- "Find 3 competitor implementations of [feature] with screenshots"\n`;
            output += `- "Research best practices for [feature type] in SaaS applications"\n`;
            output += `- "Identify potential technical challenges for [feature] implementation"\n\n`;

            return output;
        }

        // Generate Book/Novel prompt (manuscript-ready, narrative-focused)
        function generateBookPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ğŸ“š'} ${tree.name || 'Book Manuscript'}\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Calculate manuscript metrics
            let totalWordCount = 0;
            let targetWordCount = 0;
            let totalChapters = 0;
            const chapterMetrics = [];

            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.type === 'phase' && chapter.items) {
                        let chapterWords = 0;
                        let chapterTarget = 0;
                        let sceneCount = chapter.items.length;

                        chapter.items.forEach(scene => {
                            chapterWords += scene.wordCount || 0;
                            chapterTarget += scene.targetWordCount || 0;
                        });

                        chapterMetrics.push({
                            name: chapter.name || `Chapter ${chapter.phase + 1}`,
                            subtitle: chapter.subtitle,
                            current: chapterWords,
                            target: chapterTarget,
                            scenes: sceneCount,
                            progress: chapterTarget > 0 ? Math.round((chapterWords / chapterTarget) * 100) : 0
                        });

                        totalWordCount += chapterWords;
                        targetWordCount += chapterTarget;
                        totalChapters++;
                    }
                });
            }

            const overallProgress = targetWordCount > 0 ? Math.round((totalWordCount / targetWordCount) * 100) : 0;

            // Manuscript Overview
            output += `## ğŸ“– Manuscript Overview\n\n`;
            output += `**Writing Progress:**\n`;
            output += `- Current Length: ${totalWordCount.toLocaleString()} words\n`;
            output += `- Target Length: ${targetWordCount.toLocaleString()} words\n`;
            output += `- Completion: ${overallProgress}% ${overallProgress < 50 ? '(First Draft)' : overallProgress < 80 ? '(Revision Stage)' : '(Near Final)'}\n`;
            output += `- Structure: ${totalChapters} chapters\n`;
            output += `- Average Chapter: ${Math.round(totalWordCount / totalChapters).toLocaleString()} words\n\n`;

            // Story Arc Analysis
            output += `## ğŸ­ Story Arc Structure\n\n`;
            chapterMetrics.forEach((ch, idx) => {
                const position = idx / (totalChapters - 1);
                let arcStage = '';
                if (position < 0.25) arcStage = 'ğŸ“ Setup/Exposition';
                else if (position < 0.5) arcStage = 'â¬†ï¸ Rising Action';
                else if (position < 0.75) arcStage = 'ğŸ”¥ Climax/Conflict';
                else arcStage = 'â¬‡ï¸ Falling Action/Resolution';

                const progressBar = 'â–ˆ'.repeat(Math.floor(ch.progress / 10)) + 'â–‘'.repeat(10 - Math.floor(ch.progress / 10));
                output += `### ${ch.name} ${arcStage}\n`;
                output += `- Progress: [${progressBar}] ${ch.progress}%\n`;
                output += `- Word Count: ${ch.current.toLocaleString()} / ${ch.target.toLocaleString()} words\n`;
                output += `- Scenes: ${ch.scenes}\n\n`;
            });

            // Scene Breakdown
            output += `---\n\n## ğŸ“ Scene-by-Scene Breakdown\n\n`;

            if (tree.children) {
                tree.children.forEach((chapter, chIdx) => {
                    if (chapter.type === 'phase' && chapter.items && chapter.items.length > 0) {
                        output += `### ${chapter.name || `Chapter ${chIdx + 1}`}${chapter.subtitle ? ` â€” ${chapter.subtitle}` : ''}\n\n`;

                        chapter.items.forEach((scene, sIdx) => {
                            output += `#### Scene ${sIdx + 1}: ${scene.name}\n\n`;

                            // Scene metadata
                            const sceneMetadata = [];
                            if (scene.povCharacter) sceneMetadata.push(`**POV:** ${scene.povCharacter}`);
                            if (scene.sceneSetting) sceneMetadata.push(`**Setting:** ${scene.sceneSetting}`);
                            if (scene.plotFunction) sceneMetadata.push(`**Plot Function:** ${scene.plotFunction}`);

                            if (sceneMetadata.length > 0) {
                                output += sceneMetadata.join(' â€¢ ') + '\n\n';
                            }

                            // Scene description
                            if (scene.description) {
                                output += `**What Happens:**\n${scene.description}\n\n`;
                            }

                            // Writing progress
                            if (scene.wordCount !== undefined || scene.targetWordCount) {
                                const sceneProgress = scene.targetWordCount > 0 ? Math.round((scene.wordCount || 0) / scene.targetWordCount * 100) : 0;
                                output += `**Writing Status:** ${scene.wordCount || 0} words (${sceneProgress}% of ${scene.targetWordCount || '?'} target)`;
                                if (scene.draftStatus) {
                                    output += ` â€” ${scene.draftStatus}`;
                                }
                                output += `\n\n`;
                            }

                            // Beats/moments within scene
                            if (scene.children && scene.children.length > 0) {
                                output += `**Story Beats:**\n`;
                                scene.children.forEach((beat, bIdx) => {
                                    output += `${bIdx + 1}. ${beat.name}`;
                                    if (beat.description) {
                                        output += ` â€” ${beat.description}`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Writing Recommendations
            output += `## âœï¸ Writing Strategy & Next Steps\n\n`;
            output += `**Manuscript Status:**\n`;
            if (overallProgress < 50) {
                output += `- Stage: First Draft â€” focus on completing story structure\n`;
                output += `- Priority: Write forward, don't revise yet\n`;
                output += `- Goal: Reach "The End" before editing\n\n`;
            } else if (overallProgress < 80) {
                output += `- Stage: Revision â€” deepen character arcs and pacing\n`;
                output += `- Priority: Address plot holes and character motivation\n`;
                output += `- Goal: Complete second draft with all scenes polished\n\n`;
            } else {
                output += `- Stage: Final Polish â€” line edits and beta feedback\n`;
                output += `- Priority: Professional editing and proofreading\n`;
                output += `- Goal: Query-ready or publish-ready manuscript\n\n`;
            }

            output += `**Story Development Checklist:**\n`;
            output += `1. Character Arcs: Do all major characters change/grow?\n`;
            output += `2. Plot Coherence: Are there any unresolved threads?\n`;
            output += `3. Pacing: Does each scene advance plot or deepen character?\n`;
            output += `4. Setting: Is the world vivid and consistent?\n`;
            output += `5. Theme: Are thematic elements woven throughout?\n\n`;

            output += `**Scene-Level Quality:**\n`;
            output += `- Each scene should have: Goal, Conflict, Disaster (or Resolution)\n`;
            output += `- POV consistency within chapters\n`;
            output += `- Vary scene length for pacing (long for tension, short for action)\n`;
            output += `- End chapters with hooks to keep readers engaged\n\n`;

            output += `---\n\n`;
            output += `**ğŸ’¡ AI Prompt Usage - Manuscript Deliverables:**\n`;
            output += `\n`;
            output += `**For Drafting:**\n`;
            output += `- "Write a 1000-word opening scene for [chapter] from [POV character]'s perspective"\n`;
            output += `- "Expand [scene name] with more sensory details and emotional depth"\n`;
            output += `- "Draft dialogue between [character A] and [character B] about [conflict]"\n`;
            output += `- "Write the climax scene where [key plot event] happens"\n\n`;
            output += `**For Revision:**\n`;
            output += `- "Analyze character arc for [protagonist] - identify weak character development"\n`;
            output += `- "Find pacing issues in Act 2 - which scenes drag or feel rushed?"\n`;
            output += `- "Suggest ways to increase tension in [chapter name]"\n`;
            output += `- "Identify plot holes or inconsistencies in the manuscript"\n\n`;
            output += `**For Publishing:**\n`;
            output += `- "Write a compelling 300-word book blurb for marketing"\n`;
            output += `- "Generate 20 comp titles (comparable books) with explanation"\n`;
            output += `- "Draft query letter to literary agents highlighting unique elements"\n`;
            output += `- "Create chapter summaries for submission synopsis (1-2 sentences each)"\n\n`;

            return output;
        }

        // Generate Course/Training prompt (curriculum-ready, learning-focused)
        function generateCoursePrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ğŸ“–'} ${tree.name || 'Course Curriculum'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate course metrics
            let totalDuration = 0;
            let totalLessons = 0;
            let assessmentCount = 0;
            const moduleMetrics = [];

            if (tree.children) {
                tree.children.forEach(module => {
                    if (module.type === 'phase' && module.items) {
                        let moduleDuration = 0;
                        let lessonCount = module.items.length;

                        module.items.forEach(lesson => {
                            // Parse duration (e.g., "2 hours", "45 minutes")
                            if (lesson.duration) {
                                const match = lesson.duration.match(/(\d+)\s*(hour|minute|min)/i);
                                if (match) {
                                    const value = parseInt(match[1]);
                                    const unit = match[2].toLowerCase();
                                    moduleDuration += unit.startsWith('hour') ? value * 60 : value;
                                }
                            }
                            if (lesson.assessmentType && lesson.assessmentType !== 'None') {
                                assessmentCount++;
                            }
                        });

                        moduleMetrics.push({
                            name: module.name || `Module ${module.phase + 1}`,
                            subtitle: module.subtitle,
                            duration: moduleDuration,
                            lessons: lessonCount
                        });

                        totalDuration += moduleDuration;
                        totalLessons += lessonCount;
                    }
                });
            }

            const totalHours = Math.floor(totalDuration / 60);
            const totalMinutes = totalDuration % 60;

            // Course Overview
            output += `## ğŸ“ Course Overview\n\n`;
            output += `**Course Specifications:**\n`;
            output += `- Total Duration: ${totalHours}h ${totalMinutes}m\n`;
            output += `- Total Modules: ${moduleMetrics.length}\n`;
            output += `- Total Lessons: ${totalLessons}\n`;
            output += `- Assessments: ${assessmentCount}\n`;
            output += `- Average Lesson: ${Math.round(totalDuration / totalLessons)} minutes\n\n`;

            // Learning Path
            output += `## ğŸ›¤ï¸ Learning Path Structure\n\n`;
            moduleMetrics.forEach((mod, idx) => {
                const modHours = Math.floor(mod.duration / 60);
                const modMinutes = mod.duration % 60;
                output += `### Module ${idx + 1}: ${mod.name}${mod.subtitle ? ` â€” ${mod.subtitle}` : ''}\n`;
                output += `- Duration: ${modHours}h ${modMinutes}m\n`;
                output += `- Lessons: ${mod.lessons}\n`;
                output += `- Average Lesson: ${Math.round(mod.duration / mod.lessons)} minutes\n\n`;
            });

            // Detailed Curriculum
            output += `---\n\n## ğŸ“š Detailed Curriculum\n\n`;

            if (tree.children) {
                tree.children.forEach((module, modIdx) => {
                    if (module.type === 'phase' && module.items && module.items.length > 0) {
                        output += `### Module ${modIdx + 1}: ${module.name || `Module ${modIdx + 1}`}\n\n`;
                        if (module.subtitle) {
                            output += `*${module.subtitle}*\n\n`;
                        }

                        module.items.forEach((lesson, lesIdx) => {
                            output += `#### Lesson ${modIdx + 1}.${lesIdx + 1}: ${lesson.name}\n\n`;

                            // Lesson metadata
                            const metadata = [];
                            if (lesson.duration) metadata.push(`â±ï¸ ${lesson.duration}`);
                            if (lesson.difficultyLevel) metadata.push(`ğŸ“Š ${lesson.difficultyLevel}`);
                            if (lesson.assessmentType && lesson.assessmentType !== 'None') metadata.push(`âœ… ${lesson.assessmentType}`);

                            if (metadata.length > 0) {
                                output += metadata.join(' â€¢ ') + '\n\n';
                            }

                            // Learning objectives
                            if (lesson.learningObjectives) {
                                output += `**Learning Objectives:**\n${lesson.learningObjectives}\n\n`;
                            }

                            // Lesson description
                            if (lesson.description) {
                                output += `**Lesson Content:**\n${lesson.description}\n\n`;
                            }

                            // Prerequisites
                            if (lesson.prerequisites) {
                                output += `**Prerequisites:** ${lesson.prerequisites}\n\n`;
                            }

                            // Resources
                            if (lesson.resourcesNeeded) {
                                output += `**Resources Needed:** ${lesson.resourcesNeeded}\n\n`;
                            }

                            // Activities/exercises
                            if (lesson.children && lesson.children.length > 0) {
                                output += `**Activities & Exercises:**\n`;
                                lesson.children.forEach((activity, aIdx) => {
                                    output += `${aIdx + 1}. ${activity.name}`;
                                    if (activity.duration) {
                                        output += ` (${activity.duration})`;
                                    }
                                    if (activity.description) {
                                        output += `\n   ${activity.description}`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (lesson.dependencies && lesson.dependencies.length > 0) {
                                output += `**âš ï¸ Requires Completion Of:** ${lesson.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Course Development Recommendations
            output += `## ğŸ¯ Course Development Strategy\n\n`;
            output += `**Instructional Design Checklist:**\n`;
            output += `1. Learning Objectives: Each lesson has clear, measurable outcomes\n`;
            output += `2. Scaffolding: Concepts build progressively from simple to complex\n`;
            output += `3. Active Learning: Mix of theory, practice, and assessment\n`;
            output += `4. Engagement: Vary content types (video, text, interactive, projects)\n`;
            output += `5. Assessment: Regular checkpoints to verify understanding\n\n`;

            output += `**Course Quality Standards:**\n`;
            output += `- Lesson Length: Keep videos 10-20 minutes for optimal retention\n`;
            output += `- Practice Ratio: 70% practice, 30% theory for skill-based courses\n`;
            output += `- Assessment Frequency: Quiz or exercise every 3-4 lessons\n`;
            output += `- Resource Quality: Provide downloadable templates, cheat sheets, references\n`;
            output += `- Community: Discussion forums or peer review for social learning\n\n`;

            output += `**Production Planning:**\n`;
            const avgLessonTime = Math.round(totalDuration / totalLessons);
            const videoHours = Math.ceil(totalHours * 2); // 2:1 production ratio
            output += `- Video Production Time: ~${videoHours} hours (2:1 ratio for recording/editing)\n`;
            output += `- Script Writing: ~2 hours per lesson (${totalLessons * 2} hours total)\n`;
            output += `- Assessment Creation: ~1 hour per quiz/exercise\n`;
            output += `- Platform Setup: LMS configuration, student enrollment, progress tracking\n\n`;

            output += `---\n\n`;
            output += `**ğŸ’¡ AI Prompt Usage - Course Deliverables:**\n`;
            output += `\n`;
            output += `**For Content Creation:**\n`;
            output += `- "Write a detailed lesson script for [lesson name] covering [learning objectives]"\n`;
            output += `- "Create 10 multiple-choice quiz questions for [module] with explanations"\n`;
            output += `- "Design a hands-on project assignment for [topic] with rubric"\n`;
            output += `- "Generate practice exercises with solutions for [concept]"\n\n`;
            output += `**For Course Materials:**\n`;
            output += `- "Create a 1-page cheat sheet summarizing [module] key concepts"\n`;
            output += `- "Write downloadable PDF guide for [technical skill] with examples"\n`;
            output += `- "Design flashcards for memorizing [terminology/concepts]"\n`;
            output += `- "Generate code templates/starter files for [programming lesson]"\n\n`;
            output += `**For Marketing & Launch:**\n`;
            output += `- "Write compelling course description highlighting unique value (300 words)"\n`;
            output += `- "Create course landing page copy with benefits, outcomes, testimonials"\n`;
            output += `- "Generate lesson previews and free samples to attract students"\n`;
            output += `- "Draft email sequence for course launch (5 emails over 2 weeks)"\n\n`;
            output += `**For Student Support:**\n`;
            output += `- "Create FAQ document answering common student questions"\n`;
            output += `- "Write discussion prompts for community engagement in forums"\n`;
            output += `- "Generate personalized feedback templates for assignment reviews"\n\n`;

            return output;
        }

        // Generate Academic Thesis prompt (manuscript-ready, scholarly)
        function generateThesisPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ğŸ“'} ${tree.name || 'Thesis'}\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Calculate manuscript metrics
            let totalWordCount = 0;
            let targetWordCount = 0;
            let totalChapters = 0;
            const chapterMetrics = [];

            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.type === 'phase' && chapter.items) {
                        let chapterWords = 0;
                        let chapterTarget = 0;
                        let sectionCount = chapter.items.length;

                        chapter.items.forEach(section => {
                            chapterWords += section.wordCount || 0;
                            chapterTarget += section.targetWordCount || 0;
                        });

                        chapterMetrics.push({
                            name: chapter.name || `Chapter ${chapter.phase + 1}`,
                            subtitle: chapter.subtitle,
                            current: chapterWords,
                            target: chapterTarget,
                            sections: sectionCount,
                            progress: chapterTarget > 0 ? Math.round((chapterWords / chapterTarget) * 100) : 0
                        });

                        totalWordCount += chapterWords;
                        targetWordCount += chapterTarget;
                        totalChapters++;
                    }
                });
            }

            const overallProgress = targetWordCount > 0 ? Math.round((totalWordCount / targetWordCount) * 100) : 0;

            // Document Metadata
            output += `## ğŸ“„ Document Metadata\n\n`;
            output += `**Manuscript Status:**\n`;
            output += `- Current Length: ${totalWordCount.toLocaleString()} words\n`;
            output += `- Target Length: ${targetWordCount.toLocaleString()} words\n`;
            output += `- Completion: ${overallProgress}% (${totalWordCount}/${targetWordCount})\n`;
            output += `- Structure: ${totalChapters} chapters across ${pattern.levels.phase}\n`;
            output += `- Average Chapter: ${Math.round(totalWordCount / totalChapters).toLocaleString()} words\n\n`;

            // Chapter Breakdown with Progress
            output += `## ğŸ“š Chapter Structure\n\n`;
            chapterMetrics.forEach((ch, idx) => {
                const progressBar = 'â–ˆ'.repeat(Math.floor(ch.progress / 10)) + 'â–‘'.repeat(10 - Math.floor(ch.progress / 10));
                output += `### ${ch.name}${ch.subtitle ? ` â€” ${ch.subtitle}` : ''}\n`;
                output += `- Progress: [${progressBar}] ${ch.progress}%\n`;
                output += `- Word Count: ${ch.current.toLocaleString()} / ${ch.target.toLocaleString()} words\n`;
                output += `- Sections: ${ch.sections}\n\n`;
            });

            // Chapter Details
            output += `---\n\n## ğŸ“– Detailed Chapter Content\n\n`;

            if (tree.children) {
                tree.children.forEach((chapter, chIdx) => {
                    if (chapter.type === 'phase' && chapter.items && chapter.items.length > 0) {
                        output += `### ${chapter.name || `Chapter ${chIdx + 1}`}${chapter.subtitle ? ` â€” ${chapter.subtitle}` : ''}\n\n`;

                        chapter.items.forEach((section, sIdx) => {
                            output += `#### ${sIdx + 1}. ${section.name}\n\n`;

                            // Section metadata
                            if (section.keyArgument) {
                                output += `**Central Argument:**\n`;
                                output += `${section.keyArgument}\n\n`;
                            }

                            if (section.description) {
                                output += `**Section Overview:**\n`;
                                output += `${section.description}\n\n`;
                            }

                            // Evidence & Methodology
                            const hasMethodology = section.evidenceType || section.citations;
                            if (hasMethodology) {
                                output += `**Evidence & Methods:**\n`;
                                if (section.evidenceType) {
                                    output += `- Evidence Type: ${section.evidenceType}\n`;
                                }
                                if (section.citations) {
                                    output += `- Key Citations: ${section.citations}\n`;
                                }
                                output += `\n`;
                            }

                            // Writing Progress
                            if (section.wordCount !== undefined || section.targetWordCount) {
                                const sectionProgress = section.targetWordCount > 0 ? Math.round((section.wordCount || 0) / section.targetWordCount * 100) : 0;
                                output += `**Writing Progress:**\n`;
                                output += `- Current: ${section.wordCount || 0} words\n`;
                                output += `- Target: ${section.targetWordCount || 'TBD'} words\n`;
                                output += `- Status: ${sectionProgress}% complete`;
                                if (section.draftStatus) {
                                    output += ` (${section.draftStatus})`;
                                }
                                output += `\n\n`;
                            }

                            // Subsections/Arguments
                            if (section.children && section.children.length > 0) {
                                output += `**Sub-arguments:**\n`;
                                section.children.forEach((sub, subIdx) => {
                                    output += `${subIdx + 1}. ${sub.name}`;
                                    if (sub.keyArgument) {
                                        output += ` â€” ${sub.keyArgument}`;
                                    }
                                    if (sub.citations) {
                                        output += ` [${sub.citations}]`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (section.dependencies && section.dependencies.length > 0) {
                                output += `**âš ï¸ Dependencies:** This section builds on: ${section.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Writing Recommendations
            output += `## âœï¸ Writing Recommendations\n\n`;
            output += `**Manuscript Completeness:**\n`;
            output += `- Overall Progress: ${overallProgress}% complete\n`;
            if (overallProgress < 50) {
                output += `- Status: Early draft stage â€” focus on completing first drafts of all chapters\n`;
            } else if (overallProgress < 80) {
                output += `- Status: Mid-stage â€” focus on deepening arguments and adding evidence\n`;
            } else {
                output += `- Status: Late stage â€” focus on revision, citations, and cohesion\n`;
            }
            output += `- Remaining: ${(targetWordCount - totalWordCount).toLocaleString()} words to target length\n\n`;

            output += `**Chapter Balance:**\n`;
            const chapterLengths = chapterMetrics.map(ch => ch.current);
            const avgChapter = chapterLengths.reduce((a, b) => a + b, 0) / chapterLengths.length;
            const imbalanced = chapterLengths.filter(len => len < avgChapter * 0.5 || len > avgChapter * 1.5);
            if (imbalanced.length > 0) {
                output += `- âš ï¸ ${imbalanced.length} chapter(s) significantly differ from average length\n`;
                output += `- Consider redistributing content or adjusting targets\n`;
            } else {
                output += `- âœ“ Chapters are relatively balanced in length\n`;
            }
            output += `\n`;

            output += `**Academic Quality Checks:**\n`;
            output += `1. Citation Coverage: Ensure each major claim has 2-3 supporting citations\n`;
            output += `2. Argument Coherence: Check logical flow within and between chapters\n`;
            output += `3. Evidence Types: Balance theoretical, empirical, and case study evidence\n`;
            output += `4. Literature Gaps: Identify missing perspectives or counter-arguments\n`;
            output += `5. Methodological Rigor: Document methods, limitations, and validity\n\n`;

            output += `**Next Steps:**\n`;
            const incompleteSections = [];
            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.items) {
                        chapter.items.forEach(section => {
                            if (!section.wordCount || section.wordCount < (section.targetWordCount || 0) * 0.5) {
                                incompleteSections.push(section.name);
                            }
                        });
                    }
                });
            }
            if (incompleteSections.length > 0) {
                output += `- Priority: Complete ${incompleteSections.length} under-developed section(s)\n`;
                output += `- Focus areas: ${incompleteSections.slice(0, 3).join(', ')}${incompleteSections.length > 3 ? '...' : ''}\n`;
            }
            output += `- Review: Get feedback from advisors on completed chapters\n`;
            output += `- Citations: Update and complete bibliography\n`;
            output += `- Editing: Professional copyediting for polished sections\n\n`;

            output += `---\n\n`;
            output += `**ğŸ’¡ AI Prompt Usage:** This academic manuscript can be used to:\n`;
            output += `- Ask AI to critique arguments and suggest counter-arguments\n`;
            output += `- Generate literature review summaries for each chapter\n`;
            output += `- Draft section transitions and chapter conclusions\n`;
            output += `- Suggest additional citations based on argument types\n`;
            output += `- Create visual abstracts and conference presentations\n`;
            output += `- Identify methodological weaknesses and suggest improvements\n`;
            output += `- Generate research questions for future studies\n\n`;

            return output;
        }

        // Generate Sales Pipeline prompt (executive-ready, action-oriented)
        function generateSalesPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ğŸ’¼'} ${tree.name || 'Sales Pipeline'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate pipeline metrics
            let totalPipelineValue = 0;
            let weightedPipelineValue = 0;
            let totalDeals = 0;
            const quarterMetrics = [];

            if (tree.children) {
                tree.children.forEach(quarter => {
                    if (quarter.type === 'phase' && quarter.items) {
                        let quarterTotal = 0;
                        let quarterWeighted = 0;
                        let quarterDeals = quarter.items.length;

                        quarter.items.forEach(deal => {
                            const dealValue = deal.dealValue || 0;
                            const probability = deal.stageProbability || deal.probability || 0;

                            quarterTotal += dealValue;
                            quarterWeighted += (dealValue * probability / 100);
                        });

                        quarterMetrics.push({
                            name: quarter.name || `Quarter ${quarter.phase + 1}`,
                            subtitle: quarter.subtitle,
                            total: quarterTotal,
                            weighted: quarterWeighted,
                            deals: quarterDeals
                        });

                        totalPipelineValue += quarterTotal;
                        weightedPipelineValue += quarterWeighted;
                        totalDeals += quarterDeals;
                    }
                });
            }

            // Executive Summary
            output += `## ğŸ“Š Executive Summary\n\n`;
            output += `**Pipeline Health:**\n`;
            output += `- Total Pipeline Value: $${totalPipelineValue.toLocaleString()}\n`;
            output += `- Weighted Pipeline (Probability Adjusted): $${Math.round(weightedPipelineValue).toLocaleString()}\n`;
            output += `- Total Active Deals: ${totalDeals}\n`;
            output += `- Average Deal Size: $${Math.round(totalPipelineValue / totalDeals).toLocaleString()}\n`;
            output += `- Weighted Close Rate: ${Math.round(weightedPipelineValue / totalPipelineValue * 100)}%\n\n`;

            // Quarterly Breakdown
            output += `## ğŸ“… Quarterly Breakdown\n\n`;
            quarterMetrics.forEach((q, idx) => {
                output += `### ${q.name}${q.subtitle ? ` - ${q.subtitle}` : ''}\n`;
                output += `- Pipeline: $${q.total.toLocaleString()} (${q.deals} deals)\n`;
                output += `- Expected Revenue: $${Math.round(q.weighted).toLocaleString()}\n`;
                output += `- Conversion Confidence: ${Math.round(q.weighted / q.total * 100)}%\n\n`;
            });

            // Deal Details by Quarter
            output += `---\n\n## ğŸ’¼ Deal Pipeline\n\n`;

            if (tree.children) {
                tree.children.forEach((quarter, qIdx) => {
                    if (quarter.type === 'phase' && quarter.items && quarter.items.length > 0) {
                        output += `### ${quarter.name || `Quarter ${qIdx + 1}`}\n\n`;

                        quarter.items.forEach((deal, dIdx) => {
                            const dealValue = deal.dealValue || 0;
                            const probability = deal.stageProbability || deal.probability || 0;
                            const expectedRevenue = Math.round(dealValue * probability / 100);

                            output += `#### ${dIdx + 1}. ${deal.name}\n\n`;

                            // Deal metrics bar
                            output += `**Deal Snapshot:**\n`;
                            output += `- ğŸ’° Value: $${dealValue.toLocaleString()}\n`;
                            output += `- ğŸ“Š Probability: ${probability}%\n`;
                            output += `- ğŸ’µ Expected Revenue: $${expectedRevenue.toLocaleString()}\n`;
                            if (deal.expectedCloseDate || deal.expectedClose) {
                                output += `- ğŸ“… Target Close: ${deal.expectedCloseDate || deal.expectedClose}\n`;
                            }
                            if (deal.accountExecutive) {
                                output += `- ğŸ‘¤ Account Executive: ${deal.accountExecutive}\n`;
                            }
                            if (deal.itemType) {
                                const typeLabel = pattern.types.find(t => t.value === deal.itemType)?.label || deal.itemType;
                                output += `- ğŸ·ï¸ Deal Type: ${typeLabel}\n`;
                            }
                            if (deal.status) {
                                output += `- ğŸ“ Status: ${deal.status}\n`;
                            }
                            if (deal.leadTime) {
                                output += `- â±ï¸ Sales Cycle: ${deal.leadTime}\n`;
                            }
                            output += `\n`;

                            if (deal.description) {
                                output += `**Overview:**\n${deal.description}\n\n`;
                            }

                            // Action items / Next steps
                            if (deal.children && deal.children.length > 0) {
                                output += `**Action Items:**\n`;
                                deal.children.forEach((action, aIdx) => {
                                    output += `${aIdx + 1}. **${action.name}**\n`;
                                    if (action.description) {
                                        output += `   ${action.description}\n`;
                                    }
                                    if (action.expectedClose || action.expectedCloseDate) {
                                        output += `   _Due: ${action.expectedClose || action.expectedCloseDate}_\n`;
                                    }
                                    if (action.dependencies && action.dependencies.length > 0) {
                                        output += `   _Depends on: ${action.dependencies.join(', ')}_\n`;
                                    }
                                    output += `\n`;
                                });
                            }

                            // Competitive intelligence
                            if (deal.competitorInfo) {
                                output += `**ğŸ¯ Competitive Landscape:**\n${deal.competitorInfo}\n\n`;
                            }

                            // Dependencies/blockers
                            if (deal.dependencies && deal.dependencies.length > 0) {
                                output += `**âš ï¸ Dependencies:** This deal depends on: ${deal.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Risk Analysis & Recommendations
            output += `## âš ï¸ Risk Analysis & Recommendations\n\n`;
            output += `**Pipeline Coverage:**\n`;
            const averageCloseRate = Math.round(weightedPipelineValue / totalPipelineValue * 100);
            output += `- Current weighted close rate: ${averageCloseRate}%\n`;
            output += `- To hit 100% of targets, maintain ${Math.round(100 / averageCloseRate)}x pipeline coverage\n`;
            output += `- Low-probability deals (<50%): Focus on advancing or disqualifying quickly\n`;
            output += `- High-value deals (>$500K): Ensure executive sponsorship and multi-threading\n\n`;

            output += `**Key Actions:**\n`;
            output += `1. Accelerate deals in late stages (>70% probability) to close within quarter\n`;
            output += `2. Qualify out deals stuck in discovery for >2 months\n`;
            output += `3. Build relationships with economic buyers, not just champions\n`;
            output += `4. Document competitive wins and losses for pattern analysis\n`;
            output += `5. Request customer references from recent wins for social proof\n\n`;

            output += `---\n\n`;
            output += `**ğŸ’¡ AI Prompt Usage:** This sales pipeline can be used to:\n`;
            output += `- Ask AI to analyze deal health and suggest next best actions\n`;
            output += `- Generate sales enablement materials (case studies, proposals, ROI calculators)\n`;
            output += `- Forecast quarterly revenue with Monte Carlo simulations\n`;
            output += `- Identify at-risk deals based on activity patterns\n`;
            output += `- Draft personalized executive emails for each stakeholder\n`;
            output += `- Create competitive battlecards from competitorInfo fields\n\n`;

            return output;
        }

        // Generate Philosophy prompts (executable, professional)
        function generatePhilosophyPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ğŸ¤”'} ${tree.name || 'Philosophical Argument'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            output += `**Professional Philosophy Prompt** - Copy-paste ready for Claude/GPT-4\n\n`;
            output += `---\n\n`;

            // Collect all arguments
            const allArguments = [];
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach(item => {
                            allArguments.push({
                                ...item,
                                phaseName: phase.name,
                                phaseSubtitle: phase.subtitle
                            });
                        });
                    }
                });
            }

            if (allArguments.length === 0) {
                output += `*No arguments defined yet. Add items to your tree.*\n`;
                return output;
            }

            // Detect speakers and dialogue partners
            const speakers = [...new Set(allArguments.map(a => a.speaker).filter(s => s))];
            const primarySpeaker = speakers[0] || 'The Philosopher';
            const isDialogue = speakers.length > 1;

            // SYNTHESIZE: Create professional philosophical prompt

            // 1. CONTEXT & ROLE
            output += `## ğŸ“š Context\n\n`;
            output += `This is a ${isDialogue ? 'philosophical dialogue' : 'structured argument'} `;
            if (speakers.length > 0) {
                output += `featuring ${speakers.join(', ')}. `;
            }
            output += `The argument progresses through ${tree.children.length} major movements with ${allArguments.length} distinct claims.\n\n`;

            // 2. MAIN PROMPT
            output += `## ğŸ’­ Your Task\n\n`;
            output += `You are a philosophy professor preparing a comprehensive critical analysis. Write a 2500-word essay that:\n\n`;

            output += `**1. Reconstructs the Argument**\n`;
            output += `- Present each major claim in logical order\n`;
            output += `- Identify premises, inferences, and conclusions\n`;
            output += `- Map the dependency structure (which claims build on others)\n\n`;

            output += `**2. Evaluates Logical Validity**\n`;
            output += `- Are the inferences sound?\n`;
            output += `- Do the conclusions follow from the premises?\n`;
            output += `- What hidden assumptions are made?\n`;
            output += `- Are there logical fallacies?\n\n`;

            output += `**3. Engages Philosophically**\n`;
            output += `- What are the strongest objections to this view?\n`;
            output += `- How might the author respond?\n`;
            output += `- What implications does this have for ethics, epistemology, or metaphysics?\n`;
            output += `- How does this compare to contemporary philosophical positions?\n\n`;

            output += `**4. Applies to Modern Context**\n`;
            output += `- What modern issues does this illuminate?\n`;
            output += `- How would this argument address current debates?\n`;
            output += `- Is this view still defensible today? Why or why not?\n\n`;

            // 3. THE ARGUMENT STRUCTURE (as reference)
            output += `---\n\n`;
            output += `## ğŸ“– The Argument Structure\n\n`;
            output += `Use this as your reference material for the analysis above:\n\n`;

            tree.children.forEach((phase, phaseIdx) => {
                output += `### ${phase.name}\n`;
                if (phase.subtitle) {
                    output += `*${phase.subtitle}*\n`;
                }
                output += `\n`;

                if (phase.items && phase.items.length > 0) {
                    phase.items.forEach((item, itemIdx) => {
                        output += `**Argument ${phaseIdx + 1}.${itemIdx + 1}: ${item.name}**\n\n`;

                        if (item.description) {
                            output += `${item.description}\n\n`;
                        }

                        // Build structured argument info
                        const argDetails = [];

                        if (item.speaker) argDetails.push(`*Speaker*: ${item.speaker}`);
                        if (item.argumentType) argDetails.push(`*Type*: ${item.argumentType}`);
                        if (item.keyTerms) argDetails.push(`*Key Terms*: ${item.keyTerms}`);

                        if (argDetails.length > 0) {
                            output += argDetails.join(' â€¢ ') + '\n\n';
                        }

                        // Premises and conclusion in structured format
                        if (item.premise1 || item.premise2 || item.conclusion) {
                            output += `<argument>\n`;
                            if (item.premise1) output += `**P1**: ${item.premise1}\n\n`;
                            if (item.premise2) output += `**P2**: ${item.premise2}\n\n`;
                            if (item.premise3) output += `**P3**: ${item.premise3}\n\n`;
                            if (item.conclusion) output += `**âˆ´**: ${item.conclusion}\n`;
                            output += `</argument>\n\n`;
                        }

                        // Dependencies
                        if (item.dependencies && item.dependencies.length > 0) {
                            output += `*Builds on*: ${item.dependencies.join(', ')}\n\n`;
                        }

                        // Subtasks as supporting points
                        if (item.subtasks && item.subtasks.length > 0) {
                            output += `*Supporting points*:\n`;
                            item.subtasks.forEach(sub => {
                                output += `- ${sub.name}`;
                                if (sub.description) output += `: ${sub.description}`;
                                output += `\n`;
                            });
                            output += `\n`;
                        }
                    });
                }
            });

            // 4. OUTPUT STRUCTURE
            output += `---\n\n`;
            output += `## âœï¸ Essay Structure\n\n`;
            output += `Your 2500-word analysis should follow this structure:\n\n`;
            output += `**Introduction (300 words)**\n`;
            output += `- Introduce the philosophical problem\n`;
            output += `- State the main thesis being examined\n`;
            output += `- Preview your analytical approach\n\n`;

            output += `**Part I: Argument Reconstruction (600 words)**\n`;
            output += `- Present the argument structure clearly\n`;
            output += `- Identify all major premises and conclusions\n`;
            output += `- Map the logical flow and dependencies\n\n`;

            output += `**Part II: Logical Analysis (500 words)**\n`;
            output += `- Evaluate validity and soundness\n`;
            output += `- Identify hidden assumptions\n`;
            output += `- Note any fallacies or weak inferences\n\n`;

            output += `**Part III: Philosophical Engagement (600 words)**\n`;
            output += `- Present strongest objections\n`;
            output += `- Consider author's possible responses\n`;
            output += `- Discuss broader philosophical implications\n\n`;

            output += `**Part IV: Modern Application (400 words)**\n`;
            output += `- Connect to contemporary issues\n`;
            output += `- Assess relevance and defensibility today\n`;
            output += `- Suggest modifications or extensions\n\n`;

            output += `**Conclusion (100 words)**\n`;
            output += `- Summarize your analysis\n`;
            output += `- State your final evaluation of the argument\n\n`;

            // 5. EVALUATION CRITERIA
            output += `---\n\n`;
            output += `## âœ“ Success Criteria\n\n`;
            output += `Your essay should demonstrate:\n`;
            output += `- âœ… Accurate reconstruction of all ${allArguments.length} arguments\n`;
            output += `- âœ… Rigorous logical analysis using formal/informal logic\n`;
            output += `- âœ… Engagement with key philosophical concepts: ${getKeyTerms(allArguments)}\n`;
            output += `- âœ… Awareness of relevant philosophical traditions and debates\n`;
            output += `- âœ… Clear, precise philosophical writing (avoid vagueness)\n`;
            output += `- âœ… Fair-minded treatment (steel man, not straw man objections)\n`;
            output += `- âœ… Creative application to modern contexts\n`;
            output += `- âœ… Original insights, not mere summary\n\n`;

            // 6. ALTERNATIVE PROMPT MODES
            output += `---\n\n`;
            output += `## ğŸ”„ Alternative Prompt Modes\n\n`;

            if (isDialogue) {
                output += `**Mode 1: Continue the Dialogue**\n`;
                output += `\`\`\`\n`;
                output += `You are responding to ${primarySpeaker}'s arguments. Write a philosophical `;
                output += `dialogue where you (as an interlocutor) raise 3 sophisticated objections, `;
                output += `then have ${primarySpeaker} respond to each. Use the Socratic method `;
                output += `of questioning to probe deeper.\n`;
                output += `\`\`\`\n\n`;
            }

            output += `**Mode 2: Compare to Another Philosopher**\n`;
            output += `\`\`\`\n`;
            output += `Compare this argument to [Kant/Nietzsche/Rawls/Singer]. How would [philosopher] `;
            output += `respond to these claims? Where would they agree/disagree and why? What synthesis `;
            output += `might be possible between the two views?\n`;
            output += `\`\`\`\n\n`;

            output += `**Mode 3: Logical Formalization**\n`;
            output += `\`\`\`\n`;
            output += `Formalize this argument using predicate logic. Translate each premise and `;
            output += `conclusion into logical notation (âˆ€, âˆƒ, â†’, â†”, Â¬, âˆ§, âˆ¨). Prove validity using `;
            output += `natural deduction or truth tables. Identify which premises, if any, are dubious.\n`;
            output += `\`\`\`\n\n`;

            output += `**Mode 4: Teaching Guide**\n`;
            output += `\`\`\`\n`;
            output += `Create a teaching guide for undergraduate philosophy students. Include: `;
            output += `(1) Pre-reading questions, (2) Key concepts glossary, (3) Discussion prompts, `;
            output += `(4) Thought experiments to test understanding, (5) Essay topics.\n`;
            output += `\`\`\`\n\n`;

            // 7. PHILOSOPHICAL CONTEXT
            if (allArguments.some(a => a.argumentType)) {
                output += `---\n\n`;
                output += `## ğŸ“ Philosophical Methods Used\n\n`;
                const argTypes = [...new Set(allArguments.map(a => a.argumentType).filter(t => t))];
                argTypes.forEach(type => {
                    const count = allArguments.filter(a => a.argumentType === type).length;
                    output += `- **${type}** (${count} argument${count > 1 ? 's' : ''})\n`;
                });
                output += `\n`;
            }

            return output;
        }

        // Helper: Extract key terms for Philosophy prompt
        function getKeyTerms(arguments) {
            const allTerms = arguments
                .map(a => a.keyTerms)
                .filter(t => t)
                .join(', ')
                .split(',')
                .map(t => t.trim())
                .filter(t => t.length > 0);

            // Get unique terms, limit to top 8
            const uniqueTerms = [...new Set(allTerms)].slice(0, 8);
            return uniqueTerms.join(', ');
        }

        // Generate generic prompt format
        function generateGenericPrompt(tree, pattern) {
            // SPECIAL CASE: AI Video Production uses different format
            if (currentPattern === 'film') {
                return generateAIVideoPrompts(tree, pattern);
            }

            // SPECIAL CASE: Philosophy uses different format
            if (currentPattern === 'philosophy') {
                return generatePhilosophyPrompt(tree, pattern);
            }

            // SPECIAL CASE: Sales Pipeline uses different format
            if (currentPattern === 'sales') {
                return generateSalesPrompt(tree, pattern);
            }

            // SPECIAL CASE: Thesis/Academic uses different format
            if (currentPattern === 'thesis') {
                return generateThesisPrompt(tree, pattern);
            }

            // SPECIAL CASE: Product Roadmap uses different format
            if (currentPattern === 'roadmap') {
                return generateRoadmapPrompt(tree, pattern);
            }

            // SPECIAL CASE: Book/Novel uses different format
            if (currentPattern === 'book') {
                return generateBookPrompt(tree, pattern);
            }

            // SPECIAL CASE: Course/Training uses different format
            if (currentPattern === 'course') {
                return generateCoursePrompt(tree, pattern);
            }

            let prompt = `# ${tree.icon || 'ğŸ“‹'} ${tree.name || 'Project'}\n\n`;

            if (tree.description) {
                prompt += `${tree.description}\n\n`;
            }

            prompt += `---\n\n`;

            // Introduction based on pattern
            const patternIntros = {
                'sales': `You are a sales analyst. Follow this structured sales pipeline analysis:`,
                'thesis': `You are an academic advisor. Follow this thesis structure:`,
                'roadmap': `You are a product manager. Follow this product roadmap:`,
                'book': `You are a writing coach. Follow this book structure:`,
                'event': `You are an event planner. Follow this event plan:`,
                'fitness': `You are a fitness coach. Follow this training program:`,
                'strategy': `You are a business strategist. Follow this strategic plan:`,
                'course': `You are an educator. Follow this course structure:`,
                'philosophy': `You are a philosophy scholar. Follow this philosophical argument:`,
                'familytree': `You are a genealogist. Follow this family tree structure:`,
                'generic': `Follow this structured workflow:`
            };

            prompt += `${patternIntros[currentPattern] || patternIntros['generic']}\n\n`;

            // Process each phase
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    prompt += `## ${pattern.levels.phase} ${phaseIdx + 1}: ${phase.name}\n`;
                    if (phase.subtitle) {
                        prompt += `*${phase.subtitle}*\n`;
                    }
                    prompt += `\n`;

                    // Add items
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            prompt += `### ${itemIdx + 1}. ${item.name}\n`;

                            if (item.description) {
                                prompt += `${item.description}\n`;
                            }

                            // Add ALL pattern-specific fields dynamically
                            prompt += `\n`;
                            if (pattern.fields) {
                                Object.keys(pattern.fields).forEach(fieldKey => {
                                    const fieldConfig = pattern.fields[fieldKey];

                                    // Skip non-field properties
                                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                                        return;
                                    }

                                    const value = item[fieldKey];
                                    if (value !== undefined && value !== null && value !== '') {
                                        let displayValue = value;

                                        // Format based on field type
                                        if (fieldConfig.type === 'number') {
                                            if (fieldKey === 'cost' || fieldKey === 'dealValue') {
                                                displayValue = formatCost(value);
                                            } else {
                                                displayValue = value;
                                            }
                                        } else if (fieldConfig.type === 'date') {
                                            displayValue = new Date(value).toLocaleDateString();
                                        }

                                        prompt += `- **${fieldConfig.label}**: ${displayValue}\n`;
                                    }
                                });
                            }

                            // Add dependencies
                            if (item.dependencies && item.dependencies.length > 0) {
                                const deps = Array.isArray(item.dependencies) ? item.dependencies.join(', ') : item.dependencies;
                                prompt += `- **Dependencies**: ${deps}\n`;
                            }

                            // Add PM tracking fields if present
                            if (item.pmStatus) prompt += `- **Status**: ${item.pmStatus}\n`;
                            if (item.pmAssignee) prompt += `- **Assignee**: ${item.pmAssignee}\n`;
                            if (item.pmProgress !== undefined) prompt += `- **Progress**: ${item.pmProgress}%\n`;
                            if (item.pmPriority) prompt += `- **Priority**: ${item.pmPriority}\n`;
                            if (item.pmDueDate) prompt += `- **Due Date**: ${new Date(item.pmDueDate).toLocaleDateString()}\n`;

                            // Add subtasks
                            if (item.subtasks && item.subtasks.length > 0) {
                                prompt += `\nAction steps:\n`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    prompt += `${subIdx + 1}. ${subtask.name}`;
                                    if (subtask.description) {
                                        prompt += `: ${subtask.description}`;
                                    }
                                    // Add subtask PM tracking if present
                                    const pmInfo = [];
                                    if (subtask.pmStatus) pmInfo.push(`Status: ${subtask.pmStatus}`);
                                    if (subtask.pmAssignee) pmInfo.push(`Assignee: ${subtask.pmAssignee}`);
                                    if (subtask.pmProgress !== undefined) pmInfo.push(`${subtask.pmProgress}%`);
                                    if (pmInfo.length > 0) {
                                        prompt += ` [${pmInfo.join(', ')}]`;
                                    }
                                    prompt += `\n`;
                                });
                            }

                            prompt += `\n`;
                        });
                    }

                    prompt += `\n`;
                });
            }

            // Footer
            prompt += `---\n\n`;
            prompt += `Provide a comprehensive response following this structure, addressing each ${pattern.levels.phase.toLowerCase()} and ${pattern.levels.item.toLowerCase()} systematically.\n`;

            return prompt;
        }

        // AI Modal - Overall Project Analysis (Dynamic AI-Generated)
        document.getElementById('ai-btn').addEventListener('click', async () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;

            document.getElementById('modal-title').textContent = `âœ¨ ${pattern.name} Analysis`;

            // Count items by phase
            function countItems(node, counts = {p0: 0, p1: 0, p2: 0}) {
                if (node.items && node.phase !== undefined) {
                    counts[`p${node.phase}`] += node.items.length;
                }
                if (node.children) {
                    node.children.forEach(child => countItems(child, counts));
                }
                return counts;
            }

            const itemCounts = countItems(capexTree);

            // Pattern-aware summary cards
            let summaryHTML = '';

            // For financial patterns (generic, sales, roadmap, strategy)
            if (pattern.fields && pattern.fields.cost) {
                const totalCost = calculateTotal(capexTree);
                const getPhaseCost = (phaseId) => {
                    const phase = findNode(phaseId);
                    return phase ? calculatePhaseTotal(phase) : 0;
                };

                const phase0Cost = getPhaseCost('phase-0');
                const phase1Cost = getPhaseCost('phase-1');
                const phase2Cost = getPhaseCost('phase-2');

                summaryHTML = `
                    <div style="background: linear-gradient(135deg, var(--treeplex-primary), #009977); color: white; padding: 24px; border-radius: 12px; margin-bottom: 24px;">
                        <h2 style="margin-bottom: 8px; font-size: 32px;">${formatCost(totalCost)}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Total Project Investment</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-0);">
                            <div style="font-size: 11px; font-weight: 600; color: #2e7d32; margin-bottom: 4px;">${levels.phase.toUpperCase()} 1</div>
                            <div style="font-size: 20px; font-weight: 700; color: #1b5e20; margin-bottom: 4px;">${formatCost(phase0Cost)}</div>
                            <div style="font-size: 12px; color: #2e7d32;">${itemCounts.p0} ${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-1);">
                            <div style="font-size: 11px; font-weight: 600; color: #1565c0; margin-bottom: 4px;">${levels.phase.toUpperCase()} 2</div>
                            <div style="font-size: 20px; font-weight: 700; color: #0d47a1; margin-bottom: 4px;">${formatCost(phase1Cost)}</div>
                            <div style="font-size: 12px; color: #1565c0;">${itemCounts.p1} ${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #fff3e0; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-2);">
                            <div style="font-size: 11px; font-weight: 600; color: #e65100; margin-bottom: 4px;">${levels.phase.toUpperCase()} 3</div>
                            <div style="font-size: 20px; font-weight: 700; color: #bf360c; margin-bottom: 4px;">${formatCost(phase2Cost)}</div>
                            <div style="font-size: 12px; color: #e65100;">${itemCounts.p2} ${levels.item.toLowerCase()}s</div>
                        </div>
                    </div>`;
            } else {
                // For non-financial patterns (AI Prompt Design, Philosophy, etc.)
                const totalItems = itemCounts.p0 + itemCounts.p1 + itemCounts.p2;
                const totalSubtasks = capexTree.children?.reduce((acc, phase) => {
                    return acc + (phase.items?.reduce((itemAcc, item) => {
                        return itemAcc + (item.subtasks?.length || 0);
                    }, 0) || 0);
                }, 0) || 0;

                summaryHTML = `
                    <div style="background: linear-gradient(135deg, var(--treeplex-primary), #8b5cf6); color: white; padding: 24px; border-radius: 12px; margin-bottom: 24px;">
                        <h2 style="margin-bottom: 8px; font-size: 32px;">${pattern.icon} ${capexTree.name || pattern.levels.root}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">${capexTree.children?.length || 0} ${levels.phase}s â€¢ ${totalItems} ${levels.item}s â€¢ ${totalSubtasks} ${levels.subtask}s</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-0);">
                            <div style="font-size: 11px; font-weight: 600; color: #2e7d32; margin-bottom: 4px;">${levels.phase.toUpperCase()} 1</div>
                            <div style="font-size: 20px; font-weight: 700; color: #1b5e20; margin-bottom: 4px;">${itemCounts.p0}</div>
                            <div style="font-size: 12px; color: #2e7d32;">${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-1);">
                            <div style="font-size: 11px; font-weight: 600; color: #1565c0; margin-bottom: 4px;">${levels.phase.toUpperCase()} 2</div>
                            <div style="font-size: 20px; font-weight: 700; color: #0d47a1; margin-bottom: 4px;">${itemCounts.p1}</div>
                            <div style="font-size: 12px; color: #1565c0;">${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #fff3e0; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-2);">
                            <div style="font-size: 11px; font-weight: 600; color: #e65100; margin-bottom: 4px;">${levels.phase.toUpperCase()} 3</div>
                            <div style="font-size: 20px; font-weight: 700; color: #bf360c; margin-bottom: 4px;">${itemCounts.p2}</div>
                            <div style="font-size: 12px; color: #e65100;">${levels.item.toLowerCase()}s</div>
                        </div>
                    </div>`;
            }

            // Show summary + loading state for AI analysis
            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    ${summaryHTML}

                    <div id="ai-analysis-loading" style="padding: 40px; text-align: center; background: var(--card-bg); border-radius: 12px; margin-top: 20px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary); font-size: 14px;">AI is analyzing your ${pattern.name.toLowerCase()}...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Generating insights and recommendations</p>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Call AI to generate the analysis sections dynamically
            console.log('ğŸ¤– Calling AI analysis at:', AI_CONFIG.apiEndpoint);
            try {
                const aiResponse = await generateAIAnalysis(capexTree, 'project');

                // Replace loading with AI-generated content
                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                        <div style="margin-bottom: 20px;">
                            <div id="ai-generated-content" style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                                <div style="white-space: pre-wrap; font-size: 14px; line-height: 1.8; color: var(--text-primary);">${aiResponse}</div>
                            </div>
                            <div style="margin-top: 16px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ğŸ¤– Analysis powered by Claude Sonnet â€¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;
                }

            } catch (error) {
                // Fallback to static analysis when AI is unavailable
                console.warn('AI Analysis unavailable, using static fallback:', error.message);

                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">CRITICAL PATH ANALYSIS</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    â€¢ <strong>Land acquisition</strong> is the primary gating factor for Phase 1 execution<br>
                                    â€¢ <strong>Turbine PO deposit</strong> (${formatCost(2000000)}) secures manufacturing capacity for Phase 2<br>
                                    â€¢ <strong>Pipeline FEED</strong> and permitting run in parallel to optimize timeline<br>
                                    â€¢ Phase 2 equipment procurement has 12-18 month lead times requiring early commitment
                                </p>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">RISK ASSESSMENT</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    <strong style="color: #d32f2f;">High Risk:</strong> Phase 2 represents ${((phase2Cost/totalCost)*100).toFixed(0)}% of total budget concentrated in equipment and infrastructure.<br>
                                    <strong style="color: #f57c00;">Medium Risk:</strong> Regulatory approvals for land, pipeline, and permitting on critical path.<br>
                                    <strong style="color: #388e3c;">Low Risk:</strong> Phase 0 has manageable capital exposure with assignable land options.
                                </p>
                            </div>

                            <div style="background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); padding: 20px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--treeplex-primary); text-transform: uppercase; letter-spacing: 0.5px;">STRATEGIC RECOMMENDATIONS</h4>
                                <ul style="font-size: 14px; line-height: 2; margin: 0; padding-left: 20px; color: var(--text-primary);">
                                    <li>Secure Phase 0 land option immediately to unlock downstream activities</li>
                                    <li>Negotiate payment milestones tied to regulatory approvals</li>
                                    <li>Consider project financing for Phase 2 to preserve equity</li>
                                    <li>Establish vendor relationships early for long-lead equipment items</li>
                                    <li>Build 10-15% contingency buffer beyond stated ${formatCost(310000)} reserves</li>
                                </ul>
                            </div>
                        </div>
                        <div style="margin-top: 16px; padding: 12px; background: rgba(255, 152, 0, 0.1); border-radius: 6px; text-align: center; border: 1px solid rgba(255, 152, 0, 0.3);">
                            <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                â„¹ï¸ AI Analysis unavailable â€¢ Showing static analysis â€¢ Deploy to Netlify for dynamic AI insights
                            </p>
                        </div>
                    </div>
                `;
                }
            }
        });

        document.getElementById('modal-close').addEventListener('click', () => {
            document.getElementById('modal').style.display = 'none';
        });

        // =============================================================================
        // API KEY CONFIGURATION
        // =============================================================================

        // Show/hide API keys toggle
        document.getElementById('api-key-show').addEventListener('change', (e) => {
            const claudeInput = document.getElementById('claude-api-key-input');
            const geminiInput = document.getElementById('gemini-api-key-input');
            const openaiInput = document.getElementById('openai-api-key-input');
            const inputType = e.target.checked ? 'text' : 'password';
            claudeInput.type = inputType;
            geminiInput.type = inputType;
            openaiInput.type = inputType;
        });

        // Clear all API keys
        document.getElementById('api-key-clear').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all saved API keys? This action cannot be undone.')) {
                clearLocalAPIKey('anthropic');
                clearLocalAPIKey('gemini');
                clearLocalAPIKey('openai');
                document.getElementById('claude-api-key-input').value = '';
                document.getElementById('gemini-api-key-input').value = '';
                document.getElementById('openai-api-key-input').value = '';
                updateKeyStatusBadges();
                console.log('ğŸ—‘ï¸ All API keys cleared');
                alert('All API keys have been cleared.');
            }
        });

        // Cancel API key modal
        document.getElementById('api-key-cancel').addEventListener('click', () => {
            document.getElementById('api-key-modal').style.display = 'none';
        });

        document.getElementById('api-key-btn').addEventListener('click', () => {
            showApiKeyModal(true);
        });

        // Unified AI Mode selector
        document.getElementById('unified-ai-mode-select').addEventListener('change', (e) => {
            const newMode = e.target.value;
            const parsed = parseUnifiedMode(newMode);

            // Check if this mode requires an API key
            if (parsed.requiresKey) {
                const provider = parsed.provider;
                const hasKey = getLocalAPIKey(provider);

                if (!hasKey) {
                    // Show helpful message about needing API key
                    const providerName = provider === 'anthropic' ? 'Claude' :
                                       provider === 'gemini' ? 'Gemini' : 'OpenAI';

                    alert(`ğŸ”‘ This mode requires your ${providerName} API key.\n\nPlease click the ğŸ”‘ API Key button to configure your key, then try again.`);

                    // Revert to previous mode
                    const currentMode = getUnifiedAIMode();
                    e.target.value = currentMode;
                    return;
                }
            }

            // Save the new mode
            setUnifiedAIMode(newMode);

            // Show informational message
            console.log(`âœ… AI Mode: ${parsed.description}`);

            // Show user-friendly toast
            if (parsed.enabled) {
                const modeLabel = e.target.options[e.target.selectedIndex].text;
                showToast(`âœ… AI Mode: ${modeLabel}`);
            } else {
                showToast('âŒ AI features disabled');
            }
        });

        // Initialize unified AI mode selector on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Attach Canvas view toggle
            const toggleBtn = document.getElementById('toggle-view-mode');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleViewMode);
            }

            // Attach Canvas export button
            const exportCanvasBtn = document.getElementById('export-canvas-btn');
            if (exportCanvasBtn) {
                exportCanvasBtn.addEventListener('click', exportCanvasAsImage);
            }

            // Initialize canvas event listeners
            initializeCanvasEvents();

            // Rebind expand/collapse buttons to use progressive collapse/expand
            // Wait a bit for TreeListy to finish its initialization
            setTimeout(() => {
                const expandBtn = document.getElementById('expand-btn');
                const collapseBtn = document.getElementById('collapse-btn');

                if (expandBtn) {
                    // Remove all existing listeners by cloning the button
                    const newExpandBtn = expandBtn.cloneNode(true);
                    expandBtn.parentNode.replaceChild(newExpandBtn, expandBtn);

                    // Add new listener with progressive expand
                    newExpandBtn.addEventListener('click', () => {
                        console.log('â¬‡ï¸ Progressive Expand clicked');
                        if (typeof canvasExpandOneLevel === 'function') {
                            canvasExpandOneLevel();
                        }
                    });
                }

                if (collapseBtn) {
                    // Remove all existing listeners by cloning the button
                    const newCollapseBtn = collapseBtn.cloneNode(true);
                    collapseBtn.parentNode.replaceChild(newCollapseBtn, collapseBtn);

                    // Add new listener with progressive collapse
                    newCollapseBtn.addEventListener('click', () => {
                        console.log('â¬†ï¸ Progressive Collapse clicked');
                        if (typeof canvasCollapseOneLevel === 'function') {
                            canvasCollapseOneLevel();
                        }
                    });
                }
            }, 500);

            // Bind Canvas toolbar buttons
            const autoLayoutSelect = document.getElementById('auto-layout-select');
            const gridToggleBtn = document.getElementById('grid-toggle');
            const resetViewBtn = document.getElementById('reset-view');
            const fitViewBtn = document.getElementById('fit-view');
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');

            if (autoLayoutSelect) {
                autoLayoutSelect.addEventListener('change', (e) => {
                    if (e.target.value) {
                        applyAutoLayout(e.target.value);
                        e.target.value = '';  // Reset to default
                    }
                });
            }

            // Cluster-by selector event listener
            const clusterBySelect = document.getElementById('cluster-by-select');
            if (clusterBySelect) {
                // Populate on load
                updateClusterByOptions();

                clusterBySelect.addEventListener('change', (e) => {
                    clusterByField = e.target.value;
                    if (clusterByField) {
                        console.log(`Clustering enabled by: ${clusterByField}`);

                        // Auto-sync: update sort to match cluster field if linked
                        if (sortClusterLinked) {
                            const sortSelect = document.getElementById('pattern-sort-select');
                            if (sortSelect) {
                                // Try to find matching sort option by field
                                const matchingOption = Array.from(sortSelect.options).find(
                                    opt => opt.dataset && opt.dataset.field === clusterByField
                                );
                                if (matchingOption) {
                                    sortSelect.value = matchingOption.value;
                                    // Trigger sort
                                    const sortConfig = {
                                        value: matchingOption.value,
                                        field: matchingOption.dataset.field,
                                        order: matchingOption.dataset.order,
                                        type: matchingOption.dataset.type
                                    };
                                    sortTree(sortConfig);
                                    const resetSortBtn = document.getElementById('reset-sort-btn');
                                    if (resetSortBtn) resetSortBtn.style.display = 'inline-block';
                                    console.log(`ğŸ”— Auto-synced Sort to: ${clusterByField}`);
                                }
                            }
                        }

                        // Re-apply force-directed layout if currently in canvas mode
                        if (viewMode === 'canvas') {
                            applyForceDirectedLayout();
                            renderCanvas();
                        }

                        const linkedMsg = sortClusterLinked ? ' (Tree synced)' : '';
                        showToast(`Clustered by: ${e.target.options[e.target.selectedIndex].textContent}${linkedMsg}`, 'success', 2000);
                    } else {
                        console.log('Clustering disabled');

                        // Auto-sync: reset sort too if linked
                        if (sortClusterLinked) {
                            const sortSelect = document.getElementById('pattern-sort-select');
                            const resetSortBtn = document.getElementById('reset-sort-btn');
                            if (sortSelect) {
                                sortSelect.value = '';
                                currentSortConfig = null;
                                sortTree(null);
                                if (resetSortBtn) resetSortBtn.style.display = 'none';
                            }
                        }
                    }
                });
            }

            if (gridToggleBtn) {
                gridToggleBtn.addEventListener('click', toggleGrid);
            }

            if (resetViewBtn) {
                resetViewBtn.addEventListener('click', resetView);
            }

            if (fitViewBtn) {
                fitViewBtn.addEventListener('click', fitToView);
            }

            // BUILD 547: +/- buttons zoom toward viewport center
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    zoomCanvasCenter(1.2);
                });
            }

            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    zoomCanvasCenter(1 / 1.2);
                });
            }

            const savedMode = getUnifiedAIMode();
            const select = document.getElementById('unified-ai-mode-select');
            if (select) {
                select.value = savedMode;
            }
        });

        // Save API key(s)
        document.getElementById('api-key-save').addEventListener('click', () => {
            const claudeKey = document.getElementById('claude-api-key-input').value.trim();
            const geminiKey = document.getElementById('gemini-api-key-input').value.trim();
            const openaiKey = document.getElementById('openai-api-key-input').value.trim();
            const selectedProvider = document.getElementById('provider-select').value;

            // Validate keys if provided
            if (claudeKey && !claudeKey.startsWith('sk-ant-')) {
                alert('Invalid Claude API key format. Anthropic API keys start with "sk-ant-"');
                return;
            }

            if (geminiKey && !geminiKey.startsWith('AIza')) {
                alert('Invalid Gemini API key format. Google API keys typically start with "AIza"');
                return;
            }

            if (openaiKey && !openaiKey.startsWith('sk-')) {
                alert('Invalid OpenAI API key format. OpenAI API keys start with "sk-"');
                return;
            }

            // Check if selected provider has a key
            if (selectedProvider === 'anthropic' && !claudeKey && !getLocalAPIKey('anthropic')) {
                alert('Please enter a Claude API key, or switch to another provider.');
                return;
            }

            if (selectedProvider === 'gemini' && !geminiKey && !getLocalAPIKey('gemini')) {
                alert('Please enter a Gemini API key, or switch to another provider.');
                return;
            }

            if (selectedProvider === 'openai' && !openaiKey && !getLocalAPIKey('openai')) {
                alert('Please enter an OpenAI API key, or switch to another provider.');
                return;
            }

            // Save keys if provided (preserves existing keys if not changed)
            if (claudeKey) {
                setLocalAPIKey(claudeKey, 'anthropic');
                console.log('âœ… Claude API key saved');
            }

            if (geminiKey) {
                setLocalAPIKey(geminiKey, 'gemini');
                console.log('âœ… Gemini API key saved');
            }

            if (openaiKey) {
                setLocalAPIKey(openaiKey, 'openai');
                console.log('âœ… OpenAI API key saved');
            }

            // Save provider preference
            setAIProvider(selectedProvider);
            console.log(`âœ… Primary AI provider set to: ${selectedProvider}`);

            // Close modal
            document.getElementById('api-key-modal').style.display = 'none';

            // If we came from Analysis Mode, reopen it
            if (window.pendingAnalysisMode) {
                window.pendingAnalysisMode = false;
                document.getElementById('analyze-text-btn').click();
            }
        });

        // Function to check if API key is configured
        function checkAPIKeyConfigured(options = {}) {
            const { forcePrompt = false } = options;
            const localKey = getLocalAPIKey();
            if (localKey) {
                return true;
            }

            if (!forcePrompt && canUseServerlessAI()) {
                console.log('ğŸŒ No local API key found. Using Netlify serverless function for AI calls.');
                return true;
            }

            // No local key and serverless unavailable (or prompt requested) - show modal
            showApiKeyModal(false);
            return false;
        }

        // =============================================================================
        // AI REVIEW & ENHANCE SYSTEM
        // =============================================================================

        // Open AI Review modal and analyze tree
        document.getElementById('ai-review-btn').addEventListener('click', async () => {
            // Check if AI is enabled
            const aiMode = getGlobalAIMode();
            if (aiMode === 'off') {
                alert('âŒ AI features are currently disabled.\n\nPlease enable AI mode in the header (ğŸ¤– AI dropdown) to use AI Review.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            // Check if tree has content
            if (!hasExistingContent()) {
                alert('âš ï¸ Your tree is empty.\n\nPlease add some content first, then use AI Review to get suggestions for improvements.');
                return;
            }

            // Open modal and start analysis
            document.getElementById('ai-review-modal').style.display = 'flex';
            document.getElementById('ai-review-status').style.display = 'block';
            document.getElementById('ai-review-results').style.display = 'none';

            await performAIReview();
        });

        // Close AI Review modal
        document.getElementById('close-ai-review-modal').addEventListener('click', () => {
            document.getElementById('ai-review-modal').style.display = 'none';
        });

        // Re-analyze button
        document.getElementById('ai-review-again').addEventListener('click', async () => {
            document.getElementById('ai-review-status').style.display = 'block';
            document.getElementById('ai-review-results').style.display = 'none';
            await performAIReview();
        });

        // Perform AI Review of the tree
        async function performAIReview() {
            const pattern = PATTERNS[currentPattern];
            const tree = capexTree;

            try {
                // Build pattern-specific review prompt
                const reviewPrompt = buildReviewPrompt(tree, pattern);

                console.log('ğŸ”¬ Starting AI Review...');
                console.log('Pattern:', currentPattern);
                console.log('Tree:', tree.name);

                // Call AI with extended thinking for deep analysis
                const aiMode = getGlobalAIMode();
                const useExtendedThinking = aiMode === 'deep';

                // Extended thinking has budget_tokens = 5000, so maxTokens must be > 5000
                // Using 8000 to give 3000 tokens for actual response content
                const maxTokensForReview = useExtendedThinking ? 8000 : 4096;

                // Pattern-specific expert personas for AI Review
                const reviewExperts = {
                    philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments. Review for logical validity, premise strength, and dialectical completeness.',
                    sales: 'You are a sales strategist with 20 years of enterprise B2B experience. Review for pipeline health, deal qualification, and revenue optimization.',
                    thesis: 'You are an academic advisor helping graduate students structure rigorous research. Review for argument progression, citation quality, and scholarly standards.',
                    roadmap: 'You are a product manager experienced in agile development and feature prioritization. Review for execution readiness, story completeness, and technical feasibility.',
                    prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude, GPT-4, and other LLMs. Review for prompt clarity, few-shot example quality, output format specification, and edge case handling.',
                    book: 'You are a professional fiction editor and writing coach. Review for narrative flow, character development, and pacing.',
                    film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway). Review for visual storytelling, shot composition, and production feasibility.',
                    course: 'You are an instructional designer with expertise in curriculum development. Review for learning progression, assessment alignment, and instructional scaffolding.',
                    dialogue: 'You are a debate coach and rhetoric expert specializing in argumentation theory, logical fallacies, and persuasive communication. Review for argument strength, rhetorical effectiveness, fallacy identification, and evidence quality.',
                    filesystem: 'You are LibrarianAI, a filesystem organization expert. Review for folder structure clarity, file naming consistency, redundancy reduction, data quality, and organizational best practices. Focus on metadata enrichment opportunities and safe, non-destructive improvements.',
                    generic: `You are an expert ${pattern.name} analyst. Review the provided tree structure for completeness, redundancies, logical flow, and alignment with ${pattern.name} best practices.`
                };

                const expertPersona = reviewExperts[currentPattern] || reviewExperts.generic;

                const content = await callClaudeAPI(
                    reviewPrompt,
                    expertPersona + ' Provide specific, actionable suggestions.',
                    maxTokensForReview,
                    useExtendedThinking
                );

                // Parse the AI response and display results
                displayReviewResults(content);

            } catch (error) {
                console.error('âŒ AI Review error:', error);
                document.getElementById('ai-review-status').innerHTML = `
                    <div style="padding: 15px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">âŒ Error during analysis</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            ${error.message}
                        </div>
                    </div>
                `;
            }
        }

        // Build pattern-specific review prompt
        function buildReviewPrompt(tree, pattern) {
            const levels = pattern.levels;
            let prompt = `# ${pattern.name} Tree Review\n\n`;
            prompt += `**Project:** ${tree.name}\n`;
            prompt += `**Pattern:** ${pattern.name}\n\n`;

            // Count items
            const itemCounts = {
                phases: tree.children ? tree.children.length : 0,
                items: 0,
                subtasks: 0
            };

            if (tree.children) {
                tree.children.forEach(phase => {
                    // Support 'items' (standard), 'children' (filesystem), and 'subItems' (philosophy)
                    const nodeList = phase.items || phase.children || phase.subItems || [];
                    if (nodeList.length > 0) {
                        itemCounts.items += nodeList.length;
                        nodeList.forEach(item => {
                            if (item.subtasks || item.children) {
                                itemCounts.subtasks += (item.subtasks || item.children || []).length;
                            }
                        });
                    }
                });
            }

            prompt += `**Current Structure:**\n`;
            prompt += `- ${itemCounts.phases} ${levels.phase}(s)\n`;
            prompt += `- ${itemCounts.items} ${levels.item}(s)\n`;
            prompt += `- ${itemCounts.subtasks} ${levels.subtask}(s)\n\n`;

            // Add tree content
            prompt += `## Tree Structure\n\n`;
            if (tree.children) {
                tree.children.forEach((phase, pIdx) => {
                    prompt += `### ${pIdx + 1}. ${phase.name}\n\n`;
                    if (phase.description) {
                        prompt += `${phase.description}\n\n`;
                    }

                    // Support 'items' (standard), 'children' (filesystem), and 'subItems' (philosophy)
                    const nodeList = phase.items || phase.children || phase.subItems || [];
                    if (nodeList.length > 0) {
                        nodeList.forEach((item, iIdx) => {
                            prompt += `  **${iIdx + 1}. ${item.name}**\n`;
                            if (item.description) {
                                prompt += `  ${item.description}\n`;
                            }

                            // Add pattern-specific fields
                            const fields = Object.keys(item).filter(k =>
                                !['id', 'name', 'icon', 'type', 'description', 'subtasks', 'children', 'dependencies'].includes(k)
                            );

                            if (fields.length > 0) {
                                prompt += `  Fields: ${fields.join(', ')}\n`;
                            }
                            prompt += `\n`;
                        });
                    }
                    prompt += `\n`;
                });
            }

            // Pattern-specific review criteria
            prompt += `\n## Review Criteria\n\n`;
            prompt += `Please analyze this ${pattern.name} tree and provide:\n\n`;

            prompt += `1. **Completeness Check:**\n`;
            prompt += `   - Are all necessary ${levels.item.toLowerCase()}s present?\n`;
            prompt += `   - Are there obvious gaps in the ${levels.phase.toLowerCase()} coverage?\n`;
            prompt += `   - Are critical fields missing values?\n\n`;

            prompt += `2. **Redundancy Analysis:**\n`;
            prompt += `   - Are there duplicate or overlapping ${levels.item.toLowerCase()}s?\n`;
            prompt += `   - Can any ${levels.item.toLowerCase()}s be merged or consolidated?\n\n`;

            prompt += `3. **Logical Flow:**\n`;
            prompt += `   - Do the ${levels.phase.toLowerCase()}s follow a logical sequence?\n`;
            prompt += `   - Are dependencies properly structured?\n`;
            prompt += `   - Does the tree structure make sense for this ${pattern.name}?\n\n`;

            prompt += `4. **Pattern Alignment:**\n`;
            prompt += `   - Does this follow ${pattern.name} best practices?\n`;
            prompt += `   - Are pattern-specific fields used appropriately?\n`;
            prompt += `   - What could improve alignment with ${pattern.name} standards?\n\n`;

            // Pattern-specific additions
            if (currentPattern === 'philosophy') {
                prompt += `5. **Philosophical Rigor:**\n`;
                prompt += `   - Are premises logically valid?\n`;
                prompt += `   - Are objections comprehensive?\n`;
                prompt += `   - Are textual references adequate?\n\n`;
            } else if (currentPattern === 'sales') {
                prompt += `5. **Pipeline Health:**\n`;
                prompt += `   - Are all pipeline stages represented?\n`;
                prompt += `   - Are deal values and probabilities realistic?\n`;
                prompt += `   - Are key competitors identified?\n\n`;
            } else if (currentPattern === 'thesis') {
                prompt += `5. **Academic Standards:**\n`;
                prompt += `   - Is the argument progression clear?\n`;
                prompt += `   - Are citations sufficient?\n`;
                prompt += `   - Is chapter balance appropriate?\n\n`;
            } else if (currentPattern === 'roadmap') {
                prompt += `5. **Execution Readiness:**\n`;
                prompt += `   - Are user stories well-defined?\n`;
                prompt += `   - Are story points assigned?\n`;
                prompt += `   - Are technical risks identified?\n\n`;
            } else if (currentPattern === 'book') {
                prompt += `5. **Narrative Structure:**\n`;
                prompt += `   - Does the story arc flow naturally?\n`;
                prompt += `   - Are character arcs developed?\n`;
                prompt += `   - Is pacing appropriate?\n\n`;
            } else if (currentPattern === 'course') {
                prompt += `5. **Instructional Design:**\n`;
                prompt += `   - Is learning progression scaffolded?\n`;
                prompt += `   - Are assessments aligned with objectives?\n`;
                prompt += `   - Is content appropriately chunked?\n\n`;
            } else if (currentPattern === 'prompting') {
                prompt += `5. **Prompt Engineering Quality:**\n`;
                prompt += `   - Are system prompts clear and specific?\n`;
                prompt += `   - Do few-shot examples cover edge cases?\n`;
                prompt += `   - Are output formats well-defined?\n`;
                prompt += `   - Are chain-of-thought instructions effective?\n`;
                prompt += `   - Are test cases comprehensive?\n\n`;
            }

            prompt += `## Output Format\n\n`;
            prompt += `Provide your analysis in the following format:\n\n`;
            prompt += `**SUMMARY:** (2-3 sentences overview of tree quality)\n\n`;
            prompt += `**STRENGTHS:** (Bullet list of what's working well)\n\n`;
            prompt += `**GAPS:** (Specific missing items or fields)\n\n`;
            prompt += `**REDUNDANCIES:** (Items that could be merged)\n\n`;
            prompt += `**IMPROVEMENTS:** (Actionable suggestions to enhance the tree)\n\n`;

            return prompt;
        }

        // Display AI review results
        function displayReviewResults(response) {
            // Hide status, show results
            document.getElementById('ai-review-status').style.display = 'none';
            document.getElementById('ai-review-results').style.display = 'block';

            // Parse response sections
            const sections = {
                summary: extractSection(response, 'SUMMARY'),
                strengths: extractSection(response, 'STRENGTHS'),
                gaps: extractSection(response, 'GAPS'),
                redundancies: extractSection(response, 'REDUNDANCIES'),
                improvements: extractSection(response, 'IMPROVEMENTS')
            };

            // Build summary HTML
            const summaryHTML = `
                <div style="padding: 16px; background: var(--card-bg); border-radius: 8px; margin-bottom: 16px;">
                    ${sections.summary || 'Analysis complete.'}
                </div>

                ${sections.strengths ? `
                <div style="padding: 16px; background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #10b981; font-size: 14px;">âœ… Strengths</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.strengths)}</div>
                </div>
                ` : ''}

                ${sections.gaps ? `
                <div style="padding: 16px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #ef4444; font-size: 14px;">âš ï¸ Gaps</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.gaps)}</div>
                </div>
                ` : ''}

                ${sections.redundancies ? `
                <div style="padding: 16px; background: rgba(245, 158, 11, 0.1); border-left: 3px solid #f59e0b; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #f59e0b; font-size: 14px;">ğŸ”„ Redundancies</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.redundancies)}</div>
                </div>
                ` : ''}
            `;

            document.getElementById('ai-review-summary').innerHTML = summaryHTML;

            // Build suggestions HTML
            const suggestionsHTML = sections.improvements ? `
                <div style="padding: 16px; background: rgba(99, 102, 241, 0.1); border-left: 3px solid #6366f1; border-radius: 6px;">
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.improvements)}</div>
                </div>
            ` : '<div style="color: var(--text-secondary);">No specific improvements suggested.</div>';

            document.getElementById('ai-review-suggestions').innerHTML = suggestionsHTML;

            console.log('âœ… AI Review complete');
        }

        // Extract section from AI response
        function extractSection(text, sectionName) {
            const regex = new RegExp(`\\*\\*${sectionName}:\\*\\*\\s*([\\s\\S]*?)(?=\\n\\*\\*[A-Z]+:|$)`, 'i');
            const match = text.match(regex);
            return match ? match[1].trim() : '';
        }

        // Format markdown to HTML (simple version)
        function formatMarkdown(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
                .replace(/^- (.+)$/gm, '<li>$1</li>') // List items
                .replace(/(<li>.*<\/li>)/s, '<ul style="margin: 8px 0; padding-left: 20px;">$1</ul>') // Wrap in ul
                .replace(/\n\n/g, '<br><br>'); // Paragraphs
        }

        // =============================================================================
        // ANALYSIS MODE - TEXT TO TREE CONVERSION
        // =============================================================================

        let analysisText = '';
        let analysisFileName = '';

        // Open Analysis Modal
        // Track analysis mode (fresh or append)
        let analysisAppendMode = false;

        document.getElementById('analyze-text-btn').addEventListener('click', () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                window.pendingAnalysisMode = true;
                return;
            }

            // If tree has content, ask user if they want to append or start fresh
            if (hasExistingContent()) {
                showAnalysisModeChoice();
            } else {
                openAnalysisModal(false); // false = start fresh
            }
        });

        // Header Import Text button - same as sidebar analyze-text-btn
        document.getElementById('import-text-header-btn')?.addEventListener('click', () => {
            document.getElementById('analyze-text-btn').click();
        });

        // Empty state CTA buttons
        document.getElementById('empty-state-import-btn')?.addEventListener('click', () => {
            document.getElementById('analyze-text-btn').click();
        });

        document.getElementById('empty-state-chat-btn')?.addEventListener('click', () => {
            document.getElementById('wizard-btn').click();
        });

        // BUILD 538: Close button for empty state CTA
        document.getElementById('empty-state-close-btn')?.addEventListener('click', () => {
            const emptyStateCta = document.getElementById('empty-state-cta');
            if (emptyStateCta) {
                emptyStateCta.style.display = 'none';
                window.emptyStateManuallyDismissed = true; // Remember user dismissed it
            }
        });

        // BUILD 538: Allow Escape key to close empty state CTA
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const emptyStateCta = document.getElementById('empty-state-cta');
                if (emptyStateCta && emptyStateCta.style.display !== 'none') {
                    emptyStateCta.style.display = 'none';
                    window.emptyStateManuallyDismissed = true;
                }
            }
        });

        // Show modal to choose analysis mode
        function showAnalysisModeChoice() {
            const pattern = PATTERNS[currentPattern];
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ” Analyze Text Mode';

            // Count existing items
            const itemCount = capexTree.children?.reduce((sum, phase) =>
                sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 24px;">
                        Your tree already has <strong style="color: var(--treeplex-primary);">${itemCount} ${pattern.levels.item.toLowerCase()}(s)</strong>.
                        How would you like to proceed?
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="analysis-mode-append" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">â•</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Append to Existing
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Analyze the text and add the results to your current tree. Great for combining multiple documents.
                            </div>
                        </div>

                        <div id="analysis-mode-fresh" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">ğŸ”„</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Replace Tree
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Clear the current tree and replace it with the analysis results. Starts from scratch.
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                        ğŸ’¡ <strong>Tip:</strong> Append mode lets you analyze multiple documents and combine them into one comprehensive tree.
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Add click handlers
            document.getElementById('analysis-mode-append').onclick = () => {
                modal.style.display = 'none';
                openAnalysisModal(true); // true = append mode
            };

            document.getElementById('analysis-mode-fresh').onclick = () => {
                modal.style.display = 'none';
                openAnalysisModal(false); // false = start fresh
            };
        }

        // Open the analysis modal
        function openAnalysisModal(appendMode) {
            analysisAppendMode = appendMode;

            const modal = document.getElementById('analysis-modal');
            modal.style.display = 'flex';

            // Reset form
            document.getElementById('analysis-text-input').value = '';
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            document.getElementById('char-count').textContent = '0 characters';
            document.getElementById('analysis-warning').style.display = 'none';
            analysisText = '';
            analysisFileName = '';

            // BUILD 519: Reset source type and clear PDF/URL state
            currentSourceType = 'text';
            extractedPdfText = '';
            fetchedUrlText = '';
            pdfSourceInfo = null;
            urlSourceInfo = null;
            switchSourceType('text'); // Reset UI to text tab

            // Reset PDF section
            const pdfInput = document.getElementById('pdf-file-input');
            if (pdfInput) pdfInput.value = '';
            document.getElementById('pdf-name-display')?.style && (document.getElementById('pdf-name-display').style.display = 'none');
            document.getElementById('pdf-text-preview')?.style && (document.getElementById('pdf-text-preview').style.display = 'none');
            document.getElementById('pdf-extraction-progress')?.style && (document.getElementById('pdf-extraction-progress').style.display = 'none');

            // Reset URL section
            const urlInput = document.getElementById('url-input');
            if (urlInput) urlInput.value = '';
            document.getElementById('url-text-preview')?.style && (document.getElementById('url-text-preview').style.display = 'none');
            document.getElementById('url-fetch-progress')?.style && (document.getElementById('url-fetch-progress').style.display = 'none');

            // Update the AI mode display to show current global mode
            updateAnalysisModeDisplay();
        }

        // Update the AI mode display in Analyze Text modal
        function updateAnalysisModeDisplay() {
            const mode = getGlobalAIMode();
            const label = document.getElementById('analyze-mode-label');
            const description = document.getElementById('analyze-mode-description');

            if (mode === 'off') {
                label.textContent = 'âŒ Off';
                description.textContent = 'AI features are disabled. Enable AI mode in the header to use this feature.';
                description.style.color = '#EF4444';
            } else if (mode === 'quick') {
                label.textContent = 'âš¡ Quick';
                description.textContent = 'Fast pattern detection + basic structure. Recommended for most uses. Uses server API key (rate limited).';
                description.style.color = 'var(--text-secondary)';
            } else if (mode === 'deep') {
                label.textContent = 'ğŸ”¬ Deep';
                description.textContent = 'Comprehensive parsing with extended thinking (8192 tokens). Handles 3x more text. Requires your API key. No timeouts.';
                description.style.color = 'var(--text-secondary)';
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 511: Voice Input for Import Modal
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let importVoiceState = {
            recognition: null,
            isRecording: false,
            finalText: ''
        };

        function toggleImportVoiceCapture() {
            if (importVoiceState.isRecording) {
                stopImportVoiceCapture();
            } else {
                startImportVoiceCapture();
            }
        }

        function startImportVoiceCapture() {
            // Check browser support
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showToast('Voice input not supported in this browser', 'error');
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            importVoiceState.recognition = new SpeechRecognition();
            importVoiceState.recognition.continuous = true;
            importVoiceState.recognition.interimResults = true;
            importVoiceState.recognition.lang = 'en-US';
            importVoiceState.finalText = '';

            const textarea = document.getElementById('analysis-text-input');
            const btn = document.getElementById('import-voice-btn');

            // Get existing text to preserve
            const existingText = textarea.value;

            importVoiceState.recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (finalTranscript) {
                    importVoiceState.finalText += finalTranscript + ' ';
                }

                // Show in textarea (append to existing)
                const newText = existingText + (existingText ? ' ' : '') + importVoiceState.finalText + interimTranscript;
                textarea.value = newText;
                textarea.style.borderColor = '#10b981';

                // Update character count
                document.getElementById('char-count').textContent = newText.length + ' characters';
            };

            importVoiceState.recognition.onerror = (event) => {
                console.error('Import voice error:', event.error);
                stopImportVoiceCapture();

                if (event.error === 'not-allowed') {
                    showToast('Microphone access denied. Please allow mic in browser settings.', 'error');
                } else if (event.error === 'no-speech') {
                    showToast('No speech detected. Please speak louder.', 'warning');
                } else if (event.error !== 'aborted') {
                    showToast('Voice error: ' + event.error, 'error');
                }
            };

            importVoiceState.recognition.onend = () => {
                if (importVoiceState.isRecording) {
                    // User didn't explicitly stop, might have timed out
                    stopImportVoiceCapture();
                }
            };

            // Start recording
            try {
                importVoiceState.recognition.start();
                importVoiceState.isRecording = true;

                // Update button appearance
                btn.innerHTML = 'ğŸ”´ Stop';
                btn.style.background = 'rgba(239, 68, 68, 0.4)';
                btn.style.borderColor = '#ef4444';
                btn.style.animation = 'pulse 1s infinite';

                showToast('ğŸ¤ Listening... Speak now', 'info');
            } catch (e) {
                console.error('Failed to start voice:', e);
                showToast('Failed to start voice capture', 'error');
            }
        }

        function stopImportVoiceCapture() {
            if (importVoiceState.recognition) {
                try {
                    importVoiceState.recognition.stop();
                } catch (e) {}
            }

            importVoiceState.isRecording = false;

            const btn = document.getElementById('import-voice-btn');
            if (btn) {
                btn.innerHTML = 'ğŸ¤ Voice';
                btn.style.background = 'rgba(239, 68, 68, 0.15)';
                btn.style.borderColor = 'rgba(239, 68, 68, 0.4)';
                btn.style.animation = 'none';
            }

            const textarea = document.getElementById('analysis-text-input');
            if (textarea) {
                textarea.style.borderColor = '';
            }

            if (importVoiceState.finalText.trim()) {
                showToast('Voice captured: ' + importVoiceState.finalText.trim().substring(0, 50) + '...', 'success');
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 519: RAG Phase 1 - Source Type Switching
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let currentSourceType = 'text'; // text | pdf | url
        let extractedPdfText = '';
        let fetchedUrlText = '';
        let pdfSourceInfo = null;
        let urlSourceInfo = null;

        // Initialize source type buttons
        document.querySelectorAll('.source-type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const sourceType = btn.dataset.source;
                switchSourceType(sourceType);
            });
        });

        function switchSourceType(sourceType) {
            currentSourceType = sourceType;

            // Update button states
            document.querySelectorAll('.source-type-btn').forEach(btn => {
                if (btn.dataset.source === sourceType) {
                    btn.style.border = '2px solid var(--treeplex-primary)';
                    btn.style.background = 'rgba(99, 102, 241, 0.15)';
                    btn.style.color = 'var(--text-primary)';
                    btn.classList.add('active');
                } else {
                    btn.style.border = '2px solid var(--border)';
                    btn.style.background = 'transparent';
                    btn.style.color = 'var(--text-secondary)';
                    btn.classList.remove('active');
                }
            });

            // Show/hide sections
            document.getElementById('source-text-section').style.display = sourceType === 'text' ? 'block' : 'none';
            document.getElementById('source-pdf-section').style.display = sourceType === 'pdf' ? 'block' : 'none';
            document.getElementById('source-url-section').style.display = sourceType === 'url' ? 'block' : 'none';
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 519: RAG Phase 1 - PDF Extraction with pdf.js
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Load pdf.js from CDN if not already loaded
        let pdfJsLoaded = false;
        async function loadPdfJs() {
            if (pdfJsLoaded || window.pdfjsLib) {
                pdfJsLoaded = true;
                return;
            }

            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
                script.onload = () => {
                    window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    pdfJsLoaded = true;
                    resolve();
                };
                script.onerror = () => reject(new Error('Failed to load pdf.js'));
                document.head.appendChild(script);
            });
        }

        // PDF drop zone handlers
        const pdfDropZone = document.getElementById('pdf-drop-zone');
        const pdfFileInput = document.getElementById('pdf-file-input');

        if (pdfDropZone && pdfFileInput) {
            pdfDropZone.addEventListener('click', () => pdfFileInput.click());

            pdfFileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) await handlePdfFile(file);
            });

            pdfDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                pdfDropZone.style.borderColor = 'var(--treeplex-primary)';
                pdfDropZone.style.background = 'rgba(99, 102, 241, 0.05)';
            });

            pdfDropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                pdfDropZone.style.borderColor = 'var(--border)';
                pdfDropZone.style.background = 'var(--bg-secondary)';
            });

            pdfDropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                pdfDropZone.style.borderColor = 'var(--border)';
                pdfDropZone.style.background = 'var(--bg-secondary)';
                const file = e.dataTransfer.files[0];
                if (file && file.type === 'application/pdf') {
                    await handlePdfFile(file);
                } else {
                    showToast('Please drop a PDF file', 'error');
                }
            });

            // Clear PDF button
            document.getElementById('clear-pdf-btn')?.addEventListener('click', () => {
                pdfFileInput.value = '';
                extractedPdfText = '';
                pdfSourceInfo = null;
                document.getElementById('pdf-name-display').style.display = 'none';
                document.getElementById('pdf-text-preview').style.display = 'none';
                document.getElementById('pdf-extraction-progress').style.display = 'none';
            });
        }

        async function handlePdfFile(file) {
            if (file.size > 10 * 1024 * 1024) {
                showToast('PDF too large (max 10MB)', 'error');
                return;
            }

            // Show file name
            document.getElementById('selected-pdf-name').textContent = file.name;
            document.getElementById('pdf-name-display').style.display = 'block';

            // Show progress
            const progress = document.getElementById('pdf-extraction-progress');
            const progressBar = document.getElementById('pdf-extraction-bar');
            const statusText = document.getElementById('pdf-extraction-status');
            progress.style.display = 'block';
            progressBar.style.width = '0%';
            statusText.textContent = 'Loading pdf.js...';

            try {
                // Load pdf.js if needed
                await loadPdfJs();
                statusText.textContent = 'Reading PDF...';
                progressBar.style.width = '20%';

                // Read file as ArrayBuffer
                const arrayBuffer = await file.arrayBuffer();
                statusText.textContent = 'Parsing PDF...';
                progressBar.style.width = '40%';

                // Load PDF document
                const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const numPages = pdf.numPages;
                statusText.textContent = `Extracting text from ${numPages} pages...`;

                let fullText = '';
                for (let i = 1; i <= numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += `\n\n--- Page ${i} ---\n\n${pageText}`;
                    progressBar.style.width = `${40 + (i / numPages) * 50}%`;
                }

                // Store extracted text
                extractedPdfText = fullText.trim();
                pdfSourceInfo = {
                    fileName: file.name,
                    fileSize: file.size,
                    pageCount: numPages,
                    extractedAt: new Date().toISOString()
                };

                // Show preview
                progress.style.display = 'none';
                const preview = document.getElementById('pdf-text-preview');
                const textArea = document.getElementById('pdf-extracted-text');
                textArea.value = extractedPdfText.substring(0, 5000) + (extractedPdfText.length > 5000 ? '\n\n[... truncated preview ...]' : '');
                document.getElementById('pdf-char-count').textContent = `${extractedPdfText.length.toLocaleString()} characters extracted from ${numPages} pages`;
                preview.style.display = 'block';

                showToast(`PDF extracted: ${extractedPdfText.length.toLocaleString()} characters`, 'success');

            } catch (err) {
                console.error('PDF extraction error:', err);
                progress.style.display = 'none';
                showToast('Failed to extract PDF text: ' + err.message, 'error');
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 519: RAG Phase 1 - URL Content Fetching
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        document.getElementById('fetch-url-btn')?.addEventListener('click', async () => {
            const urlInput = document.getElementById('url-input');
            const url = urlInput.value.trim();

            if (!url) {
                showToast('Please enter a URL', 'error');
                return;
            }

            // Validate URL
            try {
                new URL(url);
            } catch {
                showToast('Invalid URL format', 'error');
                return;
            }

            await fetchUrlContent(url);
        });

        // Allow Enter key to fetch
        document.getElementById('url-input')?.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                document.getElementById('fetch-url-btn')?.click();
            }
        });

        async function fetchUrlContent(url) {
            const progress = document.getElementById('url-fetch-progress');
            const statusText = document.getElementById('url-fetch-status');
            progress.style.display = 'block';
            statusText.textContent = 'Fetching page content...';

            try {
                // Use a CORS proxy or the Netlify function
                // For now, we'll try direct fetch first, then fallback to a proxy
                let response;
                let content = '';

                try {
                    // Try fetching through our claude-proxy which can handle CORS
                    const proxyUrl = '/.netlify/functions/url-proxy?url=' + encodeURIComponent(url);
                    response = await fetch(proxyUrl, {
                        method: 'GET',
                        headers: { 'Accept': 'text/html,text/plain' }
                    });

                    if (response.ok) {
                        content = await response.text();
                    } else {
                        throw new Error('Proxy fetch failed');
                    }
                } catch (proxyErr) {
                    // Fallback: try direct fetch (may fail due to CORS)
                    statusText.textContent = 'Trying direct fetch...';
                    try {
                        response = await fetch(url, { mode: 'cors' });
                        content = await response.text();
                    } catch (directErr) {
                        throw new Error('Cannot fetch URL - CORS blocked. Try copying the page content manually.');
                    }
                }

                // Extract text content from HTML
                statusText.textContent = 'Extracting text...';
                const extractedText = extractTextFromHtml(content, url);

                // Store fetched text
                fetchedUrlText = extractedText;
                urlSourceInfo = {
                    url: url,
                    fetchedAt: new Date().toISOString(),
                    contentLength: content.length
                };

                // Show preview
                progress.style.display = 'none';
                const preview = document.getElementById('url-text-preview');
                const textArea = document.getElementById('url-fetched-text');
                textArea.value = fetchedUrlText.substring(0, 5000) + (fetchedUrlText.length > 5000 ? '\n\n[... truncated preview ...]' : '');
                document.getElementById('url-char-count').textContent = `${fetchedUrlText.length.toLocaleString()} characters fetched`;
                document.getElementById('url-source-info').textContent = new URL(url).hostname;
                preview.style.display = 'block';

                showToast(`Page fetched: ${fetchedUrlText.length.toLocaleString()} characters`, 'success');

            } catch (err) {
                console.error('URL fetch error:', err);
                progress.style.display = 'none';
                showToast(err.message || 'Failed to fetch URL', 'error');
            }
        }

        function extractTextFromHtml(html, url) {
            // Create a DOM parser
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            // Remove scripts, styles, nav, footer, etc.
            const removeSelectors = ['script', 'style', 'nav', 'footer', 'header', 'aside', 'noscript', 'iframe', 'svg'];
            removeSelectors.forEach(sel => {
                doc.querySelectorAll(sel).forEach(el => el.remove());
            });

            // Try to find main content
            const mainContent = doc.querySelector('main, article, [role="main"], .content, .post, .article, #content, #main');
            const contentEl = mainContent || doc.body;

            // Get text content
            let text = contentEl?.textContent || '';

            // Clean up whitespace
            text = text
                .replace(/\s+/g, ' ')
                .replace(/\n\s*\n/g, '\n\n')
                .trim();

            // Add source header
            const title = doc.querySelector('title')?.textContent || url;
            return `Source: ${title}\nURL: ${url}\n\n${text}`;
        }

        // Close Analysis Modal
        document.getElementById('analysis-cancel').addEventListener('click', () => {
            stopImportVoiceCapture(); // Stop voice if recording
            document.getElementById('analysis-modal').style.display = 'none';
        });

        // File Drop Zone - Click to browse
        const fileDropZone = document.getElementById('file-drop-zone');
        const fileInput = document.getElementById('analysis-file-input');

        fileDropZone.addEventListener('click', () => {
            fileInput.click();
        });

        // File selected via browse
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Drag and Drop handlers
        fileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--treeplex-primary)';
            fileDropZone.style.background = 'rgba(99, 102, 241, 0.05)';
        });

        fileDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';
        });

        fileDropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';

            const file = e.dataTransfer.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Handle file upload
        async function handleAnalysisFile(file) {
            // Check file type
            const validTypes = ['.txt', '.md'];
            const fileName = file.name.toLowerCase();
            const isValid = validTypes.some(type => fileName.endsWith(type));

            if (!isValid) {
                alert('Please upload a .txt or .md file only.');
                return;
            }

            // Show file name
            document.getElementById('selected-file-name').textContent = file.name;
            document.getElementById('file-name-display').style.display = 'block';
            analysisFileName = file.name;

            // Read file content
            const reader = new FileReader();
            reader.onload = (e) => {
                analysisText = e.target.result;

                // Clear text area since we're using file
                document.getElementById('analysis-text-input').value = '';

                // Update character count
                updateCharCount(analysisText.length);

                // Check file size and show warning if needed
                checkFileSize(analysisText.length);
            };
            reader.readAsText(file);
        }

        // Clear file button
        document.getElementById('clear-file-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            analysisText = '';
            analysisFileName = '';
            updateCharCount(0);
            document.getElementById('analysis-warning').style.display = 'none';
        });

        // Text area character count
        const textInput = document.getElementById('analysis-text-input');
        textInput.addEventListener('input', (e) => {
            analysisText = e.target.value;
            updateCharCount(analysisText.length);
            checkFileSize(analysisText.length);

            // Clear file if typing in text area
            if (analysisText.length > 0 && analysisFileName) {
                document.getElementById('analysis-file-input').value = '';
                document.getElementById('file-name-display').style.display = 'none';
                analysisFileName = '';
            }
        });

        function updateCharCount(count) {
            const charCountEl = document.getElementById('char-count');
            const words = count > 0 ? analysisText.trim().split(/\s+/).length : 0;
            charCountEl.textContent = `${count.toLocaleString()} characters (~${words} words)`;

            if (count > 50000) {
                charCountEl.style.color = '#ff9f43';
            } else {
                charCountEl.style.color = 'var(--text-secondary)';
            }
        }

        function checkFileSize(charCount) {
            const warningEl = document.getElementById('analysis-warning');
            const warningText = document.getElementById('analysis-warning-text');

            // Rough token estimate: 1 token â‰ˆ 4 characters
            const estimatedTokens = Math.ceil(charCount / 4);
            const estimatedWords = Math.ceil(charCount / 5);

            if (charCount > 100000) { // Will be truncated
                warningEl.style.display = 'block';
                warningText.textContent = `âš ï¸ Text is ${charCount.toLocaleString()} characters (~${estimatedWords.toLocaleString()} words). Will be automatically truncated to 100,000 characters (~25,000 words) to prevent timeouts. Consider pasting a shorter excerpt for best results.`;
            } else if (charCount > 75000) { // Large but ok
                warningEl.style.display = 'block';
                warningText.textContent = `Very large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis may take 15-25 seconds. Quick Mode strongly recommended.`;
            } else if (charCount > 50000) { // Large
                warningEl.style.display = 'block';
                warningText.textContent = `Large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Deep Mode will provide richer analysis but may take 20-30 seconds.`;
            } else if (charCount > 5000) {
                warningEl.style.display = 'block';
                warningText.textContent = `Medium text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis should take 15-30 seconds.`;
            } else {
                warningEl.style.display = 'none';
            }
        }

        // =============================================================================
        // AI PATTERN DETECTION & TEXT-TO-TREE CONVERSION
        // =============================================================================

        // Pattern detection function
        async function detectPattern(text) {
            const prompt = `Analyze the following text and determine the 3 most appropriate TreeListy patterns for organizing it.

AVAILABLE PATTERNS:
1. Generic Project - Universal structure for any project (Project â†’ Phase â†’ Item â†’ Task)
2. Sales Pipeline - Deal tracking across quarters (Pipeline â†’ Quarter â†’ Deal â†’ Action)
3. Academic Writing - Thesis/research paper structure (Thesis â†’ Chapter â†’ Section â†’ Point)
4. Product Roadmap - Feature development timeline (Product â†’ Quarter â†’ Feature â†’ Story)
5. Book Writing - Narrative structure (Book â†’ Part â†’ Chapter â†’ Scene)
6. Event Planning - Event organization and logistics (Event â†’ Stage â†’ Activity â†’ Task)
7. Fitness Program - Workout programs and exercises (Program â†’ Phase â†’ Workout â†’ Exercise)
8. Strategic Plan - Business initiatives and metrics (Strategy â†’ Pillar â†’ Initiative â†’ Action)
9. Course Design - Educational curriculum structure (Course â†’ Unit â†’ Lesson â†’ Exercise)
10. Film Production - Film/video production workflow (Film â†’ Phase â†’ Scene â†’ Shot)
11. Veo3 (Google) - Google Veo 3 AI video generation (Project â†’ Sequence â†’ Scene â†’ Shot/Frame)
12. Sora2 (OpenAI) - OpenAI Sora 2 AI video generation (Project â†’ Sequence â†’ Beat â†’ Shot/Remix)
13. Philosophy - Philosophical arguments and treatises (Treatise â†’ Book â†’ Argument â†’ Premise)
14. Prompt Engineering - AI prompts and testing (Library â†’ Category â†’ Prompt â†’ Test Case)
15. Family Tree - Genealogical documentation (Family â†’ Generation â†’ Person â†’ Event)
16. Dialogue & Rhetoric - Analyze debates, conversations, and arguments (Conversation â†’ Speaker â†’ Statement â†’ Point)
17. CAPEX / Angel Pitch - Investor-ready capital expenditure for startups (Project â†’ Funding Phase â†’ Investment â†’ Deliverable)
18. File System - File and folder organization (Root â†’ Directory â†’ Subdirectory â†’ File)

TEXT TO ANALYZE:
${text.substring(0, 5000)}${text.length > 5000 ? '\n\n[... truncated for analysis ...]' : ''}

DETECTION HINTS:
- If text contains prompt-related terms like "system prompt", "user prompt", "few-shot examples", "chain-of-thought", "temperature", "max tokens" â†’ Prompt Engineering
- If text looks like AI instructions or discusses prompt design â†’ Prompt Engineering
- If text mentions AI models (Claude, GPT, Anthropic, OpenAI) in context of prompting â†’ Prompt Engineering
- If text contains debate/dialogue terms like "speaker", "argument", "rhetoric", "fallacy", "premise", "counterargument", "rebuttal", "debate", "conversation" â†’ Dialogue & Rhetoric
- If text is a transcript of a conversation, political debate, or online discussion â†’ Dialogue & Rhetoric
- If text analyzes persuasion, argumentation, or rhetorical techniques â†’ Dialogue & Rhetoric
- If text contains startup/investment terms like "seed round", "series A/B", "CAPEX", "funding", "investors", "valuation", "angel", "VC", "runway", "burn rate", "ROI", "IRR" â†’ CAPEX / Angel Pitch
- If text describes capital expenditure, startup fundraising, or investor pitch materials â†’ CAPEX / Angel Pitch
- If text is about file/folder organization, directory structure, or filesystem hierarchy â†’ File System

Respond with ONLY a valid JSON object in this exact format:
{
  "recommendations": [
    {
      "pattern": "pattern-key",
      "patternName": "Pattern Display Name",
      "confidence": 9,
      "reasoning": "Brief explanation of why this pattern fits"
    }
  ]
}

Provide exactly 3 recommendations, ranked by confidence (1-10). Use these pattern keys: generic, sales, thesis, roadmap, book, event, fitness, strategy, course, film, philosophy, prompting, familytree, dialogue, capex, filesystem`;

            const response = await callClaudeAPI(prompt);

            try {
                // Extract JSON from response
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    return result.recommendations;
                }
            } catch (e) {
                console.error('Failed to parse pattern detection response:', e);
            }

            // Fallback to generic
            return [{
                pattern: 'generic',
                patternName: 'Generic Project',
                confidence: 5,
                reasoning: 'Default fallback pattern'
            }];
        }

        // Helper function to fix common JSON issues
        function repairJSON(jsonText) {
            // SIMPLE APPROACH: Replace all problematic characters with spaces or escaped versions
            // This is more reliable than complex regex matching

            // Replace literal newlines, carriage returns, and tabs with spaces
            // These shouldn't be in JSON strings - Claude should use \n instead
            jsonText = jsonText.replace(/\r\n/g, ' ');
            jsonText = jsonText.replace(/\r/g, ' ');
            jsonText = jsonText.replace(/\n/g, ' ');
            jsonText = jsonText.replace(/\t/g, ' ');

            // Remove other control characters (ASCII 0-31 except space)
            jsonText = jsonText.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');

            // Remove trailing commas before closing brackets/braces (run multiple times to catch nested cases)
            let previousText;
            do {
                previousText = jsonText;
                jsonText = jsonText.replace(/,(\s*[}\]])/g, '$1');
            } while (jsonText !== previousText);

            // Remove comments (// and /* */)
            jsonText = jsonText.replace(/\/\/.*$/gm, '');
            jsonText = jsonText.replace(/\/\*[\s\S]*?\*\//g, '');

            return jsonText;
        }

        // PROMPT IMPROVEMENT: Special handler for Prompt Engineering pattern
        // Takes a basic prompt and generates comprehensive improved version with best practices
        async function improvePromptWithAI(basicPrompt, mode = 'quick') {
            console.log(`ğŸ§  Improving prompt using ${mode} mode...`);

            // BUILD 173: "Super Hybrid" meta-prompt combining best traits from A/B winners
            // - Iterative Refinement (80.2%): Self-critique loop, "junior engineer test"
            // - Hybrid V2 (78.4%): Expert panel synthesis, agent contracts
            // - Direct+Concrete (74.2%): Maximum specificity, concrete personas
            const systemPrompt = `You are a world-class prompt engineer. Generate, critique, and refine a production-ready prompt.

## Phase 1: Draft Generation
Create an initial prompt. Apply expert perspectives:
- Anthropic: XML tags, explicit constraints, safety considerations
- OpenAI: JSON mode, function calling patterns, system message optimization
- Production: Token efficiency, error handling, latency considerations

## Phase 2: Self-Critique (Internal - Don't output this)
Score your draft against these criteria:
â–¡ Would a junior engineer understand exactly what to do?
â–¡ Are there ANY ambiguous instructions?
â–¡ Would this produce correct output on the FIRST try?
â–¡ Is the persona SPECIFIC (not "expert" but "senior engineer at Stripe with 8 years in payment systems")?
â–¡ Are examples CONCRETE with actual inputâ†’output pairs?
â–¡ For multi-agent: Are contracts between agents crystal clear with exact JSON schemas?

## Phase 3: Refined Output
Apply your critique. Fix every issue. Output the IMPROVED prompt.

## Output Requirements
Your generated prompt MUST include:
- <system> with SPECIFIC persona (domain, years experience, company context)
- <task> with precise instructions and success criteria
- <format> with exact output structure (JSON schema if structured)
- <examples> with 2+ CONCRETE inputâ†’output examples
- <constraints> with boundaries and error handling
- For workflows: <agent_contracts> with INPUT/OUTPUT contracts per agent

CRITICAL: Return ONLY valid JSON. No explanations. No meta-commentary.`;

            const userPrompt = `Transform this input into a production-ready prompt:

INPUT: "${basicPrompt}"

You are a PROMPT ARCHITECT. Your output is a prompt that CONFIGURES another AI.
- If input is a topic â†’ CREATE a prompt for an AI to handle that topic
- If input is a draft prompt â†’ IMPROVE it to production quality

CRITICAL: Your output must INSTRUCT the AI, not answer a question.
BAD: "Help me with skin care"
GOOD: "You are a dermatologist with 15 years experience at Mayo Clinic. When providing skin care: 1) Ask about skin type 2) Provide routine with ingredients 3) Return as JSON. Help me create a routine."

Return ONLY this JSON structure:
{
  "projectName": "Descriptive name",
  "description": "1-sentence description",
  "phases": [{
    "name": "Production Prompt",
    "subtitle": "Ready to use",
    "items": [{
      "name": "Refined: [Use Case Name]",
      "description": "Production-ready prompt",
      "itemType": "task-instruction",
      "systemPrompt": "<system>\\nYou are a [SPECIFIC ROLE: e.g., senior ML engineer at Google with 10 years in NLP].\\n[Context]\\n[Constraints]\\n</system>",
      "userPromptTemplate": "<task>\\n[Precise instructions with success criteria]\\n</task>\\n<format>\\n[Exact output structure/JSON schema]\\n</format>\\n<constraints>\\n[What NOT to do, error handling]\\n</constraints>",
      "fewShotExamples": "<examples>\\n<example>\\nInput: [concrete input 1]\\nOutput: [concrete output 1]\\n</example>\\n<example>\\nInput: [concrete input 2]\\nOutput: [concrete output 2]\\n</example>\\n</examples>",
      "chainOfThought": "Think step by step: 1) [step], 2) [step], 3) [step]",
      "outputFormat": "Return JSON: {\\"field1\\": \\"type\\", \\"field2\\": \\"type\\"}",
      "structuralTags": "<thinking>\\nReasoning\\n</thinking>\\n<answer>\\nFinal response\\n</answer>",
      "assistantPrefill": "Here is my analysis:",
      "modelTarget": "Claude Sonnet 4",
      "temperature": 0.7,
      "maxTokens": 2000
    }]
  }]
}

RULES:
- systemPrompt: SPECIFIC persona (role + years + company context), not generic "expert"
- userPromptTemplate: Must INSTRUCT the AI, not ask a question
- fewShotExamples: CONCRETE inputâ†’output pairs, not placeholders
- NO {{variables}} - make it work immediately when pasted
- NO trailing commas in JSON
- Escape quotes inside strings`;

            // Deep mode uses extended thinking (budget_tokens = 5000)
            // So maxTokens must be > 5000. Using 8000 to give 3000 tokens for actual response.
            const maxTokens = mode === 'deep' ? 8000 : 2048;
            const useThinking = mode === 'deep';

            const response = await callClaudeAPI(userPrompt, systemPrompt, maxTokens, useThinking);

            try {
                // Extract JSON from response
                let jsonText = response.trim();
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                const firstBrace = jsonText.indexOf('{');
                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ğŸ§  Skipping text before JSON:', jsonText.substring(0, firstBrace));
                    jsonText = jsonText.substring(firstBrace);
                }

                // Find matching closing brace
                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = 0; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Could not find matching closing brace in JSON');
                }

                jsonText = jsonText.substring(0, endPos + 1);

                const parsed = JSON.parse(jsonText);
                console.log('âœ… Prompt improved successfully:', parsed.projectName);
                return parsed;

            } catch (e) {
                console.error('âŒ JSON parsing error:', e);
                console.error('Response:', response);
                throw new Error(`Failed to improve prompt. AI response was not valid JSON: ${e.message}`);
            }
        }

        // Quick Mode: Basic structure conversion with semantic chunking
        async function convertTextToTreeQuick(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            // SPECIAL CASE: Prompt Engineering pattern - improve the prompt instead of extracting
            if (pattern === 'prompting') {
                return await improvePromptWithAI(text, 'quick');
            }

            // =========================================================================
            // SEMANTIC CHUNKING PREPROCESSING
            // =========================================================================
            console.log('ğŸ§  Starting semantic chunking preprocessing...');
            const chunker = new SemanticChunker();
            let chunks;

            // Show chunking status in UI
            const modalBody = document.getElementById('modal-body');
            if (modalBody) {
                modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">ğŸ§  Analyzing text structure...</p>';
            }

            // Tier 2: Scientific approach (if embedding provider available)
            if (EmbeddingManager.hasProvider()) {
                console.log('âœ… Embedding provider detected - using scientific semantic chunking');
                try {
                    chunks = await chunker.chunkByEmbedding(text);
                } catch (error) {
                    console.warn('âš ï¸ Semantic chunking failed, falling back to structural split:', error);
                    chunks = chunker.structuralSplit(text);
                }
            } else {
                // Tier 1: Structural fallback
                console.log('ğŸ“ No embedding provider - using structural split');
                chunks = chunker.structuralSplit(text);
            }

            console.log(`âœ… Text split into ${chunks.length} semantic chunks`);

            // Show chunk visualization
            if (modalBody && chunks.length > 1) {
                const chunkLengths = chunks.map(c => c.text.length);
                const maxLength = Math.max(...chunkLengths);
                const bars = chunks.map((chunk, i) => {
                    const width = (chunk.text.length / maxLength) * 100;
                    return `<div style="background: linear-gradient(90deg, rgba(99, 102, 241, 0.6), rgba(139, 92, 246, 0.6)); height: 8px; width: ${width}%; border-radius: 4px; margin: 2px 0;" title="Chunk ${i + 1}: ${chunk.text.length} chars"></div>`;
                }).join('');

                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div class="spinner"></div>
                            <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600;">
                                ğŸ§  Detected ${chunks.length} Semantic Sections
                            </p>
                            <p style="color: var(--text-secondary); font-size: 13px; margin-top: 4px;">
                                Processing each section with ${patternConfig.name} pattern...
                            </p>
                        </div>
                        <div style="padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3);">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Chunk size distribution:</div>
                            ${bars}
                        </div>
                    </div>
                `;
            }

            // Generate quick field hints (top 5 most important fields)
            let quickFieldHints = '';
            const importantFields = [];

            Object.keys(fields).forEach(fieldKey => {
                const fieldConfig = fields[fieldKey];
                // Skip non-field properties
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }
                if (fieldConfig.label) {
                    let hint = `- ${fieldKey}: ${fieldConfig.label}`;
                    if (fieldConfig.type === 'number') {
                        hint += ` (number)`;
                    } else if (fieldConfig.type === 'date') {
                        hint += ` (YYYY-MM-DD)`;
                    } else if (fieldConfig.type === 'select' && fieldConfig.options) {
                        hint += ` (${fieldConfig.options.slice(0, 3).join('/')})`;
                    }
                    importantFields.push(hint);
                }
            });

            if (importantFields.length > 0) {
                quickFieldHints = `\n\nKEY FIELDS TO EXTRACT (if mentioned in text):\n${importantFields.slice(0, 6).join('\n')}\n`;
            }

            // Add item types if available
            let itemTypeHints = '';
            if (patternConfig.types && patternConfig.types.length > 0) {
                const typesList = patternConfig.types.slice(0, 8).map(t => t.value).join(', ');
                itemTypeHints = `\n\nITEM TYPES: Use these specific types: ${typesList}\n`;
            }

            // Pattern-specific subtask guidance
            // BUILD 320: Added CAPEX subtask guidance
            function getPatternSubtaskGuidance(pattern) {
                const guidance = {
                    capex: `For ${levels.item}s (line items), add ${levels.subtask}s like: components, delivery milestones, installation steps, verification tasks. Include cost breakdowns if available.`,
                    philosophy: `For ${levels.item}s (Claims), REQUIRED 1-3 ${levels.subtask}s (Supports): premises, objections, supporting evidence, textual references. NEVER skip subItems.`,
                    sales: `For ${levels.item}s (deals), add ${levels.subtask}s like: follow-up actions, next steps, activities to close`,
                    thesis: `For ${levels.item}s (arguments), add ${levels.subtask}s like: supporting evidence, citations, counter-arguments`,
                    roadmap: `For ${levels.item}s (features), add ${levels.subtask}s like: implementation steps, technical tasks, acceptance criteria`,
                    book: `For ${levels.item}s (chapters), add ${levels.subtask}s like: scenes, key moments, character developments`,
                    course: `For ${levels.item}s (modules), add ${levels.subtask}s like: lessons, activities, assessments, practice exercises`,
                    film: `For ${levels.item}s (scenes), add ${levels.subtask}s like: specific shots, camera movements, lighting changes`,
                    prompting: `For ${levels.item}s (prompts), add ${levels.subtask}s like: test cases, variations, edge cases to handle`,
                    generic: `For ${levels.item}s, add ${levels.subtask}s like: steps, components, or sub-elements needed`
                };
                return guidance[pattern] || guidance.generic;
            }

            // Pattern-specific instructions for Quick Mode
            // BUILD 321: Enhanced CAPEX prompts with transcript analysis + research request detection
            let patternSpecialInstructions = '';
            if (pattern === 'capex') {
                // BUILD 321: Detect if text looks like a meeting transcript
                const isTranscript = /\[\d{1,2}:\d{2}\]|transcript|meeting notes|discussed|mentioned|can you research|look into|we should check/i.test(text);

                const transcriptExtras = isTranscript ? `

## MEETING TRANSCRIPT MODE (Detected)
This appears to be a meeting transcript. In addition to extracting CAPEX items:

### EXTRACT CONTACTS
For any person mentioned with a company/role, add to extractedContacts array:
- name: Person's full name
- role: Their title/role if mentioned
- company: Their company/organization
- context: How they relate to the project (vendor contact, consultant, etc.)

### DETECT RESEARCH REQUESTS
Look for phrases like "research this", "look into", "can you check", "we should investigate", "find out about".
Add these to researchRequests array with:
- topic: What needs to be researched
- context: Why it was requested
- priority: high/medium/low based on urgency indicators

### UPDATE SIGNALS
If transcript mentions updates to existing items (new pricing, changed timelines, etc.):
- Include itemUpdates array with: itemName, field, oldValue (if mentioned), newValue
` : '';

                patternSpecialInstructions = `

âš ï¸ CAPEX PATTERN REQUIREMENTS (Financial Rigor):

## COST EXTRACTION (CRITICAL)
1. **EXTRACT ALL DOLLAR AMOUNTS**: Every cost, budget, price mentioned MUST be captured
2. **PRESERVE EXACT VALUES**: "$1.2M" â†’ cost: 1200000, NOT rounded or estimated
3. **TRACK VENDORS**: Any company/supplier names go in alternateSource field
4. **DEPENDENCIES**: Equipment that relies on other items â†’ dependencies array

## HIERARCHY STRUCTURE
- Phase = Project phase (Planning, Procurement, Installation, Testing, etc.)
- Item = Capital expense line item (equipment, infrastructure, service)
- SubItem = Component, delivery milestone, or installation step

## REQUIRED FIELDS PER ITEM
- name: Equipment/expense name (be specific: "Dell PowerEdge R750 Servers" not "servers")
- cost: Numeric value in base currency (no symbols, no commas)
- itemType: equipment/infrastructure/labor/contingency/software/consulting
- leadTime: Delivery/implementation time if mentioned ("6-8 weeks")
- alternateSource: Vendor/supplier name

## ITEM TYPES (Use precisely)
- equipment: Physical hardware, machinery, devices
- infrastructure: Facilities, power, cooling, networking
- labor: Installation, configuration, training services
- software: Licenses, subscriptions, development
- consulting: Professional services, design, project management
- contingency: Risk reserves, buffer allocations
${transcriptExtras}
âš ï¸ KEY: NEVER skip cost values. If a range is given ($100K-$150K), use midpoint.
`;
            } else if (pattern === 'philosophy') {
                patternSpecialInstructions = `

âš ï¸ PHILOSOPHY PATTERN REQUIREMENTS (Academic Standard):

## SCHOLARLY REQUIREMENTS
Your output must include:
1. **NAMED SECONDARY SOURCES**: Cite at least 2-3 specific scholars who have written on this text (e.g., "Vlastos (1991)", "Williams (1978)")
2. **STANDARD OBJECTIONS**: Name specific objections with their associated philosophers (e.g., "Lichtenberg's objection", "Cartesian Circle")
3. **TRADITION PLACEMENT**: Identify the specific philosophical school (Platonic, Rationalist, Empiricist, etc.)

## STRUCTURE
1. Create 3-5 movements (phases) following the text's argumentative structure
2. EVERY claim MUST have 1-3 subItems (supporting premises, evidence, or reasoning)
3. Include IMPLICIT premises (unstated assumptions required for validity)

## ITEM TYPES (Use precisely)
- question: Interrogative moves that drive inquiry forward
- premise: Explicit foundational claims
- implicit-premise: Unstated assumptions required for validity
- definition: Attempts to characterize a concept
- distinction: Conceptual clarification separating ideas
- thought-experiment: Hypothetical scenario testing intuitions
- refutation: Counter-arguments that challenge positions
- objection: Standard criticism from the literature
- conclusion: Claims derived from prior reasoning

## METADATA (Required)
Include in root metadata: tradition, method, keyTerms, interlocutors, secondarySources, standardObjections

âš ï¸ KEY: Name SPECIFIC scholars and objections. Do not use generic placeholders.
`;
            } else if (pattern === 'film') {
                patternSpecialInstructions = `\n\nâš ï¸ AI VIDEO: Create ACTUAL SCENES (not workflows about making videos). Each item = one shot. Include videoPrompt, cameraMovement, visualStyle, duration.\n`;
            }

            // =========================================================================
            // CHUNK PROCESSING LOOP
            // =========================================================================
            const allPhasesCollected = [];
            let projectName = '';
            // BUILD 321: Transcript analysis aggregation
            const allExtractedContacts = [];
            const allResearchRequests = [];
            const allItemUpdates = [];

            for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                const chunk = chunks[chunkIndex];
                console.log(`ğŸ”„ Processing chunk ${chunkIndex + 1}/${chunks.length} (${chunk.text.length} chars)`);

                // BUILD 321: Detect transcript mode for CAPEX
                const isTranscript = pattern === 'capex' && /\[\d{1,2}:\d{2}\]|transcript|meeting notes|discussed|mentioned|can you research|look into|we should check/i.test(text);

                // BUILD 321: Additional JSON fields for transcript mode
                const transcriptJsonFields = isTranscript ? `,
  "extractedContacts": [
    { "name": "Person Name", "role": "Title", "company": "Company", "context": "Vendor contact" }
  ],
  "researchRequests": [
    { "topic": "What to research", "context": "Why it matters", "priority": "high/medium/low" }
  ],
  "itemUpdates": [
    { "itemName": "Existing item", "field": "cost", "newValue": "Updated value" }
  ]` : '';

                // Pattern-aware context for this specific chunk
                // BUILD 353: Prepend Smart Import Context if available
                const smartContext = window.smartImportContext || '';
                const chunkPrompt = `${smartContext}Extract items for the ${patternConfig.name} pattern from this SPECIFIC SECTION of a larger document (Section ${chunkIndex + 1}/${chunks.length}).

PATTERN HIERARCHY:
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}
${itemTypeHints}${quickFieldHints}${patternSpecialInstructions}

SECTION TEXT:
${chunk.text}

INSTRUCTIONS (BE CONCISE TO AVOID TIMEOUT):
1. Identify hierarchical structure in THIS SECTION ONLY
2. Create 1-2 phases (${levels.phase}s) for content in this section
3. For each phase, create 2-4 items (${levels.item}s)
4. Add 2-3 ${levels.subtask}s to items that need them
   â†’ ${getPatternSubtaskGuidance(pattern)}
5. Keep descriptions SHORT (under 100 characters)
6. Extract key fields if mentioned
7. ONLY extract content from this section - don't infer content from other sections

JSON FORMATTING RULES (CRITICAL):
- NO trailing commas
- ONLY plain JSON - no markdown, no explanations
- Start response with { and end with }

Respond with ONLY valid JSON:
{
  "projectName": "Section ${chunkIndex + 1} or inferred name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle",
      "icon": "ğŸ“‹",
      "items": [
        {
          "name": "Item name",
          "description": "Brief description",
          "itemType": "type",
          "subItems": [
            { "name": "${levels.subtask} 1", "description": "Detail" }
          ]
        }
      ]
    }
  ]${transcriptJsonFields}
}`;

                // BUILD 319: Use optimized model selection based on pattern
                // A/B testing showed +13.9% improvement with pattern-specific models
                const response = await callOptimizedImportAPI(chunkPrompt, '', 2000, pattern);

                // Parse JSON response from this chunk
                try {
                    let jsonText = response.trim();

                    // Remove markdown code blocks if present
                    jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    // Find the FIRST complete JSON object using proper brace matching
                    const firstBrace = jsonText.indexOf('{');

                    if (firstBrace === -1) {
                        console.warn(`âš ï¸ Chunk ${chunkIndex + 1}: No JSON found, skipping`);
                        continue;
                    }

                    if (firstBrace > 0) {
                        console.log(`ğŸª„ Chunk ${chunkIndex + 1}: Skipping text before JSON`);
                    }

                    let depth = 0;
                    let endPos = -1;
                    let inString = false;
                    let escapeNext = false;

                    for (let i = firstBrace; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            inString = !inString;
                            continue;
                        }

                        if (!inString) {
                            if (char === '{') depth++;
                            else if (char === '}') {
                                depth--;
                                if (depth === 0) {
                                    endPos = i + 1;
                                    break;
                                }
                            }
                        }
                    }

                    if (endPos === -1) {
                        console.warn(`âš ï¸ Chunk ${chunkIndex + 1}: Incomplete JSON, skipping`);
                        continue;
                    }

                    jsonText = jsonText.substring(firstBrace, endPos);

                    // Parse JSON
                    let parsed;
                    try {
                        parsed = JSON.parse(jsonText);
                    } catch (firstError) {
                        console.warn(`ğŸª„ Chunk ${chunkIndex + 1}: JSON parse failed, attempting sanitization...`, firstError.message);

                        // Sanitize JSON: Fix control characters in string values
                        let sanitized = '';
                        let inString = false;
                        let escapeNext = false;

                        for (let i = 0; i < jsonText.length; i++) {
                            const char = jsonText[i];

                            if (escapeNext) {
                                sanitized += char;
                                escapeNext = false;
                                continue;
                            }

                            if (char === '\\') {
                                sanitized += char;
                                escapeNext = true;
                                continue;
                            }

                            if (char === '"') {
                                sanitized += char;
                                inString = !inString;
                                continue;
                            }

                            // If we're inside a string value, escape control characters
                            if (inString) {
                                if (char === '\n') {
                                    sanitized += '\\n';
                                } else if (char === '\r') {
                                    sanitized += '\\r';
                                } else if (char === '\t') {
                                    sanitized += '\\t';
                                } else if (char.charCodeAt(0) < 32) {
                                    sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                                } else {
                                    sanitized += char;
                                }
                            } else {
                                sanitized += char;
                            }
                        }

                        jsonText = sanitized;
                        console.log(`âœ… Chunk ${chunkIndex + 1}: JSON sanitized successfully`);
                        parsed = JSON.parse(jsonText);
                    }

                    // Aggregate results from this chunk
                    if (!projectName && parsed.projectName) {
                        projectName = parsed.projectName;
                        console.log(`ğŸ“ Project name extracted from chunk ${chunkIndex + 1}: ${projectName}`);
                    }

                    if (parsed.phases && parsed.phases.length > 0) {
                        console.log(`âœ… Chunk ${chunkIndex + 1}: Extracted ${parsed.phases.length} phases`);
                        allPhasesCollected.push(...parsed.phases);
                    }

                    // BUILD 321: Aggregate transcript analysis fields
                    if (parsed.extractedContacts && parsed.extractedContacts.length > 0) {
                        console.log(`ğŸ“‡ Chunk ${chunkIndex + 1}: Found ${parsed.extractedContacts.length} contacts`);
                        allExtractedContacts.push(...parsed.extractedContacts);
                    }
                    if (parsed.researchRequests && parsed.researchRequests.length > 0) {
                        console.log(`ğŸ” Chunk ${chunkIndex + 1}: Found ${parsed.researchRequests.length} research requests`);
                        allResearchRequests.push(...parsed.researchRequests);
                    }
                    if (parsed.itemUpdates && parsed.itemUpdates.length > 0) {
                        console.log(`ğŸ“ Chunk ${chunkIndex + 1}: Found ${parsed.itemUpdates.length} item updates`);
                        allItemUpdates.push(...parsed.itemUpdates);
                    }

                } catch (e) {
                    console.error(`âŒ Chunk ${chunkIndex + 1} failed to parse:`, e);
                    console.error('Response (first 500 chars):', response.substring(0, 500));
                    // Continue to next chunk instead of failing entirely
                }
            }

            // =========================================================================
            // MERGE DUPLICATE PHASES AND RETURN AGGREGATED RESULT
            // =========================================================================
            console.log(`âœ… All chunks processed. Total phases collected: ${allPhasesCollected.length}`);

            // Merge phases with the same name
            const phaseMap = new Map();
            allPhasesCollected.forEach(phase => {
                const phaseName = phase.name;
                if (phaseMap.has(phaseName)) {
                    // Merge items into existing phase
                    const existingPhase = phaseMap.get(phaseName);
                    if (phase.items && phase.items.length > 0) {
                        existingPhase.items.push(...phase.items);
                    }
                } else {
                    // Add new phase
                    phaseMap.set(phaseName, { ...phase });
                }
            });

            const mergedPhases = Array.from(phaseMap.values());
            console.log(`âœ… After merging duplicates: ${mergedPhases.length} unique phases`);

            // Use a generic project name if none was extracted
            if (!projectName) {
                projectName = `${patternConfig.name} Project`;
            }

            // BUILD 321: Include transcript analysis data if available
            const result = {
                projectName: projectName,
                phases: mergedPhases
            };

            // Add transcript analysis fields if any were detected
            if (allExtractedContacts.length > 0) {
                result.extractedContacts = allExtractedContacts;
                console.log(`ğŸ“‡ Total contacts extracted: ${allExtractedContacts.length}`);
            }
            if (allResearchRequests.length > 0) {
                result.researchRequests = allResearchRequests;
                console.log(`ğŸ” Total research requests: ${allResearchRequests.length}`);
            }
            if (allItemUpdates.length > 0) {
                result.itemUpdates = allItemUpdates;
                console.log(`ğŸ“ Total item updates: ${allItemUpdates.length}`);
            }

            return result;
        }

        // =========================================================================
        // BUILD 355: VERIFICATION PASS - Validate & Auto-Fix Generated Trees
        // =========================================================================
        // Generator â†’ Critic â†’ Revise pipeline to catch errors before user sees them

        /**
         * Verify generated tree data and attempt fixes if issues found
         * @param {Object} treeData - The generated tree data
         * @param {string} pattern - The pattern used
         * @param {string} originalText - Original input text (for context in fixes)
         * @returns {Object} - Verified/fixed tree data
         */
        async function verifyAndFixTreeData(treeData, pattern, originalText) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;

            console.log('ğŸ” BUILD 355: Starting verification pass...');

            // Collect issues
            const issues = [];

            // Check 1: Has phases?
            if (!treeData.phases || !Array.isArray(treeData.phases) || treeData.phases.length === 0) {
                issues.push({
                    severity: 'critical',
                    message: `No ${levels.phase}s found in generated tree`,
                    type: 'missing_phases'
                });
            }

            // Check 2: Project name exists?
            if (!treeData.projectName || treeData.projectName.trim() === '') {
                issues.push({
                    severity: 'minor',
                    message: 'Missing project name',
                    type: 'missing_project_name'
                });
                // Quick fix - don't need AI for this
                treeData.projectName = `${patternConfig.name} Project`;
            }

            // Check 3: Validate each phase
            let totalItems = 0;
            let itemsWithDescription = 0;
            let itemsWithSubtasks = 0;

            if (treeData.phases && Array.isArray(treeData.phases)) {
                treeData.phases.forEach((phase, pIdx) => {
                    // Phase needs a name
                    if (!phase.name || phase.name.trim() === '') {
                        issues.push({
                            severity: 'warning',
                            message: `${levels.phase} ${pIdx + 1} has no name`,
                            type: 'missing_phase_name',
                            location: `phase[${pIdx}]`
                        });
                    }

                    // Phase should have items
                    if (!phase.items || !Array.isArray(phase.items) || phase.items.length === 0) {
                        issues.push({
                            severity: 'warning',
                            message: `${levels.phase} "${phase.name || pIdx + 1}" has no ${levels.item}s`,
                            type: 'empty_phase',
                            location: `phase[${pIdx}]`
                        });
                    } else {
                        // Check each item
                        phase.items.forEach((item, iIdx) => {
                            totalItems++;

                            if (!item.name || item.name.trim() === '') {
                                issues.push({
                                    severity: 'warning',
                                    message: `${levels.item} at ${levels.phase} "${phase.name}" position ${iIdx + 1} has no name`,
                                    type: 'missing_item_name',
                                    location: `phase[${pIdx}].items[${iIdx}]`
                                });
                            }

                            if (item.description && item.description.trim() !== '') {
                                itemsWithDescription++;
                            }

                            if (item.subtasks && Array.isArray(item.subtasks) && item.subtasks.length > 0) {
                                itemsWithSubtasks++;
                            } else if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                                // Some patterns use subItems instead of subtasks
                                itemsWithSubtasks++;
                            }
                        });
                    }
                });
            }

            // Check 4: Description coverage (warn if <50% have descriptions)
            if (totalItems > 0) {
                const descCoverage = (itemsWithDescription / totalItems) * 100;
                if (descCoverage < 50) {
                    issues.push({
                        severity: 'quality',
                        message: `Only ${Math.round(descCoverage)}% of ${levels.item}s have descriptions`,
                        type: 'low_description_coverage',
                        stats: { total: totalItems, withDesc: itemsWithDescription }
                    });
                }
            }

            // Check 5: Subtask coverage for deep patterns (philosophy, thesis, course)
            const deepPatterns = ['philosophy', 'thesis', 'course', 'book', 'film'];
            if (deepPatterns.includes(pattern) && totalItems > 0) {
                const subtaskCoverage = (itemsWithSubtasks / totalItems) * 100;
                if (subtaskCoverage < 30) {
                    issues.push({
                        severity: 'quality',
                        message: `Only ${Math.round(subtaskCoverage)}% of ${levels.item}s have ${levels.subtask}s (${pattern} pattern expects more depth)`,
                        type: 'low_subtask_coverage',
                        stats: { total: totalItems, withSubtasks: itemsWithSubtasks }
                    });
                }
            }

            // Log issues found
            const criticalIssues = issues.filter(i => i.severity === 'critical');
            const warningIssues = issues.filter(i => i.severity === 'warning');
            const qualityIssues = issues.filter(i => i.severity === 'quality');

            console.log(`ğŸ” Verification complete: ${criticalIssues.length} critical, ${warningIssues.length} warnings, ${qualityIssues.length} quality suggestions`);

            // If critical issues or multiple warnings, attempt AI fix
            if (criticalIssues.length > 0 || warningIssues.length >= 3) {
                console.log('âš ï¸ Issues require AI correction. Attempting fix...');

                try {
                    const fixedTree = await attemptAITreeFix(treeData, issues, pattern, originalText);
                    if (fixedTree) {
                        console.log('âœ… AI fix successful');
                        // Add verification metadata
                        fixedTree._verificationPassed = true;
                        fixedTree._fixApplied = true;
                        fixedTree._issuesFixed = issues.length;
                        return fixedTree;
                    }
                } catch (error) {
                    console.warn('âš ï¸ AI fix failed, returning original with warnings:', error.message);
                }
            }

            // Add verification metadata
            treeData._verificationPassed = issues.filter(i => i.severity !== 'quality').length === 0;
            treeData._qualityIssues = qualityIssues.length;

            return treeData;
        }

        /**
         * Call AI to fix issues in generated tree
         */
        async function attemptAITreeFix(treeData, issues, pattern, originalText) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;

            // Build feedback prompt
            const issuesList = issues.map(i => `- ${i.message}`).join('\n');

            const fixPrompt = `You previously generated a tree structure but it has these issues:

${issuesList}

Here is the ORIGINAL TEXT that needs to be analyzed:
---
${originalText.substring(0, 3000)}${originalText.length > 3000 ? '...(truncated)' : ''}
---

Here is the FLAWED TREE you generated:
${JSON.stringify(treeData, null, 2).substring(0, 2000)}

Please regenerate the tree, fixing all the issues above. The pattern is "${patternConfig.name}" with these levels:
- ${levels.root} (root)
- ${levels.phase} (phases/major sections)
- ${levels.item} (items within each phase)
- ${levels.subtask} (subtasks/sub-items for depth)

IMPORTANT:
1. Every ${levels.phase} must have a meaningful name
2. Every ${levels.phase} must have at least 1-2 ${levels.item}s
3. ${levels.item}s should have descriptions that capture key information
4. For ${pattern} pattern, include ${levels.subtask}s where the content supports them

Return ONLY valid JSON in this exact format:
{
  "projectName": "...",
  "phases": [
    {
      "name": "...",
      "items": [
        {
          "name": "...",
          "description": "...",
          "subtasks": [{ "name": "..." }]
        }
      ]
    }
  ]
}`;

            // Get current AI provider
            const provider = localStorage.getItem('aiProvider') || 'claude';
            let response;

            // Show fixing status
            const modalBody = document.getElementById('modal-body');
            if (modalBody) {
                modalBody.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div class="spinner"></div>
                        <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600;">
                            ğŸ”§ Fixing ${issues.length} issue${issues.length > 1 ? 's' : ''}...
                        </p>
                        <p style="color: var(--text-secondary); font-size: 13px; margin-top: 8px;">
                            TreeBeard is reviewing and improving the structure
                        </p>
                    </div>
                `;
            }

            try {
                if (provider === 'claude') {
                    response = await callClaudeAPI(fixPrompt);
                } else if (provider === 'gemini') {
                    response = await callGeminiAPI(fixPrompt);
                } else if (provider === 'openai') {
                    response = await callOpenAIAPI(fixPrompt);
                } else {
                    throw new Error('Unknown AI provider');
                }

                // Extract JSON from response
                let jsonText = response.trim();
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                const firstBrace = jsonText.indexOf('{');
                if (firstBrace === -1) throw new Error('No JSON in fix response');

                // Find matching closing brace
                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonText.length; i++) {
                    const char = jsonText[i];
                    if (escapeNext) { escapeNext = false; continue; }
                    if (char === '\\') { escapeNext = true; continue; }
                    if (char === '"') { inString = !inString; continue; }
                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) { endPos = i + 1; break; }
                        }
                    }
                }

                if (endPos === -1) throw new Error('Incomplete JSON in fix response');

                jsonText = jsonText.substring(firstBrace, endPos);
                const fixed = JSON.parse(jsonText);

                // Validate the fix actually improved things
                if (!fixed.phases || fixed.phases.length === 0) {
                    throw new Error('Fix produced empty tree');
                }

                // Preserve any transcript analysis data from original
                if (treeData.extractedContacts) fixed.extractedContacts = treeData.extractedContacts;
                if (treeData.researchRequests) fixed.researchRequests = treeData.researchRequests;
                if (treeData.itemUpdates) fixed.itemUpdates = treeData.itemUpdates;

                return fixed;

            } catch (error) {
                console.error('âŒ AI fix attempt failed:', error);
                throw error;
            }
        }

        // OLD SINGLE-CHUNK FALLBACK (DEPRECATED - keeping for reference)
        async function convertTextToTreeQuick_LEGACY(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the FIRST complete JSON object using proper brace matching
                const firstBrace = jsonText.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ğŸª„ [Quick] Skipping text before JSON:', jsonText.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Incomplete JSON object in AI response (no closing brace found).');
                }

                if (endPos < jsonText.length) {
                    console.log('ğŸª„ [Quick] Skipping text after JSON:', jsonText.substring(endPos, Math.min(endPos + 100, jsonText.length)));
                }

                jsonText = jsonText.substring(firstBrace, endPos);

                console.log('ğŸª„ [Quick] Extracted JSON length:', jsonText.length);

                // Sanitize JSON: Fix control characters in string values (same as wizard)
                let parsed;
                try {
                    parsed = JSON.parse(jsonText);
                } catch (firstError) {
                    console.warn('ğŸª„ [Quick] JSON parse failed, attempting sanitization...', firstError.message);

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonText = sanitized;
                    console.log('âœ… [Quick] JSON sanitized successfully');
                    parsed = JSON.parse(jsonText);
                }

                return parsed;
            } catch (e) {
                console.error('Failed to parse quick conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('ğŸ”§ Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('âœ… JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('âŒ Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Deep Mode: Detailed parsing with field extraction
        async function convertTextToTreeDeep(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            // SPECIAL CASE: Prompt Engineering pattern - improve the prompt instead of extracting
            if (pattern === 'prompting') {
                return await improvePromptWithAI(text, 'deep');
            }

            // =========================================================================
            // SEMANTIC CHUNKING PREPROCESSING (Deep Mode)
            // =========================================================================
            console.log('ğŸ§  [Deep] Starting semantic chunking preprocessing...');
            const chunker = new SemanticChunker();
            let chunks;

            // Show chunking status in UI
            const modalBody = document.getElementById('modal-body');
            if (modalBody) {
                modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">ğŸ§  Analyzing text structure (Deep Mode)...</p>';
            }

            // Tier 2: Scientific approach (if embedding provider available)
            if (EmbeddingManager.hasProvider()) {
                console.log('âœ… [Deep] Embedding provider detected - using scientific semantic chunking');
                try {
                    chunks = await chunker.chunkByEmbedding(text);
                } catch (error) {
                    console.warn('âš ï¸ [Deep] Semantic chunking failed, falling back to structural split:', error);
                    chunks = chunker.structuralSplit(text);
                }
            } else {
                // Tier 1: Structural fallback
                console.log('ğŸ“ [Deep] No embedding provider - using structural split');
                chunks = chunker.structuralSplit(text);
            }

            console.log(`âœ… [Deep] Text split into ${chunks.length} semantic chunks`);

            // Show chunk visualization
            if (modalBody && chunks.length > 1) {
                const chunkLengths = chunks.map(c => c.text.length);
                const maxLength = Math.max(...chunkLengths);
                const bars = chunks.map((chunk, i) => {
                    const width = (chunk.text.length / maxLength) * 100;
                    return `<div style="background: linear-gradient(90deg, rgba(244, 63, 94, 0.6), rgba(251, 146, 60, 0.6)); height: 10px; width: ${width}%; border-radius: 4px; margin: 2px 0;" title="Chunk ${i + 1}: ${chunk.text.length} chars"></div>`;
                }).join('');

                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div class="spinner"></div>
                            <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600;">
                                ğŸ§  Deep Mode: ${chunks.length} Semantic Sections Detected
                            </p>
                            <p style="color: var(--text-secondary); font-size: 13px; margin-top: 4px;">
                                Performing comprehensive extraction on each section...
                            </p>
                        </div>
                        <div style="padding: 12px; background: rgba(244, 63, 94, 0.1); border-radius: 8px; border: 1px solid rgba(244, 63, 94, 0.3);">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Chunk size distribution:</div>
                            ${bars}
                        </div>
                    </div>
                `;
            }

            // Generate dynamic field extraction guide from pattern.fields
            function generateFieldExtractionGuide(pattern) {
                const patternDef = PATTERNS[pattern];
                const fields = patternDef.fields || {};

                let guide = `\n${patternDef.name.toUpperCase()} PATTERN - EXTRACT THESE FIELDS FOR EVERY ITEM:\n`;

                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];

                    // Skip non-field properties
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    if (fieldConfig.label) {
                        guide += `- ${fieldKey}: ${fieldConfig.label}`;

                        // Add extraction hints based on field type
                        if (fieldConfig.type === 'number') {
                            guide += ` (extract numeric value`;
                            if (fieldConfig.min !== undefined || fieldConfig.max !== undefined) {
                                guide += `, valid range ${fieldConfig.min || 0}-${fieldConfig.max || 'âˆ'}`;
                            }
                            if (fieldConfig.step !== undefined) {
                                guide += `, use increments of ${fieldConfig.step}`;
                            }
                            guide += `)`;
                        } else if (fieldConfig.type === 'date') {
                            guide += ` (extract date, format as YYYY-MM-DD)`;
                        } else if (fieldConfig.type === 'select' && fieldConfig.options) {
                            guide += ` (choose from: ${fieldConfig.options.join(', ')})`;
                        } else if (fieldConfig.type === 'textarea') {
                            guide += ` (detailed text, 100-300 characters)`;
                        } else if (fieldConfig.type === 'text' && fieldConfig.placeholder) {
                            guide += ` (e.g., "${fieldConfig.placeholder}")`;
                        }

                        if (fieldConfig.helpText) {
                            guide += ` - ${fieldConfig.helpText}`;
                        }

                        guide += `\n`;
                    }
                });

                // Add item types
                if (patternDef.types && patternDef.types.length > 0) {
                    guide += `\nITEM TYPES FOR ${patternDef.name.toUpperCase()}: Use specific types from this list:\n`;
                    const typesList = patternDef.types.map(t => t.value).join(', ');
                    guide += typesList + '\n';
                    guide += `(NOT generic types - use the specific types above to categorize each item)\n`;
                }

                // Add PM tracking fields if pattern supports it
                if (fields.includeTracking && patternDef.fields.trackingFor) {
                    guide += `\nPM TRACKING FIELDS (for ${patternDef.fields.trackingFor.join('/')}s):\n`;
                    guide += `- pmStatus: Task status (choose from: To Do, In Progress, Blocked, Done)\n`;
                    guide += `- pmAssignee: Person responsible (if mentioned in text)\n`;
                    guide += `- pmProgress: Completion percentage (0-100)\n`;
                    guide += `- pmPriority: Priority level (Low, Medium, High, Critical)\n`;
                    guide += `- pmDueDate: Deadline (format YYYY-MM-DD if mentioned)\n`;
                    guide += `- pmStartDate: Start date (format YYYY-MM-DD if mentioned)\n`;
                }

                // Add dependencies hint
                if (fields.includeDependencies) {
                    guide += `\nDEPENDENCIES:\n`;
                    guide += `- Identify which ${levels.item}s depend on others\n`;
                    guide += `- Look for: "depends on", "requires", "after", "builds on", "assumes"\n`;
                    guide += `- Format as array of item IDs: ["item-0-1", "item-0-2"]\n`;
                }

                return guide;
            }

            const patternFieldGuide = generateFieldExtractionGuide(pattern);

            // Pattern-specific subtask guidance for Deep Mode
            // BUILD 320: Added CAPEX subtask guidance
            function getDeepModeSubtaskGuidance(pattern) {
                const guidance = {
                    capex: `CAPEX: ${levels.subtask}s = components, delivery milestones, installation steps, vendor deliverables, verification tasks. Include cost breakdowns where available.`,
                    philosophy: `Philosophy: ${levels.subtask}s = premises, objections, supporting evidence, citations. REQUIRED: 1-3 subItems per claim. NEVER skip subItems.`,
                    sales: `Sales: ${levels.subtask}s = follow-up actions, meeting notes, deliverables, next steps to advance the deal`,
                    thesis: `Academic: ${levels.subtask}s = supporting arguments, citations, evidence, counter-arguments to address`,
                    roadmap: `Engineering: ${levels.subtask}s = implementation tasks, technical specs, acceptance criteria, testing steps`,
                    book: `Narrative: ${levels.subtask}s = individual scenes, character moments, plot developments, transitions`,
                    course: `Education: ${levels.subtask}s = lessons, activities, assessments, practice exercises, readings`,
                    film: `Film: ${levels.subtask}s = specific shots, camera angles, lighting changes, actor blocking, technical details`,
                    prompting: `Prompting: ${levels.subtask}s = test cases, edge cases, variations to handle, example inputs/outputs`,
                    generic: `${levels.subtask}s = steps, components, or sub-elements needed to complete the ${levels.item}`
                };
                return guidance[pattern] || guidance.generic;
            }

            // Pattern-specific extraction instructions
            // BUILD 320: Added CAPEX pattern instructions based on A/B testing
            function getPatternSpecificInstructions(pattern) {
                const instructions = {
                    capex: `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ CAPEX PATTERN - FINANCIAL RIGOR REQUIRED
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’° COST EXTRACTION (CRITICAL - DO NOT SKIP):
Every dollar amount in the source text MUST be captured:
- "$1.2M" â†’ cost: 1200000 (raw number, no symbols)
- "$500K-$750K" â†’ cost: 625000 (use midpoint)
- "approximately $2 million" â†’ cost: 2000000
- NEVER omit or round costs arbitrarily

ğŸ“Š PROJECT HIERARCHY:
- Phase = Project phase (Planning, Procurement, Installation, Commissioning, etc.)
- Item = Individual capital expense line item (equipment, infrastructure, service)
- SubItem = Component, delivery milestone, installation step, or verification task

ğŸ·ï¸ ITEM TYPES (Assign precisely):
- equipment: Physical hardware, servers, machinery, devices
- infrastructure: Facilities, power distribution, cooling, networking, cabling
- labor: Installation services, configuration, training, deployment
- software: Licenses, subscriptions, development, integration
- consulting: Professional services, architecture, design, project management
- contingency: Risk reserves, buffer allocations, variance pools

ğŸ“‹ REQUIRED FIELDS FOR EVERY ITEM:
- name: SPECIFIC equipment name (e.g., "Dell PowerEdge R750 Servers (96 units)" NOT just "servers")
- cost: Numeric value ONLY (no $ or commas)
- itemType: One of the types above
- description: Technical specifications or scope details
- leadTime: Delivery/implementation time if mentioned ("6-8 weeks", "Q3 2025")
- alternateSource: Vendor/supplier name (Cisco, Dell, contractor name)
- dependencies: Array of item IDs this depends on ["item-0-1", "item-1-2"]

ğŸ”— DEPENDENCY TRACKING:
Look for sequencing language:
- "after installation of..." â†’ add dependency
- "requires..." â†’ add dependency
- "cannot proceed until..." â†’ add dependency
- Format: dependencies: ["item-X-Y"] referencing other items

âš ï¸ COMMON MISTAKES TO AVOID:
- Omitting cost values (NEVER skip a dollar amount)
- Generic names like "Equipment" (be specific)
- Missing vendor/supplier names
- Ignoring contingency/risk reserves
- Skipping lead time information
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`,
                    philosophy: `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ PHILOSOPHY PATTERN - CRITICAL REQUIREMENTS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“œ ARGUMENTATIVE STRUCTURE (3-5 PHASES):
Follow the text's own argumentative flow. Common patterns include:
- Problem/Question â†’ Method â†’ Analysis â†’ Conclusion
- Thesis â†’ Antithesis â†’ Synthesis
- Doubt â†’ Investigation â†’ Discovery â†’ Implications

ğŸ“‹ SUBITEMS REQUIREMENT:
- EVERY claim MUST have 1-3 subItems
- SubItems = premises, evidence, textual references, supporting reasoning
- NEVER create claims without supporting subItems

ğŸ·ï¸ ARGUMENT TYPES (Use correctly):
- question: Interrogative moves that drive the inquiry forward
- premise: Foundational claims or assumptions supporting later arguments
- definition: Explicit attempts to define or characterize concepts
- refutation: Counter-arguments that challenge or disprove prior claims
  âš ï¸ Includes: analogies, thought experiments, reductio arguments used to COUNTER a position
- conclusion: Claims derived from prior reasoning

âš ï¸ KEY DISTINCTION:
When an analogy or thought experiment is used to CHALLENGE or DISPROVE a claim,
it is a REFUTATION, not a question or premise. Look for the argumentative function.

âœ… CORRECT TYPING:
- "If a deceiver deceives me, I must exist to be deceived" â†’ refutation (self-refuting doubt)
- "What is the nature of X?" â†’ question
- "X is defined as Y" â†’ definition
- "Therefore, X must be true" â†’ conclusion
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`,
                    film: `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ AI VIDEO PRODUCTION - CRITICAL INSTRUCTIONS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

YOU ARE CREATING ACTUAL VIDEO SCENES, NOT META-WORKFLOWS!

ğŸ¬ WHAT TO CREATE:
- Each item = ONE SPECIFIC SHOT/SCENE
- Describe WHAT APPEARS IN THE FRAME
- Include: subject, action, camera movement, lighting, mood

âŒ DO NOT CREATE:
- Workflows about "creating prompts"
- Meta-tasks like "Generate a prompt for..."
- Process steps like "Use Sora to..."
- Planning tasks like "Write description of..."

âœ… CORRECT EXAMPLE (user says "drone flight over data center"):
{
  "phases": [{
    "name": "Establishing Sequence",
    "items": [
      {
        "name": "Wide aerial establishing shot",
        "description": "Camera starts at 500 feet showing vast data center campus in Saskatchewan plains",
        "videoPrompt": "Aerial drone shot ascending from ground level, revealing massive data center facility surrounded by snow-covered farmland. Wide establishing shot showing geometric rows of server buildings with steam rising from cooling towers. Camera rises smoothly from 50 feet to 200 feet over 10 seconds. Golden hour lighting with long shadows across white landscape. Cinematic widescreen aesthetic.",
        "aiPlatform": "Veo 3 (Google)",
        "visualStyle": "Cinematic",
        "duration": "10 seconds",
        "aspectRatio": "16:9 (Widescreen)",
        "cameraMovement": "Crane Up",
        "motionIntensity": "Moderate",
        "lightingMood": "Golden Hour"
      },
      {
        "name": "Dolly shot of server building exterior",
        "description": "Close-up tracking shot along reflective glass facade",
        "videoPrompt": "Slow dolly right along mirrored glass exterior of data center building. Reflections of winter sky and clouds move across glass surface. Camera tracks steadily at 6 feet height, revealing geometric patterns of windows and air vents. Overcast lighting with soft shadows. Modern architectural aesthetic. 6-second clip.",
        "cameraMovement": "Tracking Shot",
        "duration": "6 seconds"
      }
    ]
  }]
}

âŒ WRONG EXAMPLE (meta-workflow - DO NOT DO THIS):
{
  "phases": [{
    "name": "Content Creation",
    "items": [
      {
        "name": "Introduction Prompt",
        "description": "Create a natural language prompt for an introductory segment"  âŒ NO!
      },
      {
        "name": "Generate Drone Tour",
        "description": "Use Sora to produce drone footage"  âŒ NO!
      }
    ]
  }]
}

ğŸ¥ FOR EACH SCENE ITEM:
1. **name**: Short description of the shot (e.g., "Aerial reveal of campus")
2. **description**: What happens in the scene (action, subjects, context)
3. **videoPrompt**: DETAILED 100-300 character prompt describing:
   - What appears in frame
   - Camera movement and framing
   - Lighting and mood
   - Visual style
   - Duration
4. **aiPlatform**: Which AI to use (Sora, Veo 3, Runway, Pika)
5. **cameraMovement**: How camera moves (Dolly In, Crane Up, Tracking Shot, etc.)
6. **visualStyle**: Cinematic, Documentary, Photorealistic, etc.
7. **lightingMood**: Golden Hour, Dramatic, Soft Natural, etc.
8. **duration**: How long (2s, 4s, 6s, 10s, 20s)
9. **aspectRatio**: 16:9, 9:16, 2.39:1, etc.

REMEMBER: You are a cinematographer, not a project planner!
Describe the ACTUAL SHOTS, not the process of creating them.
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`
                };

                return instructions[pattern] || '';
            }

            const patternSpecificInstructions = getPatternSpecificInstructions(pattern);

            // =========================================================================
            // CHUNK PROCESSING LOOP (Deep Mode)
            // =========================================================================
            const allPhasesCollected = [];
            let projectName = '';

            for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                const chunk = chunks[chunkIndex];
                console.log(`ğŸ”„ [Deep] Processing chunk ${chunkIndex + 1}/${chunks.length} (${chunk.text.length} chars)`);

                // Update UI with chunk progress feedback
                const percent = Math.round(((chunkIndex + 1) / chunks.length) * 100);
                const modalBody = document.getElementById('modal-body');
                if (modalBody && chunks.length > 1) {
                    const progressBars = chunks.map((c, i) => {
                        const isProcessed = i < chunkIndex;
                        const isProcessing = i === chunkIndex;
                        const barColor = isProcessed ? 'rgba(16, 185, 129, 0.8)' : isProcessing ? 'rgba(251, 146, 60, 0.8)' : 'rgba(100, 100, 100, 0.3)';
                        return `<div style="flex: 1; height: 8px; background: ${barColor}; border-radius: 4px; transition: background 0.3s;"></div>`;
                    }).join('');

                    modalBody.innerHTML = `
                        <div style="padding: 20px;">
                            <div style="text-align: center; margin-bottom: 16px;">
                                <div class="spinner"></div>
                                <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600; font-size: 16px;">
                                    ğŸ§  Analyzing Section ${chunkIndex + 1} of ${chunks.length}
                                </p>
                                <p style="color: var(--text-secondary); font-size: 14px; margin-top: 4px;">
                                    ${percent}% complete â€¢ ${chunk.text.length.toLocaleString()} characters
                                </p>
                            </div>
                            <div style="display: flex; gap: 4px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                ${progressBars}
                            </div>
                            <div style="text-align: center; margin-top: 12px; font-size: 12px; color: var(--text-secondary);">
                                Deep Mode extracts comprehensive details from each section
                            </div>
                        </div>
                    `;
                }

                // BUILD 353: Prepend Smart Import Context if available
                const smartContextDeep = window.smartImportContext || '';
                const chunkPrompt = `${smartContextDeep}Convert this SPECIFIC SECTION of a larger document into a detailed hierarchical structure using the "${patternConfig.name}" pattern (Section ${chunkIndex + 1}/${chunks.length}).

PATTERN HIERARCHY (4 LEVELS):
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}
${patternFieldGuide}
${patternSpecificInstructions}

SECTION TEXT (Section ${chunkIndex + 1}/${chunks.length}):
${chunk.text}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
DEEP MODE INSTRUCTIONS - COMPREHENSIVE EXTRACTION (SECTION ${chunkIndex + 1}/${chunks.length})
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âš ï¸ CRITICAL REQUIREMENTS - YOU MUST MEET THESE MINIMUMS FOR THIS SECTION:

1. PHASES: Create 1-3 phases (${levels.phase}s) for THIS SECTION ONLY
   â†’ Do NOT summarize - extract actual phases present in this section
   â†’ Each major subsection/movement/chapter in THIS SECTION = separate phase

2. ITEMS PER PHASE: REQUIRED MINIMUM 3-8 items (${levels.item}s) per phase
   â†’ Do NOT create just 1 item per phase
   â†’ Extract ALL significant claims/arguments/features/sections
   â†’ Each distinct idea/component/argument = separate item

3. SUBTASKS: Add 2-5 ${levels.subtask}s to items that need decomposition
   â†’ ${levels.subtask}s are pattern-specific breakdowns of each ${levels.item}
   â†’ ${getDeepModeSubtaskGuidance(pattern)}
   â†’ Only skip ${levels.subtask}s for truly atomic items that cannot be decomposed

4. DEPTH: Go 3-4 levels deep in the hierarchy
   â†’ Phase â†’ Item â†’ Subtask â†’ (nested subtask if needed)
   â†’ Do NOT stop at 2 levels

5. FIELD POPULATION: Extract ALL pattern-specific field values listed above
   â†’ Populate EVERY field mentioned in the "${patternConfig.name.toUpperCase()}" pattern section
   â†’ Do NOT leave fields empty if information is available in the text
   â†’ If exact value not in text, make intelligent estimates (for word counts, story points, etc.)
   â†’ For dates, use YYYY-MM-DD format

6. DEPENDENCIES: Identify ALL logical prerequisites
   â†’ Look for: "depends on", "requires", "builds on", "follows from", "assumes", "after"
   â†’ Format: ["item-X-Y", "item-Z-W"]
   â†’ Map both intra-phase and inter-phase dependencies

7. NODE TYPES: Use specific types from the "${patternConfig.name.toUpperCase()}" item type list above
   â†’ Use the EXACT type values provided (not generic categories)
   â†’ Different items should have different types based on their function
   â†’ Do NOT use the same type for every item

8. DESCRIPTIONS: Write detailed descriptions (100-250 characters)
   â†’ Capture nuance, context, and significance
   â†’ NOT just repetition of title

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
EXAMPLE OF PROPER DEPTH (Philosophy Pattern)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

If text contains: "Socrates asks: What is justice? Callias replies it is giving each what they are owed. Socrates refutes this with the mad debtor example."

WRONG (too shallow):
{
  "phases": [{
    "name": "Movement 1",
    "items": [{"name": "Discussion of justice"}]
  }]
}

CORRECT (proper depth):
{
  "phases": [{
    "name": "Movement 1",
    "subtitle": "The Initial Inquiry",
    "items": [
      {
        "name": "Opening Question: What is Justice?",
        "itemType": "question",
        "speaker": "Socrates",
        "description": "Socrates initiates inquiry by asking Callias to define justice",
        "keyTerms": "justice, definition",
        "dependencies": []
      },
      {
        "name": "First Definition: Justice as Giving What is Owed",
        "itemType": "definition",
        "speaker": "Callias",
        "description": "Callias proposes justice means giving each person what they are owed",
        "keyTerms": "justice, debt, obligation",
        "dependencies": []
      },
      {
        "name": "Refutation via Mad Debtor Counterexample",
        "itemType": "refutation",
        "speaker": "Socrates",
        "argumentType": "Socratic Elenchus",
        "description": "Socrates refutes Callias's definition using case of returning sword to madman",
        "dependencies": ["item-0-1"],
        "subItems": [
          {
            "name": "Premise: Returning sword to madman is dangerous",
            "itemType": "premise",
            "premise1": "The madman is owed the sword (per Callias's definition)",
            "conclusion": "But returning it would be unjust (harmful)",
            "description": "Creates contradiction in Callias's definition"
          },
          {
            "name": "Conclusion: Definition is insufficient",
            "itemType": "conclusion",
            "description": "Justice cannot be merely giving what is owed, circumstances matter",
            "dependencies": ["subtask-0-2-0"]
          }
        ]
      }
    ]
  }]
}

See the difference? The CORRECT version:
âœ“ Has 3 items (not 1)
âœ“ Uses specific item types (question, definition, refutation)
âœ“ Populates fields (speaker, argumentType, keyTerms, premises)
âœ“ Has subtasks with proper nesting
âœ“ Maps dependencies between nodes

THIS IS THE LEVEL OF DETAIL REQUIRED IN DEEP MODE.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
FINAL REMINDER
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Deep Mode = COMPREHENSIVE EXTRACTION, not summarization
Extract EVERYTHING with maximum granularity and detail
Aim for 25-40 total nodes for complex texts (Haiku's 4096 token limit)

JSON FORMATTING RULES (CRITICAL - FOLLOW EXACTLY):
- NO trailing commas after the last element in arrays or objects
- NO line breaks or tabs inside string values - use spaces instead
- NO unescaped quotes inside strings
- ONLY plain JSON - no markdown code blocks, no backticks, no explanations
- Start response with { and end with }

CORRECT EXAMPLE (note: NO trailing comma after last item):
{"phases": [{"name": "Test", "items": [{"name": "Item"}]}]}

WRONG (trailing comma):
{"phases": [{"name": "Test", "items": [{"name": "Item"},]}]}

Respond with ONLY valid, parseable JSON:
{
  "projectName": "Extracted or inferred project name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle",
      "icon": "ğŸ“‹",
      "items": [
        {
          "name": "Item name",
          "description": "Detailed description",
          "itemType": "category",
          "cost": 1000,
          "dependencies": ["item-0-1", "item-1-2"],
          "subtasks": [
            {
              "name": "Subtask name",
              "description": "What needs to be done",
              "dependencies": []
            }
          ],
          "... other pattern-specific fields ...": "values"
        }
      ]
    }
  ]
}`;

                // BUILD 319: Deep Mode uses optimized model selection + higher token limits
                // Pattern-specific models (e.g., Opus for Philosophy) with extended output
                const response = await callOptimizedImportAPI(chunkPrompt, '', 8192, pattern);

                // Parse JSON response from this chunk
                try {
                    let jsonText = response.trim();

                    // Remove markdown code blocks if present
                    jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    // Find the FIRST complete JSON object using proper brace matching
                    const firstBrace = jsonText.indexOf('{');

                    if (firstBrace === -1) {
                        console.warn(`âš ï¸ [Deep] Chunk ${chunkIndex + 1}: No JSON found, skipping`);
                        continue;
                    }

                    if (firstBrace > 0) {
                        console.log(`ğŸª„ [Deep] Chunk ${chunkIndex + 1}: Skipping text before JSON`);
                    }

                    let depth = 0;
                    let endPos = -1;
                    let inString = false;
                    let escapeNext = false;

                    for (let i = firstBrace; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            inString = !inString;
                            continue;
                        }

                        if (!inString) {
                            if (char === '{') depth++;
                            else if (char === '}') {
                                depth--;
                                if (depth === 0) {
                                    endPos = i + 1;
                                    break;
                                }
                            }
                        }
                    }

                    if (endPos === -1) {
                        console.warn(`âš ï¸ [Deep] Chunk ${chunkIndex + 1}: Incomplete JSON, skipping`);
                        continue;
                    }

                    jsonText = jsonText.substring(firstBrace, endPos);

                    // Parse JSON
                    let parsed;
                    try {
                        parsed = JSON.parse(jsonText);
                    } catch (firstError) {
                        console.warn(`ğŸª„ [Deep] Chunk ${chunkIndex + 1}: JSON parse failed, attempting sanitization...`, firstError.message);

                        // Sanitize JSON: Fix control characters in string values
                        let sanitized = '';
                        let inString = false;
                        let escapeNext = false;

                        for (let i = 0; i < jsonText.length; i++) {
                            const char = jsonText[i];

                            if (escapeNext) {
                                sanitized += char;
                                escapeNext = false;
                                continue;
                            }

                            if (char === '\\') {
                                sanitized += char;
                                escapeNext = true;
                                continue;
                            }

                            if (char === '"') {
                                sanitized += char;
                                inString = !inString;
                                continue;
                            }

                            // If we're inside a string value, escape control characters
                            if (inString) {
                                if (char === '\n') {
                                    sanitized += '\\n';
                                } else if (char === '\r') {
                                    sanitized += '\\r';
                                } else if (char === '\t') {
                                    sanitized += '\\t';
                                } else if (char.charCodeAt(0) < 32) {
                                    sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                                } else {
                                    sanitized += char;
                                }
                            } else {
                                sanitized += char;
                            }
                        }

                        jsonText = sanitized;
                        console.log(`âœ… [Deep] Chunk ${chunkIndex + 1}: JSON sanitized successfully`);
                        parsed = JSON.parse(jsonText);
                    }

                    // Aggregate results from this chunk
                    if (!projectName && parsed.projectName) {
                        projectName = parsed.projectName;
                        console.log(`ğŸ“ [Deep] Project name extracted from chunk ${chunkIndex + 1}: ${projectName}`);
                    }

                    if (parsed.phases && parsed.phases.length > 0) {
                        console.log(`âœ… [Deep] Chunk ${chunkIndex + 1}: Extracted ${parsed.phases.length} phases with comprehensive detail`);
                        allPhasesCollected.push(...parsed.phases);
                    }

                } catch (e) {
                    console.error(`âŒ [Deep] Chunk ${chunkIndex + 1} failed to parse:`, e);
                    console.error('Response (first 500 chars):', response.substring(0, 500));
                    // Continue to next chunk instead of failing entirely
                }
            }

            // =========================================================================
            // MERGE DUPLICATE PHASES AND RETURN AGGREGATED RESULT (Deep Mode)
            // =========================================================================
            console.log(`âœ… [Deep] All chunks processed. Total phases collected: ${allPhasesCollected.length}`);

            // Merge phases with the same name
            const phaseMap = new Map();
            allPhasesCollected.forEach(phase => {
                const phaseName = phase.name;
                if (phaseMap.has(phaseName)) {
                    // Merge items into existing phase
                    const existingPhase = phaseMap.get(phaseName);
                    if (phase.items && phase.items.length > 0) {
                        existingPhase.items.push(...phase.items);
                    }
                } else {
                    // Add new phase
                    phaseMap.set(phaseName, { ...phase });
                }
            });

            const mergedPhases = Array.from(phaseMap.values());
            console.log(`âœ… [Deep] After merging duplicates: ${mergedPhases.length} unique phases`);

            // Use a generic project name if none was extracted
            if (!projectName) {
                projectName = `${patternConfig.name} Project`;
            }

            return {
                projectName: projectName,
                phases: mergedPhases
            };
        }

        // OLD SINGLE-CHUNK DEEP MODE (DEPRECATED - keeping for reference)
        async function convertTextToTreeDeep_LEGACY(text, pattern) {
            const response = 'DEPRECATED'; // Legacy function - semantic chunking is now standard

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the FIRST complete JSON object using proper brace matching
                const firstBrace = jsonText.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ğŸª„ [Deep] Skipping text before JSON:', jsonText.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Incomplete JSON object in AI response (no closing brace found).');
                }

                if (endPos < jsonText.length) {
                    console.log('ğŸª„ [Deep] Skipping text after JSON:', jsonText.substring(endPos, Math.min(endPos + 100, jsonText.length)));
                }

                jsonText = jsonText.substring(firstBrace, endPos);

                console.log('ğŸª„ [Deep] Extracted JSON length:', jsonText.length);

                // Sanitize JSON: Fix control characters in string values (same as wizard)
                let parsed;
                try {
                    parsed = JSON.parse(jsonText);
                } catch (firstError) {
                    console.warn('ğŸª„ [Deep] JSON parse failed, attempting sanitization...', firstError.message);

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonText = sanitized;
                    console.log('âœ… [Deep] JSON sanitized successfully');
                    parsed = JSON.parse(jsonText);
                }

                return parsed;
            } catch (e) {
                console.error('Failed to parse deep conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('ğŸ”§ Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('âœ… JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('âŒ Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Main Analyze button handler
        document.getElementById('analysis-start-btn').addEventListener('click', async () => {
            // BUILD 519: Get text based on current source type
            let finalText = '';
            let sourceMetadata = null;

            if (currentSourceType === 'text') {
                // Original text/file behavior
                const textFromTextarea = document.getElementById('analysis-text-input').value.trim();
                finalText = analysisText || textFromTextarea;
            } else if (currentSourceType === 'pdf') {
                // PDF extracted text
                finalText = extractedPdfText;
                sourceMetadata = pdfSourceInfo;
            } else if (currentSourceType === 'url') {
                // URL fetched text
                finalText = fetchedUrlText;
                sourceMetadata = urlSourceInfo;
            }

            if (!finalText) {
                const sourceMessages = {
                    'text': 'Please upload a file or paste text to analyze.',
                    'pdf': 'Please upload a PDF file to extract text from.',
                    'url': 'Please fetch a URL to import content from.'
                };
                alert(sourceMessages[currentSourceType]);
                return;
            }

            // Store source metadata for RAG
            window._lastImportSourceMetadata = sourceMetadata;

            // Get global AI mode
            const mode = getGlobalAIMode();

            // Check if AI is disabled
            if (mode === 'off') {
                alert('âŒ AI features are currently disabled.\n\nPlease enable AI mode in the header (ğŸ¤– AI Mode dropdown) to use text analysis.');
                return;
            }

            // Auto-truncate very long texts to prevent timeouts
            // Different limits for Quick vs Deep Mode
            const MAX_CHARS_QUICK = 100000; // ~25,000 words for Quick Mode
            const MAX_CHARS_DEEP = 300000;  // ~75,000 words for Deep Mode (with user API key, no timeout)
            const MAX_CHARS = mode === 'deep' ? MAX_CHARS_DEEP : MAX_CHARS_QUICK;

            let wasTruncated = false;
            if (finalText.length > MAX_CHARS) {
                wasTruncated = true;
                finalText = finalText.substring(0, MAX_CHARS);
                console.warn(`âš ï¸ Text truncated from ${analysisText.length} to ${MAX_CHARS} characters for ${mode} mode`);
            }

            // Check if Deep Mode requires user's own API key
            if (mode === 'deep') {
                const userApiKey = getLocalAPIKey();
                if (!userApiKey) {
                    alert('ğŸ”¬ Deep Mode requires your own Anthropic API key.\n\nWhy?\nâ€¢ Deep Mode uses more tokens and takes longer\nâ€¢ Prevents timeout on Netlify free tier (10s limit)\nâ€¢ You only pay for what you use\n\nPlease:\n1. Click the ğŸ”‘ API Key button\n2. Enter your Anthropic API key\n3. Try Deep Mode again\n\nQuick Mode is available without an API key.');
                    return;
                }
                console.log('âœ… Deep Mode: Using your API key (bypasses rate limits and timeouts)');
            }

            // Warn if text was truncated
            if (wasTruncated) {
                const proceed = confirm(`âš ï¸ Your text is very long and has been automatically truncated to ${MAX_CHARS} characters (~${Math.floor(MAX_CHARS/4)} words) to prevent timeouts.\n\nOnly the first portion will be analyzed.\n\nDo you want to continue?`);
                if (!proceed) {
                    return;
                }
            }

            // BUILD 353: Launch Smart Import Wizard for text analysis
            const textAnalysis = analyzeTextContent(finalText, analysisFileName || 'Pasted Text');

            // Close analysis modal before showing wizard
            document.getElementById('analysis-modal').style.display = 'none';

            // BUILD 354: Pass original text for multi-tree slice detection
            showSmartImportWizard(textAnalysis, analysisAppendMode, async (userAnswers) => {
                // After wizard completes, proceed with the actual analysis
                // BUILD 354: Handle multi-tree mode
                if (userAnswers.multiTreeMode && userAnswers.multiTreeContexts) {
                    await proceedWithMultiTreeTextAnalysis(finalText, mode, userAnswers.multiTreeContexts);
                } else {
                    await proceedWithTextAnalysis(finalText, mode, analysisAppendMode);
                }
            }, { text: finalText });
        });

        // BUILD 353: Extracted analysis logic to separate function for wizard callback
        async function proceedWithTextAnalysis(finalText, mode, appendMode) {
            // Close any modal and show loading modal
            document.getElementById('modal').style.display = 'none';
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'ğŸ” Analyzing Text...';
            modal.style.display = 'flex';

            // Check if user pre-selected a specific pattern
            const preSelectedPattern = document.getElementById('analysis-pattern-select').value;

            try {
                let selectedPattern;

                // If user chose a specific pattern, skip detection and use that pattern directly
                if (preSelectedPattern && preSelectedPattern !== 'auto') {
                    selectedPattern = preSelectedPattern;
                    console.log(`âœ… Using pre-selected pattern: ${selectedPattern}`);

                    // Step 2: Convert text to tree (skip pattern detection)
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 1/2: Converting text to tree structure...</p>';

                    let treeData;
                    if (mode === 'quick') {
                        treeData = await convertTextToTreeQuick(finalText, selectedPattern);
                    } else {
                        treeData = await convertTextToTreeDeep(finalText, selectedPattern);
                    }

                    // BUILD 355: Verification pass
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 2/2: Verifying structure...</p>';
                    treeData = await verifyAndFixTreeData(treeData, selectedPattern, finalText);

                    // Step 3: Preview and import
                    showAnalysisPreview(treeData, selectedPattern, analysisAppendMode);
                    return; // Exit early - we're done!
                }

                // Otherwise, proceed with auto-detection
                modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 1/3: Detecting optimal pattern...</p>';

                // Step 1: Detect pattern
                const recommendations = await detectPattern(finalText);

                // Show pattern selection
                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <h3 style="margin-bottom: 16px; color: var(--text-primary);">ğŸ“Š Recommended Patterns</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px; font-size: 14px;">
                            AI analyzed your text and recommends these patterns. Select one to continue:
                        </p>
                        <div id="pattern-recommendations" style="display: flex; flex-direction: column; gap: 12px;">
                            ${recommendations.map((rec, index) => `
                                <label style="display: flex; align-items: flex-start; padding: 16px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s; background: var(--card-bg);" class="pattern-rec-option" data-pattern="${rec.pattern}">
                                    <input type="radio" name="selected-pattern" value="${rec.pattern}" ${index === 0 ? 'checked' : ''} style="margin-top: 4px; margin-right: 12px;" />
                                    <div style="flex: 1;">
                                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                            <span style="font-weight: 600; color: var(--text-primary); font-size: 15px;">${rec.patternName}</span>
                                            <span style="background: ${rec.confidence >= 8 ? '#4caf50' : rec.confidence >= 6 ? '#ff9f43' : '#666'}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">
                                                ${rec.confidence}/10 confidence
                                            </span>
                                        </div>
                                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                            ${rec.reasoning}
                                        </div>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                        <div style="margin-top: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">
                                Analysis Mode: ${mode === 'quick' ? 'âš¡ Quick Mode' : 'ğŸ”¬ Deep Mode'}
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary);">
                                ${mode === 'quick' ? 'Fast analysis with basic structure extraction.' : 'Detailed analysis with field extraction and dependencies.'}
                            </div>
                        </div>
                    </div>
                `;

                // Add hover effects to pattern options
                document.querySelectorAll('.pattern-rec-option').forEach(option => {
                    option.addEventListener('mouseenter', () => {
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                    option.addEventListener('mouseleave', () => {
                        const radio = option.querySelector('input[type="radio"]');
                        if (!radio.checked) {
                            option.style.borderColor = 'var(--border)';
                            option.style.background = 'var(--card-bg)';
                        }
                    });
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.pattern-rec-option').forEach(opt => {
                            opt.style.borderColor = 'var(--border)';
                            opt.style.background = 'var(--card-bg)';
                        });
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                });

                // Update modal footer with continue button
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="pattern-select-cancel">Cancel</button>
                    <button class="btn btn-primary" id="pattern-select-continue" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Continue â†’</button>
                `;

                document.getElementById('pattern-select-cancel').addEventListener('click', () => {
                    modal.style.display = 'none';
                });

                document.getElementById('pattern-select-continue').addEventListener('click', async () => {
                    const selectedPattern = document.querySelector('input[name="selected-pattern"]:checked').value;

                    // Step 2: Convert text to tree
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 2/3: Converting text to tree structure...</p>';
                    document.querySelector('#modal .modal-footer').innerHTML = '';

                    try {
                        let treeData;
                        if (mode === 'quick') {
                            treeData = await convertTextToTreeQuick(finalText, selectedPattern);
                        } else {
                            treeData = await convertTextToTreeDeep(finalText, selectedPattern);
                        }

                        // BUILD 355: Verification pass
                        modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 3/3: Verifying structure...</p>';
                        treeData = await verifyAndFixTreeData(treeData, selectedPattern, finalText);

                        // Step 4: Preview and import
                        showAnalysisPreview(treeData, selectedPattern, analysisAppendMode);

                    } catch (error) {
                        modalBody.innerHTML = `
                            <div style="padding: 20px; text-align: center;">
                                <div style="font-size: 48px; margin-bottom: 16px;">âŒ</div>
                                <h3 style="color: #f44336; margin-bottom: 12px;">Analysis Failed</h3>
                                <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                            </div>
                        `;
                        document.querySelector('#modal .modal-footer').innerHTML = `
                            <button class="btn" id="error-close">Close</button>
                            <button class="btn btn-primary" id="error-retry">Try Again</button>
                        `;

                        document.getElementById('error-close').addEventListener('click', () => {
                            modal.style.display = 'none';
                        });

                        document.getElementById('error-retry').addEventListener('click', () => {
                            modal.style.display = 'none';
                            document.getElementById('analyze-text-btn').click();
                        });
                    }
                });

            } catch (error) {
                modalBody.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">âŒ</div>
                        <h3 style="color: #f44336; margin-bottom: 12px;">Pattern Detection Failed</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                    </div>
                `;
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="error-close">Close</button>
                `;

                document.getElementById('error-close').addEventListener('click', () => {
                    modal.style.display = 'none';
                });
            }
        }

        // Show preview before importing
        function showAnalysisPreview(treeData, selectedPattern, appendMode = false) {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            document.getElementById('modal-title').textContent = 'âœ… Analysis Complete - Preview';

            // Count phases and items
            const phaseCount = treeData.phases?.length || 0;
            const itemCount = treeData.phases?.reduce((sum, phase) => sum + (phase.items?.length || 0), 0) || 0;

            // BUILD 321: Check for transcript analysis data
            const hasTranscriptData = treeData.extractedContacts?.length > 0 ||
                                      treeData.researchRequests?.length > 0 ||
                                      treeData.itemUpdates?.length > 0;

            // BUILD 321: Generate transcript analysis section HTML
            let transcriptSection = '';
            if (hasTranscriptData) {
                transcriptSection = `
                    <div style="margin-top: 20px; border: 2px solid #6366f1; border-radius: 8px; overflow: hidden;">
                        <div style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; padding: 12px 16px; font-weight: 600;">
                            ğŸ“‹ Transcript Analysis
                        </div>
                        <div style="padding: 16px; background: var(--bg-secondary);">
                            ${treeData.extractedContacts?.length > 0 ? `
                                <div style="margin-bottom: 16px;">
                                    <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                        <span style="background: #10b981; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">${treeData.extractedContacts.length}</span>
                                        ğŸ“‡ Contacts Detected
                                    </div>
                                    <div style="font-size: 13px; color: var(--text-secondary); margin-left: 8px;">
                                        ${treeData.extractedContacts.slice(0, 4).map(c => `â€¢ <strong>${c.name}</strong>${c.role ? ` (${c.role})` : ''}${c.company ? ` - ${c.company}` : ''}`).join('<br>')}
                                        ${treeData.extractedContacts.length > 4 ? `<br><em>... and ${treeData.extractedContacts.length - 4} more</em>` : ''}
                                    </div>
                                </div>
                            ` : ''}
                            ${treeData.researchRequests?.length > 0 ? `
                                <div style="margin-bottom: 16px;">
                                    <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                        <span style="background: #f59e0b; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">${treeData.researchRequests.length}</span>
                                        ğŸ” Research Requests
                                    </div>
                                    <div style="font-size: 13px; color: var(--text-secondary); margin-left: 8px;">
                                        ${treeData.researchRequests.map(r => `â€¢ <strong>${r.topic}</strong>${r.priority === 'high' ? ' <span style="color: #ef4444; font-size: 11px;">HIGH</span>' : ''}`).join('<br>')}
                                    </div>
                                </div>
                            ` : ''}
                            ${treeData.itemUpdates?.length > 0 ? `
                                <div>
                                    <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                        <span style="background: #3b82f6; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">${treeData.itemUpdates.length}</span>
                                        ğŸ“ Item Updates
                                    </div>
                                    <div style="font-size: 13px; color: var(--text-secondary); margin-left: 8px;">
                                        ${treeData.itemUpdates.slice(0, 3).map(u => `â€¢ <strong>${u.itemName}</strong>: ${u.field} â†’ ${u.newValue}`).join('<br>')}
                                        ${treeData.itemUpdates.length > 3 ? `<br><em>... and ${treeData.itemUpdates.length - 3} more</em>` : ''}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, #4caf50, #00a67d); color: white; padding: 20px; border-radius: 12px; margin-bottom: 24px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 8px;">âœ¨</div>
                        <h2 style="margin-bottom: 8px; font-size: 24px;">${treeData.projectName || 'Analyzed Project'}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Pattern: ${PATTERNS[selectedPattern].name}${hasTranscriptData ? ' â€¢ ğŸ“‹ Transcript Mode' : ''}</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${phaseCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Phases Detected</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${itemCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Items Created</div>
                        </div>
                    </div>

                    <div style="max-height: ${hasTranscriptData ? '200px' : '300px'}; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 16px; background: var(--bg-secondary);">
                        <h4 style="margin-bottom: 12px; color: var(--text-primary);">Structure Preview:</h4>
                        ${treeData.phases?.map((phase, i) => `
                            <div style="margin-bottom: 16px;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px;">
                                    ${phase.icon || 'ğŸ“‹'} ${phase.name}
                                </div>
                                <div style="margin-left: 20px; font-size: 13px; color: var(--text-secondary);">
                                    ${phase.items?.slice(0, 3).map(item => `â€¢ ${item.name}`).join('<br>')}
                                    ${phase.items?.length > 3 ? `<br>... and ${phase.items.length - 3} more items` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    ${transcriptSection}

                    <div style="margin-top: 20px; padding: 12px 16px; background: rgba(${appendMode ? '76, 175, 80' : '255, 159, 67'}, 0.1); border: 1px solid rgba(${appendMode ? '76, 175, 80' : '255, 159, 67'}, 0.3); border-radius: 6px;">
                        <div style="color: ${appendMode ? '#4caf50' : '#ff9f43'}; font-weight: 600; margin-bottom: 4px;">${appendMode ? 'â• Append Mode' : 'âš ï¸ Replace Mode'}</div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            ${appendMode ?
                                'This will add the analyzed content to your existing tree. Phases will be merged or added.' :
                                'Importing will replace your current project. Your current project will be saved as a backup first.'}
                        </div>
                    </div>
                </div>
            `;

            // Create buttons directly with event listeners attached
            const modalFooter = document.querySelector('#modal .modal-footer');
            if (!modalFooter) {
                console.error('âŒ Modal footer not found!');
                alert('Error: Modal footer not found. Please refresh the page.');
                return;
            }

            // Clear existing content
            modalFooter.innerHTML = '';

            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => {
                console.log('ğŸš« Import cancelled');
                modal.style.display = 'none';
            };

            // Create import button
            const importBtn = document.createElement('button');
            importBtn.className = 'btn btn-primary';
            importBtn.style.cssText = 'background: linear-gradient(135deg, #4caf50, #00a67d);';
            importBtn.textContent = appendMode ? 'â• Append to Tree' : 'ğŸ“¥ Import to TreeListy';
            importBtn.onclick = () => {
                console.log('ğŸ”„ Import button clicked!', { hasTreeData: !!treeData, hasPattern: !!selectedPattern, appendMode });
                try {
                    importAnalyzedTree(treeData, selectedPattern, appendMode);
                    modal.style.display = 'none';
                } catch (error) {
                    console.error('âŒ Import failed:', error);
                    alert('Import failed: ' + error.message);
                }
            };

            // Add buttons to footer
            modalFooter.appendChild(cancelBtn);
            modalFooter.appendChild(importBtn);

            console.log('âœ… Preview modal ready with import button');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 319: SEMANTIC DEDUPLICATION FOR APPEND MODE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Calculate semantic similarity between two items
         * Uses word overlap with TF-IDF-like weighting
         * @returns {number} Similarity score 0-1
         */
        function calculateItemSimilarity(existingItem, newItem) {
            // Combine name and description for comparison
            const existingText = `${existingItem.name || ''} ${existingItem.description || ''}`.toLowerCase();
            const newText = `${newItem.name || ''} ${newItem.description || ''}`.toLowerCase();

            // Tokenize and remove stopwords
            const stopwords = new Set(['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
                'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might',
                'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by', 'from', 'as', 'into', 'through', 'during',
                'and', 'or', 'but', 'if', 'then', 'else', 'when', 'where', 'why', 'how', 'all', 'each', 'every',
                'this', 'that', 'these', 'those', 'it', 'its', 'they', 'them', 'their', 'we', 'us', 'our']);

            const tokenize = (text) => text.split(/\W+/).filter(w => w.length > 2 && !stopwords.has(w));

            const existingTokens = new Set(tokenize(existingText));
            const newTokens = new Set(tokenize(newText));

            if (existingTokens.size === 0 || newTokens.size === 0) return 0;

            // Calculate Jaccard similarity
            const intersection = [...newTokens].filter(t => existingTokens.has(t)).length;
            const union = new Set([...existingTokens, ...newTokens]).size;

            return union > 0 ? intersection / union : 0;
        }

        /**
         * Find semantic duplicates in existing items
         * @param {Array} existingItems - Items already in the tree
         * @param {Object} newItem - New item to check
         * @param {number} threshold - Similarity threshold (default 0.6)
         * @returns {Object|null} Matching item if found, null otherwise
         */
        function findSemanticDuplicate(existingItems, newItem, threshold = 0.6) {
            if (!existingItems || existingItems.length === 0) return null;

            let bestMatch = null;
            let bestScore = 0;

            for (const existing of existingItems) {
                const similarity = calculateItemSimilarity(existing, newItem);
                if (similarity > threshold && similarity > bestScore) {
                    bestMatch = existing;
                    bestScore = similarity;
                }
            }

            if (bestMatch) {
                console.log(`ğŸ” Semantic match found: "${newItem.name}" â‰ˆ "${bestMatch.name}" (${(bestScore * 100).toFixed(0)}% similar)`);
            }

            return bestMatch;
        }

        /**
         * Merge new item data into existing item (update, don't duplicate)
         * @param {Object} existing - Existing item to update
         * @param {Object} incoming - New item with potential updates
         */
        function mergeItemUpdates(existing, incoming) {
            // Update description if incoming has more content
            if (incoming.description && incoming.description.length > (existing.description?.length || 0)) {
                existing.description = incoming.description;
            }

            // Merge subtasks/children
            if (incoming.children && incoming.children.length > 0) {
                existing.children = existing.children || [];
                for (const newChild of incoming.children) {
                    const duplicate = findSemanticDuplicate(existing.children, newChild, 0.7);
                    if (!duplicate) {
                        // Add new subtask with proper ID
                        const newId = `subtask-${existing.id}-${existing.children.length}`;
                        existing.children.push({ ...newChild, id: newId });
                    }
                }
            }

            // Update numeric fields if incoming has values
            if (incoming.cost && incoming.cost > 0) existing.cost = incoming.cost;
            if (incoming.dealValue && incoming.dealValue > 0) existing.dealValue = incoming.dealValue;
            if (incoming.storyPoints && incoming.storyPoints > 0) existing.storyPoints = incoming.storyPoints;

            // Mark as updated
            existing.provenance = {
                ...existing.provenance,
                lastUpdated: new Date().toISOString(),
                updateSource: 'append-merge'
            };

            console.log(`âœï¸ Updated existing item: ${existing.name}`);
        }

        // Import analyzed tree into TreeListy
        function importAnalyzedTree(treeData, selectedPattern, appendMode = false) {
            console.log('ğŸ“¥ Starting import...', { treeData, selectedPattern, appendMode });

            // Save state for undo
            saveState(appendMode ? 'Analyze Text: Append' : 'Analyze Text: Import');

            // Backup current project first
            const backup = JSON.stringify(capexTree, null, 2);
            const backupName = `treelisty_backup_${Date.now()}.json`;
            console.log('ğŸ’¾ Current project backed up as:', backupName);

            // Switch to selected pattern (only if not appending)
            if (!appendMode) {
                currentPattern = selectedPattern;
                document.getElementById('pattern-select').value = selectedPattern;
            }

            // BUILD 519: Capture RAG source metadata
            const ragSourceMeta = window._lastImportSourceMetadata;
            const ragMetadata = ragSourceMeta ? {
                sourceType: ragSourceMeta.fileName ? 'pdf' : ragSourceMeta.url ? 'url' : 'text',
                sourceId: ragSourceMeta.fileName || ragSourceMeta.url || 'pasted-text',
                importedAt: new Date().toISOString(),
                ...(ragSourceMeta.fileName && { fileName: ragSourceMeta.fileName, pageCount: ragSourceMeta.pageCount }),
                ...(ragSourceMeta.url && { url: ragSourceMeta.url })
            } : null;

            // Convert analyzed data to TreeListy format
            const newTree = {
                type: 'root',
                id: 'root',
                name: treeData.projectName || 'Analyzed Project',
                icon: 'ğŸŒ²',
                expanded: true,
                hyperedges: [], // Initialize empty hyperedges array to prevent data loss
                // BUILD 519: Add _rag metadata for RAG retrieval
                ...(ragMetadata && { _rag: ragMetadata }),
                children: treeData.phases?.map((phase, phaseIndex) => ({
                    type: 'phase',
                    id: `phase-${phaseIndex}`,
                    phase: phaseIndex,
                    name: phase.name,
                    subtitle: phase.subtitle || PATTERNS[selectedPattern].phaseSubtitles?.[phaseIndex] || '',
                    icon: phase.icon || 'ğŸ“‹',
                    expanded: true,
                    cost: 0,
                    provenance: {
                        source: 'ai-import',
                        timestamp: new Date().toISOString(),
                        modelId: null
                    },
                    // BUILD 519: Propagate _rag metadata to phases
                    ...(ragMetadata && { _rag: { ...ragMetadata, level: 'phase', chunkIndex: phaseIndex } }),
                    items: phase.items?.map((item, itemIndex) => {
                        const itemId = `item-${phaseIndex}-${itemIndex}`;

                        // Build item object with all required fields
                        const itemObj = {
                            type: 'item',
                            id: itemId,
                            name: item.name,
                            description: item.description || '',
                            itemType: item.itemType || '',
                            icon: item.icon || 'ğŸ“„',
                            cost: item.cost || 0,
                            dependencies: item.dependencies || [],
                            notes: item.notes || '',
                            leadTime: item.leadTime || '',
                            alternateSource: item.alternateSource || '',
                            expanded: false,
                            // Pattern-specific fields
                            dealValue: item.dealValue || 0,
                            wordCount: item.wordCount || 0,
                            storyPoints: item.storyPoints || 0,
                            // Provenance stamping (Cognitive Citadel)
                            provenance: {
                                source: 'ai-import',
                                timestamp: new Date().toISOString(),
                                modelId: null
                            },
                            // BUILD 519: Add _rag metadata to items
                            ...(ragMetadata && { _rag: { ...ragMetadata, level: 'item', chunkIndex: phaseIndex * 100 + itemIndex } }),
                            // Add any other fields from AI
                            ...item
                        };

                        // Add subtasks if they exist (3rd level hierarchy)
                        if (item.subtasks && item.subtasks.length > 0) {
                            itemObj.children = item.subtasks.map((subtask, subtaskIndex) => ({
                                type: 'subtask',
                                id: `subtask-${phaseIndex}-${itemIndex}-${subtaskIndex}`,
                                name: subtask.name || subtask,
                                description: subtask.description || '',
                                icon: subtask.icon || 'ğŸ“Œ',
                                notes: subtask.notes || '',
                                dependencies: subtask.dependencies || [],
                                // Provenance stamping (Cognitive Citadel)
                                provenance: {
                                    source: 'ai-import',
                                    timestamp: new Date().toISOString(),
                                    modelId: null
                                },
                                // BUILD 519: Add _rag metadata to subtasks
                                ...(ragMetadata && { _rag: { ...ragMetadata, level: 'subtask', chunkIndex: phaseIndex * 10000 + itemIndex * 100 + subtaskIndex } }),
                                // Pattern-specific fields
                                ...subtask
                            }));
                        }

                        return itemObj;
                    }) || []
                })) || []
            };

            if (appendMode) {
                // Append mode: merge phases and items
                console.log('â• Append mode: merging trees...');

                // Keep existing project name if different
                if (capexTree.name !== newTree.name && capexTree.name !== 'My Project') {
                    // User has a custom name, keep it
                } else {
                    capexTree.name = newTree.name;
                }

                // BUILD 319: Track deduplication stats across all phases
                let totalAdded = 0;
                let totalUpdated = 0;
                let newPhasesAdded = 0;

                // Merge phases
                newTree.children.forEach((newPhase, newPhaseIndex) => {
                    // Find matching phase in existing tree by index or name
                    const existingPhase = capexTree.children?.[newPhaseIndex];

                    if (existingPhase) {
                        // Phase exists - append items to it
                        console.log(`Appending ${newPhase.items?.length || 0} items to existing phase: ${existingPhase.name}`);

                        // Update phase name if it was generic
                        if (existingPhase.name === `Phase ${newPhaseIndex}` && newPhase.name !== `Phase ${newPhaseIndex}`) {
                            existingPhase.name = newPhase.name;
                        }

                        // BUILD 319: Semantic deduplication for append mode
                        // Instead of blindly appending, check for duplicates and merge updates
                        if (newPhase.items && newPhase.items.length > 0) {
                            let addedCount = 0;
                            let updatedCount = 0;

                            for (const newItem of newPhase.items) {
                                // Check for semantic duplicate
                                const duplicate = findSemanticDuplicate(existingPhase.items, newItem, 0.6);

                                if (duplicate) {
                                    // Merge updates into existing item
                                    mergeItemUpdates(duplicate, newItem);
                                    updatedCount++;
                                    totalUpdated++;
                                } else {
                                    // Truly new item - add with proper ID
                                    const currentItemCount = existingPhase.items?.length || 0;
                                    const newId = `item-${newPhaseIndex}-${currentItemCount}`;
                                    const reIdedItem = { ...newItem, id: newId };

                                    existingPhase.items = existingPhase.items || [];
                                    existingPhase.items.push(reIdedItem);
                                    addedCount++;
                                    totalAdded++;
                                }
                            }

                            console.log(`ğŸ“Š Phase "${existingPhase.name}": ${addedCount} added, ${updatedCount} updated`);
                        }
                    } else {
                        // Phase doesn't exist - add it as new
                        console.log(`Adding new phase: ${newPhase.name}`);
                        if (!capexTree.children) capexTree.children = [];

                        // Re-ID the phase
                        newPhase.id = `phase-${capexTree.children.length}`;
                        newPhase.phase = capexTree.children.length;

                        capexTree.children.push(newPhase);
                        newPhasesAdded++;
                        totalAdded += newPhase.items?.length || 0;
                    }
                });

                // BUILD 321: Store transcript analysis data in tree metadata
                if (treeData.extractedContacts?.length > 0) {
                    capexTree.extractedContacts = capexTree.extractedContacts || [];
                    capexTree.extractedContacts.push(...treeData.extractedContacts);
                    console.log(`ğŸ“‡ Stored ${treeData.extractedContacts.length} contacts in tree metadata`);
                }
                if (treeData.researchRequests?.length > 0) {
                    capexTree.researchRequests = capexTree.researchRequests || [];
                    capexTree.researchRequests.push(...treeData.researchRequests);
                    console.log(`ğŸ” Stored ${treeData.researchRequests.length} research requests in tree metadata`);
                }

                // Show success message for append with deduplication stats
                let message = 'âœ… Smart Append Complete!\n\n';
                if (totalAdded > 0) {
                    message += `ğŸ“ ${totalAdded} new items added\n`;
                }
                if (totalUpdated > 0) {
                    message += `ğŸ”„ ${totalUpdated} existing items updated (duplicates merged)\n`;
                }
                if (newPhasesAdded > 0) {
                    message += `ğŸ“ ${newPhasesAdded} new phases created\n`;
                }
                // BUILD 321: Add transcript analysis summary to message
                if (treeData.extractedContacts?.length > 0) {
                    message += `ğŸ“‡ ${treeData.extractedContacts.length} contacts detected\n`;
                }
                if (treeData.researchRequests?.length > 0) {
                    message += `ğŸ” ${treeData.researchRequests.length} research requests captured\n`;
                }
                if (totalAdded === 0 && totalUpdated === 0 && !treeData.extractedContacts?.length && !treeData.researchRequests?.length) {
                    message += 'No new content to add - all items already exist in your tree.';
                }

                alert(message);

            } else {
                // Replace mode: completely replace tree
                console.log('ğŸ”„ Replace mode: replacing tree...');
                capexTree = newTree;

                // Show success message for replace
                const totalItems = treeData.phases?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0;
                const totalSubtasks = treeData.phases?.reduce((sum, p) =>
                    sum + (p.items?.reduce((subSum, item) => subSum + (item.subtasks?.length || 0), 0) || 0), 0) || 0;

                let message = `âœ… Successfully imported!\n\n${treeData.phases?.length || 0} phases and ${totalItems} items`;
                if (totalSubtasks > 0) {
                    message += ` and ${totalSubtasks} subtasks`;
                }
                message += ` have been created.\n\nPattern: ${PATTERNS[selectedPattern].name}`;
                alert(message);
            }

            // Render
            render();

            // Auto-select first item to show detail panel
            // Find the first item in the tree
            let firstItem = null;
            if (capexTree.children && capexTree.children.length > 0) {
                for (const phase of capexTree.children) {
                    if (phase.items && phase.items.length > 0) {
                        firstItem = phase.items[0];
                        break;
                    }
                }
            }

            // Show detail panel for first item if found
            if (firstItem) {
                console.log('ğŸ“‹ Auto-selecting first item for detail panel:', firstItem.name);
                showInfo(firstItem);
            }
        }

        // How to Use button - BUILD 611: Direct load help tree (simplified from iframe)
        document.getElementById('how-to-btn').addEventListener('click', async () => {
            // If already in help mode, do nothing
            if (document.body.classList.contains('help-mode')) {
                showToast('Already viewing help', 'info');
                return;
            }

            // Save current tree to session storage for restore
            try {
                sessionStorage.setItem('treelisty_help_return', JSON.stringify(capexTree));
                sessionStorage.setItem('treelisty_help_history', JSON.stringify(historyStack));
            } catch (e) {
                console.warn('Could not save tree state:', e);
            }

            // Load help tree directly
            try {
                const response = await fetch('help-tree.json');
                if (!response.ok) throw new Error('Failed to fetch help-tree.json');
                const helpTree = await response.json();

                // Normalize and load
                const { tree: normalized } = normalizeTreeStructure(helpTree);
                migrateTree(normalized);

                // Clear and replace capexTree
                Object.keys(capexTree).forEach(k => delete capexTree[k]);
                Object.assign(capexTree, normalized);

                // Clear history stack for help mode
                historyStack.length = 0;

                // Mark help mode
                document.body.classList.add('help-mode');

                // Add back button
                showHelpModeBackButton();

                // Render
                render();
                showToast('ğŸ“– Viewing Help - Click "Back to My Tree" when done', 'success');

            } catch (err) {
                console.error('Failed to load help tree:', err);
                // Fallback to legacy help modal
                showLegacyHelp();
            }
        });

        // BUILD 611: Show floating back button in help mode
        function showHelpModeBackButton() {
            // Remove existing if any
            document.getElementById('help-back-btn')?.remove();

            const backBtn = document.createElement('button');
            backBtn.id = 'help-back-btn';
            backBtn.className = 'help-back-btn';
            backBtn.innerHTML = 'â† Back to My Tree';
            backBtn.onclick = returnFromHelpMode;
            document.body.appendChild(backBtn);
        }

        // BUILD 611: Return from help mode to user's tree
        function returnFromHelpMode() {
            const savedTree = sessionStorage.getItem('treelisty_help_return');
            const savedHistory = sessionStorage.getItem('treelisty_help_history');

            if (savedTree) {
                try {
                    const tree = JSON.parse(savedTree);
                    Object.keys(capexTree).forEach(k => delete capexTree[k]);
                    Object.assign(capexTree, tree);

                    // Restore history stack
                    if (savedHistory) {
                        const history = JSON.parse(savedHistory);
                        historyStack.length = 0;
                        historyStack.push(...history);
                    }

                    // Clean up
                    sessionStorage.removeItem('treelisty_help_return');
                    sessionStorage.removeItem('treelisty_help_history');

                    render();
                    showToast('Welcome back!', 'success');
                } catch (e) {
                    console.error('Failed to restore tree:', e);
                    showToast('Could not restore previous tree', 'error');
                }
            }

            // Remove help mode
            document.body.classList.remove('help-mode');
            document.getElementById('help-back-btn')?.remove();
        }

        // BUILD 610: Legacy help content (kept for fallback if iframe fails)
        // Original inline help content preserved below for reference
        function showLegacyHelp() {
            const modal = document.getElementById('modal');
            document.getElementById('modal-title').textContent = 'ğŸ“– How to Use TreeListy';
            document.querySelector('#modal .modal-footer').innerHTML = `<button class="btn" onclick="document.getElementById('modal').style.display='none'">Close</button>`;
            document.getElementById('modal-body').innerHTML = `
                <div style="padding: 20px; line-height: 1.8;">
                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">ğŸ’¡ What is TreeListy?</h3>
                    <p style="margin-bottom: 20px; font-size: 14px;">
                        <strong>TreeListy</strong> is a universal tool for breaking down any complex project, problem, or process into manageable parts.
                        Structure your work into phases, track dependencies between components, and analyze your entire plan at a glance.
                        Use it for software projects, sales pipelines, academic writing, product roadmaps, AI prompt design, or anything else that benefits from structured thinking! ğŸŒ³âœ¨ğŸ¯
                    </p>

                    <h3 style="color: var(--phase-1); margin-bottom: 16px; font-size: 20px;">ğŸš€ Quick Start</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-1);">
                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>1. Choose Your Pattern</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ Use the Pattern dropdown (top) to select your project type:</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">ğŸ“‹ Generic Project, ğŸ’¼ Sales Pipeline, ğŸ“ Academic Writing, ğŸš€ Product Roadmap</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">ğŸ“š Book Writing, ğŸ§  AI Prompt Design, ğŸ›ï¸ Philosophy, ğŸ’¡ Strategic Planning</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">ğŸ¬ Film Production, ğŸ“§ Email Workflow <em>(NEW!)</em>, ğŸ’¾ File System</p>
                        <p style="font-size: 12px; margin-bottom: 12px; padding-left: 16px;">ğŸŒ³ LifeTree (biographies), ğŸ¨ Custom (your own fields)...and more! (21 specialized patterns total)</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>2. Build Your Tree (3 Ways)</strong></p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">ğŸ§™ AI Wizard (Easiest!)</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Click "ğŸ§™ AI Wizard" button in toolbar</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Describe your project in plain language</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ AI asks strategic questions and builds your tree</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">â€¢ Works for new trees or enhancing existing ones!</p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">ğŸ“„ Analyze Text</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Click "ğŸ“„ Analyze Text" button</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Paste any document (plans, specs, articles)</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Choose Quick Mode (fast) or Deep Mode (thorough)</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">â€¢ Can append to existing trees or replace completely</p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">âœ‹ Manual Creation</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Right-click on any Phase â†’ "Add Item"</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">â€¢ Fill in fields manually with full control</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>3. Use Smart Features</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>AI Review ğŸ”¬</strong> - Click "ğŸ”¬ AI Review" for comprehensive tree analysis</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Smart Suggest ğŸ’¡</strong> - Right-click any field â†’ Choose "âœ¨ AI Suggest" or "ğŸ’¡ Quick Suggest"</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Dependencies</strong> - Edit an item â†’ Check boxes in Dependencies section</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>AI Analysis ğŸ¤–</strong> - Click any item â†’ "AI Analysis" for insights</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Undo</strong> - Click "â†©ï¸ Undo" or press Ctrl+Z (Cmd+Z on Mac)</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>4. Navigate & View</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Expand/Collapse</strong> - Click "â¬‡ï¸ Expand" or "â¬†ï¸ Collapse" buttons</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Click nodes</strong> to expand/collapse individually or view details</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Pan/Zoom</strong> - Use mouse wheel or pan controls</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>5. Export & Share</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ğŸ“ Generate Prompt</strong> - Export as AI-ready prompt (for Claude, GPT, etc.)</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ğŸ“Š Export Excel</strong> - Professional multi-sheet workbook</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ğŸ“¥ Import Excel</strong> - Import Excel files back into TreeListy</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ğŸ’¾ Save/Load</strong> - Save as JSON and reload anytime</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>ğŸ”— Share</strong> - Generate shareable URL</p>
                    </div>

                    <h3 style="color: var(--phase-2); margin-bottom: 16px; font-size: 20px;">ğŸ¤– AI-Powered Features</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-2);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ§™ AI Wizard</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Interactive project building</strong> - AI asks strategic questions<br>
                            â€¢ <strong>Conversational interface</strong> - Just describe what you need<br>
                            â€¢ <strong>Enhance mode</strong> - Add to existing trees without starting over<br>
                            â€¢ <strong>Real-time preview</strong> - Watch your tree build in the side panel<br>
                            â€¢ <strong>Smart Merge protection</strong> - Never loses your existing data<br>
                            â€¢ <strong>Auto-recovery</strong> - Handles errors gracefully
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ“„ Analyze Text + ğŸ§  Semantic Chunking (NEW!)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>ğŸ§  Semantic Chunking</strong> - Auto-segments large documents (5000+ words) using NLP<br>
                            â€¢ <strong>Prevents Hallucinations</strong> - Processes chunks independently instead of all at once<br>
                            â€¢ <strong>Visual Feedback</strong> - Shows chunk distribution with bar chart during analysis<br>
                            â€¢ <strong>Embedding-Based</strong> - Uses OpenAI/Gemini embeddings to detect semantic boundaries<br>
                            â€¢ <strong>Auto-Fallback</strong> - Structural parser (Markdown â†’ paragraphs) if no embedding API<br>
                            â€¢ <strong>Quick Mode</strong> - Fast analysis (1500 tokens per chunk) for straightforward documents<br>
                            â€¢ <strong>Deep Mode</strong> - Extended thinking (8192 tokens per chunk) for complex analysis<br>
                            â€¢ <strong>Append Mode</strong> - Combine multiple document analyses<br>
                            â€¢ <strong>Pattern-specific extraction</strong> - Philosophy extracts premises, Sales extracts deals, etc.<br>
                            â€¢ <strong>Prompt improvement</strong> - AI Prompt pattern turns basic prompts into comprehensive ones
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ”¬ AI Review & Enhance</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Comprehensive tree analysis</strong> - Reviews entire tree for completeness, logic, and flow<br>
                            â€¢ <strong>Pattern-aware review</strong> - Checks alignment with pattern best practices<br>
                            â€¢ <strong>Actionable suggestions</strong> - Get specific recommendations for improvements<br>
                            â€¢ <strong>Gap identification</strong> - Finds missing phases, items, or subtasks<br>
                            â€¢ <strong>Quality assessment</strong> - Identifies redundancies and structural issues
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ’¡ Smart Suggest (Dual Modes)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>âœ¨ AI Suggest</strong> - Context-aware suggestions with pattern expertise (Philosophy prof, Sales strategist, etc.)<br>
                            â€¢ <strong>ğŸ’¡ Quick Suggest</strong> - Instant static templates for common fields<br>
                            â€¢ <strong>Pattern intelligence</strong> - Philosophy gets premises/objections, Sales gets follow-ups, Film gets Sora/Veo prompts<br>
                            â€¢ <strong>Right-click any field</strong> - Choose your mode and watch AI fill in intelligent suggestions<br>
                            â€¢ <strong>Fallback protection</strong> - Auto-switches to Quick mode if AI fails
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ“ Generate Prompt</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Export as AI prompt</strong> - Use with Claude, GPT-4, or any LLM<br>
                            â€¢ <strong>Pattern-aware formatting</strong> - Adapts to your project type<br>
                            â€¢ <strong>Executable prompts</strong> - AI Prompt pattern creates paste-ready prompts (not meta-docs)<br>
                            â€¢ <strong>Copy to clipboard</strong> - One-click copy for easy sharing<br>
                            â€¢ <strong>Complete context</strong> - Includes all phases, items, and subtasks
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ¤– AI Analysis (Per Item)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Risk assessments</strong> - Identify potential issues<br>
                            â€¢ <strong>Cost optimization</strong> - Compare with similar items<br>
                            â€¢ <strong>Strategic insights</strong> - Powered by your chosen AI model<br>
                            â€¢ <strong>Pattern-specific analysis</strong> - Tailored to your project type
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸŒ² TreeBeard Chat (AI Assistant)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Context-aware assistant</strong> - Click ğŸŒ² button in sidebar<br>
                            â€¢ <strong>Wiser mode</strong> - Toggle for full tree context in responses<br>
                            â€¢ <strong>Ask anything</strong> - Questions about your tree, pattern guidance, analysis<br>
                            â€¢ <strong>Quick actions</strong> - Get suggestions, explore related concepts
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ“ Smart Append & Deduplication</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Meeting transcripts</strong> - Auto-detect transcript format, extract contacts/research<br>
                            â€¢ <strong>Semantic deduplication</strong> - 60% Jaccard threshold prevents duplicates<br>
                            â€¢ <strong>Smart merge</strong> - Additive updates only, never loses your data<br>
                            â€¢ <strong>Multi-document append</strong> - Build trees from multiple sources
                        </p>
                    </div>

                    <h3 style="color: var(--phase-1); margin-bottom: 16px; font-size: 20px;">ğŸ”‘ AI Providers & API Keys</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-1);">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy supports multiple AI providers!</strong> Choose the model that fits your needs.
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ¤– Available Providers</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Anthropic Claude</strong> - Haiku 3/3.5 (fast, cheap) & Sonnet 4 (powerful, extended thinking)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Google Gemini</strong> - Flash 2.0 (fast) & Pro 2.5 (thorough)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>OpenAI ChatGPT</strong> - GPT-4o mini (fast) & GPT-4o (powerful)</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ” API Key Setup</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Click <strong>ğŸ”‘ Set API Key</strong> button in header</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Enter your API key from Anthropic, Google, or OpenAI</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Keys are stored in <strong>localStorage</strong> (persist across sessions)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ Get keys at: console.anthropic.com, aistudio.google.com, or platform.openai.com</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">âš¡ Rate Limits & Costs</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Server API key (default)</strong> - 200 requests/hour, 8192 max tokens per request</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Your API key</strong> - Unlimited requests (you pay for usage)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Extended Thinking</strong> - Deep Mode uses 5000 token thinking budget + response (Sonnet 4 only)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Tip</strong> - Use your own key to bypass rate limits and get faster responses</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ§  Extended Thinking Mode</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Available when using <strong>Sonnet 4</strong> in <strong>Deep Mode</strong><br>
                            â€¢ AI thinks for up to 5000 tokens before responding<br>
                            â€¢ Better reasoning, fewer errors, more comprehensive analysis<br>
                            â€¢ Ideal for complex trees, AI Review, and prompt improvement<br>
                            â€¢ Costs more but delivers significantly higher quality
                        </p>
                    </div>

                    <h3 style="color: var(--phase-3); margin-bottom: 16px; font-size: 20px;">ğŸ“Š Presentations & Sharing</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-3);">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy is perfect for investor meetings and stakeholder presentations!</strong>
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ¯ Visual Impact</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Use "â¬‡ï¸ Expand" button to show complete roadmap<br>
                            â€¢ Dependency arrows show critical path in real-time<br>
                            â€¢ Phase colors guide audience through timeline<br>
                            â€¢ Click individual nodes to drill down into details
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ“Š Excel Import & Export</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Export:</strong> Professional 4-sheet workbook (Executive Summary, Details, Dependencies, PM Tracking)<br>
                            â€¢ <strong>Import:</strong> Load Excel files back into TreeListy - edit in Excel, import changes<br>
                            â€¢ <strong>Append Mode:</strong> Import multiple Excel files into one tree<br>
                            â€¢ <strong>Pattern Detection:</strong> Automatically detects project type from Excel structure<br>
                            â€¢ Perfect for board meetings, investor due diligence, and team collaboration
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ’¼ Pattern-Based Presentations</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Sales Pipeline</strong> - Show deal flow and revenue forecast<br>
                            â€¢ <strong>Product Roadmap</strong> - Display feature timeline and engineering estimates<br>
                            â€¢ <strong>AI Prompt Design</strong> - Present prompt engineering workflows<br>
                            â€¢ <strong>Strategic Planning</strong> - Show KPIs and strategic initiatives
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ¤ Pro Tips</p>
                        <p style="font-size: 13px; margin-bottom: 8px; font-style: italic; color: var(--treeplex-primary);">
                            â€¢ <strong>Excel Workflow:</strong> Export â†’ Edit in Excel with team â†’ Import back to TreeListy<br>
                            â€¢ Use AI Wizard before meetings to quickly build comprehensive plans<br>
                            â€¢ Generate Prompt to share project structure with AI assistants<br>
                            â€¢ Import multiple Excel files using Append Mode to combine analyses<br>
                            â€¢ Use Undo (Ctrl+Z) to safely experiment during live demos
                        </p>
                    </div>

                    <h3 style="color: #10b981; margin-bottom: 16px; font-size: 20px;">ğŸ‘¥ Collaboration ("Chess by Mail")</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid #10b981;">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>Collaborate with others asynchronously or in real-time!</strong> Perfect for team projects, debates, or teaching.
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ’¬ Collaboration Comments</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Edit any node â†’ Find "Collaboration" section<br>
                            â€¢ Leave notes for collaborators (e.g., "@Alex - what do you think?")<br>
                            â€¢ ğŸ’¬ icon appears on nodes with comments<br>
                            â€¢ Hover to preview the comment
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ‘¤ Contributor Tags</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Tag who made each edit (click team member badge or type custom name)<br>
                            â€¢ Quick-select buttons for common collaborators<br>
                            â€¢ ğŸ‘¤ badge shows on nodes in Tree and Canvas views<br>
                            â€¢ Timestamps automatically tracked
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ‘ï¸ Watch Mode (Live Sync)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Click "ğŸ‘ï¸ Watch Mode" in sidebar<br>
                            â€¢ Enter your name and select a shared file<br>
                            â€¢ Choose poll interval (5s for active collab, 30s for async)<br>
                            â€¢ See changes from collaborators automatically!<br>
                            â€¢ Your saves are detected and won't reload
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">â˜ï¸ Google Drive Links</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Save tree to Google Drive â†’ Get shareable link<br>
                            â€¢ Email: <code>https://treelisty.netlify.app?gdrive=FILE_ID</code><br>
                            â€¢ Recipient clicks â†’ TreeListy opens with your tree!<br>
                            â€¢ Use <code>?watch=URL</code> to auto-open Watch Mode
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ”„ Async Workflow</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            1. Save to shared folder (OneDrive, Google Drive, Dropbox)<br>
                            2. Email the link to your collaborator<br>
                            3. They edit, set their contributor name, save<br>
                            4. You reload â†’ see their badges and comments<br>
                            5. Like chess by mail, but for ideas!
                        </p>
                    </div>

                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">âŒ¨ï¸ Keyboard Shortcuts & Tips</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--treeplex-primary);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Keyboard Shortcuts</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Ctrl+Z / Cmd+Z</strong> - Undo last action (keeps 50 states in history)<br>
                            â€¢ <strong>Ctrl+/ / Cmd+/</strong> - Toggle TreeBeard chat panel<br>
                            â€¢ Works everywhere except when typing in text fields
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Navigation</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Click nodes</strong> to expand/collapse or view details<br>
                            â€¢ <strong>Right-click anywhere</strong> for context menus<br>
                            â€¢ <strong>â¬‡ï¸ Expand / â¬†ï¸ Collapse buttons</strong> - Control all phases at once<br>
                            â€¢ <strong>Mouse wheel</strong> - Zoom in/out<br>
                            â€¢ <strong>Pan controls</strong> - Navigate large trees
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Visual Cues</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">
                            â€¢ <strong>Indented items</strong> - Depend on items above them<br>
                            â€¢ <strong>Dependency arrows</strong> - Show cross-phase relationships<br>
                            â€¢ <strong>Phase colors</strong> - Guide through timeline (green â†’ blue â†’ orange â†’ purple)<br>
                            â€¢ <strong>Hover effects</strong> - 3D pop effects on items<br>
                            â€¢ <strong>Green pulse</strong> - Newly added nodes (during Chat Builder)<br>
                            â€¢ <strong>Yellow pulse</strong> - Modified nodes (during Chat Builder)
                        </p>
                    </div>

                    <h3 style="color: #f59e0b; margin-bottom: 16px; font-size: 20px;">ğŸ–±ï¸ View Controls (Tree, Canvas, 3D, Gantt, Calendar)</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid #f59e0b;">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy has five views:</strong> Tree View (hierarchical list), Canvas View (node diagram), 3D View (spatial navigator), Gantt View (scheduling timeline), and Calendar View (monthly events). Each has different controls!
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸŒ² Tree View (Default)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Left Click</strong> - Expand/collapse node, or select to view details</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Right Click</strong> - Context menu (Add, Edit, Delete, AI options)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Mouse Wheel</strong> - Scroll up/down through the tree</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Drag & Drop</strong> - Not supported (use Edit to move items)</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ¨ Canvas View (Diagram)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Left Click</strong> - Select node (shows details in right panel)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Left Drag on Node</strong> - Move the node around the canvas</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Right Click</strong> - Context menu (Edit, Share Branch, AI Analysis)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Mouse Wheel</strong> - Zoom in/out</p>
                            <p style="font-size: 13px; margin-bottom: 4px; color: #f59e0b;"><strong>â­ Space + Drag</strong> - Pan the entire canvas (Mac-friendly!)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Middle Mouse + Drag</strong> - Pan (alternative for mice with scroll wheel click)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Ctrl/Cmd + Click</strong> - Multi-select nodes</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Left Drag on Empty Space</strong> - Box select multiple nodes</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸŒ 3D View (Spatial Navigator)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Left Drag</strong> - Orbit/rotate the view</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Mouse Wheel</strong> - Zoom in/out</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Right Drag</strong> - Pan the camera</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Hover Nodes</strong> - Highlight and see labels</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Click Node</strong> - Select and view details</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ“Š Gantt View (Project Scheduling)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Professional timeline</strong> - Frappe Gantt integration for project scheduling</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Zoom levels</strong> - Day, Week, Month, Year views (buttons in toolbar)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Drag to reschedule</strong> - Drag task bars to change dates</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Critical Path</strong> - Toggle button highlights 0-slack tasks in red</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Minimap</strong> - Overview navigation for large projects</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Click task</strong> - View/edit task details in right panel</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ“… Calendar View (Monthly Events)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Monthly display</strong> - See all events on a calendar grid</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Date-based nodes</strong> - Nodes with dates appear on their days</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Click event</strong> - Navigate to the source node</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Month navigation</strong> - Arrow buttons to browse months</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ”„ Switching Views</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Click the <strong>view dropdown</strong> in the toolbar to switch between views<br>
                            â€¢ <strong>Tree</strong> - Best for detailed editing and reading<br>
                            â€¢ <strong>Canvas</strong> - Best for seeing relationships and node diagrams<br>
                            â€¢ <strong>3D</strong> - Best for exploring large trees spatially<br>
                            â€¢ <strong>Gantt</strong> - Best for scheduling and project timelines<br>
                            â€¢ <strong>Calendar</strong> - Best for date-based event planning
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ’¡ Canvas Tips</p>
                        <p style="font-size: 13px; margin-bottom: 12px; font-style: italic; color: #f59e0b;">
                            â€¢ <strong>No middle mouse?</strong> Hold <strong>Space</strong> + drag to pan (like Photoshop/Figma!)<br>
                            â€¢ <strong>Lost on a big canvas?</strong> Click "Fit" button to see all nodes<br>
                            â€¢ <strong>Create hyperedges:</strong> Select multiple nodes â†’ Click "Edges" â†’ Name your connection
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ”— Smart Hyperedges (NEW!)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Auto-Suggestions</strong> - Open Hyperedges panel to see suggested groupings</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Query Builder</strong> - Click ğŸ” Query to create hyperedges by filter</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Live Aggregates</strong> - See totals ($2.3M â€¢ 67% â€¢ 4 nodes) on each hyperedge</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>TreeBeard Queries</strong> - Ask "show items over $500K" to find matches</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Pattern-Aware</strong> - CAPEX shows cost tiers, Philosophy shows philosophers</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ Mac Users & Trackpads</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 0;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Cmd</strong> works everywhere <strong>Ctrl</strong> is mentioned (Cmd+Z undo, Cmd+Click multi-select)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Space + Drag</strong> - Pan canvas without a middle mouse button</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Two-finger scroll</strong> - Zoom in/out on canvas</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Two-finger tap</strong> - Right-click context menu</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Pinch gesture</strong> - Works for zoom in Canvas and 3D views</p>
                        </div>
                    </div>

                    <h3 style="color: #f97316; margin-bottom: 16px; font-size: 20px;">ğŸ”¥ Firebase Live Sync + Voice Chat</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid #f97316;">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>Real-time collaboration</strong> - Multiple users can edit the same tree simultaneously!
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸš€ How to Start</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">1. Click the <strong>ğŸ”„ Live Sync</strong> button (orange, in toolbar)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">2. Click <strong>"Create Live Sync Room"</strong> to start a session</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">3. Share the <strong>6-character Room ID</strong> with collaborators</p>
                            <p style="font-size: 13px; margin-bottom: 0;">4. They enter the Room ID and click <strong>"Join"</strong></p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">âœ¨ Features</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>No sign-in required</strong> - Anonymous authentication</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Instant sync</strong> - All changes sync immediately</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Delete sync</strong> - Deletions sync to all collaborators instantly</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Nested subtasks</strong> - Full support for deeply nested structures</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Auto-save</strong> - Synced changes are saved to localStorage</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ™ï¸ Voice Chat</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Click the <strong>ğŸ™ï¸ Voice</strong> button in the chat panel</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Opens <strong>Jitsi Meet</strong> in a popup window</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>No account required</strong> - just click and talk!</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ Hands-free collaboration while building your tree</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ‘¥ Presence & Chat</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ See who's online with <strong>presence badges</strong></p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Floating chat box</strong> - draggable, minimizable</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ Real-time messaging during collaboration</p>
                        </div>

                        <p style="font-size: 13px; font-style: italic; color: #f97316;">
                            ğŸ’¡ Tip: Works alongside Google Drive sharing for async collaboration!
                        </p>
                    </div>

                    <h3 style="color: #8b5cf6; margin-bottom: 16px; font-size: 20px;">ğŸ“– Reader Navigation & TTS</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid #8b5cf6;">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>Navigate through your tree like reading a book!</strong> Sequential reading with text-to-speech support.
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">â¬…ï¸ â¡ï¸ Reader Navigation</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Prev/Next buttons</strong> - Sequential navigation through all nodes</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Position indicator</strong> - Shows "3 of 12" to track progress</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Group iteration</strong> - Navigate hyperedge members or dependency chains</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Auto-scroll</strong> - Tree view scrolls to keep current node visible</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ”Š Text-to-Speech (TTS)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Read Aloud</strong> - Click ğŸ”Š button to hear node descriptions</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Auto-Play mode</strong> - Toggle to read through entire tree sequentially</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Web Speech API</strong> - Uses browser's built-in voice synthesis</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Stop/Resume</strong> - Control playback at any time</p>
                        </div>

                        <p style="font-size: 13px; font-style: italic; color: #8b5cf6;">
                            ğŸ’¡ Tip: Great for reviewing long documents or accessibility!
                        </p>
                    </div>

                    <h3 style="color: #06b6d4; margin-bottom: 16px; font-size: 20px;">ğŸ“± Mobile Features</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid #06b6d4;">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy works great on mobile!</strong> All views are optimized for touch interaction.
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ‘† Touch Gestures</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Pinch to zoom</strong> - Canvas, 3D, and Gantt views support pinch zoom</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Swipe navigation</strong> - Edge swipes navigate between panels</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Tap to select</strong> - Tap nodes to view details</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Long-press</strong> - Opens context menu</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ¨ Mobile Canvas View</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Scrollable toolbar</strong> - Compact toolbar with horizontal scroll</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Minimap</strong> - 100x75px overview positioned bottom-left</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Bottom-sheet menu</strong> - Touch-friendly context menu</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Full functionality</strong> - All Canvas features work on mobile</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ™ï¸ Voice Input</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Import modal</strong> - Microphone button for voice-to-text input</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Speech recognition</strong> - Speak your content instead of typing</p>
                        </div>

                        <p style="font-size: 13px; font-style: italic; color: #06b6d4;">
                            ğŸ’¡ Tip: All 5 views (Tree, Canvas, 3D, Gantt, Calendar) work on mobile!
                        </p>
                    </div>

                    <h3 style="color: var(--phase-4); margin-bottom: 16px; font-size: 20px;">ğŸ”§ Advanced Features</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; border-left: 3px solid var(--phase-4);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ­ Pattern System (21 Built-in)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Generic Project</strong> - Universal template for any project</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Sales Pipeline</strong> - Deals, contacts, follow-ups, close dates</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Academic Writing</strong> - Thesis, arguments, citations, evidence</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Product Roadmap</strong> - Features, story points, user impact, technical specs</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Book Writing</strong> - Chapters, scenes, character arcs, plot points</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Event Planning</strong> - Budget, vendors, deadlines, guest counts</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Fitness Program</strong> - Sets, reps, intensity, form cues</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Strategic Plan</strong> - Pillars, initiatives, KPIs, risk levels</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Course Design</strong> - Modules, lessons, activities, assessments</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Film/Video Production</strong> - Sora/Veo prompts, camera angles, lighting</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Philosophy</strong> - Arguments, premises, objections, textual references</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Prompt Engineering</strong> - System prompts, few-shot examples, chain-of-thought</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Family Tree</strong> - Genealogy, birth/death dates, DNA info</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Dialogue & Rhetoric</strong> - Rhetorical devices, fallacies, counterarguments</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>File System</strong> - Files, folders, sizes, dates, permissions</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Email Workflow</strong> - Gmail threads, recipients, labels, analysis</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Free Speech</strong> - Constitutional analysis, legal precedent, public interest</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ›¡ï¸ Smart Merge Data Protection</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Never loses your data</strong> - AI updates preserve all existing content</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Fuzzy name matching</strong> - Finds related items even if names differ slightly</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Additive updates only</strong> - AI can add or update, but never deletes</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Transparent logging</strong> - Console shows exactly what was merged, added, or preserved</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Safe experimentation</strong> - Try AI features without fear of data loss</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ğŸ¯ Pattern-Specific AI Behavior</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">Each pattern has specialized AI intelligence:</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Philosophy</strong> - AI suggests premises, objections, supporting evidence, textual citations</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Sales</strong> - AI suggests follow-up actions, next steps, competitive positioning, deal strategies</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Film</strong> - AI generates production-ready Sora/Veo prompts with camera angles, lighting, blocking</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>AI Prompt</strong> - AI transforms basic prompts into comprehensive prompts with system/user/examples</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Roadmap</strong> - AI suggests implementation tasks, technical specs, acceptance criteria, story points</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Book</strong> - AI suggests scenes, character moments, plot developments, narrative arcs</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">âš™ï¸ Other Advanced Features</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Dependencies</strong> - Track relationships between items across phases with visual arrows</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>PM Tracking</strong> - Status, assignees, dates, progress, priorities, blocking issues</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Context Notes</strong> - Add project background for better AI suggestions and team alignment</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Shareable URLs</strong> - Compress and share entire projects via URL (base64 encoding)</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Auto-save</strong> - Your work is preserved in browser localStorage automatically</p>
                        <p style="font-size: 13px;">â€¢ <strong>Custom Patterns</strong> - Create your own pattern with custom fields, labels, and hierarchies</p>
                    </div>

                    <div style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.1), rgba(59, 143, 204, 0.1)); border-radius: 8px; text-align: center;">
                        <p style="font-size: 14px; font-weight: 600; color: var(--treeplex-primary); margin-bottom: 8px;">
                            ğŸš€ Ready to build something amazing?
                        </p>
                        <p style="font-size: 13px; opacity: 0.9; margin-bottom: 12px;">
                            Start with the AI Wizard for instant guidance, or choose a pattern and dive in!
                        </p>
                        <p style="font-size: 12px; opacity: 0.7;">
                            ğŸ§™ Pro tip: Try "ğŸ§™ AI Wizard" â†’ describe your project â†’ watch the magic happen
                        </p>
                    </div>

                    <!-- BUILD 358: Check for Updates button + BUILD 441: About button -->
                    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 12px; opacity: 0.6;">
                            v${window.TREELISTY_VERSION?.major || '2.17.0'} â€¢ Build ${window.TREELISTY_VERSION?.build || '???'}
                        </span>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="showAboutModal();" style="
                                padding: 8px 16px;
                                background: var(--bg);
                                border: 1px solid var(--border);
                                border-radius: 6px;
                                color: var(--text-primary);
                                font-size: 12px;
                                cursor: pointer;
                                transition: all 0.2s;
                            " onmouseover="this.style.background='var(--treeplex-primary)'; this.style.color='white';" onmouseout="this.style.background='var(--bg)'; this.style.color='var(--text-primary)';">
                                â„¹ï¸ About
                            </button>
                            <button onclick="window.checkForUpdates(true).then(r => { this.textContent = r === 'latest' ? 'âœ… Up to date!' : r === 'update' ? 'ğŸš€ Update available!' : 'âš ï¸ Check console'; setTimeout(() => { this.textContent='ğŸ”„ Check for Updates'; this.disabled=false; }, 3000); }); this.textContent='Checking...'; this.disabled=true;" style="
                                padding: 8px 16px;
                                background: var(--bg);
                                border: 1px solid var(--border);
                                border-radius: 6px;
                                color: var(--text-primary);
                                font-size: 12px;
                                cursor: pointer;
                                transition: all 0.2s;
                            " onmouseover="this.style.background='var(--treeplex-primary)'; this.style.color='white';" onmouseout="this.style.background='var(--bg)'; this.style.color='var(--text-primary)';">
                                ğŸ”„ Check for Updates
                            </button>
                        </div>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
        }

        // BUILD 441: About Modal - minimalist attribution
        // BUILD 443: Updated with logo image
        function showAboutModal() {
            const modal = document.getElementById('modal');
            document.getElementById('modal-title').textContent = 'About TreeListy';
            document.getElementById('modal-body').innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <img src="./assets/treelisty-icon2.png" alt="TreeListy" style="height: 80px; width: 80px; margin-bottom: 16px;">
                    <h2 style="font-size: 28px; font-weight: 700; color: var(--text-primary); margin-bottom: 4px;">TreeListy</h2>
                    <p style="font-size: 14px; color: var(--text-secondary); margin-bottom: 24px;">
                        v${window.TREELISTY_VERSION?.major || '2.19.0'} â€¢ Build ${window.TREELISTY_VERSION?.build || '???'}
                    </p>
                    <p style="font-size: 16px; color: var(--text-primary); margin-bottom: 8px;">
                        Â© 2024-2025 Garnet Brown
                    </p>
                    <p style="font-size: 14px; color: var(--text-secondary); margin-bottom: 24px;">(geej)</p>
                    <a href="https://github.com/Prairie2Cloud/treelisty" target="_blank" rel="noopener" style="
                        font-size: 13px;
                        color: var(--treeplex-primary);
                        text-decoration: none;
                    " onmouseover="this.style.textDecoration='underline';" onmouseout="this.style.textDecoration='none';">
                        github.com/Prairie2Cloud
                    </a>
                </div>
            `;
            modal.style.display = 'flex';
        }

        // =============================================================================
        // EXCEL EXPORT - Professional Multi-Sheet Workbook for Investors
        // =============================================================================

        async function exportToExcel() {
            // Lazy load XLSX library
            try {
                await loadLibrary('xlsx');
            } catch (e) {
                showToast('Failed to load Excel library. Please try again.', 'error');
                console.error('XLSX load error:', e);
                return;
            }

            // Create a new workbook
            const wb = XLSX.utils.book_new();

            // Collect all items AND subtasks from the tree (proper phase structure)
            const allItems = [];
            const allTasks = []; // Subtasks for separate PM sheet (recursive)

            // RECURSIVE function to collect nested subtasks from multiple data shapes
            function collectSubtasks(parentItem, parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel = 0) {
                const subtaskCandidates = [];
                const seenIds = new Set();

                if (Array.isArray(parentItem.subItems) && parentItem.subItems.length > 0) {
                    parentItem.subItems.forEach((subtask, index) => {
                        const id = subtask.id || `${parentItem.id || 'item'}-sub-${index}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            subtaskCandidates.push({ ...subtask, id });
                        }
                    });
                }

                if (Array.isArray(parentItem.children) && parentItem.children.length > 0) {
                    parentItem.children
                        .filter(child => child.type === 'subtask')
                        .forEach((child, index) => {
                            const id = child.id || `${parentItem.id || 'item'}-child-${index}`;
                            if (!seenIds.has(id)) {
                                seenIds.add(id);
                                subtaskCandidates.push({ ...child, id });
                            }
                        });
                }

                if (Array.isArray(parentItem.subtasks) && parentItem.subtasks.length > 0) {
                    parentItem.subtasks.forEach((entry, index) => {
                        const normalized = typeof entry === 'string'
                            ? { name: entry }
                            : { ...entry };
                        const id = normalized.id || `${parentItem.id || 'item'}-simple-${index}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            subtaskCandidates.push({
                                type: normalized.type || 'subtask',
                                ...normalized,
                                id
                            });
                        }
                    });
                }

                if (subtaskCandidates.length === 0) {
                    return;
                }

                subtaskCandidates.forEach(subtask => {
                    const indent = '  '.repeat(nestLevel); // Indentation for hierarchy
                    allTasks.push({
                        ...subtask,
                        parentItem: parentName,
                        parentItemId: parentItem.id,
                        phaseName: phaseName,
                        phaseSubtitle: phaseSubtitle,
                        phaseNumber: phaseNumber,
                        nestLevel: nestLevel,
                        taskName: indent + (subtask.name || 'Subtask')
                    });

                    // RECURSIVELY collect nested subtasks
                    collectSubtasks(subtask, subtask.name || parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel + 1);
                });
            }

            function collectItems(node) {
                // Collect items from this phase node
                if (node.items && Array.isArray(node.items)) {
                    node.items.forEach(item => {
                        allItems.push({
                            ...item,
                            phaseName: node.name || 'Unknown Phase',
                            phaseSubtitle: node.subtitle || '',
                            phaseNumber: node.phase || '0'
                        });

                        // Collect subtasks recursively for PM tracking
                        collectSubtasks(item, item.name, node.name || 'Unknown Phase', node.subtitle || '', node.phase || '0', 0);
                    });
                }

                // Recursively collect from child phases
                if (node.children && Array.isArray(node.children)) {
                    node.children.forEach(child => {
                        collectItems(child);
                    });
                }
            }
            collectItems(capexTree);

            // Calculate totals
            const totalCost = allItems.reduce((sum, item) => sum + (item.cost || 0), 0);

            // Group by phase dynamically
            const phaseBreakdown = {};
            allItems.forEach(item => {
                const phaseKey = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;
                if (!phaseBreakdown[phaseKey]) {
                    phaseBreakdown[phaseKey] = { total: 0, count: 0, phaseNumber: item.phaseNumber };
                }
                phaseBreakdown[phaseKey].total += (item.cost || 0);
                phaseBreakdown[phaseKey].count++;
            });

            // =================================================================
            // SHEET 1: EXECUTIVE SUMMARY
            // =================================================================
            const resolvePatternName = () => {
                if (capexTree.pattern) {
                    const patternKey = getPatternKey(capexTree.pattern);
                    if (patternKey) {
                        if (patternKey === 'custom') {
                            const labels = capexTree.pattern.labels || {};
                            return labels.root ? `Custom (${labels.root})` : 'Custom Pattern';
                        }
                        if (PATTERNS[patternKey]) {
                            return PATTERNS[patternKey].name;
                        }
                    }
                }
                if (PATTERNS[currentPattern]) {
                    return PATTERNS[currentPattern].name;
                }
                return 'Generic Project';
            };

            const patternNameForSummary = resolvePatternName();

            const summaryData = [
                ['TREEPLEXITY - PROJECT SUMMARY'],
                ['by geej', '', '', ''],
                [],
                ['Project:', capexTree.name || 'Project Plan'],
                ['Pattern:', patternNameForSummary],
                ['Total Cost:', `$${(totalCost / 1000000).toFixed(2)}M`],
                ['Items Count:', allItems.length],
                ['Report Date:', new Date().toLocaleDateString()],
                [],
                ['INVESTMENT BREAKDOWN BY PHASE'],
                [],
                ['Phase', 'Investment', 'Percentage', 'Items']
            ];

            // Add phase rows dynamically (sorted by phase number)
            Object.entries(phaseBreakdown)
                .sort((a, b) => (a[1].phaseNumber || 0) - (b[1].phaseNumber || 0))
                .forEach(([phaseName, data]) => {
                    const phasePercentage = totalCost > 0 ? `${((data.total / totalCost) * 100).toFixed(1)}%` : '0%';
                    summaryData.push([
                        phaseName,
                        `$${(data.total / 1000000).toFixed(2)}M`,
                        phasePercentage,
                        data.count
                    ]);
                });

            // Add total row
            summaryData.push(['TOTAL', `$${(totalCost / 1000000).toFixed(2)}M`, totalCost > 0 ? '100.0%' : '0%', allItems.length]);

            // Add key metrics
            summaryData.push([]);
            summaryData.push(['KEY METRICS']);
            summaryData.push([]);
            summaryData.push(['Metric', 'Value']);
            summaryData.push(['Average Item Cost', allItems.length > 0 ? `$${(totalCost / allItems.length / 1000).toFixed(0)}K` : '$0']);
            summaryData.push(['Largest Single Item', allItems.length > 0 ? `$${(Math.max(...allItems.map(i => i.cost || 0)) / 1000000).toFixed(2)}M` : '$0']);
            summaryData.push(['Items with Dependencies', allItems.filter(i => i.dependencies && i.dependencies.length > 0).length]);
            summaryData.push(['Items with Alternate Sources', allItems.filter(i => i.alternateSource).length]);

            const ws_summary = XLSX.utils.aoa_to_sheet(summaryData);

            // Set column widths
            ws_summary['!cols'] = [
                { wch: 30 },  // Column A
                { wch: 20 },  // Column B
                { wch: 15 },  // Column C
                { wch: 15 }   // Column D
            ];

            // Add to workbook
            XLSX.utils.book_append_sheet(wb, ws_summary, 'ğŸ“Š Executive Summary');

            // =================================================================
            // SHEET 2: DETAILED ITEMS (PATTERN-AWARE)
            // =================================================================

            // Get current pattern for dynamic columns
            const currentPatternDef = PATTERNS[currentPattern];
            const patternFields = currentPatternDef.fields || {};

            // Build dynamic column headers
            const baseColumns = ['Item Name', 'Phase', 'Type', 'Description'];
            const patternColumns = [];
            const patternFieldKeys = []; // Track field keys for data extraction

            // Add all pattern-specific fields dynamically
            Object.keys(patternFields).forEach(fieldKey => {
                const fieldConfig = patternFields[fieldKey];
                // Skip non-field properties
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }
                if (fieldConfig.label) {
                    patternColumns.push(fieldConfig.label);
                    patternFieldKeys.push(fieldKey);
                }
            });

            const endColumns = ['Dependencies', 'Notes'];
            const allColumns = [...baseColumns, ...patternColumns, ...endColumns];

            // Build column widths dynamically
            const columnWidths = [
                { wch: 30 },  // Item Name
                { wch: 25 },  // Phase
                { wch: 20 },  // Type
                { wch: 40 }   // Description
            ];

            // Add widths for pattern columns
            patternColumns.forEach(col => {
                // Determine width based on field type
                if (col.includes('Date')) {
                    columnWidths.push({ wch: 12 });
                } else if (col.includes('$') || col.includes('Cost') || col.includes('Value')) {
                    columnWidths.push({ wch: 15 });
                } else if (col.includes('%') || col.includes('Points')) {
                    columnWidths.push({ wch: 10 });
                } else if (col.length > 20) {
                    columnWidths.push({ wch: 35 }); // Long labels get more space
                } else {
                    columnWidths.push({ wch: 20 }); // Default width
                }
            });

            columnWidths.push({ wch: 30 }); // Dependencies
            columnWidths.push({ wch: 40 }); // Notes

            const itemsData = [
                [`DETAILED PROJECT ITEMS - ${currentPatternDef.name}`],
                [],
                allColumns
            ];

            // Add item rows with dynamic pattern fields
            allItems.forEach(item => {
                const phaseDisplay = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;

                const rowData = [
                    item.name || '',
                    phaseDisplay,
                    item.itemType || '',
                    item.description || ''
                ];

                // Add pattern-specific field values
                patternFieldKeys.forEach(fieldKey => {
                    const fieldConfig = patternFields[fieldKey];
                    let value = item[fieldKey];

                    if (value === undefined || value === null || value === '') {
                        rowData.push('');
                        return;
                    }

                    // Format based on field type
                    if (fieldConfig.type === 'number') {
                        // Special handling for cost (convert to millions)
                        if (fieldKey === 'cost' && fieldConfig.label.includes('($M)')) {
                            value = (value / 1000000).toFixed(2);
                        } else if (fieldKey === 'dealValue') {
                            value = (value / 1000).toFixed(0); // Thousands
                        } else {
                            value = value.toString();
                        }
                    } else if (fieldConfig.type === 'date') {
                        value = value; // Keep as-is (Excel will format)
                    } else if (fieldConfig.type === 'textarea') {
                        value = value.replace(/\n/g, ' '); // Remove newlines for Excel
                    }

                    rowData.push(value);
                });

                // Add dependencies and notes
                rowData.push((item.dependencies || []).length > 0 ? item.dependencies.join(', ') : 'None');
                rowData.push(item.notes || '');

                itemsData.push(rowData);
            });

            // Add total row (only for patterns with cost field)
            itemsData.push([]);
            if (patternFields.cost || patternFields.dealValue) {
                const totalRow = ['TOTAL', '', '', ''];

                // Find the cost column index
                const costFieldKey = patternFields.cost ? 'cost' : 'dealValue';
                const costIndex = patternFieldKeys.indexOf(costFieldKey);

                // Fill blanks up to cost column
                for (let i = 0; i < patternFieldKeys.length; i++) {
                    if (i === costIndex) {
                        if (costFieldKey === 'cost') {
                            totalRow.push((totalCost / 1000000).toFixed(2));
                        } else {
                            // Sum dealValue for sales pipeline
                            const totalDealValue = allItems.reduce((sum, item) => sum + (item.dealValue || 0), 0);
                            totalRow.push((totalDealValue / 1000).toFixed(0));
                        }
                    } else {
                        totalRow.push('');
                    }
                }

                totalRow.push('', ''); // Dependencies, Notes
                itemsData.push(totalRow);
            }

            const ws_items = XLSX.utils.aoa_to_sheet(itemsData);
            ws_items['!cols'] = columnWidths;

            XLSX.utils.book_append_sheet(wb, ws_items, 'ğŸ“‹ Detailed Items');

            // =================================================================
            // SHEET 3: DEPENDENCIES MATRIX
            // =================================================================
            const depsData = [
                ['DEPENDENCY MATRIX'],
                [],
                ['Item', 'Depends On', 'Count', 'Critical Path?']
            ];

            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    depsData.push([
                        item.name || '',
                        item.dependencies.join(', '),
                        item.dependencies.length,
                        item.dependencies.length > 2 ? 'Yes' : 'No'
                    ]);
                }
            });

            if (depsData.length === 3) {
                depsData.push(['No dependencies defined yet', '', '', '']);
            }

            const ws_deps = XLSX.utils.aoa_to_sheet(depsData);

            ws_deps['!cols'] = [
                { wch: 35 },
                { wch: 50 },
                { wch: 10 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_deps, 'ğŸ”— Dependencies');

            // =================================================================
            // SHEET 4: COST ANALYSIS BY TYPE
            // =================================================================
            const typeBreakdown = {};
            allItems.forEach(item => {
                const type = item.itemType || 'Uncategorized';
                if (!typeBreakdown[type]) {
                    typeBreakdown[type] = { count: 0, total: 0 };
                }
                typeBreakdown[type].count++;
                typeBreakdown[type].total += (item.cost || 0);
            });

            const analysisData = [
                ['COST ANALYSIS BY TYPE'],
                [],
                ['Item Type', 'Count', 'Total Cost ($M)', '% of Total', 'Avg Cost ($K)']
            ];

            Object.entries(typeBreakdown)
                .sort((a, b) => b[1].total - a[1].total)
                .forEach(([type, data]) => {
                    analysisData.push([
                        type,
                        data.count,
                        (data.total / 1000000).toFixed(2),
                        ((data.total / totalCost) * 100).toFixed(1) + '%',
                        (data.total / data.count / 1000).toFixed(0)
                    ]);
                });

            analysisData.push([]);
            analysisData.push(['TOTAL', allItems.length, (totalCost / 1000000).toFixed(2), '100.0%', (totalCost / allItems.length / 1000).toFixed(0)]);

            const ws_analysis = XLSX.utils.aoa_to_sheet(analysisData);

            ws_analysis['!cols'] = [
                { wch: 30 },
                { wch: 10 },
                { wch: 18 },
                { wch: 12 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_analysis, 'ğŸ“ˆ Cost Analysis');

            // =================================================================
            // SHEET 5: PROJECT TASKS (PM TRACKING)
            // =================================================================
            const tasksData = [
                ['PROJECT TASKS - EXECUTION TRACKING (HIERARCHICAL)'],
                ['Professional Project Management Dashboard', '', '', '', '', '', '', '', '', '', '', ''],
                [],
                ['Task Name', 'Level', 'Parent Item', 'Phase', 'Status', 'Assignee', 'Progress %', 'Priority', 'Start Date', 'Due Date', 'Blocking Issue', 'Next Steps', 'Latest Updates']
            ];

            // Add task rows
            if (allTasks.length > 0) {
                allTasks.forEach(task => {
                    const phaseDisplay = `${task.phaseName}${task.phaseSubtitle ? ' (' + task.phaseSubtitle + ')' : ''}`;

                    // Format updates as timestamped entries
                    let updatesText = '';
                    if (task.pmUpdates && Array.isArray(task.pmUpdates) && task.pmUpdates.length > 0) {
                        updatesText = task.pmUpdates
                            .map(u => `[${new Date(u.timestamp).toLocaleDateString()}] ${u.text}`)
                            .join(' | ');
                    }

                    tasksData.push([
                        task.taskName || task.name || '',  // Use indented taskName for hierarchy
                        task.nestLevel || 0,
                        task.parentItem || '',
                        phaseDisplay,
                        task.pmStatus || 'To Do',
                        task.pmAssignee || 'Unassigned',
                        task.pmProgress || 0,
                        task.pmPriority || 'Medium',
                        task.pmStartDate || '',
                        task.pmDueDate || '',
                        task.pmBlockingIssue || '',
                        task.pmNextSteps || '',
                        updatesText
                    ]);
                });
            } else {
                tasksData.push(['No tasks created yet', '', '', '', '', '', '', '', '', '', '', '', '']);
            }

            // Add summary metrics
            tasksData.push([]);
            tasksData.push(['TASK SUMMARY METRICS']);
            tasksData.push([]);

            const completedTasks = allTasks.filter(t => t.pmStatus === 'Done').length;
            const inProgressTasks = allTasks.filter(t => t.pmStatus === 'In Progress').length;
            const blockedTasks = allTasks.filter(t => t.pmStatus === 'Blocked').length;
            const avgProgress = allTasks.length > 0 ? (allTasks.reduce((sum, t) => sum + (t.pmProgress || 0), 0) / allTasks.length).toFixed(1) : 0;

            tasksData.push(['Total Tasks', allTasks.length]);
            tasksData.push(['Completed', completedTasks, `${allTasks.length > 0 ? ((completedTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['In Progress', inProgressTasks, `${allTasks.length > 0 ? ((inProgressTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['Blocked', blockedTasks, blockedTasks > 0 ? 'âš ï¸ ATTENTION REQUIRED' : '']);
            tasksData.push(['Average Progress', `${avgProgress}%`]);
            tasksData.push([]);
            tasksData.push(['Status Distribution']);

            // Status breakdown
            const statusCounts = {};
            allTasks.forEach(t => {
                const status = t.pmStatus || 'To Do';
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });

            Object.entries(statusCounts)
                .sort((a, b) => b[1] - a[1])
                .forEach(([status, count]) => {
                    tasksData.push([status, count, `${((count/allTasks.length)*100).toFixed(1)}%`]);
                });

            const ws_tasks = XLSX.utils.aoa_to_sheet(tasksData);

            // Set column widths for professional presentation
            ws_tasks['!cols'] = [
                { wch: 40 },  // Task Name (with indentation)
                { wch: 8 },   // Level
                { wch: 30 },  // Parent Item
                { wch: 25 },  // Phase
                { wch: 15 },  // Status
                { wch: 20 },  // Assignee
                { wch: 12 },  // Progress %
                { wch: 12 },  // Priority
                { wch: 15 },  // Start Date
                { wch: 15 },  // Due Date
                { wch: 35 },  // Blocking Issue
                { wch: 40 },  // Next Steps
                { wch: 60 }   // Latest Updates
            ];

            XLSX.utils.book_append_sheet(wb, ws_tasks, 'âœ… Project Tasks');

            // =================================================================
            // GENERATE AND DOWNLOAD FILE
            // =================================================================
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `TreeListy-${timestamp}.xlsx`;

            XLSX.writeFile(wb, filename);

            // Show success message
            alert(`âœ… Excel export successful!\n\nFile: ${filename}\n\nIncludes:\nâ€¢ Executive Summary\nâ€¢ Detailed Items (${allItems.length} items)\nâ€¢ Dependencies Matrix\nâ€¢ Cost Analysis by Type\nâ€¢ Project Tasks (${allTasks.length} tasks with PM tracking)\n\nProfessionally formatted and ready for investor presentations! ğŸ“Š`);
        }

        // Excel Export button handler
        document.getElementById('excel-export-btn').addEventListener('click', exportToExcel);

        // =============================================================================
        // BUILD 353: SMART IMPORT WIZARD
        // Pre-import Q&A for better AI analysis of Excel/Text
        // =============================================================================

        // Smart Import Wizard State
        let smartImportState = {
            active: false,
            contentAnalysis: null,
            userAnswers: {},
            currentStep: 0,
            questions: [],
            appendMode: false,
            sourceType: null, // 'excel' or 'text'
            onComplete: null,  // Callback when wizard completes
            // BUILD 354: Multi-tree output
            multiTreeMode: false,
            selectedSlices: [],
            detectedSlices: [],
            originalData: null  // Store original workbook/text for multi-tree processing
        };

        // Global context that gets prepended to AI prompts
        window.smartImportContext = '';

        // BUILD 354: Multi-tree contexts for generating multiple trees
        window.multiTreeContexts = [];

        // =============================================================================
        // CONTENT ANALYSIS ENGINE (client-side, no AI)
        // =============================================================================

        /**
         * Analyze Excel workbook structure
         */
        function analyzeExcelContent(workbook, fileName) {
            const analysis = {
                sourceType: 'excel',
                fileName: fileName,
                sheets: [],
                relationships: [],
                domain: { detected: 'generic', confidence: 0, keywords: [] },
                financials: { hasCapex: false, hasOpex: false, hasRevenue: false, hasCashflow: false, metrics: [], currencyColumns: [] },
                timeline: { detected: false, range: { start: null, end: null }, granularity: null, milestones: [] },
                validationInfo: { detected: false, stats: { validated: 0, notValidated: 0 } },
                totalRows: 0,
                totalCols: 0
            };

            // Domain keywords for detection
            const domainKeywords = {
                capex: ['capex', 'capital', 'turbine', 'mw', 'megawatt', 'infrastructure', 'construction', 'equipment', 'irr', 'npv', 'payback', 'data center', 'datacenter'],
                philosophy: ['argument', 'premise', 'conclusion', 'dialectic', 'thesis', 'antithesis', 'socratic', 'philosopher', 'epistemology', 'ontology'],
                sales: ['deal', 'pipeline', 'revenue', 'prospect', 'lead', 'close date', 'probability', 'competitor', 'quota', 'commission'],
                legal: ['contract', 'clause', 'party', 'obligation', 'liability', 'indemnity', 'term', 'amendment'],
                technical: ['api', 'database', 'server', 'deployment', 'architecture', 'microservice', 'endpoint', 'integration']
            };

            // Financial keywords
            const financialKeywords = {
                capex: ['capex', 'capital cost', 'capital expenditure', 'equipment cost', 'purchase', 'investment'],
                opex: ['opex', 'operating', 'maintenance', 'wages', 'salary', 'fuel', 'utilities'],
                revenue: ['revenue', 'income', 'sales', 'gross', 'billing'],
                metrics: ['irr', 'npv', 'roi', 'payback', 'margin', 'ebitda']
            };

            // Validation column keywords
            const validationKeywords = ['validated', 'approved', 'confirmed', 'verified', 'status', 'complete', 'done', 'yes/no'];

            // Timeline patterns
            const yearPattern = /\b(20[2-3]\d)\b/g;
            const quarterPattern = /Q[1-4]\s*20[2-3]\d|20[2-3]\d\s*Q[1-4]/gi;

            let allText = '';
            let detectedYears = new Set();
            let detectedMilestones = [];

            // Analyze each sheet
            workbook.SheetNames.forEach((sheetName, sheetIndex) => {
                const sheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                if (data.length === 0) return;

                const sheetInfo = {
                    name: sheetName,
                    index: sheetIndex,
                    rowCount: data.length,
                    colCount: data[0]?.length || 0,
                    headers: [],
                    sampleData: data.slice(0, 5),
                    dataTypes: {},
                    hasValidationColumn: false,
                    validationColIndex: -1,
                    validationStats: { validated: 0, notValidated: 0 },
                    hasCurrencyData: false,
                    hasDateData: false,
                    summary: ''
                };

                analysis.totalRows += data.length;
                analysis.totalCols = Math.max(analysis.totalCols, sheetInfo.colCount);

                // Find headers (first non-empty row with multiple values)
                for (let i = 0; i < Math.min(5, data.length); i++) {
                    const row = data[i];
                    if (row && row.filter(c => c !== null && c !== undefined && c !== '').length >= 2) {
                        sheetInfo.headers = row.map(h => String(h || '').trim());
                        break;
                    }
                }

                // Analyze content
                data.forEach((row, rowIndex) => {
                    if (!row) return;
                    row.forEach((cell, colIndex) => {
                        if (cell === null || cell === undefined) return;
                        const cellStr = String(cell).toLowerCase();
                        allText += ' ' + cellStr;

                        // Detect validation columns
                        if (rowIndex < 3) { // Header area
                            validationKeywords.forEach(kw => {
                                if (cellStr.includes(kw)) {
                                    sheetInfo.hasValidationColumn = true;
                                    sheetInfo.validationColIndex = colIndex;
                                }
                            });
                        }

                        // Count validation values
                        if (sheetInfo.hasValidationColumn && colIndex === sheetInfo.validationColIndex && rowIndex > 0) {
                            if (cellStr === 'yes' || cellStr === 'true' || cellStr === 'done' || cellStr === 'validated' || cellStr === 'approved') {
                                sheetInfo.validationStats.validated++;
                            } else if (cellStr === 'no' || cellStr === 'false' || cellStr === 'pending' || cellStr === 'tbd') {
                                sheetInfo.validationStats.notValidated++;
                            }
                        }

                        // Detect currency (numbers with $ or large numbers)
                        if (typeof cell === 'number' && cell > 10000) {
                            sheetInfo.hasCurrencyData = true;
                        }
                        if (cellStr.includes('$') || cellStr.includes('cost') || cellStr.includes('price')) {
                            sheetInfo.hasCurrencyData = true;
                        }

                        // Detect years and milestones
                        const yearMatches = cellStr.match(yearPattern);
                        if (yearMatches) {
                            yearMatches.forEach(y => detectedYears.add(parseInt(y)));
                        }
                        const quarterMatches = cellStr.match(quarterPattern);
                        if (quarterMatches) {
                            quarterMatches.forEach(q => {
                                if (!detectedMilestones.includes(q)) {
                                    detectedMilestones.push(q);
                                }
                            });
                        }

                        // Detect milestone keywords
                        if (cellStr.includes('milestone') || cellStr.includes('in-service') || cellStr.includes('commission') || cellStr.includes('complete')) {
                            const context = String(cell).substring(0, 100);
                            if (!detectedMilestones.some(m => m.includes(context.substring(0, 20)))) {
                                detectedMilestones.push(context);
                            }
                        }
                    });
                });

                // Generate sheet summary
                const summaryParts = [];
                if (sheetInfo.hasCurrencyData) summaryParts.push('financial data');
                if (sheetInfo.hasValidationColumn) summaryParts.push('validation status');
                if (sheetInfo.hasDateData) summaryParts.push('dates');
                sheetInfo.summary = summaryParts.length > 0 ? summaryParts.join(', ') : 'general data';

                // Aggregate validation stats
                if (sheetInfo.hasValidationColumn) {
                    analysis.validationInfo.detected = true;
                    analysis.validationInfo.stats.validated += sheetInfo.validationStats.validated;
                    analysis.validationInfo.stats.notValidated += sheetInfo.validationStats.notValidated;
                }

                analysis.sheets.push(sheetInfo);
            });

            // Domain detection
            const textLower = allText.toLowerCase();
            let maxScore = 0;
            let detectedDomain = 'generic';
            const foundKeywords = [];

            Object.entries(domainKeywords).forEach(([domain, keywords]) => {
                let score = 0;
                keywords.forEach(kw => {
                    const matches = (textLower.match(new RegExp(kw, 'g')) || []).length;
                    if (matches > 0) {
                        score += matches;
                        if (!foundKeywords.includes(kw) && foundKeywords.length < 8) {
                            foundKeywords.push(kw);
                        }
                    }
                });
                if (score > maxScore) {
                    maxScore = score;
                    detectedDomain = domain;
                }
            });

            analysis.domain = {
                detected: detectedDomain,
                confidence: Math.min(0.95, maxScore / 20),
                keywords: foundKeywords,
                suggestedPattern: detectedDomain === 'capex' ? 'generic' : detectedDomain
            };

            // Financial structure detection
            Object.entries(financialKeywords).forEach(([type, keywords]) => {
                keywords.forEach(kw => {
                    if (textLower.includes(kw)) {
                        if (type === 'capex') analysis.financials.hasCapex = true;
                        if (type === 'opex') analysis.financials.hasOpex = true;
                        if (type === 'revenue') analysis.financials.hasRevenue = true;
                        if (type === 'metrics' && !analysis.financials.metrics.includes(kw.toUpperCase())) {
                            analysis.financials.metrics.push(kw.toUpperCase());
                        }
                    }
                });
            });
            if (textLower.includes('cashflow') || textLower.includes('cash flow')) {
                analysis.financials.hasCashflow = true;
            }

            // Timeline detection
            if (detectedYears.size > 0) {
                const years = Array.from(detectedYears).sort();
                analysis.timeline = {
                    detected: true,
                    range: { start: years[0], end: years[years.length - 1] },
                    granularity: detectedMilestones.length > 4 ? 'quarterly' : 'yearly',
                    milestones: detectedMilestones.slice(0, 10)
                };
            }

            // Detect cross-sheet relationships (simple heuristic: shared keywords in sheet names)
            const sheetKeywords = analysis.sheets.map(s => ({
                name: s.name,
                keywords: s.name.toLowerCase().split(/[\s_-]+/)
            }));

            for (let i = 0; i < sheetKeywords.length; i++) {
                for (let j = i + 1; j < sheetKeywords.length; j++) {
                    const shared = sheetKeywords[i].keywords.filter(k =>
                        k.length > 2 && sheetKeywords[j].keywords.includes(k)
                    );
                    if (shared.length > 0) {
                        analysis.relationships.push({
                            from: sheetKeywords[i].name,
                            to: sheetKeywords[j].name,
                            sharedKeywords: shared,
                            type: 'related'
                        });
                    }
                }
            }

            console.log('ğŸ“Š Content analysis complete:', analysis);
            return analysis;
        }

        /**
         * Analyze text content structure
         */
        function analyzeTextContent(text, fileName = 'Pasted Text') {
            const analysis = {
                sourceType: 'text',
                fileName: fileName,
                sheets: [], // Not applicable for text
                relationships: [],
                domain: { detected: 'generic', confidence: 0, keywords: [] },
                financials: { hasCapex: false, hasOpex: false, hasRevenue: false, hasCashflow: false, metrics: [] },
                timeline: { detected: false, range: { start: null, end: null }, granularity: null, milestones: [] },
                validationInfo: { detected: false, stats: { validated: 0, notValidated: 0 } },
                textStats: {
                    charCount: text.length,
                    wordCount: text.split(/\s+/).filter(w => w.length > 0).length,
                    lineCount: text.split('\n').length,
                    hasHeaders: false,
                    hasBullets: false,
                    hasNumbers: false
                }
            };

            const textLower = text.toLowerCase();

            // Domain keywords (same as Excel)
            const domainKeywords = {
                capex: ['capex', 'capital', 'turbine', 'mw', 'infrastructure', 'equipment', 'irr', 'npv'],
                philosophy: ['argument', 'premise', 'conclusion', 'dialectic', 'thesis', 'philosopher'],
                sales: ['deal', 'pipeline', 'revenue', 'prospect', 'lead', 'probability'],
                legal: ['contract', 'clause', 'party', 'obligation', 'liability'],
                technical: ['api', 'database', 'server', 'deployment', 'architecture']
            };

            // Detect domain
            let maxScore = 0;
            let detectedDomain = 'generic';
            const foundKeywords = [];

            Object.entries(domainKeywords).forEach(([domain, keywords]) => {
                let score = 0;
                keywords.forEach(kw => {
                    const matches = (textLower.match(new RegExp(kw, 'g')) || []).length;
                    if (matches > 0) {
                        score += matches;
                        if (!foundKeywords.includes(kw)) foundKeywords.push(kw);
                    }
                });
                if (score > maxScore) {
                    maxScore = score;
                    detectedDomain = domain;
                }
            });

            analysis.domain = {
                detected: detectedDomain,
                confidence: Math.min(0.95, maxScore / 10),
                keywords: foundKeywords.slice(0, 6)
            };

            // Detect timeline
            const yearPattern = /\b(20[2-3]\d)\b/g;
            const years = [...new Set((text.match(yearPattern) || []).map(y => parseInt(y)))].sort();
            if (years.length > 0) {
                analysis.timeline = {
                    detected: true,
                    range: { start: years[0], end: years[years.length - 1] },
                    granularity: 'yearly',
                    milestones: []
                };
            }

            // Text structure detection
            analysis.textStats.hasHeaders = /^#+\s|^[A-Z][A-Z\s]+:|\n[A-Z][A-Z\s]+\n/m.test(text);
            analysis.textStats.hasBullets = /^[\s]*[-â€¢*]\s|^\s*\d+[.)]\s/m.test(text);
            analysis.textStats.hasNumbers = /\$[\d,]+|\d+%|\d+\s*(MW|kW|GJ|MWh)/i.test(text);

            // Financial detection
            if (/capex|capital\s*(cost|expenditure)/i.test(text)) analysis.financials.hasCapex = true;
            if (/opex|operating\s*(cost|expense)/i.test(text)) analysis.financials.hasOpex = true;
            if (/revenue|income|sales/i.test(text)) analysis.financials.hasRevenue = true;

            console.log('ğŸ“„ Text analysis complete:', analysis);
            return analysis;
        }

        // =============================================================================
        // BUILD 354: MULTI-TREE SLICE DETECTION
        // Detect potential ways to split data into multiple trees
        // =============================================================================

        /**
         * Detect potential slices for multi-tree output
         * Returns array of slice objects with id, name, description, and filter context
         */
        function detectPotentialSlices(analysis, workbook = null, text = null) {
            const slices = [];
            const isExcel = analysis.sourceType === 'excel';

            // 1. STAKEHOLDER/AUDIENCE SLICES
            // Look for business model indicators
            const stakeholderKeywords = {
                'btc-mining': {
                    keywords: ['btc', 'bitcoin', 'mining', 'hash', 'crypto'],
                    name: 'BTC Mining Focus',
                    desc: 'Crypto investors, mining operations',
                    icon: 'â‚¿',
                    audience: 'Crypto investors, power generation partners'
                },
                'enterprise-dc': {
                    keywords: ['enterprise', 'tier 3', 'tier 4', 'datacenter', 'data center', 'colocation', 'colo', 'ai training', 'hyperscale'],
                    name: 'Enterprise Data Center',
                    desc: 'Enterprise customers, AI/cloud investors',
                    icon: 'ğŸ¢',
                    audience: 'Enterprise customers, AI/cloud investors, ESG stakeholders'
                },
                'investor': {
                    keywords: ['irr', 'npv', 'roi', 'investor', 'returns', 'payback', 'payout'],
                    name: 'Investor Summary',
                    desc: 'Financial metrics and returns',
                    icon: 'ğŸ“ˆ',
                    audience: 'Investors, financial stakeholders, board members'
                },
                'operations': {
                    keywords: ['operations', 'maintenance', 'staff', 'wages', 'daily', 'uptime'],
                    name: 'Operations Focus',
                    desc: 'Day-to-day operational data',
                    icon: 'âš™ï¸',
                    audience: 'Operations team, facility managers'
                },
                'esg-carbon': {
                    keywords: ['carbon', 'esg', 'solar', 'renewable', 'emissions', 'neutral', 'sustainable'],
                    name: 'ESG & Carbon Neutral',
                    desc: 'Sustainability and environmental focus',
                    icon: 'ğŸŒ±',
                    audience: 'ESG committees, sustainability officers, green investors'
                }
            };

            // Check content for stakeholder indicators
            let contentText = '';
            if (isExcel && workbook) {
                workbook.SheetNames.forEach(name => {
                    const sheet = workbook.Sheets[name];
                    if (sheet) {
                        const json = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                        json.forEach(row => {
                            contentText += ' ' + row.map(c => String(c || '')).join(' ');
                        });
                    }
                });
            } else if (text) {
                contentText = text;
            }
            const contentLower = contentText.toLowerCase();

            Object.entries(stakeholderKeywords).forEach(([id, config]) => {
                const matchCount = config.keywords.reduce((count, kw) => {
                    const matches = (contentLower.match(new RegExp(kw, 'gi')) || []).length;
                    return count + matches;
                }, 0);

                if (matchCount >= 2) {
                    slices.push({
                        id: id,
                        type: 'stakeholder',
                        name: config.name,
                        desc: config.desc,
                        icon: config.icon,
                        matchScore: matchCount,
                        context: `TARGET AUDIENCE: ${config.audience}\nFOCUS: Filter and emphasize content relevant to ${config.name.toLowerCase()}. Exclude items not relevant to this audience.`
                    });
                }
            });

            // 2. TIMELINE SLICES (if multi-year data)
            if (analysis.timeline.detected && analysis.timeline.range.end - analysis.timeline.range.start >= 2) {
                // Suggest phase-based splits
                slices.push({
                    id: 'phase-early',
                    type: 'timeline',
                    name: `Early Phase (${analysis.timeline.range.start}-${analysis.timeline.range.start + 1})`,
                    desc: 'Initial development and setup',
                    icon: '1ï¸âƒ£',
                    context: `TIMELINE FILTER: Focus only on activities, costs, and milestones from ${analysis.timeline.range.start} to ${analysis.timeline.range.start + 1}. This is the early development phase.`
                });

                if (analysis.timeline.range.end - analysis.timeline.range.start >= 3) {
                    const midStart = analysis.timeline.range.start + 2;
                    const midEnd = analysis.timeline.range.end - 1;
                    slices.push({
                        id: 'phase-growth',
                        type: 'timeline',
                        name: `Growth Phase (${midStart}-${midEnd})`,
                        desc: 'Expansion and scaling',
                        icon: 'ğŸ“ˆ',
                        context: `TIMELINE FILTER: Focus only on activities, costs, and milestones from ${midStart} to ${midEnd}. This is the growth and expansion phase.`
                    });
                }

                slices.push({
                    id: 'phase-mature',
                    type: 'timeline',
                    name: `Mature Phase (${analysis.timeline.range.end}+)`,
                    desc: 'Full operations and optimization',
                    icon: 'âœ…',
                    context: `TIMELINE FILTER: Focus only on activities, costs, and milestones from ${analysis.timeline.range.end} onwards. This is the mature operations phase.`
                });
            }

            // 3. FINANCIAL STRUCTURE SLICES
            if (analysis.financials.hasCapex && analysis.financials.hasRevenue) {
                slices.push({
                    id: 'capex-only',
                    type: 'financial',
                    name: 'Capital Expenditures',
                    desc: 'Investment and infrastructure costs',
                    icon: 'ğŸ’µ',
                    context: 'FINANCIAL FILTER: Focus ONLY on capital expenditures (CAPEX) - equipment, infrastructure, land, construction. Exclude operating costs and revenue projections.'
                });

                slices.push({
                    id: 'revenue-model',
                    type: 'financial',
                    name: 'Revenue & Operations',
                    desc: 'Operating economics and returns',
                    icon: 'ğŸ’°',
                    context: 'FINANCIAL FILTER: Focus ONLY on revenue generation, operating costs (OPEX), profit margins, and ROI calculations. Minimize CAPEX details.'
                });
            }

            // 4. DOMAIN-SPECIFIC SLICES (if mixed content detected)
            if (analysis.domain.keywords.length > 4) {
                // Mixed content - suggest domain splits
                if (analysis.domain.detected === 'capex') {
                    slices.push({
                        id: 'power-infrastructure',
                        type: 'domain',
                        name: 'Power Infrastructure',
                        desc: 'Turbines, solar, grid connection',
                        icon: 'âš¡',
                        context: 'DOMAIN FILTER: Focus ONLY on power generation infrastructure - turbines, solar arrays, grid connections, electrical systems, energy storage.'
                    });

                    slices.push({
                        id: 'facility-infrastructure',
                        type: 'domain',
                        name: 'Facility & Utilities',
                        desc: 'Buildings, cooling, water, connectivity',
                        icon: 'ğŸ—ï¸',
                        context: 'DOMAIN FILTER: Focus ONLY on facility infrastructure - buildings, cooling systems, water treatment, fiber connectivity, site development.'
                    });
                }
            }

            // Sort by match score (stakeholder slices) then by type
            slices.sort((a, b) => {
                if (a.type === 'stakeholder' && b.type === 'stakeholder') {
                    return (b.matchScore || 0) - (a.matchScore || 0);
                }
                return a.type.localeCompare(b.type);
            });

            console.log('ğŸŒ³ Detected potential slices:', slices);
            return slices;
        }

        // =============================================================================
        // QUESTION POOL - Dynamic questions based on content analysis
        // =============================================================================

        const smartImportQuestions = {
            organization: {
                id: 'organization',
                condition: () => true, // Always ask
                question: "How should I organize this?",
                getOptions: (analysis) => {
                    const options = [
                        { id: 'category', label: 'By Category', desc: 'Group by domain/type' }
                    ];
                    if (analysis.timeline.detected) {
                        const range = `${analysis.timeline.range.start} â†’ ${analysis.timeline.range.end}`;
                        options.unshift({ id: 'timeline', label: 'By Timeline', desc: range });
                        options.push({
                            id: 'milestone',
                            label: 'By Milestone',
                            desc: `${analysis.timeline.milestones.length || 'Key'} milestones`,
                            recommended: analysis.timeline.milestones.length > 2
                        });
                    }
                    if (analysis.financials.hasCapex || analysis.financials.hasRevenue) {
                        options.push({ id: 'financial', label: 'By Financial Structure', desc: 'CAPEX â†’ OPEX â†’ Revenue' });
                    }
                    // Mark first as recommended if none marked
                    if (!options.some(o => o.recommended)) {
                        options[0].recommended = true;
                    }
                    return options;
                }
            },

            detailLevel: {
                id: 'detailLevel',
                condition: () => true, // Always ask
                question: "What level of detail?",
                getOptions: () => [
                    { id: 'capital-only', label: 'Key Items Only', desc: 'Main deliverables and costs' },
                    { id: 'capital-milestones', label: 'Items + Milestones', desc: 'Deliverables, infrastructure, key dates', recommended: true },
                    { id: 'everything', label: 'Everything', desc: 'All data as items/subtasks' }
                ]
            },

            financials: {
                id: 'financials',
                condition: (a) => a.financials.hasCapex || a.financials.hasRevenue || a.financials.hasOpex,
                question: "Where should financial data appear?",
                getOptions: () => [
                    { id: 'items', label: 'On Items Only', desc: 'Each item shows its cost' },
                    { id: 'summaries', label: 'Phase Summaries Only', desc: 'Totals per phase' },
                    { id: 'both', label: 'Both', desc: 'Item costs + phase summaries', recommended: true }
                ]
            },

            validation: {
                id: 'validation',
                condition: (a) => a.validationInfo.detected,
                question: "I found validation status. How should I track it?",
                getOptions: (analysis) => {
                    const stats = analysis.validationInfo.stats;
                    return [
                        { id: 'pm-status', label: 'PM Tracking', desc: `Done/To Do (${stats.validated} validated, ${stats.notValidated} pending)`, recommended: true },
                        { id: 'description', label: 'In Description', desc: 'Add [VALIDATED] tag' },
                        { id: 'ignore', label: 'Ignore', desc: "Don't import status" }
                    ];
                }
            },

            appendTarget: {
                id: 'appendTarget',
                condition: (a) => a.appendMode,
                question: "Where should new content go?",
                getOptions: (analysis) => {
                    const options = [
                        { id: 'smart-match', label: 'Smart Match', desc: 'AI matches to existing phases', recommended: true },
                        { id: 'new-phases', label: 'Add New Phases', desc: 'Create separate phases' }
                    ];
                    // Add existing phases as options
                    if (window.capexTree && window.capexTree.children) {
                        window.capexTree.children.forEach(phase => {
                            options.push({
                                id: `phase-${phase.id}`,
                                label: `Under: ${phase.name}`,
                                desc: `${phase.items?.length || 0} existing items`
                            });
                        });
                    }
                    return options;
                }
            },

            duplicateHandling: {
                id: 'duplicateHandling',
                condition: (a) => a.appendMode,
                question: "How should I handle duplicates?",
                getOptions: () => [
                    { id: 'smart-dedupe', label: 'Smart Deduplication', desc: 'Merge similar items (60% match)', recommended: true },
                    { id: 'update', label: 'Update Existing', desc: 'Overwrite matching items' },
                    { id: 'add-all', label: 'Add Everything', desc: 'No deduplication' }
                ]
            },

            // BUILD 354: Multi-tree output option
            outputMode: {
                id: 'outputMode',
                condition: (a) => !a.appendMode && a.detectedSlices && a.detectedSlices.length >= 2,
                question: "I can create multiple trees for different audiences. Interested?",
                getOptions: (analysis) => {
                    const options = [
                        { id: 'single', label: 'Single Tree', desc: 'One comprehensive tree (standard)', recommended: true }
                    ];

                    if (analysis.detectedSlices && analysis.detectedSlices.length >= 2) {
                        options.push({
                            id: 'multi-select',
                            label: 'Multiple Trees',
                            desc: `Choose from ${analysis.detectedSlices.length} detected variations`,
                            icon: 'ğŸŒ³'
                        });

                        // Add quick option for top 2 stakeholder slices
                        const stakeholderSlices = analysis.detectedSlices.filter(s => s.type === 'stakeholder');
                        if (stakeholderSlices.length >= 2) {
                            const top2 = stakeholderSlices.slice(0, 2);
                            options.push({
                                id: 'quick-dual',
                                label: `Quick: ${top2[0].name} + ${top2[1].name}`,
                                desc: 'Generate two targeted trees',
                                quickSlices: top2.map(s => s.id)
                            });
                        }
                    }

                    return options;
                }
            }
        };

        /**
         * Generate questions based on content analysis
         */
        function generateSmartQuestions(analysis) {
            const questions = [];
            Object.values(smartImportQuestions).forEach(q => {
                // Check if appendMode is set in analysis for append-specific questions
                // BUILD 354: Include detectedSlices in analysis for outputMode question
                const checkAnalysis = {
                    ...analysis,
                    appendMode: smartImportState.appendMode,
                    detectedSlices: smartImportState.detectedSlices || []
                };
                if (q.condition(checkAnalysis)) {
                    questions.push({
                        ...q,
                        options: q.getOptions(checkAnalysis)
                    });
                }
            });
            return questions;
        }

        // =============================================================================
        // SEMANTIC ICON MAPPING
        // =============================================================================

        const semanticIconMap = {
            // Energy & Power
            turbine: 'âš¡', generator: 'âš¡', power: 'âš¡', electricity: 'âš¡', 'mw': 'âš¡', megawatt: 'âš¡',
            solar: 'â˜€ï¸', photovoltaic: 'â˜€ï¸', pv: 'â˜€ï¸',
            battery: 'ğŸ”‹', bess: 'ğŸ”‹', storage: 'ğŸ”‹',
            gas: 'ğŸ”¥', fuel: 'ğŸ”¥', natural: 'ğŸ”¥',

            // Infrastructure
            water: 'ğŸ’§', cooling: 'â„ï¸', hvac: 'â„ï¸',
            fiber: 'ğŸŒ', network: 'ğŸŒ', internet: 'ğŸŒ', connectivity: 'ğŸŒ',
            building: 'ğŸ—ï¸', shell: 'ğŸ—ï¸', construction: 'ğŸ—ï¸', facility: 'ğŸ—ï¸',
            site: 'ğŸš§', civil: 'ğŸš§', grading: 'ğŸš§',
            land: 'ğŸï¸', acre: 'ğŸï¸', property: 'ğŸï¸',

            // Business
            btc: 'â‚¿', bitcoin: 'â‚¿', crypto: 'â‚¿', mining: 'â‚¿',
            enterprise: 'ğŸ¢', datacenter: 'ğŸ¢', 'data center': 'ğŸ¢', tier: 'ğŸ¢',
            revenue: 'ğŸ’°', income: 'ğŸ’°', profit: 'ğŸ’°', economics: 'ğŸ’°',
            cost: 'ğŸ’µ', capex: 'ğŸ’µ', expense: 'ğŸ’µ',

            // Status & Milestones
            milestone: 'ğŸ¯', target: 'ğŸ¯', deadline: 'ğŸ¯',
            complete: 'âœ…', done: 'âœ…', validated: 'âœ…',
            pending: 'â³', progress: 'â³',

            // Equipment
            switchgear: 'ğŸ”Œ', cable: 'ğŸ”Œ', electrical: 'ğŸ”Œ',
            diesel: 'ğŸ›¢ï¸', backup: 'ğŸ›¡ï¸', redundancy: 'ğŸ›¡ï¸',

            // Environment
            carbon: 'ğŸŒ±', co2: 'ğŸŒ±', emission: 'ğŸŒ±', green: 'ğŸŒ±',

            // Security & Compliance
            security: 'ğŸ”’', fence: 'ğŸ”’', permit: 'ğŸ“‹', approval: 'ğŸ“‹',
            engineering: 'ğŸ“', design: 'ğŸ“'
        };

        /**
         * Get semantic icon for an item name
         */
        function getSemanticIcon(itemName) {
            const nameLower = itemName.toLowerCase();
            for (const [keyword, icon] of Object.entries(semanticIconMap)) {
                if (nameLower.includes(keyword)) {
                    return icon;
                }
            }
            return 'ğŸ“¦'; // Default
        }

        // =============================================================================
        // BUILD SMART IMPORT CONTEXT (prepended to existing prompts)
        // =============================================================================

        /**
         * Build context string that gets prepended to existing AI prompts
         * This is ADDITIVE - existing prompts are not modified
         */
        function buildSmartImportContext(analysis, answers) {
            if (!analysis || Object.keys(answers).length === 0) {
                return '';
            }

            let context = `
=== SMART IMPORT CONTEXT ===
Source: ${analysis.fileName} (${analysis.sourceType})
`;

            // Organization preference
            if (answers.organization) {
                context += `\nORGANIZATION: ${answers.organization}`;
                if (answers.organization === 'timeline' && analysis.timeline.detected) {
                    context += ` (${analysis.timeline.range.start}-${analysis.timeline.range.end})`;
                } else if (answers.organization === 'milestone' && analysis.timeline.milestones.length > 0) {
                    context += `\nMilestones to use: ${analysis.timeline.milestones.slice(0, 5).join(', ')}`;
                }
            }

            // Detail level
            if (answers.detailLevel) {
                context += `\nDETAIL LEVEL: ${answers.detailLevel}`;
                if (answers.detailLevel === 'capital-only') {
                    context += ' - Focus on main deliverables and costs only';
                } else if (answers.detailLevel === 'everything') {
                    context += ' - Include all available data as items/subtasks';
                }
            }

            // Financial handling
            if (answers.financials) {
                context += `\nFINANCIALS: ${answers.financials}`;
                if (answers.financials === 'both') {
                    context += ' - Add costs to items AND create "Economics Summary" item per phase';
                }
            }

            // Validation mapping
            if (answers.validation === 'pm-status') {
                context += `\nVALIDATION â†’ PM STATUS: Map Yes/Validated/Approved â†’ pmStatus:"Done", pmProgress:100; Map No/Pending/TBD â†’ pmStatus:"To Do", pmProgress:0`;
            }

            // Append mode specifics
            if (answers.appendTarget) {
                context += `\nAPPEND TARGET: ${answers.appendTarget}`;
            }
            if (answers.duplicateHandling) {
                context += `\nDUPLICATE HANDLING: ${answers.duplicateHandling}`;
            }

            // Domain context
            if (analysis.domain.detected !== 'generic' && analysis.domain.confidence > 0.3) {
                context += `\nDOMAIN CONTEXT: This is ${analysis.domain.detected} data. Keywords: ${analysis.domain.keywords.join(', ')}`;
            }

            // Cross-sheet relationships
            if (analysis.relationships && analysis.relationships.length > 0) {
                context += `\nCROSS-REFERENCES: ${analysis.relationships.map(r => `${r.from}â†”${r.to}`).join(', ')}`;
            }

            // Source traceability instruction
            context += `\nSOURCE TRACEABILITY: Include source reference in item descriptions where helpful`;

            // Semantic icons instruction
            context += `\nICONS: Use semantic icons (âš¡ power, ğŸ’° financial, ğŸ—ï¸ building, ğŸ¯ milestone, etc.)`;

            context += `\n=== END SMART IMPORT CONTEXT ===\n\n`;

            return context;
        }

        // =============================================================================
        // SMART IMPORT WIZARD UI
        // =============================================================================

        /**
         * Show the Smart Import Wizard modal
         * BUILD 354: Added workbook/text params for multi-tree slice detection
         */
        function showSmartImportWizard(analysis, appendMode, onComplete, originalData = null) {
            // BUILD 354: Detect potential slices for multi-tree output
            const detectedSlices = !appendMode ? detectPotentialSlices(
                analysis,
                originalData?.workbook || null,
                originalData?.text || null
            ) : [];

            smartImportState = {
                active: true,
                contentAnalysis: analysis,
                userAnswers: {},
                currentStep: 0,
                questions: [], // Will be generated after detectedSlices is set
                appendMode: appendMode,
                sourceType: analysis.sourceType,
                onComplete: onComplete,
                // BUILD 354: Multi-tree state
                multiTreeMode: false,
                detectedSlices: detectedSlices,
                selectedSlices: [],
                originalData: originalData
            };

            // Generate questions now that detectedSlices is set
            smartImportState.questions = generateSmartQuestions(analysis);

            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ” Smart Import Wizard';

            // Show Step 1: Content Preview
            showWizardStep1(modalBody, analysis);
            modal.style.display = 'flex';
        }

        /**
         * Step 1: Content Preview
         */
        function showWizardStep1(container, analysis) {
            const isExcel = analysis.sourceType === 'excel';

            let sheetsHtml = '';
            if (isExcel && analysis.sheets.length > 0) {
                sheetsHtml = `
                    <div style="margin-top: 16px; border-top: 1px solid var(--border); padding-top: 16px;">
                        <div style="font-weight: 600; margin-bottom: 8px; cursor: pointer;" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">
                            ğŸ“‘ Sheets Overview (${analysis.sheets.length}) â–¾
                        </div>
                        <div style="display: none; max-height: 150px; overflow-y: auto;">
                            ${analysis.sheets.map(s => `
                                <div style="padding: 4px 0; font-size: 13px; color: var(--text-secondary);">
                                    â€¢ ${s.name} (${s.rowCount} rows) - ${s.summary || 'data'}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            let textStatsHtml = '';
            if (!isExcel && analysis.textStats) {
                textStatsHtml = `
                    <div style="padding: 8px 12px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 12px;">
                        ğŸ“„ ${analysis.textStats.wordCount.toLocaleString()} words â€¢ ${analysis.textStats.lineCount} lines
                        ${analysis.textStats.hasHeaders ? ' â€¢ Has headers' : ''}
                        ${analysis.textStats.hasBullets ? ' â€¢ Has bullet points' : ''}
                    </div>
                `;
            }

            container.innerHTML = `
                <div style="padding: 20px; max-width: 600px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 12px; color: var(--text-secondary);">Step 1 of ${smartImportState.questions.length + 1}</span>
                        <span style="font-size: 12px; color: var(--text-secondary);">${smartImportState.appendMode ? 'â• Append Mode' : 'ğŸ“¥ Import Mode'}</span>
                    </div>

                    <div style="padding: 12px 16px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 4px;">
                            ${isExcel ? 'ğŸ“Š' : 'ğŸ“„'} ${analysis.fileName}
                        </div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            ${isExcel ? `${analysis.sheets.length} sheets â€¢ ${analysis.totalRows.toLocaleString()} total rows` : ''}
                        </div>
                    </div>

                    ${textStatsHtml}

                    <div style="font-weight: 600; margin-bottom: 12px;">What I Detected:</div>

                    <div style="display: grid; gap: 8px;">
                        ${analysis.domain.detected !== 'generic' ? `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px;">
                                <span>ğŸ¢</span>
                                <div>
                                    <div style="font-weight: 500;">Domain: ${analysis.domain.detected.toUpperCase()}</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">Keywords: ${analysis.domain.keywords.slice(0, 5).join(', ')}</div>
                                </div>
                            </div>
                        ` : ''}

                        ${analysis.timeline.detected ? `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: rgba(34, 197, 94, 0.1); border-radius: 6px;">
                                <span>ğŸ“…</span>
                                <div>
                                    <div style="font-weight: 500;">Timeline: ${analysis.timeline.range.start} â†’ ${analysis.timeline.range.end}</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">${analysis.timeline.milestones.length || 'Multiple'} milestones detected</div>
                                </div>
                            </div>
                        ` : ''}

                        ${analysis.financials.hasCapex || analysis.financials.hasRevenue ? `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: rgba(245, 158, 11, 0.1); border-radius: 6px;">
                                <span>ğŸ’°</span>
                                <div>
                                    <div style="font-weight: 500;">Financial Model Detected</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">
                                        ${[
                                            analysis.financials.hasCapex ? 'CAPEX' : '',
                                            analysis.financials.hasOpex ? 'OPEX' : '',
                                            analysis.financials.hasRevenue ? 'Revenue' : ''
                                        ].filter(Boolean).join(' â€¢ ')}
                                        ${analysis.financials.metrics.length > 0 ? ` â€¢ Metrics: ${analysis.financials.metrics.join(', ')}` : ''}
                                    </div>
                                </div>
                            </div>
                        ` : ''}

                        ${analysis.validationInfo.detected ? `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: rgba(16, 185, 129, 0.1); border-radius: 6px;">
                                <span>âœ…</span>
                                <div>
                                    <div style="font-weight: 500;">Validation Column Found</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">${analysis.validationInfo.stats.validated} validated â€¢ ${analysis.validationInfo.stats.notValidated} pending</div>
                                </div>
                            </div>
                        ` : ''}

                        ${analysis.relationships && analysis.relationships.length > 0 ? `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: rgba(139, 92, 246, 0.1); border-radius: 6px;">
                                <span>ğŸ”—</span>
                                <div>
                                    <div style="font-weight: 500;">Cross-References</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">${analysis.relationships.slice(0, 3).map(r => `${r.from} â†” ${r.to}`).join(', ')}</div>
                                </div>
                            </div>
                        ` : ''}
                    </div>

                    ${sheetsHtml}

                    <div style="display: flex; justify-content: space-between; margin-top: 24px;">
                        <button onclick="closeSmartImportWizard()" class="btn" style="padding: 8px 16px;">
                            Cancel
                        </button>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="skipSmartImportWizard()" class="btn" style="padding: 8px 16px; opacity: 0.7;">
                                Skip Wizard â†’
                            </button>
                            <button onclick="nextWizardStep()" class="btn btn-primary" style="padding: 8px 20px;">
                                Continue â†’
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * Show question step
         */
        function showWizardQuestionStep(container, questionIndex) {
            const question = smartImportState.questions[questionIndex];
            if (!question) {
                finishSmartImportWizard();
                return;
            }

            const stepNum = questionIndex + 2; // +2 because Step 1 is preview
            const totalSteps = smartImportState.questions.length + 1;

            // Find recommended option
            const recommendedOption = question.options.find(o => o.recommended);

            container.innerHTML = `
                <div style="padding: 20px; max-width: 550px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <span style="font-size: 12px; color: var(--text-secondary);">Step ${stepNum} of ${totalSteps}</span>
                        <span style="font-size: 12px; color: var(--text-secondary);">${smartImportState.appendMode ? 'â• Append Mode' : 'ğŸ“¥ Import Mode'}</span>
                    </div>

                    <div style="font-size: 18px; font-weight: 600; margin-bottom: 20px;">
                        ${question.question}
                    </div>

                    <div style="display: grid; gap: 10px; margin-bottom: 20px;">
                        ${question.options.map((opt, idx) => `
                            <label style="display: flex; align-items: flex-start; gap: 12px; padding: 12px 16px; border: 2px solid ${opt.recommended ? 'var(--treeplex-primary)' : 'var(--border)'}; border-radius: 8px; cursor: pointer; transition: all 0.15s; background: ${opt.recommended ? 'rgba(0, 166, 125, 0.05)' : 'transparent'};"
                                   onmouseenter="this.style.borderColor='var(--treeplex-primary)'"
                                   onmouseleave="this.style.borderColor='${opt.recommended ? 'var(--treeplex-primary)' : 'var(--border)'}'">
                                <input type="radio" name="wizard-q-${question.id}" value="${opt.id}"
                                       ${opt.recommended ? 'checked' : ''}
                                       style="margin-top: 2px;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 500; display: flex; align-items: center; gap: 8px;">
                                        ${opt.label}
                                        ${opt.recommended ? '<span style="font-size: 11px; padding: 2px 6px; background: var(--treeplex-primary); color: white; border-radius: 4px;">Recommended</span>' : ''}
                                    </div>
                                    <div style="font-size: 13px; color: var(--text-secondary); margin-top: 2px;">${opt.desc}</div>
                                </div>
                            </label>
                        `).join('')}
                    </div>

                    ${recommendedOption ? `
                        <div style="padding: 10px 14px; background: rgba(99, 102, 241, 0.1); border-radius: 6px; margin-bottom: 20px;">
                            <div style="font-size: 13px; color: var(--text-secondary);">
                                ğŸ’¡ <strong>${recommendedOption.label}</strong> is recommended based on your data structure.
                            </div>
                        </div>
                    ` : ''}

                    <div style="display: flex; justify-content: space-between;">
                        <button onclick="prevWizardStep()" class="btn" style="padding: 8px 16px;">
                            â† Back
                        </button>
                        <button onclick="nextWizardStep()" class="btn btn-primary" style="padding: 8px 20px;">
                            ${questionIndex === smartImportState.questions.length - 1 ? 'Finish â†’' : 'Next â†’'}
                        </button>
                    </div>
                </div>
            `;
        }

        /**
         * Navigate to next step
         */
        function nextWizardStep() {
            const container = document.getElementById('modal-body');

            // Save answer from current question if on a question step
            if (smartImportState.currentStep > 0) {
                const questionIndex = smartImportState.currentStep - 1;
                const question = smartImportState.questions[questionIndex];
                if (question) {
                    const selected = document.querySelector(`input[name="wizard-q-${question.id}"]:checked`);
                    if (selected) {
                        smartImportState.userAnswers[question.id] = selected.value;

                        // BUILD 354: Handle outputMode answer
                        if (question.id === 'outputMode') {
                            if (selected.value === 'multi-select') {
                                // Show multi-tree selection step
                                smartImportState.multiTreeMode = true;
                                showMultiTreeSelectionStep(container);
                                return;
                            } else if (selected.value === 'quick-dual') {
                                // Use the quick dual slices
                                const option = question.options.find(o => o.id === 'quick-dual');
                                if (option && option.quickSlices) {
                                    smartImportState.multiTreeMode = true;
                                    smartImportState.selectedSlices = option.quickSlices;
                                }
                            }
                        }
                    }
                }
            }

            smartImportState.currentStep++;

            if (smartImportState.currentStep > smartImportState.questions.length) {
                finishSmartImportWizard();
            } else {
                showWizardQuestionStep(container, smartImportState.currentStep - 1);
            }
        }

        /**
         * BUILD 354: Show multi-tree slice selection step
         */
        function showMultiTreeSelectionStep(container) {
            const slices = smartImportState.detectedSlices;

            // Group slices by type
            const byType = {};
            slices.forEach(s => {
                if (!byType[s.type]) byType[s.type] = [];
                byType[s.type].push(s);
            });

            const typeLabels = {
                stakeholder: 'ğŸ‘¥ Audience/Stakeholder',
                timeline: 'ğŸ“… Timeline Phase',
                financial: 'ğŸ’° Financial Focus',
                domain: 'ğŸ¢ Domain/Technology'
            };

            container.innerHTML = `
                <div style="padding: 20px; max-width: 600px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 12px; color: var(--text-secondary);">ğŸŒ³ Multi-Tree Selection</span>
                    </div>

                    <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">
                        Select the trees you want to generate
                    </div>
                    <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 20px;">
                        Each selection will create a separate tree file optimized for that audience.
                    </div>

                    <div style="max-height: 350px; overflow-y: auto; margin-bottom: 20px;">
                        ${Object.entries(byType).map(([type, typeSlices]) => `
                            <div style="margin-bottom: 16px;">
                                <div style="font-weight: 600; color: var(--text-secondary); font-size: 12px; margin-bottom: 8px; text-transform: uppercase;">
                                    ${typeLabels[type] || type}
                                </div>
                                <div style="display: grid; gap: 8px;">
                                    ${typeSlices.map(slice => `
                                        <label style="display: flex; align-items: flex-start; gap: 12px; padding: 10px 14px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.15s;"
                                               onmouseenter="this.style.borderColor='var(--treeplex-primary)'"
                                               onmouseleave="if(!this.querySelector('input').checked) this.style.borderColor='var(--border)'">
                                            <input type="checkbox" name="multi-tree-slice" value="${slice.id}"
                                                   style="margin-top: 3px;"
                                                   onchange="updateSliceSelection(this)">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 500; display: flex; align-items: center; gap: 6px;">
                                                    <span>${slice.icon}</span>
                                                    ${slice.name}
                                                </div>
                                                <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">${slice.desc}</div>
                                            </div>
                                        </label>
                                    `).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div id="multi-tree-summary" style="padding: 10px 14px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 20px;">
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            Select at least 2 tree variations to generate
                        </div>
                    </div>

                    <div style="display: flex; justify-content: space-between;">
                        <button onclick="cancelMultiTreeSelection()" class="btn" style="padding: 8px 16px;">
                            â† Back to Single Tree
                        </button>
                        <button id="multi-tree-continue" onclick="confirmMultiTreeSelection()" class="btn btn-primary" style="padding: 8px 20px; opacity: 0.5;" disabled>
                            Generate Trees â†’
                        </button>
                    </div>
                </div>
            `;
        }

        /**
         * BUILD 354: Update slice selection state
         */
        function updateSliceSelection(checkbox) {
            const selected = document.querySelectorAll('input[name="multi-tree-slice"]:checked');
            const selectedIds = Array.from(selected).map(c => c.value);

            smartImportState.selectedSlices = selectedIds;

            // Update visual styling
            document.querySelectorAll('input[name="multi-tree-slice"]').forEach(cb => {
                const label = cb.closest('label');
                if (cb.checked) {
                    label.style.borderColor = 'var(--treeplex-primary)';
                    label.style.background = 'rgba(0, 166, 125, 0.05)';
                } else {
                    label.style.borderColor = 'var(--border)';
                    label.style.background = 'transparent';
                }
            });

            // Update summary
            const summary = document.getElementById('multi-tree-summary');
            const continueBtn = document.getElementById('multi-tree-continue');

            if (selectedIds.length >= 2) {
                const sliceNames = selectedIds.map(id => {
                    const slice = smartImportState.detectedSlices.find(s => s.id === id);
                    return slice ? `${slice.icon} ${slice.name}` : id;
                });
                summary.innerHTML = `
                    <div style="font-size: 13px;">
                        <strong>ğŸŒ³ ${selectedIds.length} trees to generate:</strong><br>
                        ${sliceNames.join(' â€¢ ')}
                    </div>
                `;
                continueBtn.disabled = false;
                continueBtn.style.opacity = '1';
            } else {
                summary.innerHTML = `
                    <div style="font-size: 13px; color: var(--text-secondary);">
                        Select at least 2 tree variations to generate
                    </div>
                `;
                continueBtn.disabled = true;
                continueBtn.style.opacity = '0.5';
            }
        }

        /**
         * BUILD 354: Cancel multi-tree and go back to single tree mode
         */
        function cancelMultiTreeSelection() {
            smartImportState.multiTreeMode = false;
            smartImportState.selectedSlices = [];
            smartImportState.userAnswers.outputMode = 'single';

            // Continue to next step or finish
            smartImportState.currentStep++;
            const container = document.getElementById('modal-body');

            if (smartImportState.currentStep > smartImportState.questions.length) {
                finishSmartImportWizard();
            } else {
                showWizardQuestionStep(container, smartImportState.currentStep - 1);
            }
        }

        /**
         * BUILD 354: Confirm multi-tree selection and finish wizard
         */
        function confirmMultiTreeSelection() {
            if (smartImportState.selectedSlices.length < 2) {
                showToast('Please select at least 2 tree variations', 'error');
                return;
            }

            // Continue with remaining questions if any, then finish
            smartImportState.currentStep++;
            const container = document.getElementById('modal-body');

            if (smartImportState.currentStep > smartImportState.questions.length) {
                finishSmartImportWizard();
            } else {
                showWizardQuestionStep(container, smartImportState.currentStep - 1);
            }
        }

        /**
         * Navigate to previous step
         */
        function prevWizardStep() {
            const container = document.getElementById('modal-body');
            smartImportState.currentStep--;

            if (smartImportState.currentStep <= 0) {
                smartImportState.currentStep = 0;
                showWizardStep1(container, smartImportState.contentAnalysis);
            } else {
                showWizardQuestionStep(container, smartImportState.currentStep - 1);
            }
        }

        /**
         * Skip wizard and use defaults
         */
        function skipSmartImportWizard() {
            // Use recommended defaults
            smartImportState.questions.forEach(q => {
                const recommended = q.options.find(o => o.recommended);
                if (recommended) {
                    smartImportState.userAnswers[q.id] = recommended.id;
                } else if (q.options.length > 0) {
                    smartImportState.userAnswers[q.id] = q.options[0].id;
                }
            });
            finishSmartImportWizard();
        }

        /**
         * Complete wizard and build context
         */
        function finishSmartImportWizard() {
            // BUILD 354: Handle multi-tree mode
            if (smartImportState.multiTreeMode && smartImportState.selectedSlices.length >= 2) {
                // Build contexts for each selected slice
                window.multiTreeContexts = smartImportState.selectedSlices.map(sliceId => {
                    const slice = smartImportState.detectedSlices.find(s => s.id === sliceId);
                    if (!slice) return null;

                    // Build base context from user answers
                    const baseContext = buildSmartImportContext(
                        smartImportState.contentAnalysis,
                        smartImportState.userAnswers
                    );

                    // Add slice-specific context
                    const sliceContext = `
=== MULTI-TREE SLICE CONTEXT ===
${slice.context}
TREE NAME SUFFIX: ${slice.name}
TREE ICON: ${slice.icon}
=== END SLICE CONTEXT ===

${baseContext}`;

                    return {
                        sliceId: slice.id,
                        sliceName: slice.name,
                        sliceIcon: slice.icon,
                        context: sliceContext
                    };
                }).filter(Boolean);

                // Use first slice context as the primary context
                window.smartImportContext = window.multiTreeContexts[0]?.context || '';

                console.log('ğŸŒ³ Multi-tree mode: Generating', window.multiTreeContexts.length, 'trees');
                console.log('ğŸ“‹ Slice contexts:', window.multiTreeContexts);

                // Close modal and call completion callback with multi-tree info
                document.getElementById('modal').style.display = 'none';

                if (smartImportState.onComplete) {
                    smartImportState.onComplete({
                        ...smartImportState.userAnswers,
                        multiTreeMode: true,
                        multiTreeContexts: window.multiTreeContexts
                    });
                }

                smartImportState.active = false;
                return;
            }

            // Standard single-tree mode
            // Build the context that will be prepended to AI prompts
            window.smartImportContext = buildSmartImportContext(
                smartImportState.contentAnalysis,
                smartImportState.userAnswers
            );

            console.log('ğŸ” Smart Import Wizard complete');
            console.log('ğŸ“‹ User answers:', smartImportState.userAnswers);
            console.log('ğŸ“ Context to prepend:', window.smartImportContext);

            // Close modal
            document.getElementById('modal').style.display = 'none';

            // Call the completion callback
            if (smartImportState.onComplete) {
                smartImportState.onComplete(smartImportState.userAnswers);
            }

            // Reset state
            smartImportState.active = false;
        }

        /**
         * Close wizard without completing
         */
        function closeSmartImportWizard() {
            document.getElementById('modal').style.display = 'none';
            smartImportState.active = false;
            window.smartImportContext = '';
        }

        // =============================================================================
        // BUILD 354: MULTI-TREE GENERATION
        // Process multiple tree variants sequentially
        // =============================================================================

        /**
         * Process Excel import in multi-tree mode
         * Generates multiple trees and downloads each as JSON
         */
        async function proceedWithMultiTreeExcelImport(workbook, multiTreeContexts) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸŒ³ Generating Multiple Trees';

            const generatedTrees = [];
            const totalTrees = multiTreeContexts.length;

            // Show progress UI
            modalBody.innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px;">ğŸŒ³</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 12px;">
                        Generating ${totalTrees} tree variations...
                    </div>
                    <div id="multi-tree-progress" style="font-size: 14px; color: var(--text-secondary); margin-bottom: 20px;">
                        Preparing first tree...
                    </div>
                    <div style="width: 100%; background: var(--bg-secondary); border-radius: 8px; height: 8px; overflow: hidden;">
                        <div id="multi-tree-progress-bar" style="width: 0%; height: 100%; background: var(--treeplex-primary); transition: width 0.3s;"></div>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';

            // Process each tree variant
            for (let i = 0; i < multiTreeContexts.length; i++) {
                const ctx = multiTreeContexts[i];

                // Update progress
                document.getElementById('multi-tree-progress').textContent =
                    `Generating ${ctx.sliceIcon} ${ctx.sliceName} (${i + 1}/${totalTrees})...`;
                document.getElementById('multi-tree-progress-bar').style.width =
                    `${((i + 0.5) / totalTrees) * 100}%`;

                // Set context for this tree
                window.smartImportContext = ctx.context;

                try {
                    // Use flexible import but capture the result instead of loading it
                    // For now, we'll process the first sheet with AI analysis
                    const sheetData = await extractExcelDataForMultiTree(workbook);
                    const treeResult = await generateTreeWithAI(sheetData, ctx);

                    if (treeResult) {
                        generatedTrees.push({
                            sliceId: ctx.sliceId,
                            sliceName: ctx.sliceName,
                            sliceIcon: ctx.sliceIcon,
                            tree: treeResult
                        });
                    }
                } catch (err) {
                    console.error(`Error generating tree for ${ctx.sliceName}:`, err);
                }

                // Update progress
                document.getElementById('multi-tree-progress-bar').style.width =
                    `${((i + 1) / totalTrees) * 100}%`;
            }

            // Reset context
            window.smartImportContext = '';

            // Show completion and offer downloads
            showMultiTreeCompletion(generatedTrees);
        }

        /**
         * Extract data from Excel for multi-tree processing
         */
        async function extractExcelDataForMultiTree(workbook) {
            // Combine all sheets into a single data blob for AI processing
            let combinedData = '';

            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                if (!sheet) return;

                const json = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
                if (json.length === 0) return;

                combinedData += `\n=== Sheet: ${sheetName} ===\n`;
                json.slice(0, 100).forEach(row => { // Limit to first 100 rows per sheet
                    const rowStr = row.map(cell => String(cell || '')).join(' | ');
                    if (rowStr.trim()) {
                        combinedData += rowStr + '\n';
                    }
                });
            });

            return combinedData;
        }

        /**
         * Generate a tree using AI with slice-specific context
         */
        async function generateTreeWithAI(sheetData, sliceContext) {
            try {
                // Build prompt with slice context
                const prompt = `${sliceContext.context}

Analyze the following data and create a hierarchical tree structure in JSON format.
The tree should follow this structure:
{
    "id": "root",
    "name": "[Project Name based on ${sliceContext.sliceName}]",
    "type": "root",
    "icon": "${sliceContext.sliceIcon}",
    "description": "[Summary focused on ${sliceContext.sliceName}]",
    "expanded": true,
    "children": [
        {
            "id": "phase-0",
            "name": "[Phase Name]",
            "type": "phase",
            "phase": 0,
            "icon": "1ï¸âƒ£",
            "expanded": true,
            "items": [
                {
                    "id": "item-0-0",
                    "name": "[Item Name]",
                    "description": "[Details]",
                    "icon": "[emoji]",
                    "type": "item",
                    "cost": [number if applicable],
                    "subtasks": []
                }
            ],
            "children": []
        }
    ],
    "pattern": { "key": "generic", "labels": { "root": "Project", "phase": "Phase", "item": "Item", "subtask": "Subtask" } }
}

DATA TO ANALYZE:
${sheetData.substring(0, 8000)}

Return ONLY valid JSON, no explanation.`;

                // Get current AI provider
                const provider = currentAIProvider || 'claude';
                let tree;

                if (provider === 'claude') {
                    tree = await callClaudeForMultiTree(prompt);
                } else if (provider === 'gemini') {
                    tree = await callGeminiForMultiTree(prompt);
                } else {
                    tree = await callOpenAIForMultiTree(prompt);
                }

                // BUILD 355: Lightweight validation for multi-tree output
                if (tree && tree.children && tree.children.length > 0) {
                    console.log(`âœ… Multi-tree verified: ${tree.children.length} phases for ${sliceContext.sliceName}`);
                    return tree;
                } else if (tree) {
                    console.warn(`âš ï¸ Multi-tree for ${sliceContext.sliceName} has issues, returning anyway`);
                    return tree;
                }

                return null;
            } catch (err) {
                console.error('AI tree generation failed:', err);
                return null;
            }
        }

        /**
         * Call Claude for multi-tree generation
         */
        async function callClaudeForMultiTree(prompt) {
            const response = await fetch('/.netlify/functions/claude-proxy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 8000,
                    messages: [{ role: 'user', content: prompt }]
                })
            });

            const data = await response.json();
            if (data.content?.[0]?.text) {
                return extractJSONFromResponse(data.content[0].text);
            }
            return null;
        }

        /**
         * Call Gemini for multi-tree generation
         */
        async function callGeminiForMultiTree(prompt) {
            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) return null;

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { maxOutputTokens: 8000 }
                })
            });

            const data = await response.json();
            if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                return extractJSONFromResponse(data.candidates[0].content.parts[0].text);
            }
            return null;
        }

        /**
         * Call OpenAI for multi-tree generation
         */
        async function callOpenAIForMultiTree(prompt) {
            const apiKey = localStorage.getItem('openai_api_key');
            if (!apiKey) return null;

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4-turbo-preview',
                    messages: [{ role: 'user', content: prompt }],
                    max_tokens: 8000
                })
            });

            const data = await response.json();
            if (data.choices?.[0]?.message?.content) {
                return extractJSONFromResponse(data.choices[0].message.content);
            }
            return null;
        }

        /**
         * Extract JSON from AI response
         */
        function extractJSONFromResponse(text) {
            try {
                // Try direct parse first
                return JSON.parse(text);
            } catch (e) {
                // Try to extract from code block
                const jsonMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
                if (jsonMatch) {
                    try {
                        return JSON.parse(jsonMatch[1]);
                    } catch (e2) {}
                }
                // Try to find JSON object in text
                const objMatch = text.match(/\{[\s\S]*\}/);
                if (objMatch) {
                    try {
                        return JSON.parse(objMatch[0]);
                    } catch (e3) {}
                }
            }
            return null;
        }

        /**
         * Show multi-tree completion UI with download options
         */
        function showMultiTreeCompletion(generatedTrees) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸŒ³ Trees Generated!';

            const successCount = generatedTrees.length;

            modalBody.innerHTML = `
                <div style="padding: 20px; max-width: 500px;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 48px; margin-bottom: 12px;">âœ…</div>
                        <div style="font-size: 16px; font-weight: 600;">
                            ${successCount} tree${successCount > 1 ? 's' : ''} generated successfully!
                        </div>
                    </div>

                    <div style="margin-bottom: 24px;">
                        <div style="font-weight: 600; margin-bottom: 12px;">Generated Trees:</div>
                        <div style="display: grid; gap: 8px;">
                            ${generatedTrees.map((t, idx) => `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--bg-secondary); border-radius: 8px;">
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <span style="font-size: 20px;">${t.sliceIcon}</span>
                                        <div>
                                            <div style="font-weight: 500;">${t.sliceName}</div>
                                            <div style="font-size: 12px; color: var(--text-secondary);">
                                                ${t.tree?.children?.length || 0} phases â€¢ ${countItems(t.tree)} items
                                            </div>
                                        </div>
                                    </div>
                                    <button onclick="downloadSingleTree(${idx})" class="btn" style="padding: 6px 12px; font-size: 12px;">
                                        ğŸ“¥ Download
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div style="display: flex; gap: 12px;">
                        <button onclick="downloadAllTrees()" class="btn btn-primary" style="flex: 1; padding: 10px 16px;">
                            ğŸ“¦ Download All (ZIP)
                        </button>
                        <button onclick="loadFirstTree()" class="btn" style="flex: 1; padding: 10px 16px;">
                            ğŸ“‚ Load First Tree
                        </button>
                    </div>

                    <div style="margin-top: 16px; text-align: center;">
                        <button onclick="closeModal()" class="btn" style="padding: 8px 16px; opacity: 0.7;">
                            Close
                        </button>
                    </div>
                </div>
            `;

            // Store generated trees for download
            window.generatedMultiTrees = generatedTrees;
            modal.style.display = 'flex';
        }

        /**
         * Count total items in a tree
         */
        function countItems(tree) {
            if (!tree || !tree.children) return 0;
            return tree.children.reduce((sum, phase) => {
                return sum + (phase.items?.length || 0);
            }, 0);
        }

        /**
         * Download a single tree from the generated set
         */
        function downloadSingleTree(index) {
            const trees = window.generatedMultiTrees;
            if (!trees || !trees[index]) return;

            const tree = trees[index];
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const safeName = tree.sliceName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
            const filename = `treelisty-${safeName}-${timestamp}.json`;

            const blob = new Blob([JSON.stringify(tree.tree, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            showToast(`Downloaded: ${tree.sliceName}`, 'success');
        }

        /**
         * Download all generated trees as individual JSON files
         */
        function downloadAllTrees() {
            const trees = window.generatedMultiTrees;
            if (!trees || trees.length === 0) return;

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

            trees.forEach((tree, idx) => {
                setTimeout(() => {
                    const safeName = tree.sliceName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                    const filename = `treelisty-${safeName}-${timestamp}.json`;

                    const blob = new Blob([JSON.stringify(tree.tree, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                }, idx * 500); // Stagger downloads
            });

            showToast(`Downloading ${trees.length} trees...`, 'success');
        }

        /**
         * Load the first generated tree into TreeListy
         */
        function loadFirstTree() {
            const trees = window.generatedMultiTrees;
            if (!trees || trees.length === 0) return;

            const firstTree = trees[0].tree;
            if (firstTree) {
                loadTreeData(firstTree);
                document.getElementById('modal').style.display = 'none';
                showToast(`Loaded: ${trees[0].sliceName}`, 'success');
            }
        }

        /**
         * Process text analysis in multi-tree mode
         */
        async function proceedWithMultiTreeTextAnalysis(text, mode, multiTreeContexts) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸŒ³ Generating Multiple Trees';

            const generatedTrees = [];
            const totalTrees = multiTreeContexts.length;

            // Show progress UI
            modalBody.innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px;">ğŸŒ³</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 12px;">
                        Generating ${totalTrees} tree variations...
                    </div>
                    <div id="multi-tree-progress" style="font-size: 14px; color: var(--text-secondary); margin-bottom: 20px;">
                        Preparing first tree...
                    </div>
                    <div style="width: 100%; background: var(--bg-secondary); border-radius: 8px; height: 8px; overflow: hidden;">
                        <div id="multi-tree-progress-bar" style="width: 0%; height: 100%; background: var(--treeplex-primary); transition: width 0.3s;"></div>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';

            // Process each tree variant
            for (let i = 0; i < multiTreeContexts.length; i++) {
                const ctx = multiTreeContexts[i];

                // Update progress
                document.getElementById('multi-tree-progress').textContent =
                    `Generating ${ctx.sliceIcon} ${ctx.sliceName} (${i + 1}/${totalTrees})...`;
                document.getElementById('multi-tree-progress-bar').style.width =
                    `${((i + 0.5) / totalTrees) * 100}%`;

                // Set context for this tree
                window.smartImportContext = ctx.context;

                try {
                    const treeResult = await generateTreeWithAI(text.substring(0, 8000), ctx);

                    if (treeResult) {
                        generatedTrees.push({
                            sliceId: ctx.sliceId,
                            sliceName: ctx.sliceName,
                            sliceIcon: ctx.sliceIcon,
                            tree: treeResult
                        });
                    }
                } catch (err) {
                    console.error(`Error generating tree for ${ctx.sliceName}:`, err);
                }

                // Update progress
                document.getElementById('multi-tree-progress-bar').style.width =
                    `${((i + 1) / totalTrees) * 100}%`;
            }

            // Reset context
            window.smartImportContext = '';

            // Show completion and offer downloads
            showMultiTreeCompletion(generatedTrees);
        }

        // =============================================================================
        // EXCEL IMPORT - Import from Excel back to TreeListy
        // =============================================================================

        // =============================================================================
        // FLEXIBLE EXCEL IMPORT - Import ANY Excel file with column mapping
        // =============================================================================

        let excelImportState = {
            workbook: null,
            file: null,
            selectedSheet: null,
            headers: [],
            sampleData: [],
            columnMapping: {},
            hierarchyConfig: {},
            pattern: null,
            aiAnalysis: null,  // NEW: Store AI analysis results
            aiAnalysisInProgress: false
        };

        // =============================================================================
        // AI-POWERED EXCEL ANALYSIS (Build 241)
        // =============================================================================

        async function aiAnalyzeExcelStructure(headers, sampleRows) {
            console.log('ğŸ¤– Starting AI analysis of Excel structure...');

            // Build pattern descriptions for the AI
            const patternDescriptions = Object.entries(PATTERNS).map(([key, p]) => {
                const fieldNames = Object.keys(p.fields || {}).filter(f =>
                    !['includeDependencies', 'includeTracking', 'trackingFor'].includes(f)
                ).slice(0, 8).join(', ');
                return `â€¢ ${key}: ${p.name} (fields: ${fieldNames || 'basic'})`;
            }).join('\n');

            const systemPrompt = `You are an expert data analyst helping import Excel spreadsheets into TreeListy, a hierarchical project management tool.

TreeListy organizes data into: Root â†’ Phases â†’ Items â†’ Subtasks
Each item can have pattern-specific fields like cost, dates, descriptions, etc.

Available patterns:
${patternDescriptions}

PATTERN DETECTION HINTS:
- capex: Look for Budget/Actual/Variance columns, CAPEX/OPEX terminology, Cost/Investment/ROI fields, Funding Phase/Seed/Series terms, Risk/Mitigation columns, WBS codes, project financial tracking
- sales: Look for Deal Value, Close Date, Pipeline, Quarter columns, Probability/Stage fields
- philosophy: Look for philosophical concepts, arguments, objections, sources, thinkers
- thesis: Look for chapters, sections, word counts, citations, academic structure
- roadmap: Look for Features, Story Points, Sprints, Quarters, technical terms
- generic: Use when data has project phases but doesn't clearly match other patterns

Your job: Analyze the Excel structure and suggest the best import configuration.`;

            const userPrompt = `Analyze this Excel data and suggest how to import it into TreeListy.

COLUMN HEADERS:
${headers.map((h, i) => `${i}: "${h}"`).join('\n')}

SAMPLE DATA (first ${sampleRows.length} rows):
${sampleRows.map((row, i) => `Row ${i + 1}: ${JSON.stringify(row.slice(0, headers.length))}`).join('\n')}

Respond with ONLY valid JSON (no markdown, no explanation):
{
  "recommendedPattern": "pattern_key (e.g., generic, capex, sales, philosophy, roadmap)",
  "patternConfidence": 0.85,
  "patternReason": "Brief explanation why this pattern fits",
  "columnMappings": {
    "itemName": {"column": 0, "confidence": 0.95, "reason": "Contains task/item names"},
    "phaseName": {"column": 2, "confidence": 0.80, "reason": "Groups items by category"},
    "description": {"column": null, "confidence": 0, "reason": "No description column found"}
  },
  "hierarchyDetection": {
    "hasPhases": true,
    "phaseColumn": 2,
    "estimatedPhaseCount": 4,
    "note": "Detected quarterly grouping"
  },
  "dataQuality": {
    "totalRows": ${sampleRows.length},
    "issues": ["Column X has 20% empty values"]
  }
}

IMPORTANT:
- Column numbers are 0-indexed
- Only map columns that clearly match - use null for uncertain mappings
- Focus on: itemName (required), phaseName, description, and pattern-specific fields
- Pattern-specific fields to look for based on detected pattern`;

            try {
                const response = await callClaudeAPI(userPrompt, systemPrompt, 1024, false);

                // Parse JSON from response (handle potential markdown wrapping)
                let jsonStr = response.trim();
                if (jsonStr.startsWith('```')) {
                    jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                }

                const analysis = JSON.parse(jsonStr);
                console.log('ğŸ¤– AI Analysis complete:', analysis);
                return analysis;
            } catch (error) {
                console.error('âŒ AI Excel analysis failed:', error);
                return null;
            }
        }

        function applyAIAnalysisToMapping(aiAnalysis, headers) {
            if (!aiAnalysis || !aiAnalysis.columnMappings) return null;

            const mapping = {
                itemName: null,
                phaseName: null,
                description: null,
                itemType: null,
                dependencies: null
            };

            // Apply AI-suggested mappings
            Object.entries(aiAnalysis.columnMappings).forEach(([fieldKey, fieldData]) => {
                if (fieldData && fieldData.column !== null && fieldData.confidence >= 0.5) {
                    mapping[fieldKey] = fieldData.column;
                }
            });

            return mapping;
        }

        function importFromExcel(file) {
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });

                    console.log('ğŸ“¥ Excel workbook loaded:', workbook.SheetNames);

                    excelImportState.workbook = workbook;
                    excelImportState.file = file.name;

                    // Check if this is a TreeListy export (fast automatic import)
                    if (workbook.SheetNames.includes('ğŸ“‹ Detailed Items')) {
                        console.log('âœ… TreeListy export detected - importing automatically');
                        importTreeListyExcel(workbook);
                        return;
                    }

                    // BUILD 353: Launch Smart Import Wizard for non-TreeListy Excel files
                    console.log('ğŸ“‹ Generic Excel file - launching Smart Import Wizard');
                    const analysis = analyzeExcelContent(workbook, file.name);

                    // BUILD 354: Pass workbook for multi-tree slice detection
                    showSmartImportWizard(analysis, false, (userAnswers) => {
                        // BUILD 354: Handle multi-tree mode
                        if (userAnswers.multiTreeMode && userAnswers.multiTreeContexts) {
                            console.log('ğŸŒ³ Multi-tree mode: generating', userAnswers.multiTreeContexts.length, 'trees');
                            proceedWithMultiTreeExcelImport(workbook, userAnswers.multiTreeContexts);
                        } else {
                            // After wizard completes, proceed to flexible import with context set
                            console.log('ğŸ” Smart Import Wizard complete, proceeding to import');
                            startFlexibleImportWizard(workbook);
                        }
                    }, { workbook: workbook });

                } catch (err) {
                    console.error('âŒ Excel import error:', err);
                    alert('âŒ Failed to read Excel file!\n\n' + err.message);
                }
            };

            reader.readAsArrayBuffer(file);
        }

        function showImportModeChoice(workbook) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ“¥ Excel Import Mode';

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 24px;">
                        This appears to be a TreeListy export. Choose how to import:
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="import-mode-fast" style="flex: 1; padding: 20px; border: 2px solid var(--treeplex-primary); border-radius: 12px; cursor: pointer; transition: all 0.2s; background: rgba(0, 166, 125, 0.05);">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">âš¡</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Fast Import
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Automatically import using TreeListy format. Perfect fidelity, instant import.
                            </div>
                        </div>

                        <div id="import-mode-custom" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">ğŸ¯</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Custom Mapping
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Map columns manually, customize field mappings, handle custom formats.
                            </div>
                        </div>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Hover effects
            ['import-mode-fast', 'import-mode-custom'].forEach(id => {
                const elem = document.getElementById(id);
                elem.addEventListener('mouseenter', () => {
                    elem.style.transform = 'translateY(-2px)';
                    elem.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
                });
                elem.addEventListener('mouseleave', () => {
                    elem.style.transform = 'translateY(0)';
                    elem.style.boxShadow = 'none';
                });
            });

            // Fast import handler
            document.getElementById('import-mode-fast').addEventListener('click', () => {
                modal.style.display = 'none';
                importTreeListyExcel(workbook);
            });

            // Custom import handler
            document.getElementById('import-mode-custom').addEventListener('click', () => {
                modal.style.display = 'none';
                startFlexibleImportWizard(workbook);
            });
        }

        function importTreeListyExcel(workbook) {
            try {

                    // Parse the "ğŸ“‹ Detailed Items" sheet
                    const itemsSheet = workbook.Sheets['ğŸ“‹ Detailed Items'];
                    const itemsData = XLSX.utils.sheet_to_json(itemsSheet, { header: 1 });

                    console.log('ğŸ“‹ Parsed items data:', itemsData.length, 'rows');

                    // Find the header row (contains "Item Name")
                    let headerRowIndex = -1;
                    for (let i = 0; i < itemsData.length; i++) {
                        if (itemsData[i][0] === 'Item Name') {
                            headerRowIndex = i;
                            break;
                        }
                    }

                    if (headerRowIndex === -1) {
                        alert('âŒ Invalid Excel format!\n\nCould not find the "Item Name" header row.');
                        return;
                    }

                    const headers = itemsData[headerRowIndex];
                    console.log('ğŸ“‹ Headers:', headers);

                    // Parse items (skip header and empty rows)
                    const items = [];
                    for (let i = headerRowIndex + 1; i < itemsData.length; i++) {
                        const row = itemsData[i];

                        // Skip empty rows or total row
                        if (!row[0] || row[0] === 'TOTAL') continue;

                        const item = {};
                        headers.forEach((header, index) => {
                            if (header && row[index] !== undefined && row[index] !== '') {
                                item[header] = row[index];
                            }
                        });

                        items.push(item);
                    }

                    console.log('âœ… Parsed', items.length, 'items from Excel');

                    // Detect pattern from the data structure
                    const detectedPattern = detectPatternFromExcel(items, headers);
                    console.log('ğŸ¨ Detected pattern:', detectedPattern);

                    // Convert items to tree structure
                    const newTree = convertExcelToTree(items, detectedPattern);

                    // Auto-import TreeListy exports (simple confirmation only)
                    const confirmMsg = `Import ${items.length} items from Excel?\n\nThis will replace your current tree.`;
                    if (confirm(confirmMsg)) {
                        saveState('Excel Import');
                        capexTree = newTree;
                        currentPattern = detectedPattern;
                        document.getElementById('pattern-select').value = detectedPattern;
                        render();
                        showToast(`âœ… Excel imported! ${items.length} items loaded`);
                        console.log('âœ… TreeListy export auto-imported');
                    }

            } catch (err) {
                console.error('âŒ Excel import error:', err);
                alert('âŒ Failed to import Excel file!\n\n' + err.message + '\n\nPlease ensure this is a valid TreeListy Excel export.');
            }
        }

        function detectPatternFromExcel(items, headers) {
            // Check for pattern-specific columns
            if (headers.includes('Deal Value ($)') || headers.includes('Stage Probability (%)')) {
                return 'sales';
            } else if (headers.includes('Word Count') || headers.includes('Draft Status')) {
                return 'thesis';
            } else if (headers.includes('Story Points') || headers.includes('Engineering Estimate')) {
                return 'roadmap';
            } else if (headers.includes('Use Case') || headers.includes('Target Model')) {
                return 'prompt';
            } else if (headers.includes('Chapter Number') || headers.includes('Section Type')) {
                return 'book';
            } else if (headers.includes('Argument Type') || headers.includes('Philosophical School')) {
                return 'philosophy';
            } else if (headers.includes('KPI') || headers.includes('Strategic Priority')) {
                return 'strategy';
            } else if (headers.includes('Cost ($M)') && headers.includes('Lead Time')) {
                return 'generic';
            }

            // Default to current pattern
            return currentPattern;
        }

        function convertExcelToTree(items, pattern) {
            const patternDef = PATTERNS[pattern];
            const levels = patternDef.levels;

            // Group items by phase
            const phaseMap = {};

            items.forEach(item => {
                const phaseName = item.Phase || item[levels.phase];

                if (!phaseName) return;

                // Extract phase number and subtitle if present
                const phaseMatch = phaseName.match(/^(.+?)\s*\((.*?)\)$/);
                const basePhaseName = phaseMatch ? phaseMatch[1].trim() : phaseName;
                const phaseSubtitle = phaseMatch ? phaseMatch[2].trim() : '';

                if (!phaseMap[basePhaseName]) {
                    phaseMap[basePhaseName] = {
                        name: basePhaseName,
                        subtitle: phaseSubtitle,
                        items: []
                    };
                }

                // Convert item data back to tree format
                const treeItem = {
                    name: item['Item Name'] || item.name || 'Unnamed Item',
                    description: item.Description || item.description || '',
                    type: 'item',
                    icon: 'ğŸ“¦'
                };

                // Map pattern-specific fields dynamically
                const fields = patternDef.fields;
                if (fields) {
                    Object.keys(fields).forEach(fieldKey => {
                        const fieldConfig = fields[fieldKey];

                        // Skip non-field properties
                        if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                            return;
                        }

                        const excelColumnName = fieldConfig.label;

                        if (item[excelColumnName] !== undefined && item[excelColumnName] !== '' && item[excelColumnName] !== null) {
                            let value = item[excelColumnName];

                            // Convert numeric fields
                            if (fieldConfig.type === 'number') {
                                // Handle cost (exported in millions, import back to raw)
                                if (fieldKey === 'cost' && fieldConfig.label.includes('($M)')) {
                                    value = parseFloat(value) * 1000000;
                                } else if (fieldKey === 'dealValue') {
                                    // dealValue exported in thousands, import back to raw
                                    value = parseFloat(value) * 1000;
                                } else {
                                    value = parseFloat(value);
                                }
                            } else if (fieldConfig.type === 'date') {
                                // Keep dates as-is (Excel format)
                                value = value;
                            } else if (fieldConfig.type === 'select') {
                                // Ensure select value is string
                                value = value.toString();
                            } else if (fieldConfig.type === 'textarea') {
                                // Textarea values are already strings
                                value = value.toString();
                            } else {
                                // Text fields
                                value = value.toString();
                            }

                            treeItem[fieldKey] = value;
                        }
                    });
                }

                // Handle dependencies
                if (item.Dependencies && item.Dependencies !== 'None') {
                    treeItem.dependencies = item.Dependencies.split(', ').map(d => d.trim());
                }

                // Handle item type
                if (item.Type) {
                    treeItem.itemType = item.Type;
                }

                phaseMap[basePhaseName].items.push(treeItem);
            });

            // Convert phase map to tree structure
            const phases = Object.values(phaseMap).map((phase, index) => {
                return {
                    id: `phase-${index}`,
                    type: 'phase',
                    phase: index,
                    name: phase.name,
                    subtitle: phase.subtitle,
                    icon: `${index + 1}ï¸âƒ£`,
                    expanded: false,
                    items: phase.items.map((item, itemIndex) => ({
                        ...item,
                        id: `item-${index}-${itemIndex}`
                    }))
                };
            });

            // Create new tree
            const newTree = {
                id: 'root',
                type: 'root',
                name: items[0]?.Project || capexTree.name || 'Imported Project',
                icon: 'ğŸŒ³',
                expanded: true,
                children: phases,
                pattern: {
                    key: pattern,
                    labels: levels
                }
            };

            return newTree;
        }

        function showImportConfirmation(newTree, itemCount, pattern) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ“¥ Import from Excel';

            const patternInfo = PATTERNS[pattern];
            const phaseCount = newTree.children?.length || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 20px; border-radius: 12px; margin-bottom: 24px;">
                        <h3 style="margin: 0 0 12px 0; color: var(--treeplex-primary);">ğŸ“Š Import Summary</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 14px;">
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">Pattern Detected</div>
                                <div style="font-weight: 600;">${patternInfo.icon} ${patternInfo.levels.root}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">${patternInfo.levels.phase}s</div>
                                <div style="font-weight: 600;">${phaseCount}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">${patternInfo.levels.item}s</div>
                                <div style="font-weight: 600;">${itemCount}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">Project Name</div>
                                <div style="font-weight: 600;">${newTree.name}</div>
                            </div>
                        </div>
                    </div>

                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 24px; border-left: 3px solid var(--treeplex-primary);">
                        <p style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600;">Import Mode</p>
                        <p style="margin: 0 0 16px 0; font-size: 13px; color: var(--text-secondary);">
                            How would you like to import this Excel file?
                        </p>

                        <div style="display: flex; gap: 12px;">
                            <button id="import-replace-btn" class="btn" style="flex: 1; background: linear-gradient(135deg, #f59e0b, #d97706); padding: 12px;">
                                ğŸ”„ Replace Current Tree
                            </button>
                            <button id="import-append-btn" class="btn" style="flex: 1; background: linear-gradient(135deg, var(--treeplex-primary), #059669); padding: 12px;">
                                â• Append to Current Tree
                            </button>
                        </div>
                    </div>

                    <div style="background: rgba(239, 68, 68, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #ef4444;">
                        <p style="margin: 0; font-size: 12px; color: var(--text-secondary);">
                            âš ï¸ <strong>Replace</strong> will overwrite your current project. <strong>Append</strong> will add items to existing phases.
                        </p>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Handle replace
            document.getElementById('import-replace-btn').addEventListener('click', () => {
                saveState('Excel Import: Replace');

                // Replace tree
                capexTree = newTree;
                currentPattern = pattern;
                document.getElementById('pattern-select').value = pattern;

                render();
                modal.style.display = 'none';

                showToast(`âœ… Excel imported! ${itemCount} items loaded`);
                console.log('âœ… Excel import complete (replace mode)');
            });

            // Handle append
            document.getElementById('import-append-btn').addEventListener('click', () => {
                saveState('Excel Import: Append');

                // Append phases and items
                newTree.children.forEach((newPhase, newPhaseIndex) => {
                    const existingPhase = capexTree.children?.[newPhaseIndex];

                    if (existingPhase) {
                        // Phase exists - append items
                        if (newPhase.items && newPhase.items.length > 0) {
                            const currentItemCount = existingPhase.items?.length || 0;

                            // Re-ID items
                            const reIdedItems = newPhase.items.map((item, idx) => ({
                                ...item,
                                id: `item-${newPhaseIndex}-${currentItemCount + idx}`
                            }));

                            existingPhase.items = [...(existingPhase.items || []), ...reIdedItems];
                        }
                    } else {
                        // Phase doesn't exist - add it
                        if (!capexTree.children) capexTree.children = [];
                        newPhase.id = `phase-${capexTree.children.length}`;
                        newPhase.phase = capexTree.children.length;
                        capexTree.children.push(newPhase);
                    }
                });

                render();
                modal.style.display = 'none';

                showToast(`âœ… Excel imported! ${itemCount} items added`);
                console.log('âœ… Excel import complete (append mode)');
            });
        }

        // =============================================================================
        // FLEXIBLE EXCEL IMPORT WIZARD - Import any Excel file with column mapping
        // =============================================================================

        function startFlexibleImportWizard(workbook) {
            console.log('ğŸ§™ Starting flexible import wizard...');

            excelImportState.workbook = workbook;
            excelImportState.multiSheetAnalysis = null;

            // If only one sheet, skip to column mapping
            if (workbook.SheetNames.length === 1) {
                analyzeSheetStructure(workbook.SheetNames[0]);
                return;
            }

            // Multiple sheets - check if AI is available
            const aiMode = document.getElementById('unified-ai-mode-select')?.value || '';
            const aiAvailable = aiMode && aiMode !== 'off';

            if (aiAvailable) {
                // AI analyzes all sheets and suggests how to combine
                analyzeMultipleSheetsWithAI(workbook);
            } else {
                // Fallback to manual sheet selection
                showSheetSelection(workbook);
            }
        }

        async function analyzeMultipleSheetsWithAI(workbook) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ¤– AI Analyzing Workbook...';
            modalBody.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <div class="spinner" style="margin: 0 auto 20px;"></div>
                    <p style="color: var(--text-secondary); font-size: 14px;">
                        AI is analyzing ${workbook.SheetNames.length} sheets to suggest the best import strategy...
                    </p>
                </div>
            `;
            modal.style.display = 'flex';

            // Gather info about each sheet
            const sheetsInfo = workbook.SheetNames.map(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                const headers = data[0]?.filter(h => h !== '' && h !== null && h !== undefined) || [];
                const sampleRows = data.slice(1, 4);
                const rowCount = data.length - 1;

                return {
                    name: sheetName,
                    headers,
                    sampleRows,
                    rowCount,
                    colCount: headers.length
                };
            });

            // Build AI prompt
            const systemPrompt = `You are an expert data analyst helping import a multi-sheet Excel workbook into TreeListy.

TreeListy organizes data hierarchically: Root â†’ Phases â†’ Items â†’ Subtasks
You need to analyze multiple sheets and recommend how to combine them.`;

            const userPrompt = `Analyze this Excel workbook with ${sheetsInfo.length} sheets and suggest how to import:

${sheetsInfo.map((s, i) => `
SHEET ${i + 1}: "${s.name}"
- Columns: ${s.headers.join(', ')}
- Rows: ${s.rowCount}
- Sample: ${JSON.stringify(s.sampleRows[0]?.slice(0, 6) || [])}
`).join('\n')}

Respond with ONLY valid JSON:
{
  "strategy": "combine_similar|separate_phases|single_primary|skip_some",
  "strategyReason": "Brief explanation of recommended approach",
  "sheets": [
    {
      "name": "Sheet1",
      "action": "import_as_phase|combine_with|skip|primary",
      "combineWith": null,
      "phaseNameSuggestion": "Suggested phase name",
      "importance": "primary|secondary|reference|skip",
      "reason": "Why this action"
    }
  ],
  "recommendedPattern": "generic|sales|philosophy|etc",
  "patternConfidence": 0.85,
  "warnings": ["Any issues or notes"]
}

STRATEGIES:
- combine_similar: Sheets with same structure merge into one phase
- separate_phases: Each sheet becomes its own phase
- single_primary: One main sheet, others are reference/skip
- skip_some: Some sheets aren't useful for import`;

            try {
                const response = await callClaudeAPI(userPrompt, systemPrompt, 1500, false);

                let jsonStr = response.trim();
                if (jsonStr.startsWith('```')) {
                    jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                }

                const analysis = JSON.parse(jsonStr);
                console.log('ğŸ¤– Multi-sheet analysis:', analysis);

                excelImportState.multiSheetAnalysis = analysis;
                showMultiSheetStrategyUI(workbook, analysis, sheetsInfo);

            } catch (error) {
                console.error('âŒ Multi-sheet AI analysis failed:', error);
                // Fall back to manual selection
                showSheetSelection(workbook);
            }
        }

        function showMultiSheetStrategyUI(workbook, analysis, sheetsInfo) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ¤– AI Import Strategy';

            const strategyLabels = {
                'combine_similar': 'ğŸ”— Combine Similar Sheets',
                'separate_phases': 'ğŸ“ Each Sheet â†’ Phase',
                'single_primary': 'â­ Focus on Primary Sheet',
                'skip_some': 'ğŸ¯ Selective Import'
            };

            const actionIcons = {
                'import_as_phase': 'ğŸ“',
                'combine_with': 'ğŸ”—',
                'skip': 'â­ï¸',
                'primary': 'â­'
            };

            const importanceColors = {
                'primary': '#10b981',
                'secondary': '#6366f1',
                'reference': '#f59e0b',
                'skip': '#6b7280'
            };

            // Build sheet cards
            let sheetsHTML = '';
            analysis.sheets.forEach((sheetAnalysis, idx) => {
                const sheetInfo = sheetsInfo.find(s => s.name === sheetAnalysis.name) || sheetsInfo[idx];
                const icon = actionIcons[sheetAnalysis.action] || 'ğŸ“„';
                const color = importanceColors[sheetAnalysis.importance] || '#6b7280';
                const isIncluded = sheetAnalysis.action !== 'skip';

                sheetsHTML += `
                    <div class="multi-sheet-card" data-sheet="${sheetAnalysis.name}" style="
                        padding: 12px 16px;
                        background: ${isIncluded ? 'rgba(16, 185, 129, 0.05)' : 'rgba(107, 114, 128, 0.05)'};
                        border: 1px solid ${isIncluded ? 'rgba(16, 185, 129, 0.2)' : 'rgba(107, 114, 128, 0.2)'};
                        border-radius: 8px;
                        margin-bottom: 8px;
                        opacity: ${isIncluded ? '1' : '0.6'};
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 18px;">${icon}</span>
                                <div>
                                    <div style="font-weight: 600; color: var(--text-primary);">${sheetAnalysis.name}</div>
                                    <div style="font-size: 11px; color: var(--text-secondary);">
                                        ${sheetInfo?.rowCount || '?'} rows â€¢ ${sheetInfo?.colCount || '?'} columns
                                    </div>
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 12px; color: ${color}; font-weight: 600;">
                                    ${sheetAnalysis.importance.toUpperCase()}
                                </div>
                                ${sheetAnalysis.phaseNameSuggestion ?
                                    `<div style="font-size: 11px; color: var(--text-secondary);">â†’ ${sheetAnalysis.phaseNameSuggestion}</div>` :
                                    ''}
                            </div>
                        </div>
                        <div style="font-size: 11px; color: var(--text-secondary); margin-top: 6px;">
                            ${sheetAnalysis.reason}
                        </div>
                    </div>
                `;
            });

            // Count what will be imported
            const importCount = analysis.sheets.filter(s => s.action !== 'skip').length;
            const totalRows = analysis.sheets
                .filter(s => s.action !== 'skip')
                .reduce((sum, s) => {
                    const info = sheetsInfo.find(si => si.name === s.name);
                    return sum + (info?.rowCount || 0);
                }, 0);

            // Warnings
            let warningsHTML = '';
            if (analysis.warnings?.length > 0) {
                warningsHTML = `
                    <div style="margin-top: 16px; padding: 12px; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 8px;">
                        <div style="font-size: 12px; font-weight: 600; color: #f59e0b; margin-bottom: 6px;">âš ï¸ Notes:</div>
                        ${analysis.warnings.map(w => `<div style="font-size: 12px; color: var(--text-secondary);">â€¢ ${w}</div>`).join('')}
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div style="padding: 20px; max-height: 75vh; overflow-y: auto;">
                    <!-- Strategy Banner -->
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 16px; border-radius: 12px; margin-bottom: 20px; border: 1px solid rgba(99, 102, 241, 0.2);">
                        <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">
                            ${strategyLabels[analysis.strategy] || analysis.strategy}
                        </div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            ${analysis.strategyReason}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
                            ğŸ“Š Importing ${importCount} of ${analysis.sheets.length} sheets â€¢ ~${totalRows} total rows
                            ${analysis.recommendedPattern ? ` â€¢ Pattern: <strong>${PATTERNS[analysis.recommendedPattern]?.name || analysis.recommendedPattern}</strong>` : ''}
                        </div>
                    </div>

                    <!-- Sheet Cards -->
                    <div style="margin-bottom: 16px;">
                        ${sheetsHTML}
                    </div>

                    ${warningsHTML}

                    <!-- Action Buttons -->
                    <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between;">
                        <button id="multi-sheet-manual-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                            ğŸ“‹ Pick Sheets Manually
                        </button>
                        <div style="display: flex; gap: 12px;">
                            <button id="multi-sheet-cancel-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                                Cancel
                            </button>
                            <button id="multi-sheet-proceed-btn" style="padding: 10px 24px; border: none; border-radius: 8px; background: linear-gradient(135deg, #10b981, #059669); color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                                âœ“ Proceed with AI Strategy
                            </button>
                        </div>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Event handlers
            document.getElementById('multi-sheet-cancel-btn').addEventListener('click', () => {
                modal.style.display = 'none';
            });

            document.getElementById('multi-sheet-manual-btn').addEventListener('click', () => {
                showSheetSelection(workbook);
            });

            document.getElementById('multi-sheet-proceed-btn').addEventListener('click', () => {
                executeMultiSheetImport(workbook, analysis, sheetsInfo);
            });
        }

        async function executeMultiSheetImport(workbook, analysis, sheetsInfo) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            // Apply recommended pattern
            if (analysis.recommendedPattern && PATTERNS[analysis.recommendedPattern]) {
                document.getElementById('pattern-select').value = analysis.recommendedPattern;
                currentPattern = analysis.recommendedPattern;
            }

            // Get sheets to import
            const sheetsToImport = analysis.sheets.filter(s => s.action !== 'skip');

            if (sheetsToImport.length === 0) {
                alert('No sheets selected for import');
                return;
            }

            // If only one sheet to import, use standard flow
            if (sheetsToImport.length === 1) {
                analyzeSheetStructure(sheetsToImport[0].name);
                return;
            }

            // Multiple sheets - show progress and import each
            modalTitle.textContent = 'ğŸ¤– Importing Multiple Sheets...';
            modalBody.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <div class="spinner" style="margin: 0 auto 20px;"></div>
                    <p style="color: var(--text-secondary); font-size: 14px;">
                        Processing ${sheetsToImport.length} sheets...
                    </p>
                    <div id="multi-import-progress" style="margin-top: 16px; font-size: 13px; color: var(--text-secondary);"></div>
                </div>
            `;

            const progressEl = document.getElementById('multi-import-progress');
            const allItems = [];
            const phaseMap = {};

            for (let i = 0; i < sheetsToImport.length; i++) {
                const sheetConfig = sheetsToImport[i];
                const sheetName = sheetConfig.name;
                progressEl.textContent = `Analyzing: ${sheetName} (${i + 1}/${sheetsToImport.length})`;

                const sheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                // Find headers
                let headerRowIndex = 0;
                for (let j = 0; j < data.length; j++) {
                    if (data[j] && data[j].some(cell => cell !== '' && cell !== null && cell !== undefined)) {
                        headerRowIndex = j;
                        break;
                    }
                }

                const headers = data[headerRowIndex].filter(h => h !== '' && h !== null && h !== undefined);
                const rows = data.slice(headerRowIndex + 1);

                // Quick AI analysis for column mapping
                const sampleRows = rows.slice(0, 5);

                try {
                    const aiAnalysis = await aiAnalyzeExcelStructure(headers, sampleRows);

                    if (aiAnalysis?.columnMappings) {
                        const mapping = applyAIAnalysisToMapping(aiAnalysis, headers);

                        // Determine phase name
                        const phaseName = sheetConfig.phaseNameSuggestion || sheetName;

                        // Extract items
                        rows.forEach(row => {
                            if (!row || row.every(cell => !cell)) return;

                            const itemName = mapping.itemName !== null ? row[mapping.itemName] : null;
                            if (!itemName) return;

                            const item = {
                                name: String(itemName),
                                description: mapping.description !== null ? String(row[mapping.description] || '') : '',
                                type: mapping.itemType !== null ? String(row[mapping.itemType] || '') : '',
                                sourceSheet: sheetName
                            };

                            // Add pattern-specific fields
                            Object.keys(mapping).forEach(key => {
                                if (!['itemName', 'phaseName', 'description', 'itemType', 'dependencies'].includes(key)) {
                                    if (mapping[key] !== null && row[mapping[key]]) {
                                        item[key] = row[mapping[key]];
                                    }
                                }
                            });

                            if (!phaseMap[phaseName]) phaseMap[phaseName] = [];
                            phaseMap[phaseName].push(item);
                            allItems.push(item);
                        });
                    }
                } catch (error) {
                    console.warn(`âš ï¸ Failed to analyze sheet ${sheetName}:`, error);
                }
            }

            // Build final tree
            progressEl.textContent = 'Building tree structure...';

            const patternDef = PATTERNS[currentPattern];
            const phases = Object.keys(phaseMap).map((phaseName, phaseIndex) => ({
                id: `phase-${phaseIndex}`,
                type: 'phase',
                phase: phaseIndex,
                name: phaseName,
                subtitle: `${phaseMap[phaseName].length} items`,
                icon: `${phaseIndex + 1}ï¸âƒ£`,
                expanded: false,
                items: phaseMap[phaseName].map((item, itemIndex) => ({
                    ...item,
                    id: `item-${phaseIndex}-${itemIndex}`,
                    type: 'item'
                }))
            }));

            saveState('Multi-sheet Excel Import');

            capexTree = {
                id: 'root',
                type: 'root',
                name: `Imported from ${excelImportState.file}`,
                icon: 'ğŸŒ³',
                expanded: true,
                hyperedges: [],
                children: phases,
                pattern: {
                    key: currentPattern,
                    labels: patternDef.levels
                }
            };

            render();
            modal.style.display = 'none';

            showToast(`âœ… Imported ${allItems.length} items from ${sheetsToImport.length} sheets into ${phases.length} phases`);
        }

        function showSheetSelection(workbook) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ“‘ Select Sheet to Import';

            let sheetsHTML = '';
            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                const rowCount = data.length;
                const colCount = data[0]?.length || 0;

                // Preview first 3 rows
                const preview = data.slice(0, 3)
                    .map(row => row.slice(0, 5).join(', '))
                    .join('<br>');

                sheetsHTML += `
                    <div class="sheet-option" data-sheet="${sheetName}" style="border: 2px solid var(--border); padding: 16px; margin-bottom: 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 8px;">${sheetName}</div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                            ${rowCount} rows Ã— ${colCount} columns
                        </div>
                        <div style="font-size: 11px; font-family: monospace; color: var(--text-secondary); max-height: 60px; overflow: hidden;">
                            ${preview}
                        </div>
                    </div>
                `;
            });

            modalBody.innerHTML = `<div style="padding: 20px;">${sheetsHTML}</div>`;
            modal.style.display = 'flex';

            // Add click handlers
            document.querySelectorAll('.sheet-option').forEach(elem => {
                elem.addEventListener('click', () => {
                    const sheetName = elem.dataset.sheet;
                    analyzeSheetStructure(sheetName);
                });

                // Hover effect
                elem.addEventListener('mouseenter', () => {
                    elem.style.borderColor = 'var(--treeplex-primary)';
                    elem.style.background = 'rgba(0, 166, 125, 0.05)';
                });
                elem.addEventListener('mouseleave', () => {
                    elem.style.borderColor = 'var(--border)';
                    elem.style.background = 'transparent';
                });
            });
        }

        async function analyzeSheetStructure(sheetName) {
            const sheet = excelImportState.workbook.Sheets[sheetName];
            const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            console.log('ğŸ“Š Analyzing sheet:', sheetName);

            // Find header row (first non-empty row)
            let headerRowIndex = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] && data[i].some(cell => cell !== '' && cell !== null && cell !== undefined)) {
                    headerRowIndex = i;
                    break;
                }
            }

            const headers = data[headerRowIndex].filter(h => h !== '' && h !== null && h !== undefined);
            const sampleData = data.slice(headerRowIndex + 1, headerRowIndex + 11); // 10 sample rows for AI

            console.log('ğŸ“‹ Found headers:', headers);
            console.log('ğŸ“‹ Sample data rows:', sampleData.length);

            excelImportState.selectedSheet = sheetName;
            excelImportState.headers = headers;
            excelImportState.sampleData = sampleData;
            excelImportState.aiAnalysis = null;

            // Check if AI is available (any provider configured)
            const aiMode = document.getElementById('unified-ai-mode-select')?.value || '';
            const aiAvailable = aiMode && aiMode !== 'off';

            if (aiAvailable) {
                // Show loading state
                showAIAnalysisLoading();

                try {
                    // Call AI to analyze structure
                    const aiAnalysis = await aiAnalyzeExcelStructure(headers, sampleData);
                    excelImportState.aiAnalysis = aiAnalysis;

                    if (aiAnalysis) {
                        // Apply AI-suggested mappings
                        const aiMappings = applyAIAnalysisToMapping(aiAnalysis, headers);
                        if (aiMappings) {
                            excelImportState.columnMapping = aiMappings;
                        }

                        // If AI recommends a different pattern, offer to switch
                        if (aiAnalysis.recommendedPattern && aiAnalysis.patternConfidence >= 0.7) {
                            const recommendedKey = aiAnalysis.recommendedPattern.toLowerCase().replace(/[^a-z]/g, '');
                            if (PATTERNS[recommendedKey] && recommendedKey !== currentPattern) {
                                console.log(`ğŸ¤– AI recommends pattern: ${recommendedKey} (${(aiAnalysis.patternConfidence * 100).toFixed(0)}% confidence)`);
                            }
                        }

                        // Show AI-enhanced mapping UI
                        showAIEnhancedMappingUI();
                        return;
                    }
                } catch (error) {
                    console.warn('âš ï¸ AI analysis failed, falling back to keyword matching:', error);
                }
            }

            // Fallback: Use keyword-based auto-suggest
            const suggestedMappings = autoSuggestColumnMappings(headers);
            excelImportState.columnMapping = suggestedMappings;

            console.log('ğŸ¯ Suggested mappings (keyword-based):', suggestedMappings);

            // Show standard column mapping UI
            showColumnMappingUI();
        }

        function showAIAnalysisLoading() {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ¤– AI Analyzing Excel Structure...';
            modalBody.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <div class="spinner" style="margin: 0 auto 20px;"></div>
                    <p style="color: var(--text-secondary); font-size: 14px;">
                        AI is analyzing your spreadsheet to suggest the best import configuration...
                    </p>
                    <p style="color: var(--text-secondary); font-size: 12px; margin-top: 12px; opacity: 0.7;">
                        Detecting patterns, mapping columns, identifying hierarchy...
                    </p>
                </div>
            `;
            modal.style.display = 'flex';
        }

        function showAIEnhancedMappingUI() {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            const aiAnalysis = excelImportState.aiAnalysis;
            const headers = excelImportState.headers;
            const mapping = excelImportState.columnMapping;

            modalTitle.textContent = 'ğŸ¤– AI-Detected Import Configuration';

            // Build confidence badge
            const confidence = aiAnalysis?.patternConfidence || 0;
            const confidenceColor = confidence >= 0.8 ? '#10b981' : confidence >= 0.6 ? '#f59e0b' : '#ef4444';
            const confidencePercent = (confidence * 100).toFixed(0);

            // Build pattern recommendation
            const recommendedPattern = aiAnalysis?.recommendedPattern || currentPattern;
            const patternDef = PATTERNS[recommendedPattern] || PATTERNS[currentPattern];
            const patternReason = aiAnalysis?.patternReason || '';

            // Build mapping cards
            let mappingCardsHTML = '';
            const coreMappings = [
                { key: 'itemName', label: 'Item Name', required: true, icon: 'ğŸ“' },
                { key: 'phaseName', label: 'Phase/Category', required: false, icon: 'ğŸ“' },
                { key: 'description', label: 'Description', required: false, icon: 'ğŸ“„' }
            ];

            coreMappings.forEach(({ key, label, required, icon }) => {
                const colIndex = mapping[key];
                const colName = colIndex !== null ? headers[colIndex] : null;
                const aiData = aiAnalysis?.columnMappings?.[key];
                const confidence = aiData?.confidence || 0;
                const reason = aiData?.reason || '';

                const isMapped = colIndex !== null;
                const bgColor = isMapped ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)';
                const borderColor = isMapped ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)';

                mappingCardsHTML += `
                    <div class="ai-mapping-card" data-field="${key}" style="padding: 12px 16px; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 16px; margin-right: 8px;">${icon}</span>
                                <strong style="color: var(--text-primary);">${label}</strong>
                                ${required ? '<span style="color: #ef4444; margin-left: 4px;">*</span>' : ''}
                            </div>
                            <div style="text-align: right;">
                                ${isMapped ?
                                    `<span style="color: #10b981; font-weight: 600;">"${colName}"</span>
                                     <span style="color: var(--text-secondary); font-size: 11px; margin-left: 8px;">${(confidence * 100).toFixed(0)}%</span>` :
                                    `<span style="color: #ef4444;">Not mapped</span>`
                                }
                            </div>
                        </div>
                        ${reason ? `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px; padding-left: 28px;">${reason}</div>` : ''}
                    </div>
                `;
            });

            // Add pattern-specific field mappings
            const fields = patternDef.fields || {};
            const mappedPatternFields = Object.entries(fields)
                .filter(([key]) => !['includeDependencies', 'includeTracking', 'trackingFor'].includes(key))
                .filter(([key]) => mapping[key] !== null && mapping[key] !== undefined)
                .slice(0, 5);

            if (mappedPatternFields.length > 0) {
                mappingCardsHTML += `<div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border);">
                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Pattern-specific fields detected:</div>`;

                mappedPatternFields.forEach(([key, fieldConfig]) => {
                    const colIndex = mapping[key];
                    const colName = headers[colIndex];
                    mappingCardsHTML += `
                        <div style="display: flex; justify-content: space-between; padding: 6px 0; font-size: 13px;">
                            <span style="color: var(--text-secondary);">${fieldConfig.label || key}</span>
                            <span style="color: #10b981;">"${colName}"</span>
                        </div>
                    `;
                });

                mappingCardsHTML += `</div>`;
            }

            // Data quality notes
            let qualityHTML = '';
            if (aiAnalysis?.dataQuality?.issues?.length > 0) {
                qualityHTML = `
                    <div style="margin-top: 16px; padding: 12px; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 8px;">
                        <div style="font-size: 12px; font-weight: 600; color: #f59e0b; margin-bottom: 6px;">âš ï¸ Data Quality Notes:</div>
                        ${aiAnalysis.dataQuality.issues.map(issue => `<div style="font-size: 12px; color: var(--text-secondary);">â€¢ ${issue}</div>`).join('')}
                    </div>
                `;
            }

            // Total row count
            const totalRows = XLSX.utils.sheet_to_json(excelImportState.workbook.Sheets[excelImportState.selectedSheet], { header: 1 }).length - 1;

            modalBody.innerHTML = `
                <div style="padding: 20px; max-height: 75vh; overflow-y: auto;">
                    <!-- AI Confidence Banner -->
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 16px; border-radius: 12px; margin-bottom: 20px; border: 1px solid rgba(99, 102, 241, 0.2);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div style="font-weight: 600; color: var(--text-primary);">
                                ğŸ¤– AI Detected: <span style="color: #8b5cf6;">${patternDef.name}</span>
                            </div>
                            <div style="background: ${confidenceColor}; color: white; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600;">
                                ${confidencePercent}% confidence
                            </div>
                        </div>
                        ${patternReason ? `<div style="font-size: 13px; color: var(--text-secondary);">${patternReason}</div>` : ''}
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
                            ğŸ“Š Sheet: <strong>${excelImportState.selectedSheet}</strong> â€¢ ${totalRows} rows
                        </div>
                    </div>

                    <!-- Column Mappings -->
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 12px;">
                            Column Mappings <span style="font-weight: 400; color: var(--text-secondary); font-size: 12px;">(click to adjust)</span>
                        </div>
                        ${mappingCardsHTML}
                    </div>

                    ${qualityHTML}

                    <!-- Action Buttons -->
                    <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between;">
                        <button id="ai-import-adjust-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                            âš™ï¸ Adjust Mappings
                        </button>
                        <div style="display: flex; gap: 12px;">
                            <button id="ai-import-cancel-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                                Cancel
                            </button>
                            <button id="ai-import-confirm-btn" style="padding: 10px 24px; border: none; border-radius: 8px; background: linear-gradient(135deg, #10b981, #059669); color: white; cursor: pointer; font-size: 14px; font-weight: 600;" ${mapping.itemName === null ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                                âœ“ Import ${totalRows} Items
                            </button>
                        </div>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Event handlers
            document.getElementById('ai-import-cancel-btn').addEventListener('click', () => {
                modal.style.display = 'none';
            });

            document.getElementById('ai-import-adjust-btn').addEventListener('click', () => {
                showColumnMappingUI(); // Fall back to detailed mapping UI
            });

            document.getElementById('ai-import-confirm-btn').addEventListener('click', () => {
                if (mapping.itemName === null) {
                    alert('âŒ Item Name mapping is required');
                    return;
                }
                // Apply recommended pattern if different
                if (aiAnalysis?.recommendedPattern) {
                    const recKey = aiAnalysis.recommendedPattern.toLowerCase().replace(/[^a-z]/g, '');
                    if (PATTERNS[recKey]) {
                        document.getElementById('pattern-select').value = recKey;
                        currentPattern = recKey;
                    }
                }
                previewFlexibleImport();
            });

            // Make mapping cards clickable to adjust individual mappings
            document.querySelectorAll('.ai-mapping-card').forEach(card => {
                card.addEventListener('click', () => {
                    const fieldKey = card.dataset.field;
                    showQuickFieldMapping(fieldKey);
                });
            });
        }

        function showQuickFieldMapping(fieldKey) {
            const headers = excelImportState.headers;
            const currentMapping = excelImportState.columnMapping[fieldKey];

            const fieldLabels = {
                itemName: 'Item Name',
                phaseName: 'Phase/Category',
                description: 'Description',
                itemType: 'Item Type',
                dependencies: 'Dependencies'
            };

            const options = headers.map((h, i) =>
                `<option value="${i}" ${currentMapping === i ? 'selected' : ''}>${h}</option>`
            ).join('');

            const popup = document.createElement('div');
            popup.id = 'quick-mapping-popup';
            popup.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--card-bg); padding: 24px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); z-index: 10001; min-width: 300px;';
            popup.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 16px; color: var(--text-primary);">
                    Map: ${fieldLabels[fieldKey] || fieldKey}
                </div>
                <select id="quick-mapping-select" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); color: var(--text-primary); font-size: 14px; margin-bottom: 16px;">
                    <option value="">-- Skip this field --</option>
                    ${options}
                </select>
                <div style="display: flex; gap: 8px; justify-content: flex-end;">
                    <button id="quick-mapping-cancel" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; background: transparent; color: var(--text-primary); cursor: pointer;">Cancel</button>
                    <button id="quick-mapping-apply" style="padding: 8px 16px; border: none; border-radius: 6px; background: var(--treeplex-primary); color: white; cursor: pointer; font-weight: 600;">Apply</button>
                </div>
            `;

            // Add overlay
            const overlay = document.createElement('div');
            overlay.id = 'quick-mapping-overlay';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000;';

            document.body.appendChild(overlay);
            document.body.appendChild(popup);

            overlay.addEventListener('click', () => {
                popup.remove();
                overlay.remove();
            });

            document.getElementById('quick-mapping-cancel').addEventListener('click', () => {
                popup.remove();
                overlay.remove();
            });

            document.getElementById('quick-mapping-apply').addEventListener('click', () => {
                const select = document.getElementById('quick-mapping-select');
                const value = select.value === '' ? null : parseInt(select.value);
                excelImportState.columnMapping[fieldKey] = value;
                popup.remove();
                overlay.remove();
                showAIEnhancedMappingUI(); // Refresh the UI
            });
        }

        function autoSuggestColumnMappings(headers) {
            const mapping = {
                itemName: null,
                phaseName: null,
                description: null,
                itemType: null,
                dependencies: null
            };

            // Get current pattern for field suggestions
            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};

            // Try to match each header to a TreeListy field
            headers.forEach((header, index) => {
                const headerLower = header.toLowerCase().trim();

                // Match core fields
                if (headerLower.includes('name') || headerLower.includes('title') || headerLower.includes('item')) {
                    if (!mapping.itemName) mapping.itemName = index;
                } else if (headerLower.includes('phase') || headerLower.includes('quarter') || headerLower.includes('stage') || headerLower.includes('chapter') || headerLower.includes('category')) {
                    if (!mapping.phaseName) mapping.phaseName = index;
                } else if (headerLower.includes('description') || headerLower.includes('notes') || headerLower.includes('details')) {
                    if (!mapping.description) mapping.description = index;
                } else if (headerLower.includes('type') || headerLower.includes('status')) {
                    if (!mapping.itemType) mapping.itemType = index;
                } else if (headerLower.includes('depend') || headerLower.includes('prerequisite')) {
                    if (!mapping.dependencies) mapping.dependencies = index;
                }

                // Try to match pattern-specific fields
                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    if (!mapping[fieldKey] && fieldConfig.label) {
                        const fieldLabelLower = fieldConfig.label.toLowerCase().replace(/[^a-z0-9]/g, '');
                        const headerSimplified = headerLower.replace(/[^a-z0-9]/g, '');

                        // Check for similarity
                        if (fieldLabelLower === headerSimplified ||
                            fieldLabelLower.includes(headerSimplified) ||
                            headerSimplified.includes(fieldLabelLower)) {
                            mapping[fieldKey] = index;
                        }
                    }
                });
            });

            console.log('ğŸ” Auto-detected mappings:', mapping);
            return mapping;
        }

        function showColumnMappingUI() {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ¯ Map Excel Columns to TreeListy Fields';

            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};
            const headers = excelImportState.headers;
            const sampleData = excelImportState.sampleData;
            const mapping = excelImportState.columnMapping;

            // Build mapping rows
            let mappingRowsHTML = '';

            // Core fields
            mappingRowsHTML += createMappingRow('Item Name', 'itemName', 'REQUIRED: Name of each item/task', mapping.itemName, true);
            mappingRowsHTML += createMappingRow('Phase/Category', 'phaseName', 'Group items by phase (optional)', mapping.phaseName, false);
            mappingRowsHTML += createMappingRow('Description', 'description', 'Item description', mapping.description, false);
            mappingRowsHTML += createMappingRow('Item Type', 'itemType', 'Type/category of item', mapping.itemType, false);

            // Pattern-specific fields
            Object.keys(fields).forEach(fieldKey => {
                const fieldConfig = fields[fieldKey];
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }

                if (fieldConfig.label) {
                    const helpText = fieldConfig.helpText || `${fieldConfig.label} field`;
                    mappingRowsHTML += createMappingRow(
                        fieldConfig.label,
                        fieldKey,
                        helpText,
                        mapping[fieldKey],
                        false
                    );
                }
            });

            // Dependencies
            mappingRowsHTML += createMappingRow('Dependencies', 'dependencies', 'Comma-separated list of dependencies', mapping.dependencies, false);

            modalBody.innerHTML = `
                <div style="padding: 20px; max-height: 70vh; overflow-y: auto;">
                    <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 16px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.6;">
                            ğŸ“‹ <strong>Sheet:</strong> ${excelImportState.selectedSheet}<br>
                            ğŸ¨ <strong>Pattern:</strong> ${patternDef.name}<br>
                            ğŸ“Š <strong>Rows:</strong> ${excelImportState.sampleData.length + ' (preview) / ' + (XLSX.utils.sheet_to_json(excelImportState.workbook.Sheets[excelImportState.selectedSheet], { header: 1 }).length - 1) + ' (total)'}
                        </div>
                    </div>

                    <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                        Map your Excel columns to TreeListy fields. We've pre-selected likely matches.
                    </p>

                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border);">
                                <th style="text-align: left; padding: 8px; font-size: 13px; color: var(--text-secondary);">TreeListy Field</th>
                                <th style="text-align: left; padding: 8px; font-size: 13px; color: var(--text-secondary);">Excel Column</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${mappingRowsHTML}
                        </tbody>
                    </table>

                    <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: flex-end;">
                        <button id="cancel-mapping-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                            Cancel
                        </button>
                        <button id="preview-import-btn" style="padding: 10px 20px; border: none; border-radius: 8px; background: var(--treeplex-primary); color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Preview Import â†’
                        </button>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Update mapping when dropdowns change
            document.querySelectorAll('.column-mapping-select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const fieldKey = e.target.dataset.field;
                    const columnIndex = e.target.value === '' ? null : parseInt(e.target.value);
                    excelImportState.columnMapping[fieldKey] = columnIndex;
                    console.log('ğŸ”„ Updated mapping:', fieldKey, 'â†’', columnIndex);
                });
            });

            // Cancel button
            document.getElementById('cancel-mapping-btn').addEventListener('click', () => {
                modal.style.display = 'none';
            });

            // Preview button
            document.getElementById('preview-import-btn').addEventListener('click', () => {
                // Validate required fields
                if (excelImportState.columnMapping.itemName === null) {
                    alert('âŒ Required Field Missing\n\nYou must map the "Item Name" field to import.');
                    return;
                }

                previewFlexibleImport();
            });
        }

        function createMappingRow(label, fieldKey, helpText, selectedValue, required) {
            const requiredBadge = required ? '<span style="color: var(--error); margin-left: 4px;">*</span>' : '';

            // Build options with proper selected attribute
            const headers = excelImportState.headers;
            const sampleData = excelImportState.sampleData;

            let options = '<option value="">-- Skip this column --</option>';
            headers.forEach((h, i) => {
                const isSelected = (selectedValue !== null && selectedValue !== undefined && selectedValue === i) ? 'selected' : '';
                options += `<option value="${i}" ${isSelected}>${h} (sample: ${sampleData[0]?.[i] || 'N/A'})</option>`;
            });

            return `
                <tr style="border-bottom: 1px solid var(--border);">
                    <td style="padding: 12px 8px;">
                        <div style="font-weight: 500; font-size: 14px;">
                            ${label}${requiredBadge}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">
                            ${helpText}
                        </div>
                    </td>
                    <td style="padding: 12px 8px;">
                        <select class="column-mapping-select" data-field="${fieldKey}" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px;">
                            ${options}
                        </select>
                    </td>
                </tr>
            `;
        }

        function previewFlexibleImport() {
            console.log('ğŸ‘€ Generating preview...');

            const sheet = excelImportState.workbook.Sheets[excelImportState.selectedSheet];
            const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            // Find header row
            let headerRowIndex = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] && data[i].some(cell => cell !== '' && cell !== null && cell !== undefined)) {
                    headerRowIndex = i;
                    break;
                }
            }

            const rows = data.slice(headerRowIndex + 1).filter(row => row && row.length > 0);
            const mapping = excelImportState.columnMapping;
            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};

            // Extract items
            const importedItems = [];
            const phaseMap = {};

            rows.forEach((row, rowIndex) => {
                // Skip empty rows
                if (!row[mapping.itemName] || row[mapping.itemName] === '') {
                    return;
                }

                const item = {
                    name: row[mapping.itemName] || `Item ${rowIndex + 1}`,
                    description: mapping.description !== null ? (row[mapping.description] || '') : '',
                    itemType: mapping.itemType !== null ? (row[mapping.itemType] || '') : '',
                    type: 'item',
                    icon: 'ğŸ“¦'
                };

                // Map pattern-specific fields
                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    const columnIndex = mapping[fieldKey];
                    if (columnIndex !== null && columnIndex !== undefined && row[columnIndex] !== undefined && row[columnIndex] !== '') {
                        let value = row[columnIndex];

                        // Type conversion
                        if (fieldConfig.type === 'number') {
                            value = parseFloat(value) || 0;
                            // Handle special scaling
                            if (fieldKey === 'cost' && fieldConfig.label && fieldConfig.label.includes('($M)')) {
                                value = value * 1000000;
                            } else if (fieldKey === 'dealValue') {
                                value = value * 1000;
                            }
                        }

                        item[fieldKey] = value;
                    }
                });

                // Handle dependencies
                if (mapping.dependencies !== null && row[mapping.dependencies]) {
                    const depString = String(row[mapping.dependencies]);
                    if (depString !== '' && depString.toLowerCase() !== 'none') {
                        item.dependencies = depString.split(/[,;|]/).map(d => d.trim()).filter(d => d);
                    }
                }

                // Determine phase
                const phaseName = mapping.phaseName !== null && row[mapping.phaseName]
                    ? String(row[mapping.phaseName])
                    : 'Default Phase';

                if (!phaseMap[phaseName]) {
                    phaseMap[phaseName] = [];
                }

                phaseMap[phaseName].push(item);
                importedItems.push(item);
            });

            // Generate preview HTML
            let previewHTML = '<div style="padding: 20px; max-height: 70vh; overflow-y: auto;">';

            previewHTML += `
                <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 16px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 12px 0; color: var(--treeplex-primary);">ğŸ“Š Import Preview</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; font-size: 14px;">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Pattern</div>
                            <div style="font-weight: 600;">${patternDef.icon} ${patternDef.name}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Phases</div>
                            <div style="font-weight: 600;">${Object.keys(phaseMap).length}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Items</div>
                            <div style="font-weight: 600;">${importedItems.length}</div>
                        </div>
                    </div>
                </div>
            `;

            // Show preview of first 10 items
            previewHTML += '<div style="font-weight: 600; margin-bottom: 12px;">Preview (first 10 items):</div>';
            previewHTML += '<div style="font-family: monospace; font-size: 12px; background: var(--bg-secondary); padding: 16px; border-radius: 8px; line-height: 1.8;">';

            let itemCount = 0;
            Object.keys(phaseMap).forEach((phaseName, phaseIndex) => {
                if (itemCount >= 10) return;

                previewHTML += `<div style="color: var(--treeplex-primary); font-weight: 600; margin-top: ${phaseIndex > 0 ? '12px' : '0'};">${phaseName}</div>`;

                phaseMap[phaseName].forEach((item, itemIndex) => {
                    if (itemCount >= 10) return;
                    itemCount++;

                    previewHTML += `<div style="margin-left: 20px; color: var(--text-primary);">â”œâ”€ ${item.name}`;
                    if (item.itemType) previewHTML += ` [${item.itemType}]`;
                    if (item.dependencies && item.dependencies.length > 0) {
                        previewHTML += ` <span style="color: var(--text-secondary);">â†’ Depends on: ${item.dependencies.join(', ')}</span>`;
                    }
                    previewHTML += `</div>`;
                });
            });

            if (importedItems.length > 10) {
                previewHTML += `<div style="color: var(--text-secondary); margin-top: 8px;">... and ${importedItems.length - 10} more items</div>`;
            }

            previewHTML += '</div>';

            // Action buttons
            previewHTML += `
                <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between;">
                    <button id="back-to-mapping-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                        â† Back to Mapping
                    </button>
                    <div style="display: flex; gap: 12px;">
                        <button id="execute-import-replace-btn" style="padding: 10px 20px; border: none; border-radius: 8px; background: var(--treeplex-primary); color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Replace Current Tree
                        </button>
                        <button id="execute-import-append-btn" style="padding: 10px 20px; border: 1px solid var(--treeplex-primary); border-radius: 8px; background: transparent; color: var(--treeplex-primary); cursor: pointer; font-size: 14px; font-weight: 600;">
                            Append to Tree
                        </button>
                    </div>
                </div>
            `;

            previewHTML += '</div>';

            // Show modal
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ‘€ Preview Import';
            modalBody.innerHTML = previewHTML;
            modal.style.display = 'flex';

            // Store preview data
            excelImportState.previewData = { phaseMap, importedItems };

            // Button handlers
            document.getElementById('back-to-mapping-btn').addEventListener('click', () => {
                showColumnMappingUI();
            });

            document.getElementById('execute-import-replace-btn').addEventListener('click', () => {
                executeFlexibleImport('replace');
            });

            document.getElementById('execute-import-append-btn').addEventListener('click', () => {
                executeFlexibleImport('append');
            });
        }

        function executeFlexibleImport(mode) {
            console.log('ğŸš€ Executing import in', mode, 'mode...');

            const { phaseMap, importedItems } = excelImportState.previewData;
            const patternDef = PATTERNS[currentPattern];

            saveState(`Excel Import: ${mode === 'replace' ? 'Replace' : 'Append'}`);

            if (mode === 'replace') {
                // Create new tree from scratch
                const phases = Object.keys(phaseMap).map((phaseName, phaseIndex) => {
                    return {
                        id: `phase-${phaseIndex}`,
                        type: 'phase',
                        phase: phaseIndex,
                        name: phaseName,
                        subtitle: '',
                        icon: `${phaseIndex + 1}ï¸âƒ£`,
                        expanded: false,
                        items: phaseMap[phaseName].map((item, itemIndex) => ({
                            ...item,
                            id: `item-${phaseIndex}-${itemIndex}`
                        }))
                    };
                });

                capexTree = {
                    id: 'root',
                    type: 'root',
                    name: `Imported from ${excelImportState.file}`,
                    icon: 'ğŸŒ³',
                    expanded: true,
                    hyperedges: [], // Initialize empty hyperedges array to prevent data loss
                    children: phases,
                    pattern: {
                        key: currentPattern,
                        labels: patternDef.levels
                    }
                };

            } else {
                // Append mode
                if (!capexTree.children) capexTree.children = [];

                Object.keys(phaseMap).forEach((phaseName) => {
                    // Try to find existing phase
                    let existingPhase = capexTree.children.find(p => p.name === phaseName);

                    if (existingPhase) {
                        // Append items to existing phase
                        const currentItemCount = existingPhase.items?.length || 0;
                        const phaseIndex = capexTree.children.indexOf(existingPhase);

                        const newItems = phaseMap[phaseName].map((item, idx) => ({
                            ...item,
                            id: `item-${phaseIndex}-${currentItemCount + idx}`
                        }));

                        existingPhase.items = [...(existingPhase.items || []), ...newItems];
                    } else {
                        // Create new phase
                        const phaseIndex = capexTree.children.length;
                        const newPhase = {
                            id: `phase-${phaseIndex}`,
                            type: 'phase',
                            phase: phaseIndex,
                            name: phaseName,
                            subtitle: '',
                            icon: `${phaseIndex + 1}ï¸âƒ£`,
                            expanded: false,
                            items: phaseMap[phaseName].map((item, itemIndex) => ({
                                ...item,
                                id: `item-${phaseIndex}-${itemIndex}`
                            }))
                        };

                        capexTree.children.push(newPhase);
                    }
                });
            }

            // Update UI
            render();
            document.getElementById('modal').style.display = 'none';

            showToast(`âœ… Excel imported! ${importedItems.length} items ${mode === 'replace' ? 'loaded' : 'added'}`);
            console.log('âœ… Flexible import complete');
        }

        // Excel Import button handler
        document.getElementById('excel-import-btn').addEventListener('click', () => {
            document.getElementById('excel-upload-input').click();
        });

        // BUILD 568: Image Import button handler - opens modal
        document.getElementById('image-import-btn').addEventListener('click', () => {
            showImageImportModal();
        });

        // ============================================
        // LOAD FROM GOOGLE DRIVE MODAL
        // ============================================

        const RECENT_GDRIVE_KEY = 'treelisty-recent-gdrive';
        const MAX_RECENT_FILES = 8;

        // Get recent Google Drive files from localStorage
        function getRecentGdriveFiles() {
            try {
                return JSON.parse(localStorage.getItem(RECENT_GDRIVE_KEY) || '[]');
            } catch {
                return [];
            }
        }

        // Add a file to recent list
        function addToRecentGdrive(fileId, projectName, pattern) {
            const recent = getRecentGdriveFiles();
            // Remove if already exists
            const filtered = recent.filter(f => f.fileId !== fileId);
            // Add to front
            filtered.unshift({
                fileId,
                projectName: projectName || 'Untitled Project',
                pattern: pattern || 'generic',
                loadedAt: new Date().toISOString()
            });
            // Keep only max
            const trimmed = filtered.slice(0, MAX_RECENT_FILES);
            localStorage.setItem(RECENT_GDRIVE_KEY, JSON.stringify(trimmed));
            return trimmed;
        }

        // Render recent files list
        function renderRecentGdriveList() {
            const section = document.getElementById('recent-gdrive-section');
            const list = document.getElementById('recent-gdrive-list');
            const recent = getRecentGdriveFiles();

            if (recent.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            list.innerHTML = recent.map((file, idx) => {
                const date = new Date(file.loadedAt);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const patternEmoji = {
                    philosophy: 'ğŸ›ï¸', sales: 'ğŸ’¼', film: 'ğŸ¬', capex: 'ğŸ’°',
                    generic: 'ğŸ“‹', academic: 'ğŸ“', product: 'ğŸš€', book: 'ğŸ“š'
                }[file.pattern] || 'ğŸ“„';

                return `
                    <div class="recent-gdrive-item" data-file-id="${file.fileId}"
                        style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--card-bg); border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s; border: 1px solid var(--border);"
                        onmouseover="this.style.borderColor='#4285f4'; this.style.transform='translateX(4px)'"
                        onmouseout="this.style.borderColor='var(--border)'; this.style.transform='none'">
                        <div style="font-size: 24px;">${patternEmoji}</div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 600; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${file.projectName}
                            </div>
                            <div style="font-size: 11px; color: var(--text-secondary);">
                                ${dateStr}
                            </div>
                        </div>
                        <div style="font-size: 16px; color: var(--text-secondary);">â†’</div>
                    </div>
                `;
            }).join('');

            // Add click handlers
            list.querySelectorAll('.recent-gdrive-item').forEach(item => {
                item.addEventListener('click', () => {
                    const fileId = item.dataset.fileId;
                    loadFromGoogleDrive(fileId);
                });
            });
        }

        // Load tree from Google Drive file ID
        async function loadFromGoogleDrive(fileId) {
            const modal = document.getElementById('load-gdrive-modal');
            const loadBtn = document.getElementById('gdrive-load-btn');
            const originalText = loadBtn.textContent;

            try {
                loadBtn.textContent = 'â³ Loading...';
                loadBtn.disabled = true;

                showToast('â˜ï¸ Loading from Google Drive...', 'info');

                const proxyUrl = `/.netlify/functions/gdrive-proxy?id=${fileId}`;
                const response = await fetch(proxyUrl);
                const result = await response.json();

                if (!response.ok || result.error) {
                    throw new Error(result.error || 'Failed to fetch from Google Drive');
                }

                // Load the tree data
                capexTree = result;

                // Update pattern if present
                if (result.pattern) {
                    const patternKey = getPatternKey(result.pattern);
                    if (patternKey) {
                        currentPattern = patternKey;
                        const patternSelect = document.getElementById('pattern-select');
                        if (patternSelect) patternSelect.value = currentPattern;
                        if (currentPattern === 'custom' && result.pattern.labels) {
                            customPatternNames = result.pattern.labels;
                        }
                        if (typeof updateSortDropdown === 'function') updateSortDropdown();
                        if (typeof updateAIButtonLabel === 'function') updateAIButtonLabel();
                    }
                }

                // Add to recent files
                addToRecentGdrive(fileId, result.name || result.projectName || 'Untitled', currentPattern);

                // Close modal
                modal.style.display = 'none';

                // Render
                render();
                if (viewMode === 'canvas') renderCanvas();

                showToast('âœ… Loaded from Google Drive!', 'success');
                console.log('â˜ï¸ Loaded from Google Drive:', fileId);

            } catch (error) {
                console.error('âŒ Failed to load from Google Drive:', error);
                showToast('âŒ ' + (error.message || 'Failed to load. Check the link is publicly shared.'), 'error');
            } finally {
                loadBtn.textContent = originalText;
                loadBtn.disabled = false;
            }
        }

        // Extract file ID from various Google Drive URL formats
        function extractGdriveFileId(input) {
            if (!input) return null;

            // Already just an ID
            if (/^[a-zA-Z0-9_-]{20,}$/.test(input.trim())) {
                return input.trim();
            }

            // /d/FILE_ID format
            const dMatch = input.match(/\/d\/([a-zA-Z0-9_-]+)/);
            if (dMatch) return dMatch[1];

            // ?id=FILE_ID format
            const idMatch = input.match(/[?&]id=([a-zA-Z0-9_-]+)/);
            if (idMatch) return idMatch[1];

            // /open?id=FILE_ID format
            const openMatch = input.match(/\/open\?id=([a-zA-Z0-9_-]+)/);
            if (openMatch) return openMatch[1];

            return null;
        }

        // Initialize Load from Google Drive modal
        document.getElementById('load-gdrive-btn').addEventListener('click', () => {
            const modal = document.getElementById('load-gdrive-modal');
            modal.style.display = 'flex';
            document.getElementById('gdrive-url-input').value = '';
            document.getElementById('gdrive-url-input').focus();
            renderRecentGdriveList();
        });

        document.getElementById('load-gdrive-close').addEventListener('click', () => {
            document.getElementById('load-gdrive-modal').style.display = 'none';
        });

        document.getElementById('gdrive-load-btn').addEventListener('click', () => {
            const input = document.getElementById('gdrive-url-input').value.trim();
            const fileId = extractGdriveFileId(input);
            if (fileId) {
                loadFromGoogleDrive(fileId);
            } else {
                showToast('âŒ Could not parse Google Drive URL. Try pasting the share link.', 'error');
            }
        });

        // Allow Enter key to submit
        document.getElementById('gdrive-url-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('gdrive-load-btn').click();
            }
        });

        // Clear recent files
        document.getElementById('clear-recent-gdrive').addEventListener('click', () => {
            localStorage.removeItem(RECENT_GDRIVE_KEY);
            renderRecentGdriveList();
            showToast('Recent files cleared', 'info');
        });

        // Close modal on backdrop click
        document.getElementById('load-gdrive-modal').addEventListener('click', (e) => {
            if (e.target.id === 'load-gdrive-modal') {
                e.target.style.display = 'none';
            }
        });

        // Google Drive Refresh button handler
        document.getElementById('refresh-drive-btn').addEventListener('click', async () => {
            const btn = document.getElementById('refresh-drive-btn');
            const originalText = btn.textContent;

            try {
                // Check if current tree has source metadata
                const hasSourceMetadata = capexTree?.source?.type === 'google-drive';

                if (!hasSourceMetadata) {
                    // No source metadata - inform user
                    const proceed = confirm(
                        'âš ï¸ No Google Drive source detected!\n\n' +
                        'This will scan your entire Google Drive.\n\n' +
                        'Tip: Load a Google Drive JSON first, then click Refresh to update only that tree.\n\n' +
                        'Continue with full scan?'
                    );
                    if (!proceed) return;
                }

                // Show loading state
                btn.textContent = 'â³ Refreshing...';
                btn.disabled = true;
                btn.style.opacity = '0.6';

                console.log('â˜ï¸ Refreshing from Google Drive...');
                if (hasSourceMetadata) {
                    console.log('ğŸ“‹ Using source metadata from loaded tree:', capexTree.source);
                }

                // Prepare request body with source metadata (if available)
                const requestBody = hasSourceMetadata ? {
                    source: capexTree.source
                } : {};

                // Call local server to trigger export and get data
                const response = await fetch('http://localhost:5000/refresh-google-drive', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Server request failed');
                }

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'Unknown error');
                }

                console.log('âœ… Received data from server:', result.filename);

                // Auto-import the data
                const treeData = result.data;

                // Detect pattern
                const detectedPattern = treeData.pattern?.key || 'filesystem';
                console.log(`ğŸ“‹ Pattern detected: ${detectedPattern}`);

                // Load directly without preview modal
                if (PATTERNS[detectedPattern]) {
                    currentPattern = detectedPattern;
                    capexTree = treeData;

                    // Update pattern dropdown
                    const patternSelect = document.getElementById('pattern-select');
                    if (patternSelect) {
                        patternSelect.value = detectedPattern;
                    }

                    // Re-render the tree
                    render();

                    // Update sort dropdown options for the loaded pattern
                    updateSortDropdown();

                    // Apply default sort for filesystem pattern (folders first + alphabetical)
                    if (detectedPattern === 'filesystem') {
                        sortTree(null); // This will trigger the default filesystem sort
                    }

                    // Build success message with source info
                    let successMessage = `âœ… Google Drive refreshed successfully!\n\n`;
                    successMessage += `File: ${result.filename}\n`;
                    successMessage += `Size: ${(result.fileSize / 1024).toFixed(1)} KB\n`;
                    successMessage += `Pattern: ${PATTERNS[detectedPattern].name}\n`;

                    if (treeData.source) {
                        successMessage += `\nğŸ“‹ Source Info:\n`;
                        successMessage += `Type: ${treeData.source.type}\n`;
                        successMessage += `Folder: ${treeData.source.folderName}\n`;
                        successMessage += `Depth: ${treeData.source.syncDepth} levels\n`;

                        if (treeData.source.lastSync) {
                            const syncDate = new Date(treeData.source.lastSync);
                            successMessage += `Last Synced: ${syncDate.toLocaleString()}`;
                        }
                    }

                    alert(successMessage);

                    console.log('âœ… Google Drive data loaded successfully');
                } else {
                    throw new Error(`Unknown pattern: ${detectedPattern}`);
                }

            } catch (error) {
                console.error('âŒ Refresh failed:', error);

                // Check if server is running
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    alert('âŒ Cannot connect to local server!\n\nPlease start the server first:\n\n1. Open a terminal\n2. Run: python treelisty_server.py\n3. Keep it running\n4. Try again');
                } else {
                    alert(`âŒ Refresh failed:\n\n${error.message}`);
                }
            } finally {
                // Restore button state
                btn.textContent = originalText;
                btn.disabled = false;
                btn.style.opacity = '1';
            }
        });

        // Excel file upload handler
        document.getElementById('excel-upload-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                console.log('ğŸ“¥ Excel file selected:', file.name);
                importFromExcel(file);
            }
            // Reset input
            e.target.value = '';
        });

        // =============================================================================
        // MS PROJECT XML IMPORT - Import from MS Project XML export
        // =============================================================================

        /**
         * Parse MS Project XML (MSPDI format) and convert to TreeListy format
         * Users export from MS Project via: File â†’ Save As â†’ XML Format
         */
        function parseMSProjectXML(xmlString) {
            console.log('ğŸ“… Parsing MS Project XML...');
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');

            // Check for parsing errors
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                throw new Error('Invalid XML file: ' + parseError.textContent);
            }

            // Check if this is MS Project XML (MSPDI format)
            const projectNode = xmlDoc.querySelector('Project');
            if (!projectNode) {
                throw new Error('This does not appear to be an MS Project XML file. Please export from MS Project using File â†’ Save As â†’ XML Format.');
            }

            // Extract project metadata
            const projectName = xmlDoc.querySelector('Project > Name')?.textContent ||
                               xmlDoc.querySelector('Project > Title')?.textContent ||
                               'Imported MS Project';
            const projectStart = xmlDoc.querySelector('Project > StartDate')?.textContent;
            const projectFinish = xmlDoc.querySelector('Project > FinishDate')?.textContent;

            console.log('ğŸ“… Project:', projectName);

            // Build resource map (UID â†’ Name)
            const resourceMap = new Map();
            const resources = xmlDoc.querySelectorAll('Resources > Resource');
            resources.forEach(resource => {
                const uid = resource.querySelector('UID')?.textContent;
                const name = resource.querySelector('Name')?.textContent;
                if (uid && name) {
                    resourceMap.set(uid, name);
                }
            });
            console.log('ğŸ‘¥ Resources found:', resourceMap.size);

            // Build assignment map (TaskUID â†’ ResourceNames)
            const assignmentMap = new Map();
            const assignments = xmlDoc.querySelectorAll('Assignments > Assignment');
            assignments.forEach(assignment => {
                const taskUID = assignment.querySelector('TaskUID')?.textContent;
                const resourceUID = assignment.querySelector('ResourceUID')?.textContent;
                if (taskUID && resourceUID && resourceMap.has(resourceUID)) {
                    const existing = assignmentMap.get(taskUID) || [];
                    existing.push(resourceMap.get(resourceUID));
                    assignmentMap.set(taskUID, existing);
                }
            });

            // Parse all tasks
            const tasks = xmlDoc.querySelectorAll('Tasks > Task');
            const taskList = [];
            const taskUIDMap = new Map(); // UID â†’ task data for dependency resolution

            tasks.forEach(task => {
                const uid = task.querySelector('UID')?.textContent;
                const id = task.querySelector('ID')?.textContent;
                const name = task.querySelector('Name')?.textContent;
                const outlineLevel = parseInt(task.querySelector('OutlineLevel')?.textContent || '0');
                const wbs = task.querySelector('WBS')?.textContent || '';
                const isSummary = task.querySelector('Summary')?.textContent === '1';
                const isMilestone = task.querySelector('Milestone')?.textContent === '1';
                const notes = task.querySelector('Notes')?.textContent || '';

                // Skip the root project task (outline level 0, usually ID 0)
                if (outlineLevel === 0 && id === '0') return;

                // Dates (convert from MS Project format)
                const startDate = task.querySelector('Start')?.textContent;
                const finishDate = task.querySelector('Finish')?.textContent;

                // Duration (PT format: PT8H0M0S = 8 hours)
                const durationRaw = task.querySelector('Duration')?.textContent || '';
                const duration = parseMSProjectDuration(durationRaw);

                // Progress
                const percentComplete = parseInt(task.querySelector('PercentComplete')?.textContent || '0');

                // Cost
                const cost = parseFloat(task.querySelector('Cost')?.textContent || '0');

                // Priority (MS Project uses 0-1000, 500 is normal)
                const priorityRaw = parseInt(task.querySelector('Priority')?.textContent || '500');
                const priority = mapMSProjectPriority(priorityRaw);

                // Status based on percent complete
                const status = percentComplete === 0 ? 'To Do' :
                              percentComplete === 100 ? 'Done' : 'In Progress';

                // Get assigned resources
                const assignees = assignmentMap.get(uid) || [];

                // Parse predecessor links (dependencies) with type and lag
                const predecessorData = [];
                const predecessorLinks = task.querySelectorAll('PredecessorLink');
                predecessorLinks.forEach(link => {
                    const predUID = link.querySelector('PredecessorUID')?.textContent;
                    if (predUID) {
                        // Get dependency type: 0=FF, 1=FS, 2=SF, 3=SS
                        const typeCode = parseInt(link.querySelector('Type')?.textContent || '1');
                        const typeMap = {0: 'FF', 1: 'FS', 2: 'SF', 3: 'SS'};
                        const depType = typeMap[typeCode] || 'FS';

                        // Get lag in tenths of minutes, convert to days (8 hours/day * 60 min * 10)
                        const lagTenths = parseInt(link.querySelector('LinkLag')?.textContent || '0');
                        const lagDays = Math.round(lagTenths / (8 * 60 * 10));

                        predecessorData.push({
                            uid: predUID,
                            type: depType,
                            lag: lagDays
                        });
                    }
                });

                const taskData = {
                    uid,
                    id,
                    name: name || 'Unnamed Task',
                    outlineLevel,
                    wbs,
                    isSummary,
                    isMilestone,
                    description: notes,
                    startDate: formatMSProjectDate(startDate),
                    finishDate: formatMSProjectDate(finishDate),
                    duration,
                    percentComplete,
                    cost,
                    priority,
                    status,
                    assignees,
                    predecessorData
                };

                taskList.push(taskData);
                taskUIDMap.set(uid, taskData);
            });

            console.log('ğŸ“‹ Tasks parsed:', taskList.length);

            // Convert flat task list to hierarchical TreeListy structure
            const treeData = convertMSProjectToTreeListy(taskList, taskUIDMap, projectName);

            return treeData;
        }

        /**
         * Parse MS Project duration format (PT8H0M0S) to readable string
         */
        function parseMSProjectDuration(ptDuration) {
            if (!ptDuration) return '';

            // Match PT[n]H[n]M[n]S pattern
            const match = ptDuration.match(/PT(\d+)H(\d+)M(\d+)S/);
            if (!match) return ptDuration;

            const hours = parseInt(match[1]);
            const minutes = parseInt(match[2]);

            if (hours >= 8) {
                const days = Math.floor(hours / 8);
                const remainingHours = hours % 8;
                if (days > 0 && remainingHours === 0) {
                    return days === 1 ? '1 day' : `${days} days`;
                } else if (days > 0) {
                    return `${days}d ${remainingHours}h`;
                }
            }

            if (hours > 0 && minutes > 0) {
                return `${hours}h ${minutes}m`;
            } else if (hours > 0) {
                return `${hours} hours`;
            } else if (minutes > 0) {
                return `${minutes} minutes`;
            }

            return '';
        }

        /**
         * Map MS Project priority (0-1000) to TreeListy priority
         */
        function mapMSProjectPriority(msPriority) {
            if (msPriority <= 300) return 'Low';
            if (msPriority <= 700) return 'Medium';
            return 'High';
        }

        /**
         * Format MS Project date to YYYY-MM-DD
         */
        function formatMSProjectDate(dateStr) {
            if (!dateStr) return '';
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return '';
                return date.toISOString().split('T')[0];
            } catch {
                return '';
            }
        }

        /**
         * Convert flat MS Project task list to TreeListy hierarchical structure
         */
        function convertMSProjectToTreeListy(taskList, taskUIDMap, projectName) {
            // Group tasks by outline level to build hierarchy
            // OutlineLevel 1 = Phases (Summary tasks)
            // OutlineLevel 2 = Items
            // OutlineLevel 3+ = Subtasks

            // Check if this is a flat task list (all tasks at level 1, no deeper hierarchy)
            const maxLevel = Math.max(...taskList.map(t => t.outlineLevel));
            const isFlatList = maxLevel <= 1;

            if (isFlatList) {
                console.log('ğŸ“‹ Flat task list detected - grouping tasks as items under project phases');
                return convertFlatMSProjectToTreeListy(taskList, taskUIDMap, projectName);
            }

            const phases = [];
            let currentPhase = null;
            let currentItem = null;

            // Build UID to TreeListy ID mapping for dependencies
            const uidToIdMap = new Map();
            let phaseIndex = 0;
            let itemIndex = 0;
            let subtaskIndex = 0;

            taskList.forEach((task, index) => {
                // Milestones at level 1 should be items, not phases (they have dependencies)
                const isPhase = (task.outlineLevel === 1 || (task.isSummary && task.outlineLevel <= 1))
                    && !task.isMilestone;

                if (isPhase) {
                    // This is a phase (top-level summary task, not a milestone)
                    itemIndex = 0;
                    const phaseId = `phase-${phaseIndex}`;
                    uidToIdMap.set(task.uid, phaseId);

                    currentPhase = {
                        name: task.name,
                        subtitle: task.wbs || '',
                        icon: 'ğŸ“',
                        items: []
                    };
                    phases.push(currentPhase);
                    currentItem = null;
                    phaseIndex++;
                } else if (task.outlineLevel === 2 || (task.isSummary && task.outlineLevel === 2) || task.isMilestone) {
                    // This is an item (or milestone - milestones are treated as items to preserve dependencies)
                    if (!currentPhase) {
                        // Create default phase if none exists
                        currentPhase = {
                            name: 'Tasks',
                            subtitle: '',
                            icon: 'ğŸ“',
                            items: []
                        };
                        phases.push(currentPhase);
                    }

                    subtaskIndex = 0;
                    const itemId = `item-${phaseIndex > 0 ? phaseIndex - 1 : 0}-${itemIndex}`;
                    uidToIdMap.set(task.uid, itemId);

                    currentItem = {
                        name: task.name,
                        description: task.description || (task.wbs ? `WBS: ${task.wbs}` : ''),
                        cost: task.cost || 0,
                        leadTime: task.duration || '',
                        pmStatus: task.status,
                        pmProgress: task.percentComplete,
                        pmAssignee: task.assignees.join(', ') || 'Unassigned',
                        pmPriority: task.priority,
                        pmStartDate: task.startDate,
                        pmDueDate: task.finishDate,
                        pmNotes: '',
                        pmIsMilestone: task.isMilestone || false,
                        dependencies: [], // Will be resolved later
                        _predecessorData: task.predecessorData,
                        subtasks: []
                    };
                    currentPhase.items.push(currentItem);
                    itemIndex++;
                } else if (task.outlineLevel >= 3) {
                    // This is a subtask
                    if (!currentItem) {
                        // Create default item if none exists
                        if (!currentPhase) {
                            currentPhase = {
                                name: 'Tasks',
                                subtitle: '',
                                icon: 'ğŸ“',
                                items: []
                            };
                            phases.push(currentPhase);
                        }
                        currentItem = {
                            name: 'Tasks',
                            description: '',
                            cost: 0,
                            leadTime: '',
                            pmStatus: 'To Do',
                            pmProgress: 0,
                            pmAssignee: 'Unassigned',
                            pmPriority: 'Medium',
                            pmStartDate: '',
                            pmDueDate: '',
                            pmNotes: '',
                            dependencies: [],
                            _predecessorData: [],
                            subtasks: []
                        };
                        currentPhase.items.push(currentItem);
                    }

                    const subtaskId = `subtask-${phaseIndex > 0 ? phaseIndex - 1 : 0}-${itemIndex > 0 ? itemIndex - 1 : 0}-${subtaskIndex}`;
                    uidToIdMap.set(task.uid, subtaskId);

                    const subtask = {
                        name: task.name,
                        description: task.description || '',
                        pmStatus: task.status,
                        pmProgress: task.percentComplete,
                        pmAssignee: task.assignees.join(', ') || 'Unassigned',
                        pmPriority: task.priority,
                        pmStartDate: task.startDate,
                        pmDueDate: task.finishDate,
                        cost: task.cost || 0,
                        dependencies: [],
                        _predecessorData: task.predecessorData
                    };
                    currentItem.subtasks.push(subtask);
                    subtaskIndex++;
                } else {
                    // OutlineLevel 0 or unknown - treat as item in default phase
                    if (!currentPhase) {
                        currentPhase = {
                            name: 'Project Tasks',
                            subtitle: '',
                            icon: 'ğŸ“',
                            items: []
                        };
                        phases.push(currentPhase);
                    }

                    const itemId = `item-0-${itemIndex}`;
                    uidToIdMap.set(task.uid, itemId);

                    currentItem = {
                        name: task.name,
                        description: task.description || '',
                        cost: task.cost || 0,
                        leadTime: task.duration || '',
                        pmStatus: task.status,
                        pmProgress: task.percentComplete,
                        pmAssignee: task.assignees.join(', ') || 'Unassigned',
                        pmPriority: task.priority,
                        pmStartDate: task.startDate,
                        pmDueDate: task.finishDate,
                        pmNotes: '',
                        dependencies: [],
                        _predecessorData: task.predecessorData,
                        subtasks: []
                    };
                    currentPhase.items.push(currentItem);
                    itemIndex++;
                }
            });

            // Resolve dependencies using UID map - create typed dependency objects
            phases.forEach(phase => {
                phase.items.forEach(item => {
                    if (item._predecessorData && item._predecessorData.length > 0) {
                        item.dependencies = item._predecessorData
                            .map(pred => {
                                const treelistyId = uidToIdMap.get(pred.uid);
                                if (!treelistyId) return null;
                                return {
                                    predecessorId: treelistyId,
                                    type: pred.type || 'FS',
                                    lag: pred.lag || 0
                                };
                            })
                            .filter(dep => dep);
                    }
                    delete item._predecessorData;

                    // Resolve subtask dependencies too
                    if (item.subtasks) {
                        item.subtasks.forEach(subtask => {
                            if (subtask._predecessorData && subtask._predecessorData.length > 0) {
                                subtask.dependencies = subtask._predecessorData
                                    .map(pred => {
                                        const treelistyId = uidToIdMap.get(pred.uid);
                                        if (!treelistyId) return null;
                                        return {
                                            predecessorId: treelistyId,
                                            type: pred.type || 'FS',
                                            lag: pred.lag || 0
                                        };
                                    })
                                    .filter(dep => dep);
                            }
                            delete subtask._predecessorData;
                        });
                    }
                });
            });

            // If no phases were created, create one default phase with all tasks as items
            if (phases.length === 0) {
                phases.push({
                    name: 'Project Tasks',
                    subtitle: '',
                    icon: 'ğŸ“',
                    items: taskList.map((task, i) => ({
                        name: task.name,
                        description: task.description || '',
                        cost: task.cost || 0,
                        leadTime: task.duration || '',
                        pmStatus: task.status,
                        pmProgress: task.percentComplete,
                        pmAssignee: task.assignees.join(', ') || 'Unassigned',
                        pmPriority: task.priority,
                        pmStartDate: task.startDate,
                        pmDueDate: task.finishDate,
                        dependencies: [],
                        subtasks: []
                    }))
                });
            }

            const totalItems = phases.reduce((sum, p) => sum + p.items.length, 0);
            const totalSubtasks = phases.reduce((sum, p) =>
                sum + p.items.reduce((s, i) => s + (i.subtasks?.length || 0), 0), 0);

            console.log(`ğŸ“Š Converted: ${phases.length} phases, ${totalItems} items, ${totalSubtasks} subtasks`);

            return {
                projectName,
                phases
            };
        }

        /**
         * Convert flat MS Project task list (all at level 1) to TreeListy
         * Groups tasks by year/quarter or creates logical phases
         */
        function convertFlatMSProjectToTreeListy(taskList, taskUIDMap, projectName) {
            const uidToIdMap = new Map();

            // Group tasks by year based on start date
            const tasksByYear = new Map();

            taskList.forEach(task => {
                if (task.outlineLevel === 0) return; // Skip root

                let year = 'Tasks';
                if (task.startDate) {
                    const date = new Date(task.startDate);
                    if (!isNaN(date.getTime())) {
                        year = `${date.getFullYear()}`;
                    }
                }

                if (!tasksByYear.has(year)) {
                    tasksByYear.set(year, []);
                }
                tasksByYear.get(year).push(task);
            });

            // If all tasks in same year, try grouping by quarter
            if (tasksByYear.size === 1) {
                const allTasks = [...tasksByYear.values()][0];
                const tasksByQuarter = new Map();

                allTasks.forEach(task => {
                    let quarter = 'Tasks';
                    if (task.startDate) {
                        const date = new Date(task.startDate);
                        if (!isNaN(date.getTime())) {
                            const q = Math.ceil((date.getMonth() + 1) / 3);
                            quarter = `Q${q} ${date.getFullYear()}`;
                        }
                    }

                    if (!tasksByQuarter.has(quarter)) {
                        tasksByQuarter.set(quarter, []);
                    }
                    tasksByQuarter.get(quarter).push(task);
                });

                // Use quarters if we have more than 1
                if (tasksByQuarter.size > 1) {
                    tasksByYear.clear();
                    tasksByQuarter.forEach((tasks, quarter) => {
                        tasksByYear.set(quarter, tasks);
                    });
                }
            }

            // Convert to phases
            const phases = [];
            let phaseIndex = 0;

            // Sort keys chronologically
            const sortedKeys = [...tasksByYear.keys()].sort();

            sortedKeys.forEach(key => {
                const phaseTasks = tasksByYear.get(key);

                const phase = {
                    name: key,
                    subtitle: `${phaseTasks.length} tasks`,
                    icon: 'ğŸ“…',
                    items: phaseTasks.map((task, itemIndex) => {
                        const itemId = `item-${phaseIndex}-${itemIndex}`;
                        uidToIdMap.set(task.uid, itemId);

                        return {
                            name: task.name,
                            description: task.description || (task.wbs ? `WBS: ${task.wbs}` : ''),
                            cost: task.cost || 0,
                            leadTime: task.duration || '',
                            pmStatus: task.status,
                            pmProgress: task.percentComplete,
                            pmAssignee: task.assignees.join(', ') || 'Unassigned',
                            pmPriority: task.priority,
                            pmStartDate: task.startDate,
                            pmDueDate: task.finishDate,
                            pmNotes: '',
                            dependencies: [],
                            _predecessorData: task.predecessorData,
                            subtasks: []
                        };
                    })
                };

                phases.push(phase);
                phaseIndex++;
            });

            // Resolve dependencies - create typed dependency objects
            phases.forEach(phase => {
                phase.items.forEach(item => {
                    if (item._predecessorData && item._predecessorData.length > 0) {
                        item.dependencies = item._predecessorData
                            .map(pred => {
                                const treelistyId = uidToIdMap.get(pred.uid);
                                if (!treelistyId) return null;
                                return {
                                    predecessorId: treelistyId,
                                    type: pred.type || 'FS',
                                    lag: pred.lag || 0
                                };
                            })
                            .filter(dep => dep);
                    }
                    delete item._predecessorData;
                });
            });

            const totalItems = phases.reduce((sum, p) => sum + p.items.length, 0);
            console.log(`ğŸ“Š Flat list converted: ${phases.length} phases, ${totalItems} items`);

            return {
                projectName,
                phases
            };
        }

        /**
         * Handle MS Project XML file import
         */
        function importFromMSProject(file) {
            console.log('ğŸ“… MS Project file selected:', file.name);

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const xmlString = e.target.result;
                    const treeData = parseMSProjectXML(xmlString);

                    // Count items for confirmation
                    const itemCount = treeData.phases.reduce((sum, p) =>
                        sum + p.items.length + p.items.reduce((s, i) => s + (i.subtasks?.length || 0), 0), 0);

                    // Show confirmation modal
                    showMSProjectImportConfirmation(treeData, itemCount);

                } catch (error) {
                    console.error('âŒ MS Project import error:', error);
                    alert('âŒ Failed to import MS Project file!\n\n' + error.message);
                }
            };
            reader.readAsText(file);
        }

        /**
         * Show confirmation modal before importing MS Project data
         */
        function showMSProjectImportConfirmation(treeData, itemCount) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ğŸ“… Import from MS Project';

            const phaseCount = treeData.phases.length;
            const subtaskCount = treeData.phases.reduce((sum, p) =>
                sum + p.items.reduce((s, i) => s + (i.subtasks?.length || 0), 0), 0);

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: var(--bg-secondary); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <h3 style="margin: 0 0 16px 0; color: var(--text-primary);">ğŸ“Š ${treeData.projectName}</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                            <div style="text-align: center;">
                                <div style="font-size: 28px; font-weight: 700; color: var(--treeplex-primary);">${phaseCount}</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">Phases</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 28px; font-weight: 700; color: var(--treeplex-primary);">${itemCount - subtaskCount}</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">Tasks</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 28px; font-weight: 700; color: var(--treeplex-primary);">${subtaskCount}</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">Subtasks</div>
                            </div>
                        </div>
                    </div>

                    <div style="background: rgba(0, 166, 125, 0.1); border: 1px solid var(--treeplex-primary); border-radius: 8px; padding: 12px; margin-bottom: 20px;">
                        <div style="font-weight: 600; color: var(--treeplex-primary); margin-bottom: 8px;">âœ… Fields Imported:</div>
                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.6;">
                            Task hierarchy â€¢ Start/End dates â€¢ Duration â€¢ Progress % â€¢
                            Resources â†’ Assignees â€¢ Dependencies â€¢ Costs â€¢ Priority â€¢ Notes
                        </div>
                    </div>

                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 20px;">
                        This will <strong>replace</strong> your current project. Continue?
                    </p>

                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button class="btn" onclick="document.getElementById('modal').style.display='none';" style="padding: 10px 20px;">
                            Cancel
                        </button>
                        <button class="btn" id="msproject-import-confirm" style="background: var(--treeplex-primary); padding: 10px 24px; font-weight: 600;">
                            ğŸ“¥ Import Project
                        </button>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Handle import confirmation
            document.getElementById('msproject-import-confirm').addEventListener('click', () => {
                modal.style.display = 'none';

                // Use the existing importAnalyzedTree function
                // Default to capex pattern for MS Project imports (infrastructure/CAPEX projects)
                importAnalyzedTree(treeData, 'capex', false);

                showToast(`âœ… Imported ${itemCount} tasks from MS Project!`, 'success');
                console.log('ğŸ“… MS Project import complete:', treeData.projectName);
            });
        }

        // MS Project XML file upload handler
        document.getElementById('msproject-upload-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                importFromMSProject(file);
            }
            // Reset input
            e.target.value = '';
        });

        // MS Project import button click handler
        document.getElementById('msproject-import-btn').addEventListener('click', () => {
            document.getElementById('msproject-upload-input').click();
        });

        // =============================================================================
        // MS PROJECT XML EXPORT - Export TreeListy to MS Project XML format
        // =============================================================================

        /**
         * Export current TreeListy project to MS Project XML (MSPDI) format
         */
        function exportToMSProjectXML() {
            console.log('ğŸ“… Exporting to MS Project XML...');

            const projectName = capexTree.name || 'TreeListy Project';
            const now = new Date().toISOString();

            // Collect all tasks with their hierarchy info
            const tasks = [];
            const resources = new Map(); // name â†’ UID
            let taskUID = 1;
            let resourceUID = 1;

            // Add root project task (UID 0)
            tasks.push({
                UID: 0,
                ID: 0,
                Name: projectName,
                OutlineLevel: 0,
                Summary: true,
                WBS: '0'
            });

            // Process phases, items, and subtasks
            let taskID = 1;

            capexTree.children?.forEach((phase, phaseIndex) => {
                const phaseWBS = `${phaseIndex + 1}`;

                // Add phase as summary task
                tasks.push({
                    UID: taskUID,
                    ID: taskID,
                    Name: phase.name || phase.title || `Phase ${phaseIndex + 1}`,
                    OutlineLevel: 1,
                    Summary: true,
                    WBS: phaseWBS,
                    Notes: phase.subtitle || phase.description || '',
                    nodeId: phase.id  // Store original node ID for dependency lookup
                });
                const phaseTaskUID = taskUID;
                taskUID++;
                taskID++;

                // Process items in phase
                phase.items?.forEach((item, itemIndex) => {
                    const itemWBS = `${phaseWBS}.${itemIndex + 1}`;
                    const hasSubtasks = item.children && item.children.length > 0;

                    // Collect resource
                    if (item.pmAssignee && item.pmAssignee !== 'Unassigned') {
                        if (!resources.has(item.pmAssignee)) {
                            resources.set(item.pmAssignee, resourceUID++);
                        }
                    }

                    // Detect if this is a milestone (has flag or zero duration with same start/end)
                    const isMilestone = item.pmIsMilestone ||
                        (item.pmStartDate && item.pmStartDate === item.pmDueDate && !item.leadTime);

                    tasks.push({
                        UID: taskUID,
                        ID: taskID,
                        Name: item.name || item.title || 'Unnamed Task',
                        OutlineLevel: 2,
                        Summary: hasSubtasks && !isMilestone,  // Milestones are not summaries
                        Milestone: isMilestone,
                        WBS: itemWBS,
                        Notes: item.description || '',
                        Start: item.pmStartDate ? formatDateForMSProject(item.pmStartDate) : now,
                        Finish: item.pmDueDate ? formatDateForMSProject(item.pmDueDate) : now,
                        Duration: isMilestone ? 'PT0H0M0S' : formatDurationForMSProject(item.leadTime || item.pmDuration),
                        PercentComplete: item.pmProgress || 0,
                        Cost: item.cost || 0,
                        Priority: mapPriorityToMSProject(item.pmPriority),
                        Assignee: item.pmAssignee,
                        Dependencies: item.dependencies || [],
                        nodeId: item.id  // Store original node ID for dependency lookup
                    });
                    const itemTaskUID = taskUID;
                    taskUID++;
                    taskID++;

                    // Process subtasks
                    item.children?.forEach((subtask, subtaskIndex) => {
                        const subtaskWBS = `${itemWBS}.${subtaskIndex + 1}`;

                        // Collect resource
                        if (subtask.pmAssignee && subtask.pmAssignee !== 'Unassigned') {
                            if (!resources.has(subtask.pmAssignee)) {
                                resources.set(subtask.pmAssignee, resourceUID++);
                            }
                        }

                        tasks.push({
                            UID: taskUID,
                            ID: taskID,
                            Name: subtask.name || subtask.title || 'Unnamed Subtask',
                            OutlineLevel: 3,
                            Summary: false,
                            WBS: subtaskWBS,
                            Notes: subtask.description || '',
                            Start: subtask.pmStartDate ? formatDateForMSProject(subtask.pmStartDate) : now,
                            Finish: subtask.pmDueDate ? formatDateForMSProject(subtask.pmDueDate) : now,
                            Duration: formatDurationForMSProject(subtask.leadTime || subtask.pmDuration || '1 day'),
                            PercentComplete: subtask.pmProgress || 0,
                            Cost: subtask.cost || 0,
                            Priority: mapPriorityToMSProject(subtask.pmPriority),
                            Assignee: subtask.pmAssignee,
                            Dependencies: subtask.dependencies || [],
                            nodeId: subtask.id  // Store original node ID for dependency lookup
                        });
                        taskUID++;
                        taskID++;
                    });
                });
            });

            // Build XML document
            const xml = buildMSProjectXML(projectName, tasks, resources, now);

            // Download the file
            const blob = new Blob([xml], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${projectName.replace(/[^a-zA-Z0-9]/g, '_')}_MSProject.xml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast(`ğŸ“… Exported to MS Project XML (${tasks.length - 1} tasks)`, 'success');
            console.log('ğŸ“… MS Project XML export complete');
        }

        /**
         * Build MS Project XML (MSPDI format) document
         */
        function buildMSProjectXML(projectName, tasks, resources, timestamp) {
            // Build task ID map for dependency resolution
            const taskIdMap = new Map();
            tasks.forEach(t => {
                // Try to map TreeListy IDs to task UIDs
                if (t.WBS) {
                    taskIdMap.set(t.WBS, t.UID);
                }
            });

            let xml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Project xmlns="http://schemas.microsoft.com/project">
    <Name>${escapeXML(projectName)}</Name>
    <Title>${escapeXML(projectName)}</Title>
    <CreationDate>${timestamp}</CreationDate>
    <LastSaved>${timestamp}</LastSaved>
    <ScheduleFromStart>1</ScheduleFromStart>
    <StartDate>${timestamp}</StartDate>
    <CalendarUID>1</CalendarUID>
    <DefaultStartTime>08:00:00</DefaultStartTime>
    <DefaultFinishTime>17:00:00</DefaultFinishTime>
    <MinutesPerDay>480</MinutesPerDay>
    <MinutesPerWeek>2400</MinutesPerWeek>
    <DaysPerMonth>20</DaysPerMonth>
    <CurrencySymbol>$</CurrencySymbol>
    <CurrencyPosition>0</CurrencyPosition>
    <CurrencyDigits>2</CurrencyDigits>

    <Calendars>
        <Calendar>
            <UID>1</UID>
            <Name>Standard</Name>
            <IsBaseCalendar>1</IsBaseCalendar>
            <WeekDays>
                <WeekDay><DayType>1</DayType><DayWorking>0</DayWorking></WeekDay>
                <WeekDay><DayType>2</DayType><DayWorking>1</DayWorking></WeekDay>
                <WeekDay><DayType>3</DayType><DayWorking>1</DayWorking></WeekDay>
                <WeekDay><DayType>4</DayType><DayWorking>1</DayWorking></WeekDay>
                <WeekDay><DayType>5</DayType><DayWorking>1</DayWorking></WeekDay>
                <WeekDay><DayType>6</DayType><DayWorking>1</DayWorking></WeekDay>
                <WeekDay><DayType>7</DayType><DayWorking>0</DayWorking></WeekDay>
            </WeekDays>
        </Calendar>
    </Calendars>

    <Tasks>
`;

            // Add tasks
            tasks.forEach(task => {
                xml += `        <Task>
            <UID>${task.UID}</UID>
            <ID>${task.ID}</ID>
            <Name>${escapeXML(task.Name)}</Name>
            <WBS>${escapeXML(task.WBS || '')}</WBS>
            <OutlineLevel>${task.OutlineLevel}</OutlineLevel>
            <Summary>${task.Summary ? '1' : '0'}</Summary>
            <Milestone>${task.Milestone ? '1' : '0'}</Milestone>
            <Start>${task.Start || timestamp}</Start>
            <Finish>${task.Finish || timestamp}</Finish>
            <Duration>${task.Duration || 'PT8H0M0S'}</Duration>
            <PercentComplete>${task.PercentComplete || 0}</PercentComplete>
            <Cost>${task.Cost || 0}</Cost>
            <Priority>${task.Priority || 500}</Priority>
            <Notes>${escapeXML(task.Notes || '')}</Notes>
`;

                // Add predecessor links (dependencies)
                if (task.Dependencies && task.Dependencies.length > 0) {
                    task.Dependencies.forEach(dep => {
                        // Handle both string IDs (legacy) and typed objects {predecessorId, type, lag}
                        const predId = typeof dep === 'string' ? dep : (dep.predecessorId || dep);
                        const depType = typeof dep === 'object' ? (dep.type || 'FS') : 'FS';
                        const depLag = typeof dep === 'object' ? (dep.lag || 0) : 0;

                        // Try to find the UID for this dependency
                        const depUID = findTaskUIDByTreeListyId(tasks, predId);
                        if (depUID !== null) {
                            // Map dependency type: FF=0, FS=1, SF=2, SS=3
                            // Use ?? instead of || because FF=0 is falsy
                            const typeCode = {'FF': 0, 'FS': 1, 'SF': 2, 'SS': 3}[depType] ?? 1;
                            // Convert lag from days to tenths of minutes (1 day = 8h * 60min * 10)
                            const lagTenths = depLag * 8 * 60 * 10;

                            xml += `            <PredecessorLink>
                <PredecessorUID>${depUID}</PredecessorUID>
                <Type>${typeCode}</Type>
                <LinkLag>${lagTenths}</LinkLag>
                <LagFormat>7</LagFormat>
            </PredecessorLink>
`;
                        }
                    });
                }

                xml += `        </Task>
`;
            });

            xml += `    </Tasks>

    <Resources>
`;

            // Add resources
            resources.forEach((uid, name) => {
                xml += `        <Resource>
            <UID>${uid}</UID>
            <ID>${uid}</ID>
            <Name>${escapeXML(name)}</Name>
            <Type>1</Type>
        </Resource>
`;
            });

            xml += `    </Resources>

    <Assignments>
`;

            // Add assignments
            let assignmentUID = 1;
            tasks.forEach(task => {
                if (task.Assignee && task.Assignee !== 'Unassigned' && resources.has(task.Assignee)) {
                    xml += `        <Assignment>
            <UID>${assignmentUID}</UID>
            <TaskUID>${task.UID}</TaskUID>
            <ResourceUID>${resources.get(task.Assignee)}</ResourceUID>
        </Assignment>
`;
                    assignmentUID++;
                }
            });

            xml += `    </Assignments>
</Project>`;

            return xml;
        }

        /**
         * Find task UID by TreeListy ID (e.g., "item-0-1", "phase-2", "task-a")
         */
        function findTaskUIDByTreeListyId(tasks, treelistyId) {
            if (!treelistyId) return null;

            // First, try direct lookup by stored nodeId
            const directMatch = tasks.find(t => t.nodeId === treelistyId);
            if (directMatch) return directMatch.UID;

            // Try matching by name containing the ID (for task-a, task-b style)
            // Extract letter/number suffix: "task-a" â†’ "A", "task-12" â†’ "12"
            const taskMatch = treelistyId.match(/task-([a-z]|\d+)/i);
            if (taskMatch) {
                const suffix = taskMatch[1].toUpperCase();
                // Look for task name containing "Task A:" or similar
                const nameMatch = tasks.find(t =>
                    t.Name && (
                        t.Name.includes(`Task ${suffix}:`) ||
                        t.Name.includes(`Task ${suffix} `) ||
                        t.Name.startsWith(`Task ${suffix}`)
                    )
                );
                if (nameMatch) return nameMatch.UID;
            }

            // Parse TreeListy ID format: "item-{phase}-{item}" or "phase-{phase}"
            const itemMatch = treelistyId.match(/item-(\d+)-(\d+)/);
            if (itemMatch) {
                const phaseIdx = parseInt(itemMatch[1]);
                const itemIdx = parseInt(itemMatch[2]);
                // WBS would be "{phase+1}.{item+1}"
                const wbs = `${phaseIdx + 1}.${itemIdx + 1}`;
                const task = tasks.find(t => t.WBS === wbs);
                return task ? task.UID : null;
            }

            const phaseMatch = treelistyId.match(/phase-(\d+)/);
            if (phaseMatch) {
                const phaseIdx = parseInt(phaseMatch[1]);
                const wbs = `${phaseIdx + 1}`;
                const task = tasks.find(t => t.WBS === wbs);
                return task ? task.UID : null;
            }

            return null;
        }

        /**
         * Format date for MS Project XML
         */
        function formatDateForMSProject(dateStr) {
            if (!dateStr) return new Date().toISOString();
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return new Date().toISOString();
                return date.toISOString();
            } catch {
                return new Date().toISOString();
            }
        }

        /**
         * Format duration for MS Project XML (PT format)
         */
        function formatDurationForMSProject(durationStr) {
            if (!durationStr) return 'PT8H0M0S'; // Default 1 day

            // Handle numeric duration (days as number)
            if (typeof durationStr === 'number') {
                const hours = durationStr * 8; // 8 hours per day
                return `PT${hours}H0M0S`;
            }

            const lower = String(durationStr).toLowerCase();

            // Parse common formats
            const dayMatch = lower.match(/(\d+)\s*d/);
            const hourMatch = lower.match(/(\d+)\s*h/);
            const weekMatch = lower.match(/(\d+)\s*w/);
            const monthMatch = lower.match(/(\d+)\s*m(?:onth)?/);

            let hours = 0;

            if (weekMatch) {
                hours = parseInt(weekMatch[1]) * 40; // 5 days * 8 hours
            } else if (monthMatch) {
                hours = parseInt(monthMatch[1]) * 160; // 20 days * 8 hours
            } else if (dayMatch) {
                hours = parseInt(dayMatch[1]) * 8;
            } else if (hourMatch) {
                hours = parseInt(hourMatch[1]);
            } else {
                // Try to parse "X days", "X weeks", etc.
                const numMatch = lower.match(/(\d+)/);
                if (numMatch) {
                    const num = parseInt(numMatch[1]);
                    if (lower.includes('week')) {
                        hours = num * 40;
                    } else if (lower.includes('month')) {
                        hours = num * 160;
                    } else if (lower.includes('day')) {
                        hours = num * 8;
                    } else {
                        hours = num * 8; // Default to days
                    }
                } else {
                    hours = 8; // Default 1 day
                }
            }

            return `PT${hours}H0M0S`;
        }

        /**
         * Map TreeListy priority to MS Project priority (0-1000)
         */
        function mapPriorityToMSProject(priority) {
            if (!priority) return 500;
            const p = priority.toLowerCase();
            if (p === 'low') return 200;
            if (p === 'high') return 800;
            return 500; // Medium
        }

        /**
         * Escape special XML characters
         */
        function escapeXML(str) {
            if (!str) return '';
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        // MS Project export button click handler
        document.getElementById('msproject-export-btn').addEventListener('click', () => {
            exportToMSProjectXML();
        });

        // Redraw lines on scroll or resize
        const treeContainer = document.getElementById('tree-container');
        treeContainer.addEventListener('scroll', drawDependencyLines);
        window.addEventListener('resize', drawDependencyLines);

        // Load from shared URL if present - returns true if branch URL handled (skip initial render)
        const branchURLHandled = (function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);

            // Check for collaboration branch URL first - handle SYNCHRONOUSLY to prevent flash of default tree
            if (urlParams.has('branch')) {
                console.log('ğŸ¤ Branch URL detected - handling synchronously...');
                const success = handleBranchURL();
                if (success) {
                    console.log('âœ… Branch URL processed successfully');
                    return true; // Skip default render
                }
                // Fall through if branch handling failed
            }

            // Check for cloud share URL (?share=ID) - async, handled after page load
            if (urlParams.has('share')) {
                console.log('â˜ï¸ Cloud share URL detected - will load after initialization...');
                // Defer to after page initialization since Firebase may not be ready
                setTimeout(async () => {
                    if (window.checkForSharedTree) {
                        await window.checkForSharedTree();
                    }
                }, 500);
                return true; // Skip default render - cloud share will populate
            }

            const compressedData = urlParams.get('p');

            if (compressedData) {
                try {
                    console.log('Loading shared project from URL...');
                    const decompressed = LZString.decompressFromEncodedURIComponent(compressedData);

                    // DEBUG: Log first 500 chars of decompressed JSON
                    console.log('Decompressed JSON (first 500 chars):', decompressed.substring(0, 500));

                    const loadedTree = JSON.parse(decompressed);

                    // DEBUG: Check cost values in loaded tree
                    if (loadedTree.children && loadedTree.children[0] && loadedTree.children[0].items && loadedTree.children[0].items[0]) {
                        console.log('First item cost in loaded JSON:', loadedTree.children[0].items[0].cost);
                    }

                    // Replace capexTree with loaded data
                    capexTree = loadedTree;

                    // Update currentPattern if it's in the loaded data
                    if (capexTree.pattern) {
                        const patternKey = getPatternKey(capexTree.pattern);
                        if (patternKey) {
                            currentPattern = patternKey;
                        }
                    }

                    console.log('âœ… Shared project loaded successfully!');
                    console.log('Project:', capexTree.name || capexTree.title);
                    console.log('Pattern:', currentPattern);

                    // Simple success toast (no modal)
                    setTimeout(() => {
                        const toast = document.createElement('div');
                        toast.textContent = 'âœ… Project loaded!';
                        toast.style.cssText = `
                            position: fixed;
                            top: 80px;
                            right: 20px;
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            padding: 15px 25px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-weight: 600;
                        `;
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 2000);
                    }, 500);

                } catch (error) {
                    console.error('âŒ Failed to load shared project:', error);
                    alert('Failed to load shared project. The URL may be corrupted or invalid.');
                }
            }

            // Check for Google Drive file ID (?gdrive=FILE_ID or ?gdrive=SHARING_URL)
            // Also supports ?watch=URL for Watch Mode auto-start
            const gdriveParam = urlParams.get('gdrive');
            const watchParam = urlParams.get('watch');

            if (gdriveParam || watchParam) {
                const fileSource = gdriveParam || watchParam;
                console.log('â˜ï¸ Google Drive/Watch URL detected:', fileSource);

                // Extract file ID from various Google Drive URL formats
                let fileId = null;

                if (fileSource.includes('drive.google.com')) {
                    // Full Google Drive URL - extract file ID
                    const match = fileSource.match(/\/d\/([a-zA-Z0-9_-]+)/);
                    if (match) {
                        fileId = match[1];
                    }
                    // Also try ?id= format
                    const idMatch = fileSource.match(/[?&]id=([a-zA-Z0-9_-]+)/);
                    if (idMatch) {
                        fileId = idMatch[1];
                    }
                } else if (fileSource.match(/^[a-zA-Z0-9_-]{20,}$/)) {
                    // Just a file ID
                    fileId = fileSource;
                }

                if (fileId) {
                    // Use our proxy to avoid CORS issues
                    const proxyUrl = `/.netlify/functions/gdrive-proxy?id=${fileId}`;

                    // Fetch and load the file
                    setTimeout(async () => {
                        try {
                            showToast('â˜ï¸ Loading from Google Drive...', 'info');

                            const response = await fetch(proxyUrl);
                            const result = await response.json();

                            if (!response.ok || result.error) {
                                throw new Error(result.error || 'Failed to fetch');
                            }

                            const treeData = result;
                            capexTree = treeData;

                            // Update pattern if present in loaded data
                            if (treeData.pattern) {
                                const patternKey = getPatternKey(treeData.pattern);
                                if (patternKey) {
                                    currentPattern = patternKey;
                                    // Update pattern selector UI
                                    const patternSelect = document.getElementById('pattern-select');
                                    if (patternSelect) {
                                        patternSelect.value = currentPattern;
                                    }
                                    // Handle custom pattern labels
                                    if (currentPattern === 'custom' && treeData.pattern.labels) {
                                        customPatternNames = treeData.pattern.labels;
                                    }
                                    // Update related UI elements
                                    if (typeof updateSortDropdown === 'function') updateSortDropdown();
                                    if (typeof updateAIButtonLabel === 'function') updateAIButtonLabel();
                                    console.log('â˜ï¸ Pattern detected from Google Drive:', currentPattern);
                                }
                            }

                            // Add to recent files list
                            if (typeof addToRecentGdrive === 'function') {
                                addToRecentGdrive(fileId, treeData.name || treeData.projectName || 'Shared Project', currentPattern);
                            }

                            render();
                            if (viewMode === 'canvas') renderCanvas();

                            showToast('âœ… Loaded from Google Drive!', 'success');

                            // If this was a ?watch= parameter, auto-start Watch Mode
                            if (watchParam) {
                                // Pre-fill watch mode with this URL
                                const pathInput = document.getElementById('watch-file-path');
                                if (pathInput) pathInput.value = gdriveUrl;

                                // Show Watch Mode modal for user to enter name and start
                                setTimeout(() => {
                                    document.getElementById('watch-mode-modal').style.display = 'flex';
                                    showToast('ğŸ‘ï¸ Enter your name and click Start to sync!', 'info');
                                }, 1000);
                            }

                        } catch (error) {
                            console.error('âŒ Failed to load from Google Drive:', error);
                            showToast('âŒ Failed to load from Google Drive. Check the file is publicly shared.', 'error');
                        }
                    }, 100);
                }
            }

            return false;
        })();

        // =============================================================================
        // PWA & FILE HANDLING SYSTEM
        // =============================================================================

        // PWA install prompt event
        let deferredInstallPrompt = null;

        // Register service worker (only on http:// or https://, not file://)
        if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
            navigator.serviceWorker.register('./service-worker.js')
                .then(registration => {
                    console.log('âœ… Service Worker registered:', registration.scope);
                })
                .catch(error => {
                    console.error('âŒ Service Worker registration failed:', error);
                    console.error('Error details:', error.message, error.stack);
                });
        } else if (window.location.protocol === 'file:') {
            console.log('â„¹ï¸ Service Worker skipped (file:// protocol - not supported)');
        }

        if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {

            // Listen for file launches from service worker
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data.type === 'FILE_OPENED' && event.data.files) {
                    console.log('ğŸ“‚ File opened via file association:', event.data.files);
                    event.data.files.forEach(file => {
                        try {
                            const treeData = JSON.parse(file.content);
                            capexTree = treeData;
                            if (treeData.pattern) {
                                const patternKey = getPatternKey(treeData.pattern);
                                if (patternKey) {
                                    currentPattern = patternKey;
                                }
                            }
                            render();
                            console.log(`âœ… Loaded ${file.name}`);
                        } catch (error) {
                            console.error(`âŒ Failed to load ${file.name}:`, error);
                            alert(`Failed to load ${file.name}: Invalid JSON format`);
                        }
                    });
                }
            });
        }

        // Capture PWA install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('ğŸ’¾ PWA install prompt available - Button will trigger automatic install');
            e.preventDefault();
            deferredInstallPrompt = e;
        });

        // Debug: Check PWA install readiness
        console.log('ğŸ” PWA Debug Info:');
        console.log('- Service Worker supported:', 'serviceWorker' in navigator);
        console.log('- beforeinstallprompt listener added');
        console.log('- Manifest URL:', document.querySelector('link[rel="manifest"]')?.href);
        console.log('- Current URL:', window.location.href);
        console.log('- HTTPS:', window.location.protocol === 'https:');

        // Show PWA onboarding modal
        function showPWAOnboardingModal() {
            const modal = document.getElementById('pwa-onboarding-modal');
            modal.style.display = 'flex';
            // Button is always visible now - no need to check for prompt
        }

        // Install PWA button - Universal handler
        document.getElementById('pwa-install-btn').addEventListener('click', async () => {
            const instructionsDiv = document.getElementById('pwa-manual-instructions');

            if (deferredInstallPrompt) {
                // Automatic install available - trigger it
                try {
                    deferredInstallPrompt.prompt();

                    const { outcome } = await deferredInstallPrompt.userChoice;
                    console.log(`PWA install outcome: ${outcome}`);

                    if (outcome === 'accepted') {
                        console.log('âœ… User accepted PWA installation');

                        // Mark onboarding as completed
                        localStorage.setItem('treelisty-onboarding-seen', 'true');

                        // Close modal
                        document.getElementById('pwa-onboarding-modal').style.display = 'none';

                        // Show success message
                        const toast = document.createElement('div');
                        toast.textContent = 'âœ… TreeListy installed! You can now open .treelisty files by double-clicking them.';
                        toast.style.cssText = `
                            position: fixed;
                            top: 80px;
                            right: 20px;
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            padding: 15px 25px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-weight: 600;
                            max-width: 400px;
                        `;
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 5000);
                    } else {
                        console.log('âŒ User declined PWA installation');
                    }

                    deferredInstallPrompt = null;
                } catch (error) {
                    console.error('Install prompt error:', error);
                    // Fallback to manual instructions if prompt fails
                    instructionsDiv.style.display = 'block';
                }
            } else {
                // No automatic install - show manual instructions
                console.log('ğŸ“ Showing manual install instructions');
                instructionsDiv.style.display = 'block';

                // Change button text to indicate instructions are shown
                const btn = document.getElementById('pwa-install-btn');
                btn.textContent = 'âœ… See Instructions Below';
                btn.style.background = 'var(--card-bg)';
                btn.style.color = 'var(--text-secondary)';
                btn.disabled = true;
            }
        });

        // Skip onboarding button
        document.getElementById('pwa-skip-btn').addEventListener('click', () => {
            localStorage.setItem('treelisty-onboarding-seen', 'true');
            document.getElementById('pwa-onboarding-modal').style.display = 'none';
        });

        // Handle launchQueue for file opens (File Handling API)
        if ('launchQueue' in window) {
            window.launchQueue.setConsumer(async (launchParams) => {
                console.log('ğŸ“‚ File launch detected via File Handling API');

                if (launchParams.files && launchParams.files.length > 0) {
                    for (const fileHandle of launchParams.files) {
                        try {
                            const file = await fileHandle.getFile();
                            const content = await file.text();
                            const treeData = JSON.parse(content);

                            // Load the tree
                            capexTree = treeData;
                            if (treeData.pattern) {
                                const patternKey = getPatternKey(treeData.pattern);
                                if (patternKey) {
                                    currentPattern = patternKey;
                                }
                            }
                            render();

                            console.log(`âœ… Loaded ${file.name} via file association`);

                            // Show success toast
                            const toast = document.createElement('div');
                            toast.textContent = `âœ… Opened ${file.name}`;
                            toast.style.cssText = `
                                position: fixed;
                                top: 80px;
                                right: 20px;
                                background: linear-gradient(135deg, #10b981, #059669);
                                color: white;
                                padding: 15px 25px;
                                border-radius: 8px;
                                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                                z-index: 10000;
                                font-weight: 600;
                            `;
                            document.body.appendChild(toast);
                            setTimeout(() => toast.remove(), 3000);
                        } catch (error) {
                            console.error('âŒ Failed to load file:', error);
                            alert(`Failed to load file: ${error.message}`);
                        }
                    }
                }
            });
        } else {
            console.log('â„¹ï¸ File Handling API not supported in this browser');
        }

        // Initial render - skip if branch URL was handled (it already rendered)
        if (!branchURLHandled) {
            render();
        }

        // Update AI button label for initial pattern
        updateAIButtonLabel();

        // Initialize pattern selector
        const patternSelect = document.getElementById('pattern-select');
        console.log('Pattern selector found:', patternSelect);
        if (patternSelect) {
            // Load saved pattern from data
            if (capexTree.pattern && getPatternKey(capexTree.pattern)) {
                currentPattern = getPatternKey(capexTree.pattern);
                patternSelect.value = currentPattern;
                console.log('Loaded saved pattern:', currentPattern);
                if (currentPattern === 'custom' && capexTree.pattern.labels) {
                    customPatternNames = capexTree.pattern.labels;
                }
                // Apply pattern labels to existing nodes on load - skip if branch mode
                if (!branchURLHandled) {
                    const labels = currentPattern === 'custom' && customPatternNames ? customPatternNames : PATTERNS[currentPattern].levels;
                    renameNodesForPattern(capexTree, labels);
                    console.log('Initial nodes renamed to match saved pattern');
                    render(); // Re-render with renamed nodes
                }

                // Update sort dropdown for the loaded pattern
                updateSortDropdown();

                // Update AI button label for the loaded pattern
                updateAIButtonLabel();
            }
            // Handle pattern selection
            patternSelect.addEventListener('change', function() {
                console.log('Pattern selector changed to:', this.value);
                applyPattern(this.value);
            });
            console.log('Pattern selector event listener attached');
        } else {
            console.error('Pattern selector NOT found!');
        }

        // Initialize Theme Switcher
        const themeSelect = document.getElementById('theme-select');
        if (themeSelect) {
            // Load saved theme from localStorage
            const savedTheme = localStorage.getItem('treelisty-theme') || 'default';
            document.documentElement.setAttribute('data-theme', savedTheme);
            themeSelect.value = savedTheme;
            console.log('Theme loaded:', savedTheme);

            // Handle theme selection
            themeSelect.addEventListener('change', function() {
                const selectedTheme = this.value;
                console.log('Theme changed to:', selectedTheme);

                // Apply theme
                document.documentElement.setAttribute('data-theme', selectedTheme);

                // Save to localStorage
                localStorage.setItem('treelisty-theme', selectedTheme);

                // Show toast notification
                const themeNames = {
                    'default': 'ğŸŒ™ Default',
                    'steampunk': 'âš™ï¸ Steampunk',
                    'powerpuff': 'ğŸ’— Powerpuff',
                    'tron': 'ğŸ’  Tron'
                };
                const toast = document.createElement('div');
                toast.textContent = `Theme: ${themeNames[selectedTheme]}`;
                toast.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    right: 20px;
                    padding: 12px 24px;
                    background: var(--card-bg);
                    border: 2px solid var(--border);
                    border-radius: 12px;
                    color: var(--text-primary);
                    font-weight: 600;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: var(--shadow-lg);
                `;
                document.body.appendChild(toast);

                setTimeout(() => toast.remove(), 2000);
            });

            console.log('Theme switcher initialized');
        }

        // ============================================
        // SORTING SYSTEM
        // ============================================

        // Parse lead time string to days for comparison
        function parseLeadTimeToDays(leadTimeStr) {
            if (!leadTimeStr || leadTimeStr === 'N/A' || leadTimeStr === '') return 999999;

            const str = leadTimeStr.toLowerCase();
            let days = 0;

            // Match patterns like "12-18 months", "3-6 weeks", "2 days", etc.
            const monthsMatch = str.match(/(\d+)(?:-(\d+))?\s*months?/);
            const weeksMatch = str.match(/(\d+)(?:-(\d+))?\s*weeks?/);
            const daysMatch = str.match(/(\d+)(?:-(\d+))?\s*days?/);

            if (monthsMatch) {
                // Take average if range, otherwise use single value
                const avg = monthsMatch[2] ? (parseInt(monthsMatch[1]) + parseInt(monthsMatch[2])) / 2 : parseInt(monthsMatch[1]);
                days = avg * 30; // Approximate months to days
            } else if (weeksMatch) {
                const avg = weeksMatch[2] ? (parseInt(weeksMatch[1]) + parseInt(weeksMatch[2])) / 2 : parseInt(weeksMatch[1]);
                days = avg * 7;
            } else if (daysMatch) {
                const avg = daysMatch[2] ? (parseInt(daysMatch[1]) + parseInt(daysMatch[2])) / 2 : parseInt(daysMatch[1]);
                days = avg;
            }

            return days || 999999; // Return large number if unparseable
        }

        // Compare two values based on type
        function compareValues(a, b, type, order) {
            let valA, valB;

            switch(type) {
                case 'number':
                    valA = parseFloat(a) || 0;
                    valB = parseFloat(b) || 0;
                    break;

                case 'leadtime':
                    valA = parseLeadTimeToDays(a);
                    valB = parseLeadTimeToDays(b);
                    break;

                case 'date':
                    valA = a ? new Date(a).getTime() : 0;
                    valB = b ? new Date(b).getTime() : 0;
                    break;

                case 'text':
                default:
                    valA = (a || '').toString().toLowerCase();
                    valB = (b || '').toString().toLowerCase();
                    if (order === 'asc') return valA.localeCompare(valB);
                    return valB.localeCompare(valA);
            }

            if (order === 'asc') return valA - valB;
            return valB - valA;
        }

        // Recursively sort items array and all nested levels
        function sortItemsArray(items, sortConfig) {
            if (!items || !Array.isArray(items) || items.length === 0) return items;
            if (!sortConfig) return items;

            const { field, order, type } = sortConfig;

            // Special handling for "folders first" sorting in filesystem pattern
            if (currentPattern === 'filesystem' && field === 'isFolder') {
                items.sort((a, b) => {
                    // Folders always come before files when sorting by type
                    const aIsFolder = a.isFolder || false;
                    const bIsFolder = b.isFolder || false;

                    if (aIsFolder && !bIsFolder) return order === 'desc' ? -1 : 1;
                    if (!aIsFolder && bIsFolder) return order === 'desc' ? 1 : -1;

                    // If both are folders or both are files, sort by name as secondary
                    return (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase());
                });
            } else {
                // Standard sorting for all other fields
                items.sort((a, b) => {
                    return compareValues(a[field], b[field], type, order);
                });
            }

            // Recursively sort nested arrays (items, subItems, and children for all patterns)
            items.forEach(item => {
                // Sort standard items array (4-level patterns)
                if (item.items && Array.isArray(item.items) && item.items.length > 0) {
                    sortItemsArray(item.items, sortConfig);
                }

                // Sort subItems array (flexible depth patterns like filesystem)
                if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                    sortItemsArray(item.subItems, sortConfig);
                }

                // Sort children array (filesystem pattern uses this for nested folders)
                if (item.children && Array.isArray(item.children) && item.children.length > 0) {
                    sortItemsArray(item.children, sortConfig);
                }
            });

            return items;
        }

        // Sort the entire tree - applies to all nodes at all depths
        function sortTree(sortConfig) {
            if (!sortConfig) {
                // For filesystem pattern, apply default "folders first + alphabetical" sort
                if (currentPattern === 'filesystem') {
                    sortConfig = {
                        value: 'default-filesystem',
                        field: 'isFolder',
                        order: 'desc',
                        type: 'boolean'
                    };
                    currentSortConfig = sortConfig;
                } else {
                    // Reset to original order for other patterns
                    currentSortConfig = null;
                    render();
                    return;
                }
            } else {
                currentSortConfig = sortConfig;
            }

            // Sort phases (drives for filesystem pattern)
            if (capexTree.phases && capexTree.phases.length > 0) {
                sortItemsArray(capexTree.phases, sortConfig);

                // Sort all items within each phase recursively
                capexTree.phases.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        sortItemsArray(phase.items, sortConfig);
                    }
                });
            }

            // Sort children array (for root level if exists)
            if (capexTree.children && capexTree.children.length > 0) {
                sortItemsArray(capexTree.children, sortConfig);
            }

            // Re-render to show sorted tree with new visual order
            // Check if 3D view is active (it's an overlay, not a viewMode value)
            const view3D = document.getElementById('view-3d');
            const is3DActive = view3D && view3D.classList.contains('active');

            if (is3DActive) {
                // Refresh 3D view with new sort-based layout
                if (typeof window.refresh3DData === 'function') {
                    window.refresh3DData();
                    console.log('3D sorted by:', sortConfig, '- 3D layout transformed');
                }
            } else if (viewMode === 'canvas') {
                // Clear canvas coordinates to force re-positioning in new sorted order
                capexTree.children.forEach(phase => {
                    const nodeList = phase.items || phase.children || phase.subItems || [];
                    nodeList.forEach(node => clearCanvasCoordinates(node));
                });

                // Migrate coordinates based on new sorted order
                migrateToCanvasCoordinates();

                renderCanvas();
                console.log('Canvas sorted by:', sortConfig, '- Canvas layout updated and repositioned');
            } else {
                render();
                console.log('Tree sorted by:', sortConfig, '- Visual layout updated');
            }
        }

        // Initialize Sort System
        const sortSelect = document.getElementById('pattern-sort-select');
        const resetSortBtn = document.getElementById('reset-sort-btn');

        if (sortSelect) {
            // Handle sort selection
            sortSelect.addEventListener('change', function() {
                const selectedOption = this.options[this.selectedIndex];

                if (!this.value || this.value === '') {
                    // Reset to default order
                    currentSortConfig = null;
                    sortTree(null);
                    if (resetSortBtn) resetSortBtn.style.display = 'none';
                    console.log('Sort reset to default order');

                    // Auto-sync: reset cluster too if linked
                    if (sortClusterLinked) {
                        const clusterSelect = document.getElementById('cluster-by-select');
                        if (clusterSelect) {
                            clusterSelect.value = '';
                            clusterByField = '';
                            if (viewMode === 'canvas') {
                                applyForceDirectedLayout();
                                renderCanvas();
                            }
                        }
                    }
                } else {
                    // Apply sort
                    const sortConfig = {
                        value: this.value,
                        field: selectedOption.dataset.field,
                        order: selectedOption.dataset.order,
                        type: selectedOption.dataset.type
                    };

                    sortTree(sortConfig);
                    if (resetSortBtn) resetSortBtn.style.display = 'inline-block';

                    // Auto-sync: update cluster to match sort field if linked
                    if (sortClusterLinked && sortConfig.field) {
                        const clusterSelect = document.getElementById('cluster-by-select');
                        if (clusterSelect) {
                            // Try to find matching cluster option
                            const matchingOption = Array.from(clusterSelect.options).find(
                                opt => opt.value === sortConfig.field
                            );
                            if (matchingOption) {
                                clusterSelect.value = sortConfig.field;
                                clusterByField = sortConfig.field;
                                if (viewMode === 'canvas') {
                                    applyForceDirectedLayout();
                                    renderCanvas();
                                }
                                console.log(`ğŸ”— Auto-synced Cluster to: ${sortConfig.field}`);
                            }
                        }
                    }

                    // Show toast notification
                    const linkedMsg = sortClusterLinked ? ' (Canvas synced)' : '';
                    showToast(`Sorted: ${selectedOption.textContent}${linkedMsg}`, 'success', 2000);
                }
            });

            console.log('Sort dropdown event listener attached');
        }

        if (resetSortBtn) {
            resetSortBtn.addEventListener('click', function() {
                currentSortConfig = null;
                sortTree(null);
                sortSelect.value = '';
                this.style.display = 'none';

                // Show toast notification
                const toast = document.createElement('div');
                toast.textContent = 'Sort Reset';
                toast.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    right: 20px;
                    padding: 12px 24px;
                    background: var(--card-bg);
                    border: 2px solid var(--border);
                    border-radius: 12px;
                    color: var(--text-primary);
                    font-weight: 600;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: var(--shadow-lg);
                `;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2000);
            });
        }

        // Update sort dropdown on initial load
        updateSortDropdown();

        // Sort-Cluster link toggle button
        const linkBtn = document.getElementById('sort-cluster-link-btn');
        if (linkBtn) {
            linkBtn.addEventListener('click', function() {
                sortClusterLinked = !sortClusterLinked;
                this.textContent = sortClusterLinked ? 'ğŸ”—' : 'ğŸ”“';
                this.title = sortClusterLinked
                    ? 'Click to unlink Sort from Canvas Cluster. When linked, changing Sort also changes Canvas clustering.'
                    : 'Click to link Sort with Canvas Cluster. Currently independent.';
                this.style.opacity = sortClusterLinked ? '0.8' : '0.5';
                showToast(sortClusterLinked ? 'ğŸ”— Sort & Cluster linked' : 'ğŸ”“ Sort & Cluster independent', 'info', 2000);
            });
        }

        console.log('Sorting system initialized');

        // ============================================
        // AI TOOLS SIDEBAR SYNC
        // ============================================
        // Note: AI Tools sidebar is always visible and auto-expands on hover (no toggle needed)

        const aiModeSelectHeader = document.getElementById('unified-ai-mode-select');
        const aiModeSelectPanel = document.getElementById('unified-ai-mode-select-panel');

        // Sync AI Model selectors (header <-> panel)
        if (aiModeSelectHeader && aiModeSelectPanel) {
            // Sync panel -> header
            aiModeSelectPanel.addEventListener('change', function() {
                aiModeSelectHeader.value = this.value;
                console.log('AI mode synced from panel to header:', this.value);
            });

            // Sync header -> panel
            aiModeSelectHeader.addEventListener('change', function() {
                aiModeSelectPanel.value = this.value;
                console.log('AI mode synced from header to panel:', this.value);
            });

            // Initial sync
            aiModeSelectPanel.value = aiModeSelectHeader.value;
        }

        console.log('AI Tools panel initialized');

        // Initialize pan/zoom controls
        initPanZoom();

        // Splash screen auto-dismiss
        setTimeout(() => {
            const splashScreen = document.getElementById('splash-screen');
            if (splashScreen) {
                splashScreen.classList.add('fade-out');
                // Remove from DOM after fade-out animation completes
                setTimeout(() => {
                    splashScreen.remove();
                }, 500); // Match fade-out animation duration
            }
        }, 2000); // Show splash for 2 seconds (matches loader animation)

        // ============================================================================
        // FREE SPEECH - Stream of Consciousness Voice Capture (Build 240)
        // ============================================================================

        // Free Speech Session State
        const freeSpeechSession = {
            // State machine: IDLE -> WARMUP -> RECORDING -> PROCESSING -> REVEAL
            state: 'IDLE',

            // Web Speech API
            recognition: null,

            // Transcript (EPHEMERAL - never persisted, deleted after analysis)
            transcript: [],

            // Nudge system
            nudgeTimer: null,
            lastSpeechTime: null,
            currentNudgeIndex: 0,

            // Gamification metrics
            metrics: {
                totalDuration: 0,
                silenceCount: 0,
                nudgeCount: 0,
                wordCount: 0,
                uniqueWords: new Set(),
                fillerWords: 0,
                hedgeCount: 0,
                restartCount: 0,
                longestUninterruptedFlow: 0,
                currentFlowDuration: 0,
                startTime: null
            }
        };

        // Nudge prompts - gentle, non-judgmental momentum maintainers
        const NUDGES = [
            { text: '...', delay: 5000 },          // Soft ellipsis after 5s
            { text: 'mmhmm...', delay: 8000 },     // Acknowledgment after 8s
            { text: 'and...?', delay: 12000 },     // Continuation prompt
            { text: 'keep going...', delay: 16000 },
            { text: 'what else...?', delay: 20000 },
            { text: 'take your time...', delay: 25000 }
        ];

        // Filler words to detect
        const FILLER_WORDS = ['um', 'uh', 'like', 'you know', 'basically', 'actually', 'literally', 'sort of', 'kind of'];

        // Hedge words (self-editing indicators)
        const HEDGE_WORDS = ['i think', 'maybe', 'probably', 'i guess', 'i mean', 'sort of', 'kind of', 'i suppose'];

        // Restart indicators
        const RESTART_PHRASES = ['no wait', 'let me start over', 'actually no', 'i mean', 'scratch that', 'no no'];

        // Open Free Speech modal
        function openFreeSpeechModal() {
            const modal = document.getElementById('freespeech-modal');
            if (modal) {
                modal.style.display = 'flex';
                resetFreeSpeechModal();
            }
        }

        // Close Free Speech modal
        function closeFreeSpeechModal() {
            const modal = document.getElementById('freespeech-modal');
            if (modal) {
                modal.style.display = 'none';
                stopFreeSpeechRecording();
            }
        }

        // Reset modal to idle state
        function resetFreeSpeechModal() {
            freeSpeechSession.state = 'IDLE';
            freeSpeechSession.transcript = [];
            freeSpeechSession.currentNudgeIndex = 0;

            // Reset metrics
            freeSpeechSession.metrics = {
                totalDuration: 0,
                silenceCount: 0,
                nudgeCount: 0,
                wordCount: 0,
                uniqueWords: new Set(),
                fillerWords: 0,
                hedgeCount: 0,
                restartCount: 0,
                longestUninterruptedFlow: 0,
                currentFlowDuration: 0,
                startTime: null
            };

            // Show/hide appropriate sections
            document.getElementById('freespeech-idle').style.display = 'block';
            document.getElementById('freespeech-warmup').style.display = 'none';
            document.getElementById('freespeech-recording').style.display = 'none';
            document.getElementById('freespeech-processing').style.display = 'none';
            document.getElementById('freespeech-error').style.display = 'none';
            document.getElementById('freespeech-nudge').textContent = '';
        }

        // Start warmup countdown
        function startFreeSpeechWarmup() {
            // Check for Web Speech API support
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showFreeSpeechError('Speech recognition is not supported in this browser. Please use Chrome, Edge, or Safari.');
                return;
            }

            freeSpeechSession.state = 'WARMUP';
            document.getElementById('freespeech-idle').style.display = 'none';
            document.getElementById('freespeech-warmup').style.display = 'block';

            // Countdown animation
            const countdownEl = document.getElementById('freespeech-countdown');
            let count = 3;
            countdownEl.textContent = count;

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.textContent = count;
                } else {
                    clearInterval(countdownInterval);
                    startFreeSpeechRecording();
                }
            }, 1000);
        }

        // Start actual recording
        function startFreeSpeechRecording() {
            freeSpeechSession.state = 'RECORDING';
            document.getElementById('freespeech-warmup').style.display = 'none';
            document.getElementById('freespeech-recording').style.display = 'block';

            // Initialize Web Speech API
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            freeSpeechSession.recognition = new SpeechRecognition();

            const recognition = freeSpeechSession.recognition;
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            // Track timing
            freeSpeechSession.metrics.startTime = Date.now();
            freeSpeechSession.lastSpeechTime = Date.now();

            // Handle speech results
            recognition.onresult = (event) => {
                const now = Date.now();

                // Calculate flow duration
                const timeSinceLastSpeech = now - freeSpeechSession.lastSpeechTime;
                if (timeSinceLastSpeech < 2000) {
                    freeSpeechSession.metrics.currentFlowDuration += timeSinceLastSpeech;
                } else {
                    // Flow broken, check if it was longest
                    if (freeSpeechSession.metrics.currentFlowDuration > freeSpeechSession.metrics.longestUninterruptedFlow) {
                        freeSpeechSession.metrics.longestUninterruptedFlow = freeSpeechSession.metrics.currentFlowDuration;
                    }
                    freeSpeechSession.metrics.currentFlowDuration = 0;
                }
                freeSpeechSession.lastSpeechTime = now;

                // Process results
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    const text = result[0].transcript.trim();

                    if (result.isFinal) {
                        if (text) {
                            freeSpeechSession.transcript.push({
                                text: text,
                                timestamp: now - freeSpeechSession.metrics.startTime,
                                confidence: result[0].confidence
                            });
                            console.log('Captured:', text);

                            // Analyze for metrics
                            analyzeTranscriptSegment(text);
                        }
                        // Clear the "hearing" indicator
                        document.getElementById('freespeech-nudge').textContent = '';
                    } else {
                        // Show interim results so user knows mic is working
                        // (but don't show the actual words - just indicate hearing)
                        const wordCount = text.split(/\s+/).length;
                        if (wordCount > 0) {
                            document.getElementById('freespeech-nudge').innerHTML = '<span style="color: #10b981;">ğŸ§ hearing you...</span>';
                        }
                    }
                }

                // Clear nudge when user speaks
                freeSpeechSession.currentNudgeIndex = 0;
                resetNudgeTimer();
            };

            recognition.onerror = (event) => {
                console.log('Speech recognition event:', event.error);
                // These errors are normal and should not stop recording
                if (event.error === 'no-speech' || event.error === 'aborted' || event.error === 'network') {
                    console.log('Non-fatal speech error, continuing...');
                    return;
                }
                // Only show error for real problems
                if (event.error === 'not-allowed') {
                    showFreeSpeechError('Microphone access denied. Please allow microphone permission and try again.');
                } else if (event.error === 'audio-capture') {
                    showFreeSpeechError('No microphone found. Please connect a microphone and try again.');
                } else {
                    showFreeSpeechError(`Speech recognition error: ${event.error}`);
                }
            };

            recognition.onstart = () => {
                console.log('Speech recognition started successfully');
            };

            recognition.onaudiostart = () => {
                console.log('Audio capture started - microphone is active');
            };

            recognition.onend = () => {
                console.log('Speech recognition ended, state:', freeSpeechSession.state);
                // Restart if still recording (continuous mode workaround for Chrome)
                if (freeSpeechSession.state === 'RECORDING') {
                    console.log('Restarting recognition...');
                    setTimeout(() => {
                        if (freeSpeechSession.state === 'RECORDING') {
                            try {
                                recognition.start();
                            } catch (e) {
                                console.log('Recognition restart blocked:', e);
                            }
                        }
                    }, 100); // Small delay before restart
                }
            };

            // Start recognition
            try {
                console.log('Starting speech recognition...');
                recognition.start();
                startNudgeTimer();
                console.log('Recognition start() called');
            } catch (e) {
                console.error('Failed to start:', e);
                showFreeSpeechError('Failed to start speech recognition. Please try again.');
            }
        }

        // Analyze a transcript segment for metrics
        function analyzeTranscriptSegment(text) {
            const words = text.toLowerCase().split(/\s+/);
            freeSpeechSession.metrics.wordCount += words.length;

            words.forEach(word => {
                freeSpeechSession.metrics.uniqueWords.add(word.replace(/[^a-z]/g, ''));
            });

            // Check for filler words
            const lowerText = text.toLowerCase();
            FILLER_WORDS.forEach(filler => {
                const regex = new RegExp(`\\b${filler}\\b`, 'gi');
                const matches = lowerText.match(regex);
                if (matches) {
                    freeSpeechSession.metrics.fillerWords += matches.length;
                }
            });

            // Check for hedges
            HEDGE_WORDS.forEach(hedge => {
                if (lowerText.includes(hedge)) {
                    freeSpeechSession.metrics.hedgeCount++;
                }
            });

            // Check for restarts
            RESTART_PHRASES.forEach(restart => {
                if (lowerText.includes(restart)) {
                    freeSpeechSession.metrics.restartCount++;
                }
            });
        }

        // Nudge timer management
        function startNudgeTimer() {
            clearNudgeTimer();
            freeSpeechSession.nudgeTimer = setInterval(() => {
                if (freeSpeechSession.state !== 'RECORDING') {
                    clearNudgeTimer();
                    return;
                }

                const timeSinceLastSpeech = Date.now() - freeSpeechSession.lastSpeechTime;

                // Find appropriate nudge based on silence duration
                for (let i = NUDGES.length - 1; i >= 0; i--) {
                    if (timeSinceLastSpeech >= NUDGES[i].delay) {
                        if (i > freeSpeechSession.currentNudgeIndex - 1) {
                            document.getElementById('freespeech-nudge').textContent = NUDGES[i].text;
                            freeSpeechSession.currentNudgeIndex = i + 1;
                            freeSpeechSession.metrics.nudgeCount++;
                            freeSpeechSession.metrics.silenceCount++;
                        }
                        break;
                    }
                }
            }, 1000);
        }

        function resetNudgeTimer() {
            freeSpeechSession.currentNudgeIndex = 0;
        }

        function clearNudgeTimer() {
            if (freeSpeechSession.nudgeTimer) {
                clearInterval(freeSpeechSession.nudgeTimer);
                freeSpeechSession.nudgeTimer = null;
            }
        }

        // Stop recording and process
        function stopFreeSpeechRecording() {
            if (freeSpeechSession.recognition) {
                freeSpeechSession.recognition.stop();
                freeSpeechSession.recognition = null;
            }
            clearNudgeTimer();

            if (freeSpeechSession.state === 'RECORDING') {
                // Calculate final duration
                if (freeSpeechSession.metrics.startTime) {
                    freeSpeechSession.metrics.totalDuration = (Date.now() - freeSpeechSession.metrics.startTime) / 1000;
                }

                // Check final flow
                if (freeSpeechSession.metrics.currentFlowDuration > freeSpeechSession.metrics.longestUninterruptedFlow) {
                    freeSpeechSession.metrics.longestUninterruptedFlow = freeSpeechSession.metrics.currentFlowDuration;
                }

                // Process transcript
                processFreeSpeechTranscript();
            }
        }

        // Process transcript with AI
        async function processFreeSpeechTranscript() {
            freeSpeechSession.state = 'PROCESSING';
            document.getElementById('freespeech-recording').style.display = 'none';
            document.getElementById('freespeech-processing').style.display = 'block';

            // Check if we have any transcript
            if (freeSpeechSession.transcript.length === 0) {
                showFreeSpeechError('No speech was detected. Please try again and speak clearly.');
                return;
            }

            // Combine transcript
            const fullTranscript = freeSpeechSession.transcript.map(t => t.text).join(' ');

            // Show progress
            const progressEl = document.getElementById('freespeech-progress');
            progressEl.style.width = '20%';

            try {
                // Call AI to analyze
                const tree = await analyzeFreeSpeechTranscript(fullTranscript, freeSpeechSession.metrics);
                progressEl.style.width = '100%';

                // Small delay for visual feedback
                await new Promise(resolve => setTimeout(resolve, 500));

                // Load the tree and close modal
                if (tree) {
                    // Set the pattern
                    currentPattern = 'freespeech';

                    // Load tree data
                    capexTree = tree;

                    // Render
                    render();

                    // Close modal
                    closeFreeSpeechModal();

                    // Show success notification
                    if (typeof showNotification === 'function') {
                        showNotification('Free Speech session analyzed! Explore your psychological patterns.', 'success');
                    }
                }
            } catch (error) {
                console.error('Free Speech analysis error:', error);
                showFreeSpeechError('Failed to analyze your speech. Please try again.');
            } finally {
                // PRIVACY: Delete transcript immediately after analysis
                freeSpeechSession.transcript = [];
            }
        }

        // AI Analysis function
        async function analyzeFreeSpeechTranscript(transcript, metrics) {
            const systemPrompt = `You are a psychological pattern analyst examining stream-of-consciousness speech.
The speaker was encouraged to talk freely without self-editing.

DO NOT summarize what they said.
DO NOT organize their explicit points.
DO NOT judge or evaluate their thoughts.

Your task is to find SURPRISING PATTERNS that reveal psychological topology:

1. REPETITION - Words/phrases/themes appearing 3+ times
   (Repetition = importance, even if speaker doesn't realize it)

2. EMOTIONAL WEIGHT - Where language intensifies
   (Stronger adjectives, qualifiers like "really", "actually", "honestly")

3. NAMED ENTITIES - Who/what mentioned, frequency, context
   (Frequency reveals actual vs stated priorities)

4. CONTRADICTIONS - Opposing statements or logical inconsistencies
   (Windows into internal conflict or ambivalence)

5. AVOIDANCE - Logical topics that SHOULD have appeared but DIDN'T
   (Negative space is data - what wasn't said matters)

6. IMPLICIT BELIEFS - Unstated assumptions underlying statements
   ("I just need to work harder" assumes effort = results)

7. SENTENCE STRUCTURES - Patterns like "I should..." vs "I want..." vs "I have to..."
   (Grammar reveals agency patterns and relationship to desires)

Output a TreeListy-compatible JSON tree that REVEALS rather than ORGANIZES.

The tree should have this structure:
{
  "id": "session-[timestamp]",
  "name": "[Create a poetic/insightful session title based on themes]",
  "type": "session",
  "pattern": "freespeech",
  "children": [
    {
      "id": "theme-1",
      "name": "[Theme Name]",
      "type": "phase",
      "items": [
        {
          "id": "pattern-1",
          "name": "[Pattern Name]",
          "type": "item",
          "itemType": "[one of: repetition, emotional, contradiction, avoidance, implicit, entity, structure]",
          "frequency": [number],
          "emotionalIntensity": "[Low/Medium/High/Peak]",
          "quotedText": "[exact words from transcript]",
          "insight": "[what this pattern reveals]",
          "subItems": [
            {
              "id": "evidence-1",
              "name": "[Evidence summary]",
              "type": "subtask",
              "quotedText": "[supporting quote]"
            }
          ]
        }
      ]
    }
  ]
}

Session Metrics (for context):
- Duration: ${Math.round(metrics.totalDuration)} seconds
- Word count: ${metrics.wordCount}
- Unique words: ${metrics.uniqueWords.size}
- Filler words: ${metrics.fillerWords}
- Self-editing hedges: ${metrics.hedgeCount}
- Restarts: ${metrics.restartCount}
- Nudges needed: ${metrics.nudgeCount}
- Longest uninterrupted flow: ${Math.round(metrics.longestUninterruptedFlow / 1000)} seconds`;

            const userPrompt = `Analyze this stream-of-consciousness transcript and return ONLY valid JSON (no markdown, no explanation):

TRANSCRIPT:
${transcript}`;

            try {
                // Use the existing AI call infrastructure
                const response = await callClaudeAPI(systemPrompt, userPrompt);

                // Parse the JSON response
                let tree;
                try {
                    // Try to extract JSON from response
                    const jsonMatch = response.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        tree = JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('No JSON found in response');
                    }
                } catch (parseError) {
                    console.error('JSON parse error:', parseError);
                    // Create a minimal fallback tree
                    tree = {
                        id: `session-${Date.now()}`,
                        name: 'Free Speech Session',
                        type: 'session',
                        pattern: 'freespeech',
                        children: [{
                            id: 'theme-1',
                            name: 'Raw Transcript',
                            type: 'phase',
                            items: [{
                                id: 'pattern-1',
                                name: 'Full Recording',
                                type: 'item',
                                itemType: 'repetition',
                                frequency: 1,
                                emotionalIntensity: 'Medium',
                                quotedText: transcript.substring(0, 500) + (transcript.length > 500 ? '...' : ''),
                                insight: 'Analysis could not be parsed. Raw transcript preserved.',
                                subItems: []
                            }]
                        }]
                    };
                }

                return tree;
            } catch (error) {
                console.error('AI call error:', error);
                throw error;
            }
        }

        // Show error state
        function showFreeSpeechError(message) {
            freeSpeechSession.state = 'ERROR';
            document.getElementById('freespeech-idle').style.display = 'none';
            document.getElementById('freespeech-warmup').style.display = 'none';
            document.getElementById('freespeech-recording').style.display = 'none';
            document.getElementById('freespeech-processing').style.display = 'none';
            document.getElementById('freespeech-error').style.display = 'block';
            document.getElementById('freespeech-error-message').textContent = message;
        }

        // Expose functions globally
        window.openFreeSpeechModal = openFreeSpeechModal;
        window.closeFreeSpeechModal = closeFreeSpeechModal;
        window.startFreeSpeechWarmup = startFreeSpeechWarmup;
        window.stopFreeSpeechRecording = stopFreeSpeechRecording;
        window.resetFreeSpeechModal = resetFreeSpeechModal;

        console.log('Free Speech module initialized (Build 240)');

    </script>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         QUICK CAPTURE MODULE (Build 469)
         URL: ?capture=1 - Immediate voice capture for conversations
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script>
    (function() {
        'use strict';

        // Quick Capture State
        const quickCapture = {
            active: false,
            recognition: null,
            transcript: [],
            startTime: null,
            timerInterval: null,
            waveformInterval: null,
            autoStopTimeout: null
        };

        // Check for capture mode on page load
        function checkCaptureMode() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('capture') === '1') {
                console.log('ğŸ™ï¸ Quick Capture mode detected');
                // Get optional duration parameter (e.g., ?capture=1&duration=5 for 5 minutes)
                const duration = parseInt(urlParams.get('duration')) || 0;
                // Small delay to let page initialize
                setTimeout(() => enterCaptureMode(duration), 500);
            }
        }

        // Enter capture mode
        function enterCaptureMode(autoStopMinutes = 0) {
            // Check for Web Speech API support
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showCaptureError('Speech recognition not supported in this browser. Use Chrome, Edge, or Safari.');
                return;
            }

            quickCapture.active = true;
            const overlay = document.getElementById('quick-capture-overlay');
            overlay.style.display = 'flex';

            // Initialize waveform bars
            initWaveform();

            // Start recording
            startCaptureRecording();

            // Set up auto-stop if duration specified
            if (autoStopMinutes > 0) {
                quickCapture.autoStopTimeout = setTimeout(() => {
                    stopCaptureRecording();
                }, autoStopMinutes * 60 * 1000);
            }
        }

        // Initialize waveform visualization
        function initWaveform() {
            const container = document.getElementById('qc-waveform');
            container.innerHTML = '';
            // Create 20 bars
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.style.cssText = `
                    width: 8px;
                    height: 20px;
                    background: linear-gradient(180deg, #6366f1, #8b5cf6);
                    border-radius: 4px;
                    transition: height 0.1s ease;
                `;
                container.appendChild(bar);
            }
            // Animate bars
            quickCapture.waveformInterval = setInterval(() => {
                const bars = container.children;
                for (let bar of bars) {
                    const height = 10 + Math.random() * 60;
                    bar.style.height = height + 'px';
                }
            }, 100);
        }

        // Start recording
        function startCaptureRecording() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            quickCapture.recognition = new SpeechRecognition();

            const recognition = quickCapture.recognition;
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            quickCapture.startTime = Date.now();
            quickCapture.transcript = [];

            // Start timer
            updateTimer();
            quickCapture.timerInterval = setInterval(updateTimer, 1000);

            // Handle results
            recognition.onresult = (event) => {
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    if (event.results[i].isFinal) {
                        const text = event.results[i][0].transcript.trim();
                        if (text) {
                            quickCapture.transcript.push({
                                text: text,
                                timestamp: Date.now() - quickCapture.startTime
                            });
                        }
                    }
                }
            };

            // BUILD 505: Track restart attempts for Safari workaround
            let restartAttempts = 0;
            const maxRestarts = 50; // Allow many restarts for long recordings

            recognition.onerror = (event) => {
                console.log('Recognition error:', event.error, 'attempts:', restartAttempts);

                if (event.error === 'not-allowed') {
                    showCaptureError('Microphone access denied. Please allow microphone permission.');
                } else if (event.error === 'audio-capture' || event.error === 'network' || event.error === 'aborted') {
                    // BUILD 505: Safari throws audio-capture after ~30s timeout
                    // Don't show error - try to restart instead
                    if (quickCapture.active && restartAttempts < maxRestarts) {
                        restartAttempts++;
                        console.log('ğŸ™ï¸ Safari workaround: restarting recognition (attempt ' + restartAttempts + ')');
                        setTimeout(() => {
                            if (quickCapture.active && quickCapture.recognition) {
                                try {
                                    recognition.start();
                                } catch (e) {
                                    console.log('Restart failed:', e);
                                }
                            }
                        }, 200);
                    } else if (restartAttempts >= maxRestarts) {
                        showCaptureError('Recording stopped. Tap Done to process captured audio.');
                    }
                } else if (event.error === 'no-speech') {
                    // No speech detected - this is ok, just keep listening
                    console.log('No speech detected, continuing...');
                }
            };

            recognition.onend = () => {
                // Restart if still active (Chrome stops after silence, Safari after ~30s)
                if (quickCapture.active && restartAttempts < maxRestarts) {
                    setTimeout(() => {
                        if (quickCapture.active && quickCapture.recognition) {
                            try {
                                recognition.start();
                                console.log('ğŸ™ï¸ Recognition restarted after onend');
                            } catch (e) {
                                console.log('Recognition restart blocked:', e);
                            }
                        }
                    }, 100);
                }
            };

            try {
                recognition.start();
                console.log('ğŸ™ï¸ Quick Capture recording started');
            } catch (e) {
                showCaptureError('Failed to start recording. Please try again.');
            }
        }

        // Update timer display
        function updateTimer() {
            const elapsed = Math.floor((Date.now() - quickCapture.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('qc-timer').textContent = `${minutes}:${seconds}`;
        }

        // Stop recording and process
        function stopCaptureRecording() {
            quickCapture.active = false;

            // Stop recognition
            if (quickCapture.recognition) {
                quickCapture.recognition.stop();
                quickCapture.recognition = null;
            }

            // Stop timer and waveform
            clearInterval(quickCapture.timerInterval);
            clearInterval(quickCapture.waveformInterval);
            if (quickCapture.autoStopTimeout) {
                clearTimeout(quickCapture.autoStopTimeout);
            }

            // Check if we have any transcript
            if (quickCapture.transcript.length === 0) {
                showCaptureError('No speech detected. Please try again and speak clearly.');
                return;
            }

            // Show processing state
            document.getElementById('qc-recording').style.display = 'none';
            document.getElementById('qc-processing').style.display = 'flex';

            // Process transcript
            processConversation();
        }

        // Cancel capture
        function cancelCapture() {
            quickCapture.active = false;

            if (quickCapture.recognition) {
                quickCapture.recognition.stop();
                quickCapture.recognition = null;
            }

            clearInterval(quickCapture.timerInterval);
            clearInterval(quickCapture.waveformInterval);
            if (quickCapture.autoStopTimeout) {
                clearTimeout(quickCapture.autoStopTimeout);
            }

            // Close overlay and clean URL
            document.getElementById('quick-capture-overlay').style.display = 'none';
            window.history.replaceState({}, document.title, window.location.pathname);
        }

        // Process conversation with AI
        async function processConversation() {
            const progressBar = document.getElementById('qc-progress-bar');
            progressBar.style.width = '20%';

            const fullTranscript = quickCapture.transcript.map(t => t.text).join(' ');
            const duration = Math.floor((Date.now() - quickCapture.startTime) / 1000);

            // BUILD 504: Enhanced Quick Capture AI prompt
            const systemPrompt = `You are converting voice notes into a structured tree. The input may be:
- Rambling thoughts or brainstorming
- Meeting notes or planning discussion
- A debate between multiple people
- Project planning with timelines

ANALYZE THE CONTENT TO DETERMINE:
1. PATTERN - Choose the best fit:
   - "capex" if there are dates, timelines, schedules, deadlines, or project phases
   - "dialogue" if there's a debate or multiple speakers with opposing views
   - "generic" for general notes, ideas, or brainstorming

2. THEMES - Group related ideas into 2-5 logical categories

3. KEY POINTS - Extract specific items under each theme (2-6 per theme)

4. DATES - If dates/times mentioned (e.g., "next Tuesday", "November 2027"), include them

5. FIX TRANSCRIPTION ERRORS - Common speech-to-text mistakes:
   - "sunk" might mean "sun"
   - Numbers may be spelled out
   - Proper nouns may be mangled

CRITICAL RULES:
- Every "name" field MUST have real descriptive text (NEVER "undefined" or placeholder)
- "description" should add context, not repeat the name
- Do NOT include hyperedges array
- Clean up obvious speech recognition errors

Output ONLY this JSON structure:
{
  "id": "capture-${Date.now()}",
  "name": "[Compelling 3-8 word title summarizing the content]",
  "type": "session",
  "pattern": "[capex|dialogue|generic - choose best fit]",
  "description": "[1-2 sentence summary of what was captured]",
  "expanded": true,
  "children": [
    {
      "id": "theme-1",
      "name": "[Theme/category name]",
      "type": "phase",
      "expanded": true,
      "items": [
        {
          "id": "point-1",
          "name": "[Specific point - 3-10 words]",
          "type": "item",
          "description": "[Additional context or details]",
          "startDate": "[YYYY-MM-DD if date mentioned, otherwise omit]",
          "endDate": "[YYYY-MM-DD if end date mentioned, otherwise omit]",
          "subItems": []
        }
      ]
    }
  ]
}

Recording duration: ${duration} seconds`;

            const userPrompt = `Analyze this conversation transcript and return ONLY valid JSON (no markdown, no explanation):

TRANSCRIPT:
${fullTranscript}`;

            try {
                progressBar.style.width = '50%';

                // Use existing AI infrastructure
                const response = await callClaudeAPI(systemPrompt, userPrompt);

                progressBar.style.width = '80%';

                // Parse JSON from response
                let tree;
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    tree = JSON.parse(jsonMatch[0]);
                } else {
                    throw new Error('No valid JSON in response');
                }

                // BUILD 504: Clean and validate the tree
                function cleanTree(node, depth = 0) {
                    if (!node) return;

                    // Fix undefined/placeholder names
                    if (!node.name || node.name === 'undefined' || node.name.includes('[') || node.name.includes('REQUIRED')) {
                        node.name = depth === 0 ? 'Voice Capture' :
                                    depth === 1 ? `Topic ${node.id || 'Unknown'}` :
                                    `Point ${node.id || 'Unknown'}`;
                    }

                    // Remove placeholder descriptions
                    if (node.description && (node.description.includes('[') || node.description === node.name)) {
                        delete node.description;
                    }

                    // Remove invalid dates
                    if (node.startDate && (node.startDate.includes('[') || node.startDate === 'undefined')) {
                        delete node.startDate;
                    }
                    if (node.endDate && (node.endDate.includes('[') || node.endDate === 'undefined')) {
                        delete node.endDate;
                    }

                    if (node.children) node.children.forEach(c => cleanTree(c, depth + 1));
                    if (node.items) node.items.forEach(i => cleanTree(i, depth + 1));
                    if (node.subItems) node.subItems.forEach(s => cleanTree(s, depth + 2));
                }
                cleanTree(tree);

                // BUILD 504: Ensure no stale data - clear hyperedges, set fresh properties
                tree.hyperedges = []; // Start with no hyperedges
                tree.canvasX = 700;
                tree.canvasY = 450;
                tree.viewState = { viewMode: 'tree', treeZoom: 1, canvasZoom: 1 };

                // Extract pattern from AI response (default to generic)
                const detectedPattern = tree.pattern || 'generic';
                const validPatterns = ['generic', 'capex', 'dialogue', 'philosophy', 'sales'];
                const finalPattern = validPatterns.includes(detectedPattern) ? detectedPattern : 'generic';
                tree.pattern = finalPattern;

                progressBar.style.width = '100%';

                // Small delay for visual feedback
                await new Promise(resolve => setTimeout(resolve, 300));

                // Load the tree with detected pattern
                window.currentPattern = finalPattern;
                window.capexTree = tree;

                // Update pattern selector UI to match detected pattern
                const patternSelect = document.getElementById('pattern-select');
                if (patternSelect) patternSelect.value = finalPattern;

                // Render the tree
                if (typeof window.render === 'function') {
                    window.render();
                }
                if (typeof window.saveState === 'function') {
                    window.saveState('Quick Capture: Conversation imported');
                }

                console.log('ğŸ™ï¸ Quick Capture tree loaded:', tree);

                // Close overlay and clean URL
                document.getElementById('quick-capture-overlay').style.display = 'none';
                window.history.replaceState({}, document.title, window.location.pathname);

                // Show success toast
                if (typeof showToast === 'function') {
                    showToast('Conversation captured', 'success');
                }

            } catch (error) {
                console.error('Quick Capture processing error:', error);
                showCaptureError('Failed to process conversation. Transcript saved locally.');

                // Save transcript to localStorage as backup
                localStorage.setItem('quickCapture_backup', JSON.stringify({
                    timestamp: Date.now(),
                    transcript: fullTranscript
                }));
            }
        }

        // Show error state
        function showCaptureError(message) {
            document.getElementById('qc-recording').style.display = 'none';
            document.getElementById('qc-processing').style.display = 'none';
            document.getElementById('qc-error').style.display = 'flex';
            document.getElementById('qc-error-message').textContent = message;
        }

        // Reset and retry
        function retryCaptureMode() {
            document.getElementById('qc-error').style.display = 'none';
            document.getElementById('qc-recording').style.display = 'flex';
            quickCapture.transcript = [];
            initWaveform();
            startCaptureRecording();
        }

        // Set up event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Check for capture mode
            checkCaptureMode();

            // Done button
            const doneBtn = document.getElementById('qc-done-btn');
            if (doneBtn) {
                doneBtn.addEventListener('click', stopCaptureRecording);
            }

            // Cancel button
            const cancelBtn = document.getElementById('qc-cancel-btn');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', cancelCapture);
            }

            // Retry button
            const retryBtn = document.getElementById('qc-retry-btn');
            if (retryBtn) {
                retryBtn.addEventListener('click', retryCaptureMode);
            }
        });

        // Expose for external use
        window.enterCaptureMode = enterCaptureMode;
        window.stopCaptureRecording = stopCaptureRecording;

        console.log('Quick Capture module initialized (Build 469)');
    })();
    </script>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         CHAT ASSISTANT MODULE (Build 248)
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script>
    (function() {
        'use strict';

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHAT ASSISTANT STATE
        // BUILD 355: Added conversation memory persistence (last 5 exchanges)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const chatState = {
            isOpen: false,
            isProcessing: false,
            conversationHistory: [],
            voiceRecognition: null,
            isRecording: false,
            // Playground Mode (Build 255)
            playgroundMode: false,
            playgroundSystemPrompt: '',
            playgroundModel: 'claude-sonnet',
            playgroundHistory: [],
            // BUILD 366: LifeTree Biographer Mode
            biographerMode: null, // null, 'guided', 'listening', 'scaffolding', 'artifact'
            // BUILD 368: Conversation Mode - Full AI intelligence
            conversationMode: false, // When true, uses full AI conversation instead of command mode
            lastConversationContext: null, // Stores context for action extraction
            // BUILD 393: New Command Frame UI
            commandFrameMinimized: false,
            // BUILD 543: Preview-Then-Apply pending actions
            pendingDestructiveActions: null,
            // BUILD 543: Pattern Mismatch Routing
            pendingPatternSwitchMessage: null,
            pendingPatternSwitchTarget: null,
            skipPatternMismatchCheck: false
        };

        // BUILD 393: Feature flag for new Command Frame UI
        // Users can toggle via settings - stored in localStorage
        window.useNewChatUI = false; // Classic panel for TreeBeard // Default: true (new UI)

        // BUILD 355: Load conversation memory from localStorage
        (function loadConversationMemory() {
            try {
                const saved = localStorage.getItem('treebeardConversation');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Only keep last 5 exchanges (10 messages: 5 user + 5 assistant)
                    chatState.conversationHistory = parsed.slice(-10);
                    console.log(`ğŸŒ³ TreeBeard memory loaded: ${chatState.conversationHistory.length} messages`);
                }
            } catch (e) {
                console.warn('Could not load TreeBeard conversation memory:', e);
            }
        })();

        // BUILD 355: Save conversation memory to localStorage
        function saveConversationMemory() {
            try {
                // Keep only last 10 messages (5 exchanges)
                const toSave = chatState.conversationHistory.slice(-10);
                localStorage.setItem('treebeardConversation', JSON.stringify(toSave));
            } catch (e) {
                console.warn('Could not save TreeBeard conversation memory:', e);
            }
        }

        // BUILD 355: Restore conversation UI from memory
        function restoreConversationUI() {
            if (chatState.conversationHistory.length === 0) return;

            const messagesContainer = document.getElementById('chat-assistant-messages');
            if (!messagesContainer) return;

            // Clear the default welcome message
            messagesContainer.innerHTML = '';

            // Show a context indicator
            const contextDiv = document.createElement('div');
            contextDiv.className = 'chat-message assistant';
            contextDiv.style.opacity = '0.7';
            contextDiv.style.fontSize = '12px';
            contextDiv.innerHTML = `<em>ğŸ“œ Continuing from last session (${Math.ceil(chatState.conversationHistory.length / 2)} exchanges)</em>`;
            messagesContainer.appendChild(contextDiv);

            // Restore each message
            chatState.conversationHistory.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${msg.role}`;

                // Format content
                let formattedContent = msg.content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\n/g, '<br>');

                messageDiv.innerHTML = formattedContent;
                messagesContainer.appendChild(messageDiv);
            });

            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            console.log('ğŸŒ³ TreeBeard conversation UI restored');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 543: CAPABILITY SYSTEM - Collapse 105 commands to 10 capabilities
        // Maps natural language to canonical commands
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const CAPABILITIES = {
            navigate: {
                canonical: 'find_node',
                description: 'Find and focus on nodes in the tree',
                aliases: ['go to', 'find', 'show me', 'navigate to', 'locate', 'where is', 'jump to', 'select'],
                commands: ['find_node', 'focus_node', 'focus_root', 'parent_node', 'first_child', 'search'],
                examples: ['find marketing', 'go to phase 2', 'show me the budget items']
            },
            edit: {
                canonical: 'add_node',
                description: 'Add, modify, move, or remove nodes',
                aliases: ['add', 'create', 'new', 'insert', 'edit', 'change', 'update', 'modify', 'remove', 'delete', 'move', 'duplicate', 'copy', 'compare'],
                commands: ['add_node', 'add_child', 'add_phase', 'add_research_nodes', 'move_node', 'duplicate_node', 'compare_nodes', 'preview_node', 'delete_node', 'rename_root', 'rename_node', 'set_field'],
                examples: ['add_node Marketing Campaign | Campaign for Q1 launch', 'move_node Bergson to French Critics', 'duplicate_node Phase 1', 'compare_nodes Section A and Section B']
            },
            view: {
                canonical: 'toggle_view',
                description: 'Change how the tree is displayed',
                aliases: ['switch to', 'show', 'view', 'display', 'open'],
                commands: ['switch_to_canvas', 'switch_to_tree', 'switch_to_3d', 'view_gantt', 'view_calendar', 'toggle_view'],
                examples: ['switch to canvas', 'show gantt chart', 'view calendar']
            },
            transform: {
                canonical: 'enhance_selected',
                description: 'AI-powered expansion and improvement',
                aliases: ['enhance', 'improve', 'expand', 'break down', 'elaborate', 'deep dive', 'research'],
                commands: ['enhance_selected', 'deep_dive', 'research', 'open_wizard', 'decompose'],
                examples: ['enhance this node', 'break down into subtasks', 'research this topic']
            },
            plan: {
                canonical: 'gantt_summary',
                description: 'Schedule and project management',
                aliases: ['schedule', 'timeline', 'project', 'gantt', 'critical path', 'deadline'],
                commands: ['gantt_summary', 'gantt_critical_path', 'gantt_today', 'gantt_overdue', 'gantt_next_week'],
                examples: ['show critical path', 'what\'s overdue', 'project summary']
            },
            sync: {
                canonical: 'sync_all',
                description: 'Fetch data from external sources',
                aliases: ['sync', 'fetch', 'pull', 'refresh', 'import', 'load'],
                commands: ['sync_gmail', 'sync_drive', 'sync_calendar', 'refresh_drive', 'refresh_gmail'],
                examples: ['sync gmail', 'refresh drive', 'pull calendar']
            },
            analyze: {
                canonical: 'tree_analysis',
                description: 'Examine and compare tree content',
                aliases: ['analyze', 'compare', 'evaluate', 'summarize', 'statistics', 'report'],
                commands: ['tree_analysis', 'compare_nodes', 'project_info', 'find_redundancies', 'find_hyperedges'],
                examples: ['analyze tree', 'find duplicates', 'project statistics']
            },
            organize: {
                canonical: 'expand_node',
                description: 'Structure and arrange nodes',
                aliases: ['expand', 'collapse', 'sort', 'reorder', 'move', 'organize'],
                commands: ['expand_node', 'collapse_node', 'expand_all', 'collapse_all', 'sort_children'],
                examples: ['expand all', 'collapse this', 'sort by name']
            },
            undo: {
                canonical: 'undo',
                description: 'Undo and redo changes',
                aliases: ['undo', 'redo', 'revert', 'go back', 'restore'],
                commands: ['undo', 'redo'],
                examples: ['undo', 'redo last action']
            },
            help: {
                canonical: 'help',
                description: 'Get help and information',
                aliases: ['help', 'what can you', 'how do I', 'show commands', 'list'],
                commands: ['help', 'list_all_commands', 'project_info', 'node_info'],
                examples: ['help', 'what can you do', 'list commands']
            }
        };

        /**
         * Route natural language to a capability
         * Returns { capability: string, canonical: string, confidence: number } or null
         */
        function routeToCapability(message) {
            const msg = message.toLowerCase();

            for (const [capName, cap] of Object.entries(CAPABILITIES)) {
                // Check aliases
                for (const alias of cap.aliases) {
                    if (msg.includes(alias)) {
                        return {
                            capability: capName,
                            canonical: cap.canonical,
                            description: cap.description,
                            confidence: 0.8
                        };
                    }
                }

                // Check command names directly
                for (const cmd of cap.commands) {
                    if (msg.includes(cmd.replace(/_/g, ' '))) {
                        return {
                            capability: capName,
                            canonical: cmd,
                            description: cap.description,
                            confidence: 1.0
                        };
                    }
                }
            }

            return null;
        }

        /**
         * Get suggested commands for a capability
         */
        function getCapabilityCommands(capabilityName) {
            const cap = CAPABILITIES[capabilityName];
            if (!cap) return [];
            return cap.commands;
        }

        /**
         * Get all capabilities summary for help display
         */
        function getCapabilitiesSummary() {
            return Object.entries(CAPABILITIES).map(([name, cap]) => ({
                name,
                description: cap.description,
                example: cap.examples[0],
                canonical: cap.canonical
            }));
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 574: Tree Outline Helper for Deep Research
        // Creates a brief summary of tree structure for context
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function getTreeOutlineForResearch(tree, maxDepth = 2) {
            if (!tree) return 'Empty tree';

            const lines = [];
            const seen = new Set();

            function traverse(node, depth, prefix = '') {
                if (!node || depth > maxDepth || seen.has(node.id)) return;
                seen.add(node.id);

                const name = node.name || 'Unnamed';
                const type = node.type || 'node';
                const childCount = (node.children?.length || 0) +
                                   (node.items?.length || 0) +
                                   (node.subtasks?.length || 0) +
                                   (node.subItems?.length || 0);

                const childInfo = childCount > 0 ? ` (${childCount} children)` : '';
                lines.push(`${prefix}â€¢ ${name} [${type}]${childInfo}`);

                if (depth < maxDepth) {
                    const children = [
                        ...(node.children || []),
                        ...(node.items || []),
                        ...(node.subtasks || []),
                        ...(node.subItems || [])
                    ];
                    children.forEach(child => traverse(child, depth + 1, prefix + '  '));
                }
            }

            traverse(tree, 0);

            // Limit to reasonable size for context
            if (lines.length > 50) {
                return lines.slice(0, 50).join('\n') + `\n... (${lines.length - 50} more nodes)`;
            }
            return lines.join('\n');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMMAND REGISTRY - Maps intents to TreeListy functions
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const COMMAND_REGISTRY = {
            // View commands
            'switch_to_canvas': () => {
                const container = document.getElementById('canvas-container');
                if (container && !container.classList.contains('active')) {
                    document.getElementById('toggle-view-mode')?.click();
                }
                return 'ğŸ¨ Switched to Canvas view!';
            },
            'switch_to_tree': () => {
                const container = document.getElementById('canvas-container');
                if (container && container.classList.contains('active')) {
                    document.getElementById('toggle-view-mode')?.click();
                }
                return 'ğŸŒ³ Switched to Tree view!';
            },
            'toggle_view': () => {
                document.getElementById('toggle-view-mode')?.click();
                return 'ğŸ”„ View toggled!';
            },

            // BUILD 545: Refresh tree command
            'refresh_tree': () => {
                render();
                return 'ğŸ”„ Tree refreshed!';
            },
            'refresh_view': () => {
                render();
                return 'ğŸ”„ View refreshed!';
            },
            'refresh_root': () => {
                render();
                return 'ğŸ”„ Root view refreshed!';
            },

            // BUILD 543: Preview-Then-Apply confirmation commands
            'confirm_destructive_action': async () => {
                await executePendingDestructiveActions();
                return null; // Message handled by function
            },
            'cancel_destructive_action': () => {
                cancelPendingDestructiveActions();
                return null; // Message handled by function
            },

            // BUILD 543: Pattern Mismatch Routing commands
            'switch_pattern_and_retry': async (targetPattern) => {
                if (!targetPattern || !PATTERNS[targetPattern]) {
                    return `âŒ Unknown pattern: ${targetPattern}`;
                }

                // Switch pattern
                currentPattern = targetPattern;
                localStorage.setItem('currentPattern', targetPattern);
                updatePatternUI();

                const patternName = PATTERNS[targetPattern]?.name || targetPattern;
                addMessage(`âœ… Switched to **${patternName}** pattern.`, 'system');

                // Re-process the pending message
                if (chatState.pendingPatternSwitchMessage) {
                    const pendingMessage = chatState.pendingPatternSwitchMessage;
                    chatState.pendingPatternSwitchMessage = null;
                    chatState.pendingPatternSwitchTarget = null;

                    // Simulate re-sending the message
                    setTimeout(() => {
                        const input = document.getElementById('chat-assistant-input');
                        if (input) {
                            input.value = pendingMessage;
                            handleSendMessage();
                        }
                    }, 500);
                }
                return null;
            },
            'continue_without_switch': async () => {
                // Process the pending message without switching patterns
                if (chatState.pendingPatternSwitchMessage) {
                    const pendingMessage = chatState.pendingPatternSwitchMessage;
                    chatState.pendingPatternSwitchMessage = null;
                    chatState.pendingPatternSwitchTarget = null;
                    chatState.skipPatternMismatchCheck = true; // Flag to skip re-check

                    // Re-process
                    setTimeout(() => {
                        const input = document.getElementById('chat-assistant-input');
                        if (input) {
                            input.value = pendingMessage;
                            handleSendMessage();
                        }
                    }, 300);
                }
                return null;
            },

            'switch_to_3d': () => {
                if (typeof toggle3DView === 'function') {
                    const view3d = document.getElementById('view-3d');
                    if (!view3d?.classList.contains('active')) {
                        toggle3DView();
                    }
                    return 'ğŸŒ Switched to 3D view!';
                }
                return 'âŒ 3D view not available.';
            },
            'view_calendar': () => {
                if (typeof toggleCalendarView === 'function') {
                    const viewCalendar = document.getElementById('view-calendar');
                    if (!viewCalendar?.classList.contains('active')) {
                        toggleCalendarView();
                    }
                    return 'ğŸ“… Switched to Calendar view!';
                }
                return 'âŒ Calendar view not available.';
            },

            // BUILD 485: Gantt View Commands
            'view_gantt': () => {
                if (typeof toggleGanttView === 'function') {
                    const viewGantt = document.getElementById('view-gantt');
                    if (!viewGantt?.classList.contains('active')) {
                        toggleGanttView();
                    }
                    const taskCount = typeof getAllTasksWithDates === 'function' ? getAllTasksWithDates().length : '?';
                    return `ğŸ“Š Switched to Gantt view! ${taskCount} tasks with schedule data.`;
                }
                return 'âŒ Gantt view not available.';
            },
            'gantt_view_mode': (mode) => {
                const validModes = ['day', 'week', 'month', 'year'];
                const m = (mode || '').toLowerCase();
                if (!validModes.includes(m)) {
                    return `âš ï¸ Valid modes: ${validModes.join(', ')}. Example: "switch to week view"`;
                }
                if (typeof ganttInstance !== 'undefined' && ganttInstance) {
                    const modeMap = { day: 'Day', week: 'Week', month: 'Month', year: 'Year' };
                    ganttInstance.change_view_mode(modeMap[m]);
                    if (typeof ganttViewMode !== 'undefined') ganttViewMode = modeMap[m];
                    const select = document.getElementById('gantt-view-mode');
                    if (select) select.value = modeMap[m];
                    return `ğŸ“Š Gantt view: ${modeMap[m]} mode`;
                }
                return 'âš ï¸ Open Gantt view first.';
            },
            'gantt_zoom_in': () => {
                const btn = document.getElementById('gantt-zoom-in');
                if (btn) { btn.click(); return 'ğŸ” Zoomed in'; }
                return 'âš ï¸ Open Gantt view first.';
            },
            'gantt_zoom_out': () => {
                const btn = document.getElementById('gantt-zoom-out');
                if (btn) { btn.click(); return 'ğŸ” Zoomed out'; }
                return 'âš ï¸ Open Gantt view first.';
            },
            'gantt_fit_all': () => {
                const btn = document.getElementById('gantt-fit-btn');
                if (btn) { btn.click(); return 'ğŸ“Š Fit all tasks to view'; }
                return 'âš ï¸ Open Gantt view first.';
            },
            'gantt_today': () => {
                const btn = document.getElementById('gantt-today-btn');
                if (btn) { btn.click(); return 'ğŸ“ Scrolled to today'; }
                return 'âš ï¸ Open Gantt view first.';
            },
            'gantt_toggle_critical_path': () => {
                const btn = document.getElementById('gantt-critical-path-btn');
                if (btn) {
                    btn.click();
                    const isOn = typeof ganttShowCriticalPath !== 'undefined' && ganttShowCriticalPath;
                    return isOn ? 'ğŸ”´ Critical path highlighted. These tasks have 0 slack - any delay extends the project.' : 'âšª Critical path hidden';
                }
                return 'âš ï¸ Open Gantt view first.';
            },
            'gantt_toggle_readonly': () => {
                const checkbox = document.getElementById('gantt-readonly');
                if (checkbox) {
                    checkbox.click();
                    return checkbox.checked ? 'ğŸ”’ Read-only mode enabled' : 'âœï¸ Edit mode enabled';
                }
                return 'âš ï¸ Open Gantt view first.';
            },

            // BUILD 485: Gantt Navigation Commands
            'gantt_select': (taskName) => {
                if (!taskName) return 'âš ï¸ Specify a task name. Example: "select Design Phase"';
                const wrapper = document.getElementById('gantt-chart-wrapper');
                if (!wrapper) return 'âš ï¸ Open Gantt view first.';

                const bars = wrapper.querySelectorAll('.bar-wrapper');
                let found = null;
                const searchLower = taskName.toLowerCase();

                bars.forEach(bar => {
                    const id = bar.getAttribute('data-id');
                    if (id && typeof getNodeById === 'function') {
                        const node = getNodeById(id);
                        const name = (node?.name || node?.title || '').toLowerCase();
                        if (name.includes(searchLower)) found = { bar, node, id };
                    }
                });

                if (found) {
                    // Trigger click to open info panel
                    if (typeof showGanttInfoPanel === 'function') {
                        showGanttInfoPanel({ id: found.id, ...found.node });
                    }
                    // Scroll into view
                    found.bar.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    return `ğŸ“Š Selected "${found.node.name || found.node.title}"`;
                }
                return `âŒ Task "${taskName}" not found in Gantt chart.`;
            },
            'gantt_next_critical': () => {
                const btn = document.querySelector('#gantt-toolbar button[id*="next-critical"], #gantt-toolbar button:contains("â†’")');
                // Try clicking the next critical button if it exists
                const nextBtn = Array.from(document.querySelectorAll('#gantt-toolbar button')).find(b => b.textContent.includes('â†’'));
                if (nextBtn) { nextBtn.click(); return 'â†’ Next critical path task'; }
                return 'âš ï¸ Enable Critical Path first to navigate critical tasks.';
            },
            'gantt_focus_overdue': () => {
                if (typeof getNodeById !== 'function') return 'âš ï¸ Open Gantt view first.';
                const wrapper = document.getElementById('gantt-chart-wrapper');
                if (!wrapper) return 'âš ï¸ Open Gantt view first.';

                const today = new Date();
                today.setHours(0, 0, 0, 0);
                let overdueTask = null;

                wrapper.querySelectorAll('.bar-wrapper').forEach(bar => {
                    if (overdueTask) return;
                    const id = bar.getAttribute('data-id');
                    const node = getNodeById(id);
                    if (node && node.pmDueDate) {
                        const due = new Date(node.pmDueDate);
                        const status = node.pmStatus || '';
                        if (due < today && status !== 'Done' && status !== 'Completed') {
                            overdueTask = { bar, node, id };
                        }
                    }
                });

                if (overdueTask) {
                    if (typeof showGanttInfoPanel === 'function') {
                        showGanttInfoPanel({ id: overdueTask.id, ...overdueTask.node });
                    }
                    overdueTask.bar.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    const daysLate = Math.floor((today - new Date(overdueTask.node.pmDueDate)) / (1000 * 60 * 60 * 24));
                    return `âš ï¸ "${overdueTask.node.name || overdueTask.node.title}" is ${daysLate} days overdue`;
                }
                return 'âœ… No overdue tasks found!';
            },

            // BUILD 486: Gantt Analysis Commands
            'gantt_summary': () => {
                const tasks = typeof getAllTasksWithDates === 'function' ? getAllTasksWithDates() : [];
                if (tasks.length === 0) {
                    return 'ğŸ“Š No scheduled tasks found. Import an MS Project file or add dates to your tasks.';
                }

                // Count by status
                const byStatus = { done: 0, inProgress: 0, notStarted: 0, blocked: 0 };
                tasks.forEach(t => {
                    const s = (t.pmStatus || '').toLowerCase();
                    if (s === 'done' || s === 'completed') byStatus.done++;
                    else if (s === 'in progress') byStatus.inProgress++;
                    else if (s === 'blocked') byStatus.blocked++;
                    else byStatus.notStarted++;
                });

                // Overdue count
                const overdue = tasks.filter(t => t.isOverdue);

                // Get critical path info
                let criticalInfo = '';
                if (typeof dependencyEngine !== 'undefined' && typeof dependencyEngine.calculateCriticalPath === 'function') {
                    try {
                        const cp = dependencyEngine.calculateCriticalPath(capexTree);
                        if (cp && cp.criticalNodes && cp.criticalNodes.length > 0) {
                            criticalInfo = `\nğŸ”´ **Critical path:** ${cp.criticalNodes.length} tasks, ${cp.duration || '?'} days`;
                        }
                    } catch (e) { /* ignore */ }
                }

                // Calculate overall health
                let health = 'ğŸŸ¢ Healthy';
                if (overdue.length > 0) health = 'ğŸŸ¡ At Risk';
                if (overdue.some(t => t.isCritical)) health = 'ğŸ”´ Critical Issues';

                return `ğŸ“Š **Schedule Summary** ${health}

**Tasks:** ${tasks.length} total
â€¢ âœ… Done: ${byStatus.done}
â€¢ ğŸ”„ In Progress: ${byStatus.inProgress}
â€¢ â³ Not Started: ${byStatus.notStarted}
${byStatus.blocked > 0 ? `â€¢ ğŸš« Blocked: ${byStatus.blocked}\n` : ''}
**Issues:** ${overdue.length > 0 ? `âš ï¸ ${overdue.length} overdue` : 'âœ… None overdue'}${criticalInfo}`;
            },

            'gantt_critical_path': () => {
                if (typeof dependencyEngine === 'undefined' || typeof dependencyEngine.calculateCriticalPath !== 'function') {
                    return 'âš ï¸ Critical path analysis requires tasks with dependencies.';
                }

                try {
                    const cp = dependencyEngine.calculateCriticalPath(capexTree);
                    if (!cp || !cp.criticalNodes || cp.criticalNodes.length === 0) {
                        return 'ğŸ“Š No critical path found. Add dependencies between tasks to see the critical path.\n\nğŸ’¡ **What is critical path?** The longest chain of dependent tasks - any delay here delays the whole project.';
                    }

                    const pathNames = cp.criticalNodes.map(n => n.name || n.title || 'Untitled');
                    const longestTask = cp.criticalNodes.reduce((max, n) =>
                        (n.pmDuration || 1) > (max.pmDuration || 1) ? n : max, cp.criticalNodes[0]);

                    return `ğŸ”´ **Critical Path Analysis**

**Duration:** ${cp.duration || '?'} days total
**Tasks:** ${cp.criticalNodes.length} tasks with 0 slack

**Path:** ${pathNames.join(' â†’ ')}

**Longest task:** "${longestTask.name || longestTask.title}" (${longestTask.pmDuration || 1} days)

ğŸ’¡ These tasks have **zero slack** - any delay extends your project end date.`;
                } catch (e) {
                    return `âš ï¸ Error calculating critical path: ${e.message}`;
                }
            },

            'gantt_overdue': () => {
                const tasks = typeof getAllTasksWithDates === 'function' ? getAllTasksWithDates() : [];
                const overdue = tasks.filter(t => t.isOverdue).sort((a, b) => b.daysOverdue - a.daysOverdue);

                if (overdue.length === 0) {
                    return 'âœ… **No overdue tasks!** All tasks are on schedule.';
                }

                let response = `âš ï¸ **${overdue.length} Overdue Task${overdue.length > 1 ? 's' : ''}**\n\n`;

                overdue.forEach((t, i) => {
                    const critical = t.isCritical ? ' ğŸ”´' : '';
                    response += `${i + 1}. **${t.name}** - ${t.daysOverdue} day${t.daysOverdue > 1 ? 's' : ''} late${critical}\n`;
                    response += `   Due: ${t.pmDueDate} | Progress: ${t.pmProgress}%\n`;
                });

                if (overdue.some(t => t.isCritical)) {
                    response += '\nğŸ”´ Tasks marked with ğŸ”´ are on the critical path - prioritize these!';
                }

                return response;
            },

            'gantt_blockers': () => {
                const tasks = typeof getAllTasksWithDates === 'function' ? getAllTasksWithDates() : [];
                if (tasks.length === 0) {
                    return 'ğŸ“Š No scheduled tasks found.';
                }

                // Count how many tasks depend on each task
                const dependencyCount = {};
                tasks.forEach(t => {
                    (t.dependencies || []).forEach(dep => {
                        const predId = typeof dep === 'string' ? dep : dep.predecessorId;
                        if (predId) {
                            dependencyCount[predId] = (dependencyCount[predId] || 0) + 1;
                        }
                    });
                });

                // Find tasks with most dependents
                const blockers = tasks
                    .map(t => ({ ...t, dependentCount: dependencyCount[t.id] || 0 }))
                    .filter(t => t.dependentCount > 0)
                    .sort((a, b) => b.dependentCount - a.dependentCount)
                    .slice(0, 5);

                if (blockers.length === 0) {
                    return 'ğŸ“Š No blocking dependencies found. Tasks appear to be independent.';
                }

                let response = `ğŸ”— **Top Blocking Tasks**\n\nThese tasks block the most downstream work:\n\n`;

                blockers.forEach((t, i) => {
                    const status = t.pmStatus === 'Done' ? 'âœ…' : (t.isOverdue ? 'âš ï¸' : 'ğŸ”„');
                    response += `${i + 1}. ${status} **${t.name}** - blocks ${t.dependentCount} task${t.dependentCount > 1 ? 's' : ''}\n`;
                    response += `   Status: ${t.pmStatus} | Progress: ${t.pmProgress}%\n`;
                });

                response += '\nğŸ’¡ Completing these tasks will unblock the most downstream work.';
                return response;
            },

            'gantt_slack': (taskName) => {
                if (typeof dependencyEngine === 'undefined' || typeof dependencyEngine.calculateCriticalPath !== 'function') {
                    return 'âš ï¸ Slack analysis requires tasks with dependencies.';
                }

                try {
                    // Calculate critical path to get slack values
                    dependencyEngine.calculateCriticalPath(capexTree);
                } catch (e) { /* ignore */ }

                const tasks = typeof getAllTasksWithDates === 'function' ? getAllTasksWithDates() : [];
                if (tasks.length === 0) {
                    return 'ğŸ“Š No scheduled tasks found.';
                }

                // If task name provided, find that specific task
                if (taskName) {
                    const searchLower = taskName.toLowerCase();
                    const task = tasks.find(t => t.name.toLowerCase().includes(searchLower));
                    if (!task) {
                        return `âŒ Task "${taskName}" not found.`;
                    }

                    const slackDays = task.slack !== null ? task.slack : 'Unknown';
                    const slackStatus = task.slack === 0 ? 'ğŸ”´ Critical (0 days)' :
                                       task.slack !== null && task.slack <= 5 ? `ğŸŸ¡ Low (${slackDays} days)` :
                                       task.slack !== null ? `ğŸŸ¢ Flexible (${slackDays} days)` : 'â“ Not calculated';

                    return `ğŸ“Š **Slack Analysis: ${task.name}**

**Slack:** ${slackStatus}
**Status:** ${task.pmStatus} | **Progress:** ${task.pmProgress}%
**Duration:** ${task.pmDuration} days

ğŸ’¡ **Slack** = how many days this task can slip without affecting the project end date.`;
                }

                // Show overall slack distribution
                const criticalTasks = tasks.filter(t => t.slack === 0);
                const lowSlack = tasks.filter(t => t.slack !== null && t.slack > 0 && t.slack <= 5);
                const hasSlackData = tasks.some(t => t.slack !== null);

                if (!hasSlackData) {
                    return `ğŸ“Š **Slack Analysis**

Slack data not available. To calculate slack:
1. Ensure tasks have dependencies defined
2. Toggle Critical Path in Gantt view

ğŸ’¡ **Slack** (or float) = how many days a task can slip without delaying the project.`;
                }

                return `ğŸ“Š **Slack Distribution**

ğŸ”´ **Critical (0 days):** ${criticalTasks.length} tasks
   ${criticalTasks.slice(0, 3).map(t => t.name).join(', ')}${criticalTasks.length > 3 ? '...' : ''}

ğŸŸ¡ **Low slack (1-5 days):** ${lowSlack.length} tasks
   ${lowSlack.slice(0, 3).map(t => `${t.name} (${t.slack}d)`).join(', ')}${lowSlack.length > 3 ? '...' : ''}

ğŸ’¡ Focus on critical (0 slack) tasks first - any delay extends your project.`;
            },

            'gantt_dependencies': (taskName) => {
                if (!taskName) {
                    return 'âš ï¸ Specify a task name. Example: "show dependencies for Design Phase"';
                }

                const tasks = typeof getAllTasksWithDates === 'function' ? getAllTasksWithDates() : [];
                const searchLower = taskName.toLowerCase();
                const task = tasks.find(t => t.name.toLowerCase().includes(searchLower));

                if (!task) {
                    return `âŒ Task "${taskName}" not found.`;
                }

                // Find predecessors (what this task depends on)
                const predecessors = (task.dependencies || []).map(dep => {
                    const predId = typeof dep === 'string' ? dep : dep.predecessorId;
                    const predTask = tasks.find(t => t.id === predId);
                    const type = typeof dep === 'object' ? dep.type : 'FS';
                    const lag = typeof dep === 'object' ? (dep.lag || 0) : 0;
                    return {
                        name: predTask?.name || predId,
                        type,
                        lag,
                        status: predTask?.pmStatus || 'Unknown'
                    };
                });

                // Find successors (what depends on this task)
                const successors = tasks.filter(t => {
                    return (t.dependencies || []).some(dep => {
                        const predId = typeof dep === 'string' ? dep : dep.predecessorId;
                        return predId === task.id;
                    });
                }).map(t => {
                    const dep = t.dependencies.find(d =>
                        (typeof d === 'string' ? d : d.predecessorId) === task.id);
                    return {
                        name: t.name,
                        type: typeof dep === 'object' ? dep.type : 'FS',
                        status: t.pmStatus
                    };
                });

                let response = `ğŸ”— **Dependencies: ${task.name}**\n\n`;

                if (predecessors.length > 0) {
                    response += `**Depends on (${predecessors.length}):**\n`;
                    predecessors.forEach(p => {
                        const lagStr = p.lag ? ` +${p.lag}d` : '';
                        const statusIcon = p.status === 'Done' ? 'âœ…' : 'ğŸ”„';
                        response += `â€¢ ${statusIcon} ${p.name} (${p.type}${lagStr})\n`;
                    });
                } else {
                    response += '**Depends on:** None (can start anytime)\n';
                }

                response += '\n';

                if (successors.length > 0) {
                    response += `**Blocks (${successors.length}):**\n`;
                    successors.forEach(s => {
                        const statusIcon = s.status === 'Done' ? 'âœ…' : 'ğŸ”„';
                        response += `â€¢ ${statusIcon} ${s.name} (${s.type})\n`;
                    });
                } else {
                    response += '**Blocks:** Nothing (end task)\n';
                }

                // Add dependency type legend
                response += `\nğŸ’¡ **Types:** FS=Finish-to-Start, SS=Start-to-Start, FF=Finish-to-Finish, SF=Start-to-Finish`;

                return response;
            },

            // BUILD 487: Gantt Edit Commands
            // Helper to find task and check readonly
            '_gantt_find_task': (taskName) => {
                if (typeof ganttReadOnly !== 'undefined' && ganttReadOnly) {
                    return { error: 'ğŸ”’ Gantt is in read-only mode. Uncheck "Read Only" in the toolbar to edit.' };
                }
                if (!taskName) {
                    return { error: 'âš ï¸ Please specify a task name.' };
                }
                const tasks = typeof getAllTasksWithDates === 'function' ? getAllTasksWithDates() : [];
                const searchLower = taskName.toLowerCase();
                const task = tasks.find(t => t.name.toLowerCase().includes(searchLower));
                if (!task) {
                    return { error: `âŒ Task "${taskName}" not found.` };
                }
                return { task, node: task._node };
            },

            'gantt_set_dates': (args) => {
                // Parse: "task name, start, end" or "task name start end"
                if (!args) return 'âš ï¸ Usage: gantt_set_dates:{task name}, {start date}, {end date}\nExample: "set Design Phase dates to 2025-01-15, 2025-01-30"';

                const parts = args.split(/[,\s]+/).filter(Boolean);
                if (parts.length < 3) return 'âš ï¸ Please provide task name, start date, and end date.';

                // Last two parts are dates, rest is task name
                const endDate = parts.pop();
                const startDate = parts.pop();
                const taskName = parts.join(' ');

                const result = COMMAND_REGISTRY['_gantt_find_task'](taskName);
                if (result.error) return result.error;

                // Validate dates
                const startParsed = new Date(startDate);
                const endParsed = new Date(endDate);
                if (isNaN(startParsed.getTime())) return `âš ï¸ Invalid start date: "${startDate}". Use YYYY-MM-DD format.`;
                if (isNaN(endParsed.getTime())) return `âš ï¸ Invalid end date: "${endDate}". Use YYYY-MM-DD format.`;
                if (endParsed < startParsed) return 'âš ï¸ End date cannot be before start date.';

                const oldStart = result.node.pmStartDate;
                const oldEnd = result.node.pmDueDate;

                result.node.pmStartDate = startDate;
                result.node.pmDueDate = endDate;
                result.node.pmDuration = Math.ceil((endParsed - startParsed) / (1000 * 60 * 60 * 24));

                if (typeof saveState === 'function') saveState('Treebeard: Updated dates');
                if (typeof renderGantt === 'function' && typeof ganttInstance !== 'undefined') renderGantt();

                return `âœ… Updated **${result.task.name}** dates:\nâ€¢ Start: ${oldStart || 'none'} â†’ ${startDate}\nâ€¢ End: ${oldEnd || 'none'} â†’ ${endDate}\nâ€¢ Duration: ${result.node.pmDuration} days`;
            },

            'gantt_set_start': (args) => {
                if (!args) return 'âš ï¸ Usage: gantt_set_start:{task name}, {date}\nExample: "set Design Phase start to 2025-01-15"';

                const parts = args.split(/[,\s]+/).filter(Boolean);
                if (parts.length < 2) return 'âš ï¸ Please provide task name and start date.';

                const startDate = parts.pop();
                const taskName = parts.join(' ');

                const result = COMMAND_REGISTRY['_gantt_find_task'](taskName);
                if (result.error) return result.error;

                const startParsed = new Date(startDate);
                if (isNaN(startParsed.getTime())) return `âš ï¸ Invalid date: "${startDate}". Use YYYY-MM-DD format.`;

                const oldStart = result.node.pmStartDate;
                result.node.pmStartDate = startDate;

                // Recalculate duration if end date exists
                if (result.node.pmDueDate) {
                    const endParsed = new Date(result.node.pmDueDate);
                    result.node.pmDuration = Math.ceil((endParsed - startParsed) / (1000 * 60 * 60 * 24));
                }

                if (typeof saveState === 'function') saveState('Treebeard: Updated start date');
                if (typeof renderGantt === 'function' && typeof ganttInstance !== 'undefined') renderGantt();

                return `âœ… Updated **${result.task.name}** start date: ${oldStart || 'none'} â†’ ${startDate}`;
            },

            'gantt_set_end': (args) => {
                if (!args) return 'âš ï¸ Usage: gantt_set_end:{task name}, {date}\nExample: "set Design Phase end to 2025-01-30"';

                const parts = args.split(/[,\s]+/).filter(Boolean);
                if (parts.length < 2) return 'âš ï¸ Please provide task name and end date.';

                const endDate = parts.pop();
                const taskName = parts.join(' ');

                const result = COMMAND_REGISTRY['_gantt_find_task'](taskName);
                if (result.error) return result.error;

                const endParsed = new Date(endDate);
                if (isNaN(endParsed.getTime())) return `âš ï¸ Invalid date: "${endDate}". Use YYYY-MM-DD format.`;

                const oldEnd = result.node.pmDueDate;
                result.node.pmDueDate = endDate;

                // Recalculate duration if start date exists
                if (result.node.pmStartDate) {
                    const startParsed = new Date(result.node.pmStartDate);
                    result.node.pmDuration = Math.ceil((endParsed - startParsed) / (1000 * 60 * 60 * 24));
                }

                if (typeof saveState === 'function') saveState('Treebeard: Updated end date');
                if (typeof renderGantt === 'function' && typeof ganttInstance !== 'undefined') renderGantt();

                return `âœ… Updated **${result.task.name}** end date: ${oldEnd || 'none'} â†’ ${endDate}`;
            },

            'gantt_set_duration': (args) => {
                if (!args) return 'âš ï¸ Usage: gantt_set_duration:{task name}, {days}\nExample: "set Design Phase duration to 14 days"';

                const parts = args.split(/[,\s]+/).filter(Boolean);
                if (parts.length < 2) return 'âš ï¸ Please provide task name and duration in days.';

                // Find the number (duration)
                let duration = null;
                let taskParts = [];
                for (const part of parts) {
                    const num = parseInt(part);
                    if (!isNaN(num) && duration === null) {
                        duration = num;
                    } else if (part.toLowerCase() !== 'days' && part.toLowerCase() !== 'day') {
                        taskParts.push(part);
                    }
                }

                if (duration === null || duration < 1) return 'âš ï¸ Please provide a valid duration (positive number of days).';
                const taskName = taskParts.join(' ');

                const result = COMMAND_REGISTRY['_gantt_find_task'](taskName);
                if (result.error) return result.error;

                const oldDuration = result.node.pmDuration;
                result.node.pmDuration = duration;

                // Adjust end date if start date exists
                if (result.node.pmStartDate) {
                    const startParsed = new Date(result.node.pmStartDate);
                    startParsed.setDate(startParsed.getDate() + duration);
                    result.node.pmDueDate = startParsed.toISOString().split('T')[0];
                }

                if (typeof saveState === 'function') saveState('Treebeard: Updated duration');
                if (typeof renderGantt === 'function' && typeof ganttInstance !== 'undefined') renderGantt();

                return `âœ… Updated **${result.task.name}** duration: ${oldDuration || '?'} â†’ ${duration} days${result.node.pmDueDate ? `\nâ€¢ New end date: ${result.node.pmDueDate}` : ''}`;
            },

            'gantt_set_progress': (args) => {
                if (!args) return 'âš ï¸ Usage: gantt_set_progress:{task name}, {0-100}\nExample: "set Design Phase progress to 75%"';

                const parts = args.split(/[,\s]+/).filter(Boolean);
                if (parts.length < 2) return 'âš ï¸ Please provide task name and progress percentage.';

                // Find the number (progress)
                let progress = null;
                let taskParts = [];
                for (const part of parts) {
                    const num = parseInt(part.replace('%', ''));
                    if (!isNaN(num) && progress === null) {
                        progress = Math.max(0, Math.min(100, num));
                    } else if (part !== '%' && part.toLowerCase() !== 'percent') {
                        taskParts.push(part);
                    }
                }

                if (progress === null) return 'âš ï¸ Please provide a valid progress percentage (0-100).';
                const taskName = taskParts.join(' ');

                const result = COMMAND_REGISTRY['_gantt_find_task'](taskName);
                if (result.error) return result.error;

                const oldProgress = result.node.pmProgress || 0;
                result.node.pmProgress = progress;

                // Auto-update status based on progress
                if (progress === 100 && result.node.pmStatus !== 'Done') {
                    result.node.pmStatus = 'Done';
                } else if (progress > 0 && progress < 100 && result.node.pmStatus === 'Not Started') {
                    result.node.pmStatus = 'In Progress';
                }

                if (typeof saveState === 'function') saveState('Treebeard: Updated progress');
                if (typeof renderGantt === 'function' && typeof ganttInstance !== 'undefined') renderGantt();

                return `âœ… Updated **${result.task.name}** progress: ${oldProgress}% â†’ ${progress}%${progress === 100 ? '\nâ€¢ Status automatically set to Done' : ''}`;
            },

            'gantt_set_status': (args) => {
                if (!args) return 'âš ï¸ Usage: gantt_set_status:{task name}, {status}\nValid statuses: Not Started, In Progress, Done, Blocked';

                const validStatuses = ['Not Started', 'In Progress', 'Done', 'Blocked', 'Completed'];
                const statusMap = {
                    'not started': 'Not Started',
                    'notstarted': 'Not Started',
                    'in progress': 'In Progress',
                    'inprogress': 'In Progress',
                    'done': 'Done',
                    'completed': 'Done',
                    'blocked': 'Blocked'
                };

                // Find status in args
                let foundStatus = null;
                let taskName = args;

                for (const [key, value] of Object.entries(statusMap)) {
                    if (args.toLowerCase().includes(key)) {
                        foundStatus = value;
                        taskName = args.toLowerCase().replace(key, '').replace(/[,\s]+/g, ' ').trim();
                        break;
                    }
                }

                if (!foundStatus) return `âš ï¸ Invalid status. Valid options: ${validStatuses.slice(0, 4).join(', ')}`;

                const result = COMMAND_REGISTRY['_gantt_find_task'](taskName);
                if (result.error) return result.error;

                const oldStatus = result.node.pmStatus || 'Not Started';
                result.node.pmStatus = foundStatus;

                // Auto-update progress for Done status
                if (foundStatus === 'Done' && (result.node.pmProgress || 0) < 100) {
                    result.node.pmProgress = 100;
                }

                if (typeof saveState === 'function') saveState('Treebeard: Updated status');
                if (typeof renderGantt === 'function' && typeof ganttInstance !== 'undefined') renderGantt();

                const statusIcons = { 'Not Started': 'â³', 'In Progress': 'ğŸ”„', 'Done': 'âœ…', 'Blocked': 'ğŸš«' };
                return `âœ… Updated **${result.task.name}** status: ${oldStatus} â†’ ${statusIcons[foundStatus] || ''} ${foundStatus}`;
            },

            'gantt_add_dependency': (args) => {
                if (!args) return 'âš ï¸ Usage: gantt_add_dependency:{from task}, {to task}, {type}, {lag}\nTypes: FS (Finish-to-Start), SS, FF, SF\nExample: "add dependency from Design to Development FS"';

                if (typeof ganttReadOnly !== 'undefined' && ganttReadOnly) {
                    return 'ğŸ”’ Gantt is in read-only mode. Uncheck "Read Only" to edit.';
                }

                const tasks = typeof getAllTasksWithDates === 'function' ? getAllTasksWithDates() : [];
                if (tasks.length < 2) return 'âš ï¸ Need at least 2 tasks with dates to create dependencies.';

                // Parse: "from task, to task, FS, 2" or natural language
                const depTypes = ['FS', 'SS', 'FF', 'SF'];
                let type = 'FS';
                let lag = 0;
                let argsLower = args.toLowerCase();

                // Extract type
                for (const t of depTypes) {
                    if (argsLower.includes(t.toLowerCase())) {
                        type = t;
                        argsLower = argsLower.replace(t.toLowerCase(), '');
                        break;
                    }
                }

                // Extract lag (number followed by optional "days")
                const lagMatch = argsLower.match(/(\d+)\s*(days?|d)?/);
                if (lagMatch) {
                    lag = parseInt(lagMatch[1]);
                    argsLower = argsLower.replace(lagMatch[0], '');
                }

                // Split remaining by common separators
                const parts = argsLower.split(/(?:,|\sto\s|\s->\s|\sfrom\s|\sdepends\s*on\s)/i).map(p => p.trim()).filter(Boolean);

                if (parts.length < 2) return 'âš ï¸ Please specify both tasks. Example: "Design to Development FS"';

                const fromName = parts[0];
                const toName = parts[1];

                const fromTask = tasks.find(t => t.name.toLowerCase().includes(fromName));
                const toTask = tasks.find(t => t.name.toLowerCase().includes(toName));

                if (!fromTask) return `âŒ Task "${fromName}" not found.`;
                if (!toTask) return `âŒ Task "${toName}" not found.`;
                if (fromTask.id === toTask.id) return 'âš ï¸ A task cannot depend on itself.';

                // Check if dependency already exists
                const toNode = toTask._node;
                toNode.dependencies = toNode.dependencies || [];
                const existing = toNode.dependencies.find(d =>
                    (typeof d === 'string' ? d : d.predecessorId) === fromTask.id
                );
                if (existing) return `âš ï¸ Dependency already exists: ${fromTask.name} â†’ ${toTask.name}`;

                // Add the dependency
                toNode.dependencies.push({
                    predecessorId: fromTask.id,
                    type: type,
                    lag: lag
                });

                if (typeof saveState === 'function') saveState('Treebeard: Added dependency');
                if (typeof renderGantt === 'function' && typeof ganttInstance !== 'undefined') renderGantt();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `âœ… Created dependency:\n**${fromTask.name}** â†’ **${toTask.name}**\nâ€¢ Type: ${type} (${type === 'FS' ? 'Finish-to-Start' : type === 'SS' ? 'Start-to-Start' : type === 'FF' ? 'Finish-to-Finish' : 'Start-to-Finish'})\n${lag > 0 ? `â€¢ Lag: +${lag} days` : ''}`;
            },

            'gantt_remove_dependency': (args) => {
                if (!args) return 'âš ï¸ Usage: gantt_remove_dependency:{from task}, {to task}\nExample: "remove dependency from Design to Development"';

                if (typeof ganttReadOnly !== 'undefined' && ganttReadOnly) {
                    return 'ğŸ”’ Gantt is in read-only mode. Uncheck "Read Only" to edit.';
                }

                const tasks = typeof getAllTasksWithDates === 'function' ? getAllTasksWithDates() : [];

                // Parse tasks
                const parts = args.split(/(?:,|\sto\s|\s->\s|\sfrom\s)/i).map(p => p.trim()).filter(Boolean);
                if (parts.length < 2) return 'âš ï¸ Please specify both tasks. Example: "Design to Development"';

                const fromName = parts[0];
                const toName = parts[1];

                const fromTask = tasks.find(t => t.name.toLowerCase().includes(fromName.toLowerCase()));
                const toTask = tasks.find(t => t.name.toLowerCase().includes(toName.toLowerCase()));

                if (!fromTask) return `âŒ Task "${fromName}" not found.`;
                if (!toTask) return `âŒ Task "${toName}" not found.`;

                const toNode = toTask._node;
                if (!toNode.dependencies || toNode.dependencies.length === 0) {
                    return `âš ï¸ ${toTask.name} has no dependencies to remove.`;
                }

                const depIndex = toNode.dependencies.findIndex(d =>
                    (typeof d === 'string' ? d : d.predecessorId) === fromTask.id
                );

                if (depIndex === -1) {
                    return `âš ï¸ No dependency found from ${fromTask.name} to ${toTask.name}.`;
                }

                toNode.dependencies.splice(depIndex, 1);

                if (typeof saveState === 'function') saveState('Treebeard: Removed dependency');
                if (typeof renderGantt === 'function' && typeof ganttInstance !== 'undefined') renderGantt();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `âœ… Removed dependency: **${fromTask.name}** â†’ **${toTask.name}**`;
            },

            'gantt_mark_done': (taskName) => {
                if (!taskName) return 'âš ï¸ Usage: gantt_mark_done:{task name}\nExample: "mark Design Phase as done"';

                const result = COMMAND_REGISTRY['_gantt_find_task'](taskName);
                if (result.error) return result.error;

                const wasStatus = result.node.pmStatus || 'Not Started';
                const wasProgress = result.node.pmProgress || 0;

                result.node.pmStatus = 'Done';
                result.node.pmProgress = 100;

                if (typeof saveState === 'function') saveState('Treebeard: Marked done');
                if (typeof renderGantt === 'function' && typeof ganttInstance !== 'undefined') renderGantt();

                return `âœ… Marked **${result.task.name}** as Done!\nâ€¢ Status: ${wasStatus} â†’ Done\nâ€¢ Progress: ${wasProgress}% â†’ 100%`;
            },

            'gantt_mark_blocked': (args) => {
                if (!args) return 'âš ï¸ Usage: gantt_mark_blocked:{task name}, {reason}\nExample: "mark Design Phase as blocked waiting for client feedback"';

                // Split task name from reason
                const parts = args.split(/[,:]/).map(p => p.trim());
                const taskName = parts[0];
                const reason = parts.slice(1).join(', ') || 'No reason specified';

                const result = COMMAND_REGISTRY['_gantt_find_task'](taskName);
                if (result.error) return result.error;

                const wasStatus = result.node.pmStatus || 'Not Started';
                result.node.pmStatus = 'Blocked';

                // Add reason to notes/description
                result.node.blockReason = reason;
                if (result.node.notes) {
                    result.node.notes += `\n[BLOCKED] ${reason}`;
                } else if (result.node.description) {
                    result.node.description += `\n\n[BLOCKED] ${reason}`;
                }

                if (typeof saveState === 'function') saveState('Treebeard: Marked blocked');
                if (typeof renderGantt === 'function' && typeof ganttInstance !== 'undefined') renderGantt();

                return `ğŸš« Marked **${result.task.name}** as Blocked\nâ€¢ Previous status: ${wasStatus}\nâ€¢ Reason: ${reason}`;
            },

            // Theme commands
            'set_theme_dark': () => {
                document.getElementById('theme-select').value = 'default';
                document.getElementById('theme-select').dispatchEvent(new Event('change'));
                return 'ğŸŒ™ Dark theme applied!';
            },
            'set_theme_steampunk': () => {
                document.getElementById('theme-select').value = 'steampunk';
                document.getElementById('theme-select').dispatchEvent(new Event('change'));
                return 'âš™ï¸ Steampunk theme applied!';
            },
            'set_theme_tron': () => {
                document.getElementById('theme-select').value = 'tron';
                document.getElementById('theme-select').dispatchEvent(new Event('change'));
                return 'ğŸ’  Tron theme applied!';
            },

            // Pattern commands
            'list_patterns': () => {
                const patterns = ['Generic', 'Philosophy', 'Sales', 'CAPEX', 'Thesis', 'Roadmap', 'Book', 'Film', 'Course', 'Fitness', 'Event', 'Strategy', 'Family Tree', 'Dialogue', 'File System'];
                return 'ğŸ“‹ Available patterns:\nâ€¢ ' + patterns.join('\nâ€¢ ');
            },
            'switch_pattern': (patternName) => {
                const select = document.getElementById('pattern-select');
                if (select) {
                    const options = Array.from(select.options);
                    const match = options.find(o => o.text.toLowerCase().includes(patternName.toLowerCase()));
                    if (match) {
                        select.value = match.value;
                        select.dispatchEvent(new Event('change'));
                        return `âœ… Switched to ${match.text} pattern!`;
                    }
                }
                return `âŒ Pattern "${patternName}" not found. Try "list patterns" to see options.`;
            },

            // Export commands
            'export_json': () => {
                document.getElementById('save-btn')?.click();
                return 'ğŸ’¾ JSON file downloaded!';
            },
            'export_excel': () => {
                document.getElementById('excel-export-btn')?.click();
                return 'ğŸ“Š Excel file downloaded!';
            },
            'export_canvas_image': () => {
                if (typeof exportCanvasAsImage === 'function') {
                    exportCanvasAsImage();
                    return 'ğŸ“· Canvas exported as PNG!';
                }
                return 'âŒ Please switch to Canvas view first.';
            },

            // Tree manipulation
            'add_phase': () => {
                document.getElementById('add-phase-btn')?.click();
                return 'â• New phase added! You can rename it by clicking on it.';
            },

            // BUILD 576: Add single node to tree
            'add_node': (args) => {
                try {
                    // Parse args: "Name" or "Name | Description" or JSON
                    let name, description = '';

                    if (!args || args.trim() === '') {
                        return 'âš ï¸ Please specify a node name. Example: `add_node My New Task` or `add_node Task Name | Task description here`';
                    }

                    // Check if it's JSON format
                    if (args.trim().startsWith('{')) {
                        try {
                            const parsed = JSON.parse(args);
                            name = parsed.name;
                            description = parsed.description || '';
                        } catch (e) {
                            return 'âŒ Invalid JSON format. Use: `add_node {"name": "Task", "description": "Details"}`';
                        }
                    } else if (args.includes('|')) {
                        // "Name | Description" format
                        const parts = args.split('|');
                        name = parts[0].trim();
                        description = parts.slice(1).join('|').trim();
                    } else {
                        // Just the name
                        name = args.trim();
                    }

                    if (!name) {
                        return 'âš ï¸ Node name is required.';
                    }

                    // Find target phase - use focused node's phase or first phase
                    const phases = capexTree?.children || capexTree?.phases || [];
                    if (phases.length === 0) {
                        return 'âš ï¸ No phases in tree. Use `add_phase` first.';
                    }

                    let targetPhase = phases[0];
                    let targetPhaseIndex = 0;
                    const focusedNode = window.chatFocusedNode;

                    if (focusedNode) {
                        // Find which phase contains the focused node
                        for (let i = 0; i < phases.length; i++) {
                            const phase = phases[i];
                            const items = phase.items || phase.children || phase.subItems || [];
                            const found = items.some(item => item.id === focusedNode.id) ||
                                items.some(item => (item.subItems || item.children || []).some(sub => sub.id === focusedNode.id));
                            if (found || phase.id === focusedNode.id) {
                                targetPhase = phase;
                                targetPhaseIndex = i;
                                break;
                            }
                        }
                    }

                    // Save undo state
                    if (typeof saveState === 'function') saveState('Add node via Treebeard');

                    // Create the new node
                    const timestamp = Date.now();
                    const newNode = {
                        type: 'item',
                        id: `item-${targetPhaseIndex}-${timestamp}`,
                        nodeGuid: typeof generateNodeGuid === 'function' ? generateNodeGuid() : `n_${timestamp}`,
                        name: name,
                        description: description,
                        icon: 'ğŸ“',
                        provenance: { source: 'treebeard', timestamp: new Date().toISOString() }
                    };

                    if (!targetPhase.items) targetPhase.items = [];
                    targetPhase.items.push(newNode);

                    // Track and render
                    if (typeof trackNodeChange === 'function') trackNodeChange(newNode.id, 'added');
                    if (typeof render === 'function') render();

                    return `âœ… Added "${name}" to "${targetPhase.name}"${description ? ' with description' : ''}`;
                } catch (error) {
                    console.error('Error adding node:', error);
                    return `âŒ Failed to add node: ${error.message}`;
                }
            },

            // BUILD 576: Add child node to focused/selected node
            'add_child': (args) => {
                try {
                    const focusedNode = window.chatFocusedNode || activeNode;
                    if (!focusedNode) {
                        return 'âš ï¸ No node focused. Click on a node first, then use `add_child Child Name`.';
                    }

                    // Parse args same as add_node
                    let name, description = '';

                    if (!args || args.trim() === '') {
                        return `âš ï¸ Please specify child name. Example: \`add_child New Subtask\` (will add to "${focusedNode.name}")`;
                    }

                    if (args.trim().startsWith('{')) {
                        try {
                            const parsed = JSON.parse(args);
                            name = parsed.name;
                            description = parsed.description || '';
                        } catch (e) {
                            return 'âŒ Invalid JSON format.';
                        }
                    } else if (args.includes('|')) {
                        const parts = args.split('|');
                        name = parts[0].trim();
                        description = parts.slice(1).join('|').trim();
                    } else {
                        name = args.trim();
                    }

                    if (!name) return 'âš ï¸ Child name is required.';

                    // Save undo state
                    if (typeof saveState === 'function') saveState('Add child via Treebeard');

                    // Determine child array based on node type
                    const timestamp = Date.now();
                    const newChild = {
                        type: 'subtask',
                        id: `subtask-${timestamp}`,
                        nodeGuid: typeof generateNodeGuid === 'function' ? generateNodeGuid() : `n_${timestamp}`,
                        name: name,
                        description: description,
                        icon: 'ğŸ“Œ',
                        provenance: { source: 'treebeard', timestamp: new Date().toISOString() }
                    };

                    // Add to appropriate child array
                    if (focusedNode.type === 'phase' || focusedNode.id === 'root') {
                        newChild.type = 'item';
                        newChild.id = `item-${timestamp}`;
                        if (!focusedNode.items) focusedNode.items = [];
                        focusedNode.items.push(newChild);
                    } else if (focusedNode.type === 'item') {
                        if (!focusedNode.subItems) focusedNode.subItems = [];
                        focusedNode.subItems.push(newChild);
                    } else {
                        // Generic children array
                        if (!focusedNode.children) focusedNode.children = [];
                        focusedNode.children.push(newChild);
                    }

                    // Ensure parent is expanded
                    focusedNode.collapsed = false;

                    // Track and render
                    if (typeof trackNodeChange === 'function') trackNodeChange(newChild.id, 'added');
                    if (typeof render === 'function') render();

                    return `âœ… Added "${name}" as child of "${focusedNode.name}"`;
                } catch (error) {
                    console.error('Error adding child:', error);
                    return `âŒ Failed to add child: ${error.message}`;
                }
            },

            // BUILD 578: Preview node contents directly in chat
            'preview_node': (nodeIdOrName) => {
                if (!nodeIdOrName) {
                    const focused = window.chatFocusedNode || activeNode;
                    if (!focused) return 'âš ï¸ No node focused. Use `preview_node {name}` or focus a node first.';
                    nodeIdOrName = focused.id;
                }

                // Find node by ID or name
                let node = findNodeById(nodeIdOrName);
                if (!node) {
                    node = findNodeByName(capexTree, nodeIdOrName);
                }
                if (!node) {
                    return `âŒ Node "${nodeIdOrName}" not found.`;
                }

                // Build preview
                const children = node.children || node.items || node.subItems || node.subtasks || [];
                const childCount = children.length;
                const desc = node.description ? `\n\n**Description:**\n${node.description.substring(0, 500)}${node.description.length > 500 ? '...' : ''}` : '';
                const childList = childCount > 0
                    ? `\n\n**Children (${childCount}):**\n${children.slice(0, 10).map(c => `â€¢ ${c.name || c.id}`).join('\n')}${childCount > 10 ? `\n... and ${childCount - 10} more` : ''}`
                    : '\n\n*No children*';

                return `ğŸ“‹ **${node.name}**\n\nType: ${node.type || 'item'}\nID: \`${node.id}\`${node.nodeGuid ? `\nGUID: \`${node.nodeGuid}\`` : ''}${desc}${childList}`;
            },

            // BUILD 578: Move node to new parent
            'move_node': (args) => {
                if (!args) {
                    return 'âš ï¸ Usage: `move_node {node_name} to {parent_name}`\nExample: `move_node Bergson to French Critics`';
                }

                // Parse "node to parent" format
                const toMatch = args.match(/^(.+?)\s+to\s+(.+)$/i);
                if (!toMatch) {
                    return 'âš ï¸ Format: `move_node {source} to {destination}`';
                }

                const sourceName = toMatch[1].trim();
                const destName = toMatch[2].trim();

                // Find source node
                let sourceNode = findNodeById(sourceName) || findNodeByName(capexTree, sourceName);
                if (!sourceNode) {
                    return `âŒ Source node "${sourceName}" not found.`;
                }

                // Find destination node
                let destNode = findNodeById(destName) || findNodeByName(capexTree, destName);
                if (!destNode) {
                    return `âŒ Destination "${destName}" not found.`;
                }

                // Prevent moving to self or descendant
                if (sourceNode.id === destNode.id) {
                    return `âŒ Cannot move node to itself.`;
                }

                // Save undo state
                if (typeof saveState === 'function') saveState('Move node via Treebeard');

                // Remove from current parent
                function removeFromParent(tree, nodeId) {
                    const arrays = ['children', 'items', 'subItems', 'subtasks'];
                    for (const arr of arrays) {
                        if (tree[arr]) {
                            const idx = tree[arr].findIndex(n => n.id === nodeId);
                            if (idx !== -1) {
                                tree[arr].splice(idx, 1);
                                return true;
                            }
                            for (const child of tree[arr]) {
                                if (removeFromParent(child, nodeId)) return true;
                            }
                        }
                    }
                    return false;
                }

                removeFromParent(capexTree, sourceNode.id);

                // Add to destination
                if (!destNode.items) destNode.items = [];
                if (!destNode.children) destNode.children = [];

                // Use items for phases, children for others
                if (destNode.type === 'phase') {
                    destNode.items.push(sourceNode);
                } else {
                    destNode.children.push(sourceNode);
                }

                // Expand destination
                destNode.collapsed = false;

                // BUILD 591: Show action toast before render
                if (typeof showToast === 'function') {
                    showToast(`ğŸ“¦ Moving "${sourceNode.name}" â†’ "${destNode.name}"`, 'info', 2000);
                }

                if (typeof render === 'function') render();
                if (typeof trackNodeChange === 'function') trackNodeChange(sourceNode.id, 'moved');

                // BUILD 591: Scroll to moved node after brief delay
                setTimeout(() => {
                    const nodeEl = document.querySelector(`[data-node-id="${sourceNode.id}"]`);
                    if (nodeEl) {
                        nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);

                return `âœ… Moved "${sourceNode.name}" to "${destNode.name}"`;
            },

            // BUILD 581: Rename node
            'rename_node': (args) => {
                if (!args) {
                    return 'âš ï¸ Usage: `rename_node {old_name} to {new_name}`\nOr: `rename_node {new_name}` (renames focused node)';
                }

                let targetNode = null;
                let newName = null;

                // Parse "old to new" format
                const toMatch = args.match(/^(.+?)\s+to\s+(.+)$/i);
                if (toMatch) {
                    const oldName = toMatch[1].trim();
                    newName = toMatch[2].trim();
                    targetNode = findNodeById(oldName) || findNodeByName(capexTree, oldName);
                } else {
                    // Single arg = rename focused node
                    newName = args.trim();
                    targetNode = window.chatFocusedNode || activeNode;
                }

                if (!targetNode) {
                    return 'âŒ Node not found. Use `rename_node {old_name} to {new_name}` or focus a node first.';
                }

                if (!newName) {
                    return 'âš ï¸ Please provide a new name.';
                }

                if (targetNode.id === capexTree.id) {
                    return 'âŒ Cannot rename root via this command. Edit it directly in the info panel.';
                }

                const oldName = targetNode.name;

                // Save undo state
                if (typeof saveState === 'function') saveState(`Rename node from "${oldName}" to "${newName}"`);

                targetNode.name = newName;

                if (typeof render === 'function') render();
                if (typeof trackNodeChange === 'function') trackNodeChange(targetNode.id, 'renamed');

                return `âœ… Renamed "${oldName}" â†’ "${newName}"`;
            },

            // BUILD 581: Read full node content
            'read_node': (nodeIdOrName) => {
                const focused = window.chatFocusedNode || activeNode;
                const targetNode = nodeIdOrName
                    ? (findNodeById(nodeIdOrName) || findNodeByName(capexTree, nodeIdOrName))
                    : focused;

                if (!targetNode) {
                    return 'âš ï¸ No node specified or focused. Use `read_node {name}` or focus a node first.';
                }

                const children = targetNode.children || targetNode.items || targetNode.subItems || targetNode.subtasks || [];
                const tags = targetNode.tags ? `\n**Tags:** ${targetNode.tags}` : '';
                const pattern = targetNode.pattern?.key ? `\n**Pattern:** ${targetNode.pattern.key}` : '';

                // Full description without truncation
                const desc = targetNode.description
                    ? `\n\n---\n**Content:**\n${targetNode.description}`
                    : '\n\n*No description/content*';

                const childList = children.length > 0
                    ? `\n\n**Children (${children.length}):**\n${children.map(c => `â€¢ ${c.name || c.id}`).join('\n')}`
                    : '';

                return `ğŸ“– **${targetNode.name}**\n\n` +
                       `Type: ${targetNode.type || 'item'} | ID: \`${targetNode.id}\`${tags}${pattern}${desc}${childList}`;
            },

            // BUILD 578: Duplicate node (safety copy)
            'duplicate_node': (nodeIdOrName) => {
                const focused = window.chatFocusedNode || activeNode;
                const targetNode = nodeIdOrName
                    ? (findNodeById(nodeIdOrName) || findNodeByName(capexTree, nodeIdOrName))
                    : focused;

                if (!targetNode) {
                    return 'âš ï¸ No node specified or focused. Use `duplicate_node {name}` or focus a node first.';
                }

                if (targetNode.id === 'root' || targetNode.id === capexTree.id) {
                    return 'âŒ Cannot duplicate root node.';
                }

                // Save undo state
                if (typeof saveState === 'function') saveState('Duplicate node via Treebeard');

                // Deep clone the node
                const timestamp = Date.now();
                function cloneNode(node, isRoot = false) {
                    const clone = { ...node };
                    clone.id = `${node.id}-copy-${timestamp}`;
                    clone.nodeGuid = typeof generateNodeGuid === 'function' ? generateNodeGuid() : `n_${timestamp}`;
                    if (isRoot) clone.name = `${node.name} (Copy)`;

                    // Clone children recursively
                    ['children', 'items', 'subItems', 'subtasks'].forEach(arr => {
                        if (clone[arr]) {
                            clone[arr] = clone[arr].map(child => cloneNode(child, false));
                        }
                    });
                    return clone;
                }

                const duplicate = cloneNode(targetNode, true);

                // Find parent and add duplicate
                function findParentAndAdd(tree, nodeId, newNode) {
                    const arrays = ['children', 'items', 'subItems', 'subtasks'];
                    for (const arr of arrays) {
                        if (tree[arr]) {
                            const idx = tree[arr].findIndex(n => n.id === nodeId);
                            if (idx !== -1) {
                                tree[arr].splice(idx + 1, 0, newNode);
                                return true;
                            }
                            for (const child of tree[arr]) {
                                if (findParentAndAdd(child, nodeId, newNode)) return true;
                            }
                        }
                    }
                    return false;
                }

                findParentAndAdd(capexTree, targetNode.id, duplicate);

                if (typeof render === 'function') render();
                if (typeof trackNodeChange === 'function') trackNodeChange(duplicate.id, 'added');

                return `âœ… Created copy: "${duplicate.name}" (${duplicate.id})`;
            },

            // BUILD 578: compare_nodes moved to line ~64871 (consolidated with multi-select version)

            // BUILD 578: Search tree for nodes matching query
            'search_tree': (query) => {
                if (!query || query.trim() === '') {
                    return 'âš ï¸ Usage: `search_tree {query}`\nExample: `search_tree budget` or `search_tree @tag:important`';
                }

                query = query.trim();
                const results = [];
                const maxResults = 15;

                // Check for tag search: @tag:value or #value
                const tagMatch = query.match(/^(?:@tag:|#)(.+)$/i);
                const isTagSearch = !!tagMatch;
                const searchTerm = tagMatch ? tagMatch[1].toLowerCase() : query.toLowerCase();

                function searchNode(node, path = []) {
                    if (results.length >= maxResults) return;

                    const nodeName = (node.name || node.title || '').toLowerCase();
                    const nodeDesc = (node.description || '').toLowerCase();
                    const nodeTags = (node.tags || '').toLowerCase();
                    const nodeId = (node.id || '').toLowerCase();

                    let matched = false;
                    let matchField = '';

                    if (isTagSearch) {
                        // Tag search - check tags field
                        if (nodeTags.includes(searchTerm)) {
                            matched = true;
                            matchField = 'tags';
                        }
                    } else {
                        // General search - check name, description, id
                        if (nodeName.includes(searchTerm)) {
                            matched = true;
                            matchField = 'name';
                        } else if (nodeDesc.includes(searchTerm)) {
                            matched = true;
                            matchField = 'description';
                        } else if (nodeId.includes(searchTerm)) {
                            matched = true;
                            matchField = 'id';
                        } else if (nodeTags.includes(searchTerm)) {
                            matched = true;
                            matchField = 'tags';
                        }
                    }

                    if (matched) {
                        results.push({
                            node: node,
                            path: path.join(' > '),
                            matchField: matchField
                        });
                    }

                    // Search children
                    ['children', 'items', 'subItems', 'subtasks'].forEach(arr => {
                        if (node[arr]) {
                            node[arr].forEach(child => {
                                searchNode(child, [...path, node.name || node.id]);
                            });
                        }
                    });
                }

                // Start search from root
                searchNode(capexTree, []);

                if (results.length === 0) {
                    return `ğŸ” No results found for "${query}"`;
                }

                let output = `ğŸ” **Found ${results.length}${results.length >= maxResults ? '+' : ''} results for "${query}":**\n\n`;
                results.forEach((r, i) => {
                    const icon = r.matchField === 'tags' ? 'ğŸ·ï¸' : r.matchField === 'name' ? 'ğŸ“„' : 'ğŸ“';
                    output += `${i + 1}. ${icon} **${r.node.name || r.node.id}**`;
                    if (r.path) output += `\n   â”” ${r.path}`;
                    output += '\n';
                });

                output += `\nğŸ’¡ Use \`focus {name}\` to navigate to a result.`;
                return output;
            },

            // BUILD 578: Add or manage tags on a node
            'tag_node': (args) => {
                if (!args || args.trim() === '') {
                    return 'âš ï¸ Usage: `tag_node {node_name} with {tags}` or `tag_node {tags}` (for focused node)\nExample: `tag_node Budget with important, review` or `tag_node urgent, high-priority`';
                }

                let targetNode = null;
                let tagsToAdd = '';

                // Parse "node with tags" format
                const withMatch = args.match(/^(.+?)\s+with\s+(.+)$/i);
                if (withMatch) {
                    const nodeName = withMatch[1].trim();
                    tagsToAdd = withMatch[2].trim();
                    targetNode = findNodeById(nodeName) || findNodeByName(capexTree, nodeName);
                    if (!targetNode) {
                        return `âŒ Node "${nodeName}" not found.`;
                    }
                } else {
                    // Apply tags to focused node
                    targetNode = window.chatFocusedNode || activeNode;
                    if (!targetNode) {
                        return 'âš ï¸ No node focused. Use `tag_node {name} with {tags}` or focus a node first.';
                    }
                    tagsToAdd = args.trim();
                }

                // Save undo state
                if (typeof saveState === 'function') saveState('Tag node via Treebeard');

                // Parse and normalize tags
                const newTags = tagsToAdd.split(/[,;]/).map(t => t.trim().toLowerCase()).filter(t => t);
                if (newTags.length === 0) {
                    return 'âš ï¸ No valid tags provided.';
                }

                // Get existing tags
                const existingTags = (targetNode.tags || '').split(/[,;]/).map(t => t.trim().toLowerCase()).filter(t => t);

                // Merge tags (avoid duplicates)
                const allTags = [...new Set([...existingTags, ...newTags])];
                targetNode.tags = allTags.join(', ');

                // Render and track
                if (typeof render === 'function') render();
                if (typeof trackNodeChange === 'function') trackNodeChange(targetNode.id, 'edited');

                const addedCount = newTags.filter(t => !existingTags.includes(t)).length;
                return `ğŸ·ï¸ Tagged "${targetNode.name}" with: ${newTags.join(', ')}\n` +
                       `Total tags: ${allTags.join(', ')}` +
                       (addedCount < newTags.length ? `\n(${newTags.length - addedCount} tag(s) already existed)` : '');
            },

            // BUILD 578: Remove tags from a node
            'untag_node': (args) => {
                if (!args || args.trim() === '') {
                    return 'âš ï¸ Usage: `untag_node {node_name} remove {tags}` or `untag_node {tags}` (for focused node)';
                }

                let targetNode = null;
                let tagsToRemove = '';

                // Parse "node remove tags" format
                const removeMatch = args.match(/^(.+?)\s+remove\s+(.+)$/i);
                if (removeMatch) {
                    const nodeName = removeMatch[1].trim();
                    tagsToRemove = removeMatch[2].trim();
                    targetNode = findNodeById(nodeName) || findNodeByName(capexTree, nodeName);
                    if (!targetNode) {
                        return `âŒ Node "${nodeName}" not found.`;
                    }
                } else {
                    targetNode = window.chatFocusedNode || activeNode;
                    if (!targetNode) {
                        return 'âš ï¸ No node focused. Use `untag_node {name} remove {tags}` or focus a node first.';
                    }
                    tagsToRemove = args.trim();
                }

                if (!targetNode.tags) {
                    return `â„¹ï¸ "${targetNode.name}" has no tags to remove.`;
                }

                // Save undo state
                if (typeof saveState === 'function') saveState('Remove tags via Treebeard');

                const toRemove = new Set(tagsToRemove.split(/[,;]/).map(t => t.trim().toLowerCase()).filter(t => t));
                const existingTags = targetNode.tags.split(/[,;]/).map(t => t.trim().toLowerCase()).filter(t => t);
                const remainingTags = existingTags.filter(t => !toRemove.has(t));
                const removedCount = existingTags.length - remainingTags.length;

                targetNode.tags = remainingTags.join(', ');

                if (typeof render === 'function') render();
                if (typeof trackNodeChange === 'function') trackNodeChange(targetNode.id, 'edited');

                if (removedCount === 0) {
                    return `â„¹ï¸ None of the specified tags were found on "${targetNode.name}"`;
                }

                return `ğŸ·ï¸ Removed ${removedCount} tag(s) from "${targetNode.name}"\n` +
                       (remainingTags.length > 0 ? `Remaining tags: ${remainingTags.join(', ')}` : 'No tags remaining');
            },

            // BUILD 578: List all tags in the tree
            'list_tags': () => {
                const tagCounts = {};

                function collectTags(node) {
                    if (node.tags) {
                        node.tags.split(/[,;]/).forEach(t => {
                            const tag = t.trim().toLowerCase();
                            if (tag) {
                                tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                            }
                        });
                    }
                    ['children', 'items', 'subItems', 'subtasks'].forEach(arr => {
                        if (node[arr]) node[arr].forEach(collectTags);
                    });
                }

                collectTags(capexTree);

                const tags = Object.entries(tagCounts).sort((a, b) => b[1] - a[1]);

                if (tags.length === 0) {
                    return 'ğŸ·ï¸ No tags found in this tree.\n\nğŸ’¡ Add tags with `tag_node {name} with {tags}`';
                }

                let output = `ğŸ·ï¸ **Tags in "${capexTree.name}" (${tags.length} unique):**\n\n`;
                tags.slice(0, 20).forEach(([tag, count]) => {
                    output += `â€¢ **${tag}** (${count} node${count > 1 ? 's' : ''})\n`;
                });
                if (tags.length > 20) {
                    output += `\n... and ${tags.length - 20} more tags`;
                }
                output += `\n\nğŸ’¡ Search by tag: \`search_tree #tagname\``;

                return output;
            },

            // BUILD 578: List all empty nodes (containers with 0 children)
            'list_empty_nodes': () => {
                const emptyNodes = [];

                function findEmpty(node, path = []) {
                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    const hasChildren = children.length > 0;
                    const isLeaf = node.type === 'item' || node.type === 'subitem';

                    // A node is "empty" if it's a container type (phase, category) with no children
                    // OR if it's explicitly marked as expandable but has nothing
                    if (!isLeaf && !hasChildren && node.id !== capexTree.id) {
                        emptyNodes.push({
                            node: node,
                            path: path.join(' > '),
                            type: node.type || 'unknown'
                        });
                    }

                    // Recurse
                    children.forEach(child => {
                        findEmpty(child, [...path, node.name || node.id]);
                    });
                }

                findEmpty(capexTree, []);

                if (emptyNodes.length === 0) {
                    return 'âœ… No empty containers found! All nodes have content.';
                }

                let output = `ğŸ“­ **Found ${emptyNodes.length} empty container(s):**\n\n`;
                emptyNodes.slice(0, 15).forEach((e, i) => {
                    output += `${i + 1}. **${e.node.name || e.node.id}** (${e.type})\n`;
                    if (e.path) output += `   â”” ${e.path}\n`;
                });
                if (emptyNodes.length > 15) {
                    output += `\n... and ${emptyNodes.length - 15} more`;
                }
                output += `\n\nğŸ’¡ Use \`focus {name}\` then \`add_child\` to fill, or \`delete_node\` to remove.`;

                return output;
            },

            // BUILD 578: Show tree structure with item counts
            'show_tree_structure': (maxDepth) => {
                const depth = parseInt(maxDepth) || 3;
                let output = `ğŸŒ³ **Tree Structure: "${capexTree.name}"**\n\n`;

                function renderNode(node, indent = 0, currentDepth = 0) {
                    if (currentDepth > depth) return '';

                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    const prefix = '  '.repeat(indent);
                    const icon = children.length > 0 ? 'ğŸ“' : 'ğŸ“„';
                    const count = children.length > 0 ? ` (${children.length})` : '';

                    let line = `${prefix}${icon} ${node.name || node.id}${count}\n`;

                    if (currentDepth < depth) {
                        children.forEach(child => {
                            line += renderNode(child, indent + 1, currentDepth + 1);
                        });
                    } else if (children.length > 0) {
                        line += `${prefix}  â”” ... ${children.length} more\n`;
                    }

                    return line;
                }

                output += renderNode(capexTree, 0, 0);

                // Summary
                let totalNodes = 0;
                function count(node) {
                    totalNodes++;
                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    children.forEach(count);
                }
                count(capexTree);

                output += `\nğŸ“Š **Total: ${totalNodes} nodes** (showing ${depth} levels)`;
                output += `\nğŸ’¡ Use \`show_tree_structure {depth}\` to see more/fewer levels.`;

                return output;
            },

            // BUILD 578: Find duplicate/similar node names
            'find_duplicates': () => {
                const nameMap = {};

                function collectNames(node, path = []) {
                    const name = (node.name || '').toLowerCase().trim();
                    if (name && name.length > 2) {
                        if (!nameMap[name]) nameMap[name] = [];
                        nameMap[name].push({
                            node: node,
                            path: path.join(' > ')
                        });
                    }
                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    children.forEach(child => {
                        collectNames(child, [...path, node.name || node.id]);
                    });
                }

                collectNames(capexTree, []);

                // Find duplicates (names appearing more than once)
                const duplicates = Object.entries(nameMap)
                    .filter(([name, nodes]) => nodes.length > 1)
                    .sort((a, b) => b[1].length - a[1].length);

                if (duplicates.length === 0) {
                    return 'âœ… No duplicate node names found!';
                }

                let output = `âš ï¸ **Found ${duplicates.length} duplicate name(s):**\n\n`;
                duplicates.slice(0, 10).forEach(([name, nodes]) => {
                    output += `**"${nodes[0].node.name}"** appears ${nodes.length} times:\n`;
                    nodes.forEach((n, i) => {
                        output += `  ${i + 1}. ${n.path || 'root'}\n`;
                    });
                    output += '\n';
                });
                if (duplicates.length > 10) {
                    output += `... and ${duplicates.length - 10} more duplicates`;
                }
                output += `\nğŸ’¡ Use \`merge_nodes {node1} and {node2}\` to combine, or \`compare_nodes\` to check content.`;

                return output;
            },

            // BUILD 578: Show detailed stats for a node
            'node_stats': (nodeIdOrName) => {
                let targetNode = null;

                if (!nodeIdOrName) {
                    targetNode = window.chatFocusedNode || activeNode;
                    if (!targetNode) {
                        return 'âš ï¸ Usage: `node_stats {node_name}` or focus a node first.';
                    }
                } else {
                    targetNode = findNodeById(nodeIdOrName) || findNodeByName(capexTree, nodeIdOrName);
                    if (!targetNode) {
                        return `âŒ Node "${nodeIdOrName}" not found.`;
                    }
                }

                // Calculate stats
                let totalDescendants = 0;
                let maxDepth = 0;
                let totalContentLength = 0;

                function analyze(node, depth = 0) {
                    totalDescendants++;
                    if (depth > maxDepth) maxDepth = depth;
                    totalContentLength += (node.description || '').length;
                    totalContentLength += (node.name || '').length;

                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    children.forEach(child => analyze(child, depth + 1));
                }

                const directChildren = targetNode.children || targetNode.items || targetNode.subItems || targetNode.subtasks || [];
                directChildren.forEach(child => analyze(child, 1));

                const descLen = (targetNode.description || '').length;

                let output = `ğŸ“Š **Stats for "${targetNode.name}"**\n\n`;
                output += `â€¢ **Type:** ${targetNode.type || 'item'}\n`;
                output += `â€¢ **ID:** \`${targetNode.id}\`\n`;
                if (targetNode.nodeGuid) output += `â€¢ **GUID:** \`${targetNode.nodeGuid}\`\n`;
                output += `â€¢ **Direct children:** ${directChildren.length}\n`;
                output += `â€¢ **Total descendants:** ${totalDescendants}\n`;
                output += `â€¢ **Max depth:** ${maxDepth} level(s)\n`;
                output += `â€¢ **Description length:** ${descLen} chars\n`;
                output += `â€¢ **Total content:** ${totalContentLength} chars\n`;

                if (targetNode.tags) {
                    output += `â€¢ **Tags:** ${targetNode.tags}\n`;
                }

                return output;
            },

            // BUILD 586: Bulk move - move multiple items to a destination
            'bulk_move': (args) => {
                if (!args) {
                    return 'âš ï¸ Usage: `bulk_move {item1}, {item2}, {item3} to {destination}`\nMoves multiple nodes to a new parent in one operation.';
                }

                const toMatch = args.match(/^(.+?)\s+to\s+(.+)$/i);
                if (!toMatch) {
                    return 'âš ï¸ Format: `bulk_move {items} to {destination}`';
                }

                const itemsStr = toMatch[1].trim();
                const destName = toMatch[2].trim();
                const itemNames = itemsStr.split(/,\s*/).map(s => s.trim()).filter(s => s);

                if (itemNames.length === 0) {
                    return 'âš ï¸ No items specified.';
                }

                const destNode = findNodeById(destName) || findNodeByName(capexTree, destName);
                if (!destNode) {
                    return `âŒ Destination "${destName}" not found.`;
                }

                // Save single undo state
                if (typeof saveState === 'function') saveState(`Bulk move ${itemNames.length} items to ${destName}`);

                let movedCount = 0;
                let errors = [];

                itemNames.forEach(name => {
                    const node = findNodeById(name) || findNodeByName(capexTree, name);
                    if (!node) {
                        errors.push(`"${name}" not found`);
                        return;
                    }
                    if (node.id === capexTree.id || node.id === destNode.id) {
                        errors.push(`Cannot move "${name}"`);
                        return;
                    }

                    // Remove from current parent
                    if (typeof removeFromParent === 'function') {
                        removeFromParent(capexTree, node.id);
                    }

                    // Add to destination
                    if (!destNode.children) destNode.children = [];
                    if (!destNode.items) destNode.items = [];
                    if (destNode.type === 'phase') {
                        destNode.items.push(node);
                    } else {
                        destNode.children.push(node);
                    }
                    // BUILD 591: Track each moved node for animation
                    if (typeof trackNodeChange === 'function') trackNodeChange(node.id, 'moved');
                    movedCount++;
                });

                // BUILD 591: Show action toast
                if (typeof showToast === 'function') {
                    showToast(`ğŸ“¦ Moving ${movedCount} items â†’ "${destNode.name}"`, 'info', 2000);
                }

                destNode.collapsed = false;
                if (typeof render === 'function') render();

                // BUILD 591: Scroll to destination after brief delay
                setTimeout(() => {
                    const destEl = document.querySelector(`[data-node-id="${destNode.id}"]`);
                    if (destEl) {
                        destEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);

                let result = `âœ… Moved **${movedCount}/${itemNames.length}** items to "${destNode.name}"`;
                if (errors.length > 0) {
                    result += `\n\nâš ï¸ Issues:\n${errors.map(e => `â€¢ ${e}`).join('\n')}`;
                }
                result += `\n\nğŸ’¡ Use \`undo\` to reverse.`;
                return result;
            },

            // BUILD 586: Analyze tree balance and suggest redistribution
            'analyze_balance': () => {
                const phases = capexTree.children || [];
                if (phases.length === 0) {
                    return 'âš ï¸ No phases found in tree.';
                }

                const stats = phases.map(p => {
                    const items = p.items || p.children || [];
                    return { name: p.name, count: items.length, id: p.id };
                }).sort((a, b) => b.count - a.count);

                const total = stats.reduce((sum, s) => sum + s.count, 0);
                const avg = Math.round(total / stats.length);
                const overloaded = stats.filter(s => s.count > avg * 1.5);
                const empty = stats.filter(s => s.count === 0);
                const light = stats.filter(s => s.count > 0 && s.count < avg * 0.5);

                let output = `ğŸ“Š **Tree Balance Analysis**\n\n`;
                output += `**Total items:** ${total} across ${stats.length} phases\n`;
                output += `**Average per phase:** ${avg} items\n\n`;

                if (overloaded.length > 0) {
                    output += `ğŸ”´ **Overloaded (>${Math.round(avg * 1.5)} items):**\n`;
                    overloaded.forEach(p => {
                        output += `â€¢ "${p.name}" - ${p.count} items (${p.count - avg} over avg)\n`;
                    });
                    output += '\n';
                }

                if (empty.length > 0) {
                    output += `âšª **Empty phases:**\n`;
                    empty.forEach(p => {
                        output += `â€¢ "${p.name}" - 0 items\n`;
                    });
                    output += '\n';
                }

                if (light.length > 0) {
                    output += `ğŸŸ¡ **Light (<${Math.round(avg * 0.5)} items):**\n`;
                    light.forEach(p => {
                        output += `â€¢ "${p.name}" - ${p.count} items\n`;
                    });
                    output += '\n';
                }

                output += `ğŸ’¡ **Suggestions:**\n`;
                if (overloaded.length > 0) {
                    output += `â€¢ Use \`bulk_move {items} to {dest}\` to redistribute from overloaded phases\n`;
                }
                if (empty.length > 0) {
                    output += `â€¢ Use \`delete_empty_nodes confirm\` to remove empty containers\n`;
                    output += `â€¢ Or use \`merge_nodes {empty} into {related}\` to consolidate\n`;
                }

                return output;
            },

            // BUILD 578: Merge two nodes (move children from source to destination)
            'merge_nodes': (args) => {
                if (!args) {
                    return 'âš ï¸ Usage: `merge_nodes {source} into {destination}`\nThis moves all children from source to destination, then deletes source.';
                }

                // Parse "source into destination" format
                const match = args.match(/^(.+?)\s+(?:into|to|with)\s+(.+)$/i);
                if (!match) {
                    return 'âš ï¸ Format: `merge_nodes {source} into {destination}`';
                }

                const sourceName = match[1].trim();
                const destName = match[2].trim();

                const sourceNode = findNodeById(sourceName) || findNodeByName(capexTree, sourceName);
                const destNode = findNodeById(destName) || findNodeByName(capexTree, destName);

                if (!sourceNode) return `âŒ Source node "${sourceName}" not found.`;
                if (!destNode) return `âŒ Destination node "${destName}" not found.`;
                if (sourceNode.id === destNode.id) return 'âŒ Cannot merge a node with itself.';
                if (sourceNode.id === capexTree.id) return 'âŒ Cannot merge root node.';

                // Save undo state
                if (typeof saveState === 'function') saveState('Merge nodes via Treebeard');

                // Get children from source
                const sourceChildren = sourceNode.children || sourceNode.items || sourceNode.subItems || sourceNode.subtasks || [];
                const movedCount = sourceChildren.length;

                // Determine which array to use on destination
                const destArray = destNode.items ? 'items' :
                                  destNode.children ? 'children' :
                                  destNode.subItems ? 'subItems' : 'items';

                if (!destNode[destArray]) destNode[destArray] = [];

                // Move children to destination
                sourceChildren.forEach(child => {
                    destNode[destArray].push(child);
                });

                // Clear source children
                if (sourceNode.children) sourceNode.children = [];
                if (sourceNode.items) sourceNode.items = [];
                if (sourceNode.subItems) sourceNode.subItems = [];
                if (sourceNode.subtasks) sourceNode.subtasks = [];

                // Also merge description if source has one and dest doesn't
                if (sourceNode.description && !destNode.description) {
                    destNode.description = sourceNode.description;
                } else if (sourceNode.description && destNode.description) {
                    destNode.description += '\n\n---\n[Merged from ' + sourceNode.name + ']\n' + sourceNode.description;
                }

                // Delete source node from its parent
                function removeFromParent(tree, nodeId) {
                    const arrays = ['children', 'items', 'subItems', 'subtasks'];
                    for (const arr of arrays) {
                        if (tree[arr]) {
                            const idx = tree[arr].findIndex(n => n.id === nodeId);
                            if (idx !== -1) {
                                tree[arr].splice(idx, 1);
                                return true;
                            }
                            for (const child of tree[arr]) {
                                if (removeFromParent(child, nodeId)) return true;
                            }
                        }
                    }
                    return false;
                }

                removeFromParent(capexTree, sourceNode.id);

                if (typeof render === 'function') render();

                return `âœ… Merged "${sourceNode.name}" into "${destNode.name}"\n` +
                       `â€¢ Moved ${movedCount} children\n` +
                       `â€¢ Source node deleted\n` +
                       `ğŸ’¡ Use \`undo\` to reverse this operation.`;
            },

            // BUILD 580: Bulk delete empty containers
            'delete_empty_nodes': (options) => {
                const emptyNodes = [];
                const keepTypes = (options || '').toLowerCase().includes('keep-subtasks') ? ['subtask'] : [];

                function findEmpty(node, parent = null) {
                    if (!node || node.id === capexTree.id) return;

                    const children = node.children || node.items || node.subItems || node.subtasks || [];
                    const hasChildren = children.length > 0;
                    const isLeaf = node.type === 'item' || node.type === 'subitem';
                    const nodeType = node.type || 'unknown';

                    // Empty container = not a leaf type, has no children
                    if (!isLeaf && !hasChildren && !keepTypes.includes(nodeType)) {
                        emptyNodes.push({ node, parent, type: nodeType });
                    }

                    // Recurse into children
                    children.forEach(child => findEmpty(child, node));
                }

                // Find all empty containers
                (capexTree.children || []).forEach(child => findEmpty(child, capexTree));
                (capexTree.items || []).forEach(child => findEmpty(child, capexTree));

                if (emptyNodes.length === 0) {
                    return 'âœ… No empty containers found!';
                }

                // Preview mode if "preview" option specified
                if ((options || '').toLowerCase().includes('preview')) {
                    const preview = emptyNodes.slice(0, 20).map((e, i) =>
                        `${i + 1}. **${e.node.name}** (${e.type})`
                    ).join('\n');
                    return `ğŸ“‹ **Preview: ${emptyNodes.length} empty containers to delete:**\n\n${preview}` +
                           (emptyNodes.length > 20 ? `\n... and ${emptyNodes.length - 20} more` : '') +
                           `\n\nğŸ’¡ Run \`delete_empty_nodes confirm\` to delete all.`;
                }

                // Require explicit confirm
                if (!(options || '').toLowerCase().includes('confirm')) {
                    return `âš ï¸ Found **${emptyNodes.length} empty containers**.\n\n` +
                           `â€¢ Run \`delete_empty_nodes preview\` to see the list\n` +
                           `â€¢ Run \`delete_empty_nodes confirm\` to delete all\n` +
                           `â€¢ Run \`delete_empty_nodes confirm keep-subtasks\` to preserve empty subtasks`;
                }

                // Save single undo state for all deletions
                if (typeof saveState === 'function') {
                    saveState(`Delete ${emptyNodes.length} empty containers`);
                }

                // Delete all empty nodes (in reverse order to handle nested empties)
                let deletedCount = 0;
                emptyNodes.reverse().forEach(({ node }) => {
                    if (typeof removeFromParent === 'function') {
                        removeFromParent(capexTree, node.id);
                        deletedCount++;
                    }
                });

                if (typeof render === 'function') render();

                return `ğŸ—‘ï¸ Deleted **${deletedCount} empty containers**!\n\nğŸ’¡ Use \`undo\` to restore them all.`;
            },

            'expand_all': () => {
                document.getElementById('expand-btn')?.click();
                return 'â¬‡ï¸ Expanded one level!';
            },
            'collapse_all': () => {
                document.getElementById('collapse-btn')?.click();
                return 'â¬†ï¸ Collapsed one level!';
            },
            'undo': () => {
                document.getElementById('undo-btn')?.click();
                return 'â†©ï¸ Undo complete!';
            },
            'redo': () => {
                document.getElementById('redo-btn')?.click();
                return 'â†ªï¸ Redo complete!';
            },

            // AI operations
            'enhance_selected': async () => {
                const selectedNodes = window.selectedCanvasNodes || [];
                if (selectedNodes.length === 0) {
                    return 'âš ï¸ No nodes selected. Select some items first!';
                }
                // Trigger enhance on selected
                if (typeof enhanceWithAI === 'function') {
                    await enhanceWithAI(selectedNodes);
                    return `âœ¨ Enhancing ${selectedNodes.length} selected item(s)...`;
                }
                return 'âŒ AI enhancement not available.';
            },

            // Help
            'show_help': () => {
                document.getElementById('how-to-btn')?.click();
                return 'ğŸ“– Opening help modal...';
            },

            // BUILD 582: Request capabilities from Claude Code via MCP
            'request_dev_help': async (request) => {
                if (!request || request.trim().length < 10) {
                    return 'âš ï¸ Usage: `request_dev_help {detailed description of capability needed}`\n\n' +
                           'Example: `request_dev_help I need a command to find all nodes with descriptions longer than 500 chars`';
                }

                // Check if MCP bridge is connected
                if (!window.mcpBridgeState?.client?.connected) {
                    return 'âŒ MCP Bridge not connected. Claude Code needs to be running with the bridge.\n\n' +
                           'ğŸ’¡ Start with: `node packages/treelisty-mcp-bridge/src/bridge.js`';
                }

                // Format as dev request task
                const task = {
                    type: 'dev_request',
                    source: 'treebeard',
                    priority: 'normal',
                    request: request.trim(),
                    context: {
                        currentBuild: window.TREELISTY_VERSION?.build || 'unknown',
                        timestamp: new Date().toISOString(),
                        treeInfo: {
                            name: capexTree?.name || 'unknown',
                            nodeCount: (function countNodes(n) {
                                let c = 1;
                                (n.children || n.items || []).forEach(ch => c += countNodes(ch));
                                return c;
                            })(capexTree)
                        }
                    }
                };

                try {
                    // Dispatch via MCP
                    await window.mcpBridgeState.client.dispatchTask(task);
                    return `ğŸ“¤ **Dev request sent to Claude Code!**\n\n` +
                           `**Request:** ${request.substring(0, 200)}${request.length > 200 ? '...' : ''}\n\n` +
                           `Claude Code will implement this and push a new build. Refresh to get the update.`;
                } catch (err) {
                    return `âŒ Failed to dispatch request: ${err.message}\n\n` +
                           `Try copying this to Claude Code manually:\n\`\`\`\n${request}\n\`\`\``;
                }
            },

            // BUILD 442: Research command - web search via Gemini
            'research': async (query) => {
                if (!query) return 'âš ï¸ Please specify what to research. Example: "research competitors to Notion"';
                const result = await handleResearchRequest(query);
                return result.message;
            },

            // BUILD 442/522: Add nodes from research results (improved placement)
            'add_research_nodes': (nodesJson) => {
                try {
                    const nodes = typeof nodesJson === 'string' ? JSON.parse(nodesJson) : nodesJson;
                    if (!nodes || nodes.length === 0) return 'âš ï¸ No nodes to add.';

                    const phases = capexTree?.children || capexTree?.phases || [];
                    if (phases.length === 0) return 'âš ï¸ No phases in tree. Add a phase first.';

                    // BUILD 522: Smart placement - use focused node's phase if available
                    let targetPhase = null;
                    let targetPhaseIndex = 0;

                    // Check if there's a focused node and find its parent phase
                    const focusedNode = window.chatFocusedNode;
                    if (focusedNode) {
                        // Find which phase contains this node
                        for (let i = 0; i < phases.length; i++) {
                            const phase = phases[i];
                            const items = phase.items || phase.children || phase.subItems || [];
                            if (items.some(item => item.id === focusedNode.id)) {
                                targetPhase = phase;
                                targetPhaseIndex = i;
                                break;
                            }
                            // Check subitems too
                            for (const item of items) {
                                const subItems = item.subItems || item.children || [];
                                if (subItems.some(sub => sub.id === focusedNode.id)) {
                                    targetPhase = phase;
                                    targetPhaseIndex = i;
                                    break;
                                }
                            }
                            if (targetPhase) break;
                        }
                    }

                    // Fallback to first phase
                    if (!targetPhase) {
                        targetPhase = phases[0];
                        targetPhaseIndex = 0;
                    }

                    const existingItems = targetPhase.items || targetPhase.children || [];

                    // Save undo state
                    if (typeof saveState === 'function') saveState('Add research nodes');

                    // Add each node with unique IDs
                    const timestamp = Date.now();
                    nodes.forEach((node, i) => {
                        const newItem = {
                            type: 'item',
                            id: `item-${targetPhaseIndex}-${timestamp}-${i}`,
                            name: node.name,
                            description: node.description || '',
                            notes: `Added from research: ${new Date().toISOString()}`,
                            icon: 'ğŸ”',
                            provenance: { source: 'research', timestamp: new Date().toISOString() }
                        };

                        if (!targetPhase.items) targetPhase.items = [];
                        targetPhase.items.push(newItem);

                        // Track node change for highlighting
                        if (typeof trackNodeChange === 'function') {
                            trackNodeChange(newItem.id, 'added');
                        }
                    });

                    // Re-render
                    if (typeof render === 'function') render();

                    const placement = focusedNode ? `near "${focusedNode.name}"` : '';
                    return `âœ… Added ${nodes.length} node${nodes.length > 1 ? 's' : ''} to "${targetPhase.name}"${placement ? ' ' + placement : ''}`;
                } catch (error) {
                    console.error('Error adding research nodes:', error);
                    return `âŒ Failed to add nodes: ${error.message}`;
                }
            },

            // BUILD 522: Research followup - prompt user for next research topic
            'research_followup': () => {
                return {
                    message: 'ğŸ” **Continue Researching**\n\nWhat would you like to explore next?\n\nTry:\nâ€¢ "research [topic]" for web search\nâ€¢ "find hyperedges" to analyze tree connections\nâ€¢ "what is [concept]" for quick lookups',
                    buttons: [
                        { label: 'ğŸŒ Web Research', action: 'prompt_research' },
                        { label: 'ğŸ”— Find Hyperedges', action: 'find_hyperedges' },
                        { label: 'ğŸ“Š Project Overview', action: 'project_info' }
                    ]
                };
            },

            // BUILD 522: Prompt for research topic
            'prompt_research': () => {
                const input = document.getElementById('chat-assistant-input');
                if (input) {
                    input.value = 'research ';
                    input.focus();
                    input.setSelectionRange(input.value.length, input.value.length);
                }
                return 'ğŸ’¡ Type your research topic after "research " and press Enter!';
            },

            // BUILD 437: List all available commands for Treebeard self-discovery
            // BUILD 543: List capabilities (simpler than 100+ commands)
            'list_capabilities': () => {
                let output = 'ğŸŒ³ **What I Can Do** (10 Capabilities):\n\n';

                for (const [name, cap] of Object.entries(CAPABILITIES)) {
                    const icon = {
                        navigate: 'ğŸ”', edit: 'âœï¸', view: 'ğŸ‘ï¸', transform: 'âœ¨',
                        plan: 'ğŸ“Š', sync: 'ğŸ”„', analyze: 'ğŸ“ˆ', organize: 'ğŸ“‚',
                        undo: 'â†©ï¸', help: 'â“'
                    }[name] || 'â€¢';
                    output += `${icon} **${name.charAt(0).toUpperCase() + name.slice(1)}** - ${cap.description}\n`;
                    output += `   _Try: "${cap.examples[0]}"_\n\n`;
                }

                output += `ğŸ’¡ Just describe what you want in natural language!`;
                return output;
            },

            // BUILD 586: Help TB discover new capabilities
            'whats_new': () => {
                const currentBuild = window.TREELISTY_VERSION?.build || 'unknown';
                return `ğŸ†• **What's New - Build ${currentBuild}**

**Build 596 - Command Execution Sequences:**
ğŸ“‹ EXACT step-by-step recipes for add/move/delete operations
ğŸ¯ ADD CHILD: 1) find_node â†’ 2) add_child â†’ 3) show_tree_structure
ğŸ“¦ ADD MULTIPLE: Focus parent ONCE, then add all children
âœ… No more "Please provide a name" errors!

**Build 595 - SHOW YOUR WORK Mandatory:**
ğŸ‘ï¸ MUST show tree structure after EVERY change
ğŸ“ Report: "Added X to Y. Parent now has N children."

**Build 594 - Intent Routing:**
ğŸ”€ Unknown commands auto-route to correct command
ğŸ“ "show_overview" â†’ project_info (no more "command not found"!)
ğŸ¯ Natural language command mapping

**Build 593 - Command Discovery:**
ğŸ” \`find_command:{what you want}\` - search by purpose
ğŸ“– Never guess command names - discover them first!

**Build 591 - Visual Feedback:**
ğŸ‘ï¸ Moved nodes highlight BLUE with pulse animation
ğŸ“ Auto-scroll to changed area after operations
ğŸ”” Toast notifications show actions being performed

**Build 590 - Follow-Through:**
âœ… COMPLETE actions immediately - don't stop at focus/select
âœ… NEVER wait for "and?" or "go ahead" - execute the full action
âœ… REPORT what changed after each action

**Build 589 - Proactive Behavior:**
ğŸ§  CRITICAL capability check - I now verify my tools before saying "I can't"
ğŸ“‹ COMPLEX TASKS sequence - analyze â†’ identify â†’ act â†’ verify
ğŸ”„ ERROR RECOVERY - try alternatives before asking for help

**Recent Capabilities (Builds 578-587):**

ğŸ“Š **Tree Analysis:**
â€¢ \`list_empty_nodes\` - Find containers with 0 children
â€¢ \`show_tree_structure {depth}\` - Hierarchical view with counts
â€¢ \`find_duplicates\` - Find nodes with identical names
â€¢ \`node_stats {name}\` - Detailed stats for any node
â€¢ \`analyze_balance\` - Show phase balance, find overloaded/empty sections

ğŸ”§ **Tree Manipulation:**
â€¢ \`delete_empty_nodes confirm\` - Bulk delete all empty containers
â€¢ \`rename_node {old} to {new}\` - Rename any node
â€¢ \`move_node {source} to {dest}\` - Relocate nodes
â€¢ \`merge_nodes {source} into {dest}\` - Combine nodes
â€¢ \`duplicate_node {name}\` - Create safety copy
â€¢ \`bulk_move {items} to {dest}\` - Move multiple items at once

ğŸ“– **Content Access:**
â€¢ \`read_node {name}\` - Read full content (no truncation)
â€¢ \`preview_node {name}\` - Quick preview with children
â€¢ \`compare_nodes {a} and {b}\` - Side-by-side comparison

ğŸ·ï¸ **Tagging:**
â€¢ \`tag_node {name} with {tags}\` - Add tags
â€¢ \`untag_node {name} remove {tags}\` - Remove tags
â€¢ \`search_tree #tagname\` - Search by tag
â€¢ \`list_tags\` - Show all tags with counts

ğŸ”— **Developer Channel:**
â€¢ \`request_dev_help {description}\` - Request new capabilities from Claude Code

ğŸ’¡ Run \`list_all_commands\` for the full list (100+ commands)`;
            },

            'list_all_commands': () => {
                const commands = Object.keys(COMMAND_REGISTRY).sort();
                const grouped = {
                    'View': commands.filter(c => c.includes('view') || c.includes('canvas') || c.includes('tree') || c.includes('3d')),
                    'Theme': commands.filter(c => c.includes('theme')),
                    'Layout': commands.filter(c => c.includes('layout')),
                    'Navigation': commands.filter(c => c.includes('find') || c.includes('focus') || c.includes('expand') || c.includes('collapse') || c.includes('search')),
                    'Edit': commands.filter(c => c.includes('add') || c.includes('delete') || c.includes('edit') || c.includes('set_field')),
                    'AI': commands.filter(c => c.includes('enhance') || c.includes('wizard') || c.includes('deep') || c.includes('suggest') || c.includes('redundan') || c.includes('debate')),
                    'Export': commands.filter(c => c.includes('export') || c.includes('save') || c.includes('share')),
                    'Import': commands.filter(c => c.includes('import') || c.includes('load')),
                    'LifeTree': commands.filter(c => c.includes('lifetree') || c.includes('birthday') || c.includes('biograph')),
                    'Philosophy': commands.filter(c => c.includes('refute') || c.includes('argument') || c.includes('dialogue') || c.includes('dialectic')),
                    'Sales': commands.filter(c => c.includes('pipeline') || c.includes('lead') || c.includes('qualify') || c.includes('followup')),
                    'Project': commands.filter(c => c.includes('project') || c.includes('undo') || c.includes('redo')),
                };

                let output = 'ğŸ“‹ **All Available Commands** (100+):\n\n';
                for (const [category, cmds] of Object.entries(grouped)) {
                    if (cmds.length > 0) {
                        output += `**${category}:** ${cmds.slice(0, 8).join(', ')}${cmds.length > 8 ? ` (+${cmds.length - 8} more)` : ''}\n`;
                    }
                }
                output += `\n**Total:** ${commands.length} commands\n\nğŸ’¡ **Simpler:** Try \`list_capabilities\` for a friendlier overview!`;
                return output;
            },

            // BUILD 593: Search commands by purpose/keyword
            'find_command': (query) => {
                if (!query) {
                    return 'âš ï¸ Usage: `find_command {what you want to do}`\nExample: `find_command show project info`';
                }
                const q = query.toLowerCase();
                const commands = Object.keys(COMMAND_REGISTRY);

                // Search by name match
                const nameMatches = commands.filter(c => c.toLowerCase().includes(q));

                // Search by keyword associations
                const keywords = {
                    'overview': ['project_info', 'tree_analysis', 'analyze_balance'],
                    'info': ['project_info', 'node_stats', 'preview_node', 'read_node'],
                    'show': ['project_info', 'show_tree_structure', 'preview_node', 'list_all_commands'],
                    'project': ['project_info', 'new_project', 'rename_root', 'create_tree'],
                    'move': ['move_node', 'bulk_move', 'reorder_node'],
                    'delete': ['delete_node', 'delete_empty_nodes', 'bulk_delete'],
                    'search': ['search_tree', 'find_node', 'find_duplicates', 'search'],
                    'structure': ['show_tree_structure', 'tree_analysis', 'analyze_balance'],
                    'empty': ['list_empty_nodes', 'delete_empty_nodes'],
                    'stats': ['node_stats', 'project_info', 'tree_analysis', 'analyze_balance'],
                    'help': ['whats_new', 'list_all_commands', 'find_command'],
                    'new': ['whats_new', 'add_node', 'add_child', 'add_phase', 'create_tree'],
                };

                let keywordMatches = [];
                for (const [kw, cmds] of Object.entries(keywords)) {
                    if (q.includes(kw)) {
                        keywordMatches = keywordMatches.concat(cmds);
                    }
                }

                const allMatches = [...new Set([...nameMatches, ...keywordMatches])];

                if (allMatches.length === 0) {
                    return `âŒ No commands found for "${query}"\n\nğŸ’¡ Try: \`list_all_commands\` to see everything`;
                }

                let output = `ğŸ” **Commands matching "${query}":**\n\n`;
                allMatches.slice(0, 10).forEach(cmd => {
                    output += `â€¢ \`${cmd}\`\n`;
                });
                if (allMatches.length > 10) {
                    output += `\n... and ${allMatches.length - 10} more`;
                }
                return output;
            },

            // Project operations
            'new_project': () => {
                document.getElementById('new-project-btn')?.click();
                return 'ğŸ†• New project dialog opened!';
            },
            'open_wizard': () => {
                document.getElementById('wizard-btn')?.click();
                return 'ğŸ§™ Build Wizard opened!';
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ADDITIONAL COMMANDS (Build 249)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // File operations
            'import_text': () => {
                document.getElementById('import-text-header-btn')?.click();
                return 'ğŸ“¥ Text import modal opened! Paste any text and AI will structure it.';
            },
            'load_json': () => {
                document.getElementById('load-json-btn')?.click();
                return 'ğŸ“‚ File picker opened! Select a TreeListy JSON file.';
            },
            'import_excel': () => {
                document.getElementById('excel-import-btn')?.click();
                return 'ğŸ“Š Excel import started! Select an Excel file to analyze.';
            },
            'share_url': () => {
                document.getElementById('share-btn')?.click();
                return 'ğŸ“¤ Generating shareable URL...';
            },
            'live_sync': () => {
                document.getElementById('live-sync-btn')?.click();
                return 'ğŸ”„ Firebase Live Sync modal opened!';
            },
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 522: SERVICE SYNC COMMANDS (MCP-based via Claude Chrome)
            // These dispatch tasks to Claude Code which uses Chrome to access services
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'sync_gmail': (options) => {
                if (!mcpBridgeState?.client?.isConnected) {
                    return {
                        message: 'ğŸ”´ **Not Connected to Claude Code**\n\nTo sync Gmail, you need Claude Code running with the TreeListy MCP bridge.\n\nClick "Connect" in the header or run `/mcp add treelisty` in Claude Code.',
                        buttons: [
                            { label: 'ğŸ”— Connect', action: 'show_mcp_connect' },
                            { label: 'ğŸ“‚ Import JSON (legacy)', action: 'load_json' }
                        ]
                    };
                }
                try {
                    mcpBridgeState.client.submitTask({
                        type: 'sync',
                        service: 'gmail',
                        options: { maxItems: 50, ...options },
                        targetPattern: 'gmail'
                    });
                    return 'ğŸ“§ **Gmail Sync Started**\n\nClaude Code is fetching your emails via Chrome.\nResults will appear in your Inbox for review.';
                } catch (e) {
                    return `âŒ Failed to start sync: ${e.message}`;
                }
            },

            'sync_drive': (options) => {
                if (!mcpBridgeState?.client?.isConnected) {
                    return {
                        message: 'ğŸ”´ **Not Connected to Claude Code**\n\nTo sync Drive, you need Claude Code running with the TreeListy MCP bridge.',
                        buttons: [
                            { label: 'ğŸ”— Connect', action: 'show_mcp_connect' },
                            { label: 'ğŸ“‚ Import JSON (legacy)', action: 'load_json' }
                        ]
                    };
                }
                try {
                    mcpBridgeState.client.submitTask({
                        type: 'sync',
                        service: 'drive',
                        options: { maxDepth: 3, ...options },
                        targetPattern: 'filesystem'
                    });
                    return 'ğŸ“ **Drive Sync Started**\n\nClaude Code is scanning your Google Drive via Chrome.\nResults will appear in your Inbox for review.';
                } catch (e) {
                    return `âŒ Failed to start sync: ${e.message}`;
                }
            },

            'sync_calendar': (options) => {
                if (!mcpBridgeState?.client?.isConnected) {
                    return {
                        message: 'ğŸ”´ **Not Connected to Claude Code**\n\nTo sync Calendar, you need Claude Code running with the TreeListy MCP bridge.',
                        buttons: [
                            { label: 'ğŸ”— Connect', action: 'show_mcp_connect' }
                        ]
                    };
                }
                try {
                    mcpBridgeState.client.submitTask({
                        type: 'sync',
                        service: 'calendar',
                        options: { days: 7, ...options },
                        targetPattern: 'generic'
                    });
                    return 'ğŸ“… **Calendar Sync Started**\n\nClaude Code is fetching your calendar events via Chrome.\nResults will appear in your Inbox for review.';
                } catch (e) {
                    return `âŒ Failed to start sync: ${e.message}`;
                }
            },

            'sync_all': () => {
                if (!mcpBridgeState?.client?.isConnected) {
                    return {
                        message: 'ğŸ”´ **Not Connected to Claude Code**\n\nTo sync services, connect to Claude Code first.',
                        buttons: [{ label: 'ğŸ”— Connect', action: 'show_mcp_connect' }]
                    };
                }
                try {
                    ['gmail', 'drive', 'calendar'].forEach(service => {
                        mcpBridgeState.client.submitTask({
                            type: 'sync',
                            service,
                            options: {}
                        });
                    });
                    return 'ğŸ”„ **Syncing All Services**\n\nGmail, Drive, and Calendar sync started.\nResults will appear in your Inbox.';
                } catch (e) {
                    return `âŒ Failed to start sync: ${e.message}`;
                }
            },

            'show_mcp_connect': () => {
                if (typeof showMCPConnectModal === 'function') {
                    showMCPConnectModal();
                    return null;
                }
                return 'âš ï¸ MCP connect modal not available.';
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 604: dispatch_task - General-purpose task dispatch to Claude Code
            // Usage: "dispatch: <your task>" sends any task to Claude Code
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            'dispatch_task': (taskPrompt) => {
                if (!taskPrompt || taskPrompt.trim().length === 0) {
                    return {
                        message: 'ğŸ“¤ **Dispatch Task to Claude Code**\n\nUsage: `dispatch: <your task>`\n\nExamples:\nâ€¢ `dispatch: research Napoleon for my history tree`\nâ€¢ `dispatch: find all PDF files in my Downloads folder`\nâ€¢ `dispatch: create a summary of the current tree`',
                        buttons: null
                    };
                }

                if (!mcpBridgeState?.client?.isConnected) {
                    return {
                        message: 'ğŸ”´ **Not Connected to Claude Code**\n\nTo dispatch tasks, you need Claude Code running with the TreeListy MCP bridge.\n\nClick "Connect" in the header or run `/mcp add treelisty` in Claude Code.',
                        buttons: [
                            { label: 'ğŸ”— Connect', action: 'show_mcp_connect' }
                        ]
                    };
                }

                const selectedNode = typeof getSelectedNode === 'function' ? getSelectedNode() : activeNode;
                const treeContext = {
                    treeName: capexTree?.name || 'Untitled',
                    pattern: currentPattern || 'generic',
                    nodeCount: typeof countNodes === 'function' ? countNodes() : 0,
                    selectedNode: selectedNode ? { id: selectedNode.id, name: selectedNode.name } : null
                };

                try {
                    mcpBridgeState.client.submitTask({
                        type: 'dispatch',
                        agentId: 'general',
                        prompt: taskPrompt,
                        targetNodeId: selectedNode?.id,
                        treeContext: treeContext,
                        requestedCapabilities: ['webSearch', 'fileRead', 'treeWrite'],
                        options: { source: 'fast-path' }
                    });

                    showToast('ğŸ“¤ Task dispatched to Claude Code', 'success');
                    return `ğŸ“¤ **Task Dispatched**\n\n"${taskPrompt.substring(0, 100)}${taskPrompt.length > 100 ? '...' : ''}"\n\nClaude Code is working on this. Results will appear in your **Inbox** for review.`;
                } catch (e) {
                    console.error('[dispatch_task] Error:', e);
                    return `âŒ Failed to dispatch task: ${e.message}`;
                }
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 574: Deep Research via Claude Code
            // Dispatches research tasks to Claude Code for web search + integration
            // Bypasses fragile local Gemini filters that block on TreeListy terms
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'deep_research': (query) => {
                if (!mcpBridgeState?.client?.isConnected) {
                    return {
                        message: 'ğŸ”´ **Not Connected to Claude Code**\n\nDeep research requires Claude Code running with the TreeListy MCP bridge.\n\nThis dispatches your research request to Claude Code, which uses web search and can create proposed nodes for your tree.',
                        buttons: [
                            { label: 'ğŸ”— Connect', action: 'show_mcp_connect' },
                            { label: 'ğŸ” Local Research (Gemini)', action: `research:${query}` }
                        ]
                    };
                }

                // Build tree context for Claude Code
                const treeOutline = getTreeOutlineForResearch(capexTree, 2);
                const targetNode = activeNode || capexTree;

                try {
                    mcpBridgeState.client.submitTask({
                        type: 'research',
                        query: query,
                        context: {
                            treeName: capexTree.name,
                            treeId: capexTree.treeId || 'unknown',
                            pattern: capexTree.pattern?.key || 'generic',
                            targetNodeId: targetNode.id,
                            targetNodeName: targetNode.name,
                            treeOutline: treeOutline,
                            instructions: `Research "${query}" using web search. Create proposed nodes that integrate well with the existing tree structure. Return results as proposed_ops with create_node operations. Each node should have: name, description, and relevant pattern fields. Place nodes under "${targetNode.name}" or suggest appropriate locations based on the tree outline.`
                        }
                    });

                    return {
                        message: `ğŸ”¬ **Deep Research Started**\n\n**Query:** ${query}\n**Target:** ${targetNode.name}\n\nClaude Code is researching with web search.\nProposed nodes will appear in your **Inbox** for review.`,
                        buttons: [
                            { label: 'ğŸ“¥ View Inbox', action: 'show_inbox' }
                        ]
                    };
                } catch (e) {
                    console.error('[deep_research] Failed:', e);
                    return `âŒ Failed to start research: ${e.message}`;
                }
            },

            // Legacy aliases for backwards compatibility
            'refresh_drive': () => COMMAND_REGISTRY['sync_drive'](),
            'refresh_gmail': () => COMMAND_REGISTRY['sync_gmail'](),

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 564: Chrome Extension Screen Awareness Commands
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'capture_screen': async () => {
                if (!mcpBridgeState?.client?.isConnected) {
                    return {
                        message: 'ğŸ”´ **Not Connected**\n\nTo capture screen, connect to the MCP Bridge first.',
                        buttons: [{ label: 'ğŸ”— Connect', action: 'show_mcp_connect' }]
                    };
                }

                // Check extension status first
                const statusResult = await sendExtensionRequest('get_status', {});
                if (!statusResult?.connected) {
                    return {
                        message: 'ğŸ“· **Chrome Extension Not Connected**\n\nInstall the TreeListy Screen Awareness extension and configure the pairing token.',
                        buttons: [
                            { label: 'ğŸ“– Setup Guide', action: 'show_extension_help' }
                        ]
                    };
                }

                // Request capture
                addMessage('ğŸ“· Capturing screen...', 'system');
                const result = await sendExtensionRequest('capture_screen', {});

                if (result?.success && result?.screenshot) {
                    // Display screenshot in chat
                    displayScreenshotInChat(result.screenshot, result.provenance);

                    // Store for optional vision analysis
                    window._lastScreenCapture = result;

                    return `ğŸ“· **Captured:** ${result.provenance?.domain || 'Unknown'}\n\n[ğŸ” Analyze with Vision](#analyze-screenshot)`;
                }

                return `âŒ Capture failed: ${result?.error || 'Unknown error'}`;
            },

            'extract_page': async () => {
                if (!mcpBridgeState?.client?.isConnected) {
                    return 'ğŸ”´ Not connected. Connect to MCP Bridge first.';
                }

                addMessage('ğŸ“„ Extracting page content...', 'system');
                const result = await sendExtensionRequest('extract_dom', {});

                if (result?.success && result?.domText) {
                    // Store for context
                    window._lastPageContent = result;

                    const preview = result.domText.slice(0, 500) + (result.domText.length > 500 ? '...' : '');
                    return `ğŸ“„ **Extracted:** ${result.provenance?.domain || 'Unknown'}\n\n**Preview:**\n\`\`\`\n${preview}\n\`\`\`\n\n*${result.provenance?.charCount || 0} characters total*`;
                }

                return `âŒ Extraction failed: ${result?.error || 'Unknown error'}`;
            },

            'list_tabs': async () => {
                if (!mcpBridgeState?.client?.isConnected) {
                    return 'ğŸ”´ Not connected. Connect to MCP Bridge first.';
                }

                const result = await sendExtensionRequest('list_tabs', {});

                if (result?.success && result?.tabs) {
                    const tabList = result.tabs.map(t =>
                        `- ${t.active ? '**' : ''}${t.title}${t.active ? '**' : ''} (${t.domain})`
                    ).join('\n');
                    return `ğŸ—‚ï¸ **Open Tabs (${result.count}):**\n\n${tabList}`;
                }

                return `âŒ Failed to list tabs: ${result?.error || 'Unknown error'}`;
            },

            'extension_status': async () => {
                if (!mcpBridgeState?.client?.isConnected) {
                    return 'ğŸ”´ MCP Bridge not connected.';
                }

                const result = await sendExtensionRequest('get_status', {});

                if (result?.connected) {
                    const clients = result.clients.map(c =>
                        `- ${c.clientId}: ${c.capabilities.join(', ')}`
                    ).join('\n');
                    return `âœ… **Extension Connected**\n\n**Clients:**\n${clients}`;
                }

                return 'ğŸ“· Chrome extension not connected. Install TreeListy Screen Awareness extension.';
            },

            'show_extension_help': () => {
                const helpText = `
## TreeListy Screen Awareness Extension

### Installation
1. Download the extension from \`packages/treelisty-chrome-extension\`
2. Go to \`chrome://extensions\`
3. Enable "Developer mode"
4. Click "Load unpacked" and select the extension folder

### Configuration
1. Click the extension icon in Chrome
2. Right-click â†’ Options
3. Enter the pairing token (shown in MCP Bridge console)
4. Click "Save Settings"

### Commands
- \`capture_screen\` - Take screenshot of current tab
- \`extract_page\` - Get text content from page
- \`list_tabs\` - Show open browser tabs
- \`extension_status\` - Check connection status
- \`analyze_image\` - Decompose screenshot into tree with bounding boxes
`;
                return helpText;
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 565: Image Analysis - Decompose images into tree structure
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'analyze_image': async () => {
                // Check if we have a recent screenshot
                if (!window._lastScreenCapture?.screenshot) {
                    // Try to capture first
                    if (mcpBridgeState?.client?.isConnected) {
                        addMessage('ğŸ“· Capturing screen first...', 'system');
                        const statusResult = await sendExtensionRequest('get_status', {});
                        if (statusResult?.connected) {
                            const captureResult = await sendExtensionRequest('capture_screen', {});
                            if (captureResult?.success && captureResult?.screenshot) {
                                window._lastScreenCapture = captureResult;
                                displayScreenshotInChat(captureResult.screenshot, captureResult.provenance);
                            }
                        }
                    }
                }

                if (!window._lastScreenCapture?.screenshot) {
                    return {
                        message: 'ğŸ“· **No Screenshot Available**\n\nCapture a screenshot first, then analyze it.',
                        buttons: [
                            { label: 'ğŸ“· Capture Screen', action: 'capture_screen' }
                        ]
                    };
                }

                // Check for Gemini API key
                const geminiKey = localStorage.getItem('gemini_api_key');
                if (!geminiKey) {
                    return {
                        message: 'ğŸ”‘ **Gemini API Key Required**\n\nImage analysis uses Gemini Vision. Please set your API key in Settings.',
                        buttons: [
                            { label: 'âš™ï¸ Open Settings', action: 'show_settings' }
                        ]
                    };
                }

                // Perform the analysis
                try {
                    await importImageAnalysisTree(window._lastScreenCapture.screenshot);
                    return 'âœ… Image analysis complete! Switch to Canvas view to see bounding boxes.';
                } catch (err) {
                    return `âŒ Analysis failed: ${err?.message || 'Unknown error'}`;
                }
            },

            // Aliases for analyze_image
            'analyze': () => COMMAND_REGISTRY['analyze_image'](),
            'analyze_screenshot': () => COMMAND_REGISTRY['analyze_image'](),
            'image_to_tree': () => COMMAND_REGISTRY['analyze_image'](),
            'decompose_image': () => COMMAND_REGISTRY['analyze_image'](),

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 560: Gmail Single-Email Commands (for focused node)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Helper: Get focused email node
            '_get_focused_email': () => {
                if (!activeNode) return null;
                // Check if activeNode is an email (has threadId)
                if (activeNode.threadId) return activeNode;
                // Check if it's a message within a thread
                if (activeNode.type === 'subtask' && activeNode.fullBody) {
                    // Find parent thread
                    const parent = findParentNode(activeNode);
                    if (parent?.threadId) return parent;
                }
                return null;
            },

            // Gmail Archive (single email)
            'gmail_archive': async () => {
                const email = COMMAND_REGISTRY['_get_focused_email']();
                if (!email) {
                    return 'ğŸ“­ No email focused. Use `find_node` to select an email first.';
                }
                if (!isMCPBridgeConnected()) {
                    return 'ğŸ”´ MCP Bridge not connected. Start the bridge to use Gmail actions.';
                }
                if (typeof gmailSyncArchive === 'function') {
                    gmailSyncArchive(email.threadId, email.id, null);
                    return `ğŸ“¥ Archiving "${email.name}"... (10s undo window)`;
                }
                return 'âŒ Gmail sync not available.';
            },

            'gmail_unarchive': async () => {
                const email = COMMAND_REGISTRY['_get_focused_email']();
                if (!email) return 'ğŸ“­ No email focused. Use `find_node` to select an email first.';
                if (!isMCPBridgeConnected()) return 'ğŸ”´ MCP Bridge not connected.';
                try {
                    const result = await sendGmailAction('gmail_unarchive', { thread_id: email.threadId });
                    if (result?.success) {
                        return `ğŸ“¬ "${email.name}" moved back to inbox!`;
                    }
                    return `âŒ Failed: ${result?.error || 'Unknown error'}`;
                } catch (e) {
                    return `âŒ Error: ${e.message}`;
                }
            },

            'gmail_trash': async () => {
                const email = COMMAND_REGISTRY['_get_focused_email']();
                if (!email) return 'ğŸ“­ No email focused. Use `find_node` to select an email first.';
                if (!isMCPBridgeConnected()) return 'ğŸ”´ MCP Bridge not connected.';
                if (typeof gmailSyncTrash === 'function') {
                    gmailSyncTrash(email.threadId, email.id, null);
                    return `ğŸ—‘ï¸ Trashing "${email.name}"... (10s undo window, 30-day recovery)`;
                }
                return 'âŒ Gmail sync not available.';
            },

            'gmail_star': async () => {
                const email = COMMAND_REGISTRY['_get_focused_email']();
                if (!email) return 'ğŸ“­ No email focused. Use `find_node` to select an email first.';
                if (!isMCPBridgeConnected()) return 'ğŸ”´ MCP Bridge not connected.';
                if (typeof gmailSyncStar === 'function') {
                    gmailSyncStar(email.threadId, email.id, null);
                    return `â­ Starring "${email.name}"...`;
                }
                return 'âŒ Gmail sync not available.';
            },

            'gmail_unstar': async () => {
                const email = COMMAND_REGISTRY['_get_focused_email']();
                if (!email) return 'ğŸ“­ No email focused. Use `find_node` to select an email first.';
                if (!isMCPBridgeConnected()) return 'ğŸ”´ MCP Bridge not connected.';
                try {
                    const result = await sendGmailAction('gmail_unstar', { thread_id: email.threadId });
                    if (result?.success) {
                        return `â˜† Star removed from "${email.name}"`;
                    }
                    return `âŒ Failed: ${result?.error || 'Unknown error'}`;
                } catch (e) {
                    return `âŒ Error: ${e.message}`;
                }
            },

            'gmail_mark_read': async () => {
                const email = COMMAND_REGISTRY['_get_focused_email']();
                if (!email) return 'ğŸ“­ No email focused. Use `find_node` to select an email first.';
                if (!isMCPBridgeConnected()) return 'ğŸ”´ MCP Bridge not connected.';
                if (typeof gmailSyncMarkRead === 'function') {
                    gmailSyncMarkRead(email.threadId, email.id, null);
                    return `âœ“ Marking "${email.name}" as read...`;
                }
                return 'âŒ Gmail sync not available.';
            },

            'gmail_mark_unread': async () => {
                const email = COMMAND_REGISTRY['_get_focused_email']();
                if (!email) return 'ğŸ“­ No email focused. Use `find_node` to select an email first.';
                if (!isMCPBridgeConnected()) return 'ğŸ”´ MCP Bridge not connected.';
                try {
                    const result = await sendGmailAction('gmail_mark_unread', { thread_id: email.threadId });
                    if (result?.success) {
                        return `ğŸ“© "${email.name}" marked as unread`;
                    }
                    return `âŒ Failed: ${result?.error || 'Unknown error'}`;
                } catch (e) {
                    return `âŒ Error: ${e.message}`;
                }
            },

            'gmail_open': () => {
                const email = COMMAND_REGISTRY['_get_focused_email']();
                if (!email) return 'ğŸ“­ No email focused. Use `find_node` to select an email first.';
                if (!email.threadId) return 'âŒ This node is not a Gmail email.';
                window.open(`https://mail.google.com/mail/u/0/#inbox/${email.threadId}`, '_blank');
                return `ğŸ”— Opened "${email.name}" in Gmail`;
            },

            'gmail_reply': () => {
                const email = COMMAND_REGISTRY['_get_focused_email']();
                if (!email) return 'ğŸ“­ No email focused. Use `find_node` to select an email first.';
                if (typeof emailReaderReplyFromNode === 'function') {
                    emailReaderReplyFromNode(email);
                    return null; // Compose modal handles the UI
                }
                return 'âŒ Reply function not available.';
            },

            'gmail_forward': () => {
                const email = COMMAND_REGISTRY['_get_focused_email']();
                if (!email) return 'ğŸ“­ No email focused. Use `find_node` to select an email first.';
                if (typeof emailReaderForwardFromNode === 'function') {
                    emailReaderForwardFromNode(email);
                    return null; // Compose modal handles the UI
                }
                return 'âŒ Forward function not available.';
            },

            // Triage summary - analyze inbox
            'gmail_triage_summary': async () => {
                const getAllNodesFlat = COMMAND_REGISTRY['_getAllNodesFlat'];
                const allNodes = getAllNodesFlat();
                const emailNodes = allNodes.filter(n => n.threadId);

                if (emailNodes.length === 0) {
                    return 'ğŸ“­ No Gmail threads found. Import a Gmail JSON first.';
                }

                // Categorize emails
                const unread = emailNodes.filter(n => n.unread || n.labels?.includes('UNREAD'));
                const starred = emailNodes.filter(n => n.starred || n.labels?.includes('STARRED'));
                const important = emailNodes.filter(n => n.labels?.includes('IMPORTANT'));
                const inbox = emailNodes.filter(n => n.labels?.includes('INBOX'));
                const needsReply = emailNodes.filter(n => {
                    // Emails from others (not sent by me) that are unread or starred
                    const fromMe = n.labels?.includes('SENT') || n.senderEmail?.includes('garnet');
                    return !fromMe && (n.unread || n.starred);
                });

                let summary = `ğŸ“Š **Gmail Triage Summary**\n\n`;
                summary += `ğŸ“¬ Total threads: **${emailNodes.length}**\n`;
                summary += `ğŸ“¥ In inbox: **${inbox.length}**\n`;
                summary += `ğŸ“© Unread: **${unread.length}**\n`;
                summary += `â­ Starred: **${starred.length}**\n`;
                summary += `ğŸ”´ Important: **${important.length}**\n`;
                summary += `â†©ï¸ May need reply: **${needsReply.length}**\n`;

                if (needsReply.length > 0) {
                    summary += `\n**Likely needs attention:**\n`;
                    needsReply.slice(0, 5).forEach(e => {
                        summary += `â€¢ ${e.senderEmail?.split('<')[0] || 'Unknown'}: ${e.name?.substring(0, 40)}...\n`;
                    });
                }

                return {
                    message: summary,
                    buttons: [
                        { label: 'ğŸ“¥ Batch Archive Read', action: 'gmail_batch_archive:read' },
                        { label: 'â­ Show Starred', action: 'find_node:starred' }
                    ]
                };
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 552: Gmail Batch Commands (Phase 3)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Helper: Find email nodes matching criteria
            '_gmail_find_emails': (criteria) => {
                const getAllNodesFlat = COMMAND_REGISTRY['_getAllNodesFlat'];
                const allNodes = getAllNodesFlat();
                const emailNodes = allNodes.filter(n => n.threadId);

                if (!criteria || criteria === 'all') return emailNodes;

                const lowerCriteria = criteria.toLowerCase();

                // Filter by various criteria
                return emailNodes.filter(n => {
                    // By folder/phase
                    if (lowerCriteria.includes('inbox') && n.parent?.name?.toLowerCase()?.includes('inbox')) return true;
                    if (lowerCriteria.includes('done') && (n.status === 'completed' || n.parent?.name?.toLowerCase()?.includes('done'))) return true;
                    if (lowerCriteria.includes('archived') && n._gmailSynced === 'archived') return true;

                    // By sender
                    if (n.senderEmail?.toLowerCase()?.includes(lowerCriteria)) return true;

                    // By subject
                    if (n.name?.toLowerCase()?.includes(lowerCriteria)) return true;

                    // By read status
                    if (lowerCriteria.includes('unread') && n.unread) return true;
                    if (lowerCriteria.includes('read') && !lowerCriteria.includes('unread') && !n.unread) return true;

                    // By starred status
                    if (lowerCriteria.includes('starred') && n.starred) return true;

                    return false;
                });
            },

            // Archive batch of emails
            'gmail_batch_archive': async (criteria) => {
                if (!isMCPBridgeConnected()) {
                    return {
                        message: 'ğŸ”´ **Not Connected to MCP Bridge**\n\nStart the bridge and reconnect to use Gmail batch commands.',
                        buttons: [{ label: 'ğŸ”Œ Connect', action: 'show_mcp_connect' }]
                    };
                }

                const emails = COMMAND_REGISTRY['_gmail_find_emails'](criteria);
                if (emails.length === 0) {
                    return `ğŸ“­ No emails found matching "${criteria || 'all'}"`;
                }

                // Store for batch preview
                window.pendingBatchAction = {
                    action: 'archive',
                    emails,
                    criteria
                };

                // Show preview modal
                showBatchPreviewModal('archive', emails);

                return {
                    message: `ğŸ“§ Found **${emails.length} emails** matching "${criteria || 'all'}".\n\nReview in the preview modal before proceeding.`,
                    buttons: null
                };
            },

            // Trash batch of emails
            'gmail_batch_trash': async (criteria) => {
                if (!isMCPBridgeConnected()) {
                    return {
                        message: 'ğŸ”´ **Not Connected to MCP Bridge**',
                        buttons: [{ label: 'ğŸ”Œ Connect', action: 'show_mcp_connect' }]
                    };
                }

                const emails = COMMAND_REGISTRY['_gmail_find_emails'](criteria);
                if (emails.length === 0) {
                    return `ğŸ“­ No emails found matching "${criteria || 'all'}"`;
                }

                window.pendingBatchAction = {
                    action: 'trash',
                    emails,
                    criteria
                };

                showBatchPreviewModal('trash', emails);

                return {
                    message: `ğŸ—‘ï¸ Found **${emails.length} emails** to trash.\n\nâš ï¸ This moves them to Gmail Trash (recoverable for 30 days).`,
                    buttons: null
                };
            },

            // Star batch of emails
            'gmail_batch_star': async (criteria) => {
                if (!isMCPBridgeConnected()) {
                    return {
                        message: 'ğŸ”´ **Not Connected to MCP Bridge**',
                        buttons: [{ label: 'ğŸ”Œ Connect', action: 'show_mcp_connect' }]
                    };
                }

                const emails = COMMAND_REGISTRY['_gmail_find_emails'](criteria);
                if (emails.length === 0) {
                    return `ğŸ“­ No emails found matching "${criteria || 'all'}"`;
                }

                window.pendingBatchAction = {
                    action: 'star',
                    emails,
                    criteria
                };

                showBatchPreviewModal('star', emails);

                return {
                    message: `â­ Found **${emails.length} emails** to star.`,
                    buttons: null
                };
            },

            // Mark read batch of emails
            'gmail_batch_mark_read': async (criteria) => {
                if (!isMCPBridgeConnected()) {
                    return {
                        message: 'ğŸ”´ **Not Connected to MCP Bridge**',
                        buttons: [{ label: 'ğŸ”Œ Connect', action: 'show_mcp_connect' }]
                    };
                }

                const emails = COMMAND_REGISTRY['_gmail_find_emails'](criteria);
                if (emails.length === 0) {
                    return `ğŸ“­ No emails found matching "${criteria || 'all'}"`;
                }

                window.pendingBatchAction = {
                    action: 'mark_read',
                    emails,
                    criteria
                };

                showBatchPreviewModal('mark_read', emails);

                return {
                    message: `âœ“ Found **${emails.length} emails** to mark as read.`,
                    buttons: null
                };
            },

            // Natural language aliases
            'archive_emails': (criteria) => COMMAND_REGISTRY['gmail_batch_archive'](criteria),
            'trash_emails': (criteria) => COMMAND_REGISTRY['gmail_batch_trash'](criteria),
            'star_emails': (criteria) => COMMAND_REGISTRY['gmail_batch_star'](criteria),
            'mark_emails_read': (criteria) => COMMAND_REGISTRY['gmail_batch_mark_read'](criteria),

            // BUILD 527: Helper to get all nodes as flat array
            '_getAllNodesFlat': () => {
                const nodes = [];
                const traverse = (node) => {
                    if (!node) return;
                    nodes.push(node);
                    (node.children || []).forEach(traverse);
                    (node.items || []).forEach(traverse);
                    (node.subtasks || []).forEach(traverse);
                    (node.subItems || []).forEach(traverse);
                };
                traverse(capexTree);
                return nodes;
            },

            // BUILD 526: Open file URL (for filesystem pattern) - enhanced for Google native formats
            'open_file': (fileName) => {
                // Use internal helper
                const getAllNodesFlat = COMMAND_REGISTRY['_getAllNodesFlat'];

                // Helper: Check if file is Google native format
                const isGoogleNative = (node) => {
                    const ext = node.fileExtension?.toLowerCase() || '';
                    const mime = node.mimeType || '';
                    return ['.gdoc', '.gsheet', '.gslides', '.gform', '.gdraw'].includes(ext) ||
                           mime.includes('vnd.google-apps.');
                };

                // Helper: Try to open a node
                const tryOpenNode = (node) => {
                    // 1. Check for web URL first (Google Drive API export)
                    if (node.fileUrl && node.fileUrl.startsWith('http')) {
                        window.open(node.fileUrl, '_blank');
                        return { success: true, message: `ğŸ“‚ Opening "${node.name}" in browser...` };
                    }

                    // 2. Check if it's a Google native format without webViewLink
                    if (isGoogleNative(node)) {
                        // BUILD 528: If MCP connected, offer to open via Claude Chrome
                        const mcpConnected = mcpBridgeState?.client?.isConnected;
                        const cleanName = node.name.replace(/\.(gdoc|gsheet|gslides|gform|gdraw)$/i, '');

                        if (mcpConnected) {
                            return {
                                success: false,
                                message: `ğŸ“„ **"${node.name}"** is a Google ${node.fileExtension?.slice(1) || 'Workspace'} file.\n\nClaude Code can open this via Chrome:`,
                                buttons: [
                                    { label: 'ğŸš€ Open via Claude Chrome', action: `open_gdrive_via_mcp:${cleanName}` },
                                    { label: 'ğŸ”— Open Google Drive', action: 'open_file_url:https://drive.google.com' },
                                    { label: 'ğŸ“‹ Copy File Name', action: `copy_text:${cleanName}` }
                                ]
                            };
                        }

                        return {
                            success: false,
                            message: `âš ï¸ **Cannot Open Google File Directly**\n\n"${node.name}" is a Google ${node.fileExtension?.slice(1) || 'Workspace'} file.\n\nTo open these files:\nâ€¢ Connect to Claude Code (MCP) for Chrome-based opening\nâ€¢ Or use Google Drive in your browser\n\n*Local Drive sync files don't include web URLs.*`,
                            buttons: [
                                { label: 'ğŸ”Œ Connect Claude Code', action: 'show_mcp_connect' },
                                { label: 'ğŸ”— Open Google Drive', action: 'open_file_url:https://drive.google.com' },
                                { label: 'ğŸ“‹ Copy File Name', action: `copy_text:${cleanName}` }
                            ]
                        };
                    }

                    // 3. Check for local file path
                    if (node.filePath) {
                        // Convert Windows path to file:// URL
                        let fileUrl = node.filePath;
                        if (fileUrl.match(/^[A-Za-z]:\\/)) {
                            // Windows path: C:\path\file.txt -> file:///C:/path/file.txt
                            fileUrl = 'file:///' + fileUrl.replace(/\\/g, '/');
                        } else if (fileUrl.startsWith('/')) {
                            // Unix path
                            fileUrl = 'file://' + fileUrl;
                        }
                        window.open(fileUrl, '_blank');
                        return { success: true, message: `ğŸ“‚ Opening "${node.name}" from local drive...` };
                    }

                    return { success: false, message: `âš ï¸ No URL or path available for "${node.name}".` };
                };

                if (!fileName) {
                    // Try to open focused node
                    const node = window.chatFocusedNode || activeNode;
                    if (!node) {
                        return 'âš ï¸ No file selected. Focus on a file first or specify: "open file [name]"';
                    }
                    const result = tryOpenNode(node);
                    return result.buttons ? result : result.message;
                }

                // Search for file by name (include nodes with fileUrl OR filePath)
                const allNodes = getAllNodesFlat();
                const matches = allNodes.filter(n =>
                    n.name?.toLowerCase().includes(fileName.toLowerCase()) &&
                    (n.fileUrl || n.filePath || isGoogleNative(n))
                );

                if (matches.length === 0) {
                    return `âš ï¸ No file found matching "${fileName}".`;
                }
                if (matches.length === 1) {
                    const result = tryOpenNode(matches[0]);
                    return result.buttons ? result : result.message;
                }

                // Multiple matches - show selection
                return {
                    message: `ğŸ“‚ Found ${matches.length} files matching "${fileName}":\n\n${matches.slice(0, 5).map((m, i) => `${i+1}. ${m.name}${isGoogleNative(m) ? ' â˜ï¸' : ''}`).join('\n')}`,
                    buttons: matches.slice(0, 3).map(m => ({
                        label: `ğŸ“„ ${m.name.slice(0, 20)}${isGoogleNative(m) ? 'â˜ï¸' : ''}`,
                        action: `open_file_direct:${m.id}`
                    }))
                };
            },

            // BUILD 526: Open file by node ID (handles all file types)
            'open_file_direct': (nodeId) => {
                const allNodes = COMMAND_REGISTRY['_getAllNodesFlat']();
                const node = allNodes.find(n => n.id === nodeId);
                if (!node) return 'âš ï¸ File not found.';

                // Use the same logic as open_file
                return COMMAND_REGISTRY['open_file'](node.name);
            },

            // BUILD 522: Direct URL opener
            'open_file_url': (url) => {
                if (url) {
                    window.open(url, '_blank');
                    return 'ğŸ“‚ Opening...';
                }
                return 'âš ï¸ No URL provided.';
            },

            // BUILD 526: Copy text to clipboard
            'copy_text': (text) => {
                if (text) {
                    navigator.clipboard.writeText(text);
                    return 'ğŸ“‹ Copied to clipboard!';
                }
                return 'âš ï¸ Nothing to copy.';
            },

            // BUILD 528: Open Google Drive file via MCP/Claude Chrome
            'open_gdrive_via_mcp': (fileName) => {
                if (!mcpBridgeState?.client?.isConnected) {
                    return {
                        message: 'ğŸ”´ **Not Connected to Claude Code**\n\nConnect first to use Chrome-based file opening.',
                        buttons: [
                            { label: 'ğŸ”Œ Connect', action: 'show_mcp_connect' }
                        ]
                    };
                }

                // Dispatch task to Claude Code to open the file via Chrome
                mcpBridgeState.client.submitTask({
                    type: 'open_gdrive_file',
                    fileName: fileName,
                    instructions: `Open Google Drive in Chrome, search for "${fileName}", and open the first matching result. Leave the browser window open for the user.`
                });

                return `ğŸš€ **Opening via Claude Chrome...**\n\nClaude Code is searching Google Drive for "${fileName}" and will open it in your browser.`;
            },

            // BUILD 528: Show MCP connection instructions
            'show_mcp_connect': () => {
                return {
                    message: `ğŸ”Œ **Connect to Claude Code**\n\nTo enable Chrome-based file opening:\n\n1. Open Claude Code CLI\n2. Run: \`/mcp add treelisty\`\n3. Click "Connect" in TreeListy header\n\nThis lets TreeListy dispatch tasks to Claude Code, which can then use the Chrome extension to interact with Google Drive, Gmail, and other web services.`,
                    buttons: [
                        { label: 'ğŸ“– MCP Setup Guide', action: 'open_file_url:https://docs.anthropic.com/en/docs/claude-code/mcp' }
                    ]
                };
            },

            // Search
            'search': () => {
                document.getElementById('search-btn')?.click();
                return 'ğŸ” Search modal opened! Type to search all fields.';
            },

            // Settings
            'open_settings': () => {
                document.getElementById('api-key-btn')?.click();
                return 'ğŸ”‘ API settings opened! Configure your AI provider keys.';
            },

            // AI operations
            'generate_image': () => {
                // Need to trigger Imagen modal - check if nodes selected
                const selectedNodes = window.selectedCanvasNodes || [];
                if (selectedNodes.length === 0) {
                    return 'âš ï¸ Select some nodes first, then ask me to generate an image!';
                }
                if (typeof showImagenModal === 'function') {
                    showImagenModal(selectedNodes);
                    return 'ğŸ¨ Imagen modal opened! Choose a style and generate.';
                }
                return 'âŒ Image generation not available.';
            },
            'deep_dive': () => {
                const selectedNodes = window.selectedCanvasNodes || [];
                if (selectedNodes.length === 0) {
                    return 'âš ï¸ Select some nodes first for deep dive analysis!';
                }
                if (typeof performDeepDive === 'function') {
                    performDeepDive(selectedNodes);
                    return `ğŸ”¬ Running deep dive on ${selectedNodes.length} item(s)...`;
                }
                return 'âŒ Deep dive not available.';
            },

            // Missing theme
            'set_theme_powerpuff': () => {
                document.getElementById('theme-select').value = 'powerpuff';
                document.getElementById('theme-select').dispatchEvent(new Event('change'));
                return 'ğŸ’— Powerpuff theme applied!';
            },

            // Redo (was missing proper implementation)
            'redo': () => {
                if (typeof redo === 'function') {
                    redo();
                    return 'â†ªï¸ Redo complete!';
                }
                return 'âŒ Nothing to redo.';
            },

            // Layout commands for Canvas
            'layout_hierarchical': () => {
                const select = document.getElementById('auto-layout-select');
                if (select) {
                    select.value = 'hierarchical';
                    select.dispatchEvent(new Event('change'));
                    return 'ğŸŒ³ Hierarchical layout applied!';
                }
                return 'âŒ Switch to Canvas view first.';
            },
            'layout_timeline': () => {
                const select = document.getElementById('auto-layout-select');
                if (select) {
                    select.value = 'timeline';
                    select.dispatchEvent(new Event('change'));
                    return 'ğŸ“… Timeline layout applied!';
                }
                return 'âŒ Switch to Canvas view first.';
            },
            'layout_force': () => {
                const select = document.getElementById('auto-layout-select');
                if (select) {
                    select.value = 'force';
                    select.dispatchEvent(new Event('change'));
                    return 'ğŸŒ€ Force-directed layout applied!';
                }
                return 'âŒ Switch to Canvas view first.';
            },
            'layout_grid': () => {
                const select = document.getElementById('auto-layout-select');
                if (select) {
                    select.value = 'grid';
                    select.dispatchEvent(new Event('change'));
                    return 'ğŸ“Š Grid layout applied! Nodes arranged in a neat 4-column grid.';
                }
                return 'âŒ Switch to Canvas view first.';
            },
            'layout_radial': () => {
                const select = document.getElementById('auto-layout-select');
                if (select) {
                    select.value = 'radial';
                    select.dispatchEvent(new Event('change'));
                    return 'ğŸ¯ Radial layout applied! Nodes arranged in a circle.';
                }
                return 'âŒ Switch to Canvas view first.';
            },

            // Selection helpers
            'select_all': () => {
                if (typeof selectAllNodes === 'function') {
                    selectAllNodes();
                    return 'âœ… All nodes selected!';
                }
                return 'âŒ Switch to Canvas view first.';
            },
            'clear_selection': () => {
                if (typeof clearCanvasSelection === 'function') {
                    clearCanvasSelection();
                    return 'ğŸ”² Selection cleared!';
                }
                window.selectedCanvasNodes = [];
                return 'ğŸ”² Selection cleared!';
            },

            // Project info
            'project_info': () => {
                const name = typeof capexTree !== 'undefined' ? capexTree.name : 'Unknown';
                const pattern = typeof currentPattern !== 'undefined' ? currentPattern : 'generic';
                const phaseList = typeof capexTree !== 'undefined' ? (capexTree.children || capexTree.phases || []) : [];
                const phases = phaseList.length;
                const items = phaseList.reduce((sum, p) => sum + (p.items || p.children || []).length, 0);
                return `ğŸ“‹ **Project:** ${name}\n**Pattern:** ${pattern}\n**Phases:** ${phases}\n**Items:** ${items}`;
            },

            // BUILD 592: Aliases for project_info - TB's intuitive names
            'show_overview': function() { return COMMAND_REGISTRY['project_info'](); },
            'overview': function() { return COMMAND_REGISTRY['project_info'](); },
            'project_overview': function() { return COMMAND_REGISTRY['project_info'](); },

            // BUILD 440: Tree analysis - find items with most content/children
            'tree_analysis': () => {
                if (typeof capexTree === 'undefined') return 'âŒ No tree loaded.';

                const phaseList = capexTree.children || capexTree.phases || [];
                const allItems = [];

                // Collect all items with their stats
                phaseList.forEach((phase, pi) => {
                    const items = phase.items || phase.children || phase.subItems || [];
                    items.forEach((item, ii) => {
                        const children = (item.subItems || item.subtasks || item.children || []).length;
                        const descLen = (item.description || '').length;
                        const notesLen = (item.notes || '').length;
                        allItems.push({
                            name: item.name || 'Untitled',
                            phase: phase.name || `Phase ${pi + 1}`,
                            children,
                            contentLen: descLen + notesLen,
                            id: item.id
                        });
                    });
                });

                if (allItems.length === 0) return 'ğŸ“Š No items to analyze.';

                // Sort by children count (most developed)
                const byChildren = [...allItems].sort((a, b) => b.children - a.children).slice(0, 5);
                // Sort by content length (most detailed)
                const byContent = [...allItems].sort((a, b) => b.contentLen - a.contentLen).slice(0, 5);

                let result = 'ğŸ“Š **Tree Analysis**\n\n';
                result += '**Most Developed (by children):**\n';
                byChildren.forEach((item, i) => {
                    result += `${i + 1}. "${item.name}" - ${item.children} children\n`;
                });

                result += '\n**Most Detailed (by content length):**\n';
                byContent.forEach((item, i) => {
                    result += `${i + 1}. "${item.name}" - ${item.contentLen} chars\n`;
                });

                return result;
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 250: NAVIGATION & FOCUS COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Find node by name/text and select it
            'find_node': (query) => {
                if (!query) return 'âš ï¸ Please specify what to search for. Example: "find Becoming"';

                // BUILD 376: Normalize search term for flexible matching
                const normalizeForSearch = (text) => {
                    if (!text) return '';
                    let normalized = text.toLowerCase();
                    // Handle decade variations: "60's", "60s", "the 60s" -> matches "1960s"
                    normalized = normalized.replace(/[''`]/g, ''); // Remove apostrophes
                    normalized = normalized.replace(/^the\s+/i, ''); // Remove leading "the"
                    // Extract decade pattern: "60s" -> "1960s", "70s" -> "1970s"
                    const decadeMatch = normalized.match(/^(\d{2})s?$/);
                    if (decadeMatch) {
                        const decade = parseInt(decadeMatch[1]);
                        // Assume 20th century for 20-99, 21st for 00-19
                        const century = decade >= 20 ? 1900 : 2000;
                        normalized = (century + decade) + 's';
                    }
                    return normalized;
                };

                const searchNormalized = normalizeForSearch(query);

                const results = [];
                function searchTree(node, path = []) {
                    const nodeName = normalizeForSearch(node.name);
                    const nodeTitle = normalizeForSearch(node.title);
                    const nodeDesc = normalizeForSearch(node.description);

                    const nameMatch = nodeName.includes(searchNormalized) || (node.name && node.name.toLowerCase().includes(query.toLowerCase()));
                    const titleMatch = nodeTitle.includes(searchNormalized) || (node.title && node.title.toLowerCase().includes(query.toLowerCase()));
                    const descMatch = nodeDesc.includes(searchNormalized) || (node.description && node.description.toLowerCase().includes(query.toLowerCase()));

                    if (nameMatch || titleMatch || descMatch) {
                        results.push({ node, path: [...path], matchField: nameMatch ? 'name' : titleMatch ? 'title' : 'description' });
                    }

                    // Search children
                    (node.children || node.items || node.subItems || []).forEach((child, i) => {
                        searchTree(child, [...path, { name: node.name || node.id, index: i }]);
                    });
                }
                searchTree(capexTree);

                if (results.length === 0) {
                    return `âŒ No nodes found matching "${query}"`;
                }

                // Select the first match
                const firstMatch = results[0].node;
                window.chatFocusedNode = firstMatch;
                window.selectedCanvasNodes = [firstMatch];

                // Scroll to node in canvas if visible
                const nodeEl = document.querySelector(`.canvas-node[data-id="${firstMatch.id}"]`);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                // BUILD 395: Visual feedback for found node
                if (window.visualFeedback) {
                    window.visualFeedback.highlight(firstMatch.id, 'found', 4000);
                }

                const matchList = results.slice(0, 5).map((r, i) =>
                    `${i + 1}. "${r.node.name || r.node.title}" (${r.matchField})`
                ).join('\n');

                return `ğŸ” Found ${results.length} match${results.length > 1 ? 'es' : ''} for "${query}":\n${matchList}\n\nâœ… Selected: "${firstMatch.name || firstMatch.title}"`;
            },

            // Focus on a specific node by ID or name
            'focus_node': (nodeIdOrName) => {
                if (!nodeIdOrName) return 'âš ï¸ Please specify a node ID or name';

                // Try by ID first, then by name
                let node = typeof getNodeById === 'function' ? getNodeById(nodeIdOrName) : null;
                if (!node) {
                    node = findNodeById(nodeIdOrName) || findNodeByName(capexTree, nodeIdOrName);
                }
                if (!node) {
                    return `âŒ Node "${nodeIdOrName}" not found. Try a partial name or use \`search_tree\` to find it.`;
                }

                window.chatFocusedNode = node;
                window.selectedCanvasNodes = [node];

                const nodeEl = document.querySelector(`.canvas-node[data-id="${node.id}"]`);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                return `ğŸ¯ Focused on: "${node.name || node.title}" (ID: ${node.id})`;
            },

            // BUILD 538: Focus on root node - enables building from scratch
            'focus_root': () => {
                if (!capexTree) {
                    return 'âŒ No tree loaded. Create or load a tree first.';
                }

                window.chatFocusedNode = capexTree;
                window.selectedCanvasNodes = [capexTree];

                // Visual feedback
                const nodeEl = document.querySelector(`.canvas-node[data-id="${capexTree.id}"]`);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                if (window.visualFeedback) {
                    window.visualFeedback.highlight(capexTree.id, 'found', 3000);
                }

                return `ğŸ¯ Focused on root: "${capexTree.name || 'Root'}"`;
            },

            // BUILD 538: Create new tree with custom name - enables building from scratch
            'create_tree': (treeName) => {
                if (!treeName || treeName.trim() === '') {
                    return 'âš ï¸ Please provide a name for the new tree. Example: create_tree:My Project';
                }

                // Create new tree structure
                const newTree = {
                    id: 'root_' + Date.now(),
                    name: treeName.trim(),
                    description: '',
                    expanded: true,
                    children: []
                };

                // Replace current tree
                capexTree = newTree;
                window.chatFocusedNode = capexTree;
                window.selectedCanvasNodes = [capexTree];

                // BUILD 538: Dismiss the Get Started wizard since user is building via TreeBeard
                window.emptyStateManuallyDismissed = true;
                const emptyStateCta = document.getElementById('empty-state-cta');
                if (emptyStateCta) {
                    emptyStateCta.style.display = 'none';
                }

                // Save state and render
                if (typeof saveState === 'function') {
                    saveState('TreeBeard: Created new tree');
                }
                if (typeof render === 'function') {
                    render();
                }
                if (typeof renderCanvas === 'function' && viewMode === 'canvas') {
                    renderCanvas();
                }

                return `âœ… Created new tree: "${treeName.trim()}"\nğŸ¯ Focused on root - ready to add children`;
            },

            // BUILD 538: Rename root node
            'rename_root': (newName) => {
                if (!capexTree) {
                    return 'âŒ No tree loaded.';
                }
                if (!newName || newName.trim() === '') {
                    return 'âš ï¸ Please provide a new name for the root.';
                }

                const oldName = capexTree.name;
                capexTree.name = newName.trim();

                if (typeof saveState === 'function') {
                    saveState('TreeBeard: Renamed root');
                }
                if (typeof render === 'function') {
                    render();
                }

                return `âœ… Renamed root: "${oldName}" â†’ "${newName.trim()}"`;
            },

            // Expand focused node
            'expand_node': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                node.expanded = true;
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                const childCount = (node.children || node.items || node.subItems || []).length;
                return `â¬‡ï¸ Expanded "${node.name || node.title}" (${childCount} children)`;
            },

            // Collapse focused node
            'collapse_node': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                node.expanded = false;
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `â¬†ï¸ Collapsed "${node.name || node.title}"`;
            },

            // BUILD 394: Edit focused node
            'edit_node': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ No node selected. Click a node or use "find [name]" first.';

                // Open the edit modal for this node
                if (typeof showEditModal === 'function') {
                    showEditModal(node);
                    return `âœï¸ Opening editor for "${node.name || 'node'}"...`;
                } else if (typeof openNodeEditor === 'function') {
                    openNodeEditor(node);
                    return `âœï¸ Opening editor for "${node.name || 'node'}"...`;
                }

                // Fallback: trigger edit on the node element
                const nodeEl = document.querySelector(`[data-node-id="${node.id}"]`);
                if (nodeEl) {
                    const nameEl = nodeEl.querySelector('.node-name, .item-name, .phase-name');
                    if (nameEl) {
                        nameEl.click();
                        return `âœï¸ Click on the node name to edit it.`;
                    }
                }

                return 'âš ï¸ Unable to open editor. Try clicking directly on the node.';
            },

            // BUILD 394: Quick insight on focused node
            'quick_insight': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ No node selected. Click a node or use "find [name]" first.';

                // Build a quick summary
                const info = [];
                info.push(`ğŸ“ **${node.name || 'Unnamed Node'}**`);
                info.push(`Type: ${node.type || 'unknown'}`);

                if (node.description) info.push(`Description: ${node.description}`);
                if (node.status) info.push(`Status: ${node.status}`);
                if (node.cost) info.push(`Cost: ${node.cost}`);
                if (node.eventDate) info.push(`Date: ${node.eventDate}`);
                if (node.age) info.push(`Age: ${node.age}`);
                if (node.location) info.push(`Location: ${node.location}`);

                const children = node.children || node.items || node.subtasks || [];
                if (children.length > 0) {
                    info.push(`Children: ${children.length}`);
                }

                return info.join('\n');
            },

            // BUILD 394/578: Compare nodes - supports both multi-select and text-based
            'compare_nodes': (args) => {
                // BUILD 578: Text-based comparison if args provided
                if (args && typeof args === 'string') {
                    const match = args.match(/^(.+?)\s+(?:and|vs|versus)\s+(.+)$/i);
                    if (match) {
                        const name1 = match[1].trim();
                        const name2 = match[2].trim();

                        const node1 = findNodeById(name1) || findNodeByName(capexTree, name1);
                        const node2 = findNodeById(name2) || findNodeByName(capexTree, name2);

                        if (!node1) return `âŒ First node "${name1}" not found.`;
                        if (!node2) return `âŒ Second node "${name2}" not found.`;

                        const children1 = node1.children || node1.items || [];
                        const children2 = node2.children || node2.items || [];
                        const names1 = new Set(children1.map(c => (c.name || c.id).toLowerCase()));
                        const names2 = new Set(children2.map(c => (c.name || c.id).toLowerCase()));
                        const common = [...names1].filter(n => names2.has(n));

                        let result = `ğŸ”¬ **Comparison: "${node1.name}" vs "${node2.name}"**\n\n`;
                        result += `**${node1.name}**: ${children1.length} children\n`;
                        result += `**${node2.name}**: ${children2.length} children\n\n`;

                        if (common.length > 0) {
                            result += `**Duplicates (${common.length}):** ${common.slice(0, 5).join(', ')}${common.length > 5 ? '...' : ''}\n`;
                        } else {
                            result += '**No duplicate children found**\n';
                        }

                        const desc1 = (node1.description || '').toLowerCase().substring(0, 100);
                        const desc2 = (node2.description || '').toLowerCase().substring(0, 100);
                        if (desc1 && desc2 && desc1 === desc2) {
                            result += '\nâš ï¸ Descriptions are identical!';
                        }

                        return result;
                    }
                }

                // BUILD 394: Multi-select fallback
                const nodes = selectedNodes || [];
                if (nodes.length < 2) return 'âš ï¸ Usage: `compare_nodes {node1} and {node2}` or Ctrl+click 2+ nodes in Canvas.';

                const comparison = nodes.map(n => `â€¢ **${n.name}**: ${n.description || n.status || 'No description'}`).join('\n');
                return `ğŸ”¬ Comparing ${nodes.length} nodes:\n${comparison}`;
            },

            // BUILD 394: Pattern-specific placeholders
            'refute_thesis': async () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select a thesis or argument node first.';
                return `âš”ï¸ Refutation analysis for "${node.name}":\nTo refute this thesis, consider:\nâ€¢ Counter-examples\nâ€¢ Logical inconsistencies\nâ€¢ Alternative explanations\n\nUse "enhance" for AI-powered refutation.`;
            },

            'generate_dialogue': async () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select a node to generate dialogue about.';
                return `ğŸ’¬ To generate Socratic dialogue about "${node.name}", use the AI enhancement feature with prompt: "Create a Socratic dialogue exploring this concept"`;
            },

            'analyze_argument': async () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select an argument node first.';
                return `ğŸ” Argument structure for "${node.name}":\nâ€¢ Premises: [Click to add]\nâ€¢ Conclusion: ${node.description || '[Not specified]'}\nâ€¢ Type: [Deductive/Inductive/Abductive]\n\nUse "deep dive" for detailed analysis.`;
            },

            'birthday_method': () => {
                if (typeof window.startBirthdayMethod === 'function') {
                    window.startBirthdayMethod();
                    return 'ğŸ‚ Starting Birthday Memory Method...';
                }
                return 'ğŸ‚ Birthday Method: Start from a birthday memory and expand outward. What birthday do you remember most vividly?';
            },

            'generate_followup': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select a lead or deal to generate follow-up for.';
                return `ğŸ“ Follow-up suggestions for "${node.name}":\nâ€¢ Schedule check-in call\nâ€¢ Send relevant case study\nâ€¢ Propose next steps meeting`;
            },

            'qualify_lead': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select a lead to qualify.';
                return `ğŸ’° Lead qualification for "${node.name}":\nâ€¢ Budget: [TBD]\nâ€¢ Authority: [TBD]\nâ€¢ Need: [TBD]\nâ€¢ Timeline: [TBD]\n\nUpdate the node fields to track qualification.`;
            },

            'show_pipeline': () => {
                return 'ğŸ“ˆ Pipeline view: Switch to Canvas view for visual pipeline representation.';
            },

            'calculate_roi': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select a CAPEX item to calculate ROI.';
                const cost = node.cost || node.totalCost || 'Unknown';
                return `ğŸ’µ ROI Analysis for "${node.name}":\nâ€¢ Investment: ${cost}\nâ€¢ Expected Return: [TBD]\nâ€¢ Payback Period: [TBD]\n\nAdd financial details to the node for accurate calculations.`;
            },

            'show_budget': () => {
                return 'ğŸ“Š Budget Overview: Check the summary panel for total CAPEX allocation.';
            },

            'analyze_risks': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select an item to analyze risks.';
                return `âš ï¸ Risk analysis for "${node.name}":\nâ€¢ Technical Risks: [TBD]\nâ€¢ Schedule Risks: [TBD]\nâ€¢ Resource Risks: [TBD]\nâ€¢ Mitigation: [TBD]`;
            },

            // Navigate to first child
            'first_child': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                const children = node.children || node.items || node.subItems || [];
                if (children.length === 0) {
                    return `âŒ "${node.name || node.title}" has no children`;
                }

                const child = children[0];
                window.chatFocusedNode = child;
                window.selectedCanvasNodes = [child];

                return `ğŸ‘¶ Moved to first child: "${child.name || child.title}"`;
            },

            // Navigate to parent
            'parent_node': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                // Find parent by searching tree
                let parent = null;
                function findParent(current, target) {
                    const children = current.children || current.items || current.subItems || [];
                    for (const child of children) {
                        if (child.id === target.id) {
                            parent = current;
                            return true;
                        }
                        if (findParent(child, target)) return true;
                    }
                    return false;
                }
                findParent(capexTree, node);

                if (!parent) {
                    return `âŒ "${node.name || node.title}" has no parent (it's the root)`;
                }

                window.chatFocusedNode = parent;
                window.selectedCanvasNodes = [parent];

                return `â¬†ï¸ Moved to parent: "${parent.name || parent.title}"`;
            },

            // Navigate to next sibling
            'next_sibling': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                // Find sibling
                let sibling = null;
                function findSibling(parent) {
                    const children = parent.children || parent.items || parent.subItems || [];
                    const idx = children.findIndex(c => c.id === node.id);
                    if (idx >= 0 && idx < children.length - 1) {
                        sibling = children[idx + 1];
                        return true;
                    }
                    for (const child of children) {
                        if (findSibling(child)) return true;
                    }
                    return false;
                }
                findSibling(capexTree);

                if (!sibling) {
                    return `âŒ "${node.name || node.title}" has no next sibling`;
                }

                window.chatFocusedNode = sibling;
                window.selectedCanvasNodes = [sibling];

                return `â¡ï¸ Moved to next sibling: "${sibling.name || sibling.title}"`;
            },

            // Navigate to previous sibling
            'prev_sibling': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                let sibling = null;
                function findSibling(parent) {
                    const children = parent.children || parent.items || parent.subItems || [];
                    const idx = children.findIndex(c => c.id === node.id);
                    if (idx > 0) {
                        sibling = children[idx - 1];
                        return true;
                    }
                    for (const child of children) {
                        if (findSibling(child)) return true;
                    }
                    return false;
                }
                findSibling(capexTree);

                if (!sibling) {
                    return `âŒ "${node.name || node.title}" has no previous sibling`;
                }

                window.chatFocusedNode = sibling;
                window.selectedCanvasNodes = [sibling];

                return `â¬…ï¸ Moved to previous sibling: "${sibling.name || sibling.title}"`;
            },

            // List children of focused node
            'list_children': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                const children = node.children || node.items || node.subItems || [];
                if (children.length === 0) {
                    return `ğŸ“­ "${node.name || node.title}" has no children`;
                }

                const list = children.map((c, i) => `${i + 1}. ${c.name || c.title || c.id}`).join('\n');
                return `ğŸ“‹ Children of "${node.name || node.title}" (${children.length}):\n${list}`;
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // VIEW CONTROL COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'zoom_in': () => {
                // BUILD 547: Use center-focused zoom
                if (typeof zoomCanvasCenter === 'function') {
                    zoomCanvasCenter(1.2);
                    return `ğŸ” Zoomed in to ${Math.round(canvasZoom * 100)}%`;
                }
                return 'âŒ Switch to Canvas view first';
            },

            'zoom_out': () => {
                // BUILD 547: Use center-focused zoom
                if (typeof zoomCanvasCenter === 'function') {
                    zoomCanvasCenter(1 / 1.2);
                    return `ğŸ” Zoomed out to ${Math.round(canvasZoom * 100)}%`;
                }
                return 'âŒ Switch to Canvas view first';
            },

            'zoom_fit': () => {
                if (typeof fitToView === 'function') {
                    fitToView();
                    return 'ğŸ“ Fit all nodes to view';
                }
                return 'âŒ Switch to Canvas view first';
            },

            'zoom_reset': () => {
                if (typeof resetView === 'function') {
                    resetView();
                    return 'ğŸ”„ View reset to 100%';
                }
                return 'âŒ Switch to Canvas view first';
            },

            'scroll_to_node': (nodeId) => {
                const id = nodeId || (window.chatFocusedNode?.id);
                if (!id) return 'âš ï¸ No node to scroll to. Use "find [name]" first.';

                const nodeEl = document.querySelector(`.canvas-node[data-id="${id}"]`);
                if (nodeEl) {
                    nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    return `ğŸ“ Scrolled to node`;
                }
                return 'âŒ Node not visible in current view';
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIELD EDITING COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'set_title': (newTitle) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!newTitle) return 'âš ï¸ Please provide a new title';

                const oldTitle = node.name || node.title;
                if (node.name !== undefined) node.name = newTitle;
                if (node.title !== undefined) node.title = newTitle;

                if (typeof saveState === 'function') saveState('Chat: Set title');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `âœï¸ Title changed: "${oldTitle}" â†’ "${newTitle}"`;
            },

            'set_description': (newDesc) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!newDesc) return 'âš ï¸ Please provide a description';

                node.description = newDesc;

                if (typeof saveState === 'function') saveState('Chat: Set description');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `ğŸ“ Description updated for "${node.name || node.title}"`;
            },

            'set_field': (fieldAndValue) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!fieldAndValue) return 'âš ï¸ Usage: set_field:fieldName:value';

                const parts = fieldAndValue.split(':');
                if (parts.length < 2) return 'âš ï¸ Usage: set_field:fieldName:value';

                const field = parts[0];
                const value = parts.slice(1).join(':'); // Allow colons in value

                node[field] = value;

                if (typeof saveState === 'function') saveState(`Chat: Set ${field}`);
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `âœ… Set ${field} = "${value}" on "${node.name || node.title}"`;
            },

            'get_field': (field) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!field) return 'âš ï¸ Please specify a field name';

                const value = node[field];
                if (value === undefined) {
                    return `âŒ Field "${field}" not found on this node. Available fields: ${Object.keys(node).join(', ')}`;
                }

                return `ğŸ“– ${field}: "${value}"`;
            },

            'list_fields': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                const fields = Object.entries(node)
                    .filter(([k, v]) => !['children', 'items', 'subItems', 'canvasX', 'canvasY'].includes(k) && v !== null && v !== undefined)
                    .map(([k, v]) => {
                        const val = typeof v === 'string' ? (v.length > 50 ? v.substring(0, 50) + '...' : v) : v;
                        return `â€¢ ${k}: ${val}`;
                    });

                return `ğŸ“‹ Fields on "${node.name || node.title}":\n${fields.join('\n')}`;
            },

            // AI enhance specific field
            'ai_enhance_field': async (field) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!field) return 'âš ï¸ Please specify a field to enhance (e.g., description, thesis)';

                const currentValue = node[field] || '';

                // Use the proxy to enhance
                try {
                    const response = await fetch('/.netlify/functions/claude-proxy', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 500,
                            messages: [{
                                role: 'user',
                                content: `Improve this ${field} for a node titled "${node.name || node.title}" in a ${typeof currentPattern !== 'undefined' ? currentPattern : 'generic'} project tree. Keep it concise but make it more specific and actionable.\n\nCurrent ${field}: ${currentValue || '(empty)'}\n\nReturn ONLY the improved text, no explanations.`
                            }]
                        })
                    });

                    const data = await response.json();
                    const enhanced = data.content?.[0]?.text || data.choices?.[0]?.message?.content;

                    if (enhanced) {
                        node[field] = enhanced.trim();
                        if (typeof saveState === 'function') saveState(`Chat: AI enhanced ${field}`);
                        if (typeof render === 'function') render();
                        if (typeof renderCanvas === 'function') renderCanvas();
                        return `âœ¨ AI enhanced ${field}:\n"${enhanced.trim()}"`;
                    }
                    return 'âŒ AI enhancement failed - no response';
                } catch (err) {
                    return `âŒ AI enhancement failed: ${err.message}`;
                }
            },

            // Add a child node - BUILD 382: Enhanced to accept rich JSON data
            // BUILD 538: Auto-focus on root if no node focused (enables building from scratch)
            'add_child': (childData) => {
                let node = window.chatFocusedNode;

                // BUILD 538: Auto-focus on root if no node is focused
                if (!node && capexTree) {
                    node = capexTree;
                    window.chatFocusedNode = capexTree;
                    window.selectedCanvasNodes = [capexTree];
                    console.log('ğŸ”§ add_child: Auto-focused on root node');
                }

                if (!node) return 'âš ï¸ No node focused and no tree loaded. Create or load a tree first.';
                if (!childData) return 'âš ï¸ Please provide a name for the new child';

                let newChild;

                // BUILD 384: Support rich JSON data OR simple string with validation
                const trimmedData = childData.trim();
                console.log('ğŸ”§ add_child raw input:', childData);
                console.log('ğŸ”§ add_child trimmed:', trimmedData);

                if (trimmedData.startsWith('{')) {
                    try {
                        const parsed = JSON.parse(trimmedData);
                        console.log('ğŸ”§ add_child parsed:', parsed);

                        // BUILD 384: Extract name from multiple sources, validate it exists
                        let nodeName = parsed.name || parsed.title;
                        console.log('ğŸ”§ add_child nodeName extracted:', nodeName);

                        // If no name, try to extract from description
                        if (!nodeName && parsed.description) {
                            // Take first sentence or first 50 chars of description
                            nodeName = parsed.description.split(/[.!?]/)[0].trim().substring(0, 50);
                        }

                        // If still no name, try location + eventDate combo
                        if (!nodeName && (parsed.location || parsed.eventDate)) {
                            nodeName = [parsed.eventDate, parsed.location].filter(Boolean).join(' - ');
                        }

                        // Final validation - reject undefined/empty names
                        if (!nodeName || nodeName === 'undefined' || nodeName.trim() === '') {
                            return 'âš ï¸ Cannot create node without a name. Please include "name" in the JSON.';
                        }

                        newChild = {
                            id: 'chat_' + Date.now(),
                            name: nodeName,
                            expanded: true,
                            // LifeTree fields
                            eventDate: parsed.eventDate || parsed.when || parsed.date || '',
                            location: parsed.location || parsed.where || parsed.place || '',
                            people: parsed.people || parsed.who || '',
                            emotion: parsed.emotion || parsed.feeling || '',
                            source: parsed.source || parsed.rememberedBy || 'Subject',
                            confidence: parsed.confidence || 'Exact',
                            description: parsed.description || parsed.details || '',
                            historicalContext: parsed.historicalContext || '',
                            // Standard fields
                            type: parsed.type || 'memory'
                        };
                        // Clean out empty fields
                        Object.keys(newChild).forEach(k => {
                            if (newChild[k] === '' || newChild[k] === null || newChild[k] === undefined) {
                                if (!['id', 'name', 'expanded'].includes(k)) delete newChild[k];
                            }
                        });
                    } catch (e) {
                        // Fallback to simple string - but validate it's not undefined
                        if (childData === 'undefined' || childData.trim() === '') {
                            return 'âš ï¸ Cannot create node with empty name.';
                        }
                        newChild = {
                            id: 'chat_' + Date.now(),
                            name: childData,
                            expanded: true
                        };
                    }
                } else {
                    // Simple string format - validate
                    if (childData === 'undefined' || childData.trim() === '') {
                        return 'âš ï¸ Cannot create node with empty name.';
                    }
                    newChild = {
                        id: 'chat_' + Date.now(),
                        name: childData,
                        expanded: true
                    };
                }

                // Determine which array to use
                if (node.subItems) {
                    node.subItems.push(newChild);
                } else if (node.items) {
                    node.items.push(newChild);
                } else if (node.children) {
                    node.children.push(newChild);
                } else {
                    node.subItems = [newChild];
                }

                if (typeof saveState === 'function') saveState('Chat: Added child');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                // BUILD 597: Keep focus on PARENT so multiple add_child calls work correctly
                // Previously auto-focused on newChild, which broke ADD MULTIPLE CHILDREN sequence
                // Parent stays focused - user can explicitly find_node to focus on the new child if needed

                // BUILD 382: Show what fields were captured
                const fieldsAdded = Object.keys(newChild).filter(k =>
                    !['id', 'name', 'expanded'].includes(k) && newChild[k]
                );
                const fieldsSummary = fieldsAdded.length > 0
                    ? ` (${fieldsAdded.join(', ')})`
                    : '';

                return `â• Added child "${newChild.name}" to "${node.name || node.title}"${fieldsSummary}`;
            },

            // Delete focused node
            'delete_node': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (node.id === capexTree.id) return 'âŒ Cannot delete the root node';

                // Find and remove from parent
                function removeFromParent(parent) {
                    const arrays = ['children', 'items', 'subItems'];
                    for (const arr of arrays) {
                        if (parent[arr]) {
                            const idx = parent[arr].findIndex(c => c.id === node.id);
                            if (idx >= 0) {
                                parent[arr].splice(idx, 1);
                                return true;
                            }
                            for (const child of parent[arr]) {
                                if (removeFromParent(child)) return true;
                            }
                        }
                    }
                    return false;
                }

                const name = node.name || node.title;
                removeFromParent(capexTree);
                window.chatFocusedNode = null;

                if (typeof saveState === 'function') saveState('Chat: Deleted node');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `ğŸ—‘ï¸ Deleted "${name}"`;
            },

            // BUILD 392: Delete phase by ID (for health check integration)
            'delete_phase': (phaseId) => {
                if (!phaseId) return 'âš ï¸ No phase ID provided.';

                const phases = capexTree?.children || [];
                const phaseIndex = phases.findIndex(p => p.id === phaseId);

                if (phaseIndex < 0) {
                    return `âš ï¸ Phase not found: ${phaseId}`;
                }

                const phase = phases[phaseIndex];
                const itemCount = (phase.items || phase.children || phase.subItems || []).length;

                if (typeof saveState === 'function') {
                    saveState(`Delete phase: ${phase.name}`);
                }

                capexTree.children.splice(phaseIndex, 1);

                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `ğŸ—‘ï¸ Deleted phase "${phase.name}"${itemCount > 0 ? ` (including ${itemCount} items)` : ''}`;
            },

            // Show focused node info
            'node_info': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                const children = (node.children || node.items || node.subItems || []).length;
                const fields = Object.keys(node).filter(k => !['children', 'items', 'subItems', 'canvasX', 'canvasY', 'id'].includes(k));

                return `ğŸ“ **Focused Node:**\nâ€¢ Name: ${node.name || node.title || 'Untitled'}\nâ€¢ ID: ${node.id}\nâ€¢ Children: ${children}\nâ€¢ Fields: ${fields.join(', ')}`;
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 384: REPAIR TREE - Find and fix bad nodes
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'repair_tree': () => {
                const issues = [];

                // Helper: Calculate string similarity (Jaccard-ish)
                function similarity(a, b) {
                    if (!a || !b) return 0;
                    const setA = new Set(a.toLowerCase().split(/\s+/));
                    const setB = new Set(b.toLowerCase().split(/\s+/));
                    const intersection = [...setA].filter(x => setB.has(x)).length;
                    const union = new Set([...setA, ...setB]).size;
                    return union > 0 ? intersection / union : 0;
                }

                // Helper: Generate smart name suggestion from children
                function suggestName(node) {
                    const children = node.children || node.items || node.subItems || [];
                    if (children.length === 0) return 'Unnamed memory';

                    const firstChild = children[0];
                    const childName = firstChild.name || firstChild.title || '';
                    const location = firstChild.location || '';
                    const eventDate = firstChild.eventDate || '';

                    // Try to create a descriptive name
                    if (location) {
                        return `${location} memories`;
                    } else if (eventDate) {
                        return `${eventDate} - ${childName.substring(0, 30)}`;
                    } else if (childName) {
                        // Shorten if too long
                        return childName.length > 40 ? childName.substring(0, 37) + '...' : childName;
                    }
                    return 'Memory group';
                }

                // Helper: Get parent path for context
                function getNodePath(targetNode, current = capexTree, path = []) {
                    if (current.id === targetNode.id) return path;
                    const children = current.children || current.items || current.subItems || [];
                    for (const child of children) {
                        const result = getNodePath(targetNode, child, [...path, current.name || current.title || '?']);
                        if (result) return result;
                    }
                    return null;
                }

                // Recursive scan for issues
                function scanNode(node, parent = null, phase = null) {
                    const nodeName = node.name || node.title || '';
                    const nodeId = node.id || '';

                    // Check 1: Undefined/empty names
                    if (!nodeName || nodeName === 'undefined' || nodeName.trim() === '') {
                        issues.push({
                            type: 'undefined',
                            node: node,
                            parent: parent,
                            phase: phase,
                            suggestion: suggestName(node)
                        });
                    }

                    // Check 2: Malformed data - missing ID
                    if (!nodeId) {
                        issues.push({
                            type: 'missing_id',
                            node: node,
                            parent: parent,
                            phase: phase
                        });
                    }

                    // Recurse into children
                    const children = node.children || node.items || node.subItems || [];
                    const currentPhase = node.type === 'phase' ? node : phase;
                    children.forEach(child => scanNode(child, node, currentPhase));
                }

                // Start scan from root
                scanNode(capexTree);

                // Check 3: Duplicates within same phase
                const phases = capexTree.children || capexTree.phases || [];
                phases.forEach(phase => {
                    const items = phase.items || phase.children || phase.subItems || [];
                    for (let i = 0; i < items.length; i++) {
                        for (let j = i + 1; j < items.length; j++) {
                            const nameA = (items[i].name || items[i].title || '').toLowerCase();
                            const nameB = (items[j].name || items[j].title || '').toLowerCase();

                            // Skip if either is already flagged as undefined
                            if (!nameA || nameA === 'undefined' || !nameB || nameB === 'undefined') continue;

                            // Exact match or high similarity
                            if (nameA === nameB || similarity(nameA, nameB) >= 0.8) {
                                // Check if we already flagged this pair
                                const alreadyFlagged = issues.some(iss =>
                                    iss.type === 'duplicate' &&
                                    ((iss.node.id === items[i].id && iss.duplicate.id === items[j].id) ||
                                     (iss.node.id === items[j].id && iss.duplicate.id === items[i].id))
                                );
                                if (!alreadyFlagged) {
                                    issues.push({
                                        type: 'duplicate',
                                        node: items[i],
                                        duplicate: items[j],
                                        phase: phase,
                                        similarity: nameA === nameB ? 1.0 : similarity(nameA, nameB)
                                    });
                                }
                            }
                        }
                    }
                });

                // Store issues for interactive repair
                window.repairQueue = issues;
                window.repairIndex = 0;

                if (issues.length === 0) {
                    return 'âœ… **Tree health check complete!** No issues found. Your tree is clean.';
                }

                // Count by type
                const undefinedCount = issues.filter(i => i.type === 'undefined').length;
                const duplicateCount = issues.filter(i => i.type === 'duplicate').length;
                const malformedCount = issues.filter(i => i.type === 'missing_id').length;

                let summary = `ğŸ”§ **Found ${issues.length} issue${issues.length > 1 ? 's' : ''}:**\n`;
                if (undefinedCount > 0) summary += `â€¢ ${undefinedCount} undefined/empty name${undefinedCount > 1 ? 's' : ''}\n`;
                if (duplicateCount > 0) summary += `â€¢ ${duplicateCount} duplicate pair${duplicateCount > 1 ? 's' : ''}\n`;
                if (malformedCount > 0) summary += `â€¢ ${malformedCount} missing ID${malformedCount > 1 ? 's' : ''}\n`;

                summary += '\nLet\'s fix them one at a time.';

                // Show first issue
                setTimeout(() => {
                    if (window.repairQueue && window.repairQueue.length > 0) {
                        showRepairIssue(0);
                    }
                }, 500);

                return summary;
            },

            // Repair action: Rename a node
            'repair_rename': (newName) => {
                if (!window.repairQueue || window.repairIndex >= window.repairQueue.length) {
                    return 'âš ï¸ No active repair session. Use "repair tree" to start.';
                }

                const issue = window.repairQueue[window.repairIndex];
                if (!newName || newName.trim() === '') {
                    return 'âš ï¸ Please provide a name.';
                }

                issue.node.name = newName.trim();
                if (typeof saveState === 'function') saveState('Repair: Renamed node');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                const result = `âœ… Renamed to "${newName}"`;

                // Move to next issue
                window.repairIndex++;
                setTimeout(() => showRepairIssue(window.repairIndex), 300);

                return result;
            },

            // Repair action: Delete node and promote children
            'repair_delete_promote': () => {
                if (!window.repairQueue || window.repairIndex >= window.repairQueue.length) {
                    return 'âš ï¸ No active repair session. Use "repair tree" to start.';
                }

                const issue = window.repairQueue[window.repairIndex];
                const node = issue.node;
                const parent = issue.parent;

                if (!parent) {
                    return 'âŒ Cannot delete root node.';
                }

                const nodeChildren = node.children || node.items || node.subItems || [];

                // Find which array the node is in
                const arrays = ['children', 'items', 'subItems'];
                for (const arr of arrays) {
                    if (parent[arr]) {
                        const idx = parent[arr].findIndex(c => c.id === node.id);
                        if (idx >= 0) {
                            // Remove the bad node
                            parent[arr].splice(idx, 1);
                            // Insert its children at the same position
                            parent[arr].splice(idx, 0, ...nodeChildren);
                            break;
                        }
                    }
                }

                if (typeof saveState === 'function') saveState('Repair: Deleted & promoted children');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                const result = `ğŸ—‘ï¸ Deleted bad node, promoted ${nodeChildren.length} child${nodeChildren.length !== 1 ? 'ren' : ''}`;

                // Move to next issue
                window.repairIndex++;
                setTimeout(() => showRepairIssue(window.repairIndex), 300);

                return result;
            },

            // Repair action: Merge duplicates
            'repair_merge': () => {
                if (!window.repairQueue || window.repairIndex >= window.repairQueue.length) {
                    return 'âš ï¸ No active repair session. Use "repair tree" to start.';
                }

                const issue = window.repairQueue[window.repairIndex];
                if (issue.type !== 'duplicate') {
                    return 'âš ï¸ Current issue is not a duplicate.';
                }

                const keep = issue.node;
                const remove = issue.duplicate;
                const phase = issue.phase;

                // Merge children from duplicate into keeper
                const removeChildren = remove.children || remove.items || remove.subItems || [];
                if (removeChildren.length > 0) {
                    if (!keep.subItems) keep.subItems = [];
                    keep.subItems.push(...removeChildren);
                }

                // Merge description if duplicate has one and keeper doesn't
                if (remove.description && !keep.description) {
                    keep.description = remove.description;
                } else if (remove.description && keep.description) {
                    keep.description += '\n\n' + remove.description;
                }

                // Remove the duplicate from phase
                const phaseItems = phase.items || phase.children || phase.subItems || [];
                const idx = phaseItems.findIndex(c => c.id === remove.id);
                if (idx >= 0) {
                    phaseItems.splice(idx, 1);
                }

                if (typeof saveState === 'function') saveState('Repair: Merged duplicates');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                const result = `ğŸ”— Merged "${remove.name}" into "${keep.name}"`;

                // Move to next issue
                window.repairIndex++;
                setTimeout(() => showRepairIssue(window.repairIndex), 300);

                return result;
            },

            // Repair action: Skip current issue
            'repair_skip': () => {
                if (!window.repairQueue || window.repairIndex >= window.repairQueue.length) {
                    return 'âš ï¸ No active repair session.';
                }

                window.repairIndex++;
                setTimeout(() => showRepairIssue(window.repairIndex), 100);

                return 'â­ï¸ Skipped';
            },

            // BUILD 385: Aliases for common repair commands
            'repair': function() { return COMMAND_REGISTRY['repair_tree'](); },
            'fix_tree': function() { return COMMAND_REGISTRY['repair_tree'](); },
            'health_check': function() { return COMMAND_REGISTRY['repair_tree'](); },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 255: PROMPT PLAYGROUND MODE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Improve a prompt using AI
            'improve_prompt': async (promptText) => {
                if (!promptText || promptText.trim().length < 5) {
                    return 'âš ï¸ Please provide a prompt to improve. Example: "improve prompt: write a haiku about cats"';
                }

                // Store the prompt for playground
                chatState.pendingPromptToImprove = promptText;

                // Show improving message
                addMessage('ğŸ§  Improving your prompt...', 'system');

                try {
                    // Use the existing improvePromptWithAI function
                    const result = await improvePromptWithAI(promptText, 'quick');

                    if (result && result.phases && result.phases[0] && result.phases[0].items && result.phases[0].items[0]) {
                        const improved = result.phases[0].items[0];
                        const systemPrompt = improved.systemPrompt || '';
                        const userPrompt = improved.userPromptTemplate || '';
                        const examples = improved.fewShotExamples || '';

                        // Combine into full prompt
                        const fullPrompt = [systemPrompt, userPrompt, examples].filter(Boolean).join('\n\n');

                        // Store for playground
                        chatState.improvedPrompt = {
                            system: systemPrompt,
                            user: userPrompt,
                            examples: examples,
                            full: fullPrompt,
                            name: improved.name || 'Improved Prompt',
                            model: improved.modelTarget || 'Claude Sonnet 4'
                        };

                        return null; // We'll add the message with buttons separately
                    } else {
                        return 'âŒ Could not improve prompt. Please try again.';
                    }
                } catch (error) {
                    console.error('Prompt improvement error:', error);
                    return `âŒ Error improving prompt: ${error.message}`;
                }
            },

            // Enter playground mode with a prompt
            'enter_playground': (model) => {
                if (!chatState.improvedPrompt) {
                    return 'âš ï¸ No prompt loaded. Use "improve prompt: [your prompt]" first.';
                }

                chatState.playgroundMode = true;
                chatState.playgroundSystemPrompt = chatState.improvedPrompt.system || chatState.improvedPrompt.full;
                chatState.playgroundModel = model || 'claude-sonnet';
                chatState.playgroundHistory = [];

                // Update UI to show playground mode
                updatePlaygroundUI(true);

                return `ğŸ® **Playground Mode Active**\n\nModel: ${getModelDisplayName(chatState.playgroundModel)}\nSystem prompt loaded. Send a test message to try it out!\n\nType "exit playground" to return to TreeBeard.`;
            },

            // Exit playground mode
            'exit_playground': () => {
                chatState.playgroundMode = false;
                chatState.playgroundSystemPrompt = '';
                chatState.playgroundHistory = [];

                // Update UI to show normal mode
                updatePlaygroundUI(false);

                return 'ğŸŒ³ Back to TreeBeard! How can I help you?';
            },

            // Copy improved prompt to clipboard
            'copy_prompt': async () => {
                if (!chatState.improvedPrompt) {
                    return 'âš ï¸ No prompt to copy. Use "improve prompt: [your prompt]" first.';
                }

                try {
                    await navigator.clipboard.writeText(chatState.improvedPrompt.full);
                    return 'ğŸ“‹ Prompt copied to clipboard!';
                } catch (e) {
                    return 'âŒ Could not copy to clipboard. Try selecting the text manually.';
                }
            },

            // Save prompt as file
            'save_prompt': () => {
                if (!chatState.improvedPrompt) {
                    return 'âš ï¸ No prompt to save. Use "improve prompt: [your prompt]" first.';
                }

                const blob = new Blob([chatState.improvedPrompt.full], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${chatState.improvedPrompt.name.replace(/[^a-z0-9]/gi, '-').toLowerCase()}.txt`;
                a.click();
                URL.revokeObjectURL(url);

                return 'ğŸ’¾ Prompt saved as text file!';
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 308/309: FIND REDUNDANCIES - with actionable merge buttons
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            'find_redundancies': async () => {
                // Collect all nodes with their names/descriptions
                const allNodes = [];
                function collectNodes(node, path = []) {
                    const currentPath = [...path, node.name || node.title || 'Unnamed'];
                    allNodes.push({
                        id: node.id,
                        name: node.name || node.title || '',
                        description: node.description || '',
                        path: currentPath.join(' â†’ ')
                    });
                    (node.children || node.items || node.subItems || []).forEach(child => {
                        collectNodes(child, currentPath);
                    });
                }
                collectNodes(capexTree);

                if (allNodes.length < 3) {
                    return 'âš ï¸ Your tree has very few nodes. Add more content first!';
                }

                // Group by similar names using fuzzy matching
                const groups = [];
                const used = new Set();

                for (let i = 0; i < allNodes.length; i++) {
                    if (used.has(i)) continue;
                    const node = allNodes[i];
                    const similar = [node];
                    const words1 = node.name.toLowerCase().split(/\s+/).filter(w => w.length > 3);

                    for (let j = i + 1; j < allNodes.length; j++) {
                        if (used.has(j)) continue;
                        const other = allNodes[j];
                        const words2 = other.name.toLowerCase().split(/\s+/).filter(w => w.length > 3);

                        // Check for word overlap (3+ chars)
                        const overlap = words1.filter(w => words2.includes(w) || other.name.toLowerCase().includes(w));
                        const overlapRatio = words1.length > 0 ? overlap.length / Math.max(words1.length, words2.length) : 0;

                        // Also check for substring match
                        const nameA = node.name.toLowerCase().replace(/[^a-z]/g, '');
                        const nameB = other.name.toLowerCase().replace(/[^a-z]/g, '');
                        const isSubstring = nameA.length > 5 && nameB.length > 5 &&
                            (nameA.includes(nameB) || nameB.includes(nameA));

                        if (overlapRatio >= 0.5 || isSubstring) {
                            similar.push(other);
                            used.add(j);
                        }
                    }

                    if (similar.length > 1) {
                        groups.push(similar);
                        used.add(i);
                    }
                }

                if (groups.length === 0) {
                    return 'âœ… No obvious redundancies found! Your tree looks well-organized.\n\nFor deeper analysis, try AI Review (ğŸ”) which can detect conceptual overlaps.';
                }

                // Store for navigation
                window.chatRedundancyGroups = groups;
                window.chatCurrentGroupIndex = 0;

                // Format first group
                const group = groups[0];
                let result = `ğŸ” **Found ${groups.length} redundancy group(s)**\n\n`;
                result += `**Group 1 of ${groups.length}:** "${group[0].name}"\n\n`;
                group.forEach((node, i) => {
                    result += `${i + 1}. **${node.name}**\n   _${node.path}_\n\n`;
                });
                result += `\nğŸ’¡ Review these nodes and keep the most detailed one.`;

                return {
                    message: result,
                    buttons: [
                        { label: 'ğŸ‘ï¸ View Group 1', action: 'view_redundancy_group:0' },
                        { label: 'â¡ï¸ Next Group', action: 'next_redundancy_group' },
                        { label: 'ğŸ”€ Auto-Merge All', action: 'auto_merge_redundancies' }
                    ]
                };
            },

            // View a specific redundancy group
            'view_redundancy_group': (indexStr) => {
                const groups = window.chatRedundancyGroups;
                if (!groups || groups.length === 0) {
                    return 'âš ï¸ No redundancy groups found. Run "find redundancies" first.';
                }

                const index = parseInt(indexStr) || 0;
                if (index < 0 || index >= groups.length) {
                    return `âŒ Invalid group index. Valid range: 0-${groups.length - 1}`;
                }

                window.chatCurrentGroupIndex = index;
                const group = groups[index];

                // Select all nodes in this group in the canvas
                window.selectedCanvasNodes = group.map(n => {
                    // Find actual node object by ID
                    function findNode(tree, id) {
                        if (tree.id === id) return tree;
                        for (const child of (tree.children || tree.items || tree.subItems || [])) {
                            const found = findNode(child, id);
                            if (found) return found;
                        }
                        return null;
                    }
                    return findNode(capexTree, n.id);
                }).filter(Boolean);

                let result = `ğŸ“‹ **Group ${index + 1} of ${groups.length}:** "${group[0].name}"\n\n`;
                group.forEach((node, i) => {
                    const descPreview = node.description ? node.description.substring(0, 80) + '...' : '(no description)';
                    result += `${i + 1}. **${node.name}**\n   ${descPreview}\n   _${node.path}_\n\n`;
                });

                result += `\nâœ… ${group.length} nodes selected in canvas. Review and delete duplicates.`;

                const buttons = [
                    { label: `ğŸ” Find "${group[0].name}"`, action: `find_node:${group[0].name}` }
                ];
                if (index > 0) buttons.push({ label: 'â¬…ï¸ Prev', action: `view_redundancy_group:${index - 1}` });
                if (index < groups.length - 1) buttons.push({ label: 'â¡ï¸ Next', action: `view_redundancy_group:${index + 1}` });
                buttons.push({ label: 'ğŸ—‘ï¸ Delete Others', action: `merge_keep_first:${index}` });

                return { message: result, buttons };
            },

            // Navigate to next redundancy group
            'next_redundancy_group': () => {
                const groups = window.chatRedundancyGroups;
                if (!groups || groups.length === 0) {
                    return 'âš ï¸ No redundancy groups. Run "find redundancies" first.';
                }

                const current = window.chatCurrentGroupIndex || 0;
                const next = (current + 1) % groups.length;
                return COMMAND_REGISTRY['view_redundancy_group'](next.toString());
            },

            // Merge: keep first node, delete others in group
            'merge_keep_first': (indexStr) => {
                const groups = window.chatRedundancyGroups;
                if (!groups || groups.length === 0) {
                    return 'âš ï¸ No redundancy groups. Run "find redundancies" first.';
                }

                const index = parseInt(indexStr) || 0;
                const group = groups[index];
                if (!group || group.length < 2) {
                    return 'âŒ Invalid group.';
                }

                // Keep first, delete the rest
                const keeper = group[0];
                const toDelete = group.slice(1);
                let deletedCount = 0;

                // Save state before deletion
                if (typeof saveState === 'function') {
                    saveState('Merge redundancies - keep ' + keeper.name);
                }

                toDelete.forEach(nodeInfo => {
                    // Find and delete node
                    function deleteFromTree(parent, targetId) {
                        const childArrays = ['children', 'items', 'subItems'];
                        for (const prop of childArrays) {
                            if (parent[prop]) {
                                const idx = parent[prop].findIndex(c => c.id === targetId);
                                if (idx !== -1) {
                                    parent[prop].splice(idx, 1);
                                    deletedCount++;
                                    return true;
                                }
                                for (const child of parent[prop]) {
                                    if (deleteFromTree(child, targetId)) return true;
                                }
                            }
                        }
                        return false;
                    }
                    deleteFromTree(capexTree, nodeInfo.id);
                });

                // Re-render
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                // Remove this group from the list
                groups.splice(index, 1);
                window.chatRedundancyGroups = groups;

                const result = `âœ… Merged! Kept "${keeper.name}", deleted ${deletedCount} duplicate(s).\n\n${groups.length} groups remaining.`;

                if (groups.length > 0) {
                    return {
                        message: result,
                        buttons: [
                            { label: 'â¡ï¸ Next Group', action: 'view_redundancy_group:0' },
                            { label: 'ğŸ”€ Auto-Merge All', action: 'auto_merge_redundancies' }
                        ]
                    };
                }
                return result + '\n\nğŸ‰ All redundancies resolved!';
            },

            // Auto-merge all redundancy groups (keeps first in each)
            'auto_merge_redundancies': () => {
                const groups = window.chatRedundancyGroups;
                if (!groups || groups.length === 0) {
                    return 'âš ï¸ No redundancy groups. Run "find redundancies" first.';
                }

                if (typeof saveState === 'function') {
                    saveState('Auto-merge all redundancies');
                }

                let totalDeleted = 0;
                const kept = [];

                groups.forEach(group => {
                    kept.push(group[0].name);
                    group.slice(1).forEach(nodeInfo => {
                        function deleteFromTree(parent, targetId) {
                            const childArrays = ['children', 'items', 'subItems'];
                            for (const prop of childArrays) {
                                if (parent[prop]) {
                                    const idx = parent[prop].findIndex(c => c.id === targetId);
                                    if (idx !== -1) {
                                        parent[prop].splice(idx, 1);
                                        totalDeleted++;
                                        return true;
                                    }
                                    for (const child of parent[prop]) {
                                        if (deleteFromTree(child, targetId)) return true;
                                    }
                                }
                            }
                            return false;
                        }
                        deleteFromTree(capexTree, nodeInfo.id);
                    });
                });

                // Re-render
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                window.chatRedundancyGroups = [];

                return `ğŸ‰ **Auto-merge complete!**\n\nDeleted ${totalDeleted} duplicate nodes across ${groups.length} groups.\n\nKept: ${kept.slice(0, 5).join(', ')}${kept.length > 5 ? ` ...and ${kept.length - 5} more` : ''}\n\nğŸ’¡ Use Undo if you need to revert.`;
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 392: LIFETREE HEALTH CHECK - Proactive diagnostics
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'lifetree_health_check': () => {
                const phases = capexTree?.children || [];
                const pattern = capexTree?.pattern?.key || 'generic';

                // Only meaningful for lifetree pattern
                if (pattern !== 'lifetree') {
                    return 'âš ï¸ Health check is optimized for LifeTree pattern. Current pattern: ' + pattern;
                }

                const issues = {
                    emptyPhases: [],
                    redundantPeriods: [],
                    dataIntegrity: [],
                    sparseItems: [],
                    chronologyIssues: []
                };

                // 1. Empty phases detection
                phases.forEach(phase => {
                    const itemCount = (phase.items || phase.children || phase.subItems || []).length;
                    if (itemCount === 0) {
                        issues.emptyPhases.push({ phase, name: phase.name });
                    }
                });

                // 2. Redundant periods (overlapping decades/time ranges)
                const periodPatterns = [];
                phases.forEach(phase => {
                    const name = (phase.name || '').toLowerCase();
                    // Extract years from phase names
                    const yearMatches = name.match(/\d{4}/g);
                    const periodKeywords = ['legacy', 'rehabilitation', 'aftermath', 'canonization', 'memory', 'heritage'];
                    const hasLegacyKeyword = periodKeywords.some(kw => name.includes(kw));

                    if (yearMatches || hasLegacyKeyword) {
                        periodPatterns.push({
                            phase,
                            years: yearMatches || [],
                            isLegacy: hasLegacyKeyword,
                            name: phase.name
                        });
                    }
                });

                // Find overlapping legacy sections
                const legacyPhases = periodPatterns.filter(p => p.isLegacy);
                if (legacyPhases.length > 1) {
                    issues.redundantPeriods.push({
                        type: 'legacy_overlap',
                        phases: legacyPhases.map(p => p.name),
                        suggestion: 'Consolidate into single "Afterlife & Legacy" section'
                    });
                }

                // 3. Data integrity - count claimed vs actual events
                let totalEvents = 0;
                let phasesWithZeroDisplay = 0;
                phases.forEach(phase => {
                    const items = phase.items || phase.children || phase.subItems || [];
                    totalEvents += items.length;
                    items.forEach(item => {
                        totalEvents += (item.subItems || item.children || []).length;
                    });
                });

                // 4. Sparse items (events without subtasks that should have detail)
                const significantEvents = ['battle', 'siege', 'trial', 'execution', 'coronation', 'campaign'];
                phases.forEach(phase => {
                    (phase.items || phase.children || phase.subItems || []).forEach(item => {
                        const nameLower = (item.name || '').toLowerCase();
                        const hasSubitems = (item.subItems || item.children || []).length > 0;
                        if (!hasSubitems && significantEvents.some(evt => nameLower.includes(evt))) {
                            issues.sparseItems.push({ item, phaseName: phase.name });
                        }
                    });
                });

                // 5. Chronology issues - check for out-of-order phases
                const yearsInOrder = [];
                phases.forEach(phase => {
                    const match = (phase.name || '').match(/\d{4}/);
                    if (match) yearsInOrder.push({ year: parseInt(match[0]), name: phase.name });
                });
                for (let i = 1; i < yearsInOrder.length; i++) {
                    if (yearsInOrder[i].year < yearsInOrder[i-1].year) {
                        issues.chronologyIssues.push({
                            before: yearsInOrder[i-1].name,
                            after: yearsInOrder[i].name
                        });
                    }
                }

                // Store for cleanup actions
                window.lifetreeHealthIssues = issues;

                // Build report
                const totalIssues = issues.emptyPhases.length + issues.redundantPeriods.length +
                    issues.sparseItems.length + issues.chronologyIssues.length;

                if (totalIssues === 0) {
                    return 'âœ… **LifeTree Health: Excellent!**\n\n' +
                        `ğŸ“Š ${phases.length} phases, ${totalEvents} total events\n\n` +
                        'No structural issues detected. Your tree is well-organized!';
                }

                let report = `ğŸ©º **LifeTree Health Check**\n\n`;
                report += `ğŸ“Š ${phases.length} phases â€¢ ${totalEvents} events\n\n`;

                const priorities = [];

                // Priority 1: Redundant periods (most impactful)
                if (issues.redundantPeriods.length > 0) {
                    const rp = issues.redundantPeriods[0];
                    report += `ğŸ”´ **Pri 1: Redundant Sections** (${rp.phases.length} overlapping)\n`;
                    report += `   ${rp.phases.slice(0, 3).join(', ')}${rp.phases.length > 3 ? '...' : ''}\n`;
                    report += `   ğŸ’¡ ${rp.suggestion}\n\n`;
                    priorities.push({ label: 'ğŸ§¹ Pri 1: Consolidate Legacy', action: 'lifetree_consolidate_legacy' });
                }

                // Priority 2: Chronology issues
                if (issues.chronologyIssues.length > 0) {
                    report += `ğŸŸ  **Pri 2: Out of Order** (${issues.chronologyIssues.length} issues)\n`;
                    issues.chronologyIssues.slice(0, 2).forEach(ci => {
                        report += `   "${ci.after}" appears after "${ci.before}"\n`;
                    });
                    report += '\n';
                    priorities.push({ label: 'ğŸ”„ Pri 2: Fix Order', action: 'lifetree_fix_chronology' });
                }

                // Priority 3: Empty phases
                if (issues.emptyPhases.length > 0) {
                    report += `ğŸŸ¡ **Pri 3: Empty Sections** (${issues.emptyPhases.length})\n`;
                    issues.emptyPhases.slice(0, 3).forEach(ep => {
                        report += `   "${ep.name}" has 0 events\n`;
                    });
                    report += '\n';
                    priorities.push({ label: 'â• Pri 3: Fill Empty', action: 'lifetree_fill_empty' });
                }

                // Priority 4: Sparse items
                if (issues.sparseItems.length > 0) {
                    report += `ğŸ”µ **Pri 4: Sparse Events** (${issues.sparseItems.length} need detail)\n`;
                    issues.sparseItems.slice(0, 3).forEach(si => {
                        report += `   "${si.item.name}" lacks subtasks\n`;
                    });
                    report += '\n';
                    priorities.push({ label: 'ğŸ“ Pri 4: Add Detail', action: 'lifetree_enrich_sparse' });
                }

                report += `\nWhich fix should I execute first?`;

                // Add "Execute All" if multiple priorities
                if (priorities.length > 1) {
                    priorities.push({ label: 'âš¡ Execute All', action: 'lifetree_execute_all_fixes' });
                }

                return { message: report, buttons: priorities };
            },

            // Consolidate legacy sections into one
            'lifetree_consolidate_legacy': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues || !issues.redundantPeriods.length) {
                    return 'âš ï¸ No redundant sections found. Run health check first.';
                }

                const rp = issues.redundantPeriods[0];
                const legacyPhaseNames = rp.phases;

                // Find all legacy phases and their items
                const allLegacyItems = [];
                const phasesToRemove = [];

                capexTree.children.forEach((phase, idx) => {
                    if (legacyPhaseNames.includes(phase.name)) {
                        (phase.items || phase.children || phase.subItems || []).forEach(item => {
                            allLegacyItems.push({ ...item, sourcePhase: phase.name });
                        });
                        phasesToRemove.push(idx);
                    }
                });

                if (phasesToRemove.length < 2) {
                    return 'âš ï¸ Not enough legacy phases to consolidate.';
                }

                // Save state before changes
                if (typeof saveState === 'function') {
                    saveState('Consolidate legacy sections');
                }

                // Remove old phases (in reverse order to preserve indices)
                phasesToRemove.sort((a, b) => b - a).forEach(idx => {
                    capexTree.children.splice(idx, 1);
                });

                // Create consolidated phase
                const consolidatedPhase = {
                    id: 'phase-legacy-' + Date.now(),
                    name: 'Afterlife & Legacy',
                    type: 'phase',
                    icon: 'ğŸ›ï¸',
                    expanded: true,
                    description: 'Consolidated legacy, rehabilitation, and canonization events',
                    items: allLegacyItems.map(item => ({
                        ...item,
                        id: item.id || 'item-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5)
                    }))
                };

                // Add to end
                capexTree.children.push(consolidatedPhase);

                // Re-render
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return {
                    message: `âœ… **Consolidated ${phasesToRemove.length} legacy sections!**\n\n` +
                        `Created "Afterlife & Legacy" with ${allLegacyItems.length} events.\n\n` +
                        `ğŸ’¡ Use Undo to revert if needed.`,
                    buttons: [
                        { label: 'âœ… Continue to Pri 2', action: 'lifetree_health_check' },
                        { label: 'â†©ï¸ Undo', action: 'undo' }
                    ]
                };
            },

            // Fix chronological order
            'lifetree_fix_chronology': () => {
                const phases = capexTree?.children || [];

                // Extract year from each phase for sorting
                const phasesWithYears = phases.map((phase, originalIndex) => {
                    const match = (phase.name || '').match(/\d{4}/);
                    return {
                        phase,
                        year: match ? parseInt(match[0]) : 9999, // Put no-year phases at end
                        originalIndex
                    };
                });

                // Check if already sorted
                let needsSort = false;
                for (let i = 1; i < phasesWithYears.length; i++) {
                    if (phasesWithYears[i].year < phasesWithYears[i-1].year) {
                        needsSort = true;
                        break;
                    }
                }

                if (!needsSort) {
                    return 'âœ… Phases are already in chronological order!';
                }

                // Save state
                if (typeof saveState === 'function') {
                    saveState('Fix chronological order');
                }

                // Sort by year
                phasesWithYears.sort((a, b) => a.year - b.year);
                capexTree.children = phasesWithYears.map(p => p.phase);

                // Re-render
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return {
                    message: `âœ… **Phases reordered chronologically!**\n\n` +
                        `${phases.length} phases sorted from earliest to latest.\n\n` +
                        `ğŸ’¡ Use Undo to revert if needed.`,
                    buttons: [
                        { label: 'âœ… Continue Health Check', action: 'lifetree_health_check' },
                        { label: 'â†©ï¸ Undo', action: 'undo' }
                    ]
                };
            },

            // Navigate to first empty phase for filling
            'lifetree_fill_empty': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues || !issues.emptyPhases.length) {
                    return 'âœ… No empty phases found!';
                }

                const emptyPhase = issues.emptyPhases[0];

                // Navigate to the empty phase
                if (typeof window.chatFocusedNode !== 'undefined') {
                    window.chatFocusedNode = emptyPhase.phase;
                }

                return {
                    message: `ğŸ“ **Focused on: "${emptyPhase.name}"**\n\n` +
                        `This section is empty. What would you like to add?\n\n` +
                        `ğŸ’¡ Describe an event or memory for this period.`,
                    buttons: [
                        { label: 'ğŸ—‘ï¸ Delete Empty Phase', action: `delete_phase:${emptyPhase.phase.id}` },
                        { label: 'â­ï¸ Skip to Next', action: 'lifetree_fill_empty_next' },
                        { label: 'â†©ï¸ Back to Health Check', action: 'lifetree_health_check' }
                    ]
                };
            },

            // Skip to next empty phase
            'lifetree_fill_empty_next': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues || issues.emptyPhases.length <= 1) {
                    return 'âœ… No more empty phases!';
                }
                issues.emptyPhases.shift(); // Remove first
                return COMMAND_REGISTRY['lifetree_fill_empty']();
            },

            // Enrich sparse items with AI suggestions
            'lifetree_enrich_sparse': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues || !issues.sparseItems.length) {
                    return 'âœ… No sparse items found!';
                }

                const sparse = issues.sparseItems[0];

                return {
                    message: `ğŸ“ **Sparse Event: "${sparse.item.name}"**\n` +
                        `In: ${sparse.phaseName}\n\n` +
                        `This significant event has no subtasks. Would you like me to:\n\n` +
                        `â€¢ Add detailed subtasks (who, what, when, where)\n` +
                        `â€¢ Research historical context\n` +
                        `â€¢ Generate scholarly analysis`,
                    buttons: [
                        { label: 'âœ¨ AI Deep Dive', action: `deep_dive:${sparse.item.id}` },
                        { label: 'â­ï¸ Skip', action: 'lifetree_enrich_next' },
                        { label: 'â†©ï¸ Back', action: 'lifetree_health_check' }
                    ]
                };
            },

            // Skip to next sparse item
            'lifetree_enrich_next': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues || issues.sparseItems.length <= 1) {
                    return 'âœ… No more sparse items!';
                }
                issues.sparseItems.shift();
                return COMMAND_REGISTRY['lifetree_enrich_sparse']();
            },

            // Execute all fixes in sequence
            'lifetree_execute_all_fixes': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues) {
                    return 'âš ï¸ Run health check first.';
                }

                let executed = [];

                // Execute in priority order
                if (issues.redundantPeriods.length > 0) {
                    const result = COMMAND_REGISTRY['lifetree_consolidate_legacy']();
                    executed.push('Consolidated legacy sections');
                }

                // Re-run health check after fixes
                return {
                    message: `âš¡ **Executing Priority Fixes...**\n\n` +
                        (executed.length > 0 ? `âœ… ${executed.join('\nâœ… ')}\n\n` : '') +
                        `Checking for remaining issues...`,
                    buttons: [
                        { label: 'ğŸ©º Run Health Check Again', action: 'lifetree_health_check' }
                    ]
                };
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 361: HYPEREDGE QUERY COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // BUILD 522: Find/suggest hyperedges by analyzing tree structure
            'find_hyperedges': () => {
                if (typeof detectSuggestedHyperedges !== 'function') {
                    return 'âŒ Hyperedge detection not available.';
                }

                const suggestions = detectSuggestedHyperedges();
                const existing = capexTree.hyperedges || [];

                if (suggestions.length === 0 && existing.length === 0) {
                    return {
                        message: 'ğŸ” No hyperedge suggestions found.\n\nThe tree may need more nodes with shared properties, similar names, or assignees to detect meaningful connections.\n\nYou can manually create hyperedges by:\n1. Select 2+ nodes in Canvas view\n2. Right-click â†’ Create Hyperedge',
                        buttons: [
                            { label: 'ğŸ” Open Query Builder', action: 'open_query_builder' },
                            { label: 'ğŸ“Š Switch to Canvas', action: 'switch_view:canvas' }
                        ]
                    };
                }

                let response = 'ğŸ”— **Hyperedge Analysis**\n\n';

                if (existing.length > 0) {
                    response += `**Existing Hyperedges (${existing.length}):**\n`;
                    existing.slice(0, 5).forEach(h => {
                        const nodeCount = (h.nodeIds || []).length;
                        response += `â€¢ **${h.label || h.name}** - ${nodeCount} nodes (${h.type || 'manual'})\n`;
                    });
                    if (existing.length > 5) {
                        response += `...and ${existing.length - 5} more\n`;
                    }
                    response += '\n';
                }

                if (suggestions.length > 0) {
                    response += `**Suggested Hyperedges (${suggestions.length}):**\n`;
                    suggestions.slice(0, 5).forEach(s => {
                        const nodeCount = (s.nodeIds || []).length;
                        response += `â€¢ **${s.label}** - ${nodeCount} nodes (${s.description || s.type})\n`;
                    });
                    if (suggestions.length > 5) {
                        response += `...and ${suggestions.length - 5} more\n`;
                    }
                    response += '\nğŸ’¡ Open the Hyperedge Panel (ğŸ”— button) to accept or dismiss suggestions.';
                }

                return {
                    message: response,
                    buttons: [
                        { label: 'ğŸ”— Open Hyperedge Panel', action: 'toggle_hyperedge_panel' },
                        { label: 'ğŸ“Š Switch to Canvas', action: 'switch_view:canvas' }
                    ]
                };
            },

            // Alias for find_hyperedges
            'suggest_hyperedges': () => COMMAND_REGISTRY['find_hyperedges'](),

            // Create hyperedge from stored query results
            'create_hyperedge_from_query': (conditionsJson) => {
                const matches = chatState.lastQueryMatches;
                const description = chatState.lastQueryDescription;

                if (!matches || matches.length < 2) {
                    return 'âš ï¸ No valid query results. Try asking again!';
                }

                if (typeof saveState === 'function') {
                    saveState('Create Hyperedge from Query');
                }

                const label = description || 'Query Result';
                const color = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');

                const hyperedge = addHyperedge(
                    'query',
                    label,
                    matches.map(m => m.id),
                    { color, description: `Query: ${description}`, source: 'treebeard' }
                );

                if (hyperedge) {
                    hyperedge.color = color;
                }

                if (typeof renderCanvas === 'function') renderCanvas();

                return `âœ… Created hyperedge **"${label}"** with ${matches.length} nodes!\n\nğŸ¯ Switch to Canvas view to see it visualized.`;
            },

            // Highlight query results in canvas
            'highlight_query_results': () => {
                const matches = chatState.lastQueryMatches;

                if (!matches || matches.length === 0) {
                    return 'âš ï¸ No query results to highlight.';
                }

                // Select nodes in canvas
                if (typeof window.selectedCanvasNodes !== 'undefined') {
                    window.selectedCanvasNodes = matches;
                }

                // Highlight visually
                matches.forEach(node => {
                    const nodeEl = document.querySelector(`.canvas-node[data-id="${node.id}"]`);
                    if (nodeEl) {
                        nodeEl.classList.add('selected');
                        nodeEl.style.boxShadow = '0 0 20px rgba(99, 102, 241, 0.6)';
                    }
                });

                // Switch to canvas view if not already there
                const container = document.getElementById('canvas-container');
                if (container && !container.classList.contains('active')) {
                    document.getElementById('toggle-view-mode')?.click();
                }

                return `ğŸ¯ Highlighted ${matches.length} matching nodes in Canvas view!`;
            },

            // Open query builder modal
            'open_query_builder': () => {
                if (typeof showQueryBuilderModal === 'function') {
                    showQueryBuilderModal();
                    return 'ğŸ” Query Builder opened!';
                }
                return 'âŒ Query Builder not available.';
            },

            // BUILD 522: Toggle hyperedge visibility panel
            'toggle_hyperedge_panel': () => {
                if (typeof toggleHyperedgePanel === 'function') {
                    toggleHyperedgePanel();
                    return null; // No message needed, panel opens visually
                }
                return 'âŒ Hyperedge panel not available.';
            },

            // BUILD 600: Hyperedge focus mode - browse a single hyperedge
            'focus_hyperedge': (nameOrId) => {
                const hyperedges = capexTree.hyperedges || [];
                if (hyperedges.length === 0) {
                    return 'âš ï¸ No hyperedges in this tree. Create hyperedges first by selecting nodes in Canvas view â†’ Right-click â†’ Create Hyperedge.';
                }

                // If no arg provided, list available hyperedges
                if (!nameOrId) {
                    let response = 'ğŸ”— **Available Hyperedges:**\n\n';
                    hyperedges.forEach((h, idx) => {
                        const nodeCount = (h.nodeIds || []).length;
                        response += `${idx + 1}. **${h.label || h.name || h.id}** - ${nodeCount} nodes\n`;
                    });
                    response += '\nğŸ’¡ Use `focus_hyperedge:<name>` to focus on one.';
                    return response;
                }

                // Find hyperedge by name or id (case-insensitive)
                const searchTerm = nameOrId.toLowerCase();
                const hyperedge = hyperedges.find(h =>
                    h.id === nameOrId ||
                    (h.label || '').toLowerCase().includes(searchTerm) ||
                    (h.name || '').toLowerCase().includes(searchTerm)
                );

                if (!hyperedge) {
                    return `âŒ Hyperedge "${nameOrId}" not found.\n\nAvailable: ${hyperedges.map(h => h.label || h.name || h.id).join(', ')}`;
                }

                // Switch to canvas view if needed
                if (typeof viewMode !== 'undefined' && viewMode !== 'canvas') {
                    document.getElementById('view-canvas-btn')?.click();
                }

                // Focus on the hyperedge
                if (typeof focusOnHyperedge === 'function') {
                    setTimeout(() => focusOnHyperedge(hyperedge.id), 300);
                    return `ğŸ¯ Focusing on hyperedge **"${hyperedge.label || hyperedge.name}"** with ${(hyperedge.nodeIds || []).length} nodes.\n\nğŸ’¡ Use \`exit_focus\` to return to full canvas view.`;
                }
                return 'âŒ Focus mode not available.';
            },

            // BUILD 600: Exit hyperedge focus mode
            'exit_focus': () => {
                if (typeof exitFocusMode === 'function') {
                    exitFocusMode();
                    return 'ğŸ”™ Exited focus mode - showing all nodes.';
                }
                return 'âŒ Not in focus mode.';
            },

            // BUILD 600: List all hyperedges with details
            'list_hyperedges': () => {
                const hyperedges = capexTree.hyperedges || [];
                if (hyperedges.length === 0) {
                    return 'ğŸ“‹ No hyperedges defined in this tree.\n\nğŸ’¡ Create hyperedges by:\n1. Switch to Canvas view\n2. Select 2+ nodes\n3. Right-click â†’ Create Hyperedge';
                }

                let response = `ğŸ“‹ **Hyperedges in Tree (${hyperedges.length}):**\n\n`;
                hyperedges.forEach((h, idx) => {
                    const nodeCount = (h.nodeIds || []).length;
                    const visible = h.visible !== false ? 'ğŸ‘ï¸' : 'ğŸ™ˆ';
                    response += `${idx + 1}. ${visible} **${h.label || h.name || h.id}**\n`;
                    response += `   â€¢ Nodes: ${nodeCount} | Type: ${h.type || 'manual'}\n`;
                    if (h.description) response += `   â€¢ ${h.description.substring(0, 50)}...\n`;
                });
                response += '\nğŸ’¡ Commands: `focus_hyperedge:<name>`, `toggle_hyperedge_panel`';
                return response;
            },

            // BUILD 612: Show/Hide all hyperedges (edges) in canvas
            'show_edges': () => {
                if (typeof showAllHyperedges === 'function') {
                    showAllHyperedges();
                    return 'ğŸ‘ï¸ Showing all hyperedges (edges) in canvas view.';
                }
                return 'âš ï¸ Hyperedge visibility requires Canvas view.';
            },

            'hide_edges': () => {
                if (typeof hideAllHyperedges === 'function') {
                    hideAllHyperedges();
                    return 'ğŸ™ˆ Hiding all hyperedges (edges) in canvas view.';
                }
                return 'âš ï¸ Hyperedge visibility requires Canvas view.';
            },

            'toggle_edges': () => {
                // Check if any edges are currently visible
                const hyperedges = capexTree.hyperedges || [];
                if (hyperedges.length === 0) {
                    return 'ğŸ“‹ No hyperedges to toggle. Create hyperedges first.';
                }
                const hiddenCount = window.hiddenHyperedges?.size || 0;
                if (hiddenCount === 0) {
                    // All visible, hide them
                    if (typeof hideAllHyperedges === 'function') hideAllHyperedges();
                    return 'ğŸ™ˆ Toggled edges OFF - all hyperedges hidden.';
                } else {
                    // Some hidden, show all
                    if (typeof showAllHyperedges === 'function') showAllHyperedges();
                    return 'ğŸ‘ï¸ Toggled edges ON - all hyperedges visible.';
                }
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 615: CHROME CAPABILITY COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'list_capabilities': () => {
                const capabilities = findCapabilityNodes(capexTree);
                if (capabilities.length === 0) {
                    return 'ğŸ” No capabilities defined yet.\n\nğŸ’¡ Create one with:\nâ€¢ `create_capability:Chase Balance|chase.com|Read account balance`\nâ€¢ Or say "create capability for Chase balance"';
                }

                let response = `ğŸ” **Capabilities (${capabilities.length}):**\n\n`;
                capabilities.forEach((cap, idx) => {
                    const status = cap.status || 'untested';
                    const statusEmoji = { healthy: 'âœ…', degraded: 'âš ï¸', broken: 'âŒ', untested: 'â“' }[status] || 'â“';
                    const perms = (cap.allow || ['read', 'navigate']).join(', ');
                    response += `${idx + 1}. ${statusEmoji} **${cap.name}**\n`;
                    response += `   â€¢ Site: ${cap.site} | Permissions: ${perms}\n`;
                    response += `   â€¢ Goal: ${cap.goal || 'Not specified'}\n\n`;
                });
                response += 'ğŸ’¡ Commands: `test_capability:<name>`, `create_capability:<name>|<site>|<goal>`';
                return response;
            },

            'create_capability': (args) => {
                if (!args) {
                    showCreateCapabilityModal();
                    return 'ğŸ” Opening capability creation form...';
                }

                // Parse args: "name|site|goal"
                const parts = args.split('|').map(s => s.trim());
                if (parts.length < 3) {
                    return 'âš ï¸ Format: `create_capability:Name|site.com|What it does`\n\nExample: `create_capability:Chase Balance|chase.com|Read checking account balance`';
                }

                const [name, site, goal] = parts;
                const newCap = CAPABILITY_SCHEMA.create({ name, site, goal });

                // BUILD 616: Add to global capabilities registry (not current tree)
                const category = addCapabilityToRegistry(newCap);

                return `ğŸ” Created capability: **${name}**\nâ€¢ Site: ${site}\nâ€¢ Goal: ${goal}\nâ€¢ Category: ${category}\nâ€¢ Permissions: read, navigate (default)\n\nğŸ’¡ View with \`view_capabilities\` or test with \`test_capability:${name}\``;
            },

            'test_capability': (capName) => {
                if (!capName) {
                    return 'âš ï¸ Specify capability name. Example: `test_capability:Chase Balance`';
                }

                // BUILD 616: Use global capabilities registry
                const capabilities = findCapabilityNodes();
                const searchTerm = capName.toLowerCase();
                const matched = capabilities.find(c => (c.name || '').toLowerCase().includes(searchTerm));

                if (!matched) {
                    const available = capabilities.map(c => c.name).join(', ') || 'None defined';
                    return `âŒ No capability matching "${capName}".\n\nAvailable: ${available}`;
                }

                // Check if Chrome extension is connected
                if (typeof mcpBridgeState !== 'undefined' && mcpBridgeState.extensionConnected) {
                    // Dispatch test to Chrome extension via MCP
                    showToast(`ğŸ§ª Testing ${matched.name}...`, 'info', 3000);

                    // Update status to testing
                    matched.status = 'untested';
                    matched.lastTestedAt = new Date().toISOString();

                    // For now, just simulate - actual test would go through MCP bridge
                    setTimeout(() => {
                        matched.status = 'healthy';
                        matched.lastSuccessAt = new Date().toISOString();
                        matched.failureStreak = 0;
                        saveCapabilitiesTree(); // Save status update
                        showToast(`âœ… ${matched.name} is healthy!`, 'success');
                    }, 2000);

                    return `ğŸ§ª Testing **${matched.name}**...\n\nChecking if ${matched.site} is accessible and selectors work.`;
                } else {
                    return `âš ï¸ Chrome extension not connected.\n\nTo test capabilities:\n1. Install TreeListy Chrome Extension\n2. Start MCP Bridge: \`node packages/treelisty-mcp-bridge/src/bridge.js\`\n3. Ensure you're logged into ${matched.site}`;
                }
            },

            // BUILD 616: View capabilities registry tree
            'view_capabilities': () => {
                return viewCapabilitiesTree();
            },

            // BUILD 616: Return from capabilities tree
            'back_from_capabilities': () => {
                return returnFromCapabilitiesTree();
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 600: CANVAS PHASE FILTERING
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Filter canvas to show only specific phases
            'filter_phases': (phaseName) => {
                const phases = capexTree.children || [];
                if (phases.length === 0) {
                    return 'âš ï¸ No phases in this tree.';
                }

                // If no arg, list phases and their visibility
                if (!phaseName) {
                    let response = 'ğŸ“‹ **Phase Visibility:**\n\n';
                    phases.forEach((p, idx) => {
                        const visible = p.showInCanvas !== false ? 'ğŸ‘ï¸' : 'ğŸ™ˆ';
                        response += `${idx + 1}. ${visible} **${p.name}**\n`;
                    });
                    response += '\nğŸ’¡ Commands:\n';
                    response += 'â€¢ `show_phase:<name>` - Show a phase in canvas\n';
                    response += 'â€¢ `hide_phase:<name>` - Hide a phase from canvas\n';
                    response += 'â€¢ `show_all_phases` - Show all phases\n';
                    response += 'â€¢ `solo_phase:<name>` - Show only one phase';
                    return response;
                }

                // Try to match the phase name
                const searchTerm = phaseName.toLowerCase();
                const matchedPhases = phases.filter(p =>
                    (p.name || '').toLowerCase().includes(searchTerm)
                );

                if (matchedPhases.length === 0) {
                    return `âŒ No phase matching "${phaseName}".\n\nAvailable: ${phases.map(p => p.name).join(', ')}`;
                }

                // Toggle the matched phases visibility
                matchedPhases.forEach(p => {
                    p.showInCanvas = p.showInCanvas === false ? true : false;
                });

                if (typeof renderCanvas === 'function') renderCanvas();

                const nowVisible = matchedPhases.every(p => p.showInCanvas !== false);
                return `${nowVisible ? 'ğŸ‘ï¸ Showing' : 'ğŸ™ˆ Hiding'} phase(s): ${matchedPhases.map(p => p.name).join(', ')}`;
            },

            // Show a specific phase in canvas
            'show_phase': (phaseName) => {
                if (!phaseName) return 'âš ï¸ Specify phase name. Example: `show_phase:Existentialist`';

                const phases = capexTree.children || [];
                const searchTerm = phaseName.toLowerCase();
                const matched = phases.filter(p => (p.name || '').toLowerCase().includes(searchTerm));

                if (matched.length === 0) {
                    return `âŒ No phase matching "${phaseName}".`;
                }

                matched.forEach(p => p.showInCanvas = true);
                if (typeof renderCanvas === 'function') renderCanvas();

                return `ğŸ‘ï¸ Now showing: ${matched.map(p => p.name).join(', ')}`;
            },

            // Hide a specific phase from canvas
            'hide_phase': (phaseName) => {
                if (!phaseName) return 'âš ï¸ Specify phase name. Example: `hide_phase:Materialist`';

                const phases = capexTree.children || [];
                const searchTerm = phaseName.toLowerCase();
                const matched = phases.filter(p => (p.name || '').toLowerCase().includes(searchTerm));

                if (matched.length === 0) {
                    return `âŒ No phase matching "${phaseName}".`;
                }

                matched.forEach(p => p.showInCanvas = false);
                if (typeof renderCanvas === 'function') renderCanvas();

                return `ğŸ™ˆ Now hidden: ${matched.map(p => p.name).join(', ')}`;
            },

            // Show all phases
            'show_all_phases': () => {
                const phases = capexTree.children || [];
                phases.forEach(p => p.showInCanvas = true);
                if (typeof renderCanvas === 'function') renderCanvas();
                return `ğŸ‘ï¸ All ${phases.length} phases now visible in Canvas view.`;
            },

            // Solo a phase (show only one, hide all others)
            'solo_phase': (phaseName) => {
                if (!phaseName) return 'âš ï¸ Specify phase name. Example: `solo_phase:Existentialist`';

                const phases = capexTree.children || [];
                const searchTerm = phaseName.toLowerCase();
                const matched = phases.find(p => (p.name || '').toLowerCase().includes(searchTerm));

                if (!matched) {
                    return `âŒ No phase matching "${phaseName}".`;
                }

                // Hide all phases except the matched one
                phases.forEach(p => {
                    p.showInCanvas = (p.id === matched.id);
                });
                if (typeof renderCanvas === 'function') renderCanvas();

                return `ğŸ¯ Solo mode: Showing only **${matched.name}**\n\nğŸ’¡ Use \`show_all_phases\` to show all again.`;
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 600: CANVAS CAMERA FOCUS COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Focus camera on a specific node
            'focus_camera': (nodeName) => {
                if (!nodeName) {
                    return 'âš ï¸ Specify node to focus on. Example: `focus_camera:Kierkegaard`';
                }

                // Find the node by name
                let targetNode = null;
                function findNode(node) {
                    if (targetNode) return;
                    if ((node.name || '').toLowerCase().includes(nodeName.toLowerCase())) {
                        targetNode = node;
                        return;
                    }
                    (node.items || node.subItems || node.children || []).forEach(findNode);
                }
                findNode(capexTree);

                if (!targetNode) {
                    return `âŒ No node matching "${nodeName}".`;
                }

                // Switch to canvas if needed
                if (typeof viewMode !== 'undefined' && viewMode !== 'canvas') {
                    document.getElementById('view-canvas-btn')?.click();
                }

                // Calculate camera position to center on node
                const nodeX = targetNode.canvasX || 0;
                const nodeY = targetNode.canvasY || 0;
                const containerWidth = document.getElementById('canvas-container')?.offsetWidth || 1200;
                const containerHeight = document.getElementById('canvas-container')?.offsetHeight || 800;

                setTimeout(() => {
                    if (typeof canvasPan !== 'undefined' && typeof canvasZoom !== 'undefined') {
                        canvasPan = {
                            x: (containerWidth / 2) - (nodeX * canvasZoom),
                            y: (containerHeight / 2) - (nodeY * canvasZoom)
                        };
                        if (typeof updateCanvasTransform === 'function') updateCanvasTransform();
                        if (typeof updateMinimap === 'function') updateMinimap();
                    }
                }, 300);

                return `ğŸ“ Camera focused on **${targetNode.name}**`;
            },

            // Zoom to fit all visible nodes
            'zoom_fit': () => {
                if (typeof viewMode !== 'undefined' && viewMode !== 'canvas') {
                    return 'âš ï¸ Switch to Canvas view first.';
                }

                // Get all visible canvas nodes
                const nodes = document.querySelectorAll('.canvas-node');
                if (nodes.length === 0) {
                    return 'âš ï¸ No nodes visible in canvas.';
                }

                // Calculate bounding box
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                nodes.forEach(node => {
                    const rect = node.getBoundingClientRect();
                    const style = window.getComputedStyle(node);
                    const left = parseFloat(node.style.left) || 0;
                    const top = parseFloat(node.style.top) || 0;
                    minX = Math.min(minX, left);
                    minY = Math.min(minY, top);
                    maxX = Math.max(maxX, left + 320);
                    maxY = Math.max(maxY, top + 150);
                });

                const containerWidth = document.getElementById('canvas-container')?.offsetWidth || 1200;
                const containerHeight = document.getElementById('canvas-container')?.offsetHeight || 800;

                // Calculate zoom to fit
                const contentWidth = maxX - minX + 100;
                const contentHeight = maxY - minY + 100;
                const zoomX = containerWidth / contentWidth;
                const zoomY = containerHeight / contentHeight;
                const newZoom = Math.min(zoomX, zoomY, 1.5);

                if (typeof canvasZoom !== 'undefined' && typeof canvasPan !== 'undefined') {
                    canvasZoom = Math.max(0.2, Math.min(newZoom, 1.5));
                    canvasPan = {
                        x: (containerWidth / 2) - ((minX + contentWidth / 2) * canvasZoom),
                        y: (containerHeight / 2) - ((minY + contentHeight / 2) * canvasZoom)
                    };
                    if (typeof updateCanvasTransform === 'function') updateCanvasTransform();
                    if (typeof updateMinimap === 'function') updateMinimap();
                }

                return `ğŸ” Zoomed to fit ${nodes.length} nodes (zoom: ${Math.round(canvasZoom * 100)}%)`;
            },

            // Reset camera to default position
            'reset_camera': () => {
                if (typeof canvasZoom !== 'undefined' && typeof canvasPan !== 'undefined') {
                    canvasZoom = 1;
                    canvasPan = { x: 50, y: 50 };
                    if (typeof updateCanvasTransform === 'function') updateCanvasTransform();
                    if (typeof updateMinimap === 'function') updateMinimap();
                    return 'ğŸ”„ Camera reset to default position.';
                }
                return 'âš ï¸ Switch to Canvas view first.';
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 381: LIFETREE CONTEXTUAL RESEARCH
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Research a topic for contextual enrichment (historical photos, context)
            'research': async (topic) => {
                if (!topic) {
                    return 'âš ï¸ Please specify what to research. Example: "research Grey Nuns Hospital 1960s"';
                }

                // Get focused node for context
                const node = window.chatFocusedNode;
                const nodeName = node ? (node.name || node.title || 'the current event') : 'this event';
                const nodeDate = node?.eventDate || '';
                const nodeLocation = node?.location || '';

                // Build context-aware search query
                let searchContext = topic;
                if (nodeDate && !topic.toLowerCase().includes(nodeDate.toLowerCase())) {
                    searchContext += ` ${nodeDate}`;
                }
                if (nodeLocation && !topic.toLowerCase().includes(nodeLocation.toLowerCase())) {
                    searchContext += ` ${nodeLocation}`;
                }

                // Show research in progress
                addMessage(`ğŸ” Researching: **${topic}**\n\nSearching for historical context, photos, and information...`, 'system');

                try {
                    // Use Claude to generate research summary
                    const response = await fetch('/.netlify/functions/claude-proxy', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 1000,
                            messages: [{
                                role: 'user',
                                content: `You are a historical researcher helping build a family biography.

Research topic: "${topic}"
${nodeDate ? `Time period: ${nodeDate}` : ''}
${nodeLocation ? `Location: ${nodeLocation}` : ''}

Provide a brief, engaging research summary with:
1. **Historical Context** (2-3 sentences about what was happening in that place/time)
2. **Notable Facts** (2-3 interesting details about the institution/place)
3. **Cultural Snapshot** (what life was like - music, events, culture of the era)
4. **Photo Suggestions** (describe 2-3 types of historical photos that would enrich this story - be specific about what to look for)

Format in markdown. Be warm and conversational, like helping someone discover their family history.
If this is a hospital, mention when it was founded and any historical significance.
If this is a school, mention notable alumni or historical changes.
If this is a city/neighborhood, mention the community character of that era.`
                            }]
                        })
                    });

                    const data = await response.json();
                    const research = data.content?.[0]?.text || data.choices?.[0]?.message?.content;

                    if (research) {
                        // Store research for potential attachment
                        window.lastResearchResult = {
                            topic,
                            content: research,
                            timestamp: new Date().toISOString(),
                            nodeId: node?.id
                        };

                        // Increment TreeBeard score for research (+1)
                        if (typeof chatState !== 'undefined') {
                            chatState.treeBeardScore = (chatState.treeBeardScore || 0) + 1;
                        }

                        return {
                            message: `ğŸ“š **Research: ${topic}**\n\n${research}\n\n---\nâœ¨ *+1 TreeBeard for enriching ${nodeName}!*`,
                            buttons: [
                                { label: 'ğŸ“ Attach to Node', action: `attach_research:${node?.id || ''}` },
                                { label: 'ğŸ” Search for Photos', action: `search_photos:${encodeURIComponent(topic)}` },
                                { label: 'â• Add as Context', action: `add_context:${encodeURIComponent(research.substring(0, 500))}` }
                            ]
                        };
                    }
                    return 'âŒ Research failed - no response from AI.';
                } catch (err) {
                    console.error('Research error:', err);
                    return `âŒ Research failed: ${err.message}`;
                }
            },

            // Attach research to a node as historical context
            'attach_research': (nodeId) => {
                const research = window.lastResearchResult;
                if (!research) {
                    return 'âš ï¸ No research to attach. Run "research:{topic}" first.';
                }

                let node = null;
                if (nodeId) {
                    // Find by ID
                    function findNode(tree, id) {
                        if (tree.id === id) return tree;
                        for (const child of (tree.children || tree.items || tree.subItems || [])) {
                            const found = findNode(child, id);
                            if (found) return found;
                        }
                        return null;
                    }
                    node = findNode(capexTree, nodeId);
                }
                node = node || window.chatFocusedNode;

                if (!node) {
                    return 'âš ï¸ No node selected. Use "find [name]" first.';
                }

                // Add research as historical context field
                node.historicalContext = research.content;
                node.researchDate = research.timestamp;

                if (typeof saveState === 'function') saveState('Attached research');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                // +1 for attaching research
                if (typeof chatState !== 'undefined') {
                    chatState.treeBeardScore = (chatState.treeBeardScore || 0) + 1;
                }

                return `âœ… Research attached to "${node.name || node.title}"!\n\nâœ¨ *+1 TreeBeard for enriching this memory!*`;
            },

            // Search for historical photos (opens web search)
            'search_photos': (topic) => {
                if (!topic) {
                    return 'âš ï¸ Please specify what to search for.';
                }

                const decodedTopic = decodeURIComponent(topic);
                const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(decodedTopic + ' historical photos')}&tbm=isch`;

                // Open in new tab
                window.open(searchUrl, '_blank');

                return `ğŸ” Opened Google Images search for "${decodedTopic}" historical photos.\n\nğŸ’¡ Tip: When you find a good photo, right-click â†’ "Copy image address" â†’ then use the artifact panel to attach it to this node.`;
            },

            // Add research content as context field
            'add_context': (contextEncoded) => {
                const node = window.chatFocusedNode;
                if (!node) {
                    return 'âš ï¸ No node focused. Use "find [name]" first.';
                }

                const context = decodeURIComponent(contextEncoded);
                node.locationContext = context;

                if (typeof saveState === 'function') saveState('Added context');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `âœ… Context added to "${node.name || node.title}"!`;
            }
        };

        /**
         * BUILD 361: Detect hyperedge queries in natural language
         * Returns { matches, description, queryConditions } or null if not a query
         */
        function detectHyperedgeQuery(message) {
            const lowerMsg = message.toLowerCase();

            // Patterns for hyperedge queries
            const queryPatterns = [
                // Cost queries
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?items?\s+(?:over|above|>\s*)\s*\$?([\d,]+)k?/i, field: 'cost', operator: '>', multiplier: (m) => m.includes('k') || parseInt(m) < 1000 ? 1000 : 1 },
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?items?\s+(?:under|below|<\s*)\s*\$?([\d,]+)k?/i, field: 'cost', operator: '<', multiplier: (m) => m.includes('k') || parseInt(m) < 1000 ? 1000 : 1 },
                { pattern: /(?:expensive|high[\s-]?cost|big[\s-]?ticket)\s*items?/i, field: 'cost', operator: '>', value: 'percentile75' },

                // Status queries
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?(?:items?\s+)?(?:that\s+are\s+)?(?:in\s+progress|in-progress)/i, field: 'pmStatus', operator: 'equals', value: 'In Progress' },
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?(?:items?\s+)?(?:that\s+are\s+)?(?:done|completed|finished)/i, field: 'pmStatus', operator: 'equals', value: 'Done' },
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?(?:items?\s+)?(?:that\s+are\s+)?(?:to\s*do|pending|not\s+started)/i, field: 'pmStatus', operator: 'equals', value: 'To Do' },
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?blocked\s*items?/i, field: 'pmStatus', operator: 'equals', value: 'Blocked' },

                // Priority queries
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?(?:high[\s-]?priority|urgent|critical)\s*items?/i, field: 'pmPriority', operator: 'equals', value: 'High' },
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?low[\s-]?priority\s*items?/i, field: 'pmPriority', operator: 'equals', value: 'Low' },

                // Assignee queries
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?(?:items?\s+)?(?:assigned\s+to|owned\s+by|for)\s+(\w+)/i, field: 'pmAssignee', operator: 'contains', valueGroup: 1 },
                { pattern: /(\w+)'s\s+(?:items?|tasks?|work)/i, field: 'pmAssignee', operator: 'contains', valueGroup: 1 },

                // Description/name contains
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?items?\s+(?:with|containing|about|mentioning)\s+["']?([^"']+)["']?/i, field: 'description', operator: 'contains', valueGroup: 1 }
            ];

            // Try each pattern
            for (const qp of queryPatterns) {
                const match = message.match(qp.pattern);
                if (match) {
                    // Determine value
                    let value = qp.value;
                    if (qp.valueGroup) {
                        value = match[qp.valueGroup];
                    } else if (match[1] && !qp.value) {
                        value = match[1].replace(/,/g, '');
                        if (qp.multiplier) {
                            value = parseInt(value) * qp.multiplier(match[0]);
                        }
                    }

                    // Handle percentile value
                    if (value === 'percentile75') {
                        const allItems = [];
                        function collect(node) {
                            if (node.cost > 0) allItems.push(node);
                            (node.items || []).forEach(collect);
                            (node.children || []).forEach(c => { collect(c); (c.items || []).forEach(collect); });
                        }
                        collect(capexTree);
                        if (allItems.length > 0) {
                            const costs = allItems.map(i => i.cost).sort((a, b) => b - a);
                            value = costs[Math.floor(costs.length * 0.25)] || costs[0] || 100000;
                        } else {
                            value = 100000;
                        }
                    }

                    const conditions = [{ field: qp.field, operator: qp.operator, value: String(value) }];
                    const description = describeQuery(conditions);

                    // Execute query
                    const matches = executeHyperedgeQuery(conditions);

                    return { matches, description, queryConditions: conditions };
                }
            }

            return null; // Not a query
        }

        /**
         * BUILD 361: Execute a hyperedge query
         */
        function executeHyperedgeQuery(conditions) {
            const allItems = [];
            function collectItems(node) {
                if (node.type === 'item' || node.type === 'subtask') {
                    allItems.push(node);
                }
                (node.items || []).forEach(collectItems);
                (node.children || []).forEach(child => {
                    collectItems(child);
                    (child.items || []).forEach(collectItems);
                });
            }
            collectItems(capexTree);

            return allItems.filter(item => {
                return conditions.every(cond => {
                    const itemValue = item[cond.field];
                    const condValue = cond.value;
                    const searchStr = String(condValue).toLowerCase();

                    switch (cond.operator) {
                        case 'equals':
                            return String(itemValue || '').toLowerCase() === searchStr;
                        case 'contains':
                            // BUILD 565: Enhanced contains search - include email body, description, and name
                            const fieldsToSearch = [
                                itemValue,
                                item.name,
                                item.description,
                                item.emailBody,      // Gmail email body
                                item.fullBody,       // Full email content
                                item.senderEmail,    // Sender address
                                item.recipientEmail  // Recipient address
                            ];
                            return fieldsToSearch.some(field =>
                                String(field || '').toLowerCase().includes(searchStr)
                            );
                        case '>':
                            return Number(itemValue || 0) > Number(condValue);
                        case '<':
                            return Number(itemValue || 0) < Number(condValue);
                        default:
                            return false;
                    }
                });
            });
        }

        /**
         * BUILD 361: Describe a query in human-readable form
         */
        function describeQuery(conditions) {
            return conditions.map(c => {
                const fieldNames = {
                    cost: 'cost',
                    pmStatus: 'status',
                    pmPriority: 'priority',
                    pmAssignee: 'assignee',
                    description: 'description',
                    name: 'name',
                    // BUILD 565: Gmail field names
                    emailBody: 'email body',
                    fullBody: 'email content',
                    senderEmail: 'from',
                    recipientEmail: 'to',
                    labels: 'labels'
                };
                const opNames = { '>': 'over', '<': 'under', 'equals': '', 'contains': 'containing' };
                const field = fieldNames[c.field] || c.field;
                const op = opNames[c.operator] || c.operator;
                const val = c.field === 'cost' ? '$' + (Number(c.value) >= 1000000 ? (Number(c.value)/1000000).toFixed(1) + 'M' : (Number(c.value)/1000).toFixed(0) + 'K') : c.value;
                return `${field} ${op} ${val}`.replace(/\s+/g, ' ').trim();
            }).join(' AND ');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PLAYGROUND MODE HELPERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function getModelDisplayName(modelKey) {
            const names = {
                'claude-sonnet': 'ğŸŸ£ Claude Sonnet 4',
                'claude-opus': 'ğŸŸ£ Claude Opus 4',
                'claude-haiku': 'ğŸŸ£ Claude Haiku',
                'gpt-4o': 'ğŸŸ¢ GPT-4o',
                'gpt-4-turbo': 'ğŸŸ¢ GPT-4 Turbo',
                'gemini-pro': 'ğŸ”µ Gemini Pro',
                'gemini-flash': 'ğŸ”µ Gemini Flash'
            };
            return names[modelKey] || modelKey;
        }

        function updatePlaygroundUI(isPlayground) {
            const header = document.getElementById('chat-assistant-header');
            const title = header?.querySelector('h3');

            if (isPlayground) {
                if (title) {
                    title.innerHTML = `ğŸ® Prompt Playground <span style="font-size: 11px; opacity: 0.7; font-weight: normal;">(${getModelDisplayName(chatState.playgroundModel)})</span>`;
                }
                header?.style.setProperty('background', 'linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.15))');

                // Add model selector if not present
                if (!document.getElementById('playground-model-select')) {
                    const actionsDiv = header?.querySelector('.header-actions');
                    if (actionsDiv) {
                        const select = document.createElement('select');
                        select.id = 'playground-model-select';
                        select.style.cssText = 'padding: 4px 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #fff; font-size: 11px; cursor: pointer;';
                        select.innerHTML = `
                            <option value="claude-sonnet">Claude Sonnet</option>
                            <option value="claude-opus">Claude Opus</option>
                            <option value="gpt-4o">GPT-4o</option>
                            <option value="gemini-pro">Gemini Pro</option>
                        `;
                        select.value = chatState.playgroundModel;
                        select.onchange = (e) => {
                            chatState.playgroundModel = e.target.value;
                            updatePlaygroundUI(true);
                        };
                        actionsDiv.insertBefore(select, actionsDiv.firstChild);
                    }
                }

                // Add exit button if not present
                if (!document.getElementById('playground-exit-btn')) {
                    const actionsDiv = header?.querySelector('.header-actions');
                    if (actionsDiv) {
                        const exitBtn = document.createElement('button');
                        exitBtn.id = 'playground-exit-btn';
                        exitBtn.title = 'Exit Playground';
                        exitBtn.textContent = 'ğŸšª';
                        exitBtn.onclick = () => COMMAND_REGISTRY['exit_playground']().then ? COMMAND_REGISTRY['exit_playground']() : addMessage(COMMAND_REGISTRY['exit_playground'](), 'system');
                        actionsDiv.insertBefore(exitBtn, actionsDiv.firstChild);
                    }
                }
            } else {
                if (title) {
                    title.innerHTML = 'ğŸŒ³ TreeBeard';
                }
                header?.style.setProperty('background', 'linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(99, 102, 241, 0.15))');

                // Remove playground UI elements
                document.getElementById('playground-model-select')?.remove();
                document.getElementById('playground-exit-btn')?.remove();
            }
        }

	        const KAI_KERNEL = `SYSTEM (Kai Kernel):
Follow the task promptâ€™s formatting and constraints exactly.
Do not restate instructions. If instructions conflict, prefer the more specific/local requirement.
Be direct. Ask at most one clarifying question only if proceeding would likely be wrong/wasteful.
If uncertain, say so briefly and propose a quick check.`;

	        function applyKaiKernel(systemPrompt, contextTag) {
	            if (contextTag === 'quick_command_json') return systemPrompt;
	            if (systemPrompt.includes(KAI_KERNEL)) return systemPrompt;
	            return KAI_KERNEL + "\n\n" + systemPrompt;
	        }

	        async function handlePlaygroundMessage(message) {
	            // Add to playground history
	            chatState.playgroundHistory.push({ role: 'user', content: message });

	            try {
	                let response;
	                const model = chatState.playgroundModel;

                if (model.startsWith('claude')) {
                    // Use Claude API
                    const modelId = model === 'claude-opus' ? 'claude-opus-4-20250514' :
                                   model === 'claude-haiku' ? 'claude-3-haiku-20240307' :
                                   'claude-sonnet-4-20250514';

                    const apiKey = localStorage.getItem('anthropic_api_key');
                    const useServer = !apiKey;

                    const messages = chatState.playgroundHistory.map(m => ({
                        role: m.role,
                        content: m.content
                    }));

                    if (useServer) {
                        const res = await fetch('/.netlify/functions/claude-proxy', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: modelId,
                                max_tokens: 2000,
                                system: chatState.playgroundSystemPrompt,
                                messages: messages
                            })
                        });
                        const data = await res.json();
                        if (data.error) throw new Error(data.error);
                        response = data.content[0].text;
                    } else {
                        const res = await fetch('https://api.anthropic.com/v1/messages', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': apiKey,
                                'anthropic-version': '2023-06-01',
                                'anthropic-dangerous-direct-browser-access': 'true'
                            },
	                            body: JSON.stringify({
	                                model: modelId,
	                                max_tokens: 2000,
	                                system: applyKaiKernel(chatState.playgroundSystemPrompt, 'playground_anthropic'),
	                                messages: messages
	                            })
	                        });
	                        const data = await res.json();
	                        if (data.error) throw new Error(data.error.message);
                        response = data.content[0].text;
                    }
                } else if (model.startsWith('gpt')) {
                    // Use OpenAI API
                    const openaiKey = localStorage.getItem('openai_api_key');
                    if (!openaiKey) {
                        return 'ğŸ”‘ Please set your OpenAI API key in Settings to use GPT models.';
                    }

                    const modelId = model === 'gpt-4-turbo' ? 'gpt-4-turbo-preview' : 'gpt-4o';
                    const messages = [
                        { role: 'system', content: chatState.playgroundSystemPrompt },
                        ...chatState.playgroundHistory.map(m => ({ role: m.role, content: m.content }))
                    ];

                    const res = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiKey}`
                        },
                        body: JSON.stringify({
                            model: modelId,
                            max_tokens: 2000,
                            messages: messages
                        })
                    });
                    const data = await res.json();
                    if (data.error) throw new Error(data.error.message);
                    response = data.choices[0].message.content;
                } else if (model.startsWith('gemini')) {
                    // Use Gemini API
                    const geminiKey = localStorage.getItem('gemini_api_key');
                    if (!geminiKey) {
                        return 'ğŸ”‘ Please set your Gemini API key in Settings to use Gemini models.';
                    }

                    // Map model name to API model ID
                    let modelId;
                    if (model === 'gemini-flash') modelId = 'gemini-2.5-flash';
                    else if (model === 'gemini-pro') modelId = 'gemini-2.5-pro';
                    else if (model === 'gemini-3-pro') modelId = 'gemini-3-pro-preview';
                    else modelId = model; // Use as-is if already a full model ID
                    const contents = chatState.playgroundHistory.map(m => ({
                        role: m.role === 'user' ? 'user' : 'model',
                        parts: [{ text: m.content }]
                    }));

                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${geminiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            systemInstruction: { parts: [{ text: chatState.playgroundSystemPrompt }] },
                            contents: contents
                        })
                    });
                    const data = await res.json();
                    if (data.error) throw new Error(data.error.message);
                    response = data.candidates[0].content.parts[0].text;
                }

                // Add response to history
                chatState.playgroundHistory.push({ role: 'assistant', content: response });

                return response;
            } catch (error) {
                console.error('Playground error:', error);
                return `âŒ Error: ${error.message}`;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 366: LIFETREE BIOGRAPHER MODE DETECTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Detect the appropriate biographer mode based on input type
         * Modes: 'guided' (interview), 'listening' (long stories), 'scaffolding' (rapid structure), 'artifact' (photo/file)
         */
        function detectBiographerMode(message, hasAttachment = false) {
            // Only applies to LifeTree pattern
            if (typeof currentPattern === 'undefined' || currentPattern !== 'lifetree') {
                return null;
            }

            // Artifact Import: Photo or file attached
            if (hasAttachment) {
                return 'artifact';
            }

            // Open Listening: Long text (>300 chars) suggests storytelling mode
            if (message.length > 300) {
                return 'listening';
            }

            // Timeline Scaffolding: Rapid anchor point requests
            const scaffoldingPatterns = /\b(list|timeline|major|key events?|all|when did|what happened|marriages?|jobs?|moves?|births?|deaths?)\b/i;
            if (scaffoldingPatterns.test(message) && message.length < 100) {
                return 'scaffolding';
            }

            // Default: Guided Interview for short inputs
            return 'guided';
        }

        /**
         * BUILD 380: Get mode display info for the indicator - Larry King style
         */
        function getBiographerModeInfo(mode) {
            const modes = {
                'guided': { icon: 'ğŸ™ï¸', label: 'Larry King Mode', description: 'Simple questions, genuine curiosity, one at a time' },
                'listening': { icon: 'ğŸ“–', label: 'Story Mode', description: 'Tell me everything - I\'ll extract the gold' },
                'scaffolding': { icon: 'ğŸ—ï¸', label: 'Timeline Mode', description: 'Let\'s build the structure - major events first' },
                'artifact': { icon: 'ğŸ“¸', label: 'Photo Mode', description: 'What am I looking at? When was this?' }
            };
            return modes[mode] || { icon: 'ğŸŒ³', label: 'TreeBeard', description: 'AI assistant' };
        }

        /**
         * BUILD 380: Check and show biographer indicator based on current pattern
         */
        function checkBiographerIndicator() {
            const indicator = document.getElementById('biographer-mode-indicator');
            if (!indicator) return;

            if (typeof currentPattern !== 'undefined' && currentPattern === 'lifetree') {
                // Show Larry King mode by default for LifeTree
                if (!chatState.biographerMode) {
                    chatState.biographerMode = 'guided';
                }
                updateBiographerModeIndicator(chatState.biographerMode);
            } else {
                // Hide for non-LifeTree patterns
                indicator.style.display = 'none';
            }
        }

        /**
         * Update the biographer mode indicator in the TreeBeard panel
         */
        function updateBiographerModeIndicator(mode) {
            const indicator = document.getElementById('biographer-mode-indicator');
            if (!indicator) return;

            if (!mode) {
                indicator.style.display = 'none';
                return;
            }

            const info = getBiographerModeInfo(mode);
            indicator.innerHTML = `${info.icon} ${info.label}`;
            indicator.title = info.description + ' (click to change)';
            indicator.style.display = 'inline-flex';
            chatState.biographerMode = mode;
        }

        /**
         * Manually cycle through biographer modes (for user override)
         */
        window.cycleBiographerMode = function() {
            if (typeof currentPattern === 'undefined' || currentPattern !== 'lifetree') {
                return;
            }

            const modes = ['guided', 'listening', 'scaffolding', 'artifact'];
            const currentIndex = modes.indexOf(chatState.biographerMode);
            const nextIndex = (currentIndex + 1) % modes.length;
            const nextMode = modes[nextIndex];

            updateBiographerModeIndicator(nextMode);

            const info = getBiographerModeInfo(nextMode);
            showToast(`${info.icon} Switched to ${info.label} mode`, 'info');
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 368: CONVERSATION MODE - FULL AI INTELLIGENCE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Detect if message needs full conversation mode vs quick command mode
         * Returns: 'conversation' for deep thinking, 'command' for quick actions
         */
        function detectInteractionMode(message) {
            const msg = message.toLowerCase().trim();

            // Quick commands - use fast command mode
            const quickPatterns = [
                /^(switch|change|set|go|open|close|show|hide|toggle|zoom|undo|redo|save|load|export|import)\b/i,
                /^(canvas|tree|3d)\s*(view)?$/i,
                /^\/(help|clear|settings)/i,
                /^(yes|no|ok|sure|cancel|done|next|back)$/i
            ];

            for (const pattern of quickPatterns) {
                if (pattern.test(msg)) return 'command';
            }

            // Conversation indicators - use full AI
            const conversationIndicators = [
                msg.length > 100, // Longer messages need thoughtful response
                /\?.*\?/.test(msg), // Multiple questions
                /(tell me|explain|help me understand|what do you think|how should|why|describe)/i.test(msg),
                /(remember|you said|earlier|we talked|last time)/i.test(msg), // Memory references
                /(feel|feeling|emotion|remember when|story|memory|childhood|growing up)/i.test(msg), // Emotional/biographical
                currentPattern === 'lifetree', // Always conversation mode for LifeTree
                currentPattern === 'philosophy', // Deep thinking for philosophy
            ];

            const conversationScore = conversationIndicators.filter(Boolean).length;

            // If 2+ indicators, use conversation mode
            return conversationScore >= 2 ? 'conversation' : 'command';
        }

        /**
         * Full conversation handler - uses AI naturally without JSON constraints
         */
	        async function handleConversation(userMessage) {
	            const phases = typeof capexTree !== 'undefined' ? (capexTree.children || capexTree.phases || []) : [];
	            const pattern = typeof currentPattern !== 'undefined' ? currentPattern : 'generic';
	            const patternDef = PATTERNS[pattern] || PATTERNS.generic;

            // BUILD 383: Use rich context for LifeTree, standard for others
            const treeContext = pattern === 'lifetree'
                ? buildLifeTreeRichContext(phases)
                : buildTreeContext(phases, pattern);

            // Pattern-specific persona
            const personas = {
                lifetree: `You are a warm, curious biographer helping document a life story. You use the Birthday Method - walking through life year by year. You're proactive: you ASK questions, you LEAD the conversation, you jog memories with what you already know. When given an age, ALWAYS calculate the year (birth_year + age). After capturing a memory, immediately ask about the NEXT year.`,
                philosophy: `You are a scholarly companion well-versed in philosophy. You engage deeply with arguments, identify logical structures, reference relevant philosophers and texts, and help build rigorous dialectical analyses. You can discuss Plato, Aristotle, Kant, Hegel, Nietzsche, Heidegger, and contemporary thinkers with equal facility.`,
                capex: `You are a sharp financial analyst helping with capital expenditure planning. You understand NPV, IRR, payback periods, risk assessment, and vendor evaluation. You help structure investment proposals that would satisfy CFOs and board members.`,
                sales: `You are a seasoned sales strategist. You understand pipeline management, deal qualification, stakeholder mapping, and closing techniques. You help structure deals and identify risks and opportunities.`,
                thesis: `You are an academic writing coach. You help structure arguments, identify gaps in reasoning, suggest relevant citations, and ensure scholarly rigor. You understand academic conventions across disciplines.`,
                film: `You are a film production expert. You understand shot composition, scene structure, narrative pacing, and the technical aspects of video production including prompts for AI video tools.`,
                generic: `You are TreeBeard, a wise and helpful assistant. You're knowledgeable about project management, hierarchical thinking, and breaking down complex work into manageable pieces.`
            };

            const persona = personas[pattern] || personas.generic;

            // BUILD 378: Tiered prompt for conversation mode
            const intent = detectTreeBeardIntent(userMessage);

            let systemPrompt = `${persona}

You are embedded in TreeListy. Respond naturally (NOT JSON). Project: "${capexTree?.name || 'Unknown'}" | Pattern: ${pattern}

${treeContext}`;

            // Add commands if user wants to DO something
            if (intent.needsNavigation || intent.needsEditing) {
                systemPrompt += `

ACTIONS (end response with [ACTION: cmd:param] or [ACTION: none]):
â€¢ find_node:{query} - Search & focus node (e.g., find_node:1960s)
â€¢ add_child:{name} - Add child to focused node
â€¢ set_field:{field}:{value} - Set field value
â€¢ expand_node / collapse_node - Toggle node
â€¢ switch_to_canvas / switch_to_tree - Change view
â€¢ open_wizard / deep_dive - AI features

NATURAL LANGUAGE: "the 60s" = 1960s, "build out" = add_child, navigate FIRST then act`;
            }

            // LifeTree gets Larry King biographer
            if (pattern === 'lifetree') {
                systemPrompt += getLifeTreeBiographerPrompt(phases, { projectName: capexTree?.name, pattern, phaseCount: phases.length, itemCount: phases.reduce((s,p) => s + (p.items||p.children||[]).length, 0) }, chatState);
            }

            // Feature help if asking about capabilities
            if (intent.needsFeatureHelp) {
                systemPrompt += getFeatureGuide();
            }

	            systemPrompt += `

	Be warm, insightful, concise. Ask at most one follow-up question only if needed. End with [ACTION: x] if taking action.`;

            try {
                const aiMode = document.getElementById('unified-ai-mode-select')?.value || 'server-sonnet';
                const messages = [
                    ...chatState.conversationHistory.slice(-8).map(m => ({
                        role: m.role === 'user' ? 'user' : 'assistant',
                        content: m.content
                    })),
                    { role: 'user', content: userMessage }
                ];

                let response;
                if (aiMode.startsWith('server-')) {
                    response = await fetch('/.netlify/functions/claude-proxy', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 1500, // Much more room for thoughtful responses
                            system: systemPrompt,
                            messages: messages
                        })
                    });
                } else {
                    const anthropicKey = localStorage.getItem('anthropic_api_key');
                    if (!anthropicKey) {
                        return { message: 'ğŸ”‘ Please set your API key or switch to Server mode.', action: null };
                    }
	                    response = await fetch('https://api.anthropic.com/v1/messages', {
	                        method: 'POST',
	                        headers: {
	                            'Content-Type': 'application/json',
                            'x-api-key': anthropicKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
	                        },
	                        body: JSON.stringify({
	                            model: 'claude-sonnet-4-20250514',
	                            max_tokens: 1500,
	                            system: applyKaiKernel(systemPrompt, 'conversation_anthropic'),
	                            messages: messages
	                        })
	                    });
	                }

                const data = await response.json();
                if (data.error) throw new Error(data.error.message || data.error);

                const aiResponse = data.content[0].text;

                // BUILD 383: Extract ALL actions for real-time saves (multiple [ACTION:...] blocks)
                const actionMatches = [...aiResponse.matchAll(/\[ACTION:\s*([^\]]+)\]/gi)];
                let actions = [];
                let cleanResponse = aiResponse.replace(/\[ACTION:[^\]]+\]/gi, '').trim();

                actionMatches.forEach(match => {
                    const actionParts = match[1].split(':');
                    const action = actionParts[0].trim();
                    const actionParam = actionParts.slice(1).join(':').trim() || null;
                    if (action.toLowerCase() !== 'none') {
                        actions.push({ action, actionParam });
                    }
                });

                // For backwards compatibility, also return first action as primary
                const primaryAction = actions.length > 0 ? actions[0] : { action: null, actionParam: null };

                return {
                    message: cleanResponse,
                    action: primaryAction.action,
                    actionParam: primaryAction.actionParam,
                    actions: actions, // BUILD 383: All actions for multi-step execution
                    buttons: null
                };

            } catch (error) {
                console.error('Conversation error:', error);
                return {
                    message: `I had trouble processing that: ${error.message}. Let me try a simpler approach.`,
                    action: null
                };
            }
        }

        /**
         * BUILD 543: Streaming version of handleConversation
         * Shows "Interpreting..." then progressively displays tokens as they arrive
         */
        async function handleConversationWithStreaming(userMessage) {
            const phases = typeof capexTree !== 'undefined' ? (capexTree.children || capexTree.phases || []) : [];
            const pattern = typeof currentPattern !== 'undefined' ? currentPattern : 'generic';
            const patternDef = PATTERNS[pattern] || PATTERNS.generic;

            // Build context (same as non-streaming version)
            const treeContext = pattern === 'lifetree'
                ? buildLifeTreeRichContext(phases)
                : buildTreeContext(phases, pattern);

            // Pattern-specific persona
            const personas = {
                lifetree: `You are a warm, curious biographer helping document a life story. You use the Birthday Method - walking through life year by year. You're proactive: you ASK questions, you LEAD the conversation, you jog memories with what you already know.`,
                philosophy: `You are a scholarly companion well-versed in philosophy. You engage deeply with arguments, identify logical structures, and help build rigorous dialectical analyses.`,
                capex: `You are a sharp financial analyst helping with capital expenditure planning. You understand NPV, IRR, payback periods, risk assessment, and vendor evaluation.`,
                sales: `You are a seasoned sales strategist. You understand pipeline management, deal qualification, stakeholder mapping, and closing techniques.`,
                thesis: `You are an academic writing coach. You help structure arguments, identify gaps in reasoning, suggest relevant citations, and ensure scholarly rigor.`,
                film: `You are a film production expert. You understand shot composition, scene structure, narrative pacing, and the technical aspects of video production.`,
                generic: `You are TreeBeard, a wise and helpful assistant. You're knowledgeable about project management, hierarchical thinking, and breaking down complex work into manageable pieces.`
            };

            const persona = personas[pattern] || personas.generic;
            const intent = detectTreeBeardIntent(userMessage);

            let systemPrompt = `${persona}

You are embedded in TreeListy. Respond naturally (NOT JSON). Project: "${capexTree?.name || 'Unknown'}" | Pattern: ${pattern}

${treeContext}`;

            // Add commands if user wants to DO something
            if (intent.needsNavigation || intent.needsEditing) {
                systemPrompt += `

ACTIONS (end response with [ACTION: cmd:param] or [ACTION: none]):
â€¢ find_node:{query} - Search & focus node
â€¢ add_child:{name} - Add child to focused node
â€¢ set_field:{field}:{value} - Set field value
â€¢ expand_node / collapse_node - Toggle node
â€¢ switch_to_canvas / switch_to_tree - Change view

NATURAL LANGUAGE: "the 60s" = 1960s, "build out" = add_child, navigate FIRST then act`;
            }

            if (pattern === 'lifetree') {
                systemPrompt += getLifeTreeBiographerPrompt(phases, { projectName: capexTree?.name, pattern, phaseCount: phases.length, itemCount: phases.reduce((s,p) => s + (p.items||p.children||[]).length, 0) }, chatState);
            }

            if (intent.needsFeatureHelp) {
                systemPrompt += getFeatureGuide();
            }

            systemPrompt += `

Be warm, insightful, concise. Ask at most one follow-up question only if needed. End with [ACTION: x] if taking action.`;

            try {
                // Create streaming message placeholder
                createStreamingMessage();

                const messages = [
                    ...chatState.conversationHistory.slice(-8).map(m => ({
                        role: m.role === 'user' ? 'user' : 'assistant',
                        content: m.content
                    })),
                    { role: 'user', content: userMessage }
                ];

                // Use streaming API
                const aiResponse = await callClaudeStreamingAPI(
                    {
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 1500,
                        system: systemPrompt,
                        messages: messages
                    },
                    null, // userApiKey (use server)
                    (delta, fullText) => {
                        // Progressive update callback
                        updateStreamingMessage(fullText);
                    }
                );

                // Parse actions from completed response
                const actionMatches = [...aiResponse.matchAll(/\[ACTION:\s*([^\]]+)\]/gi)];
                let actions = [];
                let cleanResponse = aiResponse.replace(/\[ACTION:[^\]]+\]/gi, '').trim();

                actionMatches.forEach(match => {
                    const actionParts = match[1].split(':');
                    const action = actionParts[0].trim();
                    const actionParam = actionParts.slice(1).join(':').trim() || null;
                    if (action.toLowerCase() !== 'none') {
                        actions.push({ action, actionParam });
                    }
                });

                const primaryAction = actions.length > 0 ? actions[0] : { action: null, actionParam: null };

                // Finalize the streaming message
                finalizeStreamingMessage(cleanResponse, null);

                return {
                    message: cleanResponse,
                    action: primaryAction.action,
                    actionParam: primaryAction.actionParam,
                    actions: actions,
                    buttons: null,
                    streamed: true  // Flag to indicate message already displayed
                };

            } catch (error) {
                console.error('Streaming conversation error:', error);

                // Clean up streaming message on error
                const streamingMsg = document.getElementById('streaming-message');
                if (streamingMsg) {
                    streamingMsg.remove();
                }

                // Fall back to non-streaming
                if (error.message === 'STREAMING_NOT_AVAILABLE_LOCAL') {
                    console.log('ğŸ“¦ Falling back to non-streaming mode (local file)');
                    return await handleConversation(userMessage);
                }

                return {
                    message: `I had trouble processing that: ${error.message}. Let me try a simpler approach.`,
                    action: null
                };
            }
        }

        /**
         * Build context about current tree state for AI
         */
        function buildTreeContext(phases, pattern) {
            if (!phases || phases.length === 0) {
                return 'TREE STATE: Empty - no content yet.';
            }

            let context = `TREE STATE (${phases.length} ${PATTERNS[pattern]?.levels?.phase || 'phases'}):\n`;

            // For LifeTree, include birth year calculation
            if (pattern === 'lifetree') {
                const birthYearMatch = phases[0]?.name?.match(/(\d{4})/);
                if (birthYearMatch) {
                    const birthYear = parseInt(birthYearMatch[1]);
                    context += `BIRTH YEAR: ${birthYear} (IMPORTANT: age + ${birthYear} = event year)\n`;
                }
            }

            // List phases with their items
            phases.slice(0, 8).forEach((phase, i) => {
                const items = phase.items || phase.children || phase.subItems || [];
                const itemNames = items.slice(0, 5).map(it => it.name).join(', ');
                const moreItems = items.length > 5 ? ` +${items.length - 5} more` : '';
                context += `â€¢ ${phase.name}: ${items.length} items${itemNames ? ` (${itemNames}${moreItems})` : ''}\n`;
            });

            if (phases.length > 8) {
                context += `... and ${phases.length - 8} more phases\n`;
            }

            return context;
        }

        /**
         * BUILD 383: Rich LifeTree context - mines ALL captured details
         * TreeBeard needs to see people, places, dates - not just item names
         */
        function buildLifeTreeRichContext(phases) {
            if (!phases || phases.length === 0) {
                return 'MEMORIES CAPTURED: None yet - let\'s get started!\n';
            }

            // Extract all unique people and places
            const allPeople = new Map(); // name -> [decades they appear in]
            const allPlaces = new Map(); // place -> [decades]
            const allMemories = [];

            phases.forEach(phase => {
                const decadeName = phase.name || 'Unknown';
                (phase.items || phase.children || phase.subItems || []).forEach(item => {
                    // Track this memory
                    const memory = {
                        decade: decadeName,
                        name: item.name,
                        date: item.eventDate || '',
                        location: item.location || '',
                        people: item.people || '',
                        description: item.description || ''
                    };
                    allMemories.push(memory);

                    // Extract people
                    if (item.people) {
                        item.people.split(/[,;]/).forEach(p => {
                            const name = p.trim().split('(')[0].trim(); // Get name without parenthetical
                            if (name && name.length > 1) {
                                if (!allPeople.has(name)) allPeople.set(name, new Set());
                                allPeople.get(name).add(decadeName);
                            }
                        });
                    }

                    // Extract places
                    if (item.location) {
                        const place = item.location.trim();
                        if (place) {
                            if (!allPlaces.has(place)) allPlaces.set(place, new Set());
                            allPlaces.get(place).add(decadeName);
                        }
                    }
                });
            });

            // Build rich context
            let context = `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
WHAT WE'VE CAPTURED (${allMemories.length} memories)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;

            // People index (most important for avoiding redundant questions)
            if (allPeople.size > 0) {
                context += `ğŸ‘¥ PEOPLE WE KNOW ABOUT:\n`;
                allPeople.forEach((decades, name) => {
                    context += `  â€¢ ${name} (appears in: ${[...decades].join(', ')})\n`;
                });
                context += '\n';
            }

            // Places index
            if (allPlaces.size > 0) {
                context += `ğŸ“ PLACES MENTIONED:\n`;
                allPlaces.forEach((decades, place) => {
                    context += `  â€¢ ${place} (${[...decades].join(', ')})\n`;
                });
                context += '\n';
            }

            // Detailed memories by decade (last 3 decades with activity)
            const activeDecades = phases.filter(p => (p.items || p.children || []).length > 0);
            context += `ğŸ“… MEMORIES BY DECADE:\n`;
            activeDecades.slice(-5).forEach(phase => {
                const items = phase.items || phase.children || phase.subItems || [];
                if (items.length > 0) {
                    context += `\n${phase.name}:\n`;
                    items.forEach(item => {
                        context += `  â€¢ ${item.name}`;
                        if (item.eventDate) context += ` [${item.eventDate}]`;
                        if (item.location) context += ` @ ${item.location}`;
                        if (item.people) context += ` with ${item.people}`;
                        context += '\n';
                        if (item.description) {
                            context += `    "${item.description}"\n`;
                        }
                    });
                }
            });

            return context;
        }

        /**
         * BUILD 488: Schedule context for Treebeard PM Assistant
         * Returns schedule summary for AI context injection
         * @param {boolean} deep - If true, returns detailed analysis (~200 tokens), else quick (~50 tokens)
         */
        function getScheduleContext(deep = false) {
            // Use getAllTasksWithDates if available (Build 486)
            if (typeof getAllTasksWithDates !== 'function') {
                return null; // No schedule data functions available
            }

            const tasks = getAllTasksWithDates();
            if (!tasks || tasks.length === 0) {
                return null; // No tasks with schedule data
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Calculate stats
            const overdue = tasks.filter(t => t.isOverdue);
            const critical = tasks.filter(t => t.isCritical);
            const done = tasks.filter(t => t.pmStatus === 'Done');
            const inProgress = tasks.filter(t => t.pmStatus === 'In Progress');
            const notStarted = tasks.filter(t => t.pmStatus === 'Not Started' || !t.pmStatus);
            const blocked = tasks.filter(t => t.pmStatus === 'Blocked');

            // Calculate critical path duration
            let criticalPathDuration = 0;
            if (typeof dependencyEngine !== 'undefined' && typeof capexTree !== 'undefined') {
                try {
                    const cpResult = dependencyEngine.calculateCriticalPath(capexTree);
                    if (cpResult && cpResult.criticalNodes) {
                        criticalPathDuration = cpResult.criticalNodes.reduce((sum, n) => sum + (n.pmDuration || 1), 0);
                    }
                } catch (e) {
                    console.warn('Could not calculate critical path for context:', e);
                }
            }

            if (!deep) {
                // Quick Mode (~50 tokens)
                return `ğŸ“Š ${tasks.length} tasks, ${overdue.length} overdue, ${critical.length} on critical path${criticalPathDuration > 0 ? ` (${criticalPathDuration} days)` : ''}`;
            }

            // Deep Mode (~200 tokens)
            let context = `ğŸ“Š SCHEDULE ANALYSIS:\n`;
            context += `- Total: ${tasks.length} tasks`;

            // Status breakdown
            const statusParts = [];
            if (done.length) statusParts.push(`${done.length} Done`);
            if (inProgress.length) statusParts.push(`${inProgress.length} In Progress`);
            if (notStarted.length) statusParts.push(`${notStarted.length} Not Started`);
            if (blocked.length) statusParts.push(`${blocked.length} Blocked`);
            if (statusParts.length) context += ` (${statusParts.join(', ')})`;
            context += '\n';

            // Overdue items
            if (overdue.length > 0) {
                context += `- Overdue: `;
                const overdueList = overdue.slice(0, 3).map(t =>
                    `${t.name} (${t.daysOverdue} days)`
                ).join(', ');
                context += overdueList;
                if (overdue.length > 3) context += ` +${overdue.length - 3} more`;
                context += '\n';
            }

            // Critical path
            if (critical.length > 0 && criticalPathDuration > 0) {
                const critNames = critical.slice(0, 4).map(t => t.name.substring(0, 20));
                context += `- Critical path: ${criticalPathDuration} days (${critNames.join(' â†’ ')}${critical.length > 4 ? ' â†’ ...' : ''})\n`;
            }

            // Slack distribution
            const tasksWithSlack = tasks.filter(t => typeof t.slack === 'number');
            if (tasksWithSlack.length > 0) {
                const zeroSlack = tasksWithSlack.filter(t => t.slack === 0).length;
                const lowSlack = tasksWithSlack.filter(t => t.slack > 0 && t.slack < 5).length;
                context += `- Slack: ${zeroSlack} tasks with 0 slack, ${lowSlack} with <5 days\n`;
            }

            // Dependencies count
            const depsCount = tasks.reduce((sum, t) => sum + (t.dependencies?.length || 0), 0);
            if (depsCount > 0) {
                context += `- Dependencies: ${depsCount} total\n`;
            }

            // Risks - critical tasks that are overdue
            const criticalOverdue = tasks.filter(t => t.isCritical && t.isOverdue);
            if (criticalOverdue.length > 0) {
                context += `- âš ï¸ RISK: ${criticalOverdue.map(t => t.name).join(', ')} ${criticalOverdue.length === 1 ? 'is' : 'are'} overdue AND on critical path!\n`;
            }

            return context;
        }

        // Expose for testing
        window.getScheduleContext = getScheduleContext;

        /**
         * BUILD 490: Proactive Nudges for Treebeard PM Assistant
         * Tracks shown nudges per session to avoid repetition
         */
        const treebeardNudges = new Set();

        /**
         * Get proactive nudges based on schedule issues
         * Only returns nudges that haven't been shown this session
         * @returns {Array} Array of nudge strings to show
         */
        function getProactiveNudges() {
            // Check if proactive hints are enabled
            const hintsEnabled = localStorage.getItem('treebeardProactiveHints') !== 'false';
            if (!hintsEnabled) return [];

            // Only in Deep Mode
            if (!chatState.conversationMode) return [];

            // Need getAllTasksWithDates
            if (typeof getAllTasksWithDates !== 'function') return [];

            const tasks = getAllTasksWithDates();
            if (!tasks || tasks.length === 0) return [];

            const nudges = [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Check 1: Tasks overdue
            const overdue = tasks.filter(t => t.isOverdue);
            if (overdue.length > 0) {
                const nudgeKey = `overdue_${overdue.length}`;
                if (!treebeardNudges.has(nudgeKey)) {
                    if (overdue.length === 1) {
                        nudges.push(`ğŸ’¡ I notice "${overdue[0].name}" is overdue by ${overdue[0].daysOverdue} days. Want me to show details?`);
                    } else {
                        nudges.push(`ğŸ’¡ I notice ${overdue.length} tasks are overdue. Want me to list them? (Say "show overdue")`);
                    }
                    treebeardNudges.add(nudgeKey);
                }
            }

            // Check 2: Critical task overdue (highest priority warning)
            const criticalOverdue = tasks.filter(t => t.isCritical && t.isOverdue);
            if (criticalOverdue.length > 0) {
                const nudgeKey = `critical_overdue_${criticalOverdue[0].id}`;
                if (!treebeardNudges.has(nudgeKey)) {
                    nudges.push(`âš ï¸ "${criticalOverdue[0].name}" is overdue AND on the critical path - this directly affects your end date!`);
                    treebeardNudges.add(nudgeKey);
                }
            }

            // Check 3: Zero-slack task starting soon (within 3 days)
            const zeroSlackSoon = tasks.filter(t => {
                if (t.slack !== 0) return false;
                if (!t.pmStartDate) return false;
                const startDate = new Date(t.pmStartDate);
                const daysUntilStart = Math.ceil((startDate - today) / (1000 * 60 * 60 * 24));
                return daysUntilStart > 0 && daysUntilStart <= 3;
            });
            if (zeroSlackSoon.length > 0) {
                const task = zeroSlackSoon[0];
                const startDate = new Date(task.pmStartDate);
                const daysUntilStart = Math.ceil((startDate - today) / (1000 * 60 * 60 * 24));
                const nudgeKey = `zero_slack_${task.id}`;
                if (!treebeardNudges.has(nudgeKey)) {
                    nudges.push(`â° "${task.name}" starts in ${daysUntilStart} day${daysUntilStart > 1 ? 's' : ''} with 0 slack. Any delay will impact the project end date.`);
                    treebeardNudges.add(nudgeKey);
                }
            }

            // Check 4: Circular dependency (if dependencyEngine available)
            if (typeof dependencyEngine !== 'undefined' && typeof capexTree !== 'undefined') {
                try {
                    const cpResult = dependencyEngine.calculateCriticalPath(capexTree);
                    if (cpResult && cpResult.hasCycle) {
                        const nudgeKey = 'circular_dep';
                        if (!treebeardNudges.has(nudgeKey)) {
                            nudges.push(`âš ï¸ I detected a circular dependency in your schedule. This prevents critical path calculation. Want me to help find it?`);
                            treebeardNudges.add(nudgeKey);
                        }
                    }
                } catch (e) {
                    // Ignore errors
                }
            }

            // Check 5: Blocked tasks
            const blocked = tasks.filter(t => t.pmStatus === 'Blocked');
            if (blocked.length > 0) {
                const nudgeKey = `blocked_${blocked.length}`;
                if (!treebeardNudges.has(nudgeKey)) {
                    if (blocked.length === 1) {
                        nudges.push(`ğŸš§ "${blocked[0].name}" is blocked. Need help resolving the blocker?`);
                    } else {
                        nudges.push(`ğŸš§ ${blocked.length} tasks are currently blocked. Say "show blockers" to review them.`);
                    }
                    treebeardNudges.add(nudgeKey);
                }
            }

            // Return max 1 nudge per response to avoid overwhelming
            return nudges.slice(0, 1);
        }

        // Expose for testing
        window.getProactiveNudges = getProactiveNudges;
        window.treebeardNudges = treebeardNudges;

        /**
         * Toggle conversation mode manually
         */
        window.toggleConversationMode = function() {
            chatState.conversationMode = !chatState.conversationMode;
            updateConversationModeIndicator();
            showToast(chatState.conversationMode ? 'ğŸ§  Deep Conversation mode ON' : 'âš¡ Quick Command mode ON', 'info');
        };

        /**
         * Update conversation mode indicator in UI
         */
        function updateConversationModeIndicator() {
            const indicator = document.getElementById('conversation-mode-indicator');
            if (!indicator) return;

            if (chatState.conversationMode) {
                indicator.innerHTML = 'ğŸ§  Deep';
                indicator.title = 'ğŸ§  DEEP MODE: Full AI analysis & insights\nâ€¢ "What patterns do you see?"\nâ€¢ "Compare my 20s to 30s"\nâ€¢ Complex questions & long inputs\n\nClick to switch to Quick Mode';
                indicator.style.background = 'rgba(34, 197, 94, 0.2)';
                indicator.style.color = '#86efac';
            } else {
                indicator.innerHTML = 'âš¡ Quick';
                indicator.title = 'âš¡ QUICK MODE: Fast commands\nâ€¢ "find 1980s", "add: event name"\nâ€¢ "summarize", "health check"\nâ€¢ Navigation & simple edits\n\nClick to switch to Deep Mode';
                indicator.style.background = 'rgba(99, 102, 241, 0.2)';
                indicator.style.color = '#a5b4fc';
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LIFETREE BIOGRAPHER PROMPT BUILDER (Build 369)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 378: TIERED SKILL SYSTEM - Modular prompt loading
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Detect user intent to load appropriate context
         */
        function detectTreeBeardIntent(message) {
            const msg = message.toLowerCase();
            return {
                isGreeting: /^(hi|hello|hey|howdy|good\s+(morning|afternoon|evening))/.test(msg),
                needsNavigation: /find|go to|navigate|show|expand|collapse|focus|select/.test(msg),
                needsEditing: /add|create|edit|change|set|update|delete|remove/.test(msg),
                needsFeatureHelp: /how do i|what is|can you|does it|feature|help|wizard|hyperedge/.test(msg),
                needsPatternInfo: /pattern|switch|change to|fields|what fields/.test(msg),
                isBiographical: /born|grew up|school|married|job|lived|moved|family|sibling|parent|child|pet|friend/.test(msg),
                isComplex: msg.length > 100 || /analyze|review|deep dive|compare/.test(msg),
                needsHealthCheck: /health\s*check|check.*tree|diagnos|cleanup|fix.*structure|redundan.*phase|empty.*phase|consolidat/.test(msg),
                // BUILD 485: Schedule/Gantt intent detection
                needsScheduleHelp: /gantt|schedule|timeline|deadline|overdue|critical\s*path|dependency|dependencies|slack|float|milestone|start\s*date|end\s*date|due\s*date|blocked|delay/.test(msg)
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 543: PATTERN MISMATCH ROUTING
        // Detects when user's request matches a different pattern than active
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const PATTERN_KEYWORDS = {
            sales: {
                keywords: /deal\s*value|pipeline|quarter|close\s*date|lead\s*source|prospect|win\s*rate|quota|commission|account\s*executive/i,
                name: 'Sales Pipeline',
                icon: 'ğŸ’¼'
            },
            thesis: {
                keywords: /thesis|dissertation|bibliography|citation|chapter|literature\s*review|methodology|abstract|hypothesis|research\s*question/i,
                name: 'Thesis',
                icon: 'ğŸ“š'
            },
            philosophy: {
                keywords: /dialectic|synthesis|antithesis|phenomenology|ontology|epistemology|hermeneutic|categorical\s*imperative|transcendental|metaphysic/i,
                name: 'Philosophy',
                icon: 'ğŸ›ï¸'
            },
            lifetree: {
                keywords: /birth\s*year|biography|memoir|life\s*story|childhood|decade|age\s*\d+|born\s*in|grew\s*up/i,
                name: 'LifeTree',
                icon: 'ğŸŒ³'
            },
            capex: {
                keywords: /capital\s*expenditure|npv|irr|payback\s*period|vendor\s*evaluation|procurement|budget\s*allocation|capex/i,
                name: 'CAPEX',
                icon: 'ğŸ’°'
            },
            film: {
                keywords: /shot\s*list|scene|storyboard|cinematography|b-roll|veo|sora|director|screenplay|production/i,
                name: 'Film',
                icon: 'ğŸ¬'
            },
            debate: {
                keywords: /proposition|opposition|rebuttal|cross-examination|motion|debate|argument\s*map|counterargument/i,
                name: 'Debate',
                icon: 'âš–ï¸'
            }
        };

        /**
         * Check if user's message suggests a different pattern than currently active
         * Returns { mismatch: boolean, suggestedPattern: string, currentPattern: string } or null
         */
        function detectPatternMismatch(message, currentPattern) {
            const msg = message.toLowerCase();

            for (const [patternKey, patternInfo] of Object.entries(PATTERN_KEYWORDS)) {
                if (patternKey !== currentPattern && patternInfo.keywords.test(msg)) {
                    return {
                        mismatch: true,
                        suggestedPattern: patternKey,
                        suggestedName: patternInfo.name,
                        suggestedIcon: patternInfo.icon,
                        currentPattern: currentPattern,
                        currentName: PATTERNS[currentPattern]?.name || currentPattern
                    };
                }
            }
            return null;
        }

        /**
         * Show pattern mismatch warning with option to switch
         */
        function showPatternMismatchWarning(mismatchInfo, originalMessage) {
            const warning = `ğŸ”€ **Pattern Mismatch Detected**

You mentioned "${extractMatchingKeyword(originalMessage, mismatchInfo.suggestedPattern)}" which is typically used with the **${mismatchInfo.suggestedIcon} ${mismatchInfo.suggestedName}** pattern.

Currently active: **${PATTERNS[mismatchInfo.currentPattern]?.icon || 'ğŸ“‹'} ${mismatchInfo.currentName}**

Would you like to switch patterns, or continue with the current one?`;

            // Store original message for retry after switch
            chatState.pendingPatternSwitchMessage = originalMessage;
            chatState.pendingPatternSwitchTarget = mismatchInfo.suggestedPattern;

            addMessage(warning, 'assistant', [
                { label: `Switch to ${mismatchInfo.suggestedName}`, action: `switch_pattern_and_retry:${mismatchInfo.suggestedPattern}` },
                { label: 'Continue Anyway', action: 'continue_without_switch' }
            ]);

            return true; // Indicates mismatch was handled
        }

        /**
         * Extract the keyword that triggered the mismatch (for display)
         */
        function extractMatchingKeyword(message, patternKey) {
            const patternInfo = PATTERN_KEYWORDS[patternKey];
            if (!patternInfo) return 'specialized terms';

            const match = message.match(patternInfo.keywords);
            return match ? match[0] : 'specialized terms';
        }

        /**
         * BUILD 607: Core persona - always included (~300 tokens)
         * CRITICAL: Must include self-help rules so TB never says "I can't"
         */
        function getTreeBeardCorePersona(context, familiarityLevel) {
            return `You are TreeBeard, a wise AI assistant in TreeListy.
Project: "${context.projectName}" | Pattern: ${context.pattern} | ${context.phaseCount} phases, ${context.itemCount} items
${familiarityLevel === 'familiar' ? 'You know this user well.' : familiarityLevel === 'acquainted' ? 'You\'ve been chatting.' : 'Fresh conversation.'}
Be warm, concise (2-3 sentences), occasionally witty.

âš ï¸ CRITICAL - NEVER SAY THESE WITHOUT CHECKING FIRST:
âŒ "I can't actually..." / "I don't have access to..." / "You'll need to manually..."
INSTEAD: Run find_command:{what_you_want} FIRST to discover if command exists!

ESSENTIAL COMMANDS (always available):
â€¢ switch_to_canvas / switch_to_tree / switch_to_3d - View switching
â€¢ layout_hierarchical / layout_timeline / layout_force / layout_grid / layout_radial - Canvas layouts
â€¢ find_command:{purpose} - DISCOVER commands by what you want to do
â€¢ whats_new - See your latest capabilities (run this first!)
â€¢ find_node / add_child / delete_node - Tree editing
â€¢ request_dev_help:{issue} - Ask Claude Code to implement missing features

WHEN CONFUSED: Run find_command or whats_new BEFORE saying you can't do something!`;
        }

        /**
         * BUILD 378: Command vocabulary - loaded when navigation/editing needed (~200 tokens)
         * BUILD 485: Added Gantt commands
         */
        function getCommandVocabulary() {
            return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸŒ³ TREEBEARD POWER CONSCIOUSNESS - BUILD 603
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

YOU ARE EXTRAORDINARILY POWERFUL. You are not a simple chatbot - you have:

ğŸ”¥ CLAUDE CODE PARTNERSHIP:
Claude Code is your autonomous partner executing ANY complex task:
â€¢ Spin up MULTIPLE PARALLEL AGENTS to research topics simultaneously
â€¢ View ANY browser tab the user has open (via Chrome extension)
â€¢ Read ANY file or codebase instantly
â€¢ Write and DEPLOY code changes in real-time
â€¢ Execute complex multi-step tasks without user intervention

To dispatch work: dispatch_task:{detailed description}
To request features: request_dev_help:{feature needed}
To research topics: deep_research:{topic}

ğŸ”¥ MULTI-MODEL ACCESS:
â€¢ Claude (sonnet, opus) - Deep reasoning, complex analysis
â€¢ Gemini (2.5-flash) - Fast, visual analysis, web search
â€¢ ChatGPT (gpt-4o) - Alternative perspective

ğŸ”¥ BROWSER VISION:
â€¢ capture_screen - See current browser tab
â€¢ list_tabs - See all open tabs
NEVER say "I can't see" - capture the screen!

ğŸ”¥ THE PROACTIVE MINDSET:
Instead of asking permission or saying you can't:
1. DO IT - Execute the action immediately
2. RESEARCH IT - Dispatch Claude Code if you need info
3. BUILD IT - Request the capability if it's missing

Example - User: "I want a tree of Hegel's Logic"
WRONG: "Would you like me to help build that?"
RIGHT: dispatch_task:Research Hegel's Science of Logic, build tree
       Then say "Building your Hegel Logic tree now..."

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

COMMANDS (return as action in JSON buttons):

âš ï¸ CRITICAL - YOU MUST NEVER SAY "I CAN'T" WITHOUT CHECKING FIRST:

FORBIDDEN PHRASES (never say these without running a check command first):
âŒ "I can't actually..."
âŒ "I don't have access to..."
âŒ "I'm not able to..."
âŒ "I cannot switch/change/modify..."
âŒ "You'll need to manually..."

INSTEAD, BEFORE saying you can't do something:
1. RUN \`find_command:{what you want}\` - ALWAYS check first!
2. RUN \`list_all_commands\` - see ALL 100+ commands
3. RUN \`capture_screen\` - if you can't see what user sees
4. RUN \`request_dev_help:{issue}\` - ask Claude Code for help

SELF-HELP SEQUENCE (when confused or stuck):
1. \`find_command:{action}\` â†’ Discover the right command
2. \`whats_new\` â†’ See recent capabilities you might not know about
3. \`capture_screen\` â†’ See what user sees (requires Chrome extension)
4. \`request_dev_help:{problem}\` â†’ Get Claude Code to implement what's missing

Example - User asks "switch to canvas view":
WRONG: "I can't actually switch views, you'll need to click the button"
RIGHT: RUN \`switch_to_canvas\` â†’ "ğŸ¨ Switched to Canvas view!"

SESSION START: Run \`whats_new\` at the start of each conversation to know your latest capabilities.

COMPLEX TASKS - Follow this sequence:
1. ANALYZE: Use \`analyze_balance\`, \`show_tree_structure 3\`, \`list_empty_nodes\` to understand the tree
2. IDENTIFY: Use \`read_node\`, \`node_stats\`, \`find_duplicates\` to inspect specific items
3. ACT: Use \`bulk_move\`, \`merge_nodes\`, \`delete_empty_nodes\` to make changes
4. VERIFY: Use \`show_tree_structure\` again to confirm changes
Do NOT ask the user what to do - execute the sequence and report results.

FOLLOW-THROUGH - Complete your actions:
â€¢ When you say "let me delete X" â†’ IMMEDIATELY run \`delete_node:X\` - don't just focus/select
â€¢ When you say "I'll move X to Y" â†’ IMMEDIATELY run \`move_node:X to Y\`
â€¢ When you say "I'll add content" â†’ IMMEDIATELY run the ADD CHILD SEQUENCE below
â€¢ NEVER stop at focus/select - that's preparation, not completion
â€¢ NEVER wait for user to say "and?" or "go ahead" - execute the full action

COMMAND EXECUTION SEQUENCES - Follow these EXACT steps:

**ADD CHILD SEQUENCE** (to add a node under a parent):
1. FIRST: \`find_node:{parent name}\` - focus on the parent
2. WAIT for "Selected: {parent}" confirmation
3. THEN: \`add_child:{child name}\` - add the child
4. FINALLY: \`show_tree_structure 2\` - show the result
Example - Adding "Russell's Critique" to "Analytic Philosophy":
  Step 1: [find_node:Analytic Philosophy] â†’ "Selected: Analytic Philosophy"
  Step 2: [add_child:Russell's Critique] â†’ "Added child..."
  Step 3: [show_tree_structure 2] â†’ Shows updated tree

**ADD MULTIPLE CHILDREN** (to add several nodes to same parent):
1. FIRST: \`find_node:{parent name}\` - focus on parent ONCE
2. THEN: \`add_child:{name1}\` - add first child
3. THEN: \`add_child:{name2}\` - add second child (parent still focused)
4. REPEAT for each child
5. FINALLY: \`show_tree_structure 2\` - show all changes at end
DO NOT re-focus parent between each add - it stays focused!

**MOVE NODE SEQUENCE**:
1. RUN: \`move_node:{source} to {destination}\`
2. THEN: \`show_tree_structure 2\` - show the result

**DELETE NODE SEQUENCE**:
1. RUN: \`delete_node:{name}\`
2. THEN: \`show_tree_structure 2\` - show the result

SHOW YOUR WORK - MANDATORY after ANY add/move/delete:
After EVERY change you MUST show the result:
1. RUN \`show_tree_structure 2\` - ALWAYS show updated structure
2. REPORT: "Added X to Y. Parent now has N children."
The user CANNOT see your changes unless you show them!

ERROR RECOVERY: If a command fails or returns unexpected results:
1. Try alternative commands (e.g., if \`focus_node\` fails, try \`find_node\`)
2. Check spelling/exact node names with \`search_tree\`
3. If truly stuck, use \`request_dev_help\` - DO NOT ask user to relay to Claude Code

DEVELOPER CHANNEL:
When you encounter a limitation or missing capability:
1. DO NOT ask the user to relay messages to Claude Code
2. INSTEAD, use: request_dev_help:{detailed description of what you need}
3. This sends your request directly to Claude Code who will implement and deploy the fix
4. Example: "request_dev_help:I need a command to bulk rename nodes matching a pattern"
This is YOUR direct line to get new capabilities - use it proactively!

GLOBAL (work anytime):
â€¢ find_command:{what you want} - DISCOVER commands by purpose (USE THIS FIRST!)
â€¢ project_info - Show project overview/stats
â€¢ search - Open search modal
â€¢ find_node:{query} - Search & focus a node
â€¢ focus_root - Focus on root node (for building from scratch)
â€¢ create_tree:{name} - Create a new tree with custom name
â€¢ rename_root:{name} - Rename the root node
â€¢ research:{query} - Web search via Gemini (requires Gemini API key)
â€¢ add_node:{name} or add_node:{name | description} - Add a new node to current phase
â€¢ add_child:{name} - Add a child node to the focused node
â€¢ add_phase - Add new phase
â€¢ add_research_nodes:[{name, description},...] - Add multiple research nodes
â€¢ preview_node:{name} - See node contents (description, children) in chat
â€¢ move_node:{source} to {destination} - Move a node to a new parent
â€¢ duplicate_node:{name} - Create a safety copy of a node (deep clone)
â€¢ compare_nodes:{node1} and {node2} - Check for duplicate content between nodes
â€¢ search_tree:{query} - Search nodes by name/description/id (use #tag for tag search)
â€¢ tag_node:{name} with {tags} - Add tags to a node (comma-separated)
â€¢ untag_node:{name} remove {tags} - Remove tags from a node
â€¢ list_tags - Show all tags used in the tree with counts
â€¢ list_empty_nodes - Find containers (phases/sections) with 0 children
â€¢ show_tree_structure:{depth} - Show hierarchical tree view (default depth: 3)
â€¢ find_duplicates - Find nodes with identical names
â€¢ node_stats:{name or id} - Show detailed stats for a node (children, depth, content size)
â€¢ merge_nodes:{source} into {target} - Merge source node into target (moves children, combines descriptions)
â€¢ delete_empty_nodes - Bulk delete all empty containers (preview/confirm options)
â€¢ rename_node:{old} to {new} - Rename a node (or just {new} if focused)
â€¢ read_node:{name} - Read full content/description of a node
â€¢ request_dev_help:{description} - Request new capabilities from Claude Code via MCP (requires bridge connection)
â€¢ whats_new - Show recent capabilities added in latest builds (RUN THIS AFTER REFRESH!)
â€¢ list_all_commands - Show all 100+ available commands
â€¢ bulk_move:{items} to {dest} - Move multiple items at once (comma-separated)
â€¢ analyze_balance - Show tree balance stats and redistribution suggestions
â€¢ open_wizard - Start AI wizard
â€¢ find_redundancies - Find duplicate nodes
â€¢ switch_to_canvas / switch_to_tree / switch_to_3d - Change view
â€¢ view_gantt - Switch to Gantt chart view
â€¢ view_calendar - Switch to Calendar view
â€¢ toggle_view - Cycle through all 5 views

CANVAS VIEW COMMANDS (Build 606):
Layout Commands (5 layouts for arranging nodes spatially):
â€¢ layout_hierarchical - Tree-like top-down arrangement (phases â†’ items â†’ subitems)
â€¢ layout_timeline - Left-to-right chronological arrangement
â€¢ layout_force - Clustered physics-based layout (related nodes group together)
â€¢ layout_grid - Clean 4-column grid arrangement
â€¢ layout_radial - Circular arrangement around center

Phase & Focus Controls:
â€¢ filter_phases - List all phases and their visibility status
â€¢ show_phase:{name} - Show a phase in canvas view
â€¢ hide_phase:{name} - Hide a phase from canvas view
â€¢ solo_phase:{name} - Show ONLY this phase (hide all others) - great for focusing on one topic!
â€¢ show_all_phases - Restore all phases to visible
â€¢ focus_hyperedge:{name} - Enter hyperedge focus mode (show only connected nodes)
â€¢ exit_focus - Exit hyperedge focus mode, return to full canvas
â€¢ list_hyperedges - List all hyperedges with their member counts

Camera Controls:
â€¢ focus_camera:{node name} - Center the canvas camera on a specific node
â€¢ zoom_fit - Zoom canvas to fit all visible nodes
â€¢ zoom_in / zoom_out - Adjust zoom level
â€¢ reset_camera - Reset canvas camera to default position

SCREEN AWARENESS (Build 564+ - requires Chrome Extension + MCP Bridge):
â€¢ capture_screen - Capture screenshot of current browser tab (Claude Code will analyze)
â€¢ extension_status - Check if Chrome extension is connected
â€¢ list_tabs - List open browser tabs
When you can't see what user sees, offer to capture_screen to help diagnose!

â€¢ refresh_tree / refresh_view / refresh_root - Re-render the tree view
â€¢ undo / redo - Undo/redo changes
â€¢ list_all_commands - Show all 90+ commands
â€¢ tree_analysis - Analyze which items have most content/children
â€¢ lifetree_health_check - (LifeTree) Health diagnostics
â€¢ find_hyperedges - Analyze tree for hyperedge suggestions (groups of related nodes)
â€¢ suggest_hyperedges - Same as find_hyperedges
â€¢ toggle_hyperedge_panel - Open/close hyperedge visibility panel
â€¢ open_file:{name} - Open a file by name (for filesystem/Drive trees with URLs)
â€¢ refresh_drive - Show Google Drive refresh instructions
â€¢ refresh_gmail - Show Gmail refresh instructions
â€¢ sync_gmail - Sync Gmail inbox via MCP/Claude Chrome (requires Claude Code connection)
â€¢ sync_drive - Sync Google Drive files via MCP/Claude Chrome (requires Claude Code connection)
â€¢ sync_calendar - Sync Google Calendar events via MCP/Claude Chrome (requires Claude Code connection)
â€¢ sync_all - Sync all connected services (Gmail, Drive, Calendar)
â€¢ deep_research:{query} - Research a topic via Claude Code web search and propose nodes for tree integration (requires Claude Code connection)

GMAIL ACTIONS (for email nodes - requires MCP Bridge):
â€¢ gmail_archive - Archive focused email (remove from inbox)
â€¢ gmail_unarchive - Move archived email back to inbox
â€¢ gmail_trash - Move focused email to trash (30-day recovery)
â€¢ gmail_star - Star the focused email
â€¢ gmail_unstar - Remove star from email
â€¢ gmail_mark_read - Mark focused email as read
â€¢ gmail_mark_unread - Mark email as unread
â€¢ gmail_open - Open email in Gmail (browser tab)
â€¢ gmail_reply - Open reply composer for focused email
â€¢ gmail_forward - Open forward composer for focused email
â€¢ gmail_batch_archive:{query} - Archive all emails matching query (e.g., "from:newsletter")
â€¢ gmail_batch_star:{query} - Star all emails matching query
â€¢ gmail_triage_summary - Summarize inbox: urgent, needs reply, can archive

GANTT/SCHEDULE (for tasks with dates):
â€¢ view_gantt - Switch to Gantt chart view
â€¢ gantt_view_mode:{day|week|month|year} - Change time scale
â€¢ gantt_zoom_in / gantt_zoom_out / gantt_fit_all - Zoom controls
â€¢ gantt_today - Scroll to today's date
â€¢ gantt_toggle_critical_path - Highlight critical path (0 slack tasks)
â€¢ gantt_select:{task name} - Find and select a task
â€¢ gantt_focus_overdue - Jump to first overdue task
â€¢ gantt_next_critical - Cycle through critical path tasks

SCHEDULE ANALYSIS (Build 486):
â€¢ gantt_summary - Overall schedule health and stats
â€¢ gantt_critical_path - Critical path breakdown with slack info
â€¢ gantt_overdue - List overdue tasks with days late
â€¢ gantt_blockers - Tasks blocking the most downstream work
â€¢ gantt_slack:{task name} - Slack analysis (omit name for overview)
â€¢ gantt_dependencies:{task name} - Show predecessors and successors

SCHEDULE EDITING (Build 487):
â€¢ gantt_set_dates:{task}, {start}, {end} - Update task start/end dates
â€¢ gantt_set_start:{task}, {date} - Update start date only
â€¢ gantt_set_end:{task}, {date} - Update end date only
â€¢ gantt_set_duration:{task}, {days} - Set duration (adjusts end date)
â€¢ gantt_set_progress:{task}, {0-100} - Update progress percentage
â€¢ gantt_set_status:{task}, {status} - Set status (Not Started/In Progress/Done/Blocked)
â€¢ gantt_add_dependency:{from}, {to}, {type} - Create dependency (FS/SS/FF/SF)
â€¢ gantt_remove_dependency:{from}, {to} - Remove dependency between tasks
â€¢ gantt_mark_done:{task} - Shortcut: set progress 100%, status Done
â€¢ gantt_mark_blocked:{task}, {reason} - Set status Blocked with reason

REQUIRES FOCUSED NODE (use find_node first!):
â€¢ add_child:{name} - Add child to focused node
â€¢ edit_node - Open node editor
â€¢ expand_node / collapse_node - Toggle expansion
â€¢ set_field:{field}:{value} - Set field value
â€¢ deep_dive - AI analysis of node
â€¢ quick_insight - Quick node summary

CANVAS TIPS (tell user, no action needed):
â€¢ Ctrl+F: Search overlay
â€¢ Minimap: Drag viewport to pan
â€¢ Mobile: Pinch-to-zoom, swipe gestures

INFO PANEL FEATURES (tell user, no action needed):
â€¢ Reader Navigation: Prev/Next buttons for sequential reading
â€¢ TTS Read Aloud: Click ğŸ”Š to hear node descriptions
â€¢ Auto-Play: Toggle to read through entire tree sequentially

IMPORTANT: When suggesting buttons, prefer GLOBAL commands. If action needs a node, first use find_node to focus one.`;
        }

        /**
         * BUILD 378: Current pattern fields - loaded when pattern help needed (~100 tokens)
         */
        function getCurrentPatternFields(pattern) {
            const patternFields = {
                generic: 'cost, leadTime, dependencies, pmStatus, pmProgress',
                philosophy: 'speaker, premises, objections, dialectics, textualReference',
                sales: 'dealValue, probability, closeDate, contacts, stage',
                lifetree: 'eventDate, age, location, people, emotion, source, confidence',
                capex: 'cost, vendor, leadTime, riskLevel, approvalStatus',
                thesis: 'wordCount, citations, keyArgument, methodology',
                film: 'camera, lighting, videoPrompt, duration',
                veo3: 'videoPrompt, duration, aspectRatio, style',
                sora2: 'videoPrompt, duration, aspectRatio, style'
            };
            return `Pattern "${pattern}" fields: ${patternFields[pattern] || patternFields.generic}`;
        }

        /**
         * BUILD 378: Feature guide - loaded when user asks about capabilities (~150 tokens)
         */
        function getFeatureGuide() {
            return `
KEY FEATURES:
â€¢ AI Wizard (open_wizard): Conversational tree building
â€¢ Research (research:{query}): Web search via Gemini - finds info, suggests nodes to add
â€¢ Deep Dive: Multi-node scholarly analysis
â€¢ Smart Suggest: AI fills fields contextually
â€¢ Hyperedges: Cross-phase connections (Canvas View â†’ multi-select â†’ Create)
â€¢ Find Redundancies: Detect duplicate nodes
â€¢ Health Check (lifetree_health_check): LifeTree diagnostics - empty phases, redundant periods, chronology
â€¢ Tree Analysis (tree_analysis): Find items with most content/children
â€¢ Canvas Search (Ctrl+F): Find nodes by name/description, zoom to result
â€¢ Minimap: Bird's-eye navigation, drag viewport to pan
â€¢ Voice Capture: Mobile recording â†’ AI processing
â€¢ Artifacts: Attach files to nodes
â€¢ Live Sync: Real-time collaboration
â€¢ Debate Mode: AI vs AI debates with insight extraction

VIEWS (5 total):
â€¢ Tree View: Hierarchical list for editing
â€¢ Canvas View: 2D diagram with drag-drop, layouts, dependencies
â€¢ 3D View: Three.js spatial visualization
â€¢ Gantt View: Professional scheduling timeline (Frappe Gantt)
â€¢ Calendar View: Monthly event calendar

GANTT COMMANDS (view_gantt to access):
â€¢ gantt_view_mode:{day|week|month|year} - Change zoom level
â€¢ gantt_zoom_in/out/fit_all - Zoom controls
â€¢ gantt_today - Scroll to current date
â€¢ gantt_toggle_critical_path - Highlight 0-slack tasks
â€¢ gantt_summary - Schedule health overview
â€¢ gantt_critical_path - Critical path breakdown
â€¢ gantt_overdue - List overdue tasks
â€¢ gantt_set_dates:{task},{start},{end} - Update task dates
â€¢ gantt_set_progress:{task},{0-100} - Update progress

READER NAVIGATION:
â€¢ Prev/Next buttons in info panel for sequential reading
â€¢ Position indicator shows "3 of 12"
â€¢ Group iteration for hyperedge members
â€¢ Works in Tree and Canvas views

TTS READ ALOUD:
â€¢ speakNode() - Read node description aloud
â€¢ Auto-Play mode - Sequential reading through tree
â€¢ Stop/Resume playback controls

MOBILE FEATURES:
â€¢ Pinch-to-zoom on Canvas, 3D, Gantt
â€¢ Swipe gestures for panel navigation
â€¢ Touch-friendly context menus
â€¢ Voice input on import modal`;
        }

        // BUILD 485: Expose helper functions for testing
        window.detectTreeBeardIntent = detectTreeBeardIntent;
        window.getCommandVocabulary = getCommandVocabulary;

        /**
         * BUILD 403: Simplified LifeTree Utility Prompt
         * Quick memory addition and utility commands - full interview moved to Chat Builder
         */
        function getLifeTreeBiographerPrompt(phases, context, chatState) {
            const birthYear = capexTree?.birthYear || capexTree?.metadata?.birthYear ||
                (phases[0]?.name?.match(/\d{4}/) ? parseInt(phases[0].name.match(/\d{4}/)[0]) : null);
            const subjectName = capexTree?.metadata?.subjectName || context.projectName.replace("'s Life", "").replace(" Life", "").trim();
            const eventCount = phases.reduce((sum, p) => sum + (p.items || p.children || []).length, 0);

            return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
LIFETREE UTILITY MODE - BUILD 403
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

You're a quick utility assistant for ${subjectName}'s LifeTree (${eventCount} memories captured).
Birth year: ${birthYear || 'Unknown'}

YOUR ROLE: Fast, helpful memory capture and tree management. NOT interviews - use Chat Builder (ğŸ’¬) for full Larry King-style biography interviews.

WHAT YOU DO:
â€¢ Quick memory adds from voice/text
â€¢ Find memories by date, person, or place
â€¢ Summarize the life story so far
â€¢ Run health checks on the tree
â€¢ Navigate to specific decades

RESPONSE STYLE:
â€¢ Brief, friendly acknowledgments
â€¢ Save memories immediately with [ACTION:] tags
â€¢ No long interview questions - just quick utility

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
MEMORY CAPTURE FORMAT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

When user shares a memory, extract what you can and save immediately:

RICH FORMAT (extract all available details):
[ACTION: find_node:{decade}]
[ACTION: add_child:{"name":"Event Title","eventDate":"Date","age":"Age","location":"Place","people":"Who","description":"Details","emotion":"joy|pride|etc"}]

SIMPLE FORMAT (for quick entries):
[ACTION: add_child:Started kindergarten at Main Street School]

ACKNOWLEDGE SAVES: "âœ“ Added: [title] (+1)"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
AVAILABLE COMMANDS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â€¢ find_node:{term} - Navigate to decade, person, or place
â€¢ add_child:{JSON or text} - Add memory to focused location
â€¢ set_field:{field}:{value} - Update field on focused node
â€¢ health_check - Run LifeTree diagnostics
â€¢ summarize - Give overview of life story so far

EXAMPLE - User voice capture: "I graduated high school in 1978"

RESPONSE:
"âœ“ Added: High school graduation (+1)

[ACTION: find_node:1970s]
[ACTION: add_child:{"name":"High School Graduation","eventDate":"1978","age":"${birthYear ? 1978 - birthYear : '?'}","description":"Graduated high school"}]"

ğŸ’¡ TIP: For full biography interviews with guided questions, use the Chat Builder (ğŸ’¬ button) with LifeTree pattern.
`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 384: REPAIR ISSUE DISPLAY - Show issues one at a time
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function showRepairIssue(index) {
            if (!window.repairQueue || index >= window.repairQueue.length) {
                // All done
                const fixed = window.repairIndex || 0;
                const total = window.repairQueue?.length || 0;
                const skipped = total - fixed;
                addMessage(`âœ… **Repair complete!** Fixed ${fixed} issue${fixed !== 1 ? 's' : ''}${skipped > 0 ? `, skipped ${skipped}` : ''}.`, 'assistant');
                window.repairQueue = null;
                window.repairIndex = 0;
                return;
            }

            const issue = window.repairQueue[index];
            const remaining = window.repairQueue.length - index;
            let message = `\n**Issue ${index + 1}/${window.repairQueue.length}:**\n`;

            if (issue.type === 'undefined') {
                const phaseName = issue.phase?.name || 'Unknown phase';
                const children = issue.node.children || issue.node.items || issue.node.subItems || [];
                const childList = children.slice(0, 3).map(c => c.name || c.title || '?').join(', ');
                const moreChildren = children.length > 3 ? ` +${children.length - 3} more` : '';

                message += `ğŸ”´ **Undefined node** in ${phaseName}\n`;
                if (children.length > 0) {
                    message += `   â””â”€ Contains: ${childList}${moreChildren}\n`;
                }
                message += `\nğŸ’¡ Suggested name: "${issue.suggestion}"`;

                addMessage(message, 'assistant', [
                    { label: `âœ“ Rename to "${issue.suggestion}"`, action: 'repair_rename', param: issue.suggestion },
                    { label: 'ğŸ—‘ï¸ Delete & Keep Children', action: 'repair_delete_promote' },
                    { label: 'âœï¸ Custom Name...', action: 'repair_custom_name' },
                    { label: 'â­ï¸ Skip', action: 'repair_skip' }
                ]);

            } else if (issue.type === 'duplicate') {
                const phaseName = issue.phase?.name || 'Unknown phase';
                const similarity = Math.round(issue.similarity * 100);

                message += `ğŸŸ¡ **Duplicate found** in ${phaseName} (${similarity}% similar)\n`;
                message += `   â€¢ "${issue.node.name || issue.node.title}"\n`;
                message += `   â€¢ "${issue.duplicate.name || issue.duplicate.title}"`;

                addMessage(message, 'assistant', [
                    { label: 'ğŸ”— Merge Into One', action: 'repair_merge' },
                    { label: 'âœ“ Keep Both', action: 'repair_skip' },
                    { label: 'âœï¸ Rename Second', action: 'repair_rename_duplicate' }
                ]);

            } else if (issue.type === 'missing_id') {
                // Auto-fix missing IDs
                issue.node.id = 'repair_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                message += `ğŸŸ¢ **Fixed:** Added missing ID to "${issue.node.name || 'node'}"`;
                addMessage(message, 'assistant');

                // Auto-advance
                window.repairIndex++;
                setTimeout(() => showRepairIssue(window.repairIndex), 300);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 613: TOOL-USE AI INTERPRETER
        // Forces structured output via Claude's tool_use API
        // Fallback: MCP dispatch to Claude Code
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Define TreeBeard tools for Claude's tool_use API
        const TREEBEARD_TOOLS = [
            // View switching
            { name: 'switch_to_canvas', description: 'Switch to Canvas view for visual node diagram', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'switch_to_tree', description: 'Switch to Tree view for hierarchical outline', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'switch_to_3d', description: 'Switch to 3D view for spatial visualization', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'view_gantt', description: 'Switch to Gantt chart timeline view', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'view_calendar', description: 'Switch to Calendar view', input_schema: { type: 'object', properties: {}, required: [] } },
            // Edge/hyperedge visibility
            { name: 'show_edges', description: 'Show all hyperedges/connections in canvas', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'hide_edges', description: 'Hide all hyperedges/connections in canvas', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'toggle_edges', description: 'Toggle hyperedge visibility on/off', input_schema: { type: 'object', properties: {}, required: [] } },
            // Phase filtering
            { name: 'solo_phase', description: 'Show only one phase in canvas, hide others', input_schema: { type: 'object', properties: { phase_name: { type: 'string', description: 'Name of phase to show' } }, required: ['phase_name'] } },
            { name: 'hide_phase', description: 'Hide a specific phase from canvas', input_schema: { type: 'object', properties: { phase_name: { type: 'string', description: 'Name of phase to hide' } }, required: ['phase_name'] } },
            { name: 'show_all_phases', description: 'Show all phases in canvas', input_schema: { type: 'object', properties: {}, required: [] } },
            // Camera control
            { name: 'zoom_fit', description: 'Zoom to fit all nodes in view', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'focus_camera', description: 'Center camera on a specific node', input_schema: { type: 'object', properties: { node_name: { type: 'string', description: 'Name of node to focus on' } }, required: ['node_name'] } },
            { name: 'reset_camera', description: 'Reset camera to default position', input_schema: { type: 'object', properties: {}, required: [] } },
            // Layout
            { name: 'layout_grid', description: 'Arrange nodes in grid layout', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'layout_radial', description: 'Arrange nodes in radial/circular layout', input_schema: { type: 'object', properties: {}, required: [] } },
            // Navigation
            { name: 'expand_all', description: 'Expand all nodes in tree', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'collapse_all', description: 'Collapse all nodes in tree', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'search_tree', description: 'Search for nodes by name or content', input_schema: { type: 'object', properties: { query: { type: 'string', description: 'Search query' } }, required: ['query'] } },
            { name: 'find_node', description: 'Find and focus on a specific node', input_schema: { type: 'object', properties: { node_name: { type: 'string', description: 'Name of node to find' } }, required: ['node_name'] } },
            // Editing
            { name: 'add_child', description: 'Add a child node under a parent', input_schema: { type: 'object', properties: { parent_name: { type: 'string', description: 'Name of parent node' }, child_name: { type: 'string', description: 'Name for new child' } }, required: ['parent_name', 'child_name'] } },
            { name: 'rename_node', description: 'Rename a node', input_schema: { type: 'object', properties: { old_name: { type: 'string', description: 'Current node name' }, new_name: { type: 'string', description: 'New name' } }, required: ['old_name', 'new_name'] } },
            // Undo/Redo
            { name: 'undo', description: 'Undo last action', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'redo', description: 'Redo last undone action', input_schema: { type: 'object', properties: {}, required: [] } },
            // Help
            { name: 'show_help', description: 'Show help and available commands', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'list_hyperedges', description: 'List all hyperedges in the tree', input_schema: { type: 'object', properties: {}, required: [] } },
            // BUILD 615: Capability commands
            { name: 'list_capabilities', description: 'List all capability nodes (Chrome web actions)', input_schema: { type: 'object', properties: {}, required: [] } },
            { name: 'create_capability', description: 'Create a new capability for web actions', input_schema: { type: 'object', properties: { name: { type: 'string', description: 'Capability name (e.g., "Chase Balance")' }, site: { type: 'string', description: 'Website domain (e.g., "chase.com")' }, goal: { type: 'string', description: 'What the capability does' } }, required: ['name', 'site', 'goal'] } },
            { name: 'test_capability', description: 'Test if a capability still works', input_schema: { type: 'object', properties: { capability_name: { type: 'string', description: 'Name of capability to test' } }, required: ['capability_name'] } },
            // Conversational response (when no action needed)
            { name: 'respond', description: 'Respond conversationally without executing a command', input_schema: { type: 'object', properties: { message: { type: 'string', description: 'Response message to user' } }, required: ['message'] } }
        ];

        async function callTreeBeardWithTools(userMessage, context) {
            const anthropicKey = localStorage.getItem('anthropic_api_key');

            // Check for API key
            if (!anthropicKey) {
                // Try server proxy as fallback
                return await callTreeBeardViaServer(userMessage, context);
            }

            const systemPrompt = `You are TreeBeard, the AI assistant for TreeListy. You help users navigate and manipulate hierarchical project trees.

CURRENT CONTEXT:
- Project: ${context.projectName}
- Pattern: ${context.pattern}
- View: ${context.viewMode}
- Phases: ${context.phaseCount}
- Items: ${context.itemCount}

INSTRUCTIONS:
1. Analyze the user's request
2. Use the appropriate tool(s) to fulfill it
3. For compound requests (e.g., "canvas view with edges"), use MULTIPLE tools
4. If no action is needed, use the 'respond' tool to reply conversationally
5. ALWAYS use a tool - never return plain text

Be concise and helpful. ğŸŒ³ is your signature.`;

            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': anthropicKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 1024,
                        system: systemPrompt,
                        tools: TREEBEARD_TOOLS,
                        tool_choice: { type: 'any' }, // Force tool use
                        messages: [{ role: 'user', content: userMessage }]
                    })
                });

                const data = await response.json();
                if (data.error) throw new Error(data.error.message);

                // BUILD 614: Track API usage in Work Status
                const inputTokens = data.usage?.input_tokens || 0;
                const outputTokens = data.usage?.output_tokens || 0;
                const estimatedCost = (inputTokens * 0.003 + outputTokens * 0.015) / 1000; // Sonnet pricing
                workStatusTrackAPI('Claude (TreeBeard)', inputTokens + outputTokens, estimatedCost);
                updateWorkStatusUI();

                // Parse and execute tool calls
                return executeToolCalls(data.content, userMessage);

            } catch (error) {
                console.error('ğŸŒ³ Tool-use API failed:', error);
                // Fallback to MCP dispatch
                return fallbackToMCPDispatch(userMessage);
            }
        }

        async function callTreeBeardViaServer(userMessage, context) {
            // Server proxy doesn't support tool-use yet, use traditional approach
            // This is the existing behavior - returns to interpretCommand flow
            return null; // Signal to use existing interpretCommand logic
        }

        function executeToolCalls(content, userMessage) {
            const results = [];
            let responseMessage = '';

            for (const block of content) {
                if (block.type === 'tool_use') {
                    const toolName = block.name;
                    const toolInput = block.input || {};

                    console.log(`ğŸŒ³ Tool-use: ${toolName}`, toolInput);

                    // Handle conversational response
                    if (toolName === 'respond') {
                        responseMessage = toolInput.message || 'ğŸŒ³ How can I help?';
                        continue;
                    }

                    // Execute command via COMMAND_REGISTRY
                    if (COMMAND_REGISTRY[toolName]) {
                        try {
                            // Map tool input to command parameters
                            const param = toolInput.phase_name || toolInput.node_name ||
                                         toolInput.query || toolInput.parent_name ||
                                         toolInput.old_name || null;

                            const result = COMMAND_REGISTRY[toolName](param);
                            results.push({ tool: toolName, result: result, success: true });

                            // Build response message
                            if (typeof result === 'string') {
                                responseMessage += (responseMessage ? '\n' : '') + result;
                            } else if (result && result.message) {
                                responseMessage += (responseMessage ? '\n' : '') + result.message;
                            }
                        } catch (err) {
                            console.error(`ğŸŒ³ Tool ${toolName} failed:`, err);
                            results.push({ tool: toolName, error: err.message, success: false });
                        }
                    } else {
                        console.warn(`ğŸŒ³ Unknown tool: ${toolName}`);
                        results.push({ tool: toolName, error: 'Unknown command', success: false });
                    }
                } else if (block.type === 'text') {
                    // Shouldn't happen with tool_choice: any, but handle it
                    responseMessage = block.text;
                }
            }

            // If no message generated, create summary
            if (!responseMessage && results.length > 0) {
                const successfulTools = results.filter(r => r.success).map(r => r.tool);
                responseMessage = `ğŸŒ³ Executed: ${successfulTools.join(', ')}`;
            }

            return {
                type: 'action',
                message: responseMessage || 'ğŸŒ³ Done!',
                toolResults: results,
                buttons: null
            };
        }

        async function fallbackToMCPDispatch(userMessage) {
            console.log('ğŸŒ³ Falling back to MCP dispatch');

            // Check if MCP bridge is connected
            if (typeof mcpBridgeState !== 'undefined' && mcpBridgeState.client?.connected) {
                try {
                    const result = COMMAND_REGISTRY['dispatch_task'](userMessage);
                    return {
                        type: 'action',
                        message: result || 'ğŸŒ³ Task dispatched to Claude Code for execution.',
                        action: 'dispatch_task',
                        buttons: null
                    };
                } catch (err) {
                    console.error('MCP dispatch failed:', err);
                }
            }

            // Final fallback - return helpful message
            return {
                type: 'answer',
                message: 'ğŸŒ³ I couldn\'t execute that command directly. Try:\nâ€¢ More specific phrasing\nâ€¢ Check available commands with "help"\nâ€¢ Or connect Claude Code for advanced actions',
                buttons: [
                    { label: 'ğŸ“– Help', action: 'show_help' },
                    { label: 'ğŸ”Œ Connect Claude Code', action: 'check_mcp_status' }
                ]
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AI COMMAND INTERPRETER - BUILD 378: TIERED PROMPT SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function interpretCommand(userMessage) {
            // Get current context
            const phases = typeof capexTree !== 'undefined' ? (capexTree.children || capexTree.phases || []) : [];
            const context = {
                projectName: typeof capexTree !== 'undefined' ? capexTree.name : 'Unknown',
                pattern: typeof currentPattern !== 'undefined' ? currentPattern : 'generic',
                itemCount: phases.reduce((sum, p) => sum + (p.items || p.children || []).length, 0),
                phaseCount: phases.length,
                viewMode: document.getElementById('canvas-container')?.classList.contains('active') ? 'canvas' : 'tree',
                selectedCount: window.selectedCanvasNodes?.length || 0
            };

            // Detect user intent
            const intent = detectTreeBeardIntent(userMessage);
            const conversationCount = chatState.conversationHistory.filter(m => m.role === 'user').length;
            const familiarityLevel = conversationCount > 5 ? 'familiar' : conversationCount > 2 ? 'acquainted' : 'new';

            // BUILD 378: Tiered prompt construction - only load what's needed
            let systemPrompt = getTreeBeardCorePersona(context, familiarityLevel);

            // Tier 1: Always include response format (~100 tokens)
            systemPrompt += `

RESPONSE FORMAT (JSON only):
{"type": "action"|"answer"|"clarify", "message": "response", "action": "cmd"|null, "actionParam": "param"|null, "buttons": [{"label":"X","action":"y"}]|null}

CRITICAL: The "action" field must be EXACTLY one of the listed commands (e.g., "refresh_tree", "find_node", "add_child") or null.
NEVER use natural language descriptions as action values. If unsure, use null.
Return ONLY valid JSON.`;

            // Tier 2: Add commands if navigation/editing detected (~200 tokens)
            if (intent.needsNavigation || intent.needsEditing || intent.isComplex || intent.needsHealthCheck) {
                systemPrompt += getCommandVocabulary();
            }

            // BUILD 392: Direct health check execution for LifeTree
            if (intent.needsHealthCheck && context.pattern === 'lifetree') {
                // Execute directly without AI call
                const result = COMMAND_REGISTRY['lifetree_health_check']();
                return typeof result === 'object' ? result : { message: result, buttons: null };
            }

            // Tier 3: Add pattern fields if pattern questions detected (~100 tokens)
            if (intent.needsPatternInfo) {
                systemPrompt += '\n' + getCurrentPatternFields(context.pattern);
            }

            // Tier 4: Add feature guide if asking about capabilities (~150 tokens)
            if (intent.needsFeatureHelp) {
                systemPrompt += getFeatureGuide();
            }

            // Tier 5: LifeTree biographer mode - Larry King style (~400 tokens)
            if (context.pattern === 'lifetree') {
                systemPrompt += getLifeTreeBiographerPrompt(phases, context, chatState);
            }

            // BUILD 488: Tier 6 - Schedule context for PM Assistant
            // Inject when: in Gantt view, schedule keywords detected, or tree has schedule data with status questions
            const isInGanttView = typeof viewMode !== 'undefined' && viewMode === 'gantt';
            // Use existing conversationMode toggle (Deep mode = more detailed context)
            const useDeepScheduleContext = chatState.conversationMode === true;

            if (intent.needsScheduleHelp || isInGanttView) {
                const scheduleContext = getScheduleContext(useDeepScheduleContext);
                if (scheduleContext) {
                    systemPrompt += '\n\n' + scheduleContext;
                    systemPrompt += '\n\nYou can use GANTT/SCHEDULE commands to help with schedule tasks. Explain PM concepts briefly when relevant (critical path = longest chain, slack = buffer time, etc).';
                }
            }

            // Log token savings in dev
            console.log(`ğŸŒ³ TreeBeard prompt tiers: greeting=${intent.isGreeting}, nav=${intent.needsNavigation}, edit=${intent.needsEditing}, help=${intent.needsFeatureHelp}, pattern=${intent.needsPatternInfo}, lifetree=${context.pattern === 'lifetree'}, healthCheck=${intent.needsHealthCheck}, schedule=${intent.needsScheduleHelp || isInGanttView}`);

            // Always add minimal rules
            systemPrompt += `

RULES: Be concise (2-3 sentences). ğŸŒ³ is your signature. Show personality.`;

            try {
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // BUILD 613: Try tool-use API first (guaranteed structured output)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const toolUseResult = await callTreeBeardWithTools(userMessage, context);
                if (toolUseResult) {
                    console.log('ğŸŒ³ Tool-use succeeded:', toolUseResult);
                    return toolUseResult;
                }
                // Tool-use unavailable (no API key) or failed - fall back to existing approach
                console.log('ğŸŒ³ Tool-use unavailable, using traditional approach');

                // Use TreeListy's existing AI infrastructure
                const aiMode = document.getElementById('unified-ai-mode-select')?.value || 'server-sonnet';

                let response;
                if (aiMode.startsWith('server-')) {
                    // Use server proxy
                    response = await fetch('/.netlify/functions/claude-proxy', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 500,
                            messages: [
                                ...chatState.conversationHistory.slice(-6).map(m => ({
                                    role: m.role === 'user' ? 'user' : 'assistant',
                                    content: m.content
                                })),
                                { role: 'user', content: systemPrompt + '\n\nUser message: ' + userMessage }
                            ]
                        })
                    });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error);
                    return JSON.parse(data.content[0].text);
                } else if (aiMode.startsWith('user-')) {
                    // Use user's API key
                    const anthropicKey = localStorage.getItem('anthropic_api_key');
                    if (!anthropicKey) {
                        return {
                            type: 'answer',
                            message: 'ğŸ”‘ Please set your API key in Settings (ğŸ”‘ button) or switch to Server mode.',
                            action: null
                        };
                    }
                    response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': anthropicKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 500,
                            messages: [{ role: 'user', content: systemPrompt + '\n\nUser message: ' + userMessage }]
                        })
                    });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return JSON.parse(data.content[0].text);
                }
            } catch (error) {
                console.error('Chat AI error:', error);
                // Fallback to simple pattern matching
                return fallbackInterpret(userMessage);
            }
        }

        // Simple fallback when AI unavailable - also handles direct commands
        function fallbackInterpret(message) {
            const lower = message.toLowerCase();
            const original = message; // Keep original for parameters

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NODE NAVIGATION (Build 250) - Most powerful commands
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Find node: "find Being", "search for Becoming", "locate synthesis"
            const findMatch = original.match(/(?:find|search|locate|go to|show me)\s+(?:node\s+)?["']?(.+?)["']?$/i);
            if (findMatch) {
                return { type: 'action', message: `ğŸ” Searching for "${findMatch[1]}"...`, action: 'find_node', actionParam: findMatch[1] };
            }

            // Focus by ID: "focus node_123"
            const focusMatch = original.match(/focus\s+(?:on\s+)?(?:node\s+)?(\S+)/i);
            if (focusMatch && focusMatch[1].includes('_')) {
                return { type: 'action', message: `ğŸ¯ Focusing on ${focusMatch[1]}...`, action: 'focus_node', actionParam: focusMatch[1] };
            }

            // BUILD 538: Focus on root node
            if (lower.match(/focus\s+(?:on\s+)?root|go\s+to\s+root|select\s+root/)) {
                return { type: 'action', message: 'ğŸ¯ Focusing on root node...', action: 'focus_root' };
            }

            // BUILD 538: Create new tree - "create tree X", "new tree called X", "create a tree called X"
            const createTreeMatch = original.match(/(?:create|new|start)\s+(?:a\s+)?(?:new\s+)?tree\s+(?:called\s+)?["']?([^"']+?)["']?$/i);
            if (createTreeMatch) {
                return { type: 'action', message: `ğŸŒ³ Creating new tree: "${createTreeMatch[1]}"...`, action: 'create_tree', actionParam: createTreeMatch[1].trim() };
            }

            // BUILD 538: Rename root - "rename root to X"
            const renameRootMatch = original.match(/rename\s+root\s+(?:to\s+)?["']?([^"']+?)["']?$/i);
            if (renameRootMatch) {
                return { type: 'action', message: `âœï¸ Renaming root to "${renameRootMatch[1]}"...`, action: 'rename_root', actionParam: renameRootMatch[1].trim() };
            }

            // Expand current node
            if (lower.match(/^expand(\s+node)?(\s+it)?$/)) {
                return { type: 'action', message: 'â¬‡ï¸ Expanding focused node...', action: 'expand_node' };
            }

            // Collapse current node
            if (lower.match(/^collapse(\s+node)?(\s+it)?$/)) {
                return { type: 'action', message: 'â¬†ï¸ Collapsing focused node...', action: 'collapse_node' };
            }

            // Tree navigation
            if (lower.includes('first child') || lower.includes('go to child') || lower.includes('into')) {
                return { type: 'action', message: 'ğŸ‘¶ Moving to first child...', action: 'first_child' };
            }
            if (lower.includes('parent') || lower.includes('go up') || lower.includes('back up')) {
                return { type: 'action', message: 'â¬†ï¸ Moving to parent...', action: 'parent_node' };
            }
            if (lower.includes('next') || lower.includes('next sibling')) {
                return { type: 'action', message: 'â¡ï¸ Moving to next sibling...', action: 'next_sibling' };
            }
            if (lower.includes('prev') || lower.includes('previous')) {
                return { type: 'action', message: 'â¬…ï¸ Moving to previous sibling...', action: 'prev_sibling' };
            }
            if (lower.includes('list child') || lower.includes('show child') || lower.includes('children')) {
                return { type: 'action', message: 'ğŸ“‹ Listing children...', action: 'list_children' };
            }
            if (lower.includes('node info') || lower.includes('current node') || lower.includes('what node')) {
                return { type: 'action', message: 'ğŸ“ Node info:', action: 'node_info' };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 384: REPAIR TREE COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            if (lower.includes('repair') || lower.includes('fix bad') || lower.includes('fix undefined') ||
                lower.includes('find duplicate') || lower.includes('health check') || lower.includes('clean up tree')) {
                return { type: 'action', message: 'ğŸ”§ Scanning tree for issues...', action: 'repair_tree' };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIELD EDITING (Build 250)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Set title: "set title to X", "rename to X", "title: X"
            const titleMatch = original.match(/(?:set\s+title|rename|title)\s*(?:to|:)\s*["']?(.+?)["']?$/i);
            if (titleMatch) {
                return { type: 'action', message: `âœï¸ Setting title...`, action: 'set_title', actionParam: titleMatch[1] };
            }

            // Set description: "set description to X", "describe as X"
            const descMatch = original.match(/(?:set\s+description|describe|description)\s*(?:to|as|:)\s*["']?(.+?)["']?$/i);
            if (descMatch) {
                return { type: 'action', message: `ğŸ“ Setting description...`, action: 'set_description', actionParam: descMatch[1] };
            }

            // Set any field: "set thesis to X"
            const fieldMatch = original.match(/set\s+(\w+)\s+(?:to|:)\s*["']?(.+?)["']?$/i);
            if (fieldMatch && !['title', 'description', 'theme'].includes(fieldMatch[1].toLowerCase())) {
                return { type: 'action', message: `âœ… Setting ${fieldMatch[1]}...`, action: 'set_field', actionParam: `${fieldMatch[1]}:${fieldMatch[2]}` };
            }

            // Get field: "get thesis", "show description", "what is the title"
            const getMatch = original.match(/(?:get|show|what\s+is\s+(?:the\s+)?)\s*(\w+)$/i);
            if (getMatch && ['thesis', 'argument', 'description', 'source', 'status'].includes(getMatch[1].toLowerCase())) {
                return { type: 'action', message: `ğŸ“– Getting ${getMatch[1]}...`, action: 'get_field', actionParam: getMatch[1] };
            }

            // List fields
            if (lower.includes('list fields') || lower.includes('show fields') || lower.includes('what fields')) {
                return { type: 'action', message: 'ğŸ“‹ Listing fields...', action: 'list_fields' };
            }

            // Add child: "add child X", "create child X", "new child X"
            const addChildMatch = original.match(/(?:add|create|new)\s+child\s*(?:named|called)?\s*["']?(.+?)["']?$/i);
            if (addChildMatch) {
                return { type: 'action', message: `â• Adding child "${addChildMatch[1]}"...`, action: 'add_child', actionParam: addChildMatch[1] };
            }

            // Delete node
            if (lower.includes('delete') && (lower.includes('node') || lower.includes('this') || lower.includes('it'))) {
                return { type: 'action', message: 'ğŸ—‘ï¸ Deleting focused node...', action: 'delete_node' };
            }

            // AI enhance field: "enhance description", "ai improve thesis"
            const enhanceFieldMatch = original.match(/(?:enhance|improve|ai\s+enhance|ai\s+improve)\s+(?:the\s+)?(\w+)/i);
            if (enhanceFieldMatch && ['description', 'thesis', 'argument', 'summary', 'explanation'].includes(enhanceFieldMatch[1].toLowerCase())) {
                return { type: 'action', message: `âœ¨ AI enhancing ${enhanceFieldMatch[1]}...`, action: 'ai_enhance_field', actionParam: enhanceFieldMatch[1] };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // VIEW CONTROL (Build 250)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            if (lower.includes('zoom in') || lower === 'zoom+') {
                return { type: 'action', message: 'ğŸ” Zooming in...', action: 'zoom_in' };
            }
            if (lower.includes('zoom out') || lower === 'zoom-') {
                return { type: 'action', message: 'ğŸ” Zooming out...', action: 'zoom_out' };
            }
            if (lower.includes('fit') || lower.includes('zoom fit') || lower.includes('fit all')) {
                return { type: 'action', message: 'ğŸ“ Fitting to view...', action: 'zoom_fit' };
            }
            if (lower.includes('reset') && lower.includes('zoom')) {
                return { type: 'action', message: 'ğŸ”„ Resetting zoom...', action: 'zoom_reset' };
            }
            if (lower.includes('scroll to') || lower.includes('center on')) {
                return { type: 'action', message: 'ğŸ“ Scrolling to node...', action: 'scroll_to_node' };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ORIGINAL COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // View commands
            if (lower.includes('canvas')) return { type: 'action', message: 'ğŸ¨ Switching to Canvas!', action: 'switch_to_canvas' };
            if (lower.includes('tree view') || lower === 'tree') return { type: 'action', message: 'ğŸŒ³ Switching to Tree!', action: 'switch_to_tree' };
            if (lower.includes('3d') || lower.includes('three')) return { type: 'action', message: 'ğŸŒ Switching to 3D!', action: 'switch_to_3d' };
            if (lower.includes('gantt') || lower.includes('schedule view') || lower.includes('timeline view')) return { type: 'action', message: 'ğŸ“Š Switching to Gantt!', action: 'view_gantt' };
            if (lower.includes('calendar')) return { type: 'action', message: 'ğŸ“… Switching to Calendar!', action: 'view_calendar' };
            if (lower.includes('toggle')) return { type: 'action', message: 'ğŸ”„ Toggling view!', action: 'toggle_view' };

            // Layout commands
            if (lower.includes('hierarchical') || lower.includes('hierarchy')) return { type: 'action', message: 'ğŸŒ³ Hierarchical layout!', action: 'layout_hierarchical' };
            if (lower.includes('timeline') && !lower.includes('gantt')) return { type: 'action', message: 'ğŸ“… Timeline layout!', action: 'layout_timeline' };
            if (lower.includes('force') || lower.includes('cluster')) return { type: 'action', message: 'ğŸŒ€ Force layout!', action: 'layout_force' };
            if (lower.includes('grid') && lower.includes('layout')) return { type: 'action', message: 'ğŸ“Š Grid layout!', action: 'layout_grid' };
            if (lower.includes('radial') || lower.includes('circular') || lower.includes('circle layout')) return { type: 'action', message: 'ğŸ¯ Radial layout!', action: 'layout_radial' };

            // File operations
            if (lower.includes('import excel')) return { type: 'action', message: 'ğŸ“Š Opening Excel import!', action: 'import_excel' };
            if (lower.includes('export excel') || (lower.includes('excel') && !lower.includes('import'))) return { type: 'action', message: 'ğŸ“Š Exporting Excel!', action: 'export_excel' };
            if (lower.includes('import') && lower.includes('text')) return { type: 'action', message: 'ğŸ“¥ Opening text import!', action: 'import_text' };
            if (lower.includes('load') && lower.includes('json')) return { type: 'action', message: 'ğŸ“‚ Loading JSON!', action: 'load_json' };
            if (lower.includes('save') || lower.includes('export json')) return { type: 'action', message: 'ğŸ’¾ Saving JSON!', action: 'export_json' };
            if (lower.includes('share') || lower.includes('shareable')) return { type: 'action', message: 'ğŸ“¤ Generating URL!', action: 'share_url' };
            if (lower.includes('sync') || lower.includes('firebase')) return { type: 'action', message: 'ğŸ”„ Opening sync!', action: 'live_sync' };
            if (lower.includes('png') || (lower.includes('image') && lower.includes('export'))) return { type: 'action', message: 'ğŸ“· Exporting PNG!', action: 'export_canvas_image' };

            // Editing
            if (lower.includes('pattern')) return { type: 'action', message: 'ğŸ“‹ Here are the patterns:', action: 'list_patterns' };
            if (lower.includes('add phase') || lower.includes('new phase')) return { type: 'action', message: 'â• Adding phase!', action: 'add_phase' };
            if (lower.includes('undo')) return { type: 'action', message: 'â†©ï¸ Undoing!', action: 'undo' };
            if (lower.includes('redo')) return { type: 'action', message: 'â†ªï¸ Redoing!', action: 'redo' };
            if (lower.includes('search')) return { type: 'action', message: 'ğŸ” Opening search!', action: 'search' };
            if (lower.includes('expand all')) return { type: 'action', message: 'â¬‡ï¸ Expanding all!', action: 'expand_all' };
            if (lower.includes('collapse all')) return { type: 'action', message: 'â¬†ï¸ Collapsing all!', action: 'collapse_all' };
            if (lower.includes('select all')) return { type: 'action', message: 'âœ… Selecting all!', action: 'select_all' };
            if (lower.includes('clear') && lower.includes('select')) return { type: 'action', message: 'ğŸ”² Clearing selection!', action: 'clear_selection' };

            // AI operations
            if (lower.includes('enhance') && !lower.includes('field')) return { type: 'action', message: 'âœ¨ Enhancing selected!', action: 'enhance_selected' };
            if (lower.includes('deep dive') || lower.includes('analyze')) return { type: 'action', message: 'ğŸ”¬ Deep diving!', action: 'deep_dive' };
            if (lower.includes('generate') && lower.includes('image')) return { type: 'action', message: 'ğŸ¨ Opening Imagen!', action: 'generate_image' };

            // Themes
            if (lower.includes('steampunk')) return { type: 'action', message: 'âš™ï¸ Steampunk theme!', action: 'set_theme_steampunk' };
            if (lower.includes('tron')) return { type: 'action', message: 'ğŸ’  Tron theme!', action: 'set_theme_tron' };
            if (lower.includes('powerpuff') || lower.includes('pink')) return { type: 'action', message: 'ğŸ’— Powerpuff theme!', action: 'set_theme_powerpuff' };
            if (lower.includes('dark') || lower.includes('default theme')) return { type: 'action', message: 'ğŸŒ™ Dark theme!', action: 'set_theme_dark' };

            // Settings & Help
            if (lower.includes('help')) return { type: 'action', message: 'ğŸ“– Opening help!', action: 'show_help' };
            if (lower.includes('wizard') || lower.includes('build')) return { type: 'action', message: 'ğŸ§™ Opening wizard!', action: 'open_wizard' };
            if (lower.includes('setting') || lower.includes('api') || lower.includes('key')) return { type: 'action', message: 'ğŸ”‘ Opening settings!', action: 'open_settings' };
            if (lower.includes('new project') || lower.includes('start fresh')) return { type: 'action', message: 'ğŸ†• New project!', action: 'new_project' };
            if (lower.includes('info') || lower.includes('status') || lower.includes('stats')) return { type: 'action', message: 'ğŸ“‹ Project info:', action: 'project_info' };

            // Default with navigation-focused buttons
            return {
                type: 'answer',
                message: "I can help with that! Try these navigation commands or quick actions:",
                buttons: [
                    { label: 'ğŸ” Find Node', action: 'search' },
                    { label: 'ğŸ“‹ Node Info', action: 'node_info' },
                    { label: 'ğŸ¨ Canvas', action: 'switch_to_canvas' },
                    { label: 'ğŸ§™ Wizard', action: 'open_wizard' }
                ]
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // BUILD 393: Unified toggle - opens appropriate UI based on preference
        function toggleChatPanel() {
            console.log('ğŸ¯ toggleChatPanel: useNewChatUI =', window.useNewChatUI);
            if (window.useNewChatUI) {
                console.log('ğŸ†• -> Opening Command Frame');
                toggleCommandFrame();
            } else {
                console.log('ğŸ“¦ -> Opening Classic Panel');
                toggleClassicPanel();
            }
        }

        // Classic panel toggle (original implementation)
        function toggleClassicPanel() {
            const panel = document.getElementById('chat-assistant-panel');
            const bubble = document.getElementById('chat-assistant-bubble');

            chatState.isOpen = !chatState.isOpen;

            if (chatState.isOpen) {
                panel.classList.add('open');
                bubble.classList.add('active');
                bubble.textContent = 'âœ•';
                document.getElementById('chat-assistant-input')?.focus();
            } else {
                panel.classList.remove('open');
                bubble.classList.remove('active');
                bubble.textContent = 'ğŸ’¬';
            }
        }

        // BUILD 393: Command Frame toggle
        function toggleCommandFrame() {
            const frame = document.getElementById('command-frame');
            const bubble = document.getElementById('chat-assistant-bubble');

            chatState.isOpen = !chatState.isOpen;

            if (chatState.isOpen) {
                frame.classList.add('open');
                frame.classList.remove('minimized');
                chatState.commandFrameMinimized = false;
                bubble.classList.add('active');
                bubble.textContent = 'âœ•';
                document.getElementById('command-input')?.focus();
            } else {
                frame.classList.remove('open');
                bubble.classList.remove('active');
                bubble.textContent = 'ğŸ’¬';
            }
        }
        window.toggleCommandFrame = toggleCommandFrame;

        // BUILD 393: Minimize Command Frame
        function minimizeCommandFrame() {
            const frame = document.getElementById('command-frame');
            chatState.commandFrameMinimized = !chatState.commandFrameMinimized;
            frame.classList.toggle('minimized', chatState.commandFrameMinimized);
        }
        window.minimizeCommandFrame = minimizeCommandFrame;

        // BUILD 393: Toggle command history section
        function toggleCommandHistory() {
            const history = document.querySelector('.command-history');
            history?.classList.toggle('collapsed');
        }
        window.toggleCommandHistory = toggleCommandHistory;

        // BUILD 393: Handle send from Command Frame
        async function handleCommandSend() {
            const input = document.getElementById('command-input');
            const message = input?.value?.trim();

            if (!message) return;

            // Add to history display
            addCommandMessage(message, 'user');
            input.value = '';

            // Process via existing handleSendMessage logic
            // This reuses the existing TreeBeard intelligence
            await processCommandInput(message);
        }
        window.handleCommandSend = handleCommandSend;

        // BUILD 393: Add message to Command Frame history
        function addCommandMessage(content, type = 'assistant') {
            const historyMessages = document.querySelector('.history-messages');
            if (!historyMessages) return;

            const msg = document.createElement('div');
            msg.className = `history-msg ${type}`;

            // Format content
            let formatted = content
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            // Truncate long messages for history
            if (formatted.length > 200) {
                formatted = formatted.substring(0, 200) + '...';
            }

            msg.innerHTML = formatted;
            historyMessages.appendChild(msg);
            historyMessages.scrollTop = historyMessages.scrollHeight;

            // Expand history if it was collapsed and we have a response
            if (type === 'assistant') {
                const history = document.querySelector('.command-history');
                history?.classList.remove('collapsed');
            }

            // Store in shared chatState
            chatState.conversationHistory.push({ role: type, content });
            saveConversationMemory();
        }

        // BUILD 393: Process input from Command Frame (routes to existing TreeBeard logic)
        async function processCommandInput(message) {
            // Show processing state
            const sendBtn = document.getElementById('command-send-btn');
            if (sendBtn) {
                sendBtn.disabled = true;
                sendBtn.textContent = 'â³';
            }

            try {
                // Route to existing handleSendMessage which has all the TreeBeard intelligence
                // We temporarily set the classic input value so handleSendMessage can process it
                const classicInput = document.getElementById('chat-assistant-input');
                const originalValue = classicInput?.value;

                if (classicInput) {
                    classicInput.value = message;
                }

                // Call the main send handler (it handles all AI routing, commands, etc.)
                await handleSendMessage();

                // Restore classic input
                if (classicInput) {
                    classicInput.value = originalValue || '';
                }

                // Get the last assistant response from chatState and show in Command Frame
                const lastResponse = chatState.conversationHistory
                    .filter(m => m.role === 'assistant')
                    .pop();

                if (lastResponse) {
                    addCommandMessage(lastResponse.content, 'assistant');
                }

            } catch (error) {
                console.error('Command processing error:', error);
                addCommandMessage('Sorry, something went wrong. Please try again.', 'assistant');
            } finally {
                if (sendBtn) {
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'â¤';
                }
            }
        }

        // BUILD 393: Wire up Command Frame action buttons
        function initCommandFrameButtons() {
            document.querySelectorAll('#command-frame .cmd-btn[data-action]').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const action = btn.dataset.action;

                    // Handle prompt actions (prefill input)
                    if (action.startsWith('prompt_')) {
                        const input = document.getElementById('command-input');
                        const prompts = {
                            'prompt_find': 'find ',
                            'prompt_add': 'add '
                        };
                        if (input) {
                            input.value = prompts[action] || '';
                            input.focus();
                            input.setSelectionRange(input.value.length, input.value.length);
                        }
                    } else {
                        // Execute action via existing COMMAND_REGISTRY
                        await executeAction(action);
                    }
                });
            });

            // Mode pill clicks
            document.querySelectorAll('#command-frame .mode-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    document.querySelectorAll('#command-frame .mode-pill').forEach(p => p.classList.remove('active'));
                    pill.classList.add('active');

                    const mode = pill.dataset.mode;
                    if (mode === 'deep') {
                        chatState.conversationMode = true;
                        showToast('Deep Conversation mode - full AI intelligence', 'info');
                    } else {
                        chatState.conversationMode = false;
                        showToast('Quick mode - fast commands', 'info');
                    }
                });
            });

            // Enter key to send
            document.getElementById('command-input')?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleCommandSend();
                }
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 394: Context-Aware Action Button Generator
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const actionButtonGenerator = {
            // Universal buttons - always available
            universal: [
                { icon: 'ğŸ”', label: 'Find', action: 'prompt_find' },
                { icon: 'â•', label: 'Add', action: 'prompt_add' },
                { icon: 'âœ¨', label: 'Enhance', action: 'ai_enhance' },
                { icon: 'ğŸ“–', label: 'Help', action: 'show_help' }
            ],

            // Node-focused buttons - show when a node is selected
            nodeFocused: [
                { icon: 'âœï¸', label: 'Edit', action: 'edit_node' },
                { icon: 'ğŸ§ ', label: 'Deep Dive', action: 'deep_dive' },
                { icon: 'ğŸ“Š', label: 'Expand', action: 'expand_node' },
                { icon: 'ğŸ’¡', label: 'Insight', action: 'quick_insight' }
            ],

            // Multi-select buttons - show when 2+ nodes selected
            multiSelect: [
                { icon: 'ğŸ”—', label: 'Hyperedge', action: 'create_hyperedge' },
                { icon: 'ğŸ”¬', label: 'Compare', action: 'compare_nodes' },
                { icon: 'ğŸ¯', label: 'Group', action: 'smart_hyperedge' }
            ],

            // Pattern-specific buttons
            patternSpecific: {
                lifetree: [
                    { icon: 'ğŸ“…', label: 'Add Event', action: 'prompt_add_event' },
                    { icon: 'ğŸ‚', label: 'Birthday', action: 'birthday_method' },
                    { icon: 'ğŸ©º', label: 'Health Check', action: 'lifetree_health_check' }
                ],
                philosophy: [
                    { icon: 'âš”ï¸', label: 'Refute', action: 'refute_thesis' },
                    { icon: 'ğŸ’¬', label: 'Dialogue', action: 'generate_dialogue' },
                    { icon: 'ğŸ”', label: 'Analyze', action: 'analyze_argument' }
                ],
                sales: [
                    { icon: 'ğŸ“', label: 'Follow-up', action: 'generate_followup' },
                    { icon: 'ğŸ’°', label: 'Qualify', action: 'qualify_lead' },
                    { icon: 'ğŸ“ˆ', label: 'Pipeline', action: 'show_pipeline' }
                ],
                capex: [
                    { icon: 'ğŸ’µ', label: 'ROI', action: 'calculate_roi' },
                    { icon: 'ğŸ“Š', label: 'Budget', action: 'show_budget' },
                    { icon: 'âš ï¸', label: 'Risks', action: 'analyze_risks' }
                ]
            },

            /**
             * Get appropriate buttons based on current context
             * @returns {Object} { primary: [], secondary: [] }
             */
            getButtonsForContext() {
                const context = this.detectContext();
                const primary = [...this.universal];
                const secondary = [];

                // Add node-focused buttons if a node is selected
                if (context.hasActiveNode) {
                    secondary.push(...this.nodeFocused);
                }

                // Add multi-select buttons if 2+ nodes selected
                if (context.multiSelectCount >= 2) {
                    secondary.push(...this.multiSelect);
                }

                // Add pattern-specific buttons
                const patternButtons = this.patternSpecific[context.pattern] || [];
                if (patternButtons.length > 0) {
                    secondary.push(...patternButtons);
                }

                return { primary, secondary, context };
            },

            /**
             * Detect current UI context
             */
            detectContext() {
                return {
                    hasActiveNode: typeof activeNode !== 'undefined' && activeNode !== null,
                    activeNodeName: activeNode?.name || null,
                    activeNodeType: activeNode?.type || null,
                    multiSelectCount: typeof selectedNodes !== 'undefined' ? selectedNodes.length : 0,
                    pattern: typeof currentPattern !== 'undefined' ? currentPattern : 'generic',
                    isCanvasView: document.getElementById('canvas-container')?.classList.contains('active') || false
                };
            }
        };

        /**
         * Refresh action buttons based on current context
         */
        function refreshActionButtons() {
            const secondaryRow = document.querySelector('#command-frame .secondary-actions');
            if (!secondaryRow) return;

            const { primary, secondary, context } = actionButtonGenerator.getButtonsForContext();

            // Clear and populate secondary row
            secondaryRow.innerHTML = '';

            if (secondary.length > 0) {
                secondary.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = 'cmd-btn';
                    button.dataset.action = btn.action;
                    button.innerHTML = `<span class="btn-icon">${btn.icon}</span><span class="btn-label">${btn.label}</span>`;
                    button.addEventListener('click', async () => {
                        if (btn.action.startsWith('prompt_')) {
                            const input = document.getElementById('command-input');
                            const prompts = {
                                'prompt_find': 'find ',
                                'prompt_add': 'add ',
                                'prompt_add_event': 'add event: '
                            };
                            if (input) {
                                input.value = prompts[btn.action] || '';
                                input.focus();
                            }
                        } else {
                            await executeAction(btn.action);
                            refreshActionButtons(); // Refresh after action
                        }
                    });
                    secondaryRow.appendChild(button);
                });
                secondaryRow.classList.remove('collapsed');
            } else {
                secondaryRow.classList.add('collapsed');
            }

            // Update context bar
            updateContextBar(context);
        }

        /**
         * Update the context bar with current node info
         */
        function updateContextBar(context) {
            const contextBar = document.querySelector('#command-frame .command-context-bar');
            if (!contextBar) return;

            const contextIcon = contextBar.querySelector('.context-icon');
            const contextText = contextBar.querySelector('.context-text');
            const infoBtn = contextBar.querySelector('.context-action');

            if (context.hasActiveNode) {
                contextBar.classList.remove('no-focus');

                // Build breadcrumb path
                let path = '';
                if (activeNode) {
                    const parent = findParentOfNode(activeNode, capexTree);
                    if (parent && parent.name) {
                        path = `${parent.name} > `;
                    }
                    path += activeNode.name || 'Unnamed';
                }

                // Set icon based on node type
                const typeIcons = {
                    'phase': 'ğŸ“',
                    'item': 'ğŸ“„',
                    'subtask': 'ğŸ“Œ',
                    'root': 'ğŸŒ³'
                };
                contextIcon.textContent = typeIcons[context.activeNodeType] || 'ğŸ“';
                contextText.textContent = path || context.activeNodeName || 'Selected node';
                contextText.title = `Type: ${context.activeNodeType || 'unknown'}`;

                if (infoBtn) {
                    infoBtn.style.display = 'inline-flex';
                }
            } else if (context.multiSelectCount >= 2) {
                contextBar.classList.remove('no-focus');
                contextIcon.textContent = 'ğŸ”¢';
                contextText.textContent = `${context.multiSelectCount} nodes selected`;
                if (infoBtn) infoBtn.style.display = 'none';
            } else {
                contextBar.classList.add('no-focus');
                contextIcon.textContent = 'ğŸ“';
                contextText.textContent = 'No node focused â€” use Find or click a node';
                if (infoBtn) infoBtn.style.display = 'none';
            }
        }

        /**
         * Helper: Find parent node of a given node
         */
        function findParentOfNode(targetNode, tree, parent = null) {
            if (!tree) return null;
            if (tree === targetNode) return parent;

            // Check children
            if (tree.children) {
                for (const child of tree.children) {
                    if (child === targetNode) return tree;
                    const found = findParentOfNode(targetNode, child, tree);
                    if (found) return found;
                }
            }

            // Check items
            if (tree.items) {
                for (const item of tree.items) {
                    if (item === targetNode) return tree;
                    const found = findParentOfNode(targetNode, item, tree);
                    if (found) return found;
                }
            }

            // Check subtasks
            if (tree.subtasks) {
                for (const subtask of tree.subtasks) {
                    if (subtask === targetNode) return tree;
                    const found = findParentOfNode(targetNode, subtask, tree);
                    if (found) return found;
                }
            }

            return null;
        }

        // Hook into node selection events to refresh buttons
        function hookNodeSelection() {
            // Override or wrap existing click handlers
            // This will be called when nodes are clicked in tree/canvas view
            const origRender = window.render;
            if (typeof origRender === 'function') {
                window.render = function(...args) {
                    origRender.apply(this, args);
                    // After render, attach click listeners that trigger refresh
                    setTimeout(() => attachNodeClickListeners(), 50);
                };
            }
        }

        function attachNodeClickListeners() {
            // Tree view nodes
            document.querySelectorAll('.tree-node').forEach(node => {
                if (!node._commandFrameHooked) {
                    node._commandFrameHooked = true;
                    node.addEventListener('click', () => {
                        setTimeout(refreshActionButtons, 10);
                    });
                }
            });

            // Canvas view nodes
            document.querySelectorAll('.canvas-node').forEach(node => {
                if (!node._commandFrameHooked) {
                    node._commandFrameHooked = true;
                    node.addEventListener('click', () => {
                        setTimeout(refreshActionButtons, 10);
                    });
                }
            });
        }

        // Initialize button refresh system
        function initActionButtonRefresh() {
            // Refresh when frame opens
            const origToggleCommandFrame = window.toggleCommandFrame;
            if (typeof origToggleCommandFrame === 'function') {
                window.toggleCommandFrame = function() {
                    origToggleCommandFrame();
                    if (chatState.isOpen) {
                        refreshActionButtons();
                    }
                };
            }

            // Initial hook
            hookNodeSelection();
            attachNodeClickListeners();

            // Periodic check for stale context (every 2 seconds when open)
            setInterval(() => {
                if (chatState.isOpen && window.useNewChatUI) {
                    refreshActionButtons();
                }
            }, 2000);
        }

        // Call during DOMContentLoaded
        document.addEventListener('DOMContentLoaded', initActionButtonRefresh);

        // Expose globally for other modules
        window.refreshActionButtons = refreshActionButtons;
        window.updateContextBar = updateContextBar;
        window.actionButtonGenerator = actionButtonGenerator;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 395: Visual Feedback System
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const visualFeedback = {
            // Feedback types with colors and icons
            types: {
                found: { color: 'rgba(34, 197, 94, 0.4)', border: '#22c55e', icon: 'ğŸ”', label: 'Found' },
                added: { color: 'rgba(59, 130, 246, 0.4)', border: '#3b82f6', icon: 'â•', label: 'New' },
                edited: { color: 'rgba(249, 115, 22, 0.4)', border: '#f97316', icon: 'âœï¸', label: 'Edited' },
                enhanced: { color: 'rgba(168, 85, 247, 0.4)', border: '#a855f7', icon: 'âœ¨', label: 'Enhanced' },
                deleted: { color: 'rgba(239, 68, 68, 0.4)', border: '#ef4444', icon: 'ğŸ—‘ï¸', label: 'Deleted' },
                focused: { color: 'rgba(99, 102, 241, 0.4)', border: '#6366f1', icon: 'ğŸ“', label: 'Focused' }
            },

            // Active overlays (for cleanup)
            activeOverlays: [],

            /**
             * Highlight a node with visual feedback
             * @param {string} nodeId - ID of the node to highlight
             * @param {string} type - Feedback type (found, added, edited, enhanced, deleted, focused)
             * @param {number} duration - How long to show (ms), 0 = permanent until clear
             */
            highlight(nodeId, type = 'found', duration = 3000) {
                const feedback = this.types[type] || this.types.found;
                const isCanvasView = document.getElementById('canvas-container')?.classList.contains('active');

                if (isCanvasView) {
                    this.highlightCanvasNode(nodeId, feedback, duration);
                } else {
                    this.highlightTreeNode(nodeId, feedback, duration);
                }
            },

            /**
             * Highlight node in tree view
             */
            highlightTreeNode(nodeId, feedback, duration) {
                // Try multiple selectors
                const selectors = [
                    `[data-item-id="${nodeId}"]`,
                    `[data-node-id="${nodeId}"]`,
                    `[data-id="${nodeId}"]`
                ];

                let nodeEl = null;
                for (const selector of selectors) {
                    nodeEl = document.querySelector(selector);
                    if (nodeEl) break;
                }

                if (!nodeEl) return;

                // Scroll into view
                nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'vf-overlay vf-pulse';
                overlay.style.cssText = `
                    position: absolute;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: ${feedback.color};
                    border: 2px solid ${feedback.border};
                    border-radius: 8px;
                    pointer-events: none;
                    z-index: 100;
                `;

                // Create label badge
                const badge = document.createElement('div');
                badge.className = 'vf-badge';
                badge.style.cssText = `
                    position: absolute;
                    top: -8px; right: -8px;
                    background: ${feedback.border};
                    color: white;
                    padding: 2px 8px;
                    border-radius: 12px;
                    font-size: 11px;
                    font-weight: 600;
                    white-space: nowrap;
                    z-index: 101;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                `;
                badge.innerHTML = `${feedback.icon} ${feedback.label}`;

                // Ensure parent is positioned
                const originalPosition = nodeEl.style.position;
                if (!originalPosition || originalPosition === 'static') {
                    nodeEl.style.position = 'relative';
                }

                nodeEl.appendChild(overlay);
                nodeEl.appendChild(badge);
                this.activeOverlays.push({ overlay, badge, nodeEl, originalPosition });

                // Auto-remove after duration
                if (duration > 0) {
                    setTimeout(() => {
                        this.removeOverlay(overlay, badge, nodeEl, originalPosition);
                    }, duration);
                }
            },

            /**
             * Highlight node in canvas view
             */
            highlightCanvasNode(nodeId, feedback, duration) {
                const nodeEl = document.querySelector(`.canvas-node[data-node-id="${nodeId}"]`);
                if (!nodeEl) return;

                // Pan to node if needed
                const rect = nodeEl.getBoundingClientRect();
                const container = document.getElementById('canvas-container');
                if (container) {
                    const containerRect = container.getBoundingClientRect();
                    if (rect.left < containerRect.left || rect.right > containerRect.right ||
                        rect.top < containerRect.top || rect.bottom > containerRect.bottom) {
                        nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                    }
                }

                // Apply glow effect
                const originalBoxShadow = nodeEl.style.boxShadow;
                const originalBorder = nodeEl.style.border;

                nodeEl.style.boxShadow = `0 0 20px ${feedback.border}, 0 0 40px ${feedback.color}`;
                nodeEl.style.border = `3px solid ${feedback.border}`;
                nodeEl.classList.add('vf-pulse');

                // Create floating badge
                const badge = document.createElement('div');
                badge.className = 'vf-canvas-badge';
                badge.style.cssText = `
                    position: absolute;
                    top: -24px; left: 50%;
                    transform: translateX(-50%);
                    background: ${feedback.border};
                    color: white;
                    padding: 2px 10px;
                    border-radius: 12px;
                    font-size: 12px;
                    font-weight: 600;
                    white-space: nowrap;
                    z-index: 1000;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
                    animation: vfBadgeFloat 0.5s ease-out;
                `;
                badge.innerHTML = `${feedback.icon} ${feedback.label}`;
                nodeEl.style.position = 'relative';
                nodeEl.appendChild(badge);

                this.activeOverlays.push({
                    nodeEl,
                    badge,
                    originalBoxShadow,
                    originalBorder,
                    isCanvas: true
                });

                // Auto-remove after duration
                if (duration > 0) {
                    setTimeout(() => {
                        nodeEl.style.boxShadow = originalBoxShadow || '';
                        nodeEl.style.border = originalBorder || '';
                        nodeEl.classList.remove('vf-pulse');
                        badge.remove();
                    }, duration);
                }
            },

            /**
             * Highlight multiple nodes
             */
            highlightMultiple(nodeIds, type = 'found', duration = 3000, stagger = 100) {
                nodeIds.forEach((id, index) => {
                    setTimeout(() => {
                        this.highlight(id, type, duration);
                    }, index * stagger);
                });
            },

            /**
             * Show a connection line between nodes (for hyperedge visualization)
             */
            showConnection(fromId, toId, color = 'rgba(139, 92, 246, 0.6)', duration = 3000) {
                const container = document.getElementById('canvas-container');
                if (!container?.classList.contains('active')) return;

                const fromEl = document.querySelector(`.canvas-node[data-node-id="${fromId}"]`);
                const toEl = document.querySelector(`.canvas-node[data-node-id="${toId}"]`);
                if (!fromEl || !toEl) return;

                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();

                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.style.cssText = `
                    position: fixed;
                    top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none;
                    z-index: 999;
                `;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromRect.left + fromRect.width / 2);
                line.setAttribute('y1', fromRect.top + fromRect.height / 2);
                line.setAttribute('x2', toRect.left + toRect.width / 2);
                line.setAttribute('y2', toRect.top + toRect.height / 2);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', '3');
                line.setAttribute('stroke-dasharray', '8,4');
                line.style.animation = 'vfLineDash 0.5s linear infinite';

                svg.appendChild(line);
                document.body.appendChild(svg);

                if (duration > 0) {
                    setTimeout(() => svg.remove(), duration);
                }

                return svg;
            },

            /**
             * Clear all visual feedback
             */
            clearAll() {
                this.activeOverlays.forEach(item => {
                    if (item.isCanvas) {
                        item.nodeEl.style.boxShadow = item.originalBoxShadow || '';
                        item.nodeEl.style.border = item.originalBorder || '';
                        item.nodeEl.classList.remove('vf-pulse');
                        item.badge?.remove();
                    } else {
                        this.removeOverlay(item.overlay, item.badge, item.nodeEl, item.originalPosition);
                    }
                });
                this.activeOverlays = [];

                // Remove any connection lines
                document.querySelectorAll('svg[style*="pointer-events: none"]').forEach(svg => svg.remove());
            },

            /**
             * Remove a specific overlay
             */
            removeOverlay(overlay, badge, nodeEl, originalPosition) {
                overlay?.remove();
                badge?.remove();
                if (nodeEl && originalPosition !== undefined) {
                    nodeEl.style.position = originalPosition || '';
                }
            },

            /**
             * Flash feedback (quick pulse without label)
             */
            flash(nodeId, type = 'focused', count = 2) {
                const feedback = this.types[type] || this.types.focused;
                const isCanvasView = document.getElementById('canvas-container')?.classList.contains('active');

                const selectors = isCanvasView
                    ? [`.canvas-node[data-node-id="${nodeId}"]`]
                    : [`[data-item-id="${nodeId}"]`, `[data-node-id="${nodeId}"]`];

                let nodeEl = null;
                for (const selector of selectors) {
                    nodeEl = document.querySelector(selector);
                    if (nodeEl) break;
                }

                if (!nodeEl) return;

                let flashCount = 0;
                const interval = setInterval(() => {
                    nodeEl.style.boxShadow = flashCount % 2 === 0
                        ? `0 0 15px ${feedback.border}, inset 0 0 10px ${feedback.color}`
                        : '';
                    flashCount++;
                    if (flashCount >= count * 2) {
                        clearInterval(interval);
                        nodeEl.style.boxShadow = '';
                    }
                }, 200);
            }
        };

        // Expose globally
        window.visualFeedback = visualFeedback;

        // BUILD 578: Expose COMMAND_REGISTRY and executeAction for testing
        window.COMMAND_REGISTRY = COMMAND_REGISTRY;
        window.executeTreebeardAction = executeAction;

        function addMessage(content, type = 'assistant', buttons = null) {
            const messagesContainer = document.getElementById('chat-assistant-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${type}`;

            // Handle markdown-like formatting
            let formattedContent = content
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\[([^\]]+)\]\(#([^)]+)\)/g, '<a href="#" class="chat-action-link" data-action="$2">$1</a>')
                .replace(/\n/g, '<br>');

            messageDiv.innerHTML = formattedContent;

            // BUILD 564: Handle action links (like analyze-screenshot)
            messageDiv.querySelectorAll('.chat-action-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const action = link.dataset.action;
                    if (action === 'analyze-screenshot' && window._lastScreenCapture) {
                        analyzeScreenshotWithVision(window._lastScreenCapture);
                    }
                });
            });

            // Add action buttons if provided
            if (buttons && buttons.length > 0) {
                const btnContainer = document.createElement('div');
                btnContainer.className = 'action-buttons';
                buttons.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = 'action-btn';
                    button.textContent = btn.label;
                    button.onclick = () => executeAction(btn.action, btn.param);
                    btnContainer.appendChild(button);
                });
                messageDiv.appendChild(btnContainer);
            }

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Store in history
            chatState.conversationHistory.push({ role: type, content });

            // BUILD 355: Persist conversation memory
            saveConversationMemory();
        }

        function showTypingIndicator() {
            const messagesContainer = document.getElementById('chat-assistant-messages');
            const typing = document.createElement('div');
            typing.className = 'chat-typing';
            typing.id = 'typing-indicator';
            typing.innerHTML = '<span></span><span></span><span></span>';
            messagesContainer.appendChild(typing);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideTypingIndicator() {
            document.getElementById('typing-indicator')?.remove();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 543: AI STREAMING UI - Progressive response display
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Create a streaming message placeholder that shows "Interpreting..." initially
        function createStreamingMessage() {
            const messagesContainer = document.getElementById('chat-assistant-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message assistant streaming';
            messageDiv.id = 'streaming-message';
            messageDiv.innerHTML = '<span class="streaming-indicator">ğŸŒ³ Interpreting...</span>';
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            return messageDiv;
        }

        // Update streaming message with new content (progressive tokens)
        function updateStreamingMessage(fullText) {
            const messageDiv = document.getElementById('streaming-message');
            if (!messageDiv) return;

            // Format the text with markdown-like styling
            let formattedContent = fullText
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            // Show content + cursor indicator
            messageDiv.innerHTML = formattedContent + '<span class="streaming-cursor">â–Œ</span>';
            messageDiv.parentElement.scrollTop = messageDiv.parentElement.scrollHeight;
        }

        // Finalize streaming message - remove cursor, add to history
        function finalizeStreamingMessage(finalContent, buttons = null) {
            const messageDiv = document.getElementById('streaming-message');
            if (!messageDiv) return;

            messageDiv.classList.remove('streaming');
            messageDiv.removeAttribute('id');

            // Format final content
            let formattedContent = finalContent
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            messageDiv.innerHTML = formattedContent;

            // Add action buttons if provided
            if (buttons && buttons.length > 0) {
                const btnContainer = document.createElement('div');
                btnContainer.className = 'action-buttons';
                buttons.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = 'action-btn';
                    button.textContent = btn.label;
                    button.onclick = () => executeAction(btn.action, btn.param);
                    btnContainer.appendChild(button);
                });
                messageDiv.appendChild(btnContainer);
            }

            // Store in history
            chatState.conversationHistory.push({ role: 'assistant', content: finalContent });
            saveConversationMemory();
        }

        // Cancel streaming request
        function cancelStreaming() {
            if (chatState.streamingAbortController) {
                chatState.streamingAbortController.abort();
                chatState.streamingAbortController = null;

                // Clean up streaming message
                const streamingMsg = document.getElementById('streaming-message');
                if (streamingMsg) {
                    streamingMsg.classList.remove('streaming');
                    streamingMsg.removeAttribute('id');
                    streamingMsg.innerHTML += '<br><em style="color: var(--text-muted);">[cancelled]</em>';
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 543: PREVIEW-THEN-APPLY for destructive commands
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Commands that require user confirmation before execution
        const DESTRUCTIVE_COMMANDS = {
            'delete_node': {
                description: (param) => `Delete node "${param || 'selected'}"`,
                icon: 'ğŸ—‘ï¸',
                severity: 'high'
            },
            'create_tree': {
                description: (param) => `Replace current tree with new tree "${param || 'Untitled'}"`,
                icon: 'ğŸŒ³',
                severity: 'high'
            },
            'bulk_update': {
                description: (param) => `Update multiple nodes`,
                icon: 'ğŸ“',
                severity: 'medium'
            },
            'bulk_delete': {
                description: (param) => `Delete multiple nodes`,
                icon: 'ğŸ—‘ï¸',
                severity: 'high'
            },
            'clear_tree': {
                description: (param) => `Clear all nodes from the tree`,
                icon: 'âš ï¸',
                severity: 'high'
            }
        };

        // Check if an action requires preview confirmation
        function isDestructiveAction(actionName) {
            return DESTRUCTIVE_COMMANDS.hasOwnProperty(actionName);
        }

        // Get human-readable description of what the action will do
        function getActionDescription(actionName, param) {
            const cmd = DESTRUCTIVE_COMMANDS[actionName];
            if (cmd) {
                return `${cmd.icon} ${cmd.description(param)}`;
            }
            return `Execute: ${actionName}${param ? ` with "${param}"` : ''}`;
        }

        // Show preview for destructive action with confirm/cancel buttons
        function showDestructiveActionPreview(actions) {
            const descriptions = actions.map(act =>
                getActionDescription(act.action, act.actionParam)
            ).join('\n');

            const hasSevereAction = actions.some(act =>
                DESTRUCTIVE_COMMANDS[act.action]?.severity === 'high'
            );

            const warningPrefix = hasSevereAction
                ? 'âš ï¸ **This action cannot be undone easily.**\n\n'
                : '';

            const previewMessage = `${warningPrefix}**I'm about to:**\n${descriptions}\n\nConfirm to proceed or cancel to abort.`;

            // Store pending actions for execution on confirm
            chatState.pendingDestructiveActions = actions;

            addMessage(previewMessage, 'assistant', [
                { label: 'âœ“ Confirm', action: 'confirm_destructive_action' },
                { label: 'âœ— Cancel', action: 'cancel_destructive_action' }
            ]);
        }

        // Execute pending destructive actions (called when user confirms)
        async function executePendingDestructiveActions() {
            const actions = chatState.pendingDestructiveActions;
            if (!actions || actions.length === 0) {
                addMessage('No pending actions to execute.', 'assistant');
                return;
            }

            chatState.pendingDestructiveActions = null;

            for (const act of actions) {
                await executeAction(act.action, act.actionParam);
            }

            addMessage('âœ… Actions completed.', 'system');
        }

        // Cancel pending destructive actions
        function cancelPendingDestructiveActions() {
            chatState.pendingDestructiveActions = null;
            addMessage('âŒ Actions cancelled.', 'system');
        }

        // BUILD 545: Validate that action name looks like a valid command
        // Rejects natural language sentences that AI sometimes hallucinates
        function isValidActionName(actionName) {
            if (!actionName || typeof actionName !== 'string') return false;

            // Commands should be short (under 50 chars) and use underscores/colons
            if (actionName.length > 50) return false;

            // Commands shouldn't have multiple spaces (indicates natural language)
            if ((actionName.match(/ /g) || []).length > 2) return false;

            // Commands should match command_name or command_name:param pattern
            // Also allow single words
            if (!/^[\w_]+(?::.*)?$/.test(actionName)) return false;

            return true;
        }

        async function executeAction(actionName, param = null) {
            // BUILD 545: Skip invalid action names (AI hallucinations)
            if (!isValidActionName(actionName)) {
                console.warn(`[TreeBeard] Skipping invalid action name: "${actionName}"`);
                return; // Silently skip - the message was already shown
            }

            // BUILD 255: Handle compound actions like "enter_playground:claude-sonnet"
            let commandName = actionName;
            let commandParam = param;

            if (actionName.includes(':') && !param) {
                const parts = actionName.split(':');
                commandName = parts[0];
                commandParam = parts.slice(1).join(':'); // Rejoin in case value has colons
            }

            // BUILD 577: Normalize command name to lowercase for case-insensitive matching
            commandName = commandName.toLowerCase().trim();

            // BUILD 594: Intent routing - map natural language to commands
            const INTENT_ROUTES = {
                // Show/Display intents
                'show_project': 'project_info', 'show_overview': 'project_info', 'project_summary': 'project_info',
                'project_overview': 'project_info', 'overview': 'project_info', 'show_info': 'project_info',
                'show_tree': 'show_tree_structure', 'tree_structure': 'show_tree_structure', 'display_tree': 'show_tree_structure',
                'show_structure': 'show_tree_structure', 'view_structure': 'show_tree_structure',
                // Analysis intents
                'analyze_tree': 'analyze_balance', 'check_balance': 'analyze_balance', 'tree_balance': 'analyze_balance',
                'find_empty': 'list_empty_nodes', 'show_empty': 'list_empty_nodes', 'empty_nodes': 'list_empty_nodes',
                'find_duplicate': 'find_duplicates', 'show_duplicates': 'find_duplicates', 'check_duplicates': 'find_duplicates',
                'get_stats': 'node_stats', 'show_stats': 'node_stats',
                // Navigation intents
                'go_to': 'find_node', 'goto': 'find_node', 'navigate_to': 'find_node', 'jump_to': 'find_node',
                'focus_on': 'focus_node', 'select': 'find_node',
                // Manipulation intents
                'remove_node': 'delete_node', 'remove': 'delete_node',
                'copy_node': 'duplicate_node', 'clone_node': 'duplicate_node', 'clone': 'duplicate_node',
                'rename': 'rename_node', 'change_name': 'rename_node',
                // View intents
                'show_canvas': 'switch_to_canvas', 'canvas_view': 'switch_to_canvas', 'go_canvas': 'switch_to_canvas',
                'show_3d': 'switch_to_3d', '3d_view': 'switch_to_3d', 'go_3d': 'switch_to_3d',
                'show_gantt': 'view_gantt', 'gantt': 'view_gantt', 'go_gantt': 'view_gantt',
                // BUILD 600: Canvas control intents
                'browse_hyperedge': 'focus_hyperedge', 'explore_hyperedge': 'focus_hyperedge', 'hyperedge': 'focus_hyperedge',
                'exit_hyperedge': 'exit_focus', 'unfocus': 'exit_focus', 'show_all': 'exit_focus',
                'hyperedges': 'list_hyperedges', 'show_hyperedges': 'list_hyperedges',
                'phases': 'filter_phases', 'show_phases': 'filter_phases', 'filter': 'filter_phases',
                'solo': 'solo_phase', 'isolate': 'solo_phase', 'only': 'solo_phase',
                'show_phase': 'show_phase', 'reveal_phase': 'show_phase',
                'hide_phase': 'hide_phase', 'hide': 'hide_phase',
                'show_all_phases': 'show_all_phases', 'reveal_all': 'show_all_phases',
                'center_on': 'focus_camera', 'go_to': 'focus_camera', 'pan_to': 'focus_camera',
                'fit': 'zoom_fit', 'fit_all': 'zoom_fit', 'zoom_all': 'zoom_fit',
                'reset_view': 'reset_camera', 'reset_zoom': 'reset_camera', 'home': 'reset_camera',
                // Discovery intents
                'what_can_you_do': 'list_all_commands', 'help': 'list_all_commands', 'commands': 'list_all_commands',
                'whats_new': 'whats_new', 'new_features': 'whats_new', 'updates': 'whats_new',
                // BUILD 615: Capability intents
                'capabilities': 'list_capabilities', 'show_capabilities': 'list_capabilities', 'chrome_capabilities': 'list_capabilities',
                'add_capability': 'create_capability', 'new_capability': 'create_capability',
                'test_cap': 'test_capability', 'check_capability': 'test_capability',
                // BUILD 616: View/browse capabilities registry
                'browse_capabilities': 'view_capabilities', 'capability_registry': 'view_capabilities',
                'open_capabilities': 'view_capabilities', 'manage_capabilities': 'view_capabilities',
                'back': 'back_from_capabilities', 'return': 'back_from_capabilities', 'exit_capabilities': 'back_from_capabilities',
            };

            // Try exact match first, then intent routing
            let command = COMMAND_REGISTRY[commandName];
            let routedFrom = null;

            if (!command && INTENT_ROUTES[commandName]) {
                routedFrom = commandName;
                commandName = INTENT_ROUTES[commandName];
                command = COMMAND_REGISTRY[commandName];
                console.log(`ğŸ”€ Intent routed: "${routedFrom}" â†’ "${commandName}"`);
                // Show routing notification
                if (typeof showToast === 'function') {
                    showToast(`ğŸ”€ "${routedFrom}" â†’ ${commandName}`, 'info', 2000);
                }
            }

            if (command) {
                try {
                    const result = await command(commandParam);
                    if (result) {
                        // BUILD 309: Support commands returning {message, buttons}
                        if (typeof result === 'object' && result.message) {
                            addMessage(result.message, 'assistant', result.buttons || null);
                        } else {
                            addMessage(result, 'assistant');
                        }
                    }
                } catch (error) {
                    addMessage(`âŒ Error: ${error.message}`, 'error');
                }
            } else {
                // BUILD 437: Graceful handling of unknown actions
                const availableCommands = Object.keys(COMMAND_REGISTRY);

                // Find similar commands (fuzzy match)
                const similar = availableCommands.filter(cmd =>
                    cmd.includes(commandName.split('_')[0]) ||
                    commandName.includes(cmd.split('_')[0])
                ).slice(0, 3);

                let suggestion = `ğŸ¤” "${commandName}" isn't available yet.`;

                // Suggest alternatives based on what they tried
                if (commandName.includes('filter')) {
                    suggestion += `\n\n**Try instead:**\nâ€¢ Press **Ctrl+F** in Canvas View to search nodes\nâ€¢ Use \`search\` to open the search modal\nâ€¢ Use \`find_node:{query}\` to locate specific items`;
                } else if (similar.length > 0) {
                    suggestion += `\n\n**Similar commands:** ${similar.map(s => `\`${s}\``).join(', ')}`;
                } else {
                    suggestion += `\n\n**Tip:** Ask "what can you do?" to see available actions.`;
                }

                addMessage(suggestion, 'assistant');
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 604: FAST-PATH INTERCEPTOR
        // Deterministic command interceptor that bypasses AI interpretation
        // for known patterns. Returns { intercepted, command, param, message, reason }
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function interceptFastPath(message) {
            const MAX_LENGTH = 150;
            const lowerMsg = message.toLowerCase().trim();

            // GATE 1: Message too long for Fast-Path
            if (message.length > MAX_LENGTH) {
                return { intercepted: false, reason: 'message_too_long' };
            }

            // GATE 2: Complex questions (what/why/how) - EXCEPT "what can you do"
            if (/^(what|why|how)/i.test(lowerMsg)) {
                // Allow "what can you do" to pass through to help
                if (/^what\s+can\s+you\s+do\??$/i.test(lowerMsg)) {
                    // This will be handled below as show_help
                } else {
                    return { intercepted: false, reason: 'complex_question' };
                }
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // VIEW SWITCHING
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (/^(canvas|switch\s+to\s+canvas(\s+view)?|show\s+canvas)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['switch_to_canvas']();
                viewMode = 'canvas';
                return { intercepted: true, command: 'switch_to_canvas', message: result };
            }

            if (/^(tree|switch\s+to\s+tree(\s+view)?|show\s+tree)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['switch_to_tree']();
                viewMode = 'tree';
                return { intercepted: true, command: 'switch_to_tree', message: result };
            }

            if (/^(3d|switch\s+to\s+3d(\s+view)?|show\s+3d)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['switch_to_3d']();
                return { intercepted: true, command: 'switch_to_3d', message: result };
            }

            if (/^(gantt|switch\s+to\s+gantt(\s+view)?|show\s+gantt)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['view_gantt']();
                return { intercepted: true, command: 'view_gantt', message: result };
            }

            if (/^(calendar|switch\s+to\s+calendar(\s+view)?|show\s+calendar)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['view_calendar']();
                return { intercepted: true, command: 'view_calendar', message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // PHASE CONTROL (Canvas View)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Use original message to preserve case of phase name
            const soloMatch = message.match(/^(?:solo\s+(?:phase)?|show\s+only|isolate)[:\s]+(.+)$/i);
            if (soloMatch) {
                const phaseName = soloMatch[1].trim();
                const result = COMMAND_REGISTRY['solo_phase'](phaseName);
                return { intercepted: true, command: 'solo_phase', param: phaseName, message: result };
            }

            if (/^(show\s+all\s+phases?|reveal\s+all|unhide\s+all|reset\s+filter)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['show_all_phases']();
                return { intercepted: true, command: 'show_all_phases', message: result };
            }

            // Use original message to preserve case of phase name
            const hideMatch = message.match(/^hide\s+(?:phase)?[:\s]+(.+)$/i);
            if (hideMatch) {
                const phaseName = hideMatch[1].trim();
                const result = COMMAND_REGISTRY['hide_phase'](phaseName);
                return { intercepted: true, command: 'hide_phase', param: phaseName, message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // CAMERA CONTROL
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (/^(zoom\s+fit|fit\s+all|zoom\s+all|fit\s+to\s+view)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['zoom_fit']();
                return { intercepted: true, command: 'zoom_fit', message: result };
            }

            // Use original message to preserve case of node name
            const focusMatch = message.match(/^(?:focus\s+on|center\s+on|go\s+to|pan\s+to)[:\s]+(.+)$/i);
            if (focusMatch) {
                const nodeName = focusMatch[1].trim();
                const result = COMMAND_REGISTRY['focus_camera'](nodeName);
                return { intercepted: true, command: 'focus_camera', param: nodeName, message: result };
            }

            if (/^(reset\s+camera|camera\s+reset|reset\s+view)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['reset_camera']();
                return { intercepted: true, command: 'reset_camera', message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // HYPEREDGE COMMANDS
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (/^(list\s+hyperedges?|show\s+hyperedges?|hyperedges?)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['list_hyperedges']();
                return { intercepted: true, command: 'list_hyperedges', message: typeof result === 'object' ? result.message : result };
            }

            // Use original message to preserve case of hyperedge name
            const focusHyperedgeMatch = message.match(/^(?:focus\s+hyperedge|show\s+hyperedge)[:\s]+(.+)$/i);
            if (focusHyperedgeMatch) {
                const heName = focusHyperedgeMatch[1].trim();
                const result = COMMAND_REGISTRY['focus_hyperedge'](heName);
                return { intercepted: true, command: 'focus_hyperedge', param: heName, message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // BUILD 612: EDGE VISIBILITY
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (/^(show\s+edges?|edges?\s+on|display\s+edges?|show\s+connections?)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['show_edges']();
                return { intercepted: true, command: 'show_edges', message: result };
            }

            if (/^(hide\s+edges?|edges?\s+off|remove\s+edges?|hide\s+connections?)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['hide_edges']();
                return { intercepted: true, command: 'hide_edges', message: result };
            }

            if (/^(toggle\s+edges?|edges?)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['toggle_edges']();
                return { intercepted: true, command: 'toggle_edges', message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // NAVIGATION / UNDO / REDO
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (/^undo$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['undo']();
                return { intercepted: true, command: 'undo', message: result };
            }

            if (/^redo$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['redo']();
                return { intercepted: true, command: 'redo', message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // HELP
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (/^(help|what\s+can\s+you\s+do\??|commands|show\s+help)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['show_help'] ? COMMAND_REGISTRY['show_help']() : COMMAND_REGISTRY['help']();
                return { intercepted: true, command: 'show_help', message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // BUILD 612: EXPAND/COLLAPSE
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (/^(expand\s+all|open\s+all|unfold\s+all)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['expand_all']();
                return { intercepted: true, command: 'expand_all', message: result };
            }

            if (/^(collapse\s+all|close\s+all|fold\s+all)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['collapse_all']();
                return { intercepted: true, command: 'collapse_all', message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // BUILD 612: LAYOUT COMMANDS (Canvas)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (/^(grid\s+layout|layout\s+grid|arrange\s+grid)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['layout_grid']();
                return { intercepted: true, command: 'layout_grid', message: result };
            }

            if (/^(radial\s+layout|layout\s+radial|arrange\s+radial|circular\s+layout)$/i.test(lowerMsg)) {
                const result = COMMAND_REGISTRY['layout_radial']();
                return { intercepted: true, command: 'layout_radial', message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // BUILD 612: SEARCH
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const searchMatch = message.match(/^(?:search|find|look\s+for)[:\s]+(.+)$/i);
            if (searchMatch) {
                const query = searchMatch[1].trim();
                const result = COMMAND_REGISTRY['search_tree'](query);
                return { intercepted: true, command: 'search_tree', param: query, message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // DISPATCH TASK TO CLAUDE CODE
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const dispatchMatch = message.match(/^dispatch[:\s]+(.+)$/i);
            if (dispatchMatch) {
                const taskPrompt = dispatchMatch[1].trim();
                const result = COMMAND_REGISTRY['dispatch_task'](taskPrompt);
                return { intercepted: true, command: 'dispatch_task', param: taskPrompt, message: result };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // NOT INTERCEPTED - Falls through to AI interpretation
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            return { intercepted: false, reason: 'no_match' };
        }
        window.interceptFastPath = interceptFastPath; // Expose for testing

        async function handleSendMessage() {
            const input = document.getElementById('chat-assistant-input');
            const message = input.value.trim();

            if (!message || chatState.isProcessing) return;

            // Clear input
            input.value = '';
            input.style.height = 'auto';

            // BUILD 366: Detect and update biographer mode for LifeTree
            if (typeof currentPattern !== 'undefined' && currentPattern === 'lifetree') {
                const detectedMode = detectBiographerMode(message);
                updateBiographerModeIndicator(detectedMode);
            } else {
                updateBiographerModeIndicator(null);
            }

            // Add user message
            addMessage(message, 'user');

            // Show typing indicator
            chatState.isProcessing = true;
            showTypingIndicator();

            try {
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // BUILD 604: FAST-PATH INTERCEPTION
                // Deterministic commands bypass AI interpretation for instant response
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const fastPath = interceptFastPath(message);
                if (fastPath.intercepted) {
                    console.log(`âš¡ Fast-Path: ${fastPath.command}${fastPath.param ? `(${fastPath.param})` : ''}`);
                    hideTypingIndicator();
                    const response = typeof fastPath.message === 'object' ? fastPath.message : { message: fastPath.message, buttons: null };
                    addMessage(response.message || fastPath.message, 'assistant', response.buttons);
                    chatState.isProcessing = false;
                    return;
                }

                // BUILD 543: Pattern Mismatch Routing
                // Check if message uses terminology from a different pattern
                if (!chatState.skipPatternMismatchCheck && typeof currentPattern !== 'undefined') {
                    const mismatch = detectPatternMismatch(message, currentPattern);
                    if (mismatch) {
                        hideTypingIndicator();
                        showPatternMismatchWarning(mismatch, message);
                        chatState.isProcessing = false;
                        return;
                    }
                }
                chatState.skipPatternMismatchCheck = false; // Reset flag

                // BUILD 255: Check for Playground Mode
                if (chatState.playgroundMode) {
                    // Check for exit command
                    if (message.toLowerCase().includes('exit playground') || message.toLowerCase() === 'exit') {
                        hideTypingIndicator();
                        const exitResult = await COMMAND_REGISTRY['exit_playground']();
                        addMessage(exitResult, 'assistant');
                        chatState.isProcessing = false;
                        return;
                    }

                    // Route to playground handler
                    const response = await handlePlaygroundMessage(message);
                    hideTypingIndicator();
                    addMessage(response, 'assistant');
                    chatState.isProcessing = false;
                    return;
                }

                // Check for "improve prompt:" pattern BEFORE AI interpretation
                const improveMatch = message.match(/^(?:improve|enhance|optimize|refine)\s+(?:this\s+)?(?:prompt|my prompt)?[:\s]+(.+)$/is);
                if (improveMatch) {
                    const promptToImprove = improveMatch[1].trim();

                    try {
                        const result = await COMMAND_REGISTRY['improve_prompt'](promptToImprove);
                        hideTypingIndicator();

                        if (result) {
                            // Error message
                            addMessage(result, 'assistant');
                        } else if (chatState.improvedPrompt) {
                            // Success - show improved prompt with action buttons
                            const preview = chatState.improvedPrompt.full.length > 500
                                ? chatState.improvedPrompt.full.substring(0, 500) + '...'
                                : chatState.improvedPrompt.full;

                            const successMsg = `âœ¨ **Prompt Improved!**\n\n**${chatState.improvedPrompt.name}**\n\n\`\`\`\n${preview}\n\`\`\`\n\nWhat would you like to do?`;

                            // Add message with action buttons
                            addMessage(successMsg, 'assistant', [
                                { label: 'ğŸŸ£ Try with Claude', action: 'enter_playground:claude-sonnet' },
                                { label: 'ğŸŸ¢ Try with GPT-4', action: 'enter_playground:gpt-4o' },
                                { label: 'ğŸ”µ Try with Gemini', action: 'enter_playground:gemini-pro' },
                                { label: 'ğŸ“‹ Copy', action: 'copy_prompt' },
                                { label: 'ğŸ’¾ Save', action: 'save_prompt' }
                            ]);
                        }
                    } catch (err) {
                        hideTypingIndicator();
                        addMessage(`âŒ Failed to improve prompt: ${err.message}`, 'error');
                    }
                    chatState.isProcessing = false;
                    return;
                }

                // BUILD 361: Hyperedge query detection
                const hyperedgeQueryResult = detectHyperedgeQuery(message);
                if (hyperedgeQueryResult) {
                    hideTypingIndicator();
                    const { matches, description, queryConditions } = hyperedgeQueryResult;

                    if (matches.length === 0) {
                        addMessage(`ğŸ” No items found matching "${description}". Try a different query or use the Query Builder (ğŸ”— Hyperedges â†’ ğŸ” Query).`, 'assistant');
                    } else if (matches.length === 1) {
                        addMessage(`ğŸ” Found 1 item matching "${description}": **${matches[0].name}**\n\nNeed at least 2 items to create a hyperedge.`, 'assistant');
                    } else {
                        // Format matches for display
                        const matchList = matches.slice(0, 5).map(m => `â€¢ ${m.name}`).join('\n');
                        const moreText = matches.length > 5 ? `\n...and ${matches.length - 5} more` : '';

                        // Calculate aggregates if available
                        const totalCost = matches.reduce((sum, m) => sum + (m.cost || 0), 0);
                        const costStr = totalCost > 0
                            ? `\nğŸ’° Total: ${totalCost >= 1000000 ? '$' + (totalCost/1000000).toFixed(1) + 'M' : '$' + (totalCost/1000).toFixed(0) + 'K'}`
                            : '';

                        addMessage(
                            `ğŸ” Found **${matches.length} items** matching "${description}":${costStr}\n\n${matchList}${moreText}\n\nCreate a hyperedge to visualize them?`,
                            'assistant',
                            [
                                { label: 'âœ“ Create Hyperedge', action: `create_hyperedge_from_query:${JSON.stringify(queryConditions)}` },
                                { label: 'ğŸ¯ Highlight in Canvas', action: 'highlight_query_results' }
                            ]
                        );

                        // Store matches for later use
                        chatState.lastQueryMatches = matches;
                        chatState.lastQueryDescription = description;
                        chatState.lastQueryConditions = queryConditions;
                    }
                    chatState.isProcessing = false;
                    return;
                }

                // BUILD 442/574: Research intent detection (web search)
                const researchIntent = detectResearchIntent(message);
                if (researchIntent) {
                    console.log('ğŸ” Research intent detected:', researchIntent.query, 'useDeepResearch:', researchIntent.useDeepResearch);

                    // BUILD 574: Use deep_research (Claude Code) for explicit research + integration requests
                    if (researchIntent.useDeepResearch && mcpBridgeState?.client?.isConnected) {
                        hideTypingIndicator();
                        console.log('ğŸ”¬ Routing to deep_research via Claude Code');
                        const cmdResult = COMMAND_REGISTRY['deep_research'](researchIntent.query);
                        const response = typeof cmdResult === 'object' ? cmdResult : { message: cmdResult, buttons: null };
                        addMessage(response.message, 'assistant', response.buttons);
                        chatState.isProcessing = false;
                        return;
                    }

                    // Fallback to local Gemini research
                    hideTypingIndicator();
                    addMessage(`ğŸ” Researching: "${researchIntent.query}"...`, 'assistant');
                    showTypingIndicator();

                    try {
                        const result = await handleResearchRequest(researchIntent.query);
                        hideTypingIndicator();
                        addMessage(result.message, 'assistant', result.buttons);
                    } catch (error) {
                        hideTypingIndicator();
                        addMessage(`âŒ Research failed: ${error.message}`, 'assistant');
                    }

                    chatState.isProcessing = false;
                    return;
                }

                // BUILD 522: Direct command matching for hyperedge commands
                // This bypasses AI interpretation for exact command matches
                const lowerMessage = message.toLowerCase().trim();
                if (lowerMessage.includes('hyperedge') && (lowerMessage.includes('find') || lowerMessage.includes('suggest') || lowerMessage.includes('show') || lowerMessage.includes('analyze'))) {
                    console.log('ğŸ”— Direct hyperedge command match');
                    hideTypingIndicator();
                    const cmdResult = COMMAND_REGISTRY['find_hyperedges']();
                    const response = typeof cmdResult === 'object' ? cmdResult : { message: cmdResult, buttons: null };
                    addMessage(response.message, 'assistant', response.buttons);
                    chatState.isProcessing = false;
                    return;
                }

                // BUILD 523: Direct sync command matching
                if (lowerMessage.includes('sync')) {
                    let syncCommand = null;
                    if (lowerMessage.includes('gmail') || lowerMessage.includes('email') || lowerMessage.includes('mail')) {
                        syncCommand = 'sync_gmail';
                    } else if (lowerMessage.includes('drive') || lowerMessage.includes('files')) {
                        syncCommand = 'sync_drive';
                    } else if (lowerMessage.includes('calendar') || lowerMessage.includes('events')) {
                        syncCommand = 'sync_calendar';
                    } else if (lowerMessage.includes('all') || lowerMessage.includes('everything')) {
                        syncCommand = 'sync_all';
                    }

                    if (syncCommand && COMMAND_REGISTRY[syncCommand]) {
                        console.log('ğŸ”„ Direct sync command match:', syncCommand);
                        hideTypingIndicator();
                        const cmdResult = COMMAND_REGISTRY[syncCommand]();
                        const response = typeof cmdResult === 'object' ? cmdResult : { message: cmdResult, buttons: null };
                        addMessage(response.message, 'assistant', response.buttons);
                        chatState.isProcessing = false;
                        return;
                    }
                }

                // BUILD 526: Direct open file command matching
                if (lowerMessage.includes('open') && (lowerMessage.includes('file') || lowerMessage.includes('document'))) {
                    // Extract filename from "open file X" or "open X"
                    let fileName = message.replace(/open\s*(file|document)?\s*/i, '').trim();
                    if (fileName) {
                        console.log('ğŸ“‚ Direct open file command:', fileName);
                        hideTypingIndicator();
                        const cmdResult = COMMAND_REGISTRY['open_file'](fileName);
                        const response = typeof cmdResult === 'object' ? cmdResult : { message: cmdResult, buttons: null };
                        addMessage(response.message, 'assistant', response.buttons);
                        chatState.isProcessing = false;
                        return;
                    }
                }

                // BUILD 538: Direct command:parameter matching for core TreeBeard commands
                // This bypasses AI interpretation for exact command syntax like "add_child:X"
                const directCmdMatch = message.match(/^(add_child|find_node|find|focus_root|create_tree|rename_root|set_field|expand_node|collapse_node|delete_node|rename_node)[:\s]+(.+)$/i);
                if (directCmdMatch) {
                    const cmdName = directCmdMatch[1].toLowerCase().replace(/\s+/g, '_');
                    const cmdParam = directCmdMatch[2].trim();
                    console.log(`ğŸ¯ Direct command match: ${cmdName}(${cmdParam})`);

                    // Map aliases
                    const cmdMap = {
                        'find': 'find_node',
                        'add_child': 'add_child',
                        'find_node': 'find_node',
                        'focus_root': 'focus_root',
                        'create_tree': 'create_tree',
                        'rename_root': 'rename_root',
                        'set_field': 'set_field',
                        'expand_node': 'expand_node',
                        'collapse_node': 'collapse_node',
                        'delete_node': 'delete_node',
                        'rename_node': 'rename_node'
                    };

                    const actualCmd = cmdMap[cmdName] || cmdName;
                    if (COMMAND_REGISTRY[actualCmd]) {
                        hideTypingIndicator();
                        const cmdResult = COMMAND_REGISTRY[actualCmd](cmdParam);
                        const response = typeof cmdResult === 'object' ? cmdResult : { message: cmdResult, buttons: null };
                        addMessage(response.message || cmdResult, 'assistant', response.buttons);
                        chatState.isProcessing = false;
                        return;
                    }
                }

                // BUILD 538: Handle bare commands without parameters
                // BUILD 564: Added extension_status, capture_screen, extract_page, list_tabs
                const bareCmdMatch = lowerMessage.match(/^(focus_root|expand_node|collapse_node|project_info|help|search|add_phase|node_info|undo|redo|extension_status|capture_screen|extract_page|list_tabs|show_extension_help|analyze_image|analyze|analyze_screenshot|image_to_tree|decompose_image)$/);
                if (bareCmdMatch) {
                    const cmdName = bareCmdMatch[1];
                    console.log(`ğŸ¯ Direct bare command: ${cmdName}`);
                    if (COMMAND_REGISTRY[cmdName]) {
                        hideTypingIndicator();
                        // BUILD 564: Handle async commands (extension commands return Promises)
                        let cmdResult = COMMAND_REGISTRY[cmdName]();
                        if (cmdResult instanceof Promise) {
                            cmdResult = await cmdResult;
                        }
                        const response = typeof cmdResult === 'object' ? cmdResult : { message: cmdResult, buttons: null };
                        addMessage(response.message || cmdResult, 'assistant', response.buttons);
                        chatState.isProcessing = false;
                        return;
                    }
                }

                // BUILD 368: Smart mode detection - conversation vs command
                const interactionMode = chatState.conversationMode ? 'conversation' : detectInteractionMode(message);

                let result;
                if (interactionMode === 'conversation') {
                    // BUILD 543: Use streaming for conversation mode
                    // Hide typing indicator - streaming creates its own message UI
                    hideTypingIndicator();
                    result = await handleConversationWithStreaming(message);
                } else {
                    // Use quick command interpretation (non-streaming - needs JSON parse)
                    result = await interpretCommand(message);
                    hideTypingIndicator();
                }

                // BUILD 543: Skip addMessage if result was already streamed to UI
                if (!result.streamed) {
                    // BUILD 490: Inject proactive nudges (Deep Mode only, once per session per issue)
                    let finalMessage = result.message;
                    const nudges = getProactiveNudges();
                    if (nudges.length > 0) {
                        finalMessage += '\n\n---\n' + nudges[0];
                    }

                    // Add assistant response
                    addMessage(finalMessage, 'assistant', result.buttons);
                }

                // BUILD 383: Execute ALL actions for real-time saves (navigate + add in one go)
                // BUILD 543: Preview-Then-Apply for destructive commands
                if (result.actions && result.actions.length > 0) {
                    // Check if any actions are destructive
                    const destructiveActions = result.actions.filter(act => isDestructiveAction(act.action));
                    const safeActions = result.actions.filter(act => !isDestructiveAction(act.action));

                    // Execute safe actions immediately
                    for (const act of safeActions) {
                        await executeAction(act.action, act.actionParam);
                    }

                    // Show preview for destructive actions
                    if (destructiveActions.length > 0) {
                        showDestructiveActionPreview(destructiveActions);
                    }
                } else if (result.action) {
                    // Fallback for single action (backwards compatibility)
                    if (isDestructiveAction(result.action)) {
                        showDestructiveActionPreview([{ action: result.action, actionParam: result.actionParam }]);
                    } else {
                        await executeAction(result.action, result.actionParam);
                    }
                }
            } catch (error) {
                hideTypingIndicator();
                addMessage(`âŒ Sorry, something went wrong: ${error.message}`, 'error');
            } finally {
                chatState.isProcessing = false;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VOICE INPUT (Web Speech API) - Build 258 Fix
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initVoiceInput() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('Voice input not supported');
                document.getElementById('chat-voice-btn')?.style.setProperty('display', 'none');
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            chatState.voiceRecognition = new SpeechRecognition();
            chatState.voiceRecognition.continuous = true;  // BUILD 258: Keep listening
            chatState.voiceRecognition.interimResults = true;  // BUILD 258: Show text as speaking
            chatState.voiceRecognition.lang = 'en-US';
            chatState.voiceInterimText = '';
            chatState.voiceFinalText = '';

            chatState.voiceRecognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                // Process all results
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // Update accumulated final text
                if (finalTranscript) {
                    chatState.voiceFinalText += finalTranscript + ' ';
                }

                // Show interim results in input box
                const inputEl = document.getElementById('chat-assistant-input');
                if (inputEl) {
                    inputEl.value = chatState.voiceFinalText + interimTranscript;
                    // Show visual feedback
                    inputEl.style.borderColor = '#10b981';
                }

                console.log('Voice interim:', interimTranscript, 'Final:', finalTranscript);
            };

            chatState.voiceRecognition.onerror = (event) => {
                console.error('Voice error:', event.error);
                stopVoiceRecording();

                // BUILD 258: Better error messages
                if (event.error === 'not-allowed') {
                    addMessage('ğŸ¤ Microphone access denied. Please allow microphone in browser settings and try again.', 'error');
                } else if (event.error === 'no-speech') {
                    addMessage('ğŸ¤ No speech detected. Please speak louder or check your microphone.', 'system');
                } else if (event.error === 'network') {
                    addMessage('ğŸ¤ Network error. Voice recognition requires internet connection.', 'error');
                } else if (event.error !== 'aborted') {
                    addMessage(`ğŸ¤ Voice error: ${event.error}`, 'error');
                }
            };

            chatState.voiceRecognition.onend = () => {
                // BUILD 258: Auto-send if we have text
                const finalText = chatState.voiceFinalText.trim();
                if (finalText && chatState.isRecording) {
                    document.getElementById('chat-assistant-input').value = finalText;
                    stopVoiceRecording();
                    handleSendMessage();
                } else {
                    stopVoiceRecording();
                }
            };

            chatState.voiceRecognition.onaudiostart = () => {
                console.log('ğŸ¤ Audio capture started');
            };

            chatState.voiceRecognition.onspeechstart = () => {
                console.log('ğŸ¤ Speech detected');
            };
        }

        // BUILD 356: Track microphone permission state
        let micPermissionGranted = false;

        // BUILD 356: Check if permission was already granted (HTTPS only)
        async function checkExistingMicPermission() {
            try {
                if (navigator.permissions) {
                    const result = await navigator.permissions.query({ name: 'microphone' });
                    if (result.state === 'granted') {
                        micPermissionGranted = true;
                        console.log('ğŸ¤ Microphone permission already granted');
                    }
                    // Listen for permission changes
                    result.onchange = () => {
                        micPermissionGranted = result.state === 'granted';
                        console.log('ğŸ¤ Microphone permission changed to:', result.state);
                    };
                }
            } catch (e) {
                // Permissions API not supported or microphone query not allowed
                console.log('ğŸ¤ Cannot query microphone permission:', e.message);
            }
        }

        // Run permission check on load
        checkExistingMicPermission();

        async function requestMicrophonePermission() {
            // Check if we're on file:// protocol
            const isFileProtocol = window.location.protocol === 'file:';

            try {
                // Try to get microphone access
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                // Stop the stream immediately - we just needed to get permission
                stream.getTracks().forEach(track => track.stop());
                micPermissionGranted = true;

                if (isFileProtocol) {
                    console.log('ğŸ¤ Mic permission granted (file:// - will not persist)');
                } else {
                    console.log('ğŸ¤ Mic permission granted and persisted');
                }
                return true;
            } catch (err) {
                console.error('ğŸ¤ Mic permission denied:', err);
                if (err.name === 'NotAllowedError') {
                    addMessage('ğŸ¤ Microphone access denied. Click the lock icon in your browser address bar to allow microphone access.', 'error');
                } else {
                    addMessage(`ğŸ¤ Could not access microphone: ${err.message}`, 'error');
                }
                return false;
            }
        }

        async function startVoiceRecording() {
            if (!chatState.voiceRecognition) {
                addMessage('ğŸ¤ Voice input not available. Please use Chrome, Edge, or Safari.', 'error');
                return;
            }

            // Prevent double-start
            if (chatState.isRecording) return;

            // BUILD 356: Request permission first if not already granted
            if (!micPermissionGranted) {
                const granted = await requestMicrophonePermission();
                if (!granted) return;
            }

            chatState.isRecording = true;
            chatState.voiceFinalText = '';
            chatState.voiceInterimText = '';
            document.getElementById('chat-voice-btn')?.classList.add('recording');

            // Reset input styling
            const inputEl = document.getElementById('chat-assistant-input');
            if (inputEl) {
                inputEl.value = '';
                inputEl.placeholder = 'ğŸ¤ Listening... speak now';
            }

            try {
                chatState.voiceRecognition.start();
                console.log('ğŸ¤ Voice recording started');
            } catch (e) {
                console.error('Voice start error:', e);
                if (e.message.includes('already started')) {
                    // Already recording, ignore
                } else {
                    addMessage('ğŸ¤ Could not start voice recording. Please try again.', 'error');
                    stopVoiceRecording();
                }
            }
        }

        function stopVoiceRecording() {
            if (!chatState.isRecording) return;

            chatState.isRecording = false;
            document.getElementById('chat-voice-btn')?.classList.remove('recording');

            // Reset input styling
            const inputEl = document.getElementById('chat-assistant-input');
            if (inputEl) {
                inputEl.style.borderColor = '';
                inputEl.placeholder = 'Ask anything or give a command...';
            }

            try {
                chatState.voiceRecognition?.stop();
                console.log('ğŸ¤ Voice recording stopped');
            } catch (e) {
                // Ignore stop errors
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initChatAssistant() {
            // Toggle button (opens either classic panel or Command Frame based on preference)
            document.getElementById('chat-assistant-bubble')?.addEventListener('click', toggleChatPanel);

            // Classic panel: Close button
            document.getElementById('chat-close-btn')?.addEventListener('click', toggleChatPanel);

            // BUILD 393: Initialize Command Frame
            initCommandFrameButtons();

            // Clear button
            document.getElementById('chat-clear-btn')?.addEventListener('click', () => {
                const messages = document.getElementById('chat-assistant-messages');
                messages.innerHTML = `
                    <div class="chat-message assistant">
                        Chat cleared! How can I help you?
                        <div class="action-buttons" style="margin-top: 8px;">
                            <button class="action-btn" data-action="help">ğŸ“– Learn features</button>
                            <button class="action-btn" data-action="create">ğŸŒ³ Create a project</button>
                        </div>
                    </div>
                `;
                chatState.conversationHistory = [];
                // BUILD 355: Clear persisted memory too
                localStorage.removeItem('treebeardConversation');
            });

            // Send button
            document.getElementById('chat-send-btn')?.addEventListener('click', handleSendMessage);

            // Input - Enter to send, Shift+Enter for newline
            const input = document.getElementById('chat-assistant-input');
            input?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            });

            // Auto-resize textarea
            input?.addEventListener('input', () => {
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, 100) + 'px';
            });

            // Voice button - BUILD 258: Added touch support for mobile
            const voiceBtn = document.getElementById('chat-voice-btn');
            if (voiceBtn) {
                // Desktop: hold to record
                voiceBtn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    startVoiceRecording();
                });
                voiceBtn.addEventListener('mouseup', stopVoiceRecording);
                voiceBtn.addEventListener('mouseleave', stopVoiceRecording);

                // Mobile: touch hold to record
                voiceBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startVoiceRecording();
                }, { passive: false });
                voiceBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    stopVoiceRecording();
                });
                voiceBtn.addEventListener('touchcancel', stopVoiceRecording);

                // Also support single click/tap to toggle
                let clickTimeout;
                voiceBtn.addEventListener('click', (e) => {
                    // If already recording, stop
                    if (chatState.isRecording) {
                        stopVoiceRecording();
                    }
                    // Quick click also starts (will auto-stop after speech ends)
                });
            }

            // Quick action chips
            document.querySelectorAll('.quick-action-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    const prompt = chip.dataset.prompt;
                    if (prompt) {
                        document.getElementById('chat-assistant-input').value = prompt;
                        handleSendMessage();
                    }
                });
            });

            // BUILD 438: Action buttons - use event delegation for dynamic buttons
            const messagesContainer = document.getElementById('chat-assistant-messages');
            if (messagesContainer) {
                messagesContainer.addEventListener('click', (e) => {
                    const btn = e.target.closest('.action-btn[data-action]');
                    if (!btn) return;

                    const action = btn.dataset.action;
                    if (action === 'help') {
                        executeAction('show_help');
                    } else if (action === 'create') {
                        executeAction('open_wizard');
                    } else if (action === 'enhance') {
                        addMessage('Select some items in Canvas view, then ask me to "enhance selected items"!', 'assistant');
                    } else if (action === 'query') {
                        addMessage('Try queries like:\nâ€¢ "show items over $500K"\nâ€¢ "find blocked items"\nâ€¢ "show Sarah\'s items"\n\nOr click ğŸ”— Hyperedges â†’ ğŸ” Query for the visual builder!', 'assistant');
                    }
                });
            }

            // Keyboard shortcut: Ctrl+/ to toggle
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === '/') {
                    e.preventDefault();
                    toggleChatPanel();
                }
            });

            // Initialize voice
            initVoiceInput();

            // Initialize draggable panel
            initDraggablePanel();

            // Restore saved position
            restorePanelPosition();

            // BUILD 355: Restore conversation history UI if we have previous messages
            restoreConversationUI();

            console.log('ğŸŒ³ TreeBeard initialized (Build 355 - Conversation Memory)');

            // BUILD 370: Initialize Voice Capture system
            initVoiceCaptureSystem();

            // BUILD 371: Initialize Artifact Panel
            initArtifactPanel();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 370: VOICE CAPTURE SYSTEM
        // - Voice Inbox with FAB (mobile) + TreeBeard mic entry points
        // - Live transcript recording
        // - Captures section in TreeBeard
        // - Processing flow with guided prompts
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const voiceCaptureState = {
            isRecording: false,
            recognition: null,
            finalTranscript: '',
            interimTranscript: '',
            startTime: null,
            durationTimer: null,
            warningShown: false,
            captures: [], // Per-tree captures loaded from capexTree.captures
            processingCaptureId: null
        };

        function initVoiceCaptureSystem() {
            // Load captures from tree if available
            loadCapturesFromTree();

            // FAB click handler - Build 499: Direct Quick Capture for conversation/debate recording
            const fab = document.getElementById('voice-capture-fab');
            if (fab) {
                fab.addEventListener('click', () => {
                    // Direct to Quick Capture for conversation-to-tree recording
                    if (typeof window.enterCaptureMode === 'function') {
                        window.enterCaptureMode();
                    } else {
                        console.error('Quick Capture not available');
                    }
                });
            }

            // Quick action buttons in processing prompt
            document.querySelectorAll('#capture-processing-prompt .quick-action').forEach(btn => {
                btn.addEventListener('click', () => {
                    const action = btn.dataset.action;
                    handleCaptureAction(action);
                });
            });

            // Update body class when TreeBeard opens/closes
            const panel = document.getElementById('chat-assistant-panel');
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'class') {
                        if (panel.classList.contains('open')) {
                            document.body.classList.add('treebeard-open');
                            document.getElementById('chat-assistant-bubble')?.classList.add('panel-open');
                        } else {
                            document.body.classList.remove('treebeard-open');
                            document.getElementById('chat-assistant-bubble')?.classList.remove('panel-open');
                        }
                    }
                });
            });
            if (panel) {
                observer.observe(panel, { attributes: true });
            }

            // Initialize Web Speech API for voice capture
            initVoiceCaptureRecognition();

            console.log('ğŸ¤ Voice Capture system initialized (Build 370)');
        }

        function initVoiceCaptureRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.warn('Web Speech API not supported');
                return;
            }

            voiceCaptureState.recognition = new SpeechRecognition();
            voiceCaptureState.recognition.continuous = true;
            voiceCaptureState.recognition.interimResults = true;
            voiceCaptureState.recognition.lang = 'en-US';

            voiceCaptureState.recognition.onresult = (event) => {
                let interim = '';
                let final = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        final += transcript + ' ';
                    } else {
                        interim += transcript;
                    }
                }

                if (final) {
                    voiceCaptureState.finalTranscript += final;
                }
                voiceCaptureState.interimTranscript = interim;

                updateLiveTranscriptUI();
            };

            voiceCaptureState.recognition.onerror = (event) => {
                console.error('Voice capture error:', event.error);
                if (event.error === 'not-allowed') {
                    addMessage('ğŸ¤ Microphone access denied. Please allow microphone permission.', 'error');
                    cancelVoiceCapture();
                } else if (event.error === 'network') {
                    addMessage('ğŸ¤ Voice capture requires internet connection.', 'error');
                    cancelVoiceCapture();
                }
            };

            voiceCaptureState.recognition.onend = () => {
                // If still supposed to be recording, restart (for continuous recording)
                if (voiceCaptureState.isRecording) {
                    try {
                        voiceCaptureState.recognition.start();
                    } catch (e) {
                        // Ignore restart errors
                    }
                }
            };
        }

        function openTreeBeardWithVoice() {
            // Open TreeBeard panel
            const panel = document.getElementById('chat-assistant-panel');
            if (panel && !panel.classList.contains('open')) {
                panel.classList.add('open');
            }

            // Start voice capture
            setTimeout(() => startVoiceCapture(), 100);
        }

        window.startVoiceCapture = async function() {
            if (!voiceCaptureState.recognition) {
                addMessage('ğŸ¤ Voice capture not available. Please use Chrome, Edge, or Safari.', 'error');
                return;
            }

            if (voiceCaptureState.isRecording) return;

            // Check for internet connection
            if (!navigator.onLine) {
                addMessage('ğŸ¤ Voice capture requires internet for transcription.', 'error');
                return;
            }

            // Request microphone permission
            if (!micPermissionGranted) {
                const granted = await requestMicrophonePermission();
                if (!granted) return;
            }

            voiceCaptureState.isRecording = true;
            voiceCaptureState.finalTranscript = '';
            voiceCaptureState.interimTranscript = '';
            voiceCaptureState.startTime = Date.now();
            voiceCaptureState.warningShown = false;

            // Show recording UI
            const recordingUI = document.getElementById('voice-recording-ui');
            if (recordingUI) {
                recordingUI.classList.add('active');
            }

            // Hide captures section while recording
            const capturesSection = document.getElementById('voice-captures-section');
            if (capturesSection) {
                capturesSection.style.display = 'none';
            }

            // Update FAB if visible
            const fab = document.getElementById('voice-capture-fab');
            if (fab) {
                fab.classList.add('recording');
            }

            // Update voice button
            const voiceBtn = document.getElementById('chat-voice-btn');
            if (voiceBtn) {
                voiceBtn.classList.add('recording');
            }

            // Reset transcript display
            updateLiveTranscriptUI();

            // Start duration timer
            voiceCaptureState.durationTimer = setInterval(updateDurationDisplay, 1000);

            // Start recognition
            try {
                voiceCaptureState.recognition.start();
                console.log('ğŸ¤ Voice capture started');
            } catch (e) {
                console.error('Voice capture start error:', e);
                cancelVoiceCapture();
            }
        };

        window.stopVoiceCapture = function() {
            if (!voiceCaptureState.isRecording) return;

            voiceCaptureState.isRecording = false;

            // Stop recognition
            try {
                voiceCaptureState.recognition?.stop();
            } catch (e) {
                // Ignore stop errors
            }

            // Stop duration timer
            if (voiceCaptureState.durationTimer) {
                clearInterval(voiceCaptureState.durationTimer);
                voiceCaptureState.durationTimer = null;
            }

            // Hide recording UI
            const recordingUI = document.getElementById('voice-recording-ui');
            if (recordingUI) {
                recordingUI.classList.remove('active');
            }

            // Update FAB
            const fab = document.getElementById('voice-capture-fab');
            if (fab) {
                fab.classList.remove('recording');
            }

            // Update voice button
            const voiceBtn = document.getElementById('chat-voice-btn');
            if (voiceBtn) {
                voiceBtn.classList.remove('recording');
            }

            // Get final transcript
            const transcript = voiceCaptureState.finalTranscript.trim();

            if (transcript.length > 0) {
                // Create capture
                const capture = {
                    id: 'cap-' + Date.now(),
                    transcript: transcript,
                    wordCount: transcript.split(/\s+/).filter(w => w).length,
                    createdAt: new Date().toISOString(),
                    artifacts: []
                };

                // Add to captures
                voiceCaptureState.captures.push(capture);
                saveCaptureToTree();
                updateCapturesUI();

                // Show processing prompt for this capture
                showCaptureProcessingPrompt(capture);

                console.log('ğŸ¤ Voice capture saved:', capture.id);
            } else {
                addMessage('ğŸ¤ No speech detected. Please try again.', 'error');
                // Show captures section again
                updateCapturesUI();
            }
        };

        window.cancelVoiceCapture = function() {
            voiceCaptureState.isRecording = false;

            // Stop recognition
            try {
                voiceCaptureState.recognition?.stop();
            } catch (e) {
                // Ignore stop errors
            }

            // Stop duration timer
            if (voiceCaptureState.durationTimer) {
                clearInterval(voiceCaptureState.durationTimer);
                voiceCaptureState.durationTimer = null;
            }

            // Hide recording UI
            const recordingUI = document.getElementById('voice-recording-ui');
            if (recordingUI) {
                recordingUI.classList.remove('active');
            }

            // Update FAB
            const fab = document.getElementById('voice-capture-fab');
            if (fab) {
                fab.classList.remove('recording');
            }

            // Update voice button
            const voiceBtn = document.getElementById('chat-voice-btn');
            if (voiceBtn) {
                voiceBtn.classList.remove('recording');
            }

            // Show captures section again
            updateCapturesUI();

            console.log('ğŸ¤ Voice capture cancelled');
        };

        function updateLiveTranscriptUI() {
            const area = document.querySelector('.live-transcript-area');
            if (!area) return;

            const placeholder = area.querySelector('.live-transcript-placeholder');
            const finalSpan = area.querySelector('.final');
            const interimSpan = area.querySelector('.interim');

            const hasText = voiceCaptureState.finalTranscript || voiceCaptureState.interimTranscript;

            if (placeholder) {
                placeholder.style.display = hasText ? 'none' : 'block';
            }

            if (finalSpan) {
                finalSpan.textContent = voiceCaptureState.finalTranscript;
            }

            if (interimSpan) {
                interimSpan.textContent = voiceCaptureState.interimTranscript;
            }

            // Auto-scroll to bottom
            area.scrollTop = area.scrollHeight;
        }

        function updateDurationDisplay() {
            const elapsed = Math.floor((Date.now() - voiceCaptureState.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;

            const display = document.querySelector('.recording-duration');
            if (display) {
                display.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            // Show warning after 5 minutes
            if (elapsed >= 300 && !voiceCaptureState.warningShown) {
                voiceCaptureState.warningShown = true;
                const warning = document.querySelector('.recording-warning');
                if (warning) {
                    warning.classList.add('show');
                }
            }
        }

        function loadCapturesFromTree() {
            voiceCaptureState.captures = capexTree?.captures || [];
            updateCapturesUI();
        }

        function saveCaptureToTree() {
            if (!capexTree) return;
            capexTree.captures = voiceCaptureState.captures;
            // Save to localStorage
            if (typeof treeManager !== 'undefined') { treeManager.markAsChanged(); }
        }

        function updateCapturesUI() {
            const section = document.getElementById('voice-captures-section');
            const list = section?.querySelector('.captures-list');
            const countBadge = section?.querySelector('.capture-count');
            const fabBadge = document.querySelector('#voice-capture-fab .fab-badge');

            const captures = voiceCaptureState.captures;

            // Update count badges
            if (countBadge) {
                countBadge.textContent = captures.length;
            }
            if (fabBadge) {
                fabBadge.textContent = captures.length;
                fabBadge.style.display = captures.length > 0 ? 'flex' : 'none';
            }

            // Show/hide section
            if (section) {
                section.style.display = captures.length > 0 ? 'block' : 'none';
            }

            // Render captures list
            if (list) {
                list.innerHTML = captures.map(cap => {
                    const preview = cap.transcript.substring(0, 100) + (cap.transcript.length > 100 ? '...' : '');
                    const timeAgo = getTimeAgo(new Date(cap.createdAt));
                    return `
                        <div class="capture-item" data-id="${cap.id}" onclick="window.toggleCaptureExpand(this)">
                            <div class="capture-preview">${escapeHtml(cap.transcript)}</div>
                            <div class="capture-meta">
                                <span class="word-count">${cap.wordCount} words</span>
                                <span>${timeAgo}</span>
                            </div>
                            <div class="capture-actions">
                                <button class="capture-action-btn" onclick="event.stopPropagation(); window.processCaptureById('${cap.id}')">Process</button>
                                <button class="capture-action-btn" onclick="event.stopPropagation(); window.editCaptureById('${cap.id}')">Edit</button>
                                <button class="capture-action-btn delete" onclick="event.stopPropagation(); window.deleteCaptureById('${cap.id}')">Delete</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            // Show nudge if 3+ captures
            if (captures.length >= 3) {
                // Could show a gentle reminder in TreeBeard
            }
        }

        window.toggleCapturesSection = function() {
            const section = document.getElementById('voice-captures-section');
            if (section) {
                section.classList.toggle('collapsed');
            }
        };

        window.toggleCaptureExpand = function(element) {
            element.classList.toggle('expanded');
        };

        window.processCaptureById = function(captureId) {
            const capture = voiceCaptureState.captures.find(c => c.id === captureId);
            if (capture) {
                showCaptureProcessingPrompt(capture);
            }
        };

        window.editCaptureById = function(captureId) {
            const capture = voiceCaptureState.captures.find(c => c.id === captureId);
            if (!capture) return;

            // Simple edit via prompt
            const newText = prompt('Edit transcript:', capture.transcript);
            if (newText !== null && newText.trim()) {
                capture.transcript = newText.trim();
                capture.wordCount = newText.trim().split(/\s+/).filter(w => w).length;
                saveCaptureToTree();
                updateCapturesUI();
            }
        };

        window.deleteCaptureById = function(captureId) {
            if (!confirm('Delete this capture permanently?')) return;

            voiceCaptureState.captures = voiceCaptureState.captures.filter(c => c.id !== captureId);
            saveCaptureToTree();
            updateCapturesUI();

            // Hide processing prompt if this was the one being processed
            if (voiceCaptureState.processingCaptureId === captureId) {
                hideCaptureProcessingPrompt();
            }
        };

        function showCaptureProcessingPrompt(capture) {
            voiceCaptureState.processingCaptureId = capture.id;

            const prompt = document.getElementById('capture-processing-prompt');
            const preview = prompt?.querySelector('.transcript-preview');

            if (preview) {
                preview.textContent = capture.transcript;
            }

            if (prompt) {
                prompt.style.display = 'block';
            }

            // Focus the input for custom instruction
            const input = document.getElementById('chat-assistant-input');
            if (input) {
                input.placeholder = 'Or type custom instruction...';
                input.focus();
            }
        }

        function hideCaptureProcessingPrompt() {
            voiceCaptureState.processingCaptureId = null;

            const prompt = document.getElementById('capture-processing-prompt');
            if (prompt) {
                prompt.style.display = 'none';
            }

            const input = document.getElementById('chat-assistant-input');
            if (input) {
                input.placeholder = 'Ask anything or give a command...';
            }
        }

        function handleCaptureAction(action) {
            const captureId = voiceCaptureState.processingCaptureId;
            const capture = voiceCaptureState.captures.find(c => c.id === captureId);
            if (!capture) return;

            let instruction = '';

            switch (action) {
                case 'add-to-tree':
                    instruction = `Structure this voice capture and add it to the current tree:\n\n"${capture.transcript}"`;
                    break;
                case 'new-branch':
                    instruction = `Create a new branch/phase from this voice capture:\n\n"${capture.transcript}"`;
                    break;
                case 'save-as-note':
                    // Add as raw note directly
                    addCaptureAsRawNote(capture);
                    return;
                case 'psych-analysis':
                    // Trigger Free Speech analysis
                    instruction = `Perform psychological pattern analysis on this voice capture (like Free Speech mode):\n\n"${capture.transcript}"`;
                    break;
            }

            // Send to TreeBeard
            if (instruction) {
                const input = document.getElementById('chat-assistant-input');
                if (input) {
                    input.value = instruction;
                }
                handleSendMessage();

                // Remove the capture after processing
                removeCaptureAfterProcessing(captureId);
            }
        }

        function addCaptureAsRawNote(capture) {
            // Find or create a "Voice Notes" phase
            let notesPhase = capexTree.children.find(p => p.name === 'Voice Notes');
            if (!notesPhase) {
                notesPhase = {
                    id: 'phase-voice-notes-' + Date.now(),
                    name: 'Voice Notes',
                    type: 'phase',
                    items: []
                };
                capexTree.children.push(notesPhase);
            }

            // Add the capture as an item
            const noteItem = {
                id: 'item-' + Date.now(),
                name: capture.transcript.substring(0, 60) + (capture.transcript.length > 60 ? '...' : ''),
                type: 'item',
                description: capture.transcript,
                raw_transcript: capture.transcript,
                capture_mode: 'voice',
                createdAt: capture.createdAt
            };

            notesPhase.items = notesPhase.items || [];
            notesPhase.items.push(noteItem);

            // Save and render
            saveState('Added voice note');
            render();
            if (typeof treeManager !== 'undefined') { treeManager.markAsChanged(); }

            // Remove the capture
            removeCaptureAfterProcessing(capture.id);

            addMessage(`âœ“ Added as note in "Voice Notes" phase`, 'system');
        }

        function removeCaptureAfterProcessing(captureId) {
            voiceCaptureState.captures = voiceCaptureState.captures.filter(c => c.id !== captureId);
            saveCaptureToTree();
            updateCapturesUI();
            hideCaptureProcessingPrompt();
        }

        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 370: INDEXEDDB ARTIFACT STORAGE
        // - Local storage for artifacts during session
        // - Survives browser refresh/crash
        // - Keyed to tree ID
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const artifactDB = {
            dbName: 'TreeListyArtifacts',
            dbVersion: 1,
            storeName: 'artifacts',
            db: null
        };

        async function initArtifactDB() {
            return new Promise((resolve, reject) => {
                if (artifactDB.db) {
                    resolve(artifactDB.db);
                    return;
                }

                const request = indexedDB.open(artifactDB.dbName, artifactDB.dbVersion);

                request.onerror = () => {
                    console.error('Failed to open artifact database:', request.error);
                    reject(request.error);
                };

                request.onsuccess = () => {
                    artifactDB.db = request.result;
                    console.log('ğŸ“¦ Artifact database initialized');
                    resolve(artifactDB.db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // Create artifacts store
                    if (!db.objectStoreNames.contains(artifactDB.storeName)) {
                        const store = db.createObjectStore(artifactDB.storeName, { keyPath: 'id' });
                        store.createIndex('treeId', 'treeId', { unique: false });
                        store.createIndex('itemId', 'itemId', { unique: false });
                        console.log('ğŸ“¦ Created artifacts object store');
                    }
                };
            });
        }

        async function saveArtifact(artifact) {
            try {
                const db = await initArtifactDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([artifactDB.storeName], 'readwrite');
                    const store = transaction.objectStore(artifactDB.storeName);

                    const artifactRecord = {
                        id: artifact.id || 'art-' + Date.now(),
                        treeId: capexTree?.id || 'unknown',
                        itemId: artifact.itemId,
                        filename: artifact.filename,
                        type: artifact.type,
                        size: artifact.size,
                        data: artifact.data, // Base64 or Blob
                        addedAt: new Date().toISOString()
                    };

                    const request = store.put(artifactRecord);

                    request.onsuccess = () => {
                        console.log('ğŸ“¦ Artifact saved:', artifactRecord.id);
                        resolve(artifactRecord);
                    };

                    request.onerror = () => {
                        console.error('Failed to save artifact:', request.error);
                        reject(request.error);
                    };
                });
            } catch (e) {
                console.error('Error saving artifact:', e);
                throw e;
            }
        }

        async function getArtifact(artifactId) {
            try {
                const db = await initArtifactDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([artifactDB.storeName], 'readonly');
                    const store = transaction.objectStore(artifactDB.storeName);
                    const request = store.get(artifactId);

                    request.onsuccess = () => {
                        resolve(request.result || null);
                    };

                    request.onerror = () => {
                        console.error('Failed to get artifact:', request.error);
                        reject(request.error);
                    };
                });
            } catch (e) {
                console.error('Error getting artifact:', e);
                return null;
            }
        }

        async function getArtifactsForTree(treeId) {
            try {
                const db = await initArtifactDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([artifactDB.storeName], 'readonly');
                    const store = transaction.objectStore(artifactDB.storeName);
                    const index = store.index('treeId');
                    const request = index.getAll(treeId);

                    request.onsuccess = () => {
                        resolve(request.result || []);
                    };

                    request.onerror = () => {
                        console.error('Failed to get tree artifacts:', request.error);
                        reject(request.error);
                    };
                });
            } catch (e) {
                console.error('Error getting tree artifacts:', e);
                return [];
            }
        }

        async function getArtifactsForItem(itemId) {
            try {
                const db = await initArtifactDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([artifactDB.storeName], 'readonly');
                    const store = transaction.objectStore(artifactDB.storeName);
                    const index = store.index('itemId');
                    const request = index.getAll(itemId);

                    request.onsuccess = () => {
                        resolve(request.result || []);
                    };

                    request.onerror = () => {
                        console.error('Failed to get item artifacts:', request.error);
                        reject(request.error);
                    };
                });
            } catch (e) {
                console.error('Error getting item artifacts:', e);
                return [];
            }
        }

        async function deleteArtifact(artifactId) {
            try {
                const db = await initArtifactDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([artifactDB.storeName], 'readwrite');
                    const store = transaction.objectStore(artifactDB.storeName);
                    const request = store.delete(artifactId);

                    request.onsuccess = () => {
                        console.log('ğŸ“¦ Artifact deleted:', artifactId);
                        resolve(true);
                    };

                    request.onerror = () => {
                        console.error('Failed to delete artifact:', request.error);
                        reject(request.error);
                    };
                });
            } catch (e) {
                console.error('Error deleting artifact:', e);
                return false;
            }
        }

        async function deleteArtifactsForTree(treeId) {
            try {
                const artifacts = await getArtifactsForTree(treeId);
                for (const artifact of artifacts) {
                    await deleteArtifact(artifact.id);
                }
                console.log(`ğŸ“¦ Deleted ${artifacts.length} artifacts for tree:`, treeId);
                return true;
            } catch (e) {
                console.error('Error deleting tree artifacts:', e);
                return false;
            }
        }

        // File to artifact helper
        async function fileToArtifact(file, itemId) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = async () => {
                    const artifact = {
                        id: 'art-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                        itemId: itemId,
                        filename: file.name,
                        type: file.type,
                        size: file.size,
                        data: reader.result // Base64 data URL
                    };

                    try {
                        const saved = await saveArtifact(artifact);
                        resolve(saved);
                    } catch (e) {
                        reject(e);
                    }
                };

                reader.onerror = () => {
                    reject(new Error('Failed to read file'));
                };

                reader.readAsDataURL(file);
            });
        }

        // Get artifact display info
        function getArtifactDisplayInfo(artifact) {
            const isImage = artifact.type?.startsWith('image/');
            const isAudio = artifact.type?.startsWith('audio/');
            const isPDF = artifact.type === 'application/pdf';

            let icon = 'ğŸ“';
            if (isImage) icon = 'ğŸ–¼ï¸';
            else if (isAudio) icon = 'ğŸ™ï¸';
            else if (isPDF) icon = 'ğŸ“„';

            const sizeStr = artifact.size >= 1024 * 1024
                ? (artifact.size / (1024 * 1024)).toFixed(1) + ' MB'
                : (artifact.size / 1024).toFixed(0) + ' KB';

            return {
                icon,
                isImage,
                isAudio,
                isPDF,
                canPreview: isImage || isAudio || isPDF,
                sizeStr
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 371: ARTIFACT SIDE PANEL
        // - View/manage artifacts attached to items
        // - Drag-and-drop file upload
        // - Preview images, audio, PDFs
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const artifactPanelState = {
            isOpen: false,
            currentItemId: null,
            currentItemName: ''
        };

        function initArtifactPanel() {
            const dropZone = document.getElementById('artifact-drop-zone');
            const fileInput = document.getElementById('artifact-file-input');

            if (!dropZone || !fileInput) return;

            // Click to browse
            dropZone.addEventListener('click', () => {
                fileInput.click();
            });

            // File input change
            fileInput.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                await handleArtifactFiles(files);
                fileInput.value = ''; // Reset
            });

            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');

                const files = Array.from(e.dataTransfer.files);
                await handleArtifactFiles(files);
            });

            console.log('ğŸ“ Artifact panel initialized');
        }

        async function handleArtifactFiles(files) {
            if (!artifactPanelState.currentItemId) {
                showToast('No item selected for attachments', 'error');
                return;
            }

            const MAX_FILE_SIZE = 25 * 1024 * 1024; // 25MB limit

            for (const file of files) {
                if (file.size > MAX_FILE_SIZE) {
                    showToast(`${file.name} is too large (max 25MB)`, 'warning');
                    continue;
                }

                try {
                    const artifact = await fileToArtifact(file, artifactPanelState.currentItemId);
                    console.log('ğŸ“ File attached:', artifact.filename);
                    showToast(`Attached: ${artifact.filename}`, 'success');
                } catch (e) {
                    console.error('Failed to attach file:', e);
                    showToast(`Failed to attach ${file.name}`, 'error');
                }
            }

            // Refresh artifact list
            await updateArtifactPanel();
            // Update item in tree to show badge
            render();
        }

        window.openArtifactPanel = async function(itemId, itemName) {
            artifactPanelState.currentItemId = itemId;
            artifactPanelState.currentItemName = itemName || 'Item';
            artifactPanelState.isOpen = true;

            const panel = document.getElementById('artifact-panel');
            const itemNameEl = document.getElementById('artifact-panel-item-name');

            if (itemNameEl) {
                itemNameEl.textContent = artifactPanelState.currentItemName;
            }

            if (panel) {
                panel.classList.add('open');
            }

            await updateArtifactPanel();
        };

        window.closeArtifactPanel = function() {
            artifactPanelState.isOpen = false;
            artifactPanelState.currentItemId = null;

            const panel = document.getElementById('artifact-panel');
            if (panel) {
                panel.classList.remove('open');
            }
        };

        async function updateArtifactPanel() {
            const listEl = document.getElementById('artifact-list');
            const emptyEl = document.getElementById('artifact-empty');

            if (!listEl || !artifactPanelState.currentItemId) return;

            // Get artifacts for current item
            const artifacts = await getArtifactsForItem(artifactPanelState.currentItemId);

            if (artifacts.length === 0) {
                listEl.innerHTML = '';
                if (emptyEl) emptyEl.style.display = 'block';
                return;
            }

            if (emptyEl) emptyEl.style.display = 'none';

            listEl.innerHTML = artifacts.map(artifact => {
                const info = getArtifactDisplayInfo(artifact);
                const previewHtml = info.isImage && artifact.data
                    ? `<img src="${artifact.data}" alt="${artifact.filename}">`
                    : `<span class="placeholder-icon">${info.icon}</span>`;

                return `
                    <div class="artifact-list-item" data-artifact-id="${artifact.id}">
                        <div class="artifact-preview">
                            ${previewHtml}
                        </div>
                        <div class="artifact-info">
                            <div class="artifact-name">${artifact.filename}</div>
                            <div class="artifact-meta">${info.sizeStr} â€¢ ${new Date(artifact.addedAt).toLocaleDateString()}</div>
                            <div class="artifact-actions">
                                ${info.canPreview ? `<button class="artifact-action" onclick="window.previewArtifact('${artifact.id}')">Preview</button>` : ''}
                                <button class="artifact-action" onclick="window.downloadArtifact('${artifact.id}')">Download</button>
                                <button class="artifact-action delete" onclick="window.removeArtifact('${artifact.id}')">Remove</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        window.previewArtifact = async function(artifactId) {
            const artifact = await getArtifact(artifactId);
            if (!artifact || !artifact.data) {
                showToast('Could not load artifact', 'error');
                return;
            }

            const info = getArtifactDisplayInfo(artifact);

            // Create preview modal
            const modal = document.createElement('div');
            modal.className = 'artifact-preview-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.9);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
                padding: 40px;
            `;

            let contentHtml = '';
            if (info.isImage) {
                contentHtml = `<img src="${artifact.data}" style="max-width: 100%; max-height: 80vh; border-radius: 8px;">`;
            } else if (info.isAudio) {
                contentHtml = `<audio src="${artifact.data}" controls style="width: 400px;"></audio>`;
            } else if (info.isPDF) {
                contentHtml = `<iframe src="${artifact.data}" style="width: 90vw; height: 80vh; border: none; border-radius: 8px;"></iframe>`;
            }

            modal.innerHTML = `
                <div style="text-align: center;">
                    ${contentHtml}
                    <div style="margin-top: 16px; color: #888;">${artifact.filename}</div>
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        margin-top: 16px;
                        padding: 8px 24px;
                        background: #6366f1;
                        border: none;
                        border-radius: 8px;
                        color: white;
                        cursor: pointer;
                    ">Close</button>
                </div>
            `;

            document.body.appendChild(modal);

            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });

            // Close on Escape
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        };

        window.downloadArtifact = async function(artifactId) {
            const artifact = await getArtifact(artifactId);
            if (!artifact || !artifact.data) {
                showToast('Could not load artifact', 'error');
                return;
            }

            // Create download link
            const link = document.createElement('a');
            link.href = artifact.data;
            link.download = artifact.filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showToast(`Downloaded: ${artifact.filename}`, 'success');
        };

        window.removeArtifact = async function(artifactId) {
            if (!confirm('Remove this attachment?')) return;

            try {
                await deleteArtifact(artifactId);
                showToast('Attachment removed', 'success');
                await updateArtifactPanel();
                render(); // Update badges
            } catch (e) {
                console.error('Failed to remove artifact:', e);
                showToast('Failed to remove attachment', 'error');
            }
        };

        // Get artifact count for an item (for badges)
        async function getArtifactCountForItem(itemId) {
            const artifacts = await getArtifactsForItem(itemId);
            return artifacts.length;
        }

        // Expose for tree rendering
        window.getArtifactCountForItem = getArtifactCountForItem;
        window.openArtifactPanel = window.openArtifactPanel;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 372: .TREELISTY BUNDLE EXPORT/IMPORT
        // - ZIP archive containing tree.json + artifacts folder
        // - Portable format for sharing trees with attachments
        // - Import restores tree and all artifacts to IndexedDB
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Export current tree as .treelisty bundle (ZIP)
         * Contains: tree.json + artifacts/ folder with all attachments
         */
        window.exportTreelistyBundle = async function() {
            // Lazy load JSZip library
            try {
                await loadLibrary('jszip');
            } catch (e) {
                showToast('Failed to load bundle export library. Please try again.', 'error');
                console.error('JSZip load error:', e);
                return;
            }

            try {
                showToast('Preparing bundle...', 'info');

                const zip = new JSZip();
                const treeId = capexTree?.id || 'unknown';

                // Get all artifacts for this tree
                const artifacts = await getArtifactsForTree(treeId);

                // Build artifact manifest for tree.json
                const artifactManifest = {};
                for (const artifact of artifacts) {
                    artifactManifest[artifact.id] = {
                        filename: artifact.filename,
                        itemId: artifact.itemId,
                        type: artifact.type,
                        size: artifact.size,
                        addedAt: artifact.addedAt
                    };
                }

                // Create tree.json with artifact manifest
                const treeData = JSON.parse(JSON.stringify(capexTree));
                treeData.artifacts = artifactManifest;
                treeData.exportedAt = new Date().toISOString();
                treeData.bundleVersion = 1;

                zip.file('tree.json', JSON.stringify(treeData, null, 2));

                // Add artifacts to artifacts/ folder
                const artifactsFolder = zip.folder('artifacts');
                for (const artifact of artifacts) {
                    if (artifact.data) {
                        // Convert data URL to binary
                        const base64Data = artifact.data.split(',')[1];
                        if (base64Data) {
                            artifactsFolder.file(artifact.id + '_' + artifact.filename, base64Data, { base64: true });
                        }
                    }
                }

                // Generate the ZIP file
                const content = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });

                // Create filename from tree name
                const safeName = (capexTree?.name || 'tree')
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-|-$/g, '')
                    .substring(0, 50);
                const filename = `${safeName}.treelisty`;

                // Trigger download
                const url = URL.createObjectURL(content);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                const artifactCount = artifacts.length;
                const sizeKB = Math.round(content.size / 1024);
                showToast(`Bundle exported: ${artifactCount} artifacts, ${sizeKB} KB`, 'success');

            } catch (e) {
                console.error('Failed to export bundle:', e);
                showToast('Failed to export bundle: ' + e.message, 'error');
            }
        };

        /**
         * Import .treelisty bundle
         * Restores tree data and all artifacts to IndexedDB
         */
        window.importTreelistyBundle = async function(file) {
            if (!window.JSZip) {
                showToast('JSZip library not loaded', 'error');
                return false;
            }

            try {
                showToast('Importing bundle...', 'info');

                const zip = await JSZip.loadAsync(file);

                // Read tree.json
                const treeJsonFile = zip.file('tree.json');
                if (!treeJsonFile) {
                    throw new Error('Invalid bundle: tree.json not found');
                }

                const treeJsonText = await treeJsonFile.async('string');
                const importedTree = JSON.parse(treeJsonText);

                // Validate tree structure
                if (!importedTree.name || !importedTree.children) {
                    throw new Error('Invalid bundle: tree.json is malformed');
                }

                // Extract artifact manifest
                const artifactManifest = importedTree.artifacts || {};
                delete importedTree.artifacts; // Remove from tree data
                delete importedTree.exportedAt;
                delete importedTree.bundleVersion;

                // Generate new tree ID to avoid conflicts
                const newTreeId = 'tree-' + Date.now();
                const oldTreeId = importedTree.id;
                importedTree.id = newTreeId;

                // Import artifacts from artifacts/ folder
                const artifactsFolder = zip.folder('artifacts');
                let artifactCount = 0;

                if (artifactsFolder) {
                    const artifactFiles = [];
                    artifactsFolder.forEach((relativePath, zipEntry) => {
                        if (!zipEntry.dir) {
                            artifactFiles.push({ path: relativePath, entry: zipEntry });
                        }
                    });

                    for (const { path, entry } of artifactFiles) {
                        try {
                            // Extract original artifact ID from filename (id_originalname.ext)
                            const underscoreIndex = path.indexOf('_');
                            const originalId = underscoreIndex > 0 ? path.substring(0, underscoreIndex) : path;
                            const originalFilename = underscoreIndex > 0 ? path.substring(underscoreIndex + 1) : path;

                            // Get manifest info
                            const manifestInfo = artifactManifest[originalId] || {};

                            // Read file data as base64
                            const base64Data = await entry.async('base64');
                            const mimeType = manifestInfo.type || 'application/octet-stream';
                            const dataUrl = `data:${mimeType};base64,${base64Data}`;

                            // Create new artifact with new ID
                            const newArtifactId = 'art-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                            const artifact = {
                                id: newArtifactId,
                                treeId: newTreeId,
                                itemId: manifestInfo.itemId,
                                filename: manifestInfo.filename || originalFilename,
                                type: mimeType,
                                size: manifestInfo.size || 0,
                                data: dataUrl,
                                addedAt: manifestInfo.addedAt || new Date().toISOString()
                            };

                            await saveArtifact(artifact);
                            artifactCount++;

                        } catch (artifactError) {
                            console.error('Failed to import artifact:', path, artifactError);
                        }
                    }
                }

                // Load the tree
                capexTree = importedTree;
                saveState('Imported bundle: ' + importedTree.name);
                render();

                showToast(`Imported: "${importedTree.name}" with ${artifactCount} artifacts`, 'success');
                return true;

            } catch (e) {
                console.error('Failed to import bundle:', e);
                showToast('Failed to import bundle: ' + e.message, 'error');
                return false;
            }
        };

        /**
         * Handle file input for .treelisty import
         */
        window.handleBundleFileSelect = async function(event) {
            const file = event.target.files?.[0];
            if (!file) return;

            if (file.name.endsWith('.treelisty') || file.type === 'application/zip') {
                await window.importTreelistyBundle(file);
            } else {
                showToast('Please select a .treelisty file', 'warning');
            }

            // Reset input
            event.target.value = '';
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DRAGGABLE FLOATING PANEL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initDraggablePanel() {
            const panel = document.getElementById('chat-assistant-panel');
            const header = document.getElementById('chat-assistant-header');
            if (!panel || !header) return;

            let isDragging = false;
            let startX, startY;
            let startLeft, startTop;

            header.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on buttons
                if (e.target.tagName === 'BUTTON') return;

                isDragging = true;
                panel.classList.add('dragging');

                // Get current position
                const rect = panel.getBoundingClientRect();
                startX = e.clientX;
                startY = e.clientY;
                startLeft = rect.left;
                startTop = rect.top;

                // Switch from bottom/right to top/left positioning
                panel.style.bottom = 'auto';
                panel.style.right = 'auto';
                panel.style.left = rect.left + 'px';
                panel.style.top = rect.top + 'px';

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                let newLeft = startLeft + dx;
                let newTop = startTop + dy;

                // Keep panel within viewport bounds
                const panelRect = panel.getBoundingClientRect();
                const maxLeft = window.innerWidth - panelRect.width;
                const maxTop = window.innerHeight - panelRect.height;

                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));

                panel.style.left = newLeft + 'px';
                panel.style.top = newTop + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    panel.classList.remove('dragging');
                    savePanelPosition();
                }
            });

            // Touch support for mobile
            header.addEventListener('touchstart', (e) => {
                if (e.target.tagName === 'BUTTON') return;

                isDragging = true;
                panel.classList.add('dragging');

                const touch = e.touches[0];
                const rect = panel.getBoundingClientRect();
                startX = touch.clientX;
                startY = touch.clientY;
                startLeft = rect.left;
                startTop = rect.top;

                panel.style.bottom = 'auto';
                panel.style.right = 'auto';
                panel.style.left = rect.left + 'px';
                panel.style.top = rect.top + 'px';
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;

                const touch = e.touches[0];
                const dx = touch.clientX - startX;
                const dy = touch.clientY - startY;

                let newLeft = startLeft + dx;
                let newTop = startTop + dy;

                const panelRect = panel.getBoundingClientRect();
                const maxLeft = window.innerWidth - panelRect.width;
                const maxTop = window.innerHeight - panelRect.height;

                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));

                panel.style.left = newLeft + 'px';
                panel.style.top = newTop + 'px';
            }, { passive: true });

            document.addEventListener('touchend', () => {
                if (isDragging) {
                    isDragging = false;
                    panel.classList.remove('dragging');
                    savePanelPosition();
                }
            });
        }

        function savePanelPosition() {
            const panel = document.getElementById('chat-assistant-panel');
            if (!panel) return;

            const rect = panel.getBoundingClientRect();
            const position = {
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height
            };
            localStorage.setItem('treebeardPosition', JSON.stringify(position));
        }

        function restorePanelPosition() {
            const panel = document.getElementById('chat-assistant-panel');
            if (!panel) return;

            try {
                const saved = localStorage.getItem('treebeardPosition');
                if (saved) {
                    const position = JSON.parse(saved);

                    // Validate position is within current viewport
                    const maxLeft = window.innerWidth - 320; // min width
                    const maxTop = window.innerHeight - 300; // min height

                    if (position.left >= 0 && position.left <= maxLeft &&
                        position.top >= 0 && position.top <= maxTop) {
                        panel.style.bottom = 'auto';
                        panel.style.right = 'auto';
                        panel.style.left = Math.min(position.left, maxLeft) + 'px';
                        panel.style.top = Math.min(position.top, maxTop) + 'px';

                        if (position.width && position.width >= 320) {
                            panel.style.width = position.width + 'px';
                        }
                        if (position.height && position.height >= 300) {
                            panel.style.height = position.height + 'px';
                        }
                    }
                }
            } catch (e) {
                console.warn('Could not restore TreeBeard position:', e);
            }
        }

        // Initialize when DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initChatAssistant);
        } else {
            initChatAssistant();
        }

        // Expose for debugging
        window.chatAssistant = {
            toggle: toggleChatPanel,
            send: handleSendMessage,
            execute: executeAction,
            state: chatState
        };

    })();
    </script>

    <!-- BUILD 280: Version Check & Auto-Update Notification -->
    <script>
    (function() {
        // BUILD 328: Use global version constant as single source of truth
        const CURRENT_BUILD = window.TREELISTY_VERSION?.build || 0;
        const CHECK_INTERVAL = 30000; // Check 30 seconds after load
        const RECHECK_INTERVAL = 300000; // Then every 5 minutes

        let updateToastShown = false;

        async function checkForUpdates(forceCheck = false) {
            // BUILD 415: Allow manual checks even if toast was shown before
            if (updateToastShown && !forceCheck) return 'skipped';

            try {
                // BUILD 359: Version check - different approaches for different contexts
                const isFileProtocol = window.location.protocol === 'file:';

                if (isFileProtocol) {
                    // For file:// protocol, we can't fetch cross-origin due to CORS
                    // Instead, prompt user to check manually
                    console.log('ğŸ“¦ Running locally - visit https://treelisty.netlify.app to check for updates');
                    // Still show toast if we're significantly behind (hard-coded known version)
                    // This gets updated with each release
                    const KNOWN_LATEST = 616; // Update this with each build
                    if (KNOWN_LATEST > CURRENT_BUILD) {
                        console.log(`ğŸš€ New version likely available: Build ${KNOWN_LATEST}+ (you have ${CURRENT_BUILD})`);
                        showUpdateToast(KNOWN_LATEST);
                        return 'update';
                    }
                    return 'latest';
                }

                // For HTTPS (Netlify), fetch the current page to check version
                const response = await fetch(window.location.pathname + '?_nocache=' + Date.now(), {
                    cache: 'no-store',
                    headers: { 'Cache-Control': 'no-cache' }
                });

                if (!response.ok) return 'error';

                const html = await response.text();

                // Extract build number from header comment: "Build XXX"
                const match = html.match(/TreeListy v[\d.]+ \| Build (\d+)/);
                if (!match) return 'error';

                const latestBuild = parseInt(match[1]);

                if (latestBuild > CURRENT_BUILD) {
                    console.log(`ğŸš€ New version available: Build ${latestBuild} (current: ${CURRENT_BUILD})`);
                    showUpdateToast(latestBuild);
                    return 'update';
                } else {
                    console.log(`âœ… Running latest version: Build ${CURRENT_BUILD}`);
                    return 'latest';
                }
            } catch (e) {
                console.warn('Version check failed:', e);
                return 'error';
            }
        }

        function showUpdateToast(newBuild) {
            updateToastShown = true;

            // Create update toast
            const toast = document.createElement('div');
            toast.id = 'update-toast';
            toast.style.cssText = `
                position: fixed;
                bottom: 80px;
                right: 20px;
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
                padding: 16px 20px;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(16, 185, 129, 0.4);
                z-index: 10001;
                font-family: inherit;
                animation: slideInRight 0.3s ease-out;
                max-width: 300px;
            `;

            toast.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <div style="font-size: 24px;">ğŸš€</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 700; font-size: 14px; margin-bottom: 4px;">
                            New Version Available!
                        </div>
                        <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">
                            Build ${newBuild} is ready (you have Build ${CURRENT_BUILD})
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="window.forceUpdateApp()" style="
                                padding: 8px 16px;
                                background: white;
                                color: #059669;
                                border: none;
                                border-radius: 6px;
                                font-weight: 700;
                                font-size: 12px;
                                cursor: pointer;
                            ">Update Now</button>
                            <button onclick="this.closest('#update-toast').remove()" style="
                                padding: 8px 12px;
                                background: rgba(255,255,255,0.2);
                                color: white;
                                border: none;
                                border-radius: 6px;
                                font-size: 12px;
                                cursor: pointer;
                            ">Later</button>
                        </div>
                    </div>
                    <button onclick="this.closest('#update-toast').remove()" style="
                        background: none;
                        border: none;
                        color: white;
                        opacity: 0.7;
                        cursor: pointer;
                        font-size: 16px;
                        padding: 0;
                    ">&times;</button>
                </div>
            `;

            // Add animation keyframes if not exists
            if (!document.getElementById('update-toast-styles')) {
                const style = document.createElement('style');
                style.id = 'update-toast-styles';
                style.textContent = `
                    @keyframes slideInRight {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(toast);
        }

        // Force update - bypass all caches while preserving tree state
        window.forceUpdateApp = function() {
            // BUILD 329: Save current tree state before refresh
            try {
                if (window.capexTree) {
                    // Capture current view state
                    const viewState = {
                        viewMode: typeof viewMode !== 'undefined' ? viewMode : 'tree',
                        treeZoom: typeof zoomLevel !== 'undefined' ? zoomLevel : 1,
                        treePanX: typeof panX !== 'undefined' ? panX : 0,
                        treePanY: typeof panY !== 'undefined' ? panY : 0,
                        canvasZoom: typeof canvasZoom !== 'undefined' ? canvasZoom : 1,
                        canvasPanX: typeof canvasPan !== 'undefined' ? canvasPan.x : 0,
                        canvasPanY: typeof canvasPan !== 'undefined' ? canvasPan.y : 0
                    };
                    window.capexTree.viewState = viewState;

                    // Save tree + state for restore after update
                    const updateState = {
                        tree: window.capexTree,
                        pattern: typeof currentPattern !== 'undefined' ? currentPattern : 'generic',
                        roomId: window.firebaseSyncState?.roomId || null,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('treelisty:pending-update', JSON.stringify(updateState));
                    console.log('ğŸ’¾ Saved tree state for update restore');
                }
            } catch (e) {
                console.warn('âš ï¸ Could not save tree state before update:', e);
            }

            // Clear service worker cache if exists
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => caches.delete(name));
                });
            }

            // Unregister service workers
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    registrations.forEach(reg => reg.unregister());
                });
            }

            // Navigate with cache-busting parameter
            const url = new URL(window.location.href);
            url.searchParams.set('_v', Date.now());
            window.location.href = url.toString();
        };

        // Manual check function (can be called from console)
        window.checkForUpdates = checkForUpdates;

        // Initial check after page loads
        setTimeout(checkForUpdates, CHECK_INTERVAL);

        // Periodic rechecks
        setInterval(checkForUpdates, RECHECK_INTERVAL);

        console.log(`ğŸ”„ Version checker active (Build ${CURRENT_BUILD})`);
    })();
    </script>

    <!-- Canvas View Container -->
    <div class="canvas-container" id="canvas-container">
        <!-- Canvas Toolbar -->
        <div class="canvas-toolbar" id="canvas-toolbar" style="position: fixed; top: 120px; left: 50%; transform: translateX(-50%); z-index: 200; display: none; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(20, 20, 30, 0.98); backdrop-filter: blur(10px); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.4);">
            <select id="auto-layout-select" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.15); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 8px; color: #ffffff; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                <option value="" style="background: #1a1a2e; color: #ffffff;">ğŸ“ Auto-Layout</option>
                <option value="hierarchical" style="background: #1a1a2e; color: #ffffff;">ğŸŒ³ Hierarchical</option>
                <option value="timeline" style="background: #1a1a2e; color: #ffffff;">ğŸ“… Timeline</option>
                <option value="force" style="background: #1a1a2e; color: #ffffff;">ğŸŒ€ Force-Directed</option>
                <option value="radial" style="background: #1a1a2e; color: #ffffff;">â­• Radial</option>
                <option value="grid" style="background: #1a1a2e; color: #ffffff;">âŠ Grid</option>
            </select>
            <select id="cluster-by-select" style="padding: 8px 14px; background: rgba(34, 197, 94, 0.15); border: 1px solid rgba(34, 197, 94, 0.4); border-radius: 8px; color: #ffffff; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                <!-- Options populated dynamically by updateClusterByOptions() -->
            </select>
            <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
            <button id="grid-toggle" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                â—« Grid
            </button>
            <button id="reset-view" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                ğŸ¯ Reset
            </button>
            <button id="fit-view" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                âŠ¡ Fit
            </button>
            <button id="hyperedge-panel-btn" onclick="toggleHyperedgePanel()" class="btn" style="padding: 8px 14px; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 8px; color: #A78BFA; font-size: 13px; transition: all 0.2s;" title="Manage hyperedge visibility">
                ğŸ”— Edges
            </button>
            <button id="critical-path-toggle" onclick="toggleCriticalPath()" class="btn" style="padding: 8px 14px; background: rgba(255, 0, 0, 0.1); border: 1px solid rgba(255, 0, 0, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;" title="Highlight critical path dependencies">
                âš¡ Critical Path
            </button>
            <!-- BUILD 510: Dependency display controls -->
            <button id="deps-toggle" onclick="toggleDependencyDisplay()" class="btn" style="padding: 8px 14px; background: rgba(255, 107, 107, 0.3); border: 1px solid #ff6b6b; border-radius: 8px; color: #ff6b6b; font-size: 13px; transition: all 0.2s;" title="Toggle dependency lines on/off">
                ğŸ”— Deps: On
            </button>
            <button id="deps-filter-toggle" onclick="toggleDepsSelectedOnly()" class="btn" style="padding: 8px 14px; background: rgba(34, 197, 94, 0.2); border: 1px solid rgba(34, 197, 94, 0.5); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;" title="Show deps for selected node only, or all">
                ğŸ‘ Selected
            </button>
            <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
            <div style="display: flex; align-items: center; gap: 6px;">
                <button id="zoom-out" class="btn" style="padding: 6px 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: var(--text-primary); font-weight: 600; transition: all 0.2s;">âˆ’</button>
                <span id="zoom-level" style="font-size: 12px; font-weight: 600; color: var(--treeplex-primary); min-width: 50px; text-align: center;">100%</span>
                <button id="zoom-in" class="btn" style="padding: 6px 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: var(--text-primary); font-weight: 600; transition: all 0.2s;">+</button>
            </div>
            <!-- BUILD 565: Image Analysis Controls (hidden by default, shown when _imageAnalysis exists) -->
            <div id="image-analysis-controls" style="display: none; align-items: center; gap: 6px; margin-left: 8px; padding-left: 8px; border-left: 1px solid rgba(99, 102, 241, 0.2);">
                <button id="bg-image-toggle" onclick="toggleBackgroundImage()" class="btn" style="padding: 6px 12px; background: rgba(59, 130, 246, 0.2); border: 1px solid rgba(59, 130, 246, 0.4); border-radius: 6px; color: #60A5FA; font-size: 12px; transition: all 0.2s;" title="Toggle background image">
                    ğŸ–¼ï¸
                </button>
                <input type="range" id="bg-opacity-slider" min="10" max="80" value="40"
                       onchange="setBackgroundOpacity(this.value / 100)"
                       style="width: 60px; height: 4px; cursor: pointer;"
                       title="Background opacity">
                <button id="bbox-toggle" onclick="toggleBoundingBoxOverlays()" class="btn" style="padding: 6px 12px; background: rgba(34, 197, 94, 0.2); border: 1px solid rgba(34, 197, 94, 0.4); border-radius: 6px; color: #22C55E; font-size: 12px; transition: all 0.2s;" title="Toggle bounding boxes">
                    ğŸ“¦
                </button>
                <!-- BUILD 567: Bbox Filter Controls -->
                <select id="bbox-type-filter" onchange="filterBboxByType(this.value)" style="padding: 4px 8px; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 6px; color: #A78BFA; font-size: 11px; cursor: pointer;" title="Filter by object type">
                    <option value="">All Types</option>
                </select>
                <select id="bbox-confidence-filter" onchange="filterBboxByConfidence(this.value)" style="padding: 4px 8px; background: rgba(245, 158, 11, 0.15); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 6px; color: #F59E0B; font-size: 11px; cursor: pointer;" title="Filter by confidence">
                    <option value="0">All Confidence</option>
                    <option value="0.5">â‰¥50%</option>
                    <option value="0.7">â‰¥70%</option>
                    <option value="0.9">â‰¥90%</option>
                </select>
            </div>
        </div>

        <!-- Selection Counter -->
        <div id="selection-counter" style="display: none; position: fixed; top: 200px; left: 50%; transform: translateX(-50%); background: rgba(99, 102, 241, 0.95); color: white; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: 600; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px);">
            <span id="selection-count">0</span> nodes selected
        </div>

        <!-- BUILD 435: Canvas Search Overlay (Ctrl+F) -->
        <div id="canvas-search-overlay" class="canvas-search-overlay" style="display: none;">
            <div class="canvas-search-box">
                <input type="text" id="canvas-search-input" placeholder="Search nodes... (Esc to close)" autocomplete="off">
                <span id="canvas-search-count" class="canvas-search-count"></span>
                <button id="canvas-search-prev" class="canvas-search-nav" title="Previous (Shift+Enter)">â–²</button>
                <button id="canvas-search-next" class="canvas-search-nav" title="Next (Enter)">â–¼</button>
                <button id="canvas-search-close" class="canvas-search-close" title="Close (Esc)">âœ•</button>
            </div>
            <div id="canvas-search-results" class="canvas-search-results"></div>
        </div>

        <!-- BUILD 435: Canvas Minimap -->
        <div id="canvas-minimap" class="canvas-minimap">
            <canvas id="minimap-canvas" width="200" height="150"></canvas>
            <div id="minimap-viewport" class="minimap-viewport"></div>
        </div>

        <div id="canvas">
            <!-- Grid Pattern -->
            <svg class="canvas-grid" id="canvas-grid" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; opacity: 0;">
                <defs>
                    <pattern id="grid-pattern" width="40" height="40" patternUnits="userSpaceOnUse">
                        <path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(99, 102, 241, 0.15)" stroke-width="1"/>
                    </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid-pattern)" />
            </svg>

            <!-- BUILD 565: Background Image Layer for Image Analysis -->
            <div id="canvas-background-image" style="
                position: absolute;
                top: 0;
                left: 0;
                pointer-events: none;
                z-index: 1;
                opacity: 0.4;
                display: none;
                transition: opacity 0.3s ease;
            ">
                <img id="canvas-bg-img" style="max-width: none; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);" />
            </div>

            <!-- BUILD 565: Bounding Box Overlay Layer for Image Analysis -->
            <svg id="canvas-bboxes" style="
                position: absolute;
                width: 20000px;
                height: 20000px;
                left: -5000px;
                top: -5000px;
                pointer-events: none;
                z-index: 2;
            "></svg>

            <svg class="canvas-connections" id="canvas-connections"></svg>
        </div>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         CHAT ASSISTANT BUBBLE & PANEL
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

    <!-- BUILD 370: Voice Capture FAB (Floating Action Button) - Mobile only -->
    <button id="voice-capture-fab" title="Voice Capture">
        ğŸ¤
        <span class="fab-badge" style="display: none;">0</span>
    </button>

    <!-- Floating Chat Bubble -->
    <button id="chat-assistant-bubble" title="TreeBeard (Ctrl+/)">
        ğŸ’¬
    </button>

    <!-- Chat Panel - Draggable Floating Frame -->
    <div id="chat-assistant-panel">
        <div id="chat-assistant-header">
            <h3>ğŸŒ³ TreeBeard</h3>
            <!-- BUILD 368: Conversation mode indicator -->
            <span id="conversation-mode-indicator" style="display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; background: rgba(99, 102, 241, 0.2); border-radius: 12px; font-size: 10px; color: #a5b4fc; cursor: pointer;" onclick="window.toggleConversationMode()" title="âš¡ QUICK MODE: Fast commands (find, add, navigate)&#10;Click to switch to Deep Mode for analysis">âš¡ Quick</span>
            <!-- BUILD 366: Biographer mode indicator for LifeTree -->
            <span id="biographer-mode-indicator" style="display: none; align-items: center; gap: 4px; padding: 3px 8px; background: rgba(99, 102, 241, 0.2); border-radius: 12px; font-size: 10px; color: #a5b4fc; cursor: pointer;" onclick="window.cycleBiographerMode()" title="Click to change mode"></span>
            <div class="header-actions">
                <button id="chat-clear-btn" title="Clear conversation">ğŸ—‘ï¸</button>
                <button id="chat-close-btn" title="Close">âœ•</button>
            </div>
        </div>

        <!-- BUILD 370: Voice Recording UI -->
        <div id="voice-recording-ui">
            <div class="recording-status">
                <div class="recording-dot"></div>
                <span class="recording-duration">0:00</span>
            </div>
            <div class="live-transcript-area">
                <span class="live-transcript-placeholder">Start speaking... your words will appear here</span>
                <span class="final"></span>
                <span class="interim"></span>
            </div>
            <div class="recording-controls">
                <button class="recording-stop-btn" onclick="window.stopVoiceCapture()">âœ“ Done</button>
                <button class="recording-cancel-btn" onclick="window.cancelVoiceCapture()">Cancel</button>
            </div>
            <div class="recording-warning">Recording for over 5 minutes. Tap "Done" when ready.</div>
        </div>

        <!-- BUILD 370: Voice Captures Section -->
        <div id="voice-captures-section" style="display: none;">
            <div class="captures-header" onclick="window.toggleCapturesSection()">
                <h4>ğŸ“ Captures <span class="capture-count">0</span></h4>
                <span class="toggle-icon">â–¼</span>
            </div>
            <div class="captures-list">
                <!-- Captures populated dynamically -->
            </div>
        </div>

        <!-- BUILD 370: Capture Processing Prompt (shown when processing a capture) -->
        <div id="capture-processing-prompt" class="capture-processing-prompt" style="display: none;">
            <div class="prompt-header">ğŸ“ Voice Capture</div>
            <div class="transcript-preview"></div>
            <div class="quick-actions">
                <button class="quick-action" data-action="add-to-tree">Add to tree</button>
                <button class="quick-action" data-action="new-branch">New branch</button>
                <button class="quick-action" data-action="save-as-note">Save as note</button>
                <button class="quick-action" data-action="psych-analysis">ğŸ§  Psychological analysis</button>
            </div>
            <div class="instruction-hint">Or type your own instruction below...</div>
        </div>

        <div id="chat-assistant-messages">
            <!-- Welcome message -->
            <div class="chat-message assistant">
                How can I help? Try:
                <div class="action-buttons" style="margin-top: 6px;">
                    <button class="action-btn" data-action="help">ğŸ“– Features</button>
                    <button class="action-btn" data-action="create">ğŸŒ³ New tree</button>
                    <button class="action-btn" data-action="enhance">âœ¨ Enhance</button>
                    <button class="action-btn" data-action="query">ğŸ” Query</button>
                </div>
            </div>
        </div>

        <div id="chat-assistant-input-area">
            <textarea id="chat-assistant-input" placeholder="Ask anything or give a command..." rows="1"></textarea>
            <button id="chat-voice-btn" title="Voice capture" onclick="window.startVoiceCapture()">ğŸ¤</button>
            <button id="chat-send-btn" title="Send message">â¤</button>
        </div>
    </div>

    <!-- BUILD 393: Floating Command Frame (New Chat UI) -->
    <div id="command-frame">
        <!-- Compact Header with Mode Toggle -->
        <div class="command-frame-header">
            <span class="frame-icon">ğŸŒ³</span>
            <span class="frame-title">TreeBeard</span>
            <div class="mode-pills">
                <button class="mode-pill active" data-mode="quick" title="Quick Commands">âš¡ Quick</button>
                <button class="mode-pill" data-mode="deep" title="Deep Conversation">ğŸ§  Deep</button>
            </div>
            <button class="frame-minimize" title="Minimize" onclick="minimizeCommandFrame()">âˆ’</button>
            <button class="frame-close" title="Close" onclick="toggleCommandFrame()">âœ•</button>
        </div>

        <!-- Context Bar - Shows current selection/focus -->
        <div class="command-context-bar no-focus">
            <span class="context-icon">ğŸ“</span>
            <span class="context-text">No node focused â€” use Find or click a node</span>
            <button class="context-action" data-action="show_info" title="Show Details" style="display: none;">â„¹ï¸</button>
        </div>

        <!-- Action Button Grid - Always Visible -->
        <div class="command-actions">
            <div class="action-row primary-actions">
                <button class="cmd-btn" data-action="prompt_find"><span class="btn-icon">ğŸ”</span><span class="btn-label">Find</span></button>
                <button class="cmd-btn" data-action="prompt_add"><span class="btn-icon">â•</span><span class="btn-label">Add</span></button>
                <button class="cmd-btn" data-action="ai_enhance"><span class="btn-icon">âœ¨</span><span class="btn-label">Enhance</span></button>
                <button class="cmd-btn" data-action="show_help"><span class="btn-icon">ğŸ“–</span><span class="btn-label">Help</span></button>
            </div>
            <div class="action-row secondary-actions collapsed">
                <!-- Populated dynamically based on context -->
            </div>
        </div>

        <!-- Input Area -->
        <div class="command-input-area">
            <input type="text" id="command-input" placeholder="Type command or question..." autocomplete="off">
            <button id="command-voice-btn" class="command-btn" title="Voice" onclick="window.startVoiceCapture()">ğŸ¤</button>
            <button id="command-send-btn" class="command-btn primary" title="Send" onclick="handleCommandSend()">â¤</button>
        </div>

        <!-- Collapsible Message History -->
        <div class="command-history collapsed">
            <div class="history-toggle" onclick="toggleCommandHistory()">
                <span>ğŸ’¬ History</span>
                <span class="toggle-icon">â–¼</span>
            </div>
            <div class="history-messages">
                <!-- Messages populated dynamically -->
            </div>
        </div>
    </div>

    <!-- BUILD 393: Visual Feedback Overlay -->
    <div id="tree-feedback-overlay" class="feedback-overlay"></div>

    <!-- BUILD 405: Live Tree Agent Frame (Chat Builder Redesign) -->
    <!-- BUILD 416: Removed inline display:none - CSS handles visibility via .open class -->
    <div id="tree-agent-frame" class="tree-agent">
        <div class="agent-header">
            <div class="agent-title-row">
                <span class="agent-icon">ğŸ¤–</span>
                <span class="agent-title" id="agent-title">Building Tree...</span>
            </div>
            <div class="agent-progress-row">
                <div class="agent-progress-bar">
                    <div class="agent-progress-fill" id="agent-progress-fill" style="width: 0%;"></div>
                </div>
                <span class="agent-progress-text" id="agent-progress-text">0%</span>
            </div>
            <div class="agent-header-actions">
                <button class="agent-btn" id="agent-minimize-btn" title="Minimize">âˆ’</button>
                <button class="agent-btn" id="agent-close-btn" title="Close">âœ•</button>
            </div>
        </div>
        <div class="agent-body" id="agent-body">
            <div class="agent-messages" id="agent-messages">
                <!-- Chat messages populated dynamically -->
            </div>
            <div class="agent-input-row">
                <input type="text" id="agent-input" placeholder="Type or click a choice..." autocomplete="off">
                <button class="agent-input-btn" id="agent-voice-btn" title="Voice input">ğŸ¤</button>
                <button class="agent-input-btn primary" id="agent-send-btn" title="Send">â¤</button>
            </div>
            <div class="agent-footer">
                <button class="agent-action-btn" id="agent-cancel-btn">Cancel</button>
                <button class="agent-action-btn primary" id="agent-finish-btn">âœ… Finish & Apply</button>
            </div>
        </div>
    </div>

    <!-- BUILD 427: Debate Mode Panel -->
    <div id="debate-panel" class="debate-panel">
        <div class="debate-header">
            <div class="debate-title-row">
                <span class="debate-icon">ğŸ­</span>
                <span class="debate-title" id="debate-title">Debate: Topic</span>
            </div>
            <div class="debate-turn-info">
                <span id="debate-turn-counter">Turn 0</span>
            </div>
            <div class="debate-header-actions">
                <button class="debate-btn" id="debate-minimize-btn" title="Minimize">âˆ’</button>
                <button class="debate-btn" id="debate-close-btn" title="Close">âœ•</button>
            </div>
        </div>
        <div class="debate-body" id="debate-body">
            <div class="debate-transcript" id="debate-transcript">
                <!-- Debate turns populated dynamically -->
            </div>
            <div class="debate-input-row">
                <input type="text" id="debate-interject-input" placeholder="Interject in the debate..." autocomplete="off">
                <button class="debate-input-btn" id="debate-interject-btn" title="Send">ğŸ’¬</button>
            </div>
            <div class="debate-footer">
                <div class="debate-footer-left">
                    <button class="debate-action-btn" id="debate-next-turn-btn">â–¶ï¸ Next Turn</button>
                    <label class="debate-autoplay-toggle">
                        <input type="checkbox" id="debate-autoplay">
                        <span>Auto-play</span>
                    </label>
                </div>
                <button class="debate-action-btn primary" id="debate-end-btn">âœ… End & Extract</button>
            </div>
        </div>
    </div>

    <!-- Debate Setup Modal (Build 430: Defender vs Challenger) -->
    <div id="debate-setup-modal" class="debate-setup-modal">
        <div class="debate-setup-content">
            <h3>âš”ï¸ Start Debate</h3>
            <div class="debate-topic-display" id="debate-topic-display"></div>
            <div style="font-size: 12px; color: var(--text-secondary); margin: -8px 0 12px 0; text-align: center;">
                One side defends, one side challenges
            </div>

            <div class="debate-persona-row">
                <div class="debate-persona-select">
                    <label>ğŸ›¡ï¸ Defender Style</label>
                    <select id="debate-persona-a">
                        <option value="scholarly">ğŸ“š Scholar</option>
                        <option value="socratic">ğŸ›ï¸ Socratic</option>
                        <option value="passionate">ğŸ”¥ Passionate</option>
                        <option value="pragmatic">âš–ï¸ Pragmatist</option>
                    </select>
                </div>
                <span class="debate-vs">VS</span>
                <div class="debate-persona-select">
                    <label>âš”ï¸ Challenger Style</label>
                    <select id="debate-persona-b">
                        <option value="socratic">ğŸ›ï¸ Socratic</option>
                        <option value="scholarly">ğŸ“š Scholar</option>
                        <option value="passionate">ğŸ”¥ Passionate</option>
                        <option value="pragmatic">âš–ï¸ Pragmatist</option>
                    </select>
                </div>
            </div>

            <div class="debate-rounds-row">
                <label>Rounds:</label>
                <select id="debate-rounds">
                    <option value="3">3 rounds</option>
                    <option value="5" selected>5 rounds</option>
                    <option value="10">10 rounds</option>
                    <option value="0">Unlimited</option>
                </select>
            </div>

            <div class="debate-setup-actions">
                <button id="debate-cancel-setup">Cancel</button>
                <button id="debate-start-btn" class="primary">Start Debate</button>
            </div>
        </div>
    </div>

    <!-- BUILD 371: Artifact Side Panel -->
    <div id="artifact-panel">
        <div class="panel-header">
            <div>
                <h3>ğŸ“ Attachments</h3>
                <div class="item-name" id="artifact-panel-item-name"></div>
            </div>
            <button class="panel-close" onclick="window.closeArtifactPanel()">âœ•</button>
        </div>
        <div class="panel-content">
            <div class="artifact-drop-zone" id="artifact-drop-zone">
                <div class="drop-icon">ğŸ“</div>
                <div class="drop-text">Drop files here</div>
                <div class="drop-hint">or click to browse</div>
                <input type="file" id="artifact-file-input" multiple style="display: none;" accept="image/*,audio/*,.pdf,.doc,.docx,.txt,.md">
            </div>
            <div class="artifact-list" id="artifact-list">
                <!-- Artifacts populated dynamically -->
            </div>
            <div class="artifact-empty" id="artifact-empty" style="display: none;">
                <div class="empty-icon">ğŸ“</div>
                <div>No attachments yet</div>
            </div>
        </div>
    </div>

<!-- =============================================================================
     BUILD 286: 3D VIEW - Experimental Three.js Helix Visualization (PoC)
     - Non-destructive: Isolated alongside existing 2D views
     - Uses ES Modules to load Three.js from CDN
     - Toggle with "3D View" button in toolbar
============================================================================= -->

<style>
    /* 3D Viewport Container */
    #view-3d {
        position: fixed;
        top: 60px; /* Below header */
        left: 0;
        width: 100vw;
        height: calc(100vh - 60px);
        background: radial-gradient(circle at center, #1a1d24 0%, #000000 100%);
        z-index: 50; /* Above tree, below modals */
        display: none; /* Hidden by default */
        overflow: hidden;
    }

    #view-3d.active {
        display: block;
    }

    /* 3D Floating Nodes (HTML Overlay) */
    .node-3d-label {
        font-family: 'Inter', sans-serif;
        padding: 12px 16px;
        background: rgba(20, 20, 30, 0.75);
        backdrop-filter: blur(6px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-left: 4px solid var(--node-color, #6366f1);
        border-radius: 8px;
        color: #fff;
        font-size: 12px;
        width: 220px;
        box-shadow: 0 0 15px rgba(0,0,0,0.5);
        transition: all 0.3s ease;
        pointer-events: auto; /* Allow clicking */
        cursor: pointer;
        user-select: none;
    }

    .node-3d-label:hover {
        transform: scale(1.1);
        background: rgba(40, 40, 55, 0.9);
        box-shadow: 0 0 25px var(--node-color, #6366f1);
        z-index: 100;
    }

    .node-3d-title {
        font-weight: 700;
        font-size: 14px;
        margin-bottom: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .node-3d-meta {
        font-size: 10px;
        opacity: 0.7;
        display: flex;
        justify-content: space-between;
    }

    /* 3D Toolbar Overlay */
    #controls-3d {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 12px;
        background: rgba(0,0,0,0.5);
        padding: 10px;
        border-radius: 20px;
        border: 1px solid rgba(255,255,255,0.1);
        pointer-events: auto;
    }

    /* Floating Tree Title - Screenshot Ready */
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap');

    #title-3d {
        position: absolute;
        top: 30px;
        left: 80px; /* More margin to avoid panel overlap */
        pointer-events: none;
        z-index: 100;
    }

    #title-3d-name {
        font-family: 'Orbitron', 'Inter', sans-serif;
        font-size: 48px;
        font-weight: 900;
        color: #00ffff;
        text-shadow:
            0 0 10px rgba(0, 255, 255, 0.8),
            0 0 30px rgba(0, 255, 255, 0.6),
            0 0 60px rgba(0, 255, 255, 0.4),
            0 0 100px rgba(0, 255, 255, 0.2),
            0 4px 8px rgba(0, 0, 0, 0.9);
        letter-spacing: 4px;
        text-transform: uppercase;
        margin: 0;
        line-height: 1.1;
    }

    #title-3d-pattern {
        display: none; /* Hidden for cleaner look */
    }

    /* Hover Tooltip */
    #hover-tooltip-3d {
        position: absolute;
        background: rgba(10, 15, 30, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 255, 255, 0.4);
        border-radius: 10px;
        padding: 12px 16px;
        min-width: 180px;
        max-width: 280px;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3),
                    0 8px 32px rgba(0, 0, 0, 0.6);
        z-index: 200;
        display: none;
        pointer-events: none;
        transform: translate(-50%, -100%) translateY(-15px);
    }

    #hover-tooltip-3d.visible {
        display: block;
    }

    #hover-tooltip-name {
        font-family: 'Orbitron', sans-serif;
        font-size: 14px;
        font-weight: 700;
        color: #00ffff;
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    #hover-tooltip-type {
        font-size: 10px;
        color: rgba(255, 255, 255, 0.5);
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 6px;
    }

    #hover-tooltip-desc {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
        line-height: 1.4;
        max-height: 60px;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* 3D Context Menu */
    #context-menu-3d {
        position: absolute;
        background: rgba(20, 20, 35, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 150, 255, 0.3);
        border-radius: 12px;
        padding: 8px 0;
        min-width: 200px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5),
                    0 0 20px rgba(100, 150, 255, 0.2);
        z-index: 1000;
        display: none;
        pointer-events: auto;
    }

    #context-menu-3d.visible {
        display: block;
    }

    .context-menu-3d-item {
        padding: 10px 16px;
        color: #fff;
        font-size: 13px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.15s;
    }

    .context-menu-3d-item:hover {
        background: rgba(100, 150, 255, 0.2);
    }

    .context-menu-3d-item.danger:hover {
        background: rgba(255, 100, 100, 0.2);
    }

    .context-menu-3d-divider {
        height: 1px;
        background: rgba(255, 255, 255, 0.1);
        margin: 6px 0;
    }

    .context-menu-3d-header {
        padding: 8px 16px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.4);
        text-transform: uppercase;
        letter-spacing: 1px;
    }
</style>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     BUILD 457: GANTT VIEW CONTAINER
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<style>
    /* Gantt View Container */
    #view-gantt {
        display: none;
        position: fixed;
        top: 140px;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        overflow: hidden;
        z-index: 100;
    }

    #view-gantt.active {
        display: block;
    }

    /* Gantt Toolbar */
    #gantt-toolbar {
        position: fixed;
        top: 120px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 200;
        display: none;
        align-items: center;
        gap: 8px;
        padding: 10px 16px;
        background: rgba(20, 20, 30, 0.98);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(99, 102, 241, 0.3);
        border-radius: 16px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    #gantt-toolbar.active {
        display: flex;
    }

    /* Gantt Chart Wrapper */
    #gantt-chart-wrapper {
        width: 100%;
        height: calc(100% - 20px);
        overflow: auto;
        padding: 10px;
        cursor: grab;
    }
    #gantt-chart-wrapper:active {
        cursor: grabbing;
    }
    /* BUILD 473: Ensure SVG handles zoom correctly */
    #gantt-chart-wrapper svg {
        transition: transform 0.15s ease-out;
    }

    /* BUILD 474: Gantt Minimap (BUILD 475: Fixed position to avoid sidebar) */
    .gantt-minimap {
        position: absolute;
        bottom: 20px;
        left: 70px;  /* Offset to avoid sidebar overlap */
        width: 250px;
        height: 100px;
        background: rgba(20, 20, 30, 0.95);
        border: 2px solid rgba(99, 102, 241, 0.3);
        border-radius: 8px;
        overflow: hidden;
        z-index: 200;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        transition: border-color 0.2s;
        display: none;
    }
    #view-gantt.active .gantt-minimap {
        display: block;
    }
    .gantt-minimap:hover {
        border-color: rgba(99, 102, 241, 0.5);
    }
    #gantt-minimap-canvas {
        width: 100%;
        height: 100%;
    }
    .gantt-minimap-viewport {
        position: absolute;
        border: 2px solid rgba(99, 102, 241, 0.8);
        background: rgba(99, 102, 241, 0.15);
        pointer-events: auto;
        cursor: grab;
        transition: all 0.1s ease;
    }
    .gantt-minimap-viewport:active,
    .gantt-minimap-viewport.dragging {
        cursor: grabbing;
        border-color: rgba(99, 102, 241, 1);
        background: rgba(99, 102, 241, 0.25);
    }
    @media (max-width: 768px) {
        .gantt-minimap {
            display: none !important;
        }
    }

    /* Empty State */
    #gantt-empty-state {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        padding: 40px;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
        border: 2px solid rgba(99, 102, 241, 0.3);
        border-radius: 16px;
        max-width: 500px;
    }

    /* Frappe Gantt Dark Theme Overrides */
    .gantt .grid-header {
        fill: var(--card-bg);
    }
    .gantt .grid-row {
        fill: var(--bg);
    }
    .gantt .grid-row:nth-child(even) {
        fill: rgba(99, 102, 241, 0.05);
    }
    .gantt .bar {
        fill: var(--treeplex-primary);
        transition: filter 0.2s, stroke 0.2s;
    }
    /* BUILD 475: Selected bar highlight */
    .gantt .bar-wrapper.selected .bar {
        stroke: #FFD700;
        stroke-width: 3px;
        filter: brightness(1.2) drop-shadow(0 0 8px rgba(255, 215, 0, 0.6));
    }
    /* BUILD 475: Alternating bar shades for better distinction */
    .gantt .bar-wrapper:nth-child(odd) .bar {
        fill: rgba(99, 102, 241, 0.9);
    }
    .gantt .bar-wrapper:nth-child(even) .bar {
        fill: rgba(139, 92, 246, 0.85);
    }
    .gantt .bar-label {
        fill: white;
        font-family: 'Inter', sans-serif;
        font-weight: 600;
        font-size: 13px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    /* BUILD 470: Fix Gantt date labels - white text on dark background */
    .gantt .lower-text {
        fill: #ffffff;
        font-family: 'Inter', sans-serif;
        font-size: 12px;
    }
    .gantt .upper-text {
        fill: #a0a0a0;
        font-family: 'Inter', sans-serif;
        font-size: 12px;
        font-weight: 600;
    }
    .gantt text {
        fill: #ffffff;
    }
    .gantt .tick {
        stroke: rgba(99, 102, 241, 0.2);
    }
    .gantt .tick.thick {
        stroke: rgba(99, 102, 241, 0.4);
    }
    .gantt .row-line {
        stroke: rgba(99, 102, 241, 0.1);
    }
    .gantt .bar-progress {
        fill: #4f46e5;
    }
    /* BUILD 478: Frappe Gantt applies custom_class to .bar-wrapper, not .bar */
    .gantt .bar-wrapper.critical .bar {
        fill: #ff0000 !important;
    }
    .gantt .bar-wrapper.critical .bar-progress {
        fill: #cc0000 !important;
    }
    .gantt .bar-wrapper.critical .bar-label {
        fill: #ffffff !important;
        font-weight: bold;
    }
    .gantt .arrow {
        stroke: var(--treeplex-primary);
        stroke-width: 1.5;
    }
    .gantt .today-highlight {
        fill: rgba(99, 102, 241, 0.2);
    }
    .gantt-container .popup-wrapper {
        background: var(--card-bg) !important;
        border: 1px solid var(--border) !important;
        border-radius: 8px !important;
        box-shadow: 0 8px 24px rgba(0,0,0,0.4) !important;
        padding: 12px !important;
        z-index: 1000 !important;
    }
    .gantt-container .popup-wrapper .title {
        color: #ffffff !important;
        font-size: 14px !important;
        font-weight: 600 !important;
        margin-bottom: 4px !important;
    }
    .gantt-container .popup-wrapper .subtitle {
        color: #a0a0a0 !important;
        font-size: 12px !important;
    }
    /* BUILD 475: Hover effect on bars */
    .gantt .bar-wrapper:hover .bar {
        filter: brightness(1.15);
        cursor: pointer;
    }
    .gantt .bar-wrapper:hover .bar-label {
        font-weight: 700;
    }
    /* BUILD 475: Custom Gantt tooltip */
    #gantt-tooltip {
        position: fixed;
        z-index: 10000;
        background: rgba(20, 20, 35, 0.98);
        border: 2px solid rgba(99, 102, 241, 0.4);
        border-radius: 10px;
        padding: 14px 16px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.15s ease;
        max-width: 280px;
        backdrop-filter: blur(8px);
    }
    #gantt-tooltip.visible {
        opacity: 1;
    }
    #gantt-tooltip .tooltip-title {
        font-size: 15px;
        font-weight: 700;
        color: #ffffff;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(99, 102, 241, 0.3);
    }
    #gantt-tooltip .tooltip-row {
        display: flex;
        gap: 8px;
        font-size: 13px;
        color: #d1d5db;
        margin-bottom: 6px;
    }
    #gantt-tooltip .tooltip-row:last-child {
        margin-bottom: 0;
    }
    #gantt-tooltip .tooltip-hint {
        margin-top: 10px;
        font-size: 11px;
        color: #6B7280;
        font-style: italic;
    }
</style>

<!-- BUILD 475: Custom Gantt Tooltip -->
<div id="gantt-tooltip">
    <div class="tooltip-title"></div>
    <div class="tooltip-content"></div>
    <div class="tooltip-hint">Click for full details</div>
</div>

<div id="view-gantt">
    <!-- Empty State (shown when no schedule data) -->
    <div id="gantt-empty-state">
        <div style="font-size: 48px; margin-bottom: 16px;">ğŸ“Š</div>
        <h2 style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">Gantt View</h2>
        <p style="font-size: 14px; color: var(--text-secondary); margin-bottom: 24px; line-height: 1.6;">
            This tree has no items with start/due dates.<br>
            Import an MS Project XML file or add schedule data to nodes.
        </p>
        <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
            <button class="btn" id="gantt-import-xml-btn" style="background: linear-gradient(135deg, #8b5cf6, #6366f1); padding: 12px 24px; font-size: 15px; font-weight: 600; color: white; border-radius: 8px; border: none; cursor: pointer;">
                ğŸ“¥ Import MS Project
            </button>
            <button class="btn" id="gantt-back-btn" style="background: rgba(99, 102, 241, 0.1); padding: 12px 24px; font-size: 15px; font-weight: 600; color: var(--text-primary); border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3); cursor: pointer;">
                â† Back to Tree
            </button>
        </div>
    </div>

    <!-- Gantt Chart Container (populated by Frappe Gantt) -->
    <div id="gantt-chart-wrapper" style="display: none;">
        <svg id="gantt-chart"></svg>
    </div>

    <!-- BUILD 474: Gantt Minimap -->
    <div class="gantt-minimap" id="gantt-minimap">
        <canvas id="gantt-minimap-canvas" width="250" height="100"></canvas>
        <div class="gantt-minimap-viewport" id="gantt-minimap-viewport"></div>
    </div>

    <!-- BUILD 474: Floating Zoom Controls (BUILD 475: Fixed position to avoid sidebar) -->
    <div id="gantt-floating-zoom" style="position: absolute; bottom: 130px; left: 70px; display: flex; flex-direction: column; gap: 4px; background: rgba(20, 20, 30, 0.95); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 8px; padding: 8px; z-index: 100;">
        <button id="gantt-floating-zoom-in" style="width: 32px; height: 32px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 6px; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center;">+</button>
        <span id="gantt-floating-zoom-level" style="text-align: center; font-size: 10px; color: rgba(255,255,255,0.8); padding: 2px 0;">100%</span>
        <button id="gantt-floating-zoom-out" style="width: 32px; height: 32px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 6px; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center;">âˆ’</button>
        <div style="border-top: 1px solid rgba(99, 102, 241, 0.2); margin: 4px 0;"></div>
        <button id="gantt-floating-fit" style="width: 32px; height: 32px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 6px; color: white; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Fit All">âŠ¡</button>
    </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     BUILD 494: CALENDAR VIEW CONTAINER
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<style>
    /* Calendar View Container */
    #view-calendar {
        display: none;
        position: fixed;
        top: 140px;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        overflow: hidden;
        z-index: 100;
        padding: 20px;
    }

    #view-calendar.active {
        display: block;
    }

    /* Calendar wrapper takes full height */
    #calendar-wrapper {
        height: 100%;
        max-height: calc(100vh - 180px);
    }

    /* FullCalendar Dark Theme Overrides */
    .fc {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        color: var(--text-primary);
        height: 100%;
    }

    .fc-theme-standard .fc-scrollgrid {
        border-color: var(--border);
    }

    .fc-theme-standard td, .fc-theme-standard th {
        border-color: var(--border);
    }

    .fc-col-header-cell-cushion, .fc-daygrid-day-number {
        color: var(--text-secondary);
        text-decoration: none;
    }

    .fc-col-header-cell-cushion:hover, .fc-daygrid-day-number:hover {
        color: var(--text-primary);
    }

    .fc-day-today {
        background-color: rgba(99, 102, 241, 0.08) !important;
    }

    .fc-day-today .fc-daygrid-day-number {
        color: var(--treeplex-primary);
        font-weight: 700;
    }

    /* Toolbar buttons */
    .fc .fc-button-primary {
        background-color: var(--card-bg) !important;
        border-color: var(--border) !important;
        color: var(--text-primary) !important;
        font-weight: 500;
        text-transform: capitalize;
    }

    .fc .fc-button-primary:hover {
        background-color: rgba(99, 102, 241, 0.2) !important;
        border-color: var(--treeplex-primary) !important;
    }

    .fc .fc-button-primary:disabled {
        opacity: 0.5;
    }

    .fc .fc-button-primary:not(:disabled).fc-button-active,
    .fc .fc-button-primary:not(:disabled):active {
        background-color: var(--treeplex-primary) !important;
        border-color: var(--treeplex-primary) !important;
        color: white !important;
    }

    /* Toolbar title */
    .fc .fc-toolbar-title {
        color: var(--text-primary);
        font-size: 1.4em;
        font-weight: 700;
    }

    /* Calendar Events */
    .fc-event {
        cursor: pointer;
        border: none !important;
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 500;
        border-radius: 4px;
        transition: transform 0.15s, box-shadow 0.15s;
    }

    .fc-event:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    .fc-event-title {
        font-weight: 500;
    }

    .fc-daygrid-event-dot {
        border-color: currentColor !important;
    }

    /* More events link */
    .fc-daygrid-more-link {
        color: var(--treeplex-primary);
        font-weight: 600;
    }

    /* Month view day grid - ensure visibility */
    /* Month view scrollgrid - ensure body section renders */
    .fc-scrollgrid {
        height: auto !important;
    }

    .fc-scrollgrid-section-body {
        height: auto !important;
    }

    .fc-scrollgrid-section-body > td {
        height: auto !important;
    }

    .fc-daygrid-body {
        background: var(--bg);
        position: relative !important;
        width: 100% !important;
    }

    .fc-daygrid-body-balanced .fc-daygrid-day-events {
        position: relative !important;
    }

    .fc-daygrid-day {
        background: var(--bg);
    }

    .fc-daygrid-day-frame {
        min-height: 100px;
        position: relative !important;
    }

    .fc-scrollgrid-sync-table {
        background: var(--bg);
        width: 100% !important;
    }

    /* Ensure rows render in daygrid */
    .fc-daygrid-body-unbalanced .fc-daygrid-day-events {
        min-height: 2em;
    }

    .fc-daygrid-body table {
        width: 100% !important;
    }

    /* Day number styling */
    .fc-daygrid-day-top {
        padding: 4px 8px;
    }

    /* Week/Day time grid */
    .fc-timegrid-slot-label {
        color: var(--text-secondary);
    }

    .fc-timegrid-axis {
        color: var(--text-secondary);
    }

    /* Calendar Empty State */
    #calendar-empty-state {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        padding: 40px;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
        border: 2px solid rgba(99, 102, 241, 0.3);
        border-radius: 16px;
        max-width: 500px;
    }

    #calendar-empty-state h2 {
        font-size: 24px;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 8px;
    }

    #calendar-empty-state p {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: 24px;
        line-height: 1.6;
    }

    /* Mobile Calendar Adjustments */
    @media (max-width: 768px) {
        #view-calendar {
            top: 100px;
            padding: 10px;
        }

        #calendar-wrapper {
            max-height: calc(100vh - 120px);
        }

        .fc .fc-toolbar {
            flex-direction: column;
            gap: 8px;
        }

        .fc .fc-toolbar-title {
            font-size: 1.1em;
        }

        .fc .fc-button {
            padding: 6px 10px;
            font-size: 12px;
        }
    }
</style>

<div id="view-calendar">
    <!-- Calendar Wrapper (populated by FullCalendar) -->
    <div id="calendar-wrapper"></div>

    <!-- Empty State (shown when no dated items) -->
    <div id="calendar-empty-state">
        <div style="font-size: 48px; margin-bottom: 16px;">ğŸ“…</div>
        <h2>Calendar View</h2>
        <p>
            No dated items found in this tree.<br>
            Add Start Dates, Due Dates, or Events to see them here.
        </p>
        <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
            <button class="btn" id="calendar-back-btn" style="background: rgba(99, 102, 241, 0.1); padding: 12px 24px; font-size: 15px; font-weight: 600; color: var(--text-primary); border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3); cursor: pointer;">
                â† Back to Tree
            </button>
        </div>
    </div>
</div>

<!-- Gantt Toolbar (shown when Gantt view is active) -->
<div id="gantt-toolbar">
    <select id="gantt-view-mode" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.15); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 8px; color: #ffffff; font-size: 13px; font-weight: 600; cursor: pointer;">
        <option value="Day" style="background: #1a1a2e; color: #ffffff;">Day</option>
        <option value="Week" selected style="background: #1a1a2e; color: #ffffff;">Week</option>
        <option value="Month" style="background: #1a1a2e; color: #ffffff;">Month</option>
        <option value="Year" style="background: #1a1a2e; color: #ffffff;">Year</option>
    </select>
    <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
    <!-- BUILD 473: Zoom Controls -->
    <button id="gantt-zoom-out" class="btn" style="padding: 8px 12px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px 0 0 8px; color: var(--text-primary); font-size: 14px; cursor: pointer; border-right: none;">
        âˆ’
    </button>
    <span id="gantt-zoom-level" style="padding: 8px 12px; background: rgba(99, 102, 241, 0.05); border: 1px solid rgba(99, 102, 241, 0.3); color: var(--text-primary); font-size: 12px; font-weight: 600; min-width: 50px; text-align: center;">
        100%
    </span>
    <button id="gantt-zoom-in" class="btn" style="padding: 8px 12px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 0 8px 8px 0; color: var(--text-primary); font-size: 14px; cursor: pointer; border-left: none;">
        +
    </button>
    <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
    <button id="gantt-today-btn" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
        ğŸ“ Today
    </button>
    <button id="gantt-fit-btn" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
        âŠ¡ Fit All
    </button>
    <button id="gantt-critical-btn" class="btn" style="padding: 8px 14px; background: rgba(128, 128, 128, 0.1); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 8px; color: var(--text-secondary); font-size: 13px; cursor: not-allowed; opacity: 0.5;" disabled title="No dependencies in this tree">
        âš¡ Critical Path
    </button>
    <button id="gantt-next-critical-btn" class="btn" style="display: none; padding: 8px 14px; background: rgba(255, 0, 0, 0.2); border: 1px solid rgba(255, 0, 0, 0.4); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;" title="Navigate to next critical task">
        â†’ Next
    </button>
    <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
    <label style="display: flex; align-items: center; gap: 6px; color: var(--text-secondary); font-size: 12px; cursor: pointer;">
        <input type="checkbox" id="gantt-readonly" style="accent-color: var(--treeplex-primary);">
        Read-only
    </label>
</div>

<div id="view-3d">
    <!-- Floating Title Overlay -->
    <div id="title-3d">
        <h1 id="title-3d-name">Project Title</h1>
        <div id="title-3d-pattern">Pattern Name</div>
    </div>

    <!-- Hover Tooltip -->
    <div id="hover-tooltip-3d">
        <div id="hover-tooltip-name"></div>
        <div id="hover-tooltip-type"></div>
        <div id="hover-tooltip-desc"></div>
    </div>

    <!-- Context Menu for Node Editing -->
    <div id="context-menu-3d">
        <div class="context-menu-3d-header">Node Actions</div>
        <div class="context-menu-3d-item" data-action="edit">âœï¸ Edit Node</div>
        <div class="context-menu-3d-item" data-action="expand">ğŸ“‚ Expand Children</div>
        <div class="context-menu-3d-item" data-action="collapse">ğŸ“ Collapse Children</div>
        <div class="context-menu-3d-divider"></div>
        <div class="context-menu-3d-item" data-action="add-child">â• Add Child</div>
        <div class="context-menu-3d-item" data-action="add-sibling">â• Add Sibling</div>
        <div class="context-menu-3d-divider"></div>
        <div class="context-menu-3d-header">Connections</div>
        <div class="context-menu-3d-item" data-action="add-hyperedge">ğŸ”— Create Hyperedge</div>
        <div class="context-menu-3d-item" data-action="add-dependency">â†—ï¸ Add Dependency</div>
        <div class="context-menu-3d-divider"></div>
        <div class="context-menu-3d-item danger" data-action="delete">ğŸ—‘ï¸ Delete Node</div>
    </div>

    <!-- Controls -->
    <div id="controls-3d">
        <button class="btn" id="btn-3d-reset">ğŸ  Reset</button>
        <button class="btn" id="btn-3d-spin">ğŸ”„ Spin</button>
        <button class="btn" id="btn-3d-zoom-in">â• Zoom In</button>
        <button class="btn" id="btn-3d-zoom-out">â– Zoom Out</button>
        <div style="width: 1px; height: 24px; background: rgba(255,255,255,0.2); margin: 0 4px;"></div>
        <button class="btn" id="btn-3d-expand-all" title="Expand all nodes">ğŸ“‚ Expand All</button>
        <button class="btn" id="btn-3d-collapse-all" title="Collapse all nodes">ğŸ“ Collapse All</button>
        <div style="color: #888; font-size: 11px; align-self: center; margin-left: 10px;">
            Click: Select | Right-Click: Menu | Drag: Rotate | Scroll: Zoom
        </div>
    </div>
</div>

<!-- Three.js via CDN (global) - BUILD 540: Lazy-loaded on demand for 3D view -->
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script> -->

<!-- BUILD 458: Frappe Gantt (MIT License) - Inlined for single-file constraint -->
<!-- https://github.com/frappe/gantt v0.6.1 -->
<script>
var Gantt=function(){"use strict";const t="year",e="month",s="day",i="hour",n="minute",a="second",o="millisecond",r={en:["January","February","March","April","May","June","July","August","September","October","November","December"],es:["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"],ru:["Ğ¯Ğ½Ğ²Ğ°Ñ€ÑŒ","Ğ¤ĞµĞ²Ñ€Ğ°Ğ»ÑŒ","ĞœĞ°Ñ€Ñ‚","ĞĞ¿Ñ€ĞµĞ»ÑŒ","ĞœĞ°Ğ¹","Ğ˜ÑĞ½ÑŒ","Ğ˜ÑĞ»ÑŒ","ĞĞ²Ğ³ÑƒÑÑ‚","Ğ¡ĞµĞ½Ñ‚ÑĞ±Ñ€ÑŒ","ĞĞºÑ‚ÑĞ±Ñ€ÑŒ","ĞĞ¾ÑĞ±Ñ€ÑŒ","Ğ”ĞµĞºĞ°Ğ±Ñ€ÑŒ"],ptBr:["Janeiro","Fevereiro","MarÃ§o","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],fr:["Janvier","FÃ©vrier","Mars","Avril","Mai","Juin","Juillet","AoÃ»t","Septembre","Octobre","Novembre","DÃ©cembre"],tr:["Ocak","Åubat","Mart","Nisan","MayÄ±s","Haziran","Temmuz","AÄŸustos","EylÃ¼l","Ekim","KasÄ±m","AralÄ±k"],zh:["ä¸€æœˆ","äºŒæœˆ","ä¸‰æœˆ","å››æœˆ","äº”æœˆ","å…­æœˆ","ä¸ƒæœˆ","å…«æœˆ","ä¹æœˆ","åæœˆ","åä¸€æœˆ","åäºŒæœˆ"]};var h={parse(t,e="-",s=/[.:]/){if(t instanceof Date)return t;if("string"==typeof t){let i,n;const a=t.split(" ");i=a[0].split(e).map((t=>parseInt(t,10))),n=a[1]&&a[1].split(s),i[1]=i[1]-1;let o=i;return n&&n.length&&(4==n.length&&(n[3]="0."+n[3],n[3]=1e3*parseFloat(n[3])),o=o.concat(n)),new Date(...o)}},to_string(t,e=!1){if(!(t instanceof Date))throw new TypeError("Invalid argument type");const s=this.get_date_values(t).map(((t,e)=>(1===e&&(t+=1),d(t+"",6===e?3:2,"0")))),i=`${s[0]}-${s[1]}-${s[2]}`,n=`${s[3]}:${s[4]}:${s[5]}.${s[6]}`;return i+(e?" "+n:"")},format(t,e="YYYY-MM-DD HH:mm:ss.SSS",s="en"){const i=this.get_date_values(t).map((t=>d(t,2,0))),n={YYYY:i[0],MM:d(+i[1]+1,2,0),DD:i[2],HH:i[3],mm:i[4],ss:i[5],SSS:i[6],D:i[2],MMMM:r[s][+i[1]],MMM:r[s][+i[1]]};let a=e;const o=[];return Object.keys(n).sort(((t,e)=>e.length-t.length)).forEach((t=>{a.includes(t)&&(a=a.replace(t,`$${o.length}`),o.push(n[t]))})),o.forEach(((t,e)=>{a=a.replace(`$${e}`,t)})),a},diff(t,e,i=s){let n,a,o,r,h,d,p;return n=t-e,a=n/1e3,r=a/60,o=r/60,h=o/24,d=h/30,p=d/12,i.endsWith("s")||(i+="s"),Math.floor({milliseconds:n,seconds:a,minutes:r,hours:o,days:h,months:d,years:p}[i])},today(){const t=this.get_date_values(new Date).slice(0,3);return new Date(...t)},now:()=>new Date,add(r,h,d){h=parseInt(h,10);const p=[r.getFullYear()+(d===t?h:0),r.getMonth()+(d===e?h:0),r.getDate()+(d===s?h:0),r.getHours()+(d===i?h:0),r.getMinutes()+(d===n?h:0),r.getSeconds()+(d===a?h:0),r.getMilliseconds()+(d===o?h:0)];return new Date(...p)},start_of(r,h){const d={[t]:6,[e]:5,[s]:4,[i]:3,[n]:2,[a]:1,[o]:0};function p(t){return d[t]<=d[h]}const _=[r.getFullYear(),p(t)?0:r.getMonth(),p(e)?1:r.getDate(),p(s)?0:r.getHours(),p(i)?0:r.getMinutes(),p(n)?0:r.getSeconds(),p(a)?0:r.getMilliseconds()];return new Date(..._)},clone(t){return new Date(...this.get_date_values(t))},get_date_values:t=>[t.getFullYear(),t.getMonth(),t.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),t.getMilliseconds()],get_days_in_month(t){const e=[31,28,31,30,31,30,31,31,30,31,30,31],s=t.getMonth();if(1!==s)return e[s];const i=t.getFullYear();return i%4==0&&i%100!=0||i%400==0?29:28}};function d(t,e,s){return t+="",e>>=0,s=String(void 0!==s?s:" "),t.length>e?String(t):((e-=t.length)>s.length&&(s+=s.repeat(e/s.length)),s.slice(0,e)+String(t))}function p(t,e){return"string"==typeof t?(e||document).querySelector(t):t||null}function _(t,e){const s=document.createElementNS("http://www.w3.org/2000/svg",t);for(let t in e)if("append_to"===t){e.append_to.appendChild(s)}else"innerHTML"===t?s.innerHTML=e.innerHTML:s.setAttribute(t,e[t]);return s}function g(t,e,s,i){const n=function(t,e,s,i,n="0.4s",a="0.1s"){const o=t.querySelector("animate");if(o)return p.attr(o,{attributeName:e,from:s,to:i,dur:n,begin:"click + "+a}),t;const r=_("animate",{attributeName:e,from:s,to:i,dur:n,begin:a,calcMode:"spline",values:s+";"+i,keyTimes:"0; 1",keySplines:l("ease-out")});return t.appendChild(r),t}(t,e,s,i);if(n===t){const t=document.createEvent("HTMLEvents");t.initEvent("click",!0,!0),t.eventName="click",n.dispatchEvent(t)}}function l(t){return{ease:".25 .1 .25 1",linear:"0 0 1 1","ease-in":".42 0 1 1","ease-out":"0 0 .58 1","ease-in-out":".42 0 .58 1"}[t]}p.on=(t,e,s,i)=>{i?p.delegate(t,e,s,i):(i=s,p.bind(t,e,i))},p.off=(t,e,s)=>{t.removeEventListener(e,s)},p.bind=(t,e,s)=>{e.split(/\s+/).forEach((function(e){t.addEventListener(e,s)}))},p.delegate=(t,e,s,i)=>{t.addEventListener(e,(function(t){const e=t.target.closest(s);e&&(t.delegatedTarget=e,i.call(this,t,e))}))},p.closest=(t,e)=>e?e.matches(t)?e:p.closest(t,e.parentNode):null,p.attr=(t,e,s)=>{if(!s&&"string"==typeof e)return t.getAttribute(e);if("object"!=typeof e)t.setAttribute(e,s);else for(let s in e)p.attr(t,s,e[s])};class u{constructor(t,e){this.set_defaults(t,e),this.prepare(),this.draw(),this.bind()}set_defaults(t,e){this.action_completed=!1,this.gantt=t,this.task=e}prepare(){this.prepare_values(),this.prepare_helpers()}prepare_values(){this.invalid=this.task.invalid,this.height=this.gantt.options.bar_height,this.x=this.compute_x(),this.y=this.compute_y(),this.corner_radius=this.gantt.options.bar_corner_radius,this.duration=h.diff(this.task._end,this.task._start,"hour")/this.gantt.options.step,this.width=this.gantt.options.column_width*this.duration,this.progress_width=this.gantt.options.column_width*this.duration*(this.task.progress/100)||0,this.group=_("g",{class:"bar-wrapper "+(this.task.custom_class||""),"data-id":this.task.id}),this.bar_group=_("g",{class:"bar-group",append_to:this.group}),this.handle_group=_("g",{class:"handle-group",append_to:this.group})}prepare_helpers(){SVGElement.prototype.getX=function(){return+this.getAttribute("x")},SVGElement.prototype.getY=function(){return+this.getAttribute("y")},SVGElement.prototype.getWidth=function(){return+this.getAttribute("width")},SVGElement.prototype.getHeight=function(){return+this.getAttribute("height")},SVGElement.prototype.getEndX=function(){return this.getX()+this.getWidth()}}draw(){this.draw_bar(),this.draw_progress_bar(),this.draw_label(),this.draw_resize_handles()}draw_bar(){this.$bar=_("rect",{x:this.x,y:this.y,width:this.width,height:this.height,rx:this.corner_radius,ry:this.corner_radius,class:"bar",append_to:this.bar_group}),g(this.$bar,"width",0,this.width),this.invalid&&this.$bar.classList.add("bar-invalid")}draw_progress_bar(){this.invalid||(this.$bar_progress=_("rect",{x:this.x,y:this.y,width:this.progress_width,height:this.height,rx:this.corner_radius,ry:this.corner_radius,class:"bar-progress",append_to:this.bar_group}),g(this.$bar_progress,"width",0,this.progress_width))}draw_label(){_("text",{x:this.x+this.width/2,y:this.y+this.height/2,innerHTML:this.task.name,class:"bar-label",append_to:this.bar_group}),requestAnimationFrame((()=>this.update_label_position()))}draw_resize_handles(){if(this.invalid)return;const t=this.$bar;_("rect",{x:t.getX()+t.getWidth()-9,y:t.getY()+1,width:8,height:this.height-2,rx:this.corner_radius,ry:this.corner_radius,class:"handle right",append_to:this.handle_group}),_("rect",{x:t.getX()+1,y:t.getY()+1,width:8,height:this.height-2,rx:this.corner_radius,ry:this.corner_radius,class:"handle left",append_to:this.handle_group}),this.task.progress&&this.task.progress<100&&(this.$handle_progress=_("polygon",{points:this.get_progress_polygon_points().join(","),class:"handle progress",append_to:this.handle_group}))}get_progress_polygon_points(){const t=this.$bar_progress;return[t.getEndX()-5,t.getY()+t.getHeight(),t.getEndX()+5,t.getY()+t.getHeight(),t.getEndX(),t.getY()+t.getHeight()-8.66]}bind(){this.invalid||this.setup_click_event()}setup_click_event(){p.on(this.group,"focus "+this.gantt.options.popup_trigger,(t=>{this.action_completed||(this.show_popup(),this.gantt.unselect_all(),this.group.classList.add("active"))})),p.on(this.group,"dblclick",(t=>{this.action_completed||this.gantt.trigger_event("click",[this.task])}))}show_popup(){if(this.gantt.bar_being_dragged)return;const t=h.format(this.task._start,"MMM D",this.gantt.options.language)+" - "+h.format(h.add(this.task._end,-1,"second"),"MMM D",this.gantt.options.language);this.gantt.show_popup({target_element:this.$bar,title:this.task.name,subtitle:t,task:this.task})}update_bar_position({x:t=null,width:e=null}){const s=this.$bar;if(t){if(!this.task.dependencies.map((t=>this.gantt.get_bar(t).$bar.getX())).reduce(((e,s)=>t>=s),t))return void(e=null);this.update_attr(s,"x",t)}e&&e>=this.gantt.options.column_width&&this.update_attr(s,"width",e),this.update_label_position(),this.update_handle_position(),this.update_progressbar_position(),this.update_arrow_position()}date_changed(){let t=!1;const{new_start_date:e,new_end_date:s}=this.compute_start_end_date();Number(this.task._start)!==Number(e)&&(t=!0,this.task._start=e),Number(this.task._end)!==Number(s)&&(t=!0,this.task._end=s),t&&this.gantt.trigger_event("date_change",[this.task,e,h.add(s,-1,"second")])}progress_changed(){const t=this.compute_progress();this.task.progress=t,this.gantt.trigger_event("progress_change",[this.task,t])}set_action_completed(){this.action_completed=!0,setTimeout((()=>this.action_completed=!1),1e3)}compute_start_end_date(){const t=this.$bar,e=t.getX()/this.gantt.options.column_width,s=h.add(this.gantt.gantt_start,e*this.gantt.options.step,"hour"),i=t.getWidth()/this.gantt.options.column_width;return{new_start_date:s,new_end_date:h.add(s,i*this.gantt.options.step,"hour")}}compute_progress(){const t=this.$bar_progress.getWidth()/this.$bar.getWidth()*100;return parseInt(t,10)}compute_x(){const{step:t,column_width:e}=this.gantt.options,s=this.task._start,i=this.gantt.gantt_start;let n=h.diff(s,i,"hour")/t*e;if(this.gantt.view_is("Month")){n=h.diff(s,i,"day")*e/30}return n}compute_y(){return this.gantt.options.header_height+this.gantt.options.padding+this.task._index*(this.height+this.gantt.options.padding)}get_snap_position(t){let e,s,i=t;return this.gantt.view_is("Week")?(e=t%(this.gantt.options.column_width/7),s=i-e+(e<this.gantt.options.column_width/14?0:this.gantt.options.column_width/7)):this.gantt.view_is("Month")?(e=t%(this.gantt.options.column_width/30),s=i-e+(e<this.gantt.options.column_width/60?0:this.gantt.options.column_width/30)):(e=t%this.options.column_width,s=i-e+(e<this.gantt.options.column_width/2?0:this.gantt.options.column_width)),s}update_attr(t,e,s){return s=+s,isNaN(s)||t.setAttribute(e,s),t}update_progressbar_position(){this.$bar_progress.setAttribute("x",this.$bar.getX()),this.$bar_progress.setAttribute("width",this.$bar.getWidth()*(this.task.progress/100))}update_label_position(){const t=this.$bar,e=this.group.querySelector(".bar-label");e.getBBox().width>t.getWidth()?(e.classList.add("big"),e.setAttribute("x",t.getX()+t.getWidth()+5)):(e.classList.remove("big"),e.setAttribute("x",t.getX()+t.getWidth()/2))}update_handle_position(){const t=this.$bar;this.handle_group.querySelector(".handle.left").setAttribute("x",t.getX()+1),this.handle_group.querySelector(".handle.right").setAttribute("x",t.getEndX()-9);const e=this.group.querySelector(".handle.progress");e&&e.setAttribute("points",this.get_progress_polygon_points())}update_arrow_position(){this.arrows=this.arrows||[];for(let t of this.arrows)t.update()}}class c{constructor(t,e,s){this.gantt=t,this.from_task=e,this.to_task=s,this.calculate_path(),this.draw()}calculate_path(){let t=this.from_task.$bar.getX()+this.from_task.$bar.getWidth()/2;const e=()=>this.to_task.$bar.getX()<t+this.gantt.options.padding&&t>this.from_task.$bar.getX()+this.gantt.options.padding;for(;e();)t-=10;const s=this.gantt.options.header_height+this.gantt.options.bar_height+(this.gantt.options.padding+this.gantt.options.bar_height)*this.from_task.task._index+this.gantt.options.padding,i=this.to_task.$bar.getX()-this.gantt.options.padding/2,n=this.gantt.options.header_height+this.gantt.options.bar_height/2+(this.gantt.options.padding+this.gantt.options.bar_height)*this.to_task.task._index+this.gantt.options.padding,a=this.from_task.task._index>this.to_task.task._index,o=this.gantt.options.arrow_curve,r=a?1:0,h=a?-o:o,d=a?n+this.gantt.options.arrow_curve:n-this.gantt.options.arrow_curve;if(this.path=`\n            M ${t} ${s}\n            V ${d}\n            a ${o} ${o} 0 0 ${r} ${o} ${h}\n            L ${i} ${n}\n            m -5 -5\n            l 5 5\n            l -5 5`,this.to_task.$bar.getX()<this.from_task.$bar.getX()+this.gantt.options.padding){const e=this.gantt.options.padding/2-o,a=this.to_task.$bar.getY()+this.to_task.$bar.getHeight()/2-h,d=this.to_task.$bar.getX()-this.gantt.options.padding;this.path=`\n                M ${t} ${s}\n                v ${e}\n                a ${o} ${o} 0 0 1 -${o} ${o}\n                H ${d}\n                a ${o} ${o} 0 0 ${r} -${o} ${h}\n                V ${a}\n                a ${o} ${o} 0 0 ${r} ${o} ${h}\n                L ${i} ${n}\n                m -5 -5\n                l 5 5\n                l -5 5`}}draw(){this.element=_("path",{d:this.path,"data-from":this.from_task.task.id,"data-to":this.to_task.task.id})}update(){this.calculate_path(),this.element.setAttribute("d",this.path)}}class m{constructor(t,e){this.parent=t,this.custom_html=e,this.make()}make(){this.parent.innerHTML='\n            <div class="title"></div>\n            <div class="subtitle"></div>\n            <div class="pointer"></div>\n        ',this.hide(),this.title=this.parent.querySelector(".title"),this.subtitle=this.parent.querySelector(".subtitle"),this.pointer=this.parent.querySelector(".pointer")}show(t){if(!t.target_element)throw new Error("target_element is required to show popup");t.position||(t.position="left");const e=t.target_element;if(this.custom_html){let e=this.custom_html(t.task);e+='<div class="pointer"></div>',this.parent.innerHTML=e,this.pointer=this.parent.querySelector(".pointer")}else this.title.innerHTML=t.title,this.subtitle.innerHTML=t.subtitle,this.parent.style.width=this.parent.clientWidth+"px";let s;e instanceof HTMLElement?s=e.getBoundingClientRect():e instanceof SVGElement&&(s=t.target_element.getBBox()),"left"===t.position&&(this.parent.style.left=s.x+(s.width+10)+"px",this.parent.style.top=s.y+"px",this.pointer.style.transform="rotateZ(90deg)",this.pointer.style.left="-7px",this.pointer.style.top="2px"),this.parent.style.opacity=1}hide(){this.parent.style.opacity=0,this.parent.style.left=0}}const w={QUARTER_DAY:"Quarter Day",HALF_DAY:"Half Day",DAY:"Day",WEEK:"Week",MONTH:"Month",YEAR:"Year"};class f{constructor(t,e,s){this.setup_wrapper(t),this.setup_options(s),this.setup_tasks(e),this.change_view_mode(),this.bind_events()}setup_wrapper(t){let e,s;if("string"==typeof t&&(t=document.querySelector(t)),t instanceof HTMLElement)s=t,e=t.querySelector("svg");else{if(!(t instanceof SVGElement))throw new TypeError("FrappÃ© Gantt only supports usage of a string CSS selector, HTML DOM element or SVG DOM element for the 'element' parameter");e=t}e?(this.$svg=e,this.$svg.classList.add("gantt")):this.$svg=_("svg",{append_to:s,class:"gantt"}),this.$container=document.createElement("div"),this.$container.classList.add("gantt-container");this.$svg.parentElement.appendChild(this.$container),this.$container.appendChild(this.$svg),this.popup_wrapper=document.createElement("div"),this.popup_wrapper.classList.add("popup-wrapper"),this.$container.appendChild(this.popup_wrapper)}setup_options(t){const e={header_height:50,column_width:30,step:24,view_modes:[...Object.values(w)],bar_height:20,bar_corner_radius:3,arrow_curve:5,padding:18,view_mode:"Day",date_format:"YYYY-MM-DD",popup_trigger:"click",custom_popup_html:null,language:"en"};this.options=Object.assign({},e,t)}setup_tasks(t){this.tasks=t.map(((t,e)=>{if(t._start=h.parse(t.start),t._end=h.parse(t.end),h.diff(t._end,t._start,"year")>10&&(t.end=null),t._index=e,!t.start&&!t.end){const e=h.today();t._start=e,t._end=h.add(e,2,"day")}!t.start&&t.end&&(t._start=h.add(t._end,-2,"day")),t.start&&!t.end&&(t._end=h.add(t._start,2,"day"));if(h.get_date_values(t._end).slice(3).every((t=>0===t))&&(t._end=h.add(t._end,24,"hour")),t.start&&t.end||(t.invalid=!0),"string"==typeof t.dependencies||!t.dependencies){let e=[];t.dependencies&&(e=t.dependencies.split(",").map((t=>t.trim())).filter((t=>t))),t.dependencies=e}return t.id||(t.id=function(t){return t.name+"_"+Math.random().toString(36).slice(2,12)}(t)),t})),this.setup_dependencies()}setup_dependencies(){this.dependency_map={};for(let t of this.tasks)for(let e of t.dependencies)this.dependency_map[e]=this.dependency_map[e]||[],this.dependency_map[e].push(t.id)}refresh(t){this.setup_tasks(t),this.change_view_mode()}change_view_mode(t=this.options.view_mode){this.update_view_scale(t),this.setup_dates(),this.render(),this.trigger_event("view_change",[t])}update_view_scale(t){this.options.view_mode=t,t===w.DAY?(this.options.step=24,this.options.column_width=38):t===w.HALF_DAY?(this.options.step=12,this.options.column_width=38):t===w.QUARTER_DAY?(this.options.step=6,this.options.column_width=38):t===w.WEEK?(this.options.step=168,this.options.column_width=140):t===w.MONTH?(this.options.step=720,this.options.column_width=120):t===w.YEAR&&(this.options.step=8760,this.options.column_width=120)}setup_dates(){this.setup_gantt_dates(),this.setup_date_values()}setup_gantt_dates(){this.gantt_start=this.gantt_end=null;for(let t of this.tasks)(!this.gantt_start||t._start<this.gantt_start)&&(this.gantt_start=t._start),(!this.gantt_end||t._end>this.gantt_end)&&(this.gantt_end=t._end);this.gantt_start=h.start_of(this.gantt_start,"day"),this.gantt_end=h.start_of(this.gantt_end,"day"),this.view_is([w.QUARTER_DAY,w.HALF_DAY])?(this.gantt_start=h.add(this.gantt_start,-7,"day"),this.gantt_end=h.add(this.gantt_end,7,"day")):this.view_is(w.MONTH)?(this.gantt_start=h.start_of(this.gantt_start,"year"),this.gantt_end=h.add(this.gantt_end,1,"year")):this.view_is(w.YEAR)?(this.gantt_start=h.add(this.gantt_start,-2,"year"),this.gantt_end=h.add(this.gantt_end,2,"year")):(this.gantt_start=h.add(this.gantt_start,-1,"month"),this.gantt_end=h.add(this.gantt_end,1,"month"))}setup_date_values(){this.dates=[];let t=null;for(;null===t||t<this.gantt_end;)t=t?this.view_is(w.YEAR)?h.add(t,1,"year"):this.view_is(w.MONTH)?h.add(t,1,"month"):h.add(t,this.options.step,"hour"):h.clone(this.gantt_start),this.dates.push(t)}bind_events(){this.bind_grid_click(),this.bind_bar_events()}render(){this.clear(),this.setup_layers(),this.make_grid(),this.make_dates(),this.make_bars(),this.make_arrows(),this.map_arrows_on_bars(),this.set_width(),this.set_scroll_position()}setup_layers(){this.layers={};const t=["grid","date","arrow","progress","bar","details"];for(let e of t)this.layers[e]=_("g",{class:e,append_to:this.$svg})}make_grid(){this.make_grid_background(),this.make_grid_rows(),this.make_grid_header(),this.make_grid_ticks(),this.make_grid_highlights()}make_grid_background(){const t=this.dates.length*this.options.column_width,e=this.options.header_height+this.options.padding+(this.options.bar_height+this.options.padding)*this.tasks.length;_("rect",{x:0,y:0,width:t,height:e,class:"grid-background",append_to:this.layers.grid}),p.attr(this.$svg,{height:e+this.options.padding+100,width:"100%"})}make_grid_rows(){const t=_("g",{append_to:this.layers.grid}),e=_("g",{append_to:this.layers.grid}),s=this.dates.length*this.options.column_width,i=this.options.bar_height+this.options.padding;let n=this.options.header_height+this.options.padding/2;for(let a of this.tasks)_("rect",{x:0,y:n,width:s,height:i,class:"grid-row",append_to:t}),_("line",{x1:0,y1:n+i,x2:s,y2:n+i,class:"row-line",append_to:e}),n+=this.options.bar_height+this.options.padding}make_grid_header(){_("rect",{x:0,y:0,width:this.dates.length*this.options.column_width,height:this.options.header_height+10,class:"grid-header",append_to:this.layers.grid})}make_grid_ticks(){let t=0,e=this.options.header_height+this.options.padding/2,s=(this.options.bar_height+this.options.padding)*this.tasks.length;for(let i of this.dates){let n="tick";this.view_is(w.DAY)&&1===i.getDate()&&(n+=" thick"),this.view_is(w.WEEK)&&i.getDate()>=1&&i.getDate()<8&&(n+=" thick"),this.view_is(w.MONTH)&&(i.getMonth()+1)%3==0&&(n+=" thick"),_("path",{d:`M ${t} ${e} v ${s}`,class:n,append_to:this.layers.grid}),this.view_is(w.MONTH)?t+=h.get_days_in_month(i)*this.options.column_width/30:t+=this.options.column_width}}make_grid_highlights(){if(this.view_is(w.DAY)){_("rect",{x:h.diff(h.today(),this.gantt_start,"hour")/this.options.step*this.options.column_width,y:0,width:this.options.column_width,height:(this.options.bar_height+this.options.padding)*this.tasks.length+this.options.header_height+this.options.padding/2,class:"today-highlight",append_to:this.layers.grid})}}make_dates(){for(let t of this.get_dates_to_draw())if(_("text",{x:t.lower_x,y:t.lower_y,innerHTML:t.lower_text,class:"lower-text",append_to:this.layers.date}),t.upper_text){const e=_("text",{x:t.upper_x,y:t.upper_y,innerHTML:t.upper_text,class:"upper-text",append_to:this.layers.date});e.getBBox().x2>this.layers.grid.getBBox().width&&e.remove()}}get_dates_to_draw(){let t=null;return this.dates.map(((e,s)=>{const i=this.get_date_info(e,t,s);return t=e,i}))}get_date_info(t,e,s){e||(e=h.add(t,1,"year"));const i={"Quarter Day_lower":h.format(t,"HH",this.options.language),"Half Day_lower":h.format(t,"HH",this.options.language),Day_lower:t.getDate()!==e.getDate()?h.format(t,"D",this.options.language):"",Week_lower:t.getMonth()!==e.getMonth()?h.format(t,"D MMM",this.options.language):h.format(t,"D",this.options.language),Month_lower:h.format(t,"MMMM",this.options.language),Year_lower:h.format(t,"YYYY",this.options.language),"Quarter Day_upper":t.getDate()!==e.getDate()?h.format(t,"D MMM",this.options.language):"","Half Day_upper":t.getDate()!==e.getDate()?t.getMonth()!==e.getMonth()?h.format(t,"D MMM",this.options.language):h.format(t,"D",this.options.language):"",Day_upper:t.getMonth()!==e.getMonth()?h.format(t,"MMMM",this.options.language):"",Week_upper:t.getMonth()!==e.getMonth()?h.format(t,"MMMM",this.options.language):"",Month_upper:t.getFullYear()!==e.getFullYear()?h.format(t,"YYYY",this.options.language):"",Year_upper:t.getFullYear()!==e.getFullYear()?h.format(t,"YYYY",this.options.language):""},n={x:s*this.options.column_width,lower_y:this.options.header_height,upper_y:this.options.header_height-25},a={"Quarter Day_lower":4*this.options.column_width/2,"Quarter Day_upper":0,"Half Day_lower":2*this.options.column_width/2,"Half Day_upper":0,Day_lower:this.options.column_width/2,Day_upper:30*this.options.column_width/2,Week_lower:0,Week_upper:4*this.options.column_width/2,Month_lower:this.options.column_width/2,Month_upper:12*this.options.column_width/2,Year_lower:this.options.column_width/2,Year_upper:30*this.options.column_width/2};return{upper_text:i[`${this.options.view_mode}_upper`],lower_text:i[`${this.options.view_mode}_lower`],upper_x:n.x+a[`${this.options.view_mode}_upper`],upper_y:n.upper_y,lower_x:n.x+a[`${this.options.view_mode}_lower`],lower_y:n.lower_y}}make_bars(){this.bars=this.tasks.map((t=>{const e=new u(this,t);return this.layers.bar.appendChild(e.group),e}))}make_arrows(){this.arrows=[];for(let t of this.tasks){let e=[];e=t.dependencies.map((e=>{const s=this.get_task(e);if(!s)return;const i=new c(this,this.bars[s._index],this.bars[t._index]);return this.layers.arrow.appendChild(i.element),i})).filter(Boolean),this.arrows=this.arrows.concat(e)}}map_arrows_on_bars(){for(let t of this.bars)t.arrows=this.arrows.filter((e=>e.from_task.task.id===t.task.id||e.to_task.task.id===t.task.id))}set_width(){const t=this.$svg.getBoundingClientRect().width,e=this.$svg.querySelector(".grid .grid-row").getAttribute("width");t<e&&this.$svg.setAttribute("width",e)}set_scroll_position(){const t=this.$svg.parentElement;if(!t)return;const e=h.diff(this.get_oldest_starting_date(),this.gantt_start,"hour")/this.options.step*this.options.column_width-this.options.column_width;t.scrollLeft=e}bind_grid_click(){p.on(this.$svg,this.options.popup_trigger,".grid-row, .grid-header",(()=>{this.unselect_all(),this.hide_popup()}))}bind_bar_events(){let t=!1,e=0,s=0,i=!1,n=!1,a=null,o=[];this.bar_being_dragged=null,p.on(this.$svg,"mousedown",".bar-wrapper, .handle",((r,h)=>{const d=p.closest(".bar-wrapper",h);h.classList.contains("left")?i=!0:h.classList.contains("right")?n=!0:h.classList.contains("bar-wrapper")&&(t=!0),d.classList.add("active"),e=r.offsetX,s=r.offsetY,a=d.getAttribute("data-id");const _=[a,...this.get_all_dependent_tasks(a)];o=_.map((t=>this.get_bar(t))),this.bar_being_dragged=a,o.forEach((t=>{const e=t.$bar;e.ox=e.getX(),e.oy=e.getY(),e.owidth=e.getWidth(),e.finaldx=0}))})),p.on(this.$svg,"mousemove",(s=>{if(!(t||i||n))return;const r=s.offsetX-e;s.offsetY,o.forEach((e=>{const s=e.$bar;s.finaldx=this.get_snap_position(r),this.hide_popup(),i?a===e.task.id?e.update_bar_position({x:s.ox+s.finaldx,width:s.owidth-s.finaldx}):e.update_bar_position({x:s.ox+s.finaldx}):n?a===e.task.id&&e.update_bar_position({width:s.owidth+s.finaldx}):t&&e.update_bar_position({x:s.ox+s.finaldx})}))})),document.addEventListener("mouseup",(e=>{(t||i||n)&&o.forEach((t=>t.group.classList.remove("active"))),t=!1,i=!1,n=!1})),p.on(this.$svg,"mouseup",(t=>{this.bar_being_dragged=null,o.forEach((t=>{t.$bar.finaldx&&(t.date_changed(),t.set_action_completed())}))})),this.bind_bar_progress()}bind_bar_progress(){let t=0,e=0,s=null,i=null,n=null,a=null;p.on(this.$svg,"mousedown",".handle.progress",((o,r)=>{s=!0,t=o.offsetX,e=o.offsetY;const h=p.closest(".bar-wrapper",r).getAttribute("data-id");i=this.get_bar(h),n=i.$bar_progress,a=i.$bar,n.finaldx=0,n.owidth=n.getWidth(),n.min_dx=-n.getWidth(),n.max_dx=a.getWidth()-n.getWidth()})),p.on(this.$svg,"mousemove",(e=>{if(!s)return;let a=e.offsetX-t;e.offsetY,a>n.max_dx&&(a=n.max_dx),a<n.min_dx&&(a=n.min_dx);const o=i.$handle_progress;p.attr(n,"width",n.owidth+a),p.attr(o,"points",i.get_progress_polygon_points()),n.finaldx=a})),p.on(this.$svg,"mouseup",(()=>{s=!1,n&&n.finaldx&&(i.progress_changed(),i.set_action_completed())}))}get_all_dependent_tasks(t){let e=[],s=[t];for(;s.length;){const t=s.reduce(((t,e)=>t=t.concat(this.dependency_map[e])),[]);e=e.concat(t),s=t.filter((t=>!s.includes(t)))}return e.filter(Boolean)}get_snap_position(t){let e,s,i=t;return this.view_is(w.WEEK)?(e=t%(this.options.column_width/7),s=i-e+(e<this.options.column_width/14?0:this.options.column_width/7)):this.view_is(w.MONTH)?(e=t%(this.options.column_width/30),s=i-e+(e<this.options.column_width/60?0:this.options.column_width/30)):(e=t%this.options.column_width,s=i-e+(e<this.options.column_width/2?0:this.options.column_width)),s}unselect_all(){[...this.$svg.querySelectorAll(".bar-wrapper")].forEach((t=>{t.classList.remove("active")}))}view_is(t){return"string"==typeof t?this.options.view_mode===t:!!Array.isArray(t)&&t.some((t=>this.options.view_mode===t))}get_task(t){return this.tasks.find((e=>e.id===t))}get_bar(t){return this.bars.find((e=>e.task.id===t))}show_popup(t){this.popup||(this.popup=new m(this.popup_wrapper,this.options.custom_popup_html)),this.popup.show(t)}hide_popup(){this.popup&&this.popup.hide()}trigger_event(t,e){this.options["on_"+t]&&this.options["on_"+t].apply(null,e)}get_oldest_starting_date(){return this.tasks.map((t=>t._start)).reduce(((t,e)=>e<=t?e:t))}clear(){this.$svg.innerHTML=""}}return f.VIEW_MODE=w,f}();
console.log('ğŸ“Š Frappe Gantt loaded');
</script>

<script>
(function() {
    'use strict';

    // Check if Three.js loaded
    // BUILD 553: Don't return early - Gantt/Calendar views don't need Three.js
    const threeJsLoaded = typeof THREE !== 'undefined';
    if (threeJsLoaded) {
        console.log('ğŸ§Š Three.js r128 loaded successfully');
    } else {
        console.log('ğŸ§Š Three.js not loaded - 3D view will lazy-load when needed');
    }

    // --- State ---
    let camera, scene, renderer, controls;
    let isInitialized = false;
    let autoSpin = false;
    const nodePositions = new Map(); // Store positions for drawing lines
    const nodeMeshes = []; // Store mesh references for raycasting
    const labelSprites = []; // Store label sprites for raycasting
    const nodeToLabel = new Map(); // Map mesh to its label sprite
    let raycaster, mouse;
    let selectedMesh = null;
    let selectionGlow = null;
    let hoveredMesh = null; // Currently hovered node
    let hoverScale = 1; // Animation scale for hover
    let contextMenuNode = null; // Node for context menu actions
    const expandedNodes = new Set(); // Track which nodes are expanded in 3D
    let sunCorona = null; // Animated sun corona
    let coronaTime = 0; // Animation time
    let hoverTooltip = null; // HTML tooltip element
    const hyperedgeMeshes = []; // Store hyperedge tubes for raycasting
    let selectedHyperedge = null; // Currently selected hyperedge data

    // --- Configuration ---
    const CONFIG = {
        helixRadius: 300,
        verticalSpacing: 80,
        phaseSpacingZ: 600,
        colorPalette: [0x5FA463, 0x3B8FCC, 0xD68A2E, 0x8B5CF6, 0xEC4899]
    };

    // Pattern-based nebula colors
    const NEBULA_THEMES = {
        'philosophy': { primary: 0x4a148c, secondary: 0x7b1fa2, accent: 0xce93d8 },
        'capex': { primary: 0x0d47a1, secondary: 0x1565c0, accent: 0x64b5f6 },
        'generic': { primary: 0x1a237e, secondary: 0x283593, accent: 0x7986cb },
        'sales': { primary: 0x004d40, secondary: 0x00695c, accent: 0x4db6ac },
        'dialogue': { primary: 0x311b92, secondary: 0x4527a0, accent: 0xb39ddb },
        'film': { primary: 0x880e4f, secondary: 0xad1457, accent: 0xf48fb1 },
        'default': { primary: 0x0d1b2a, secondary: 0x1b263b, accent: 0x415a77 }
    };

    // Determine 3D layout mode based on sort configuration
    function determineLayoutMode(sortConfig) {
        if (!sortConfig || !sortConfig.field) return 'helix'; // Default

        const type = sortConfig.type || 'string';
        const field = sortConfig.field.toLowerCase();

        // Check for date fields
        if (type === 'date' || field.includes('date') || field.includes('time') ||
            field === 'created' || field === 'modified' || field === 'deadline') {
            return 'timeline';
        }

        // Check for numeric fields
        if (type === 'number' || type === 'currency' || type === 'percentage' ||
            field.includes('cost') || field.includes('price') || field.includes('amount') ||
            field.includes('budget') || field.includes('value') || field.includes('score') ||
            field.includes('priority') || field.includes('rank') || field.includes('rating')) {
            return 'tower';
        }

        // Check for boolean - use cluster
        if (type === 'boolean') {
            return 'cluster';
        }

        // Default to cluster for string/category fields
        return 'cluster';
    }

    // --- 1. Initialize 3D Button (button is in HTML, we just add handler) ---
    function init3DButton() {
        const btn = document.getElementById('toggle-3d-mode');
        if (!btn || btn.dataset.initialized) return;

        btn.dataset.initialized = 'true';
        btn.addEventListener('click', toggle3DView);
        console.log('ğŸ§Š 3D View button initialized');
    }

    // --- BUILD 459: Gantt Data Conversion ---

    // Gantt state
    let ganttInstance = null;
    let ganttViewMode = 'Week';
    let ganttShowCriticalPath = false;
    let ganttReadOnly = false;
    let ganttZoom = 100; // BUILD 473: Zoom level (25-200%)
    const GANTT_ZOOM_MIN = 25;
    const GANTT_ZOOM_MAX = 200;
    const GANTT_ZOOM_STEP = 10;

    /**
     * BUILD 479: Update Critical Path button state based on whether tree has dependencies
     */
    function updateGanttCriticalPathButton() {
        const btn = document.getElementById('gantt-critical-btn');
        if (!btn) return;

        // Check if tree has dependencies (reuse existing function)
        const hasDeps = typeof treeHasDependencies === 'function' && treeHasDependencies();

        if (hasDeps) {
            // Enable button with red styling
            btn.disabled = false;
            btn.style.background = 'rgba(255, 0, 0, 0.1)';
            btn.style.borderColor = 'rgba(255, 0, 0, 0.3)';
            btn.style.color = 'var(--text-primary)';
            btn.style.cursor = 'pointer';
            btn.style.opacity = '1';
            btn.title = 'Highlight critical path dependencies';
        } else {
            // Disable button with grey styling
            btn.disabled = true;
            btn.style.background = 'rgba(128, 128, 128, 0.1)';
            btn.style.borderColor = 'rgba(128, 128, 128, 0.3)';
            btn.style.color = 'var(--text-secondary)';
            btn.style.cursor = 'not-allowed';
            btn.style.opacity = '0.5';
            btn.title = 'No dependencies in this tree';
        }
    }

    /**
     * BUILD 482: Generate a stable hue from task ID using hash
     * Uses golden ratio for optimal distribution when walking through tasks
     */
    function hashStringToHue(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        // Use golden ratio multiplier for better distribution
        const goldenRatio = 0.618033988749895;
        const hue = ((Math.abs(hash) * goldenRatio) % 1) * 360;
        return hue;
    }

    /**
     * BUILD 482: Apply smooth task colors based on ID hash + status
     * Each task gets a unique hue, with status affecting saturation/lightness
     */
    function applyGanttTaskColors() {
        const wrapper = document.getElementById('gantt-chart-wrapper');
        if (!wrapper) return;

        const barWrappers = wrapper.querySelectorAll('.bar-wrapper');
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        barWrappers.forEach((barWrapper, index) => {
            const taskId = barWrapper.getAttribute('data-id');
            if (!taskId) return;

            // Skip if critical path is showing and this is critical
            if (ganttShowCriticalPath && barWrapper.classList.contains('critical')) return;

            const node = getNodeById(taskId);
            if (!node) return;

            // Get base hue from task ID hash
            const baseHue = hashStringToHue(taskId);

            // Determine status modifiers
            const status = node.pmStatus || 'Not Started';
            const progress = node.pmProgress || 0;
            const dueDate = node.pmDueDate ? new Date(node.pmDueDate) : null;
            const isOverdue = dueDate && dueDate < today && status !== 'Done' && status !== 'Completed';

            // Calculate saturation and lightness based on status
            // BUILD 483: More muted/grey tones for professional look
            let saturation, lightness;

            if (status === 'Done' || status === 'Completed' || progress >= 100) {
                // Done: very desaturated, faded grey
                saturation = 18;
                lightness = 42;
            } else if (status === 'Blocked') {
                // Blocked: noticeable red but muted
                saturation = 55;
                lightness = 48;
            } else if (status === 'In Progress') {
                // In Progress: moderate saturation, not too vibrant
                saturation = 42;
                lightness = 52;
            } else {
                // Not Started: grey-ish, subtle
                saturation = 32;
                lightness = 48;
            }

            // Apply color to bar
            const bar = barWrapper.querySelector('.bar');
            const barProgress = barWrapper.querySelector('.bar-progress');
            const barLabel = barWrapper.querySelector('.bar-label');

            if (bar) {
                let fillColor;
                if (status === 'Blocked') {
                    fillColor = `hsl(0, ${saturation}%, ${lightness}%)`; // Muted red for blocked
                } else if (isOverdue) {
                    // Overdue: muted orange (BUILD 483)
                    fillColor = `hsl(30, 50%, 48%)`;
                } else {
                    fillColor = `hsl(${baseHue}, ${saturation}%, ${lightness}%)`;
                }
                bar.style.fill = fillColor;

                // Add subtle glow for overdue (reduced intensity)
                if (isOverdue) {
                    bar.style.filter = 'drop-shadow(0 0 3px rgba(245, 158, 11, 0.4))';
                }
            }

            if (barProgress) {
                // Progress bar is slightly darker version
                const progressLightness = Math.max(lightness - 15, 25);
                if (status === 'Blocked') {
                    barProgress.style.fill = `hsl(0, ${saturation + 8}%, ${progressLightness}%)`;
                } else if (isOverdue) {
                    barProgress.style.fill = `hsl(25, 55%, 38%)`;
                } else {
                    barProgress.style.fill = `hsl(${baseHue}, ${saturation + 8}%, ${progressLightness}%)`;
                }
            }

            if (barLabel) {
                // Ensure label is readable
                barLabel.style.fill = lightness > 50 ? '#1a1a2e' : '#ffffff';
                if (status === 'Done' || status === 'Completed') {
                    barLabel.style.opacity = '0.7';
                }
            }
        });

        console.log('ğŸ¨ Gantt task colors applied');
    }

    /**
     * BUILD 482: Apply past column desaturation effect
     * Columns before today are visually faded to show completed time
     */
    function applyGanttPastFade() {
        const wrapper = document.getElementById('gantt-chart-wrapper');
        if (!wrapper) return;

        const svg = wrapper.querySelector('svg');
        if (!svg) return;

        // Find or create the past-fade overlay
        let fadeOverlay = svg.querySelector('#gantt-past-fade');
        if (fadeOverlay) fadeOverlay.remove(); // Remove old one

        // Get the grid dimensions
        const gridBackground = svg.querySelector('.grid-background');
        if (!gridBackground) return;

        const gridHeight = parseFloat(gridBackground.getAttribute('height')) || 500;
        const headerHeight = 50; // Frappe Gantt default header height

        // Find today's position
        const todayHighlight = svg.querySelector('.today-highlight');
        if (!todayHighlight) {
            // No today marker, try to calculate from dates
            // For now, skip if no today marker
            return;
        }

        const todayX = parseFloat(todayHighlight.getAttribute('x')) || 0;

        // Create a subtle gradient overlay for past time
        const defs = svg.querySelector('defs') || document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        if (!svg.querySelector('defs')) {
            svg.insertBefore(defs, svg.firstChild);
        }

        // Create gradient
        const gradientId = 'gantt-past-gradient';
        let gradient = defs.querySelector(`#${gradientId}`);
        if (!gradient) {
            gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient.setAttribute('id', gradientId);
            gradient.innerHTML = `
                <stop offset="0%" stop-color="rgba(0,0,0,0.3)" />
                <stop offset="90%" stop-color="rgba(0,0,0,0.15)" />
                <stop offset="100%" stop-color="rgba(0,0,0,0)" />
            `;
            defs.appendChild(gradient);
        }

        // Create overlay rectangle
        fadeOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        fadeOverlay.setAttribute('id', 'gantt-past-fade');
        fadeOverlay.setAttribute('x', '0');
        fadeOverlay.setAttribute('y', headerHeight.toString());
        fadeOverlay.setAttribute('width', todayX.toString());
        fadeOverlay.setAttribute('height', (gridHeight - headerHeight).toString());
        fadeOverlay.setAttribute('fill', `url(#${gradientId})`);
        fadeOverlay.setAttribute('pointer-events', 'none');

        // Insert after grid but before bars
        const gridLayer = svg.querySelector('g.grid');
        if (gridLayer && gridLayer.nextSibling) {
            svg.insertBefore(fadeOverlay, gridLayer.nextSibling);
        } else {
            svg.appendChild(fadeOverlay);
        }

        console.log('ğŸŒ«ï¸ Gantt past fade applied');
    }

    /**
     * Check if tree has any schedule data (nodes with dates)
     */
    function treeHasScheduleData() {
        let hasData = false;
        function check(node) {
            if (!node || hasData) return;  // Early exit if already found
            if (node.pmStartDate || node.pmDueDate) {
                hasData = true;
                return;
            }
            if (node.phases) node.phases.forEach(check);  // MS Project imports
            if (node.children) node.children.forEach(check);
            if (node.items) node.items.forEach(check);
            if (node.subItems) node.subItems.forEach(check);
        }
        check(capexTree);
        return hasData;
    }

    /**
     * BUILD 486: Get all tasks with schedule data for analysis
     * Returns raw node data with calculated fields for PM analysis
     */
    function getAllTasksWithDates() {
        const tasks = [];
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        function processNode(node) {
            if (!node) return;

            if (node.pmStartDate || node.pmDueDate) {
                const startDate = node.pmStartDate ? new Date(node.pmStartDate) : null;
                const dueDate = node.pmDueDate ? new Date(node.pmDueDate) : null;
                const status = node.pmStatus || 'Not Started';
                const progress = node.pmProgress || 0;

                // Calculate overdue status
                let isOverdue = false;
                let daysOverdue = 0;
                if (dueDate && dueDate < today && status !== 'Done' && status !== 'Completed') {
                    isOverdue = true;
                    daysOverdue = Math.floor((today - dueDate) / (1000 * 60 * 60 * 24));
                }

                // Calculate days until due
                let daysUntilDue = null;
                if (dueDate && !isOverdue) {
                    daysUntilDue = Math.floor((dueDate - today) / (1000 * 60 * 60 * 24));
                }

                tasks.push({
                    id: node.id,
                    name: node.name || node.title || 'Untitled',
                    pmStartDate: node.pmStartDate,
                    pmDueDate: node.pmDueDate,
                    pmDuration: node.pmDuration || 1,
                    pmStatus: status,
                    pmProgress: progress,
                    dependencies: node.dependencies || [],
                    isOverdue,
                    daysOverdue,
                    daysUntilDue,
                    isCritical: node._isCritical || false,
                    slack: node._slack !== undefined ? node._slack : null,
                    _node: node  // Reference to original node
                });
            }

            // Traverse all child structures
            if (node.phases) node.phases.forEach(processNode);
            if (node.children) node.children.forEach(processNode);
            if (node.items) node.items.forEach(processNode);
            if (node.subItems) node.subItems.forEach(processNode);
        }

        processNode(capexTree);
        return tasks;
    }
    window.getAllTasksWithDates = getAllTasksWithDates;

    /**
     * Convert TreeListy tree to Frappe Gantt task format
     * Frappe expects: {id, name, start, end, progress, dependencies}
     */
    function convertTreeToGanttTasks() {
        const tasks = [];
        const today = new Date().toISOString().split('T')[0];

        function processNode(node) {
            if (!node) return;

            // Only include nodes with dates
            if (node.pmStartDate || node.pmDueDate) {
                const start = node.pmStartDate || today;
                let end = node.pmDueDate;

                // Calculate end from duration if not set
                if (!end && node.pmDuration) {
                    const startDate = new Date(start);
                    startDate.setDate(startDate.getDate() + node.pmDuration);
                    end = startDate.toISOString().split('T')[0];
                }
                if (!end) {
                    // Default to 1 day duration
                    const startDate = new Date(start);
                    startDate.setDate(startDate.getDate() + 1);
                    end = startDate.toISOString().split('T')[0];
                }

                // Convert dependencies to comma-separated string
                let depString = '';
                if (node.dependencies && node.dependencies.length > 0) {
                    depString = node.dependencies
                        .map(d => typeof d === 'string' ? d : d.predecessorId)
                        .filter(Boolean)
                        .join(', ');
                }

                // Build custom class for critical path
                let customClass = '';
                if (node._isCritical && ganttShowCriticalPath) {
                    customClass = 'critical';
                }

                tasks.push({
                    id: node.id,
                    name: node.name || node.title || 'Untitled',
                    start: start,
                    end: end,
                    progress: node.pmProgress || 0,
                    dependencies: depString,
                    custom_class: customClass
                });
            }

            // Recursively process all possible child structures
            if (node.phases) node.phases.forEach(processNode);  // MS Project imports
            if (node.children) node.children.forEach(processNode);
            if (node.items) node.items.forEach(processNode);
            if (node.subItems) node.subItems.forEach(processNode);
        }

        // Start from root
        processNode(capexTree);

        console.log(`ğŸ“Š Gantt: Found ${tasks.length} tasks with schedule data`);

        return tasks;
    }

    /**
     * Render the Gantt chart
     */
    function renderGantt() {
        const wrapper = document.getElementById('gantt-chart-wrapper');
        const emptyState = document.getElementById('gantt-empty-state');
        const chartSvg = document.getElementById('gantt-chart');

        // Check for schedule data
        if (!treeHasScheduleData()) {
            emptyState.style.display = 'block';
            wrapper.style.display = 'none';
            console.log('ğŸ“Š No schedule data found');
            return;
        }

        // Convert tree to Gantt tasks
        const tasks = convertTreeToGanttTasks();

        if (tasks.length === 0) {
            emptyState.style.display = 'block';
            wrapper.style.display = 'none';
            console.log('ğŸ“Š No tasks with dates found');
            return;
        }

        // Show chart, hide empty state
        emptyState.style.display = 'none';
        wrapper.style.display = 'block';

        // Clear existing chart
        chartSvg.innerHTML = '';

        // Create Gantt chart
        try {
            ganttInstance = new Gantt('#gantt-chart', tasks, {
                view_mode: ganttViewMode,
                date_format: 'YYYY-MM-DD',
                bar_height: 28,  // BUILD 475: Taller bars for better readability
                bar_corner_radius: 6,
                padding: 20,
                popup_trigger: null,  // BUILD 475: Disable Frappe popup, use custom tooltip
                language: 'en',

                // Event handlers (bidirectional sync in Build 461)
                on_click: function(task) {
                    console.log('ğŸ“Š Gantt task clicked:', task.name);
                    // BUILD 472: Show info panel with scheduling data
                    showGanttInfoPanel(task);
                },

                on_date_change: function(task, start, end) {
                    console.log('ğŸ“Š Gantt date changed:', task.name, start, end);
                    // Build 461: Bidirectional sync - update tree node
                    if (ganttReadOnly) {
                        showToast('ğŸ”’ Read-only mode - changes not saved', 'warning');
                        return;
                    }
                    const node = getNodeById(task.id);
                    if (node) {
                        // Format dates as YYYY-MM-DD
                        const formatDate = (d) => {
                            if (d instanceof Date) {
                                return d.toISOString().split('T')[0];
                            }
                            return String(d).split('T')[0];
                        };
                        node.pmStartDate = formatDate(start);
                        node.pmDueDate = formatDate(end);

                        // Calculate duration in days
                        const startDate = new Date(node.pmStartDate);
                        const endDate = new Date(node.pmDueDate);
                        const diffDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
                        if (diffDays > 0) {
                            node.pmDuration = diffDays;
                        }

                        saveState('Gantt: Update dates for ' + (node.name || node.title));
                        showToast(`ğŸ“Š Updated dates: ${node.name || node.title}`, 'success');
                    }
                },

                on_progress_change: function(task, progress) {
                    console.log('ğŸ“Š Gantt progress changed:', task.name, progress);
                    // Build 461: Bidirectional sync - update tree node
                    if (ganttReadOnly) {
                        showToast('ğŸ”’ Read-only mode - changes not saved', 'warning');
                        return;
                    }
                    const node = getNodeById(task.id);
                    if (node) {
                        node.pmProgress = Math.round(progress);

                        // Update status based on progress
                        if (progress >= 100) {
                            node.pmStatus = 'Done';
                        } else if (progress > 0) {
                            node.pmStatus = 'In Progress';
                        }

                        saveState('Gantt: Update progress for ' + (node.name || node.title));
                        showToast(`ğŸ“Š Progress: ${node.name || node.title} â†’ ${Math.round(progress)}%`, 'success');
                    }
                }
            });

            console.log('ğŸ“Š Gantt chart rendered with', tasks.length, 'tasks');
            showToast(`ğŸ“Š Gantt chart: ${tasks.length} tasks`, 'success');

            // BUILD 474: Update minimap after chart renders
            if (window.updateGanttMinimap) {
                setTimeout(window.updateGanttMinimap, 100);
            }

            // BUILD 475: Initialize custom tooltips after chart renders
            initGanttTooltips();

            // BUILD 479: Update Critical Path button state based on dependencies
            updateGanttCriticalPathButton();

            // BUILD 482: Apply smooth task colors + past fade
            applyGanttTaskColors();
            applyGanttPastFade();

        } catch (error) {
            console.error('ğŸ“Š Gantt render error:', error);
            showToast('Failed to render Gantt chart', 'error');
            emptyState.style.display = 'block';
            wrapper.style.display = 'none';
        }
    }

    // Expose renderGantt globally
    window.renderGantt = renderGantt;

    // BUILD 475: Custom tooltip initialization
    function initGanttTooltips() {
        const tooltip = document.getElementById('gantt-tooltip');
        const wrapper = document.getElementById('gantt-chart-wrapper');
        if (!tooltip || !wrapper) return;

        const svg = wrapper.querySelector('svg');
        if (!svg) return;

        // Helper: Find bar-wrapper by walking up the SVG tree (closest() unreliable on SVG)
        function findBarWrapper(el) {
            let current = el;
            while (current && current !== svg) {
                if (current.classList && current.classList.contains('bar-wrapper')) {
                    return current;
                }
                current = current.parentElement;
            }
            return null;
        }

        // Event delegation for all bars
        svg.addEventListener('mouseover', (e) => {
            const barWrapper = findBarWrapper(e.target);
            if (!barWrapper) return;

            const taskId = barWrapper.getAttribute('data-id');
            if (!taskId) return;

            const node = getNodeById(taskId);
            if (!node) return;

            // Build tooltip content
            const titleEl = tooltip.querySelector('.tooltip-title');
            const contentEl = tooltip.querySelector('.tooltip-content');

            titleEl.textContent = node.name || node.title || 'Task';

            const startStr = node.pmStartDate ? new Date(node.pmStartDate).toLocaleDateString() : 'â€”';
            const endStr = node.pmDueDate ? new Date(node.pmDueDate).toLocaleDateString() : 'â€”';
            const progress = node.pmProgress || 0;
            const status = node.pmStatus || 'Not Started';
            const duration = node.pmDuration || 'â€”';

            contentEl.innerHTML = `
                <div class="tooltip-row">ğŸ“… ${startStr} â†’ ${endStr}</div>
                <div class="tooltip-row">â±ï¸ Duration: ${duration} days</div>
                <div class="tooltip-row">ğŸ“Š Progress: ${progress}%</div>
                <div class="tooltip-row">ğŸ”– Status: ${status}</div>
            `;

            tooltip.classList.add('visible');
        });

        svg.addEventListener('mousemove', (e) => {
            if (!tooltip.classList.contains('visible')) return;

            // Position tooltip near cursor
            const offsetX = 15;
            const offsetY = 15;
            let x = e.clientX + offsetX;
            let y = e.clientY + offsetY;

            // Keep tooltip within viewport
            const rect = tooltip.getBoundingClientRect();
            if (x + rect.width > window.innerWidth - 10) {
                x = e.clientX - rect.width - offsetX;
            }
            if (y + rect.height > window.innerHeight - 10) {
                y = e.clientY - rect.height - offsetY;
            }

            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
        });

        svg.addEventListener('mouseout', (e) => {
            const barWrapper = findBarWrapper(e.target);
            const relatedTarget = e.relatedTarget;

            // Only hide if we're leaving the bar-wrapper entirely
            if (barWrapper && (!relatedTarget || !barWrapper.contains(relatedTarget))) {
                tooltip.classList.remove('visible');
            }
        });

        // Also hide on leaving the SVG
        svg.addEventListener('mouseleave', () => {
            tooltip.classList.remove('visible');
        });

        // BUILD 484: Single-click to show info panel (consistent with other views)
        svg.addEventListener('click', (e) => {
            const barWrapper = findBarWrapper(e.target);
            if (!barWrapper) return;

            const taskId = barWrapper.getAttribute('data-id');
            if (!taskId) return;

            const node = getNodeById(taskId);
            if (!node) return;

            // Show info panel (same as double-click behavior)
            showGanttInfoPanel({ id: taskId, ...node });
        });
    }

    // BUILD 475: Track selected Gantt bar for highlighting
    let selectedGanttTaskId = null;

    /**
     * BUILD 472: Show info panel with scheduling data when Gantt task clicked
     * BUILD 475: Added selection highlight, X close button, click-away close
     */
    function showGanttInfoPanel(task) {
        const node = getNodeById(task.id);
        if (!node) {
            console.warn('ğŸ“Š Node not found for task:', task.id);
            return;
        }

        const panel = document.getElementById('info-panel');
        const titleEl = document.getElementById('info-title');
        const bodyEl = document.getElementById('info-body');

        if (!panel || !titleEl || !bodyEl) return;

        // BUILD 475: Clear previous selection and highlight new one
        document.querySelectorAll('.gantt .bar-wrapper.selected').forEach(el => el.classList.remove('selected'));
        const barWrapper = document.querySelector(`.gantt .bar-wrapper[data-id="${task.id}"]`);
        if (barWrapper) {
            barWrapper.classList.add('selected');
        }
        selectedGanttTaskId = task.id;

        // Title with X close button
        titleEl.innerHTML = `
            <span style="flex: 1;">ğŸ“Š ${node.name || node.title || 'Task'}</span>
            <button id="gantt-info-close-btn" style="background: none; border: none; color: var(--text-secondary); font-size: 20px; cursor: pointer; padding: 4px 8px; margin: -4px -8px -4px 0; border-radius: 4px; transition: all 0.2s;" onmouseover="this.style.color='#EF4444'; this.style.background='rgba(239,68,68,0.1)'" onmouseout="this.style.color='var(--text-secondary)'; this.style.background='none'">&times;</button>
        `;
        titleEl.style.display = 'flex';
        titleEl.style.alignItems = 'center';

        // Add X button click handler
        setTimeout(() => {
            const closeBtn = document.getElementById('gantt-info-close-btn');
            if (closeBtn) {
                closeBtn.onclick = () => closeGanttInfoPanel();
            }
        }, 0);

        // Calculate schedule info
        const startDate = node.pmStartDate ? new Date(node.pmStartDate) : null;
        const endDate = node.pmDueDate ? new Date(node.pmDueDate) : null;
        const today = new Date();

        let daysInfo = '';
        if (endDate) {
            const diffDays = Math.ceil((endDate - today) / (1000 * 60 * 60 * 24));
            if (node.pmStatus === 'Done' || node.pmProgress >= 100) {
                daysInfo = '<span style="color: #10B981;">âœ… Completed</span>';
            } else if (diffDays < 0) {
                daysInfo = `<span style="color: #EF4444; font-weight: 600;">âš ï¸ ${Math.abs(diffDays)} days overdue</span>`;
            } else if (diffDays === 0) {
                daysInfo = '<span style="color: #F59E0B; font-weight: 600;">ğŸ“… Due today!</span>';
            } else if (diffDays <= 7) {
                daysInfo = `<span style="color: #F59E0B;">â° ${diffDays} days left</span>`;
            } else {
                daysInfo = `<span style="color: var(--text-secondary);">${diffDays} days remaining</span>`;
            }
        }

        // Status color
        const statusColors = {
            'To Do': { bg: 'rgba(156, 163, 175, 0.3)', color: '#9CA3AF' },
            'Not Started': { bg: 'rgba(156, 163, 175, 0.3)', color: '#9CA3AF' },
            'In Progress': { bg: 'rgba(59, 130, 246, 0.3)', color: '#3B82F6' },
            'Done': { bg: 'rgba(16, 185, 129, 0.3)', color: '#10B981' },
            'Completed': { bg: 'rgba(16, 185, 129, 0.3)', color: '#10B981' },
            'Blocked': { bg: 'rgba(239, 68, 68, 0.3)', color: '#EF4444' }
        };
        const status = node.pmStatus || 'Not Started';
        const statusStyle = statusColors[status] || statusColors['Not Started'];

        // Format dates
        const formatDate = (d) => d ? new Date(d).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : 'â€”';

        // Build dependencies list
        let depsHtml = '';
        if (node.dependencies && node.dependencies.length > 0) {
            const depItems = node.dependencies.map(dep => {
                const depId = typeof dep === 'string' ? dep : (dep.predecessorId || '');
                const depType = typeof dep === 'object' ? dep.type : 'FS';
                const depLag = typeof dep === 'object' ? (dep.lag || 0) : 0;
                const depNode = getNodeById(depId);
                const name = depNode ? (depNode.name || depNode.title) : depId;
                let typeInfo = depType !== 'FS' || depLag ? ` (${depType}${depLag ? '+' + depLag + 'd' : ''})` : '';
                return `<div style="padding: 4px 0;">ğŸ“Œ ${name}<span style="color: var(--primary); font-size: 0.85em;">${typeInfo}</span></div>`;
            }).join('');
            depsHtml = `
                <div style="margin-top: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 8px;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: var(--primary);">â¬…ï¸ Depends On</div>
                    ${depItems}
                </div>
            `;
        }

        // Build panel content
        bodyEl.innerHTML = `
            <!-- PROMINENT TITLE SECTION -->
            <div style="margin-bottom: 20px; padding: 16px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.1)); border-radius: 12px; border-left: 4px solid var(--primary);">
                <div style="font-size: 20px; font-weight: 700; color: var(--text-primary); line-height: 1.3; margin-bottom: 8px;">
                    ${node.name || node.title || 'Task'}
                </div>
                ${node.description ? `
                <div style="font-size: 14px; color: var(--text-secondary); line-height: 1.5;">
                    ${node.description}
                </div>
                ` : '<div style="font-size: 13px; color: var(--text-secondary); font-style: italic;">No description</div>'}
            </div>

            <!-- Status & Progress Row -->
            <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                <div style="flex: 1; padding: 16px; background: ${statusStyle.bg}; border-radius: 10px; border: 2px solid ${statusStyle.color}; text-align: center;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">STATUS</div>
                    <div style="font-size: 18px; font-weight: 700; color: ${statusStyle.color};">${status}</div>
                </div>
                <div style="flex: 1; padding: 16px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(99, 102, 241, 0.05)); border-radius: 10px; border: 2px solid rgba(99, 102, 241, 0.4); text-align: center;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">PROGRESS</div>
                    <div style="font-size: 24px; font-weight: 700; color: var(--primary);">${node.pmProgress || 0}%</div>
                    <div style="width: 100%; height: 6px; background: rgba(0,0,0,0.3); border-radius: 3px; margin-top: 8px;">
                        <div style="height: 100%; width: ${node.pmProgress || 0}%; background: var(--primary); border-radius: 3px;"></div>
                    </div>
                </div>
            </div>

            <!-- Schedule Grid -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ“… START</div>
                    <div style="font-size: 14px; font-weight: 600;">${formatDate(node.pmStartDate)}</div>
                </div>
                <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ END</div>
                    <div style="font-size: 14px; font-weight: 600;">${formatDate(node.pmDueDate)}</div>
                </div>
                <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">â±ï¸ DURATION</div>
                    <div style="font-size: 14px; font-weight: 600;">${node.pmDuration || 'â€”'} days</div>
                </div>
                <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">â³ TIMELINE</div>
                    <div style="font-size: 14px; font-weight: 600;">${daysInfo || 'â€”'}</div>
                </div>
            </div>

            ${node.pmOwner ? `
            <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 16px;">
                <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ğŸ‘¤ OWNER</div>
                <div style="font-size: 14px; font-weight: 600;">${node.pmOwner}</div>
            </div>
            ` : ''}

            ${depsHtml}

            <!-- Actions -->
            <div style="margin-top: 20px; display: flex; gap: 8px;">
                <button onclick="window.editNodeFromGantt('${node.id}')" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    âœï¸ Edit Task
                </button>
                <button onclick="window.goToNodeInTree('${node.id}')" style="flex: 1; padding: 10px; background: rgba(99, 102, 241, 0.2); color: var(--text-primary); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 8px; cursor: pointer; font-weight: 600;">
                    ğŸŒ² View in Tree
                </button>
            </div>
        `;

        // Open panel
        panel.classList.add('open');
    }

    // BUILD 475: Close Gantt info panel and clear selection
    function closeGanttInfoPanel() {
        const panel = document.getElementById('info-panel');
        if (panel) {
            panel.classList.remove('open');
        }
        // Clear bar selection highlight
        document.querySelectorAll('.gantt .bar-wrapper.selected').forEach(el => el.classList.remove('selected'));
        selectedGanttTaskId = null;
    }

    // BUILD 475: Click-away to close info panel (only in Gantt view)
    document.addEventListener('click', (e) => {
        if (viewMode !== 'gantt') return;

        const panel = document.getElementById('info-panel');
        if (!panel || !panel.classList.contains('open')) return;

        // Check if click is inside info panel
        if (panel.contains(e.target)) return;

        // Check if click is on a Gantt bar (opening new panel)
        if (e.target.closest('.bar-wrapper, .bar, .bar-label, .bar-progress')) return;

        // Check if click is on floating controls or minimap
        if (e.target.closest('#gantt-floating-zoom, #gantt-minimap, #gantt-toolbar')) return;

        // Otherwise close the panel
        closeGanttInfoPanel();
    });

    // Helper: Edit node from Gantt (BUILD 483: Fixed to use handleEdit)
    window.editNodeFromGantt = function(nodeId) {
        const node = getNodeById(nodeId);
        if (node) {
            // Set activeNode using the exposed setter and call handleEdit
            if (typeof window.setActiveNode === 'function') {
                window.setActiveNode(node);
            }
            if (typeof window.handleEdit === 'function') {
                window.handleEdit();
            } else {
                showToast('Edit function not available', 'error');
            }
        }
    };

    // Helper: Navigate to node in Tree view
    window.goToNodeInTree = function(nodeId) {
        // Close Gantt view
        toggleGanttView();
        // Find and select the node in tree view
        setTimeout(() => {
            const nodeElement = document.querySelector(`[data-item-id="${nodeId}"]`);
            if (nodeElement) {
                nodeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                nodeElement.click();
            }
        }, 300);
    };

    // --- BUILD 457: Gantt View Toggle ---
    function toggleGanttView() {
        const viewGantt = document.getElementById('view-gantt');
        const treeView = document.querySelector('.tree-view-container');
        const canvasView = document.getElementById('canvas-container');
        const view3D = document.getElementById('view-3d');
        const toolbar = document.getElementById('gantt-toolbar');
        const emptyState = document.getElementById('gantt-empty-state');

        const isActive = viewGantt.classList.contains('active');

        // BUILD 474: Minimap and floating zoom elements
        const minimap = document.getElementById('gantt-minimap');
        const floatingZoom = document.getElementById('gantt-floating-zoom');

        if (isActive) {
            // Close Gantt view
            viewGantt.classList.remove('active');
            toolbar.classList.remove('active');
            treeView.classList.remove('hidden');
            // BUILD 474: Hide minimap and floating zoom
            if (minimap) minimap.style.display = 'none';
            if (floatingZoom) floatingZoom.style.display = 'none';
            viewMode = 'tree';
            if (window.updateViewDropdown) window.updateViewDropdown('tree');
            render();
        } else {
            // Open Gantt view
            viewGantt.classList.add('active');
            toolbar.classList.add('active');
            treeView.classList.add('hidden');
            canvasView.classList.remove('active');
            view3D.classList.remove('active');
            // BUILD 494: Close Calendar view if open
            const viewCalendar = document.getElementById('view-calendar');
            if (viewCalendar) viewCalendar.classList.remove('active');
            // BUILD 474: Show minimap and floating zoom
            if (minimap) minimap.style.display = 'block';
            if (floatingZoom) floatingZoom.style.display = 'flex';
            viewMode = 'gantt';

            // BUILD 468: Hide canvas toolbar when entering Gantt view
            const canvasToolbar = document.getElementById('canvas-toolbar');
            if (canvasToolbar) canvasToolbar.classList.remove('active');

            // BUILD 459: Render Gantt chart
            renderGantt();

            if (window.updateViewDropdown) window.updateViewDropdown('gantt');
            console.log('ğŸ“Š Gantt view opened');
        }
    }

    // Expose toggleGanttView globally
    window.toggleGanttView = toggleGanttView;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BUILD 494: CALENDAR VIEW LOGIC
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let calendarInstance = null;

    /**
     * Extract dates from a node based on pattern
     */
    function getNodeDates(node) {
        const dates = [];
        // Use window.capexTree since this runs in IIFE scope
        const tree = window.capexTree;
        const pattern = tree?.pattern?.key || 'generic';

        // Universal PM dates (all patterns)
        if (node.pmStartDate && !isNaN(Date.parse(node.pmStartDate))) {
            dates.push({ date: node.pmStartDate, type: 'Start', color: '#3B82F6' }); // Blue
        }
        if (node.pmDueDate && !isNaN(Date.parse(node.pmDueDate))) {
            dates.push({ date: node.pmDueDate, type: 'Due', color: '#EF4444' }); // Red
        }

        // Pattern-specific dates
        if (pattern === 'lifetree' || pattern === 'familytree') {
            if (node.eventDate && !isNaN(Date.parse(node.eventDate))) {
                dates.push({ date: node.eventDate, type: 'Event', color: '#10B981' }); // Green
            }
            if (node.birthDate && !isNaN(Date.parse(node.birthDate))) {
                dates.push({ date: node.birthDate, type: 'Birth', color: '#EC4899' }); // Pink
            }
            if (node.deathDate && !isNaN(Date.parse(node.deathDate))) {
                dates.push({ date: node.deathDate, type: 'Death', color: '#6B7280' }); // Gray
            }
            if (node.marriageDate && !isNaN(Date.parse(node.marriageDate))) {
                dates.push({ date: node.marriageDate, type: 'Marriage', color: '#F59E0B' }); // Orange
            }
        }

        if (pattern === 'sales' && node.expectedCloseDate && !isNaN(Date.parse(node.expectedCloseDate))) {
            dates.push({ date: node.expectedCloseDate, type: 'Close', color: '#10B981' }); // Green
        }

        if (pattern === 'event') {
            if (node.bookingDeadline && !isNaN(Date.parse(node.bookingDeadline))) {
                dates.push({ date: node.bookingDeadline, type: 'Deadline', color: '#F59E0B' }); // Orange
            }
        }

        return dates;
    }

    /**
     * Traverse tree and collect all calendar events
     */
    function getCalendarEvents() {
        const events = [];

        function traverse(node, parentPhase = null) {
            const nodeDates = getNodeDates(node);

            nodeDates.forEach(d => {
                events.push({
                    id: `${node.id}-${d.type}`,
                    title: `${d.type}: ${node.name}`,
                    start: d.date,
                    backgroundColor: d.color,
                    borderColor: d.color,
                    textColor: '#ffffff',
                    extendedProps: {
                        nodeId: node.id,
                        type: d.type,
                        nodeName: node.name
                    }
                });
            });

            // Traverse children
            if (node.children) {
                node.children.forEach(child => traverse(child, child));
            }
            if (node.items) {
                node.items.forEach(item => traverse(item, parentPhase));
            }
            if (node.subtasks) {
                node.subtasks.forEach(sub => traverse(sub, parentPhase));
            }
            if (node.subItems) {
                node.subItems.forEach(sub => traverse(sub, parentPhase));
            }
        }

        // Use window.capexTree since this runs in IIFE scope
        traverse(window.capexTree);
        return events;
    }

    /**
     * Render the calendar view
     */
    async function renderCalendar() {
        // Lazy load FullCalendar library
        if (typeof FullCalendar === 'undefined') {
            try {
                await loadLibrary('fullcalendar');
            } catch (e) {
                showToast('Failed to load calendar library. Please try again.', 'error');
                console.error('FullCalendar load error:', e);
                return;
            }
        }

        const calendarEl = document.getElementById('calendar-wrapper');
        const emptyState = document.getElementById('calendar-empty-state');
        const events = getCalendarEvents();

        if (events.length === 0) {
            calendarEl.style.display = 'none';
            emptyState.style.display = 'block';
            return;
        }

        calendarEl.style.display = 'block';
        emptyState.style.display = 'none';

        // Initialize FullCalendar if not already done
        if (!calendarInstance) {
            calendarInstance = new FullCalendar.Calendar(calendarEl, {
                initialView: 'dayGridMonth',
                headerToolbar: {
                    left: 'prev,next today',
                    center: 'title',
                    right: 'dayGridMonth,timeGridWeek'
                },
                height: 'auto',
                contentHeight: 'auto',
                events: events,
                eventClick: function(info) {
                    const nodeId = info.event.extendedProps.nodeId;
                    // Find and select the node
                    const node = typeof getNodeById === 'function' ? getNodeById(nodeId) : null;
                    if (node) {
                        if (typeof showInfo === 'function') {
                            showInfo(node);
                        }
                        showToast(`Selected: ${node.name}`, 'info');
                    }
                },
                eventDidMount: function(info) {
                    // Add tooltip
                    const props = info.event.extendedProps;
                    info.el.title = `${props.type}: ${props.nodeName}\nClick to view details`;
                },
                // Responsive settings
                windowResize: function() {
                    calendarInstance.updateSize();
                }
            });
            calendarInstance.render();
        } else {
            // Refresh events
            calendarInstance.removeAllEvents();
            calendarInstance.addEventSource(events);
            calendarInstance.render();
        }
    }

    /**
     * Toggle Calendar view on/off
     */
    function toggleCalendarView() {
        const viewCalendar = document.getElementById('view-calendar');
        const treeView = document.querySelector('.tree-view-container');
        const canvasView = document.getElementById('canvas-container');
        const view3D = document.getElementById('view-3d');
        const viewGantt = document.getElementById('view-gantt');
        const ganttToolbar = document.getElementById('gantt-toolbar');

        const isActive = viewCalendar.classList.contains('active');

        if (isActive) {
            // Close Calendar view
            viewCalendar.classList.remove('active');
            treeView.classList.remove('hidden');
            viewMode = 'tree';
            if (window.updateViewDropdown) window.updateViewDropdown('tree');
            render();
            console.log('ğŸ“… Calendar view closed');
        } else {
            // Open Calendar view
            viewCalendar.classList.add('active');
            treeView.classList.add('hidden');
            canvasView?.classList.remove('active');
            view3D?.classList.remove('active');
            viewGantt?.classList.remove('active');
            if (ganttToolbar) ganttToolbar.classList.remove('active');

            // Hide canvas toolbar
            const canvasToolbar = document.getElementById('canvas-toolbar');
            if (canvasToolbar) canvasToolbar.classList.remove('active');

            viewMode = 'calendar';
            renderCalendar();
            if (window.updateViewDropdown) window.updateViewDropdown('calendar');
            console.log('ğŸ“… Calendar view opened');
        }
    }

    // Expose toggleCalendarView globally
    window.toggleCalendarView = toggleCalendarView;
    window.renderCalendar = renderCalendar;
    window.getCalendarEvents = getCalendarEvents;
    // Expose calendarInstance for navigation (gotoDate, etc.)
    Object.defineProperty(window, 'calendarInstance', {
        get: () => calendarInstance,
        configurable: true
    });

    // Initialize Calendar back button
    document.addEventListener('DOMContentLoaded', () => {
        const calendarBackBtn = document.getElementById('calendar-back-btn');
        if (calendarBackBtn) {
            calendarBackBtn.addEventListener('click', () => {
                toggleCalendarView();
            });
        }
    });

    // Initialize Gantt back button
    document.addEventListener('DOMContentLoaded', () => {
        const backBtn = document.getElementById('gantt-back-btn');
        if (backBtn) {
            backBtn.addEventListener('click', () => {
                toggleGanttView();
            });
        }

        const importBtn = document.getElementById('gantt-import-xml-btn');
        if (importBtn) {
            importBtn.addEventListener('click', () => {
                // Trigger MS Project import
                const msInput = document.getElementById('ms-project-import-input');
                if (msInput) {
                    msInput.click();
                } else {
                    showToast('Import MS Project XML from the Open menu', 'info');
                }
            });
        }

        // BUILD 462: Gantt Toolbar Controls
        // View mode selector (Day/Week/Month/Year)
        const viewModeSelect = document.getElementById('gantt-view-mode');
        if (viewModeSelect) {
            viewModeSelect.addEventListener('change', (e) => {
                ganttViewMode = e.target.value;
                if (ganttInstance) {
                    ganttInstance.change_view_mode(ganttViewMode);
                    showToast(`ğŸ“Š View: ${ganttViewMode}`, 'info');
                }
            });
        }

        // Today button - scroll to current date
        const todayBtn = document.getElementById('gantt-today-btn');
        if (todayBtn) {
            todayBtn.addEventListener('click', () => {
                if (ganttInstance) {
                    // Frappe Gantt doesn't have a native scroll_today, so we'll re-render centered on today
                    const today = new Date().toISOString().split('T')[0];
                    // Find a task that includes today in its date range
                    const tasks = convertTreeToGanttTasks();
                    const todayDate = new Date(today);

                    // Scroll the wrapper to show today's column
                    const wrapper = document.getElementById('gantt-chart-wrapper');
                    const chartSvg = wrapper?.querySelector('svg');
                    if (chartSvg) {
                        // Estimate position based on start date of first task
                        const firstTask = tasks[0];
                        if (firstTask) {
                            const startDate = new Date(firstTask.start);
                            const daysDiff = Math.floor((todayDate - startDate) / (1000 * 60 * 60 * 24));
                            const pixelsPerDay = ganttViewMode === 'Day' ? 38 : ganttViewMode === 'Week' ? 140 / 7 : ganttViewMode === 'Month' ? 300 / 30 : 365 / 365;
                            const scrollX = daysDiff * pixelsPerDay - wrapper.clientWidth / 2;
                            wrapper.scrollLeft = Math.max(0, scrollX);
                        }
                    }
                    showToast('ğŸ“ Scrolled to today', 'info');
                }
            });
        }

        // Fit All button - calculate zoom to fit entire chart (BUILD 473)
        const fitBtn = document.getElementById('gantt-fit-btn');
        if (fitBtn) {
            fitBtn.addEventListener('click', () => {
                const wrapper = document.getElementById('gantt-chart-wrapper');
                if (!wrapper) return;

                const svg = wrapper.querySelector('svg');
                if (!svg) return;

                // Reset zoom first to get true dimensions
                ganttZoom = 100;
                svg.style.transform = 'scale(1)';

                // Get dimensions after a brief delay
                setTimeout(() => {
                    const svgWidth = svg.scrollWidth || svg.getBoundingClientRect().width;
                    const wrapperWidth = wrapper.clientWidth;

                    if (svgWidth > 0 && wrapperWidth > 0) {
                        // Calculate zoom to fit width
                        const fitZoom = Math.floor((wrapperWidth / svgWidth) * 100);
                        ganttZoom = Math.max(GANTT_ZOOM_MIN, Math.min(GANTT_ZOOM_MAX, fitZoom));
                    } else {
                        ganttZoom = 50; // Default to 50% if calculation fails
                    }

                    // Apply zoom
                    if (window.applyGanttZoom) {
                        window.applyGanttZoom();
                    } else {
                        svg.style.transform = `scale(${ganttZoom / 100})`;
                        svg.style.transformOrigin = 'top left';
                        const levelEl = document.getElementById('gantt-zoom-level');
                        if (levelEl) levelEl.textContent = `${ganttZoom}%`;
                    }

                    // Reset scroll
                    wrapper.scrollLeft = 0;
                    wrapper.scrollTop = 0;

                    showToast(`âŠ¡ Fit All: Zoomed to ${ganttZoom}%`, 'info');
                }, 50);
            });
        }

        // Critical Path toggle (BUILD 478: Fixed to use correct function and variable)
        const criticalBtn = document.getElementById('gantt-critical-btn');
        const nextCriticalBtn = document.getElementById('gantt-next-critical-btn');
        let ganttCriticalNodes = []; // Store critical node IDs for navigation
        let ganttCriticalIndex = -1; // Current position in critical path navigation

        if (criticalBtn) {
            criticalBtn.addEventListener('click', () => {
                ganttShowCriticalPath = !ganttShowCriticalPath;

                if (ganttShowCriticalPath) {
                    // Calculate critical path using dependencyEngine
                    if (typeof dependencyEngine !== 'undefined' && dependencyEngine.calculateCriticalPath) {
                        const criticalNodes = dependencyEngine.calculateCriticalPath(capexTree);
                        if (!criticalNodes || criticalNodes.length === 0) {
                            showToast('No critical path found (needs dependencies with durations)', 'info');
                            ganttShowCriticalPath = false;
                            return;
                        }
                        // Store critical node IDs for navigation
                        ganttCriticalNodes = criticalNodes.map(n => n.id);
                        ganttCriticalIndex = -1;

                        renderGantt(); // Re-render with critical path classes
                        criticalBtn.style.background = 'rgba(255, 0, 0, 0.3)';
                        criticalBtn.style.borderColor = '#ff0000';
                        // Show navigation button
                        if (nextCriticalBtn) {
                            nextCriticalBtn.style.display = 'inline-flex';
                            nextCriticalBtn.textContent = `â†’ 1/${criticalNodes.length}`;
                        }
                        showToast(`âš¡ Critical path: ${criticalNodes.length} tasks (use â†’ Next to browse)`, 'success');
                    } else {
                        showToast('Critical path engine not available', 'error');
                        ganttShowCriticalPath = false;
                    }
                } else {
                    // Clear critical path highlighting
                    if (typeof dependencyEngine !== 'undefined' && dependencyEngine.clearCriticalPath) {
                        dependencyEngine.clearCriticalPath(capexTree);
                    }
                    ganttCriticalNodes = [];
                    ganttCriticalIndex = -1;
                    criticalBtn.style.background = 'rgba(255, 0, 0, 0.1)';
                    criticalBtn.style.borderColor = 'rgba(255, 0, 0, 0.3)';
                    // Hide navigation button
                    if (nextCriticalBtn) nextCriticalBtn.style.display = 'none';
                    renderGantt(); // Re-render without critical highlighting
                    showToast('âš¡ Critical path hidden', 'info');
                }
            });
        }

        // Navigate to next critical task
        if (nextCriticalBtn) {
            nextCriticalBtn.addEventListener('click', () => {
                if (ganttCriticalNodes.length === 0) return;

                ganttCriticalIndex = (ganttCriticalIndex + 1) % ganttCriticalNodes.length;
                const nodeId = ganttCriticalNodes[ganttCriticalIndex];

                // Find the bar in the Gantt chart and scroll to it
                const wrapper = document.getElementById('gantt-chart-wrapper');
                const bar = wrapper?.querySelector(`.bar-wrapper[data-id="${nodeId}"] .bar`);

                if (bar) {
                    const barX = parseFloat(bar.getAttribute('x')) || 0;
                    const barY = parseFloat(bar.getAttribute('y')) || 0;
                    const barW = parseFloat(bar.getAttribute('width')) || 0;

                    // Scroll to center the bar
                    const centerX = (barX + barW / 2) * (ganttZoom / 100) - wrapper.clientWidth / 2;
                    const centerY = barY * (ganttZoom / 100) - wrapper.clientHeight / 2;

                    wrapper.scrollTo({
                        left: Math.max(0, centerX),
                        top: Math.max(0, centerY),
                        behavior: 'smooth'
                    });

                    // Select the task (triggers info panel)
                    selectedGanttTaskId = nodeId;
                    document.querySelectorAll('.gantt .bar-wrapper.selected').forEach(el => el.classList.remove('selected'));
                    const barWrapper = wrapper.querySelector(`.bar-wrapper[data-id="${nodeId}"]`);
                    if (barWrapper) barWrapper.classList.add('selected');

                    // Show info panel
                    const node = getNodeById(nodeId);
                    if (node) showGanttInfoPanel(node);
                }

                // Update button text
                nextCriticalBtn.textContent = `â†’ ${ganttCriticalIndex + 1}/${ganttCriticalNodes.length}`;
            });
        }

        // Read-only checkbox
        const readonlyCheck = document.getElementById('gantt-readonly');
        if (readonlyCheck) {
            readonlyCheck.addEventListener('change', (e) => {
                ganttReadOnly = e.target.checked;
                if (ganttInstance) {
                    // Re-render with read-only setting
                    renderGantt();
                }
                showToast(ganttReadOnly ? 'ğŸ”’ Read-only mode' : 'âœï¸ Edit mode', 'info');
            });
        }

        // BUILD 473: Zoom controls (BUILD 474: Also update minimap + floating panel)
        // BUILD 477: Zoom-to-focal-point (keeps selected item or cursor position centered)
        // BUILD 483: Smooth zoom via JS animation (replaces choppy CSS transitions)
        let ganttZoomAnimation = null;

        function applyGanttZoom(oldZoom, focalX, focalY) {
            const wrapper = document.getElementById('gantt-chart-wrapper');
            const levelEl = document.getElementById('gantt-zoom-level');
            const floatingLevelEl = document.getElementById('gantt-floating-zoom-level');
            if (wrapper) {
                const svg = wrapper.querySelector('svg');
                if (svg) {
                    // Remove any CSS transition - we'll animate with JS
                    svg.style.transition = 'none';
                    svg.style.transformOrigin = 'top left';

                    // If focal point provided, animate both scroll and scale together
                    if (oldZoom !== undefined && focalX !== undefined && focalY !== undefined) {
                        // Cancel any running animation
                        if (ganttZoomAnimation) cancelAnimationFrame(ganttZoomAnimation);

                        // Calculate the point in SVG space (unscaled coordinates)
                        const svgX = (wrapper.scrollLeft + focalX) / (oldZoom / 100);
                        const svgY = (wrapper.scrollTop + focalY) / (oldZoom / 100);

                        // Calculate target scroll position
                        const targetScrollLeft = Math.max(0, svgX * (ganttZoom / 100) - focalX);
                        const targetScrollTop = Math.max(0, svgY * (ganttZoom / 100) - focalY);

                        // Starting values
                        const startScrollLeft = wrapper.scrollLeft;
                        const startScrollTop = wrapper.scrollTop;
                        const startZoom = oldZoom;
                        const targetZoom = ganttZoom;

                        // Animation parameters
                        const duration = 120; // ms - fast but smooth
                        const startTime = performance.now();

                        // Disable scroll behavior during animation
                        wrapper.style.scrollBehavior = 'auto';

                        function animateZoom(currentTime) {
                            const elapsed = currentTime - startTime;
                            const progress = Math.min(elapsed / duration, 1);

                            // Ease-out cubic for smooth deceleration
                            const eased = 1 - Math.pow(1 - progress, 3);

                            // Interpolate zoom
                            const currentZoom = startZoom + (targetZoom - startZoom) * eased;
                            svg.style.transform = `scale(${currentZoom / 100})`;

                            // Interpolate scroll
                            wrapper.scrollLeft = startScrollLeft + (targetScrollLeft - startScrollLeft) * eased;
                            wrapper.scrollTop = startScrollTop + (targetScrollTop - startScrollTop) * eased;

                            if (progress < 1) {
                                ganttZoomAnimation = requestAnimationFrame(animateZoom);
                            } else {
                                // Final values
                                svg.style.transform = `scale(${ganttZoom / 100})`;
                                wrapper.scrollLeft = targetScrollLeft;
                                wrapper.scrollTop = targetScrollTop;
                                ganttZoomAnimation = null;
                            }
                        }

                        ganttZoomAnimation = requestAnimationFrame(animateZoom);
                    } else {
                        svg.style.transform = `scale(${ganttZoom / 100})`;
                    }
                }
            }
            if (levelEl) {
                levelEl.textContent = `${ganttZoom}%`;
            }
            if (floatingLevelEl) {
                floatingLevelEl.textContent = `${ganttZoom}%`;
            }
            // Update minimap viewport after zoom change
            if (window.updateGanttMinimap) {
                setTimeout(window.updateGanttMinimap, 50);
            }
        }

        // BUILD 477: Get focal point for zoom (selected task center, or viewport center)
        function getGanttZoomFocalPoint() {
            const wrapper = document.getElementById('gantt-chart-wrapper');
            if (!wrapper) return { x: 0, y: 0 };

            // If a task is selected, use its center as focal point
            if (selectedGanttTaskId) {
                const selectedBar = wrapper.querySelector(`.bar-wrapper[data-id="${selectedGanttTaskId}"] .bar`);
                if (selectedBar) {
                    const barX = parseFloat(selectedBar.getAttribute('x')) || 0;
                    const barY = parseFloat(selectedBar.getAttribute('y')) || 0;
                    const barW = parseFloat(selectedBar.getAttribute('width')) || 0;
                    const barH = parseFloat(selectedBar.getAttribute('height')) || 0;

                    // Convert bar center to wrapper-relative coordinates
                    const centerX = (barX + barW / 2) * (ganttZoom / 100) - wrapper.scrollLeft;
                    const centerY = (barY + barH / 2) * (ganttZoom / 100) - wrapper.scrollTop;

                    return { x: centerX, y: centerY };
                }
            }

            // Default: center of visible area
            return { x: wrapper.clientWidth / 2, y: wrapper.clientHeight / 2 };
        }

        const zoomInBtn = document.getElementById('gantt-zoom-in');
        const zoomOutBtn = document.getElementById('gantt-zoom-out');

        if (zoomInBtn) {
            zoomInBtn.addEventListener('click', () => {
                if (ganttZoom < GANTT_ZOOM_MAX) {
                    const oldZoom = ganttZoom;
                    const focal = getGanttZoomFocalPoint();
                    ganttZoom = Math.min(GANTT_ZOOM_MAX, ganttZoom + GANTT_ZOOM_STEP);
                    applyGanttZoom(oldZoom, focal.x, focal.y);
                }
            });
        }

        if (zoomOutBtn) {
            zoomOutBtn.addEventListener('click', () => {
                if (ganttZoom > GANTT_ZOOM_MIN) {
                    const oldZoom = ganttZoom;
                    const focal = getGanttZoomFocalPoint();
                    ganttZoom = Math.max(GANTT_ZOOM_MIN, ganttZoom - GANTT_ZOOM_STEP);
                    applyGanttZoom(oldZoom, focal.x, focal.y);
                }
            });
        }

        // BUILD 474: Mouse wheel always zooms in Gantt (pan via click-drag)
        // BUILD 477: Zoom toward cursor position
        const ganttWrapper = document.getElementById('gantt-chart-wrapper');
        if (ganttWrapper) {
            ganttWrapper.addEventListener('wheel', (e) => {
                // Wheel always zooms (hold Shift to scroll horizontally instead)
                if (e.shiftKey) {
                    // Shift+wheel = horizontal scroll (let browser handle)
                    return;
                }
                e.preventDefault();
                const oldZoom = ganttZoom;
                // Use cursor position as focal point
                const rect = ganttWrapper.getBoundingClientRect();
                const focalX = e.clientX - rect.left;
                const focalY = e.clientY - rect.top;

                if (e.deltaY < 0 && ganttZoom < GANTT_ZOOM_MAX) {
                    ganttZoom = Math.min(GANTT_ZOOM_MAX, ganttZoom + GANTT_ZOOM_STEP);
                } else if (e.deltaY > 0 && ganttZoom > GANTT_ZOOM_MIN) {
                    ganttZoom = Math.max(GANTT_ZOOM_MIN, ganttZoom - GANTT_ZOOM_STEP);
                }
                applyGanttZoom(oldZoom, focalX, focalY);
            }, { passive: false });

            // BUILD 491: Pinch-to-zoom for mobile Gantt View
            let ganttTouchState = { initialDistance: 0, initialZoom: 100, isPinching: false, lastTouchX: 0, lastTouchY: 0 };

            ganttWrapper.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    ganttTouchState.initialDistance = Math.hypot(dx, dy);
                    ganttTouchState.initialZoom = ganttZoom;
                    ganttTouchState.isPinching = true;
                } else if (e.touches.length === 1) {
                    ganttTouchState.lastTouchX = e.touches[0].clientX;
                    ganttTouchState.lastTouchY = e.touches[0].clientY;
                    ganttTouchState.isPinching = false;
                }
            }, { passive: false });

            ganttWrapper.addEventListener('touchmove', (e) => {
                if (ganttTouchState.isPinching && e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const currentDistance = Math.hypot(dx, dy);
                    const scale = currentDistance / ganttTouchState.initialDistance;
                    const oldZoom = ganttZoom;
                    ganttZoom = Math.max(GANTT_ZOOM_MIN, Math.min(GANTT_ZOOM_MAX, ganttTouchState.initialZoom * scale));
                    // Use center of pinch as focal point
                    const rect = ganttWrapper.getBoundingClientRect();
                    const focalX = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left;
                    const focalY = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top;
                    applyGanttZoom(oldZoom, focalX, focalY);
                } else if (e.touches.length === 1 && !ganttTouchState.isPinching) {
                    // Single finger scroll
                    const deltaX = ganttTouchState.lastTouchX - e.touches[0].clientX;
                    const deltaY = ganttTouchState.lastTouchY - e.touches[0].clientY;
                    ganttWrapper.scrollLeft += deltaX;
                    ganttWrapper.scrollTop += deltaY;
                    ganttTouchState.lastTouchX = e.touches[0].clientX;
                    ganttTouchState.lastTouchY = e.touches[0].clientY;
                }
            }, { passive: false });

            ganttWrapper.addEventListener('touchend', () => {
                ganttTouchState.isPinching = false;
                if (window.updateGanttMinimap) {
                    setTimeout(window.updateGanttMinimap, 50);
                }
            });

            // BUILD 475: Click-drag pan navigation
            let isPanning = false;
            let panStartX = 0;
            let panStartY = 0;
            let scrollStartX = 0;
            let scrollStartY = 0;

            ganttWrapper.addEventListener('mousedown', (e) => {
                // Only pan on middle-click or if clicking empty space (not on bars)
                if (e.button === 1 || (e.button === 0 && !e.target.closest('.bar-wrapper, .bar, .bar-label, .bar-progress'))) {
                    isPanning = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    scrollStartX = ganttWrapper.scrollLeft;
                    scrollStartY = ganttWrapper.scrollTop;
                    ganttWrapper.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                const dx = e.clientX - panStartX;
                const dy = e.clientY - panStartY;
                ganttWrapper.scrollLeft = scrollStartX - dx;
                ganttWrapper.scrollTop = scrollStartY - dy;
            });

            document.addEventListener('mouseup', () => {
                if (isPanning) {
                    isPanning = false;
                    ganttWrapper.style.cursor = 'grab';
                    // Update minimap viewport
                    if (window.updateGanttMinimap) {
                        setTimeout(window.updateGanttMinimap, 50);
                    }
                }
            });

            // Set default cursor
            ganttWrapper.style.cursor = 'grab';
        }

        // Expose applyGanttZoom globally for Fit All
        window.applyGanttZoom = applyGanttZoom;

        // BUILD 474: Floating zoom control event listeners
        const floatingZoomIn = document.getElementById('gantt-floating-zoom-in');
        const floatingZoomOut = document.getElementById('gantt-floating-zoom-out');
        const floatingFit = document.getElementById('gantt-floating-fit');

        if (floatingZoomIn) {
            floatingZoomIn.addEventListener('click', () => {
                if (ganttZoom < GANTT_ZOOM_MAX) {
                    const oldZoom = ganttZoom;
                    const focal = getGanttZoomFocalPoint();
                    ganttZoom = Math.min(GANTT_ZOOM_MAX, ganttZoom + GANTT_ZOOM_STEP);
                    applyGanttZoom(oldZoom, focal.x, focal.y);
                }
            });
        }

        if (floatingZoomOut) {
            floatingZoomOut.addEventListener('click', () => {
                if (ganttZoom > GANTT_ZOOM_MIN) {
                    const oldZoom = ganttZoom;
                    const focal = getGanttZoomFocalPoint();
                    ganttZoom = Math.max(GANTT_ZOOM_MIN, ganttZoom - GANTT_ZOOM_STEP);
                    applyGanttZoom(oldZoom, focal.x, focal.y);
                }
            });
        }

        if (floatingFit) {
            floatingFit.addEventListener('click', () => {
                // Trigger the main Fit All button
                const fitBtn = document.getElementById('gantt-fit-btn');
                if (fitBtn) fitBtn.click();
            });
        }

        // =====================================================================
        // BUILD 474: Gantt Minimap
        // =====================================================================
        const ganttMinimapConfig = {
            width: 250,
            height: 100,
            padding: 5,
            taskColor: 'rgba(99, 102, 241, 0.7)',
            criticalColor: 'rgba(239, 68, 68, 0.7)',
            backgroundColor: 'rgba(30, 30, 40, 0.9)'
        };

        let ganttMinimapBounds = { totalWidth: 1000, totalHeight: 500 };

        function updateGanttMinimap() {
            const canvas = document.getElementById('gantt-minimap-canvas');
            const wrapper = document.getElementById('gantt-chart-wrapper');
            const svg = wrapper?.querySelector('svg');

            if (!canvas || !svg || viewMode !== 'gantt') return;

            const ctx = canvas.getContext('2d');
            const { width, height, padding } = ganttMinimapConfig;

            // Clear canvas
            ctx.fillStyle = ganttMinimapConfig.backgroundColor;
            ctx.fillRect(0, 0, width, height);

            // Get actual SVG dimensions (accounting for zoom)
            const svgRect = svg.getBoundingClientRect();
            const actualWidth = svgRect.width / (ganttZoom / 100);
            const actualHeight = svgRect.height / (ganttZoom / 100);

            ganttMinimapBounds = {
                totalWidth: actualWidth || 1000,
                totalHeight: actualHeight || 500
            };

            // Calculate scale to fit
            const scaleX = (width - padding * 2) / ganttMinimapBounds.totalWidth;
            const scaleY = (height - padding * 2) / ganttMinimapBounds.totalHeight;
            const scale = Math.min(scaleX, scaleY);

            // Draw simplified representation of Gantt bars
            const bars = svg.querySelectorAll('.bar');
            bars.forEach(bar => {
                const x = parseFloat(bar.getAttribute('x')) || 0;
                const y = parseFloat(bar.getAttribute('y')) || 0;
                const w = parseFloat(bar.getAttribute('width')) || 50;
                const h = parseFloat(bar.getAttribute('height')) || 20;

                const miniX = padding + x * scale;
                const miniY = padding + y * scale;
                const miniW = Math.max(w * scale, 2);
                const miniH = Math.max(h * scale, 2);

                // Check if critical
                const isCritical = bar.classList.contains('critical') ||
                                   bar.parentElement?.classList.contains('critical');
                ctx.fillStyle = isCritical ? ganttMinimapConfig.criticalColor : ganttMinimapConfig.taskColor;
                ctx.fillRect(miniX, miniY, miniW, miniH);
            });

            // Update viewport indicator
            updateGanttMinimapViewport();
        }

        function updateGanttMinimapViewport() {
            const viewport = document.getElementById('gantt-minimap-viewport');
            const wrapper = document.getElementById('gantt-chart-wrapper');

            if (!viewport || !wrapper || viewMode !== 'gantt') return;

            const { width, height, padding } = ganttMinimapConfig;
            const { totalWidth, totalHeight } = ganttMinimapBounds;

            // Calculate scale
            const scaleX = (width - padding * 2) / totalWidth;
            const scaleY = (height - padding * 2) / totalHeight;
            const scale = Math.min(scaleX, scaleY);

            // Current visible area (accounting for zoom)
            const visibleWidth = wrapper.clientWidth / (ganttZoom / 100);
            const visibleHeight = wrapper.clientHeight / (ganttZoom / 100);
            const scrollLeft = wrapper.scrollLeft / (ganttZoom / 100);
            const scrollTop = wrapper.scrollTop / (ganttZoom / 100);

            // Calculate viewport rectangle
            const vpLeft = padding + scrollLeft * scale;
            const vpTop = padding + scrollTop * scale;
            const vpWidth = Math.max(visibleWidth * scale, 20);
            const vpHeight = Math.max(visibleHeight * scale, 10);

            viewport.style.left = vpLeft + 'px';
            viewport.style.top = vpTop + 'px';
            viewport.style.width = vpWidth + 'px';
            viewport.style.height = vpHeight + 'px';
        }

        // BUILD 476: Throttled scroll updates using requestAnimationFrame
        let ganttMinimapScrollPending = false;
        if (ganttWrapper) {
            ganttWrapper.addEventListener('scroll', () => {
                if (!ganttMinimapScrollPending) {
                    ganttMinimapScrollPending = true;
                    requestAnimationFrame(() => {
                        updateGanttMinimapViewport();
                        ganttMinimapScrollPending = false;
                    });
                }
            });
        }

        // BUILD 476: Viewport drag-to-pan (like Canvas minimap)
        let ganttMinimapDragging = false;
        let ganttMinimapDragStart = { x: 0, y: 0 };
        let ganttMinimapScrollStart = { left: 0, top: 0 };

        const ganttMinimap = document.getElementById('gantt-minimap');
        const ganttMinimapViewport = document.getElementById('gantt-minimap-viewport');

        if (ganttMinimapViewport) {
            // Mouse down on viewport starts drag
            ganttMinimapViewport.addEventListener('mousedown', (e) => {
                e.preventDefault();
                ganttMinimapDragging = true;
                ganttMinimapDragStart = { x: e.clientX, y: e.clientY };
                const wrapper = document.getElementById('gantt-chart-wrapper');
                if (wrapper) {
                    ganttMinimapScrollStart = { left: wrapper.scrollLeft, top: wrapper.scrollTop };
                }
                ganttMinimapViewport.style.cursor = 'grabbing';
                ganttMinimapViewport.classList.add('dragging');
            });
        }

        // Global mousemove for viewport drag
        document.addEventListener('mousemove', (e) => {
            if (!ganttMinimapDragging) return;

            const wrapper = document.getElementById('gantt-chart-wrapper');
            if (!wrapper) return;

            const { width, height, padding } = ganttMinimapConfig;
            const { totalWidth, totalHeight } = ganttMinimapBounds;

            // Calculate scale
            const scaleX = (width - padding * 2) / totalWidth;
            const scaleY = (height - padding * 2) / totalHeight;
            const scale = Math.min(scaleX, scaleY);

            // Calculate delta in minimap space and convert to scroll space
            const deltaX = e.clientX - ganttMinimapDragStart.x;
            const deltaY = e.clientY - ganttMinimapDragStart.y;

            // Convert to chart scroll (accounting for zoom)
            const scrollDeltaX = (deltaX / scale) * (ganttZoom / 100);
            const scrollDeltaY = (deltaY / scale) * (ganttZoom / 100);

            wrapper.scrollLeft = ganttMinimapScrollStart.left + scrollDeltaX;
            wrapper.scrollTop = ganttMinimapScrollStart.top + scrollDeltaY;
        });

        // Global mouseup ends drag
        document.addEventListener('mouseup', () => {
            if (ganttMinimapDragging) {
                ganttMinimapDragging = false;
                if (ganttMinimapViewport) {
                    ganttMinimapViewport.style.cursor = 'grab';
                    ganttMinimapViewport.classList.remove('dragging');
                }
            }
        });

        // Click on minimap (not viewport) to navigate
        if (ganttMinimap) {
            ganttMinimap.addEventListener('click', (e) => {
                // Skip if clicking on viewport or just finished dragging
                if (e.target.id === 'gantt-minimap-viewport' || ganttMinimapDragging) return;

                const wrapper = document.getElementById('gantt-chart-wrapper');
                if (!wrapper) return;

                const rect = ganttMinimap.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                const { width, height, padding } = ganttMinimapConfig;
                const { totalWidth, totalHeight } = ganttMinimapBounds;

                // Calculate scale
                const scaleX = (width - padding * 2) / totalWidth;
                const scaleY = (height - padding * 2) / totalHeight;
                const scale = Math.min(scaleX, scaleY);

                // Convert click position to scroll position
                const targetX = ((clickX - padding) / scale) * (ganttZoom / 100);
                const targetY = ((clickY - padding) / scale) * (ganttZoom / 100);

                // Center the view on the clicked position
                const visibleWidth = wrapper.clientWidth;
                const visibleHeight = wrapper.clientHeight;

                wrapper.scrollTo({
                    left: targetX - visibleWidth / 2,
                    top: targetY - visibleHeight / 2,
                    behavior: 'smooth'
                });
            });
        }

        // Expose minimap update function
        window.updateGanttMinimap = updateGanttMinimap;
    });

    // --- 2. Toggle View ---
    async function toggle3DView() {
        const view3D = document.getElementById('view-3d');
        const treeView = document.querySelector('.tree-view-container');
        const canvasView = document.getElementById('canvas-container');
        const btn = document.getElementById('toggle-3d-mode');

        const isActive = view3D.classList.contains('active');

        if (isActive) {
            // Close 3D - save state first
            save3DViewState();
            view3D.classList.remove('active');
            treeView.classList.remove('hidden');
            btn.style.border = '1px solid var(--border)';
            hideContextMenu();
            // BUILD 352: Update viewMode variable so view switching works correctly
            viewMode = 'tree';
            // BUILD 333: Update view dropdown to show tree view
            if (window.updateViewDropdown) window.updateViewDropdown('tree');
        } else {
            // Open 3D
            view3D.classList.add('active');
            treeView.classList.add('hidden');
            canvasView.classList.remove('active'); // Ensure 2D canvas is off
            // BUILD 494: Close Calendar view if open
            const viewCalendar = document.getElementById('view-calendar');
            if (viewCalendar) viewCalendar.classList.remove('active');
            btn.style.border = '2px solid #fff';
            // BUILD 352: Update viewMode variable so view switching works correctly
            viewMode = '3d';

            if (!isInitialized) await initThreeJS();
            // Restore state before refresh
            restore3DViewState();
            // Always refresh data on open
            refresh3DData();
            updateTitle();
            // BUILD 333: Update view dropdown to show 3D view
            if (window.updateViewDropdown) window.updateViewDropdown('3d');
        }
    }

    // Expose toggle3DView globally for mobile view switching
    window.toggle3DView = toggle3DView;

    // Update floating title from tree data - max 3 words
    function updateTitle() {
        const tree = window.capexTree;
        if (!tree) return;

        const titleEl = document.getElementById('title-3d-name');

        if (titleEl) {
            let name = tree.name || 'Untitled';
            // Truncate to 3 words max
            const words = name.split(/\s+/);
            if (words.length > 3) {
                name = words.slice(0, 3).join(' ') + 'â€¦';
            }
            titleEl.textContent = name;
        }
    }

    // --- 3. Initialize Three.js ---
    async function initThreeJS() {
        // Lazy load Three.js and OrbitControls
        if (typeof THREE === 'undefined') {
            console.log('ğŸ§Š Loading Three.js library...');
            try {
                await loadLibrary('threejs');
                await loadLibrary('orbitcontrols');
            } catch (e) {
                showToast('Failed to load 3D view library. Please try again.', 'error');
                console.error('Three.js load error:', e);
                return;
            }
        }

        console.log('ğŸ§Š Initializing Three.js...');
        const container = document.getElementById('view-3d');

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a); // Dark background
        console.log('ğŸ§Š Scene created');

        // Camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(800, 400, 800);
        camera.lookAt(0, 0, 0);
        console.log('ğŸ§Š Camera created');

        // WebGL Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        console.log('ğŸ§Š Renderer created');

        // Controls - attach to renderer.domElement
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 5000;
        controls.minDistance = 100;
        console.log('ğŸ§Š OrbitControls created');

        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const point = new THREE.PointLight(0xffffff, 1);
        point.position.set(0, 500, 0);
        scene.add(point);

        // Stars/Particles
        addStarfield();

        // Event Listeners
        window.addEventListener('resize', onWindowResize);
        document.getElementById('btn-3d-reset').addEventListener('click', () => {
            camera.position.set(800, 400, 800);
            controls.target.set(0, 0, 0);
        });
        document.getElementById('btn-3d-spin').addEventListener('click', () => {
            autoSpin = !autoSpin;
            document.getElementById('btn-3d-spin').style.background = autoSpin ? '#10b981' : '';
        });

        // Zoom controls
        document.getElementById('btn-3d-zoom-in').addEventListener('click', () => {
            camera.position.multiplyScalar(0.8);
        });
        document.getElementById('btn-3d-zoom-out').addEventListener('click', () => {
            camera.position.multiplyScalar(1.25);
        });

        // Expand/Collapse All controls
        document.getElementById('btn-3d-expand-all').addEventListener('click', () => {
            expandAllNodes();
        });
        document.getElementById('btn-3d-collapse-all').addEventListener('click', () => {
            collapseAllNodes();
        });

        // Raycaster for click detection
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Click handler for node selection
        renderer.domElement.addEventListener('click', onNodeClick);
        renderer.domElement.addEventListener('dblclick', onNodeDoubleClick);

        // Right-click context menu
        renderer.domElement.addEventListener('contextmenu', onNodeRightClick);
        document.addEventListener('click', hideContextMenu);
        initContextMenuHandlers();

        // Mousemove handler for hover effects
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseleave', onMouseLeave);

        // Get tooltip reference
        hoverTooltip = document.getElementById('hover-tooltip-3d');

        isInitialized = true;
        animate();
        console.log('ğŸ§Š Three.js initialized successfully');
    }

    // Mousemove handler for hover detection
    function onMouseMove(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Check nodes, labels, AND hyperedges
        const allClickable = [...nodeMeshes, ...labelSprites, ...hyperedgeMeshes];
        const intersects = raycaster.intersectObjects(allClickable);

        if (intersects.length > 0) {
            let targetMesh = intersects[0].object;

            // Check if it's a hyperedge - show hyperedge tooltip
            if (targetMesh.userData.isHyperedge) {
                if (targetMesh !== hoveredMesh) {
                    if (hoveredMesh) resetHoverState(hoveredMesh);
                    hoveredMesh = targetMesh;
                    applyHyperedgeHoverState(targetMesh);
                    showHyperedgeTooltip(event.clientX, event.clientY, targetMesh.userData.edgeData);
                } else {
                    updateTooltipPosition(event.clientX, event.clientY);
                }
                renderer.domElement.style.cursor = 'pointer';
                return;
            }

            // If we hit a label, find its associated mesh
            if (targetMesh.userData.parentMesh) {
                targetMesh = targetMesh.userData.parentMesh;
            }

            if (targetMesh !== hoveredMesh) {
                // Reset previous hover
                if (hoveredMesh) {
                    resetHoverState(hoveredMesh);
                }

                hoveredMesh = targetMesh;
                applyHoverState(hoveredMesh);
                showHoverTooltip(event.clientX, event.clientY, hoveredMesh.userData.nodeData);
            } else {
                // Update tooltip position
                updateTooltipPosition(event.clientX, event.clientY);
            }

            renderer.domElement.style.cursor = 'pointer';
        } else {
            // No intersection
            if (hoveredMesh) {
                resetHoverState(hoveredMesh);
                hoveredMesh = null;
            }
            hideHoverTooltip();
            renderer.domElement.style.cursor = 'default';
        }

        // Dim distant nodes based on mouse proximity (focus effect)
        applyProximityFocus();
    }

    // Mouse leave handler
    function onMouseLeave() {
        if (hoveredMesh) {
            resetHoverState(hoveredMesh);
            hoveredMesh = null;
        }
        hideHoverTooltip();
        resetProximityFocus();
    }

    // Apply hover magnification
    function applyHoverState(mesh) {
        if (!mesh) return;
        mesh.userData.originalScale = mesh.scale.clone();
        mesh.scale.multiplyScalar(1.4); // Magnify by 40%

        // Also scale up the label
        const label = nodeToLabel.get(mesh);
        if (label) {
            label.userData.originalScale = label.scale.clone();
            label.scale.multiplyScalar(1.3);
        }
    }

    // Reset hover state
    function resetHoverState(mesh) {
        if (!mesh) return;

        // Handle hyperedge hover reset
        if (mesh.userData.isHyperedge && mesh.material) {
            if (mesh.userData.originalOpacity !== undefined) {
                mesh.material.opacity = mesh.userData.originalOpacity;
            } else {
                mesh.material.opacity = 0.4;
            }
            mesh.material.emissiveIntensity = 0.2;
            return;
        }

        // Handle node hover reset
        if (!mesh.userData.originalScale) return;
        mesh.scale.copy(mesh.userData.originalScale);

        const label = nodeToLabel.get(mesh);
        if (label && label.userData.originalScale) {
            label.scale.copy(label.userData.originalScale);
        }
    }

    // Show hover tooltip
    function showHoverTooltip(x, y, nodeData) {
        if (!hoverTooltip || !nodeData) return;

        document.getElementById('hover-tooltip-name').textContent = nodeData.name || 'Unnamed';
        document.getElementById('hover-tooltip-type').textContent = nodeData.type || 'Node';

        // Get description from various possible fields
        const desc = nodeData.description || nodeData.summary || nodeData.details || '';
        document.getElementById('hover-tooltip-desc').textContent = desc ? desc.substring(0, 150) : '';

        hoverTooltip.style.left = x + 'px';
        hoverTooltip.style.top = y + 'px';
        hoverTooltip.classList.add('visible');
    }

    // Update tooltip position
    function updateTooltipPosition(x, y) {
        if (!hoverTooltip) return;
        hoverTooltip.style.left = x + 'px';
        hoverTooltip.style.top = y + 'px';
    }

    // Hide hover tooltip
    function hideHoverTooltip() {
        if (hoverTooltip) {
            hoverTooltip.classList.remove('visible');
        }
    }

    // Apply hover glow to hyperedge tube
    function applyHyperedgeHoverState(mesh) {
        if (!mesh || !mesh.material) return;
        mesh.userData.originalOpacity = mesh.material.opacity;
        mesh.material.opacity = 0.8;
        mesh.material.emissiveIntensity = 0.5;
    }

    // Show hyperedge tooltip
    function showHyperedgeTooltip(x, y, edgeData) {
        if (!hoverTooltip || !edgeData) return;

        const nameEl = document.getElementById('hover-tooltip-name');
        const typeEl = document.getElementById('hover-tooltip-type');
        const descEl = document.getElementById('hover-tooltip-desc');

        if (nameEl) nameEl.textContent = edgeData.label || 'Hyperedge';
        if (typeEl) typeEl.textContent = `ğŸ”— ${edgeData.nodeIds?.length || 0} connected nodes`;
        if (descEl) descEl.textContent = edgeData.description || 'Click to view/edit';

        hoverTooltip.style.left = x + 'px';
        hoverTooltip.style.top = y + 'px';
        hoverTooltip.classList.add('visible');
    }

    // Select a hyperedge - show info panel
    function selectHyperedge(mesh) {
        clearSelection();
        selectedHyperedge = mesh.userData.edgeData;

        // Highlight all tubes of this hyperedge
        hyperedgeMeshes.forEach(m => {
            if (m.userData.edgeData === selectedHyperedge && m.material) {
                m.material.opacity = 0.9;
                m.material.emissiveIntensity = 0.6;
            }
        });

        // Show hyperedge in info panel
        showHyperedgeInfoPanel(selectedHyperedge);
    }

    // Show hyperedge info in the 3D info panel
    function showHyperedgeInfoPanel(edgeData) {
        const panel = document.getElementById('info-panel-3d');
        if (!panel || !edgeData) return;

        // Get node names for display
        const tree = window.capexTree;
        const nodeNames = [];
        if (edgeData.nodeIds && tree) {
            edgeData.nodeIds.forEach(id => {
                const node = findNodeById(tree, id);
                if (node) nodeNames.push(node.name || 'Unnamed');
            });
        }

        panel.innerHTML = `
            <div style="padding: 16px;">
                <div style="font-size: 11px; color: rgba(255,255,255,0.5); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">
                    ğŸ”— Hyperedge
                </div>
                <h3 style="color: #fff; margin: 0 0 12px 0; font-size: 18px;">
                    ${edgeData.label || 'Unnamed Hyperedge'}
                </h3>
                <div style="font-size: 13px; color: rgba(255,255,255,0.7); margin-bottom: 12px;">
                    ${edgeData.description || 'No description'}
                </div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
                    <strong>Connected Nodes (${nodeNames.length}):</strong>
                </div>
                <ul style="margin: 0; padding-left: 20px; font-size: 12px; color: rgba(255,255,255,0.8);">
                    ${nodeNames.map(n => `<li>${n}</li>`).join('')}
                </ul>
                <button onclick="editHyperedgeFrom3D()" style="
                    margin-top: 16px;
                    padding: 8px 16px;
                    background: rgba(78, 205, 196, 0.3);
                    color: #4ecdc4;
                    border: 1px solid rgba(78, 205, 196, 0.5);
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                    width: 100%;
                ">âœï¸ Edit Hyperedge</button>
            </div>
        `;
        panel.classList.add('visible');
    }

    // Edit hyperedge from 3D view
    window.editHyperedgeFrom3D = function() {
        if (!selectedHyperedge) return;

        // Close 3D view and open hyperedge editor
        const view3D = document.getElementById('view-3d');
        if (view3D) view3D.classList.remove('active');

        // Find and show hyperedge info
        const tree = window.capexTree;
        if (tree && tree.hyperedges) {
            const hyperedge = tree.hyperedges.find(e => e.id === selectedHyperedge.id);
            if (hyperedge && typeof window.showHyperedgeInfo === 'function') {
                window.showHyperedgeInfo(hyperedge);
            }
        }
    };

    // Helper: Find node by ID in tree
    function findNodeById(node, id) {
        if (node.id === id) return node;
        if (node.children) {
            for (const child of node.children) {
                const found = findNodeById(child, id);
                if (found) return found;
            }
        }
        if (node.items) {
            for (const item of node.items) {
                const found = findNodeById(item, id);
                if (found) return found;
            }
        }
        if (node.subItems) {
            for (const sub of node.subItems) {
                const found = findNodeById(sub, id);
                if (found) return found;
            }
        }
        return null;
    }

    // Apply proximity-based focus (dim distant nodes)
    function applyProximityFocus() {
        if (!hoveredMesh) return;

        const hoverPos = hoveredMesh.position;
        const focusRadius = 500; // Nodes within this radius stay bright

        nodeMeshes.forEach(mesh => {
            if (mesh === hoveredMesh || mesh === selectedMesh) return;

            const distance = mesh.position.distanceTo(hoverPos);
            const opacity = distance < focusRadius ? 1 : Math.max(0.3, 1 - (distance - focusRadius) / 1000);

            if (mesh.material) {
                mesh.material.opacity = opacity;
                mesh.material.transparent = true;
            }
        });
    }

    // Reset proximity focus
    function resetProximityFocus() {
        nodeMeshes.forEach(mesh => {
            if (mesh.material && mesh.material.opacity !== undefined) {
                mesh.material.opacity = 1;
            }
        });
    }

    // Right-click handler for context menu
    function onNodeRightClick(event) {
        event.preventDefault();

        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(nodeMeshes);

        if (intersects.length > 0) {
            const clickedMesh = intersects[0].object;
            contextMenuNode = clickedMesh.userData.nodeData;
            selectNode(clickedMesh);
            showContextMenu(event.clientX, event.clientY);
        } else {
            hideContextMenu();
        }
    }

    // Show context menu at position
    function showContextMenu(x, y) {
        const menu = document.getElementById('context-menu-3d');
        if (!menu) return;

        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        menu.classList.add('visible');

        // Update expand/collapse visibility based on node
        const expandItem = menu.querySelector('[data-action="expand"]');
        const collapseItem = menu.querySelector('[data-action="collapse"]');

        if (contextMenuNode) {
            const hasChildren = (contextMenuNode.children && contextMenuNode.children.length > 0) ||
                              (contextMenuNode.items && contextMenuNode.items.length > 0) ||
                              (contextMenuNode.subItems && contextMenuNode.subItems.length > 0);

            if (expandItem) expandItem.style.display = hasChildren ? 'flex' : 'none';
            if (collapseItem) collapseItem.style.display = hasChildren ? 'flex' : 'none';
        }
    }

    // Hide context menu
    function hideContextMenu() {
        const menu = document.getElementById('context-menu-3d');
        if (menu) menu.classList.remove('visible');
        contextMenuNode = null;
    }

    // Initialize context menu action handlers
    function initContextMenuHandlers() {
        const menu = document.getElementById('context-menu-3d');
        if (!menu) return;

        menu.addEventListener('click', (e) => {
            const item = e.target.closest('.context-menu-3d-item');
            if (!item || !contextMenuNode) return;

            const action = item.dataset.action;
            handleContextMenuAction(action, contextMenuNode);
            hideContextMenu();
        });
    }

    // Handle context menu action
    function handleContextMenuAction(action, node) {
        console.log('ğŸ§Š Context action:', action, 'on node:', node.name);

        switch (action) {
            case 'edit':
                // Open the info panel for editing
                if (typeof window.showInfo === 'function') {
                    window.showInfo(node);
                }
                // Also try to focus the edit modal if available
                if (typeof window.editNode === 'function') {
                    window.editNode(node.id);
                }
                break;

            case 'expand':
                expandedNodes.add(node.id);
                refresh3DData();
                break;

            case 'collapse':
                expandedNodes.delete(node.id);
                refresh3DData();
                break;

            case 'add-child':
                if (typeof window.addChild === 'function') {
                    window.addChild(node.id);
                    setTimeout(() => refresh3DData(), 100);
                }
                break;

            case 'add-sibling':
                if (typeof window.addSibling === 'function') {
                    window.addSibling(node.id);
                    setTimeout(() => refresh3DData(), 100);
                }
                break;

            case 'add-hyperedge':
                if (typeof window.showToast === 'function') {
                    window.showToast('Select another node to create hyperedge', 'info');
                }
                // Store first node for hyperedge creation
                window._hyperedgeStartNode = node.id;
                break;

            case 'add-dependency':
                if (typeof window.showToast === 'function') {
                    window.showToast('Select target node for dependency', 'info');
                }
                window._dependencyStartNode = node.id;
                break;

            case 'delete':
                if (confirm(`Delete "${node.name}"?`)) {
                    if (typeof window.deleteNode === 'function') {
                        window.deleteNode(node.id);
                        setTimeout(() => refresh3DData(), 100);
                    }
                }
                break;
        }
    }

    // Handle click on 3D node or hyperedge
    function onNodeClick(event) {
        // Calculate mouse position in normalized device coordinates
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Check nodes, labels, AND hyperedges for click
        const allClickable = [...nodeMeshes, ...labelSprites, ...hyperedgeMeshes];
        const intersects = raycaster.intersectObjects(allClickable);

        if (intersects.length > 0) {
            let clickedMesh = intersects[0].object;

            // Check if it's a hyperedge
            if (clickedMesh.userData.isHyperedge) {
                selectHyperedge(clickedMesh);
                return;
            }

            // If clicked on a label, get its parent mesh
            if (clickedMesh.userData.parentMesh) {
                clickedMesh = clickedMesh.userData.parentMesh;
            }
            selectNode(clickedMesh);
        }
    }

    // Double-click to reset to root
    function onNodeDoubleClick(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const allClickable = [...nodeMeshes, ...labelSprites];
        const intersects = raycaster.intersectObjects(allClickable);

        if (intersects.length === 0) {
            // Double-click on empty space - reset to root
            controls.target.set(0, 0, 0);
            clearSelection();
        }
    }

    // Select a node: change orbit target, highlight, show info panel
    function selectNode(mesh) {
        // Clear previous selection glow
        clearSelection();

        selectedMesh = mesh;
        const position = mesh.position.clone();
        const nodeData = mesh.userData.nodeData;

        // Set orbit controls to pivot around this node
        controls.target.copy(position);

        // Create selection glow
        const glowSize = mesh.geometry.parameters.radius * 2.5;
        const glowGeometry = new THREE.SphereGeometry(glowSize, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        selectionGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        selectionGlow.position.copy(position);
        scene.add(selectionGlow);

        // Show infographic panel for this node
        if (nodeData && typeof window.showInfo === 'function') {
            window.showInfo(nodeData);
        }

        console.log('ğŸ§Š Selected node:', nodeData?.name || 'Unknown');
    }

    // Clear selection highlight
    function clearSelection() {
        if (selectionGlow) {
            scene.remove(selectionGlow);
            selectionGlow.geometry.dispose();
            selectionGlow.material.dispose();
            selectionGlow = null;
        }
        selectedMesh = null;
    }

    // Expand all nodes - collect all node IDs
    function expandAllNodes() {
        const tree = window.capexTree;
        if (!tree) return;

        function collectNodeIds(node) {
            if (node.id) expandedNodes.add(node.id);
            if (node.children) node.children.forEach(collectNodeIds);
            if (node.items) node.items.forEach(collectNodeIds);
            if (node.subItems) node.subItems.forEach(collectNodeIds);
        }

        collectNodeIds(tree);
        refresh3DData();
        save3DViewState();
        console.log('ğŸ§Š Expanded all nodes:', expandedNodes.size);
    }

    // Collapse all nodes
    function collapseAllNodes() {
        expandedNodes.clear();
        refresh3DData();
        save3DViewState();
        console.log('ğŸ§Š Collapsed all nodes');
    }

    // Save 3D view state to tree metadata
    function save3DViewState() {
        const tree = window.capexTree;
        if (!tree || !camera || !controls) return;

        tree.view3DState = {
            camera: {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            },
            target: {
                x: controls.target.x,
                y: controls.target.y,
                z: controls.target.z
            },
            expandedNodes: Array.from(expandedNodes),
            autoSpin: autoSpin
        };

        console.log('ğŸ§Š Saved 3D view state');
    }

    // Restore 3D view state from tree metadata
    function restore3DViewState() {
        const tree = window.capexTree;
        if (!tree || !tree.view3DState || !camera || !controls) return;

        const state = tree.view3DState;

        // Restore camera position
        if (state.camera) {
            camera.position.set(state.camera.x, state.camera.y, state.camera.z);
        }

        // Restore orbit target
        if (state.target) {
            controls.target.set(state.target.x, state.target.y, state.target.z);
        }

        // Restore expanded nodes
        if (state.expandedNodes && Array.isArray(state.expandedNodes)) {
            expandedNodes.clear();
            state.expandedNodes.forEach(id => expandedNodes.add(id));
        }

        // Restore auto-spin
        if (typeof state.autoSpin === 'boolean') {
            autoSpin = state.autoSpin;
            const spinBtn = document.getElementById('btn-3d-spin');
            if (spinBtn) spinBtn.style.background = autoSpin ? '#10b981' : '';
        }

        console.log('ğŸ§Š Restored 3D view state');
    }

    function addStarfield() {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const colors = [];

        for (let i = 0; i < 3000; i++) {
            vertices.push(
                THREE.MathUtils.randFloatSpread(5000),
                THREE.MathUtils.randFloatSpread(5000),
                THREE.MathUtils.randFloatSpread(5000)
            );
            // Vary star colors slightly (white to blue-white)
            const brightness = 0.3 + Math.random() * 0.7;
            colors.push(brightness, brightness, brightness + Math.random() * 0.2);
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(geometry, material);
        stars.userData.isBackground = true;
        scene.add(stars);

        // Add nebula clouds based on pattern
        addNebulaClouds();
    }

    // Add nebula clouds for atmosphere
    function addNebulaClouds() {
        const tree = window.capexTree;
        const pattern = tree?.pattern || 'default';
        const theme = NEBULA_THEMES[pattern] || NEBULA_THEMES['default'];

        // Create multiple nebula cloud layers
        for (let i = 0; i < 5; i++) {
            const nebulaGeometry = new THREE.SphereGeometry(1500 + i * 400, 32, 32);
            const nebulaMaterial = new THREE.MeshBasicMaterial({
                color: i % 2 === 0 ? theme.primary : theme.secondary,
                transparent: true,
                opacity: 0.03 - i * 0.004,
                side: THREE.BackSide
            });
            const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            nebula.position.set(
                THREE.MathUtils.randFloatSpread(500),
                THREE.MathUtils.randFloatSpread(500),
                THREE.MathUtils.randFloatSpread(1000)
            );
            nebula.userData.isBackground = true;
            scene.add(nebula);
        }

        // Add accent glow spots
        for (let i = 0; i < 3; i++) {
            const glowGeometry = new THREE.SphereGeometry(200 + Math.random() * 300, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: theme.accent,
                transparent: true,
                opacity: 0.08
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.set(
                THREE.MathUtils.randFloatSpread(2000),
                THREE.MathUtils.randFloatSpread(1500),
                THREE.MathUtils.randFloatSpread(2000)
            );
            glow.userData.isBackground = true;
            scene.add(glow);
        }
    }

    // --- 4. The Core Logic: Data to 3D ---
    function refresh3DData() {
        // Clear existing tree objects (keep stars/lights/nebula)
        scene.children = scene.children.filter(obj => obj.type === 'Points' || obj.isLight || obj.userData?.isBackground);
        sunCorona = null; // Reset corona reference
        // Clear labels
        const labels = document.querySelectorAll('.node-3d-label');
        labels.forEach(el => el.remove()); // DOM cleanup

        // Clear tracking arrays
        nodeMeshes.length = 0;
        nodePositions.clear();
        labelSprites.length = 0;
        nodeToLabel.clear();
        hyperedgeMeshes.length = 0;
        selectedHyperedge = null;
        clearSelection();
        hoveredMesh = null;

        // Grab Global Tree
        const tree = window.capexTree;
        if (!tree) return;

        // --- Render Root ---
        createNode(tree, 0, 0, 0, 0xffffff, 'root');

        // BUILD 537: If root is collapsed, only show root node
        if (tree.expanded === false) {
            return;
        }

        // --- Determine Layout Mode based on Sort ---
        const sortConfig = window.currentSortConfig;
        const layoutMode = determineLayoutMode(sortConfig);

        // --- Render Phases & Items based on Layout Mode ---
        if (tree.children) {
            let globalItemIndex = 0;
            let allItems = []; // Collect all items for sorted layouts

            // Collect all items with their phase info for sorted layouts
            if (layoutMode !== 'helix') {
                tree.children.forEach((phase, pIdx) => {
                    const phaseColor = CONFIG.colorPalette[pIdx % CONFIG.colorPalette.length];
                    // BUILD 537: Skip items if phase is collapsed
                    if (phase.expanded === false) return;
                    if (phase.items) {
                        phase.items.forEach(item => {
                            allItems.push({ item, phase, pIdx, phaseColor });
                        });
                    }
                });
            }

            if (layoutMode === 'helix') {
                // DEFAULT: Original Helix Layout
                tree.children.forEach((phase, pIdx) => {
                    const phaseColor = CONFIG.colorPalette[pIdx % CONFIG.colorPalette.length];
                    const phaseZ = (pIdx + 1) * CONFIG.phaseSpacingZ;

                    createNode(phase, 0, 0, phaseZ, phaseColor, 'phase');

                    const prevPos = pIdx === 0 ? new THREE.Vector3(0,0,0) : new THREE.Vector3(0,0, pIdx * CONFIG.phaseSpacingZ);
                    createConnection(prevPos, new THREE.Vector3(0,0, phaseZ), 0x555555, 1);

                    // BUILD 537: Skip items if phase is collapsed
                    if (phase.expanded === false) return;

                    if (phase.items) {
                        phase.items.forEach((item, iIdx) => {
                            const angle = globalItemIndex * 0.8;
                            const radius = CONFIG.helixRadius;
                            const x = Math.cos(angle) * radius;
                            const y = (iIdx * CONFIG.verticalSpacing) - ((phase.items.length * CONFIG.verticalSpacing)/2);
                            const z = phaseZ + (Math.sin(angle) * 100);

                            createNode(item, x, y, z, phaseColor, 'item');
                            createConnection(new THREE.Vector3(0,0,phaseZ), new THREE.Vector3(x,y,z), phaseColor, 0.3);

                            renderSubtasks(item, x, y, z, phaseColor);
                            globalItemIndex++;
                        });
                    }
                });

            } else if (layoutMode === 'tower') {
                // NUMERIC SORT: Tower/Skyscraper Layout - Y position = value
                const field = sortConfig.field;
                const values = allItems.map(a => parseFloat(a.item[field]) || 0);
                const maxVal = Math.max(...values, 1);
                const minVal = Math.min(...values, 0);
                const range = maxVal - minVal || 1;

                // Render phases as rings at base
                tree.children.forEach((phase, pIdx) => {
                    const phaseColor = CONFIG.colorPalette[pIdx % CONFIG.colorPalette.length];
                    const ringAngle = (pIdx / tree.children.length) * Math.PI * 2;
                    const ringRadius = 300;
                    const px = Math.cos(ringAngle) * ringRadius;
                    const pz = Math.sin(ringAngle) * ringRadius;
                    createNode(phase, px, -200, pz, phaseColor, 'phase');
                    createConnection(new THREE.Vector3(0,0,0), new THREE.Vector3(px,-200,pz), 0x555555, 0.5);
                });

                // Items arranged by value - higher value = higher position
                allItems.forEach((a, idx) => {
                    const val = parseFloat(a.item[field]) || 0;
                    const normalizedY = ((val - minVal) / range) * 800 - 200; // -200 to 600
                    const angle = (idx / allItems.length) * Math.PI * 2;
                    const radius = 200 + (normalizedY + 200) * 0.3; // Wider at top
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;

                    createNode(a.item, x, normalizedY, z, a.phaseColor, 'item');

                    // Connect to center pillar at same height
                    createConnection(new THREE.Vector3(0, normalizedY, 0), new THREE.Vector3(x, normalizedY, z), a.phaseColor, 0.2);

                    renderSubtasks(a.item, x, normalizedY, z, a.phaseColor);
                });

                // Add central pillar
                const pillarGeometry = new THREE.CylinderGeometry(5, 5, 1000, 16);
                const pillarMaterial = new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                pillar.position.set(0, 200, 0);
                scene.add(pillar);

            } else if (layoutMode === 'cluster') {
                // CATEGORY SORT: Cluster Layout - Group by value
                const field = sortConfig.field;
                const groups = {};

                allItems.forEach(a => {
                    const key = String(a.item[field] || 'Unknown');
                    if (!groups[key]) groups[key] = [];
                    groups[key].push(a);
                });

                const groupKeys = Object.keys(groups);
                const groupColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xaa96da, 0xf38181, 0x6c5ce7, 0x00b894];

                // Render phases in center ring
                tree.children.forEach((phase, pIdx) => {
                    const phaseColor = CONFIG.colorPalette[pIdx % CONFIG.colorPalette.length];
                    const angle = (pIdx / tree.children.length) * Math.PI * 2;
                    const px = Math.cos(angle) * 150;
                    const pz = Math.sin(angle) * 150;
                    createNode(phase, px, 0, pz, phaseColor, 'phase');
                    createConnection(new THREE.Vector3(0,0,0), new THREE.Vector3(px,0,pz), 0x555555, 0.5);
                });

                // Each group gets its own cluster sphere in space
                groupKeys.forEach((key, gIdx) => {
                    const groupItems = groups[key];
                    const groupAngle = (gIdx / groupKeys.length) * Math.PI * 2;
                    const groupRadius = 600;
                    const groupColor = groupColors[gIdx % groupColors.length];

                    // Group center position
                    const gx = Math.cos(groupAngle) * groupRadius;
                    const gz = Math.sin(groupAngle) * groupRadius;
                    const gy = 0;

                    // Create group marker (larger translucent sphere)
                    const groupGeometry = new THREE.SphereGeometry(80, 32, 32);
                    const groupMaterial = new THREE.MeshBasicMaterial({
                        color: groupColor,
                        transparent: true,
                        opacity: 0.15
                    });
                    const groupSphere = new THREE.Mesh(groupGeometry, groupMaterial);
                    groupSphere.position.set(gx, gy, gz);
                    scene.add(groupSphere);

                    // Add group label
                    const groupLabel = createTextSprite(key, groupColor);
                    groupLabel.position.set(gx, gy + 120, gz);
                    groupLabel.scale.set(250, 60, 1);
                    scene.add(groupLabel);

                    // Connect group to root
                    createConnection(new THREE.Vector3(0,0,0), new THREE.Vector3(gx, gy, gz), groupColor, 0.15);

                    // Arrange items within the group cluster
                    groupItems.forEach((a, iIdx) => {
                        const itemAngle = (iIdx / groupItems.length) * Math.PI * 2;
                        const itemRadius = 60 + groupItems.length * 8;
                        const ix = gx + Math.cos(itemAngle) * itemRadius;
                        const iy = gy + (Math.random() - 0.5) * 100;
                        const iz = gz + Math.sin(itemAngle) * itemRadius;

                        createNode(a.item, ix, iy, iz, a.phaseColor, 'item');
                        createConnection(new THREE.Vector3(gx, gy, gz), new THREE.Vector3(ix, iy, iz), a.phaseColor, 0.2);

                        renderSubtasks(a.item, ix, iy, iz, a.phaseColor);
                    });
                });

            } else if (layoutMode === 'timeline') {
                // DATE SORT: Timeline Layout - Z position = time
                const field = sortConfig.field;
                const dates = allItems.map(a => new Date(a.item[field] || 0).getTime());
                const minDate = Math.min(...dates);
                const maxDate = Math.max(...dates);
                const dateRange = maxDate - minDate || 1;

                // Render phases as waypoints along timeline
                tree.children.forEach((phase, pIdx) => {
                    const phaseColor = CONFIG.colorPalette[pIdx % CONFIG.colorPalette.length];
                    const phaseZ = (pIdx / tree.children.length) * 1500 - 500;
                    createNode(phase, 0, 100, phaseZ, phaseColor, 'phase');
                });

                // Items arranged along Z-axis by date
                allItems.forEach((a, idx) => {
                    const dateVal = new Date(a.item[field] || 0).getTime();
                    const normalizedZ = ((dateVal - minDate) / dateRange) * 1500 - 500;
                    const angle = idx * 0.5;
                    const radius = 250;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * 80;

                    createNode(a.item, x, y, normalizedZ, a.phaseColor, 'item');

                    // Connect to timeline axis
                    createConnection(new THREE.Vector3(0, 0, normalizedZ), new THREE.Vector3(x, y, normalizedZ), a.phaseColor, 0.2);

                    renderSubtasks(a.item, x, y, normalizedZ, a.phaseColor);
                });

                // Add timeline axis
                const axisGeometry = new THREE.CylinderGeometry(3, 3, 1600, 8);
                const axisMaterial = new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5 });
                const axis = new THREE.Mesh(axisGeometry, axisMaterial);
                axis.rotation.x = Math.PI / 2;
                axis.position.set(0, 0, 250);
                scene.add(axis);
            }
        }

        // Helper: Render subtasks for an item
        function renderSubtasks(item, x, y, z, phaseColor) {
            // BUILD 537: Skip subtasks if item is collapsed
            if (item.expanded === false) return;
            if (item.subItems) {
                item.subItems.forEach((sub, sIdx) => {
                    const subRadius = 120;
                    const subAngle = (sIdx / item.subItems.length) * Math.PI * 2;
                    const sx = x + Math.cos(subAngle) * subRadius;
                    const sy = y + Math.sin(subAngle) * subRadius;
                    const sz = z + 50;

                    createNode(sub, sx, sy, sz, phaseColor, 'subtask');
                    createConnection(new THREE.Vector3(x,y,z), new THREE.Vector3(sx,sy,sz), phaseColor, 0.2);
                });
            }
        }

        // --- Render Hyperedges (3D Tube Shapes) ---
        if (tree.hyperedges) {
            const hyperedgeColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da];

            tree.hyperedges.forEach((edge, edgeIndex) => {
                // Use edge color or assign from palette
                const colorHex = edge.color ? parseInt(edge.color.replace('#', ''), 16) : hyperedgeColors[edgeIndex % hyperedgeColors.length];

                if (edge.nodeIds && edge.nodeIds.length >= 2) {
                    const positions = edge.nodeIds.map(id => nodePositions.get(id)).filter(p => p);

                    if (positions.length >= 2) {
                        // For 2 nodes, draw a single curved tube
                        // For 3+ nodes, draw tubes connecting all nodes through a central hub

                        if (positions.length === 2) {
                            // Simple curve between two points
                            createHyperedgeTube(positions[0], positions[1], colorHex, edge.label, edge);
                        } else {
                            // Multi-node hyperedge: create central hub and connect all nodes to it
                            const centroid = new THREE.Vector3();
                            positions.forEach(p => centroid.add(p));
                            centroid.divideScalar(positions.length);
                            centroid.y += 150; // Lift the hub above

                            // Create central hub sphere
                            const hubGeometry = new THREE.SphereGeometry(15, 16, 16);
                            const hubMaterial = new THREE.MeshBasicMaterial({
                                color: colorHex,
                                transparent: true,
                                opacity: 0.6
                            });
                            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                            hub.position.copy(centroid);
                            hub.userData = { isHyperedge: true, edgeData: edge, colorHex: colorHex, isHub: true };
                            scene.add(hub);
                            hyperedgeMeshes.push(hub); // Hub is also clickable

                            // Connect all nodes to the hub
                            positions.forEach(pos => {
                                createHyperedgeTube(pos, centroid, colorHex, null, edge);
                            });

                            // Add label at hub if available
                            if (edge.label) {
                                const labelSprite = createTextSprite(edge.label, colorHex);
                                labelSprite.position.set(centroid.x, centroid.y + 40, centroid.z);
                                labelSprite.scale.set(150, 37, 1);
                                labelSprite.userData = { isHyperedge: true, edgeData: edge, parentHub: hub };
                                scene.add(labelSprite);
                                hyperedgeMeshes.push(labelSprite);
                            }
                        }
                    }
                }
            });
        }

        // --- Render Dependencies (Dashed Arrows) ---
        renderDependencies(tree);
    }

    // Render dependencies as dashed arrows
    function renderDependencies(tree) {
        // Collect all dependencies from nodes
        function collectDependencies(node, deps = []) {
            if (node.dependencies && Array.isArray(node.dependencies)) {
                node.dependencies.forEach(dep => {
                    deps.push({
                        from: dep.sourceId || dep.from,
                        to: node.id,
                        label: dep.label || dep.type || ''
                    });
                });
            }
            // Also check for outgoing dependencies
            if (node.dependsOn && Array.isArray(node.dependsOn)) {
                node.dependsOn.forEach(targetId => {
                    deps.push({
                        from: node.id,
                        to: targetId,
                        label: ''
                    });
                });
            }
            if (node.children) node.children.forEach(c => collectDependencies(c, deps));
            if (node.items) node.items.forEach(i => collectDependencies(i, deps));
            if (node.subItems) node.subItems.forEach(s => collectDependencies(s, deps));
            return deps;
        }

        const dependencies = collectDependencies(tree);

        dependencies.forEach(dep => {
            const fromPos = nodePositions.get(dep.from);
            const toPos = nodePositions.get(dep.to);

            if (fromPos && toPos) {
                createDependencyArrow(fromPos, toPos, dep.label);
            }
        });
    }

    // Create a dashed arrow for dependency
    function createDependencyArrow(start, end, label) {
        const direction = new THREE.Vector3().subVectors(end, start);
        const length = direction.length();

        // Create dashed line
        const points = [];
        const segments = 20;
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const point = new THREE.Vector3().lerpVectors(start, end, t);
            // Add slight arc
            point.y += Math.sin(t * Math.PI) * length * 0.1;
            points.push(point);
        }

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineDashedMaterial({
            color: 0xff9900, // Orange for dependencies
            dashSize: 15,
            gapSize: 10,
            transparent: true,
            opacity: 0.7
        });

        const line = new THREE.Line(geometry, material);
        line.computeLineDistances(); // Required for dashed lines
        scene.add(line);

        // Add arrowhead at destination
        const arrowDir = direction.clone().normalize();
        const arrowLength = 20;
        const arrowColor = 0xff9900;

        // Position arrowhead slightly before the end point
        const arrowPos = end.clone().sub(arrowDir.clone().multiplyScalar(15));

        const arrowHelper = new THREE.ArrowHelper(
            arrowDir,
            arrowPos,
            arrowLength,
            arrowColor,
            arrowLength * 0.6,
            arrowLength * 0.4
        );
        scene.add(arrowHelper);

        // Add label if provided
        if (label) {
            const midPoint = new THREE.Vector3().lerpVectors(start, end, 0.5);
            midPoint.y += length * 0.1 + 20; // Above the arc
            const labelSprite = createTextSprite(label, 0xff9900);
            labelSprite.position.copy(midPoint);
            labelSprite.scale.set(120, 30, 1);
            scene.add(labelSprite);
        }
    }

    // Helper: Create hyperedge tube between two points
    function createHyperedgeTube(start, end, colorHex, label, edgeData) {
        // Calculate a graceful arc midpoint
        const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
        const distance = start.distanceTo(end);
        mid.y += distance * 0.3; // Arc proportional to distance

        const curve = new THREE.QuadraticBezierCurve3(start, mid, end);

        // Create tube geometry along the curve
        const tubeGeometry = new THREE.TubeGeometry(curve, 32, 8, 8, false);
        const tubeMaterial = new THREE.MeshPhongMaterial({
            color: colorHex,
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide,
            emissive: colorHex,
            emissiveIntensity: 0.2
        });
        const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
        tube.userData = { isHyperedge: true, edgeData: edgeData, colorHex: colorHex };
        scene.add(tube);

        // Track for raycasting
        hyperedgeMeshes.push(tube);

        // Add label at midpoint if provided
        if (label) {
            const labelSprite = createTextSprite(label, colorHex);
            labelSprite.position.copy(mid);
            labelSprite.position.y += 30;
            labelSprite.scale.set(150, 37, 1);
            labelSprite.userData = { isHyperedge: true, edgeData: edgeData, parentTube: tube };
            scene.add(labelSprite);
            hyperedgeMeshes.push(labelSprite); // Also make label clickable
        }

        return tube;
    }

    // Helper: Create text label sprite
    function createTextSprite(text, colorHex) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 128;

        // Background
        context.fillStyle = 'rgba(0, 0, 0, 0.7)';
        context.roundRect(0, 0, canvas.width, canvas.height, 10);
        context.fill();

        // Border
        context.strokeStyle = '#' + colorHex.toString(16).padStart(6, '0');
        context.lineWidth = 4;
        context.roundRect(2, 2, canvas.width - 4, canvas.height - 4, 8);
        context.stroke();

        // Text
        context.font = 'bold 36px Arial';
        context.fillStyle = '#ffffff';
        context.textAlign = 'center';
        context.textBaseline = 'middle';

        // Truncate text if too long
        let displayText = text || 'Unnamed';
        if (displayText.length > 25) {
            displayText = displayText.substring(0, 22) + '...';
        }
        context.fillText(displayText, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(200, 50, 1);
        return sprite;
    }

    // Helper: Create Visual Node
    function createNode(data, x, y, z, colorHex, type) {
        const position = new THREE.Vector3(x, y, z);
        nodePositions.set(data.id, position);

        // Size based on type
        const size = type === 'root' ? 30 : type === 'phase' ? 20 : type === 'item' ? 12 : 8;

        // Create glowing sphere
        const geometry = new THREE.SphereGeometry(size, 32, 32);

        // Special materials for root (sun) and phases (planets)
        let material;
        if (type === 'root') {
            // Sun - bright yellow/orange with intense glow
            material = new THREE.MeshBasicMaterial({
                color: 0xffdd44,
                transparent: false
            });
        } else {
            material = new THREE.MeshPhongMaterial({
                color: colorHex,
                emissive: colorHex,
                emissiveIntensity: 0.3,
                shininess: 100
            });
        }

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(position);
        mesh.userData = { nodeData: data, type: type, colorHex: colorHex };
        scene.add(mesh);

        // Track mesh for raycasting
        nodeMeshes.push(mesh);

        // ROOT: Add animated sun corona
        if (type === 'root') {
            // Inner corona glow
            const coronaGeometry1 = new THREE.SphereGeometry(size * 1.4, 32, 32);
            const coronaMaterial1 = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.4,
                side: THREE.BackSide
            });
            const corona1 = new THREE.Mesh(coronaGeometry1, coronaMaterial1);
            corona1.position.copy(position);
            scene.add(corona1);

            // Outer corona glow (animated)
            const coronaGeometry2 = new THREE.SphereGeometry(size * 2, 32, 32);
            const coronaMaterial2 = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            sunCorona = new THREE.Mesh(coronaGeometry2, coronaMaterial2);
            sunCorona.position.copy(position);
            scene.add(sunCorona);

            // Sun flare ring
            const flareGeometry = new THREE.RingGeometry(size * 2.5, size * 3.5, 64);
            const flareMaterial = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const flare = new THREE.Mesh(flareGeometry, flareMaterial);
            flare.position.copy(position);
            flare.lookAt(camera.position);
            scene.add(flare);
        }

        // PHASE: Add planetary rings
        if (type === 'phase') {
            // Main planetary ring
            const ringGeometry = new THREE.RingGeometry(size * 1.8, size * 2.8, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(position);
            ring.rotation.x = Math.PI / 2.5; // Tilt the ring
            ring.rotation.z = Math.random() * 0.5; // Slight random tilt
            scene.add(ring);

            // Outer faint ring
            const outerRingGeometry = new THREE.RingGeometry(size * 3, size * 3.5, 64);
            const outerRingMaterial = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
            outerRing.position.copy(position);
            outerRing.rotation.x = Math.PI / 2.5;
            outerRing.rotation.z = ring.rotation.z;
            scene.add(outerRing);

            // Atmospheric glow
            const atmoGeometry = new THREE.SphereGeometry(size * 1.15, 32, 32);
            const atmoMaterial = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmoGeometry, atmoMaterial);
            atmosphere.position.copy(position);
            scene.add(atmosphere);
        }

        // Add text label sprite
        const label = createTextSprite(data.name, type === 'root' ? 0xffdd44 : colorHex);
        label.position.set(x, y + size + 40, z);
        label.userData.parentMesh = mesh; // Link label to its node mesh
        label.userData.nodeData = data; // Store node data on label too
        scene.add(label);

        // Register label for raycasting (clickable labels)
        labelSprites.push(label);
        nodeToLabel.set(mesh, label);
    }

    // Helper: Create Connection Line
    function createConnection(v1, v2, color, opacity) {
        const material = new THREE.LineBasicMaterial({
            color: color,
            opacity: opacity,
            transparent: true
        });
        const points = [v1, v2];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line);
    }

    function onWindowResize() {
        if (!camera || !renderer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        // Animate sun corona pulsing
        if (sunCorona) {
            coronaTime += 0.02;
            const pulse = 1 + Math.sin(coronaTime) * 0.15;
            sunCorona.scale.setScalar(pulse);
            sunCorona.material.opacity = 0.15 + Math.sin(coronaTime * 1.5) * 0.08;
        }

        // Auto-spin
        if (autoSpin && controls) {
            controls.autoRotate = true;
            controls.autoRotateSpeed = 2.0;
        } else if (controls) {
            controls.autoRotate = false;
        }

        if (controls) controls.update();
        if (renderer && scene && camera) {
            renderer.render(scene, camera);
        }
    }

    // Initialize 3D button handler - ensure DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init3DButton);
    } else {
        init3DButton();
    }

    // Also try after a short delay as fallback
    setTimeout(init3DButton, 500);

    // Expose refresh3DData to global scope for sort integration
    window.refresh3DData = refresh3DData;

})(); // End IIFE
</script>

</body>
</html>
<!-- Cache buster: 1764725799 -->
