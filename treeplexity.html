<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TreeListy - Universal Project Decomposition by geej</title>
    <!--
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    TreeListy v2.11.0 | Build 196 | 2025-11-29
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Universal Project Decomposition Tool
    - 17 specialized patterns (Generic, Philosophy, Sales, Veo3, Sora2, etc.)
    - AI-powered (Claude, Gemini, ChatGPT) with tunable personas
    - Pattern Translation Engine with shadow data preservation
    - Modern collapsible sidebar UI (icon-based navigation)
    - Smart JSON save with pattern-based filenames
    - LocalStorage auto-save every 2 minutes
    - 50-state undo system
    - PWA-ready (installable on desktop & mobile)

    Changelog (Build 196): ðŸ”§ Fix Merge Undo Function
    - FIX: Changed pushToUndoStack() to saveToHistory() (correct function name)
    - FIX: Merge now saves undo state before making changes

    Previous (Build 195): ðŸ” Debug Merge Button Click

    Previous (Build 194): ðŸ”§ Fix Merge Button Variable Scope

    Previous (Build 193): ðŸ”§ IIFE with DOM Ready Check

    Previous (Build 192): ðŸ’° Hide $0 Cost in Canvas View
    - FIX: Cost badge only shows in canvas if pattern supports cost AND cost > 0

    Previous (Build 191): âœ¨ New "Explore TreeListy" Starter Tree
    - NEW: Self-describing starter tree teaches TreeListy by example
    - NEW: 4 phases: Discover, Create, Enhance, Share

    Previous (Build 190): ðŸŽ¨ Layout Fix - Edges Panel vs Info Panel

    Previous (Build 189): ðŸ“§ Improved Collaboration Email & Merge UI
    - NEW: "Merge Branch" button in sidebar to paste collaboration URLs
    - NEW: "Copy Email" button copies rich HTML with clickable button

    Previous (Build 188): ðŸ”€ Smart Merge with Project Validation
    - NEW: Detects if wrong project is loaded when merging
    - NEW: Shows expected vs current project name comparison

    Previous (Build 187): ðŸ¤ Complete Collaboration System (Branch & Merge)
    - NEW: ðŸ“¥ ?branch= URL detection and parsing on page load
    - NEW: ðŸ¤ Branch editing mode with purple banner for collaborators
    - NEW: ðŸ“¤ "Share Back" button to send edits to original author
    - NEW: ðŸ”€ Merge modal for accepting incoming collaboration changes

    Previous (Build 186): ðŸ¤ Share for Collaboration UI
    - NEW: ðŸ”‘ getDeviceFingerprint() - Canvas-based device ID for contributor tracking
    - NEW: ðŸ—ºï¸ getAncestryPath(nodeId) - Get breadcrumb path to any node
    - NEW: ðŸ“¦ extractSubtree(nodeIds, hyperedgeId) - Extract nodes for sharing
    - NEW: ðŸ”— generateBranchURL(branch) - Create shareable ?branch= URL
    - NEW: ðŸ“ Size validation - Blocks sharing if subtree > 8KB URL limit
    - FOUNDATION: isBranchMode() check, currentBranch state variable

    Previous (Build 184): ðŸ› Fix New Project Not Updating Canvas
    - FIX: ðŸ› "New Project" now calls renderCanvas() to update canvas view immediately
    - Previously only tree view was updated, canvas stayed on old project

    Previous (Build 183): ðŸ‘ï¸ Hyperedge Hover Dims Unrelated Nodes
    - NEW: ðŸ” Hovering a hyperedge now dims all nodes NOT in that hyperedge (0.25 opacity)
    - NEW: âœ¨ Member nodes get highlighted with purple glow on hover
    - ENHANCED: Smooth 0.3s transition for opacity and glow effects
    - FIX: ðŸ› Fixed dataset.itemId lookup (was using wrong attribute name)

    Previous (Build 181): ðŸ”§ Fix Hyperedge/Connection Clipping on Zoom Out
    - FIX: ðŸ› Hyperedges and connections were clipped to small rectangle on zoom out
    - FIX: canvas-connections SVG now uses 20000x20000px area (like dependency-svg)
    - FIX: Added SVG_OFFSET (5000px) to all drawing coordinates
    - IMPROVED: Hyperedges now render correctly at any zoom level (10%-500%)

    Previous (Build 180): ðŸ”— Hyperedge Visibility Management
    - NEW: ðŸ‘ï¸ Hover dimming - other hyperedges fade when you hover one
    - NEW: ðŸŽ¯ Focus View button in hyperedge info modal to isolate view
    - NEW: ðŸ”— "Edges" button in canvas toolbar to manage hyperedge visibility
    - NEW: Visibility panel with checkboxes, Show All/Hide All, focus shortcuts
    - ENHANCED: Each hyperedge wrapped in SVG group for better interaction

    Previous (Build 179): ðŸ’Š Capsule Geometry for 2-Node Hyperedges
    - NEW: ðŸŽ¯ Deep Dive auto-focuses on hyperedge members
    - NEW: Auto-arranges analyzed nodes in clean layout
    - FIX: ðŸ› Hyperedge now clickable

    Previous (Build 176): ðŸ§  AI-Powered Relationship Analysis
    - NEW: ðŸ§  AI analyzes selected nodes and DISCERNS the philosophical relationship
    - NEW: AI generates: relationshipType, dialecticalRelation, argumentativeFlow, conceptualBridge
    - NEW: AI identifies: philosophical tension and potential synthesis

    Previous (Build 175): ðŸ›ï¸ Descriptive Hyperedge Labels
    - NEW: ðŸ›ï¸ Hyperedge labels show dialectical relation type
    - NEW: ðŸ‘† "click to explore relationship" hint below hyperedge label

    Previous (Build 174): ðŸŽ¨ Hyperedge Visual Enhancement
    - NEW: ðŸŽ¨ Hyperedge color permeates member nodes (tinted border + glow)
    - NEW: ðŸ“¦ Hyperedge hull includes both selected nodes AND generated subitems (Venn diagram)
    - NEW: ðŸ–±ï¸ Clickable hyperedges - shows philosophy relationship info panel

    Previous (Build 173): ðŸ”— Fix Hyperedge Visualization
    - FIX: ðŸ› Hyperedges not visible after Deep Dive Analysis
    - FIX: Division by zero in padding calculation when nodes overlap
    - FIX: NaN coordinates causing polygon to not render

    Previous (Build 169): ðŸŽ“ Deep Dive Analysis (Structured Scholar)
    - NEW: Right-click â†’ "Deep Dive Analysis" on any node(s)
    - NEW: Generates 2-4 subItems per node (objections, implications, hidden premises)
    - NEW: Auto-fills missing fields (speaker, keyTerms, textualReference)
    - NEW: Multi-select support - Ctrl+click nodes, then Deep Dive all at once
    - NEW: Auto-creates purple hyperedge linking analyzed nodes
    - NEW: Philosophy-specific prompts using Structured Scholar technique
    - NEW: Generic pattern support for non-philosophy deep dives

    Previous (Build 168): Fix Undefined Text in Tree/Canvas Views
    - FIX: ðŸ› Phase subtitle undefined - Now conditionally rendered
    - FIX: ðŸ› Item/Node icons undefined - Added fallbacks (ðŸ“‹, ðŸ“„, ðŸŒ³)

    Previous (Build 167): Philosophy Structured Scholar Prompt (+4.7% depth)
    - ENHANCED: ðŸŽ“ Philosophy prompts use "Structured Scholar" technique (93% vs 88% baseline)
    - NEW: Mandatory NAMED secondary sources requirement (e.g., "Vlastos", "Williams")
    - NEW: Standard objections must cite specific philosophers
    - NEW: Expanded itemTypes: implicit-premise, distinction, thought-experiment, objection
    - NEW: Required metadata: tradition, method, keyTerms, interlocutors, secondarySources
    - RESEARCH: Tested 10 meta-prompting techniques; Structured Scholar won

    Changelog (Build 166): Philosophy Pattern Prompt Optimization
    - ENHANCED: ðŸ§  Philosophy pattern prompts optimized based on A/B testing (+10% structural fidelity)
    - NEW: Explicit itemType examples with common error warnings
    - FIX: "Bee analogy = question" misclassification now explicitly corrected
    - IMPROVED: Deep Mode philosophy instructions with full JSON examples

    Previous (Build 165): Cognitive Citadel Foundation
    - NEW: ðŸ›¡ï¸ Migration System - Schema versioning for backward compatibility
    - NEW: ðŸ›¡ï¸ Provenance Stamping - All nodes track origin (user/ai-import/legacy)
    - NEW: ðŸ›¡ï¸ Dialectic Mode - Forces AI to identify assumptions & counter-arguments
    - NEW: Phenomenology array on nodes (future: capture "residue" that doesn't fit structure)
    - NEW: Metrics stub on nodes (future: attention economics tracking)
    - FIX: AI-imported content now properly tagged with provenance

    Previous (Build 164): Model Selector + Latest Model IDs
    - NEW: ðŸŽ¯ Model Selector Dropdown - Choose specific AI models per call
    - NEW: Claude: Haiku 3 (server), Haiku 3.5, Sonnet 4, Opus 4
    - NEW: Gemini: Flash 2.0, Pro 2.5 Preview
    - NEW: ChatGPT: 4o-mini, GPT-4o, o1 reasoning
    - FIX: Updated Gemini models to latest (2.0-flash stable, 2.5-pro-preview)

    Previous (Build 163): Fix undefined response error + null guard
    - FIX: Added null guard for AI response to prevent "Cannot read properties of undefined"
    - FIX: Better error message when AI returns empty/undefined response
    - INFO: Anthropic intentionally blocks direct browser API calls (no CORS headers)
    - INFO: This is NOT a bug - it's their security architecture requiring server proxy

    Previous (Build 162): AGGRESSIVE Large Tree Handling
    - FIX: ðŸ›‘ Large trees (30+ items) now FORCE treeUpdate: null in enhance mode
    - FIX: Removed instruction to "echo baseline" that was causing 32K responses

    Previous (Build 161): Smart Fallback for Large Trees
    - NEW: ðŸš€ Auto-fallback to fast mode on timeout or response cutoff
    - NEW: Large tree detection (50+ items) - warns about potential timeout
    - NEW: Timeout auto-retry - switches to fast mode and retries automatically

    Previous (Build 160): Wizard Token Optimization + Claude CORS Fix
    - FIX: ðŸª„ Wizard "response cut off" bug - Added STRONG instruction to NOT echo entire tree
    - FIX: ðŸ”„ Claude API routing - Anthropic blocks ALL direct browser calls (CORS policy)
    - INFO: Deep Mode for Claude MUST use Netlify proxy (10s timeout applies)
    - INFO: For unlimited Deep Mode, use Gemini (allows direct browser API calls)

    Previous (Build 158): Based on Gemini code review recommendations
    - FIX: ðŸ› Hyperedges Data Loss Bug - importAnalyzedTree and executeFlexibleImport now initialize hyperedges: []
    - FIX: âš¡ Performance - drawHyperedges now uses O(1) Map lookup instead of O(N) recursive getNodeById
    - NEW: ðŸ“Š Deep Mode Progress UI - Real-time chunk-by-chunk progress bar during semantic analysis
    - NEW: ðŸ”— Hyperedge Management UI - Delete hyperedges from root node info panel (no more JSON editing!)
    - Added window.deleteHyperedge() global handler with undo support

    Previous (Build 157):
    - FIX: ðŸ”‘ API Key Storage Bug - EmbeddingManager now uses correct localStorage key format
    - Fixed: Changed 'openai-api-key' â†’ 'openai_api_key' (underscore format)
    - Fixed: Changed 'gemini-api-key' â†’ 'gemini_api_key' (underscore format)
    - Your saved API keys from Build 155 and earlier are now accessible again!

    Previous (Build 156):
    - NEW: ðŸ§  Semantic Chunking Engine - NLP-powered text segmentation for large documents
    - NEW: SemanticChunker class with cosine similarity and 90th percentile adaptive thresholding
    - NEW: EmbeddingManager service supporting OpenAI text-embedding-3-small & Gemini text-embedding-004
    - NEW: Chunk-by-chunk processing in Quick Mode and Deep Mode (prevents hallucinations on large files)
    - NEW: Visual chunk distribution UI showing detected semantic sections
    - ENHANCED: Automatic structural fallback (Markdown headers â†’ paragraphs â†’ lines) when no embedding provider
    - TECH: Sliding window context buffering, batch API processing (max 20 per batch)
    - TECH: Silent error handling with graceful degradation

    Previous (Build 155):
    - FIX: Cluster-by dropdown scope issue - Moved function to global scope
    - Pattern-specific options now properly populate for Philosophy, Film, Veo3, Sora2, Sales, Roadmap
    - Function now accessible from all pattern switch and file load handlers

    Previous (Build 154):
    - FIX: Cluster-by dropdown now properly dynamic (removed hardcoded HTML)
    - NEW: Philosophy sort options - speaker, argument type, validity, school, claim name
    - NEW: Film sort options - visual style, lighting mood, camera movement, AI platform, duration
    - ENHANCED: Cluster-by and sort dropdowns now fully pattern-aware

    Previous (Build 153):
    - FIX: Pattern-specific clustering - Dropdown now shows relevant fields per pattern
    - Philosophy: argumentType, validity, speaker, philosophicalSchool
    - Film: visualStyle, lightingMood, cameraMovement, aiPlatform
    - Veo3/Sora2: Flow mode, beat type, cameo, physics complexity
    - Sales: leadStage, leadSource, dealSize
    - ENHANCED: Dynamic cluster-by options update on pattern switch and file load

    Previous (Build 152):
    - NEW: Wolfram-style Hyperedges - N-ary relationships (montage, argument, theme, etc.)
    - NEW: Convex Hull Visualization - Hyperedges render as semi-transparent blobs in Canvas View
    - NEW: Multi-select Hyperedge Creation - Ctrl+Click nodes, right-click "Create Hyperedge"
    - NEW: Provenance Stamping - All nodes track creation source (ai-sonnet, ai-gemini, user, etc.)
    - NEW: Root-level Hyperedge Storage - Cross-phase relationships (Film flashbacks, Philosophy refutations)
    - ENHANCED: Graham Scan Algorithm - O(n log n) convex hull computation for hyperedge visualization

    Previous (Build 151):
    - FIX: Smart Suggest for videoPrompt - No more "Okay, buckle up!" conversational fluff
    - NEW: Veo3/Sora2 Smart Suggest - Full field suggestions for new AI video patterns

    Previous (Build 150):
    - NEW: Veo3 (Google) & Sora2 (OpenAI) AI Video Patterns - Platform-specific workflows
    - NEW: Metadata Clustering in Canvas - Group nodes by type, owner, status, cost, or date
    - ENHANCED: Force-Directed Layout - Barnes-Hut O(n log n), collision detection, 500 iterations
    - FIX: Extended Thinking temperature must be 1 (Claude API requirement)

    Previous (Build 148):
    - NEW: Collapsible AI Tools Sidebar - Icon-based left-docked navigation (60px â†’ 260px on hover)
    - NEW: Modern Chat UI - Neutral slate grey for AI, vibrant primary for user (ChatGPT aesthetic)
    - NEW: Typography Improvements - Larger titles (17px), better hierarchy, improved scannability
    - NEW: Zoom controls integrated into sidebar above Settings (fixes layout conflict)
    - ENHANCEMENT: Reclaimed ~200px canvas width when sidebar collapsed
    - FIX: Removed standalone zoom panel that was obstructing AI sidebar

    Previous (Build 147):
    - NEW: Pattern Translation Engine - Convert Generic â†’ Sales (and reverse) with field mapping
    - NEW: Shadow Data Preservation - Original data backed up during translation
    - FIX: Temperature parameter now correctly applied from Creativity slider

    Previous (Build 146):
    - NEW: AI Tuner - Customize AI tone, verbosity, creativity, and custom instructions
    - NEW: Persistent AI personas - Settings saved in tree JSON and travel with file
    - NEW: Live preview in AI Settings modal shows before/after prompt transformation

    Previous (Build 145):
    - NEW: Filesystem pattern "Digital Librarian" AI - Smart Suggest for all file metadata fields
    - COMPLETE: All 15 patterns now have pattern-specific Smart Suggest coverage

    Previous (Build 144):
    - FIX: Canvas View dependency arrows for hidden phases (no more random purple lines)
    - FIX: Philosophy Pattern AI Analysis using correct persona (not generic PM)
    - FIX: Pattern loading from JSON handles both string and object formats

    Previous (Build 143):
    - FIX: CORS protection for ALL AI providers (Gemini, ChatGPT, Claude)
    - FIX: Clear error messages when using Gemini/ChatGPT from local files
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -->

    <!-- PWA Configuration -->
    <link rel="manifest" href="./manifest.json" id="pwa-manifest">
    <script>
        // Remove manifest link on file:// protocol to prevent CORS errors
        if (window.location.protocol === 'file:') {
            document.getElementById('pwa-manifest')?.remove();
        }
    </script>
    <meta name="theme-color" content="#6366f1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TreeListy">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%236366f1'/><text x='50' y='70' font-size='70' text-anchor='middle' fill='white'>ðŸŒ³</text></svg>">
    <meta name="description" content="Visual project management and hierarchical data organization tool with AI-powered insights">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            /* Default Theme */
            --treeplex-primary: #6366f1;
            --treeplex-primary-dark: #4f46e5;
            --phase-0: #5FA463;
            --phase-0-light: #6FB56E;
            --phase-0-dark: #4A8C4E;
            --phase-1: #3B8FCC;
            --phase-1-light: #4A9DD9;
            --phase-1-dark: #2B7AB8;
            --phase-2: #D68A2E;
            --phase-2-light: #E09940;
            --phase-2-dark: #B8741F;
            --text-primary: #E8EAF0;
            --text-secondary: #9DA3B4;
            --border: #3A3F4D;
            --bg: #1E2128;
            --card-bg: #2A2F3C;
            --card-bg-light: #32374A;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.5);
            --shadow-xl: 0 12px 40px rgba(0,0,0,0.6);
        }

        /* THEME: STEAMPUNK */
        [data-theme="steampunk"] {
            --treeplex-primary: #b8860b;
            --treeplex-primary-dark: #8b6914;
            --phase-0: #cd7f32;
            --phase-0-light: #d4924e;
            --phase-0-dark: #8b5a2b;
            --phase-1: #b87333;
            --phase-1-light: #d4924e;
            --phase-1-dark: #8b4513;
            --phase-2: #daa520;
            --phase-2-light: #ffd700;
            --phase-2-dark: #b8860b;
            --text-primary: #f5deb3;
            --text-secondary: #d2b48c;
            --border: #8b4513;
            --bg: #2b1810;
            --card-bg: #3e2315;
            --card-bg-light: #4a2817;
        }

        /* THEME: POWERPUFF GIRLS */
        [data-theme="powerpuff"] {
            --treeplex-primary: #ff6eb4;
            --treeplex-primary-dark: #ff1493;
            --phase-0: #ff69b4;
            --phase-0-light: #ffb6d9;
            --phase-0-dark: #c71585;
            --phase-1: #87ceeb;
            --phase-1-light: #b0e0e6;
            --phase-1-dark: #4682b4;
            --phase-2: #9acd32;
            --phase-2-light: #c7ea46;
            --phase-2-dark: #6b8e23;
            --text-primary: #2d2d2d;
            --text-secondary: #666666;
            --border: #ffb6d9;
            --bg: #fff0f5;
            --card-bg: #ffffff;
            --card-bg-light: #fffafd;
        }

        /* THEME: TRON */
        [data-theme="tron"] {
            --treeplex-primary: #00ffff;
            --treeplex-primary-dark: #00d4d4;
            --phase-0: #00ffff;
            --phase-0-light: #66ffff;
            --phase-0-dark: #00cccc;
            --phase-1: #00d4ff;
            --phase-1-light: #66e0ff;
            --phase-1-dark: #0099cc;
            --phase-2: #ff6600;
            --phase-2-light: #ff9944;
            --phase-2-dark: #cc5200;
            --text-primary: #e0ffff;
            --text-secondary: #7dd3ff;
            --border: #00ffff;
            --bg: #000000;
            --card-bg: #0a0a0a;
            --card-bg-light: #141414;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            overflow: auto;
        }

        ::selection {
            background: var(--treeplex-primary);
            color: white;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            background: #252931;
            border-bottom: 1px solid var(--border);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .logo {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-right: 40px;
        }

        .logo-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 24px;
            font-weight: 700;
            color: var(--treeplex-primary);
            letter-spacing: -0.5px;
        }

        .logo-subtitle {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-left: 46px;
        }

        /*         .confidential {
        /*             padding: 4px 12px;
        /*             background: #fff5f5;
        /*             border: 1px solid #ffccc7;
        /*             border-radius: 6px;
        /*             font-size: 11px;
        /*             font-weight: 600;
        /*             color: #d32f2f;
        /*             letter-spacing: 0.5px;
        /*         } */

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .control-section {
            display: flex;
            gap: 6px;
            padding: 0 12px;
            border-right: 1px solid var(--border);
        }

        .control-section:last-child {
            border-right: none;
            padding-right: 0;
        }

        .control-section:first-child {
            padding-left: 0;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: var(--card-bg);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn:hover {
            background: var(--card-bg-light);
            border-color: var(--treeplex-primary);
        }

        .btn-primary {
            background: var(--treeplex-primary);
            color: white;
            border-color: var(--treeplex-primary);
        }

        .btn-primary:hover {
            background: var(--treeplex-primary-dark);
        }
/* Pattern Selector */        .pattern-selector {            position: relative;            display: inline-block;        }        .pattern-select {            padding: 8px 12px;            border: 1px solid var(--border);            background: var(--card-bg);            color: var(--text-primary);            border-radius: 6px;            font-size: 13px;            font-weight: 500;            cursor: pointer;            font-family: inherit;            min-width: 180px;        }        .pattern-select:hover {            background-color: var(--card-bg-light);            border-color: var(--treeplex-primary);        }        .pattern-select:focus {            outline: none;            border-color: var(--treeplex-primary);            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);        }

        /* Pan/Zoom Controls */
        .zoom-controls {
            position: fixed;
            top: 90px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: var(--card-bg);
            padding: 12px;
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border);
        }

        .zoom-btn {
            width: 44px;
            height: 44px;
            border: 1px solid var(--border);
            background: var(--card-bg-light);
            color: var(--text-primary);
            border-radius: 8px;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: inherit;
        }

        .zoom-btn:hover {
            background: var(--treeplex-primary);
            border-color: var(--treeplex-primary);
            color: white;
            transform: scale(1.05);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-level {
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            padding: 8px 0;
            border-top: 1px solid var(--border);
            margin-top: 4px;
        }

        /* Tree Container */
        .tree-container {
            padding: 0;
            overflow: hidden;
            min-height: calc(100vh - 70px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background:
                repeating-linear-gradient(45deg, transparent, transparent 40px, rgba(0, 166, 125, 0.03) 40px, rgba(0, 166, 125, 0.03) 80px),
                repeating-linear-gradient(-45deg, transparent, transparent 40px, rgba(59, 143, 204, 0.02) 40px, rgba(59, 143, 204, 0.02) 80px),
                linear-gradient(180deg, #1A1D24 0%, #1E2128 50%, #1A1D24 100%);
            cursor: grab;
        }

        .tree-container.panning {
            cursor: grabbing;
        }

        .tree-transform-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center center;
            transition: transform 0.2s ease-out;
            min-width: 100%;
            min-height: 100%;
        }

        .tree-container::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 166, 125, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(59, 143, 204, 0.06) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(214, 138, 46, 0.04) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }

        .dependency-svg {
            position: absolute;
            top: -5000px;
            left: -5000px;
            width: 20000px;
            height: 20000px;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .dependency-line {
            fill: none;
            stroke: var(--treeplex-primary);
            stroke-width: 3;
            stroke-dasharray: 8, 4;
            opacity: 0.6;
            transition: all 0.3s;
            animation: dash-flow 20s linear infinite;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
        }

        .dependency-line:hover {
            opacity: 1;
            stroke-width: 4;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25));
        }

        .dependency-line.phase-0 {
            stroke: var(--phase-0-dark);
        }

        .dependency-line.phase-1 {
            stroke: var(--phase-1-dark);
        }

        .dependency-line.phase-2 {
            stroke: var(--phase-2-dark);
        }

        .dependency-line.cross-phase {
            stroke: var(--treeplex-primary-dark);
            opacity: 0.7;
            stroke-width: 3.5;
        }

        @keyframes dash-flow {
            to {
                stroke-dashoffset: -100;
            }
        }

        .tree {
            display: flex;
            flex-direction: row;
            gap: 40px;
            align-items: center;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }

        .tree-level {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 12px;
            padding: 20px;
            border-radius: 12px;
            transition: background 0.3s;
        }

        /* Phase-specific backgrounds - subtle gradients */
        .tree-level:has(.phase-0) {
            background: linear-gradient(180deg, rgba(95, 164, 99, 0.03) 0%, rgba(95, 164, 99, 0.08) 100%);
        }

        .tree-level:has(.phase-1) {
            background: linear-gradient(180deg, rgba(59, 143, 204, 0.03) 0%, rgba(59, 143, 204, 0.08) 100%);
        }

        .tree-level:has(.phase-2) {
            background: linear-gradient(180deg, rgba(214, 138, 46, 0.03) 0%, rgba(214, 138, 46, 0.08) 100%);
        }

        .tree-node {
            background: linear-gradient(145deg, var(--card-bg-light), var(--card-bg));
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: var(--shadow-md), 0 0 0 1px rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            min-width: 280px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .tree-node:hover {
            box-shadow: var(--shadow-lg), 0 0 0 1px rgba(255,255,255,0.1);
            transform: translateX(4px) translateY(-2px);
            border-color: var(--treeplex-primary);
            background: linear-gradient(145deg, #3A3F52, var(--card-bg-light));
        }

        .tree-node::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 16px;
            background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
            pointer-events: none;
        }

        .tree-node.root {
            background: linear-gradient(135deg, #4A5568 0%, #2D3748 100%);
            color: white;
            font-size: 20px;
            font-weight: 600;
            min-width: 240px;
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(255, 255, 255, 0.15);
        }

        .tree-node.root:hover {
            box-shadow: var(--shadow-xl);
            background: linear-gradient(135deg, #556577 0%, #3A4556 100%);
        }

        .tree-node.root .node-subtitle {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.85;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 2px;
        }

        /* FILESYSTEM PATTERN: Vertical Tree Layout */
        .tree.filesystem-tree {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 20px;
        }

        .tree.filesystem-tree .tree-level {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 0;
            background: none !important;
        }

        .tree.filesystem-tree .tree-node {
            min-width: auto;
            width: 100%;
            max-width: 800px;
            margin: 4px 0;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.15s;
            cursor: pointer;
        }

        .tree.filesystem-tree .tree-node:hover {
            transform: none;
            background: rgba(99, 102, 241, 0.15);
        }

        .tree.filesystem-tree .tree-node.item,
        .tree.filesystem-tree .tree-node.subtask {
            padding: 6px 10px;
            background: transparent;
            border: none;
            box-shadow: none;
        }

        .tree.filesystem-tree .tree-node.item:hover,
        .tree.filesystem-tree .tree-node.subtask:hover {
            background: rgba(255, 255, 255, 0.05);
            box-shadow: none;
        }

        .tree.filesystem-tree .filesystem-indent-0 { margin-left: 0px; }
        .tree.filesystem-tree .filesystem-indent-1 { margin-left: 40px; }
        .tree.filesystem-tree .filesystem-indent-2 { margin-left: 80px; }
        .tree.filesystem-tree .filesystem-indent-3 { margin-left: 120px; }
        .tree.filesystem-tree .filesystem-indent-4 { margin-left: 160px; }
        .tree.filesystem-tree .filesystem-indent-5 { margin-left: 200px; }
        .tree.filesystem-tree .filesystem-indent-6 { margin-left: 240px; }
        .tree.filesystem-tree .filesystem-indent-7 { margin-left: 280px; }
        .tree.filesystem-tree .filesystem-indent-8 { margin-left: 320px; }
        .tree.filesystem-tree .filesystem-indent-9 { margin-left: 360px; }
        .tree.filesystem-tree .filesystem-indent-10 { margin-left: 400px; }

        .tree.filesystem-tree .node-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tree.filesystem-tree .expand-toggle {
            font-size: 14px;
            margin-right: 6px;
            cursor: pointer;
            padding: 2px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 16px;
            user-select: none;
            transition: all 0.2s;
        }

        .tree.filesystem-tree .expand-toggle:hover {
            color: var(--accent-primary);
            transform: scale(1.2);
        }

        .tree.filesystem-tree .node-icon {
            font-size: 16px;
            margin-right: 4px;
        }

        .tree.filesystem-tree .node-title,
        .tree.filesystem-tree .item-name {
            font-size: 13px;
            font-weight: 500;
        }

        .tree.filesystem-tree .node-subtitle,
        .tree.filesystem-tree .item-description {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .tree-node.phase {
            border-left: 6px solid;
            min-width: 260px;
            position: relative;
            overflow: hidden;
        }

        .tree-node.phase::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: linear-gradient(180deg, var(--phase-color-light), var(--phase-color-dark));
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
        }

        .tree-node.phase-0 {
            border-left-color: var(--phase-0);
            --phase-color-light: var(--phase-0-light);
            --phase-color-dark: var(--phase-0-dark);
        }

        .tree-node.phase-0:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-0);
        }

        .tree-node.phase-1 {
            border-left-color: var(--phase-1);
            --phase-color-light: var(--phase-1-light);
            --phase-color-dark: var(--phase-1-dark);
        }

        .tree-node.phase-1:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-1);
        }

        .tree-node.phase-2 {
            border-left-color: var(--phase-2);
            --phase-color-light: var(--phase-2-light);
            --phase-color-dark: var(--phase-2-dark);
        }

        .tree-node.phase-2:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-2);
        }

        .tree-node.item {
            min-width: 320px;
            max-width: 360px;
            backdrop-filter: blur(4px);
        }

        /* Subtask container - appears below parent item with animation */
        .subtask-container {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            margin-bottom: 8px;
            padding-left: 10px;
            justify-content: flex-start;
            flex-wrap: wrap;
            max-width: 100%;
            animation: slideDownFade 0.4s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            transform-origin: top center;
        }

        @keyframes slideDownFade {
            0% {
                opacity: 0;
                transform: translateY(-40px) scale(0.95);
                max-height: 0;
                filter: blur(6px) brightness(0.5);
            }
            60% {
                filter: blur(1px) brightness(0.9);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                max-height: 500px;
                filter: blur(0) brightness(1);
            }
        }

        /* Subtask styling - compact visual cards */
        .tree-node.item.subtask {
            min-width: 100px;
            max-width: 100px;
            width: 100px;
            min-height: 85px;
            background: rgba(255, 255, 255, 0.06);
            border-left: 3px solid rgba(0, 166, 125, 0.5);
            border-radius: 6px;
            padding: 10px;
            font-size: 10px;
            margin: 0;
            display: inline-flex;
            flex-direction: column;
            vertical-align: top;
            animation: subtaskReveal 0.35s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            opacity: 0;
            transform: translateY(-20px) scale(0.9);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tree-node.item.subtask:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 166, 125, 0.3);
            border-left-color: rgba(0, 166, 125, 0.8);
        }

        /* Staggered animation for subtasks */
        .tree-node.item.subtask:nth-child(1) { animation-delay: 0.05s; }
        .tree-node.item.subtask:nth-child(2) { animation-delay: 0.1s; }
        .tree-node.item.subtask:nth-child(3) { animation-delay: 0.15s; }
        .tree-node.item.subtask:nth-child(4) { animation-delay: 0.2s; }
        .tree-node.item.subtask:nth-child(5) { animation-delay: 0.25s; }
        .tree-node.item.subtask:nth-child(6) { animation-delay: 0.3s; }

        @keyframes subtaskReveal {
            0% {
                opacity: 0;
                transform: translateY(-20px) scale(0.9);
                filter: blur(4px) brightness(0.6);
            }
            70% {
                transform: translateY(2px) scale(1.01);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                filter: blur(0) brightness(1);
            }
        }


        /* Project management fields styling */
        .pm-field {
            font-size: 8px;
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            line-height: 1.1;
        }

        .pm-field-label {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .pm-field-value {
            font-weight: 600;
        }

        .pm-status {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
        }

        .pm-status.todo { background: rgba(156, 163, 175, 0.3); color: #9CA3AF; }
        .pm-status.inprogress { background: rgba(59, 130, 246, 0.3); color: #3B82F6; }
        .pm-status.completed { background: rgba(16, 185, 129, 0.3); color: #10B981; }
        .pm-status.blocked { background: rgba(239, 68, 68, 0.3); color: #EF4444; }

        .pm-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 2px;
        }

        .pm-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            transition: width 0.3s;
        }

        /* Expand/Collapse toggle for items with subtasks */
        .expand-toggle {
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
            display: inline-block;
        }

        .expand-toggle:hover {
            opacity: 1 !important;
            transform: scale(1.3) rotate(90deg);
        }

        /* Items with subtasks have a pointer cursor */
        .tree-node.item:has(.expand-toggle) {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tree-node.item:has(.expand-toggle):hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 166, 125, 0.2);
        }

        .tree-node.item:has(.expand-toggle):active {
            transform: translateY(0);
            transition: all 0.1s ease;
        }

        /* When item has expanded subtasks, add subtle glow and lift effect */
        .tree-node.item.has-expanded-subtasks {
            box-shadow: 0 0 20px rgba(0, 166, 125, 0.4), 0 6px 16px rgba(0, 0, 0, 0.3);
            border-left-color: rgba(0, 166, 125, 0.9);
            border-left-width: 4px;
            transform: translateY(-2px);
            z-index: 10;
            transition: all 0.3s ease;
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .node-icon {
            font-size: 28px;
            flex-shrink: 0;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
            transition: transform 0.3s;
        }

        .tree-node:hover .node-icon {
            transform: scale(1.1);
        }

        .node-content {
            flex: 1;
        }

        .node-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .node-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .node-cost {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-top: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .tree-node.root .node-cost {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.8));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .expand-toggle {
            font-size: 14px;
            opacity: 0.6;
            transition: transform 0.3s;
            margin-left: auto;
        }

        .tree-node.expanded .expand-toggle {
            transform: rotate(90deg);
        }

        .tree-node.collapsed .expand-toggle {
            transform: rotate(0deg);
        }

        /* Item specific */
        .item-name {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .item-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            border: 1px solid;
        }

        .badge-land {
            background: linear-gradient(135deg, rgba(95, 164, 99, 0.3), rgba(74, 140, 78, 0.2));
            color: #81C784;
            border-color: #4A8C4E;
        }
        .badge-engineering {
            background: linear-gradient(135deg, rgba(59, 143, 204, 0.3), rgba(43, 122, 184, 0.2));
            color: #64B5F6;
            border-color: #2B7AB8;
        }
        .badge-professional {
            background: linear-gradient(135deg, rgba(156, 117, 178, 0.3), rgba(128, 90, 150, 0.2));
            color: #BA68C8;
            border-color: #7B4A92;
        }
        .badge-corporate {
            background: linear-gradient(135deg, rgba(130, 130, 130, 0.3), rgba(100, 100, 100, 0.2));
            color: #B0B0B0;
            border-color: #707070;
        }
        .badge-equipment {
            background: linear-gradient(135deg, rgba(214, 138, 46, 0.3), rgba(184, 116, 31, 0.2));
            color: #FFB74D;
            border-color: #B8741F;
        }
        .badge-infrastructure {
            background: linear-gradient(135deg, rgba(233, 98, 158, 0.3), rgba(200, 70, 130, 0.2));
            color: #F48FB1;
            border-color: #C84682;
        }
        .badge-contingency {
            background: linear-gradient(135deg, rgba(229, 115, 115, 0.3), rgba(198, 80, 80, 0.2));
            color: #EF9A9A;
            border-color: #C65050;
        }

        .item-cost {
            font-size: 15px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Connection Lines */
        .tree-node::before {
            content: '';
            position: absolute;
            left: -40px;
            top: 50%;
            width: 40px;
            height: 2px;
            background: var(--border);
        }

        .tree-level:first-child .tree-node::before {
            display: none;
        }

        /* Same-phase dependency indentation indicator */
        .tree-node.item.has-same-phase-dependency::after {
            content: '';
            position: absolute;
            left: -20px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, transparent, var(--treeplex-primary) 20%, var(--treeplex-primary) 80%, transparent);
            opacity: 0.3;
            border-radius: 2px;
        }

        /* Enhanced visual for deeper dependency levels */
        .tree-node.item.has-same-phase-dependency[data-dependency-level="2"]::after {
            opacity: 0.4;
            width: 3px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="3"]::after {
            opacity: 0.5;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="4"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="5"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="6"]::after {
            opacity: 0.6;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency {
            border-left: 2px solid rgba(0, 166, 125, 0.2);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            right: -450px;
            top: 0;
            width: 450px;
            height: 100vh;
            background: var(--card-bg);
            border-left: 1px solid var(--border);
            box-shadow: -4px 0 12px rgba(0,0,0,0.5);
            transition: right 0.3s;
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        .info-panel.open {
            right: 0;
        }

        .info-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-title {
            font-size: 18px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: var(--bg);
        }

        .info-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .info-section {
            margin-bottom: 24px;
        }

        .info-section h4 {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .info-section p {
            font-size: 14px;
            line-height: 1.6;
        }

        .info-section .value {
            font-size: 20px;
            font-weight: 700;
            color: var(--treeplex-primary);
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            font-size: 18px;
            font-weight: 600;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            line-height: 1.7;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
        }

        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--treeplex-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 40px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            display: none;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            padding: 6px;
            min-width: 180px;
            z-index: 1000;
        }

        .context-item {
            padding: 10px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            color: var(--text-primary);
        }

        .context-item:hover {
            background: var(--card-bg-light);
            color: var(--treeplex-primary);
        }

        .context-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
            background: var(--bg);
            color: var(--text-primary);
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--treeplex-primary);
            box-shadow: 0 0 0 3px rgba(0, 166, 125, 0.2);
            background: var(--card-bg-light);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Splash Screen */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1d24 0%, #2a2f3c 50%, #1a1d24 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.5s ease-in;
        }

        #splash-screen.fade-out {
            animation: fadeOut 0.5s ease-out forwards;
        }

        .splash-logo {
            font-size: 72px;
            margin-bottom: 24px;
            animation: logoFloat 2s ease-in-out infinite;
        }

        .splash-title {
            font-size: 48px;
            font-weight: 700;
            color: var(--treeplex-primary);
            margin-bottom: 8px;
            letter-spacing: -1px;
        }

        .splash-subtitle {
            font-size: 20px;
            color: var(--text-secondary);
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 48px;
        }

        .splash-tagline {
            font-size: 16px;
            color: var(--text-primary);
            font-weight: 400;
            margin-bottom: 32px;
            opacity: 0.8;
        }

        .splash-loader {
            width: 200px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .splash-loader-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--phase-1));
            border-radius: 3px;
            animation: loadProgress 2s ease-in-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        @keyframes logoFloat {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes loadProgress {
            0% {
                width: 0%;
            }
            100% {
                width: 100%;
            }
        }

    /* ===================================================== */
    /* CANVAS VIEW STYLES */
    /* ===================================================== */

    .tree-view-container {
        display: block;
    }

    .tree-view-container.hidden {
        display: none !important;
    }

    .canvas-container {
        display: none;
        position: fixed;
        top: 140px;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        overflow: hidden;
        cursor: grab;
    }

    .canvas-container.active {
        display: block;
    }

    .canvas-container.grabbing {
        cursor: grabbing;
    }

    #canvas {
        width: 100%;
        height: 100%;
        position: relative;
        transform-origin: 0 0;
    }

    .canvas-connections {
        position: absolute;
        top: -5000px;
        left: -5000px;
        width: 20000px;
        height: 20000px;
        pointer-events: none;
        z-index: 1;
        overflow: visible;
    }

    /* Allow pointer events on hyperedge groups and their elements */
    .canvas-connections .hyperedge-group {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections polygon,
    .canvas-connections rect,
    .canvas-connections path.hyperedge-capsule {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections text {
        pointer-events: all;
        cursor: pointer;
    }

    /* Disable on connection lines (but not capsule paths) */
    .canvas-connections path:not(.hyperedge-capsule),
    .canvas-connections line {
        pointer-events: none;
    }

    .canvas-nodes-layer {
        position: relative;
        z-index: 2;
    }

    .canvas-node {
        position: absolute;
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        min-width: 280px;
        max-width: 320px;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, filter 0.15s ease;
        z-index: 10;
    }

    .canvas-node:hover {
        transform: translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }

    .canvas-node.dragging {
        cursor: grabbing;
        opacity: 0.9;
        z-index: 1000;
        transform: scale(1.05);
    }

    .canvas-node.selected {
        border-color: var(--treeplex-primary) !important;
        box-shadow:
            0 8px 32px rgba(99, 102, 241, 0.4),
            0 4px 16px rgba(99, 102, 241, 0.3),
            0 0 0 3px rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-2px);
    }

    .canvas-node.selected::before {
        content: 'âœ“';
        position: absolute;
        top: -10px;
        right: -10px;
        background: #6366f1;
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .canvas-node.dragging-group {
        opacity: 0.7;
        box-shadow: 0 0 20px rgba(99, 102, 241, 0.8);
    }

    .phase-zone {
        position: absolute;
        border: 3px dashed;
        border-radius: 20px;
        padding: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .phase-zone-header {
        font-weight: 700;
        font-size: 18px;
        margin-bottom: 12px;
        color: var(--text-primary);
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* Colored phase zones - vibrant colors */
    .phase-0 {
        border-color: #3B82F6;
        background: rgba(59, 130, 246, 0.08);
    }
    .phase-1 {
        border-color: #F59E0B;
        background: rgba(245, 158, 11, 0.08);
    }
    .phase-2 {
        border-color: #10B981;
        background: rgba(16, 185, 129, 0.08);
    }
    .phase-3 {
        border-color: #8B5CF6;
        background: rgba(139, 92, 246, 0.08);
    }
    .phase-4 {
        border-color: #EC4899;
        background: rgba(236, 72, 153, 0.08);
    }
    .phase-5 {
        border-color: #06B6D4;
        background: rgba(6, 182, 212, 0.08);
    }

    /* Grid overlay */
    .canvas-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .canvas-grid.active {
        opacity: 1;
    }

    .canvas-toolbar.active {
        display: flex !important;
    }

    .canvas-toolbar button:hover {
        background: rgba(99, 102, 241, 0.3) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .canvas-toolbar button:active {
        transform: translateY(0);
    }

    .canvas-toolbar select:hover {
        background: rgba(99, 102, 241, 0.25) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
    }

    .canvas-toolbar select option {
        background: #1a1a2e;
        color: #ffffff;
        padding: 10px;
        font-weight: 600;
    }

    .canvas-toolbar select option:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    /* ============================================================================
       AI SETTINGS MODAL - STYLING
       ============================================================================ */

    /* AI Settings Modal - Radio Button Styling */
    .ai-radio-option {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        padding: 12px;
        background: rgba(255,255,255,0.03);
        border: 2px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .ai-radio-option:hover {
        background: rgba(255,255,255,0.06);
        border-color: rgba(99, 102, 241, 0.4);
    }

    .ai-radio-option input[type="radio"] {
        margin-top: 2px;
        cursor: pointer;
    }

    .ai-radio-option input[type="radio"]:checked + .radio-label {
        color: #6366f1;
    }

    .ai-radio-option:has(input[type="radio"]:checked) {
        background: rgba(99, 102, 241, 0.1);
        border-color: #6366f1;
    }

    .radio-label {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .radio-label strong {
        font-size: 13px;
        color: rgba(255,255,255,0.9);
    }

    .radio-label small {
        font-size: 11px;
        color: rgba(255,255,255,0.5);
    }

    /* Creativity Slider */
    #creativity-slider {
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        background: rgba(255,255,255,0.1);
        border-radius: 3px;
        outline: none;
    }

    #creativity-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        background: #6366f1;
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(99, 102, 241, 0.4);
    }

    #creativity-slider::-moz-range-thumb {
        width: 18px;
        height: 18px;
        background: #6366f1;
        border-radius: 50%;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 6px rgba(99, 102, 241, 0.4);
    }

    /* ============================================================================
       UI MODERNIZATION - BUILD 148
       ============================================================================ */

    /* AI TOOLS SIDEBAR - Collapsible Left-Docked */
    #ai-tools-panel {
        position: fixed !important;
        top: 70px !important;
        left: 0 !important;
        bottom: 0 !important;
        width: 60px !important;
        min-width: 60px !important;
        background: #1E2128 !important;
        border-right: 1px solid var(--border) !important;
        border-top: none !important;
        border-bottom: none !important;
        border-left: none !important;
        border-radius: 0 !important;
        padding: 16px 8px !important;
        transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
        overflow: hidden !important;
        z-index: 900 !important;
        display: flex !important;
        flex-direction: column !important;
        gap: 12px !important;
        box-shadow: 4px 0 24px rgba(0,0,0,0.2) !important;
    }

    /* Expand on Hover */
    #ai-tools-panel:hover {
        width: 260px !important;
        background: var(--card-bg) !important;
    }

    /* Sidebar Buttons */
    #ai-tools-panel .btn {
        justify-content: flex-start !important;
        padding: 10px 12px !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        width: 100% !important;
        background: transparent !important;
        border: 1px solid transparent !important;
        color: var(--text-secondary) !important;
        transition: all 0.2s !important;
    }

    /* Button Icons (Always Visible) */
    #ai-tools-panel .btn::before {
        content: attr(data-icon);
        font-size: 20px;
        min-width: 24px;
        margin-right: 16px;
        text-align: center;
    }

    /* Button Hover State */
    #ai-tools-panel .btn:hover {
        background: rgba(255, 255, 255, 0.05) !important;
        color: var(--text-primary) !important;
        border-color: rgba(255, 255, 255, 0.1) !important;
    }

    /* Active/Primary Button Override */
    #ai-tools-panel .btn.btn-primary {
        background: linear-gradient(135deg, #6366f1, #8b5cf6) !important;
        color: white !important;
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    /* Hide text when collapsed */
    #ai-tools-panel:not(:hover) .btn span {
        opacity: 0;
    }

    #ai-tools-panel .btn span {
        transition: opacity 0.2s;
        opacity: 1;
    }

    /* TYPOGRAPHY IMPROVEMENTS - Better Hierarchy */
    /* Primary Title - Bigger & Bolder */
    .node-title, .item-name {
        font-size: 17px !important;
        font-weight: 700 !important;
        color: #F3F4F6 !important;
        letter-spacing: -0.01em;
        margin-bottom: 6px !important;
        line-height: 1.3;
    }

    /* Subtitle/Description - Receded */
    .node-subtitle, .item-description {
        font-size: 13px !important;
        color: #9CA3AF !important;
        font-weight: 400;
        line-height: 1.5;
    }

    /* Tags/Badges - More refined */
    .badge {
        font-size: 10px !important;
        padding: 3px 8px !important;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-radius: 4px !important;
        font-weight: 700 !important;
    }

    /* Node Cards - Better Depth */
    .tree-node {
        box-shadow:
            0 1px 0 rgba(255,255,255,0.1) inset,
            0 4px 12px rgba(0,0,0,0.4);
    }

    /* ZOOM CONTROLS IN SIDEBAR */
    /* Hide old standalone zoom controls if they exist */
    .zoom-controls {
        display: none !important;
    }

    /* Sidebar zoom controls container */
    .sidebar-zoom-controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 100%;
        padding: 8px 0;
        border-top: 1px solid rgba(255,255,255,0.1);
    }

    /* Zoom level display in sidebar */
    .zoom-level-sidebar {
        text-align: center;
        font-size: 11px;
        color: var(--text-secondary);
        padding: 4px;
        background: rgba(255,255,255,0.03);
        border-radius: 4px;
        font-weight: 600;
    }

    /* Ensure zoom buttons follow sidebar button styling */
    .sidebar-zoom-controls .btn {
        padding: 8px 12px !important;
    }

    </style>
    <!-- SheetJS library for Excel export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <!-- LZ-String library for URL compression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <!-- Google API Client Library for OAuth and Drive API -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>
</head>
<body>
    <!-- TreeListy by geej Splash Screen -->
    <div id="splash-screen">
        <div class="splash-logo">ðŸŒ³</div>
        <div class="splash-title">TreeListy</div>
        <div class="splash-subtitle">by geej</div>
        <div class="splash-tagline">From Complexity to Clarity</div>
        <div class="splash-loader">
            <div class="splash-loader-bar"></div>
        </div>
    </div>

    <!-- Header -->
    <div class="header">
        <div style="display: flex; align-items: center; gap: 20px;">
            <div class="logo">
                <div class="logo-title">
                    <span>ðŸŒ³</span>
                    <span>TreeListy</span>
                </div>
                <div class="logo-subtitle">by geej</div>
            </div>

            <!-- Save Indicator -->
            <div id="save-indicator" style="font-size: 12px; color: #9DA3B4; margin-left: 12px; white-space: nowrap;">
                â— Unsaved changes
            </div>

        </div>
        <div class="controls" style="flex-wrap: wrap; gap: 8px;">
            <!-- Row 1: Main controls -->
            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="toggle-view-mode" title="Switch between Tree and Canvas views" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); padding: 6px 10px; font-size: 13px;">
                    <span id="view-mode-icon">ðŸŽ¨</span>
                    <span id="view-mode-text">Canvas</span>
                </button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="new-project-btn" style="background: linear-gradient(135deg, #059669, #10b981); padding: 6px 10px; font-size: 13px;" title="Start a new project">ðŸ†•</button>
                <button class="btn" id="save-json-btn" title="Save project as JSON" style="padding: 6px 10px; font-size: 13px;">ðŸ’¾</button>
                <button class="btn" id="load-json-btn" title="Load project from JSON" style="padding: 6px 10px; font-size: 13px;">ðŸ“‚</button>
                <button class="btn" id="share-btn" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); padding: 6px 10px; font-size: 13px;" title="Generate shareable URL">ðŸ“¤</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="excel-export-btn" style="background: linear-gradient(135deg, #1D6F42, #00A67D); padding: 6px 10px; font-size: 13px;" title="Export to Excel">ðŸ“Š</button>
                <button class="btn" id="excel-import-btn" style="background: linear-gradient(135deg, #00A67D, #1D6F42); padding: 6px 10px; font-size: 13px;" title="Import from Excel">ðŸ“¥</button>
                <button class="btn" id="refresh-drive-btn" style="background: linear-gradient(135deg, #4285f4, #34a853); padding: 6px 10px; font-size: 13px;" title="Refresh from Google Drive">â˜ï¸</button>
                <input type="file" id="excel-upload-input" accept=".xlsx,.xls" style="display: none;">
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="undo-btn" title="Undo last action" disabled style="opacity: 0.5; padding: 6px 10px; font-size: 13px;">â†©ï¸</button>
                <button class="btn" id="expand-btn" title="Expand all" style="padding: 6px 10px; font-size: 13px;">â¬‡ï¸</button>
                <button class="btn" id="collapse-btn" title="Collapse all" style="padding: 6px 10px; font-size: 13px;">â¬†ï¸</button>
                <button class="btn" id="search-btn" style="background: linear-gradient(135deg, #3b82f6, #2563eb); padding: 6px 10px; font-size: 13px;" title="Search all fields">ðŸ”</button>
            </div>

            <div class="control-section pattern-selector" style="margin-right: 4px;">
                <select class="pattern-select" id="pattern-select" title="Choose naming pattern" style="padding: 6px 10px; font-size: 13px; min-width: 140px;">
                    <option value="generic" data-desc="Universal: Project â†’ Phase â†’ Item â†’ Task">ðŸ“‹ Generic Project</option>
                    <option value="sales" data-desc="Sales: Pipeline â†’ Quarter â†’ Deal â†’ Action">ðŸ’¼ Sales Pipeline</option>
                    <option value="thesis" data-desc="Academic: Thesis â†’ Chapter â†’ Section â†’ Point">ðŸŽ“ Academic Writing</option>
                    <option value="roadmap" data-desc="Product: Product â†’ Quarter â†’ Feature â†’ Story">ðŸš€ Product Roadmap</option>
                    <option value="book" data-desc="Writing: Book â†’ Part â†’ Chapter â†’ Scene">ðŸ“š Book Writing</option>
                    <option value="event" data-desc="Events: Event â†’ Stage â†’ Activity â†’ Task">ðŸŽ‰ Event Planning</option>
                    <option value="fitness" data-desc="Fitness: Program â†’ Phase â†’ Workout â†’ Exercise">ðŸ’ª Fitness Program</option>
                    <option value="strategy" data-desc="Business: Strategy â†’ Pillar â†’ Initiative â†’ Action">ðŸ“Š Strategic Plan</option>
                    <option value="course" data-desc="Education: Course â†’ Unit â†’ Lesson â†’ Exercise">ðŸ“– Course Design</option>
                    <option value="film" data-desc="Production: Film â†’ Phase â†’ Scene â†’ Shot">ðŸŽ¬ Film Production</option>
                    <option value="veo3" data-desc="Veo3: Project â†’ Sequence â†’ Scene â†’ Shot/Frame">ðŸŽ¥ Veo3 (Google)</option>
                    <option value="sora2" data-desc="Sora2: Project â†’ Sequence â†’ Beat â†’ Shot/Remix">ðŸŽ¬ Sora2 (OpenAI)</option>
                    <option value="philosophy" data-desc="Philosophy: Treatise â†’ Book â†’ Argument â†’ Premise">ðŸ¤” Philosophy</option>
                    <option value="prompting" data-desc="AI Prompting: Workbook â†’ Stage â†’ Module â†’ Step">ðŸ§  AI Prompt Design</option>
                    <option value="familytree" data-desc="Genealogy: Family â†’ Generation â†’ Person â†’ Event">ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family Tree</option>
                    <option value="dialogue" data-desc="Rhetoric: Conversation â†’ Speaker â†’ Statement â†’ Point">ðŸ’¬ Dialogue & Rhetoric</option>
                    <option value="gmail" data-desc="Email: Inbox/Campaign â†’ Label/Stage â†’ Thread â†’ Message">ðŸ“§ Email Workflow</option>
                    <option value="filesystem" data-desc="File System: Drive â†’ Folder â†’ File/Folder (Unlimited Depth)">ðŸ’¾ File System</option>
                    <option value="custom" data-desc="Custom: Define your own level names">âœï¸ Custom Names</option>
                </select>
            </div>

            <div class="control-section" id="sort-section" style="display: none; margin-right: 4px;">
                <label for="pattern-sort-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>ðŸ”„</span>
                    <select id="pattern-sort-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 120px; font-size: 12px;" title="Sort tree items by specific metrics">
                        <option value="">Default Order</option>
                    </select>
                </label>
                <button class="btn" id="reset-sort-btn" style="display: none; padding: 4px 8px; font-size: 12px;" title="Reset to default order">â†º</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="toggle-ai-tools" style="background: linear-gradient(135deg, #a855f7, #ec4899); color: white; font-weight: 600; padding: 6px 10px; font-size: 13px;" title="Toggle AI Tools Panel">ðŸ¤–</button>
                <button class="btn" id="api-key-btn" title="Configure your Anthropic API key" style="padding: 6px 10px; font-size: 13px;">ðŸ”‘</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <label for="unified-ai-mode-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>ðŸ¤–</span>
                    <select id="unified-ai-mode-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 160px; font-size: 12px;" title="Choose AI provider and model">
                        <optgroup label="ðŸ†“ Server (Free - 200/hr)">
                            <option value="server-haiku" title="Fast & cheap - Claude 3 Haiku">âš¡ Haiku 3</option>
                            <option value="server-sonnet" selected title="Best reasoning - Claude Sonnet 4">ðŸ§  Sonnet 4</option>
                        </optgroup>
                        <optgroup label="ðŸ”‘ Claude (Your Key)">
                            <option value="user-haiku" title="Fast - Claude 3.5 Haiku">âš¡ Haiku 3.5</option>
                            <option value="user-sonnet" title="Best reasoning - Claude Sonnet 4">ðŸ§  Sonnet 4</option>
                            <option value="user-opus" title="Most capable - Claude Opus 4">ðŸ‘‘ Opus 4</option>
                        </optgroup>
                        <optgroup label="ðŸ”· Gemini (Your Key)">
                            <option value="user-gemini-flash" title="Fast - Gemini 2.0 Flash">âš¡ Flash 2.0</option>
                            <option value="user-gemini-pro" title="Most capable - Gemini 2.5 Pro Preview">ðŸ§  Pro 2.5</option>
                        </optgroup>
                        <optgroup label="ðŸ’¬ ChatGPT (Your Key)">
                            <option value="user-gpt4o-mini" title="Fast & cheap - GPT-4o Mini">âš¡ 4o-mini</option>
                            <option value="user-gpt4o" title="Flagship - GPT-4o">ðŸ§  GPT-4o</option>
                            <option value="user-o1" title="Reasoning - o1">ðŸ”® o1</option>
                        </optgroup>
                        <optgroup label="Disable">
                            <option value="off">âŒ Off</option>
                        </optgroup>
                    </select>
                </label>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <label for="theme-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>ðŸŽ¨</span>
                    <select id="theme-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 100px; font-size: 12px;" title="Choose visual theme">
                        <option value="default">ðŸŒ™ Default</option>
                        <option value="steampunk">âš™ï¸ Steampunk</option>
                        <option value="powerpuff">ðŸ’— Powerpuff</option>
                        <option value="tron">ðŸ’  Tron</option>
                    </select>
                </label>
            </div>

            <div class="control-section" style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                <button class="btn" id="how-to-btn" title="How to use TreeListy" style="padding: 6px 10px; font-size: 13px;">â“</button>
                <div style="font-size: 10px; color: var(--text-secondary); opacity: 0.7; white-space: nowrap;" title="TreeListy v2.11.0 | Build 196 | 2025-11-29">
                    v2.11.0 â€¢ Build 196
                </div>
            </div>
        </div>
    </div>

    <!-- Tree View Container -->
    <div class="tree-view-container">

    <!-- Tree -->
    <div class="tree-container" id="tree-container">
        <div class="tree-transform-wrapper" id="tree-transform-wrapper">
            <svg class="dependency-svg" id="dependency-svg"></svg>
            <div class="tree" id="tree-root"></div>
        </div>
    </div>

    </div><!-- /tree-view-container -->

    <!-- Info Panel -->
    <div class="info-panel" id="info-panel">
        <div class="info-header">
            <div class="info-title" id="info-title">Details</div>
            <button class="close-btn" id="close-info">âœ•</button>
        </div>
        <div class="info-body" id="info-body"></div>
    </div>

    <!-- Context Menu (populated dynamically) -->
    <div class="context-menu" id="context-menu"></div>

    <!-- AI Tools Sidebar (Collapsible) -->
    <div id="ai-tools-panel">
        <button class="btn" data-icon="ðŸ“¥" id="analyze-text-btn" title="Convert text/files into tree structure"><span>Import Text</span></button>
        <button class="btn" data-icon="ðŸ”€" id="merge-branch-btn" title="Paste a collaboration URL to merge changes"><span>Merge Branch</span></button>
        <button class="btn" data-icon="ðŸ’¬" id="wizard-btn" title="Build and edit tree via chat"><span>Chat Builder</span></button>
        <button class="btn" data-icon="ðŸ©º" id="ai-review-btn" title="Check for logic gaps and missing fields"><span>Check Quality</span></button>
        <button class="btn" data-icon="âœ¨" id="auto-enhance-btn" title="Auto-fill details and add subtasks"><span>Smart Expand</span></button>
        <button class="btn" data-icon="ðŸ“¤" id="generate-prompt-btn" title="Export tree as text for other LLMs"><span>Export Prompt</span></button>
        <button class="btn btn-primary" data-icon="ðŸ¤–" id="ai-btn" title="Run pattern-specific analysis"><span>AI Analysis</span></button>

        <div style="flex: 1;"></div>

        <!-- Zoom Controls in Sidebar -->
        <div class="sidebar-zoom-controls">
            <button class="btn" data-icon="+" id="zoom-in" title="Zoom In"><span>Zoom In</span></button>
            <button class="btn" data-icon="âˆ’" id="zoom-out" title="Zoom Out"><span>Zoom Out</span></button>
            <button class="btn" data-icon="âŸ²" id="zoom-reset" title="Reset Zoom"><span>Reset Zoom</span></button>
            <div class="zoom-level-sidebar" id="zoom-level">100%</div>
        </div>

        <button class="btn" data-icon="âš™ï¸" id="ai-settings-btn" title="AI Settings"><span>AI Settings</span></button>
    </div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <div class="modal-header" id="modal-title">AI Analysis</div>
            <div class="modal-body" id="modal-body">
                <div class="spinner"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="modal-close">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="edit-modal">
        <div class="modal-content">
            <div class="modal-header">Edit Item</div>
            <div class="modal-body" id="edit-modal-body"></div>
            <div class="modal-footer">
                <button class="btn" id="edit-cancel">Cancel</button>
                <button class="btn btn-primary" id="edit-save">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Analysis Mode Modal -->
    <div class="modal" id="analysis-modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">ðŸ” Analysis Mode - Convert Text to Tree Structure</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Upload a text file or paste content below. AI will analyze it, detect the best pattern, and convert it into a hierarchical tree structure.
                    </p>
                </div>

                <!-- Analysis Mode Selection (moved to top) -->
                <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                    <div id="current-ai-mode-display" style="padding: 16px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 8px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <div style="font-weight: 600; color: var(--text-primary);">
                                AI Mode: <span id="analyze-mode-label">âš¡ Quick</span>
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                Change mode in header
                            </div>
                        </div>
                        <div id="analyze-mode-description" style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                            Fast pattern detection + basic structure. Recommended for most uses.
                        </div>
                        <div style="margin-top: 12px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                            <strong style="color: var(--text-primary);">ðŸ’¡ Tip:</strong> Change AI mode in the header (ðŸ¤– AI Mode dropdown) to switch between Quick, Deep, or Off.
                        </div>
                    </div>
                </div>

                <!-- Pattern Selection -->
                <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        ðŸ“ Pattern Selection
                    </label>
                    <select id="analysis-pattern-select" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: #1a1a2e; color: #ffffff; font-size: 14px; cursor: pointer;">
                        <option value="auto" style="background: #1a1a2e; color: #ffffff;">ðŸ¤– Auto-detect (AI chooses best pattern)</option>
                        <option value="generic" style="background: #1a1a2e; color: #ffffff;">ðŸ“¦ Generic Project - Universal structure</option>
                        <option value="sales" style="background: #1a1a2e; color: #ffffff;">ðŸ’¼ Sales Pipeline - Deal tracking</option>
                        <option value="thesis" style="background: #1a1a2e; color: #ffffff;">ðŸ“š Academic Writing - Research papers</option>
                        <option value="roadmap" style="background: #1a1a2e; color: #ffffff;">ðŸ—ºï¸ Product Roadmap - Feature timeline</option>
                        <option value="book" style="background: #1a1a2e; color: #ffffff;">ðŸ“– Book Writing - Narrative structure</option>
                        <option value="event" style="background: #1a1a2e; color: #ffffff;">ðŸŽ‰ Event Planning - Event logistics</option>
                        <option value="fitness" style="background: #1a1a2e; color: #ffffff;">ðŸ’ª Fitness Program - Workout plans</option>
                        <option value="strategy" style="background: #1a1a2e; color: #ffffff;">ðŸŽ¯ Strategic Plan - Business initiatives</option>
                        <option value="course" style="background: #1a1a2e; color: #ffffff;">ðŸŽ“ Course Design - Curriculum structure</option>
                        <option value="film" style="background: #1a1a2e; color: #ffffff;">ðŸŽ¬ Film Production - Video workflow</option>
                        <option value="veo3" style="background: #1a1a2e; color: #ffffff;">ðŸŽ¥ Veo3 (Google) - Ingredient/Frame-based video</option>
                        <option value="sora2" style="background: #1a1a2e; color: #ffffff;">ðŸŽ¬ Sora2 (OpenAI) - Cameo/Beat-based video</option>
                        <option value="philosophy" style="background: #1a1a2e; color: #ffffff;">ðŸ¤” Philosophy - Arguments & treatises</option>
                        <option value="prompting" style="background: #1a1a2e; color: #ffffff;">ðŸ§  Prompt Engineering - AI prompts</option>
                        <option value="familytree" style="background: #1a1a2e; color: #ffffff;">ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family Tree - Genealogy</option>
                        <option value="dialogue" style="background: #1a1a2e; color: #ffffff;">ðŸ’¬ Dialogue & Rhetoric - Debate analysis</option>
                    </select>
                    <div style="margin-top: 8px; padding: 10px; background: rgba(99, 102, 241, 0.1); border-radius: 4px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                        <strong style="color: var(--text-primary);">ðŸ’¡ Tip:</strong> Auto-detect lets AI analyze your text and recommend the best pattern. Or choose a specific pattern if you know what structure you want.
                    </div>
                </div>

                <!-- File Upload Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        ðŸ“ Upload File (.txt, .md)
                    </label>
                    <div id="file-drop-zone" style="border: 2px dashed var(--border); border-radius: 8px; padding: 32px; text-align: center; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s;">
                        <div style="font-size: 48px; margin-bottom: 12px;">ðŸ“„</div>
                        <div style="color: var(--text-primary); font-weight: 500; margin-bottom: 4px;">
                            Drop file here or click to browse
                        </div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            Supports .txt and .md files (max 100KB recommended)
                        </div>
                        <input type="file" id="analysis-file-input" accept=".txt,.md" style="display: none;" />
                    </div>
                    <div id="file-name-display" style="margin-top: 8px; color: var(--text-secondary); font-size: 13px; display: none;">
                        Selected: <span id="selected-file-name" style="color: var(--treeplex-primary); font-weight: 500;"></span>
                        <button id="clear-file-btn" style="margin-left: 8px; color: var(--text-secondary); background: none; border: none; cursor: pointer; font-size: 13px;">[Clear]</button>
                    </div>
                </div>

                <div style="text-align: center; margin: 16px 0; color: var(--text-secondary); font-size: 13px; font-weight: 600;">
                    â€” OR â€”
                </div>

                <!-- Paste Text Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        ðŸ“ Paste Text
                    </label>
                    <textarea id="analysis-text-input" placeholder="Paste your text content here...

Example:
- Meeting notes
- Project outline
- Research paper
- Strategic plan
- Event agenda
- Course syllabus

The AI will analyze the structure and convert it to a tree."
                        style="width: 100%; min-height: 200px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: 'Inter', monospace; font-size: 13px; resize: vertical;"></textarea>
                    <div id="char-count" style="margin-top: 6px; text-align: right; color: var(--text-secondary); font-size: 12px;">
                        0 characters
                    </div>
                </div>

                <!-- Warning Display -->
                <div id="analysis-warning" style="display: none; padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px; margin-bottom: 16px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">âš ï¸ Large File Warning</div>
                    <div id="analysis-warning-text" style="color: var(--text-secondary); font-size: 13px;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="analysis-cancel">Cancel</button>
                <button class="btn btn-primary" id="analysis-start-btn" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">ðŸ” Analyze</button>
            </div>
        </div>
    </div>

    <!-- API Key Configuration Modal -->
    <div class="modal" id="api-key-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">ðŸ”‘ AI Provider Configuration</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Configure your AI provider and API keys. You can use Claude, Gemini, ChatGPT, or all three.
                    </p>
                </div>

                <!-- Provider Selection -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        Primary AI Provider
                    </label>
                    <select id="provider-select" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 14px; cursor: pointer;">
                        <option value="anthropic">ðŸ¤– Anthropic Claude (Sonnet 4.5) - Best reasoning</option>
                        <option value="gemini">ðŸ”· Google Gemini (2.0 Flash) - Fast & cost-effective</option>
                        <option value="openai">ðŸ’¬ OpenAI ChatGPT (GPT-4o) - Versatile & popular</option>
                    </select>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 6px; line-height: 1.4;">
                        <strong>Cost comparison:</strong> Claude ~$3/1M input, $15/1M output | Gemini Free tier, then ~$0.075/1M | ChatGPT ~$2.50/1M input, $10/1M output
                    </div>
                </div>

                <!-- Claude API Key Section -->
                <div id="claude-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(99, 102, 241, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">ðŸ¤– Anthropic Claude API Key</div>
                        <div id="claude-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: var(--treeplex-primary); font-size: 13px; font-weight: 500;">ðŸ’¡ How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://console.anthropic.com/" target="_blank" style="color: var(--treeplex-primary);">console.anthropic.com</a></li>
                            <li>Sign up or log in to your account</li>
                            <li>Go to API Keys section</li>
                            <li>Create a new API key</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="claude-api-key-input" placeholder="sk-ant-..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <!-- Gemini API Key Section -->
                <div id="gemini-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(66, 133, 244, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">ðŸ”· Google Gemini API Key</div>
                        <div id="gemini-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: #4285f4; font-size: 13px; font-weight: 500;">ðŸ’¡ How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: #4285f4;">aistudio.google.com/app/apikey</a></li>
                            <li>Sign in with your Google account</li>
                            <li>Create a new API key</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="gemini-api-key-input" placeholder="AIzaSy..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <!-- OpenAI API Key Section -->
                <div id="openai-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(16, 163, 127, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">ðŸ’¬ OpenAI ChatGPT API Key</div>
                        <div id="openai-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: #10a37f; font-size: 13px; font-weight: 500;">ðŸ’¡ How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #10a37f;">platform.openai.com/api-keys</a></li>
                            <li>Sign up or log in to your account</li>
                            <li>Click "Create new secret key"</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="openai-api-key-input" placeholder="sk-proj-..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                    <input type="checkbox" id="api-key-show" style="cursor: pointer;" />
                    <label for="api-key-show" style="font-size: 13px; color: var(--text-secondary); cursor: pointer;">Show API keys</label>
                </div>

                <div style="padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">ðŸ”’ Security & Storage</div>
                    <div style="color: var(--text-secondary); font-size: 12px; line-height: 1.5;">
                        Your API keys are stored locally in your browser's localStorage and persist across sessions. Keys are never sent to any server except the respective AI provider's API (Anthropic, Google, or OpenAI).
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="api-key-cancel">Cancel</button>
                <button class="btn" id="api-key-clear" style="margin-right: auto; background: rgba(239, 68, 68, 0.1); color: #ef4444;">ðŸ—‘ï¸ Clear All Keys</button>
                <button class="btn btn-primary" id="api-key-save" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Save & Continue</button>
            </div>
        </div>
    </div>

    <!-- AI Settings Modal -->
    <div id="ai-settings-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid rgba(255,255,255,0.1);">
                <h2 style="margin: 0; font-size: 22px; display: flex; align-items: center; gap: 10px;">
                    <span>âš™ï¸</span> AI Settings
                    <span style="font-size: 13px; font-weight: 400; color: rgba(255,255,255,0.5); margin-left: 10px;">Tune Your AI Persona</span>
                </h2>
                <button onclick="closeAISettingsModal()" style="background: none; border: none; color: rgba(255,255,255,0.6); font-size: 28px; cursor: pointer; padding: 0; line-height: 1;">&times;</button>
            </div>

            <!-- Tone Section -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ðŸŽ­ Tone & Persona
                </label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="neutral" checked>
                        <span class="radio-label">
                            <strong>âš–ï¸ Neutral</strong>
                            <small>Professional, balanced, objective</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="critical">
                        <span class="radio-label">
                            <strong>ðŸ” Critical</strong>
                            <small>Red team, skeptical, finds flaws</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="enthusiastic">
                        <span class="radio-label">
                            <strong>ðŸš€ Enthusiastic</strong>
                            <small>Encouraging, optimistic, opportunity-focused</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="socratic">
                        <span class="radio-label">
                            <strong>â“ Socratic</strong>
                            <small>Asks questions, guides discovery</small>
                        </span>
                    </label>
                </div>
            </div>

            <!-- Verbosity Section -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ðŸ“ Output Style
                </label>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-verbosity" value="concise" checked>
                        <span class="radio-label">
                            <strong>âš¡ Concise</strong>
                            <small>Brief, bullet points</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-verbosity" value="balanced">
                        <span class="radio-label">
                            <strong>ðŸ“Š Balanced</strong>
                            <small>Clear paragraphs</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-verbosity" value="verbose">
                        <span class="radio-label">
                            <strong>ðŸ“š Verbose</strong>
                            <small>Detailed, thorough</small>
                        </span>
                    </label>
                </div>
            </div>

            <!-- Creativity Slider -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ðŸŒ¡ï¸ Creativity Level
                    <span id="creativity-value" style="color: #6366f1; margin-left: 8px;">0.5</span>
                </label>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <span style="font-size: 12px; color: rgba(255,255,255,0.5);">Consistent</span>
                    <input type="range" id="creativity-slider" min="0" max="100" value="50" style="flex: 1;">
                    <span style="font-size: 12px; color: rgba(255,255,255,0.5);">Creative</span>
                </div>
                <p style="font-size: 12px; color: rgba(255,255,255,0.4); margin-top: 8px; margin-bottom: 0;">
                    Lower values (0.0-0.3): Deterministic, factual tasks. Higher values (0.7-1.0): Creative writing, brainstorming.
                </p>
            </div>

            <!-- Custom Instructions -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    âœï¸ Custom Instructions <span style="font-weight: 400; color: rgba(255,255,255,0.5);">(Optional Override)</span>
                </label>
                <textarea id="custom-instructions" rows="4" style="width: 100%; padding: 12px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-family: 'SF Mono', Monaco, monospace; font-size: 13px; resize: vertical;" placeholder="Examples:
â€¢ 'Always include code examples in TypeScript'
â€¢ 'Assume I'm a beginner - explain concepts simply'
â€¢ 'Be extremely detailed about security implications'
â€¢ 'Focus on cost optimization strategies'"></textarea>
                <p style="font-size: 12px; color: rgba(255,255,255,0.4); margin-top: 8px; margin-bottom: 0;">
                    ðŸ’¡ These instructions override all other settings. The AI will prioritize this guidance above all else.
                </p>
            </div>

            <!-- Dialectic Mode Toggle (Cognitive Citadel) -->
            <div style="margin-bottom: 25px; padding: 15px; background: rgba(220, 38, 38, 0.1); border: 1px solid rgba(220, 38, 38, 0.3); border-radius: 8px;">
                <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
                    <input type="checkbox" id="ai-dialectic-mode" style="width: 18px; height: 18px; accent-color: #EF4444; margin-top: 2px;">
                    <div>
                        <strong style="color: #EF4444;">ðŸ›¡ï¸ Dialectic Mode</strong>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-top: 4px;">
                            Forces AI to identify assumptions and counter-arguments <em>before</em> helping.
                            Breaks the agreement echo chamber.
                        </div>
                    </div>
                </label>
            </div>

            <!-- Live Preview -->
            <div style="margin-bottom: 25px; padding: 15px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ðŸ‘ï¸ Live Preview
                </label>
                <div style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
                    <strong>Before (Base Prompt):</strong>
                </div>
                <div style="padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: rgba(255,255,255,0.5); margin-bottom: 12px;">
                    You are an expert project manager specializing in breaking down complex tasks...
                </div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
                    <strong>After (With Your Settings):</strong>
                </div>
                <div id="preview-after" style="padding: 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: rgba(255,255,255,0.8); white-space: pre-wrap;">You are an expert project manager specializing in breaking down complex tasks...</div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; gap: 10px; justify-content: flex-end; padding-top: 15px; border-top: 2px solid rgba(255,255,255,0.1);">
                <button onclick="resetAISettings()" class="btn" style="padding: 10px 20px; background: rgba(255,255,255,0.05);">
                    ðŸ”„ Reset to Defaults
                </button>
                <button onclick="closeAISettingsModal()" class="btn" style="padding: 10px 20px;">
                    Cancel
                </button>
                <button onclick="saveAISettings()" class="btn btn-primary" style="padding: 10px 20px; background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);">
                    ðŸ’¾ Save Settings
                </button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div class="modal" id="share-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">ðŸ“¤ Share Your Project</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 15px;">
                        Share this link with anyone! The link contains your entire project data (no server storage).
                    </p>
                    <div style="background: var(--card-bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 15px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="share-url-input" readonly
                                   style="flex: 1; background: var(--card-bg); border: 1px solid var(--border); color: var(--text-primary); padding: 10px; border-radius: 6px; font-family: monospace; font-size: 12px; user-select: all;"
                                   value="">
                            <button class="btn btn-primary" id="copy-share-url" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); white-space: nowrap;">
                                ðŸ“‹ Copy
                            </button>
                        </div>
                    </div>
                    <div id="share-stats" style="display: flex; gap: 20px; font-size: 13px; color: var(--text-secondary);">
                        <div>ðŸ“Š <span id="share-node-count">0</span> nodes</div>
                        <div>ðŸ“ <span id="share-url-length">0</span> characters</div>
                        <div id="share-size-warning" style="display: none; color: #f59e0b;">âš ï¸ Large project - URL may not work in all apps</div>
                    </div>
                </div>
                <div style="background: var(--card-bg); padding: 15px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                    <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span>â„¹ï¸</span> How it works
                    </div>
                    <ul style="margin-left: 20px; color: var(--text-secondary); font-size: 14px; line-height: 1.6;">
                        <li>Your data is compressed and embedded in the URL (not stored on any server)</li>
                        <li>Anyone with the link can view and edit their own copy</li>
                        <li>Works best for projects with up to 40-50 nodes</li>
                        <li>For larger projects, use "ðŸ’¾ Save" to download JSON instead</li>
                    </ul>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="share-close">Close</button>
                <button class="btn btn-primary" id="open-share-url" style="background: linear-gradient(135deg, #3B8FCC, #2B7AB8);">
                    ðŸ”— Open in New Tab
                </button>
            </div>
        </div>
    </div>

    <!-- Share Branch Modal (Collaboration) -->
    <div class="modal" id="share-branch-modal" style="display: none;">
        <div class="modal-content" style="max-width: 750px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #10b981, #059669); color: white;">
                ðŸ¤ Share for Collaboration
            </div>
            <div class="modal-body" id="share-branch-body">
                <!-- Populated dynamically by showShareBranchModal() -->
            </div>
            <div class="modal-footer">
                <button class="btn" id="share-branch-close">Close</button>
                <button class="btn" id="share-branch-copy" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">
                    ðŸ“‹ Copy URL
                </button>
                <button class="btn" id="share-branch-copy-email" style="background: linear-gradient(135deg, #f59e0b, #d97706);">
                    ðŸ“§ Copy Email
                </button>
                <button class="btn btn-primary" id="share-branch-email" style="background: linear-gradient(135deg, #10b981, #059669);">
                    âœ‰ï¸ Open Email App
                </button>
            </div>
        </div>
    </div>

    <!-- Merge Branch Modal (Collaboration - receiving edited branches) -->
    <div class="modal" id="merge-branch-modal" style="display: none;">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white;">
                ðŸ”€ Merge Collaboration Changes
            </div>
            <div class="modal-body" id="merge-branch-body">
                <!-- Populated dynamically by showMergeBranchModal() -->
            </div>
            <div class="modal-footer">
                <button class="btn" id="merge-branch-cancel">Cancel</button>
                <button class="btn btn-primary" id="merge-branch-accept" style="background: linear-gradient(135deg, #10b981, #059669);">
                    âœ… Accept & Merge Changes
                </button>
            </div>
        </div>
    </div>

    <!-- Branch Editing Banner (shown when editing a shared branch) -->
    <div id="branch-edit-banner" style="display: none; position: fixed; top: 60px; left: 0; right: 0; z-index: 1000; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; padding: 12px 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);">
        <div style="display: flex; align-items: center; justify-content: space-between; max-width: 1400px; margin: 0 auto;">
            <div style="display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px;">ðŸ¤</span>
                <div>
                    <div style="font-weight: 600; font-size: 14px;">Editing Shared Branch</div>
                    <div id="branch-edit-info" style="font-size: 12px; opacity: 0.9;">From: Project Name</div>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="branch-share-back-btn" class="btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);">
                    ðŸ“¤ Share Back
                </button>
                <button id="branch-exit-btn" class="btn" style="background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);">
                    âœ– Exit
                </button>
            </div>
        </div>
    </div>

    <!-- Paste Branch URL Modal -->
    <div class="modal" id="paste-branch-modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white;">
                ðŸ”€ Merge Collaboration Branch
            </div>
            <div class="modal-body">
                <p style="color: var(--text-secondary); margin-bottom: 16px;">
                    Paste a collaboration URL you received from a collaborator to merge their changes into your project.
                </p>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Branch URL:</label>
                    <textarea id="paste-branch-url-input"
                              placeholder="Paste the full URL here (starts with https://treelisty.netlify.app?branch=...)"
                              style="width: 100%; height: 120px; background: var(--card-bg); border: 2px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 6px; font-family: monospace; font-size: 11px; resize: vertical;"></textarea>
                </div>
                <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 12px; border-radius: 6px; border-left: 3px solid #6366f1;">
                    <p style="color: var(--text-secondary); font-size: 12px; margin: 0;">
                        <strong>Tip:</strong> Make sure your original project is loaded before merging. The system will check if the projects match.
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="paste-branch-cancel">Cancel</button>
                <button class="btn btn-primary" id="paste-branch-merge" style="background: linear-gradient(135deg, #10b981, #059669);">
                    ðŸ”€ Parse & Merge
                </button>
            </div>
        </div>
    </div>

    <!-- Wizard Modal -->
    <div class="modal" id="wizard-modal" style="display: none; justify-content: flex-end; background: transparent; pointer-events: none;">
        <div class="modal-content" style="width: 550px; max-width: 90vw; height: 100vh; max-height: 100vh; margin: 0; border-radius: 0; animation: slideInRight 0.3s ease-out; pointer-events: auto; box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);">
            <style>
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                    }
                    to {
                        transform: translateX(0);
                    }
                }
        
    /* ===================================================== */
    /* CANVAS VIEW STYLES */
    /* ===================================================== */

    .tree-view-container {
        display: block;
    }

    .tree-view-container.hidden {
        display: none !important;
    }

    .canvas-container {
        display: none;
        position: fixed;
        top: 140px;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        overflow: hidden;
        cursor: grab;
    }

    .canvas-container.active {
        display: block;
    }

    .canvas-container.grabbing {
        cursor: grabbing;
    }

    #canvas {
        width: 100%;
        height: 100%;
        position: relative;
        transform-origin: 0 0;
    }

    .canvas-connections {
        position: absolute;
        top: -5000px;
        left: -5000px;
        width: 20000px;
        height: 20000px;
        pointer-events: none;
        z-index: 1;
        overflow: visible;
    }

    /* Allow pointer events on hyperedge groups and their elements */
    .canvas-connections .hyperedge-group {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections polygon,
    .canvas-connections rect,
    .canvas-connections path.hyperedge-capsule {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections text {
        pointer-events: all;
        cursor: pointer;
    }

    /* Disable on connection lines (but not capsule paths) */
    .canvas-connections path:not(.hyperedge-capsule),
    .canvas-connections line {
        pointer-events: none;
    }

    .canvas-nodes-layer {
        position: relative;
        z-index: 2;
    }

    .canvas-node {
        position: absolute;
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        min-width: 280px;
        max-width: 320px;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, filter 0.15s ease;
        z-index: 10;
    }

    .canvas-node:hover {
        transform: translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }

    .canvas-node.dragging {
        cursor: grabbing;
        opacity: 0.9;
        z-index: 1000;
        transform: scale(1.05);
    }

    .canvas-node.selected {
        border-color: var(--treeplex-primary) !important;
        box-shadow:
            0 8px 32px rgba(99, 102, 241, 0.4),
            0 4px 16px rgba(99, 102, 241, 0.3),
            0 0 0 3px rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-2px);
    }

    .canvas-node.selected::before {
        content: 'âœ“';
        position: absolute;
        top: -10px;
        right: -10px;
        background: #6366f1;
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .canvas-node.dragging-group {
        opacity: 0.7;
        box-shadow: 0 0 20px rgba(99, 102, 241, 0.8);
    }

    .phase-zone {
        position: absolute;
        border: 3px dashed;
        border-radius: 20px;
        padding: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .phase-zone-header {
        font-weight: 700;
        font-size: 18px;
        margin-bottom: 12px;
        color: var(--text-primary);
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* Colored phase zones - vibrant colors */
    .phase-0 {
        border-color: #3B82F6;
        background: rgba(59, 130, 246, 0.08);
    }
    .phase-1 {
        border-color: #F59E0B;
        background: rgba(245, 158, 11, 0.08);
    }
    .phase-2 {
        border-color: #10B981;
        background: rgba(16, 185, 129, 0.08);
    }
    .phase-3 {
        border-color: #8B5CF6;
        background: rgba(139, 92, 246, 0.08);
    }
    .phase-4 {
        border-color: #EC4899;
        background: rgba(236, 72, 153, 0.08);
    }
    .phase-5 {
        border-color: #06B6D4;
        background: rgba(6, 182, 212, 0.08);
    }

    /* Grid overlay */
    .canvas-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .canvas-grid.active {
        opacity: 1;
    }

    .canvas-toolbar.active {
        display: flex !important;
    }

    .canvas-toolbar button:hover {
        background: rgba(99, 102, 241, 0.3) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .canvas-toolbar button:active {
        transform: translateY(0);
    }

    .canvas-toolbar select:hover {
        background: rgba(99, 102, 241, 0.25) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
    }

    .canvas-toolbar select option {
        background: #1a1a2e;
        color: #ffffff;
        padding: 10px;
        font-weight: 600;
    }

    .canvas-toolbar select option:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    </style>
            <div class="modal-header">
                <span id="wizard-title">ðŸª„ AI Wizard - Building Your Project</span>
            </div>

            <div style="padding: 15px; background: var(--card-bg-light); border-bottom: 1px solid var(--border);">
                <div style="display: flex; gap: 30px; font-size: 14px; margin-bottom: 10px;">
                    <div>ðŸ“Š Turn: <span id="wizard-question-count" style="color: var(--treeplex-primary); font-weight: 600;">0</span></div>
                    <div>âœ“ Fields: <span id="wizard-fields-complete" style="color: var(--treeplex-primary); font-weight: 600;">0</span>/<span id="wizard-fields-total">10</span> complete</div>
                    <div>ðŸ“ˆ <span id="wizard-progress-percent" style="color: var(--treeplex-primary); font-weight: 600;">0%</span> complete</div>
                    <div id="wizard-completion" style="display: none; color: #10b981; font-weight: 600;">âœ… Ready to Apply!</div>
                </div>
                <!-- Progress Bar -->
                <div style="width: 100%; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden;">
                    <div id="wizard-progress-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--treeplex-primary), #10b981); transition: width 0.5s ease;"></div>
                </div>
            </div>

            <div class="modal-body" style="display: flex; flex-direction: column; padding: 0; height: calc(100vh - 200px); overflow: hidden;">
                <!-- Tip Banner -->
                <div style="padding: 12px 20px; background: linear-gradient(135deg, rgba(163, 85, 247, 0.1), rgba(236, 72, 153, 0.1)); border-bottom: 1px solid var(--border);">
                    <div style="font-size: 12px; color: var(--text-primary); display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 16px;">ðŸ’¡</span>
                        <span>Watch your tree update in real-time on the left as we build it together!</span>
                    </div>
                </div>

                <!-- Chat Area -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <div id="wizard-chat-history" style="flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px;">
                        <!-- Chat messages will appear here -->
                    </div>
                    <div style="padding: 15px 20px; border-top: 1px solid var(--border); display: flex; gap: 10px; background: var(--bg-secondary);">
                        <input type="text" id="wizard-user-input" placeholder="Type your answer here..."
                               style="flex: 1; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 6px; font-size: 14px;"
                               onkeypress="if(event.key==='Enter') document.getElementById('wizard-send').click()">
                        <button class="btn btn-primary" id="wizard-send" style="background: linear-gradient(135deg, #a855f7, #ec4899); padding: 12px 24px; white-space: nowrap;">
                            Send
                        </button>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="wizard-cancel">Cancel</button>
                <button class="btn" id="wizard-auto-enhance" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; font-weight: 600;" title="Automatically run AI Review then enhance your tree">
                    ðŸ”„ Auto-Enhance
                </button>
                <button class="btn btn-primary" id="wizard-done" style="background: linear-gradient(135deg, #10b981, #059669);">
                    âœ… Finish & Apply
                </button>
            </div>
        </div>
    </div>

    <!-- Generate Prompt Modal -->
    <div class="modal" id="generate-prompt-modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh;">
            <div class="modal-header">
                <span id="generate-prompt-title">ðŸ“ Generated Prompt</span>
            </div>

            <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(85vh - 140px);">
                <div style="margin-bottom: 15px; color: var(--text-secondary); font-size: 13px;">
                    This prompt was generated from your tree structure. Copy and paste it to use with AI systems.
                </div>

                <div style="position: relative;">
                    <textarea id="generated-prompt-text" readonly style="
                        width: 100%;
                        min-height: 400px;
                        padding: 15px;
                        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                        font-size: 13px;
                        line-height: 1.6;
                        border: 1px solid var(--border);
                        border-radius: 8px;
                        background: var(--card-bg);
                        color: var(--text-primary);
                        resize: vertical;
                    "></textarea>

                    <button id="copy-prompt-btn" style="
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        padding: 8px 16px;
                        background: var(--treeplex-primary);
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 600;
                    ">ðŸ“‹ Copy</button>
                </div>

                <div id="copy-success-message" style="
                    margin-top: 10px;
                    padding: 10px;
                    background: #10b981;
                    color: white;
                    border-radius: 6px;
                    text-align: center;
                    display: none;
                ">âœ… Copied to clipboard!</div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-prompt-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- AI Review Modal -->
    <div class="modal" id="ai-review-modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh;">
            <div class="modal-header">
                <span>ðŸ”¬ AI Review & Enhance</span>
            </div>

            <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 140px);">
                <!-- Status area -->
                <div id="ai-review-status" style="margin-bottom: 20px;">
                    <div style="padding: 15px; background: rgba(99, 102, 241, 0.1); border-left: 3px solid #6366f1; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">ðŸ¤– AI is analyzing your tree...</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            Checking for completeness, redundancies, logical flow, and pattern alignment.
                        </div>
                    </div>
                </div>

                <!-- Results area (hidden initially) -->
                <div id="ai-review-results" style="display: none;">
                    <!-- Summary section -->
                    <div style="margin-bottom: 24px; padding: 16px; background: var(--card-bg-light); border-radius: 8px;">
                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: var(--text-primary);">ðŸ“Š Analysis Summary</h3>
                        <div id="ai-review-summary"></div>
                    </div>

                    <!-- Suggestions section -->
                    <div style="margin-bottom: 24px;">
                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: var(--text-primary);">âœ¨ Suggested Improvements</h3>
                        <div id="ai-review-suggestions"></div>
                    </div>

                    <!-- Actions section -->
                    <div style="padding: 16px; background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">ðŸŽ¯ Next Steps</div>
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
                            Review the suggestions above. You can manually apply changes to your tree, or let AI enhance specific areas.
                        </div>
                        <button class="btn" id="ai-review-again" style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white;">
                            ðŸ”„ Re-analyze
                        </button>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-ai-review-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- Search Modal -->
    <div class="modal" id="search-modal" style="display: none;">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh;">
            <div class="modal-header">
                <span>ðŸ” Search Tree</span>
            </div>

            <div class="modal-body" style="padding: 20px;">
                <!-- Search input -->
                <div style="margin-bottom: 20px;">
                    <input type="text" id="search-input" placeholder="Search all fields (name, description, notes, etc.)..."
                        style="width: 100%; padding: 12px 16px; font-size: 15px; border: 2px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); outline: none; transition: border-color 0.2s;">
                    <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                        ðŸ’¡ Tip: Search is case-insensitive and searches all fields in all nodes
                    </div>
                </div>

                <!-- Search results -->
                <div id="search-results-container" style="max-height: calc(90vh - 260px); overflow-y: auto;">
                    <div id="search-results-empty" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                        <div style="font-size: 48px; margin-bottom: 12px;">ðŸ”</div>
                        <div style="font-size: 14px;">Enter a search term to find nodes</div>
                    </div>
                    <div id="search-results" style="display: none;"></div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-search-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- PWA Onboarding Modal -->
    <div class="modal" id="pwa-onboarding-modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <span>ðŸŒ³ Welcome to TreeListy!</span>
            </div>

            <div class="modal-body" style="padding: 30px;">
                <!-- Success checkmark -->
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 64px;">âœ…</div>
                    <h2 style="margin: 16px 0 8px; color: var(--text-primary); font-size: 22px;">Tree Loaded Successfully!</h2>
                    <p style="color: var(--text-secondary); font-size: 14px; margin: 0;">You can now explore this project</p>
                </div>

                <!-- Divider -->
                <div style="height: 1px; background: var(--border); margin: 24px 0;"></div>

                <!-- Install prompt -->
                <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); border: 2px solid var(--treeplex-primary); border-radius: 12px; padding: 24px; margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">
                        <div style="font-size: 40px;">ðŸ’¾</div>
                        <div>
                            <h3 style="margin: 0 0 4px; color: var(--text-primary); font-size: 18px;">Want to work with .treelisty files?</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: 13px;">Install TreeListy to open files with a double-click!</p>
                        </div>
                    </div>

                    <div style="background: var(--card-bg); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">âœ¨ Benefits:</div>
                        <ul style="margin: 0; padding-left: 20px; color: var(--text-primary); font-size: 14px; line-height: 1.8;">
                            <li>Open <code style="background: var(--bg); padding: 2px 6px; border-radius: 4px; font-family: monospace;">.treelisty</code> files with a double-click</li>
                            <li>Works offline after installation</li>
                            <li>Access from your app menu/desktop</li>
                            <li>Faster loading and better performance</li>
                        </ul>
                    </div>

                    <!-- Universal Install button - ALWAYS shown -->
                    <button class="btn" id="pwa-install-btn" style="width: 100%; background: linear-gradient(135deg, #6366f1, #8b5cf6); padding: 16px; font-size: 16px; font-weight: 600;">
                        ðŸ“¥ Install TreeListy
                    </button>

                    <!-- Instructions (shown after clicking if manual install needed) -->
                    <div id="pwa-manual-instructions" style="display: none; margin-top: 16px; padding: 16px; background: var(--card-bg-light); border-radius: 8px; border: 2px solid var(--treeplex-primary);">
                        <div style="font-size: 15px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">
                            ðŸ“ Follow these steps:
                        </div>
                        <ol style="margin: 0; padding-left: 24px; color: var(--text-primary); font-size: 14px; line-height: 2;">
                            <li>Look at the <strong>address bar</strong> (top of browser)</li>
                            <li>Find the <strong>install icon</strong> on the right side:
                                <span style="background: var(--bg); padding: 4px 8px; border-radius: 4px; margin-left: 8px;">ðŸ“¥</span> or
                                <span style="background: var(--bg); padding: 4px 8px; border-radius: 4px; margin-left: 4px;">âŠ•</span>
                            </li>
                            <li>Click the icon and select <strong>"Install"</strong></li>
                        </ol>
                        <div style="margin-top: 16px; padding: 12px; background: rgba(234, 179, 8, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                            ðŸ’¡ Don't see the icon? Close this modal and look for it. Still missing? You might need to use Chrome or Edge browser.
                        </div>
                    </div>
                </div>

                <!-- Skip option -->
                <div style="text-align: center;">
                    <button class="btn" id="pwa-skip-btn" style="background: var(--card-bg); color: var(--text-secondary); padding: 10px 20px; font-size: 13px;">
                        Maybe Later
                    </button>
                    <div style="margin-top: 8px; font-size: 11px; color: var(--text-secondary);">
                        You can always install later from the Help menu
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input for JSON upload -->
    <input type="file" id="json-upload-input" accept=".json,.treelisty" style="display: none;" />

    <script>
        console.log('TreeListy - Universal Project Decomposition - Horizontal Layout with Pan/Zoom');

        // =============================================================================
        // SEMANTIC CHUNKING ENGINE (NLP + Vector Search)
        // =============================================================================

        /**
         * EmbeddingManager - Abstraction layer for embeddings from multiple providers
         */
        class EmbeddingManager {
            /**
             * Check if any embedding provider is available
             */
            static hasProvider() {
                const openaiKey = localStorage.getItem('openai_api_key');
                const geminiKey = localStorage.getItem('gemini_api_key');
                return !!(openaiKey || geminiKey);
            }

            /**
             * Get embeddings for an array of texts
             * @param {string[]} texts - Array of text strings to embed
             * @returns {Promise<number[][]>} Array of embedding vectors
             */
            static async getEmbeddings(texts) {
                if (!texts || texts.length === 0) {
                    throw new Error('No texts provided for embedding');
                }

                const openaiKey = localStorage.getItem('openai_api_key');
                const geminiKey = localStorage.getItem('gemini_api_key');

                // Try OpenAI first
                if (openaiKey) {
                    console.log(`ðŸ”¢ Getting embeddings from OpenAI (${texts.length} texts)`);
                    return await this._getOpenAIEmbeddings(texts, openaiKey);
                }

                // Fallback to Gemini
                if (geminiKey) {
                    console.log(`ðŸ”¢ Getting embeddings from Gemini (${texts.length} texts)`);
                    return await this._getGeminiEmbeddings(texts, geminiKey);
                }

                // No provider available
                console.warn('âš ï¸ No embedding provider available (OpenAI or Gemini API key required)');
                return null;
            }

            /**
             * OpenAI text-embedding-3-small
             */
            static async _getOpenAIEmbeddings(texts, apiKey) {
                const BATCH_SIZE = 20; // OpenAI limit
                const batches = [];

                for (let i = 0; i < texts.length; i += BATCH_SIZE) {
                    batches.push(texts.slice(i, i + BATCH_SIZE));
                }

                const allEmbeddings = [];

                for (const batch of batches) {
                    try {
                        const response = await fetch('https://api.openai.com/v1/embeddings', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                input: batch,
                                model: 'text-embedding-3-small'
                            })
                        });

                        if (!response.ok) {
                            const error = await response.text();
                            throw new Error(`OpenAI API error: ${error}`);
                        }

                        const data = await response.json();
                        const embeddings = data.data.map(item => item.embedding);
                        allEmbeddings.push(...embeddings);

                    } catch (error) {
                        console.error('OpenAI embedding error:', error);
                        throw error;
                    }
                }

                return allEmbeddings;
            }

            /**
             * Gemini text-embedding-004
             */
            static async _getGeminiEmbeddings(texts, apiKey) {
                const BATCH_SIZE = 20; // Conservative batch size
                const batches = [];

                for (let i = 0; i < texts.length; i += BATCH_SIZE) {
                    batches.push(texts.slice(i, i + BATCH_SIZE));
                }

                const allEmbeddings = [];

                for (const batch of batches) {
                    try {
                        // Gemini requires individual calls per text
                        const batchEmbeddings = await Promise.all(
                            batch.map(async (text) => {
                                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${apiKey}`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        content: {
                                            parts: [{ text: text }]
                                        }
                                    })
                                });

                                if (!response.ok) {
                                    const error = await response.text();
                                    throw new Error(`Gemini API error: ${error}`);
                                }

                                const data = await response.json();
                                return data.embedding.values;
                            })
                        );

                        allEmbeddings.push(...batchEmbeddings);

                    } catch (error) {
                        console.error('Gemini embedding error:', error);
                        throw error;
                    }
                }

                return allEmbeddings;
            }
        }

        /**
         * SemanticChunker - Rigorous semantic chunking with embedding-based breakpoints
         */
        class SemanticChunker {
            constructor() {
                this.DEFAULT_THRESHOLD = 0.7;
                this.PERCENTILE_THRESHOLD = 90;
            }

            /**
             * Calculate cosine similarity between two vectors
             * @param {number[]} vecA - First vector
             * @param {number[]} vecB - Second vector
             * @returns {number} Cosine similarity (0-1)
             */
            cosineSimilarity(vecA, vecB) {
                if (!vecA || !vecB || vecA.length !== vecB.length) {
                    throw new Error('Vectors must have same length');
                }

                let dotProduct = 0;
                let magnitudeA = 0;
                let magnitudeB = 0;

                for (let i = 0; i < vecA.length; i++) {
                    dotProduct += vecA[i] * vecB[i];
                    magnitudeA += vecA[i] * vecA[i];
                    magnitudeB += vecB[i] * vecB[i];
                }

                magnitudeA = Math.sqrt(magnitudeA);
                magnitudeB = Math.sqrt(magnitudeB);

                if (magnitudeA === 0 || magnitudeB === 0) {
                    return 0;
                }

                return dotProduct / (magnitudeA * magnitudeB);
            }

            /**
             * Calculate breakpoint threshold using percentile method
             * @param {number[]} distances - Array of cosine distances
             * @returns {number} Threshold value
             */
            calculateBreakpointThreshold(distances) {
                if (!distances || distances.length === 0) {
                    return this.DEFAULT_THRESHOLD;
                }

                // Sort distances
                const sorted = [...distances].sort((a, b) => a - b);

                // Find 90th percentile
                const index = Math.floor(sorted.length * (this.PERCENTILE_THRESHOLD / 100));
                const threshold = sorted[Math.min(index, sorted.length - 1)];

                console.log(`ðŸ“Š Calculated breakpoint threshold: ${threshold.toFixed(3)} (90th percentile)`);

                return threshold;
            }

            /**
             * Split text into sentences using robust regex
             * @param {string} text - Input text
             * @returns {string[]} Array of sentences
             */
            splitIntoSentences(text) {
                if (!text) return [];

                // Split on sentence boundaries (., !, ?) followed by whitespace and capital letter
                // or newline, but preserve acronyms (e.g., U.S.A.)
                const sentences = text
                    .replace(/([.!?])\s+(?=[A-Z])/g, '$1|SPLIT|')
                    .replace(/\n+/g, '|SPLIT|')
                    .split('|SPLIT|')
                    .map(s => s.trim())
                    .filter(s => s.length > 0);

                console.log(`âœ‚ï¸ Split into ${sentences.length} sentences`);
                return sentences;
            }

            /**
             * Structural fallback split (when embeddings unavailable)
             * @param {string} text - Input text
             * @returns {Array<{text: string, start: number, end: number}>} Array of chunks
             */
            structuralSplit(text) {
                console.log('ðŸ“ Using structural split (fallback mode)');

                const chunks = [];
                let currentChunk = '';
                let start = 0;

                // Split by Markdown headers first
                const headerRegex = /^(#{1,6})\s+(.+)$/gm;
                const parts = text.split(headerRegex);

                if (parts.length > 1) {
                    // Has headers - use them as boundaries
                    for (let i = 0; i < parts.length; i += 3) {
                        const content = parts[i] || '';
                        const headerLevel = parts[i + 1];
                        const headerText = parts[i + 2];

                        if (content.trim()) {
                            chunks.push({
                                text: content.trim(),
                                start: start,
                                end: start + content.length
                            });
                            start += content.length;
                        }

                        if (headerLevel && headerText) {
                            const header = `${headerLevel} ${headerText}`;
                            chunks.push({
                                text: header.trim(),
                                start: start,
                                end: start + header.length
                            });
                            start += header.length;
                        }
                    }
                } else {
                    // No headers - split by paragraphs
                    const paragraphs = text.split(/\n\n+/);

                    for (const para of paragraphs) {
                        if (para.trim()) {
                            chunks.push({
                                text: para.trim(),
                                start: start,
                                end: start + para.length
                            });
                            start += para.length;
                        }
                    }
                }

                // If still no chunks, split by lines
                if (chunks.length === 0) {
                    const lines = text.split(/\n/);
                    for (const line of lines) {
                        if (line.trim()) {
                            chunks.push({
                                text: line.trim(),
                                start: start,
                                end: start + line.length
                            });
                            start += line.length;
                        }
                    }
                }

                console.log(`âœ… Structural split: ${chunks.length} chunks`);
                return chunks;
            }

            /**
             * Core embedding-based chunking algorithm
             * @param {string} text - Input text
             * @returns {Promise<Array<{text: string, start: number, end: number}>>} Array of semantic chunks
             */
            async chunkByEmbedding(text) {
                console.log('ðŸ§  Starting embedding-based semantic chunking...');

                try {
                    // Step 1: Split into sentences
                    const sentences = this.splitIntoSentences(text);

                    if (sentences.length === 0) {
                        console.warn('âš ï¸ No sentences found');
                        return [{ text: text, start: 0, end: text.length }];
                    }

                    if (sentences.length === 1) {
                        console.log('Single sentence - no chunking needed');
                        return [{ text: text, start: 0, end: text.length }];
                    }

                    // Step 2: Create sliding window combinations (sentence + prev + next)
                    const windowedSentences = sentences.map((sentence, i) => {
                        const prev = i > 0 ? sentences[i - 1] : '';
                        const next = i < sentences.length - 1 ? sentences[i + 1] : '';
                        return `${prev} ${sentence} ${next}`.trim();
                    });

                    // Step 3: Get embeddings
                    console.log(`ðŸ“Š Getting embeddings for ${windowedSentences.length} windowed sentences...`);
                    const embeddings = await EmbeddingManager.getEmbeddings(windowedSentences);

                    if (!embeddings) {
                        console.warn('âš ï¸ Embeddings unavailable, falling back to structural split');
                        return this.structuralSplit(text);
                    }

                    // Step 4: Calculate cosine distances between adjacent sentences
                    const distances = [];
                    for (let i = 0; i < embeddings.length - 1; i++) {
                        const similarity = this.cosineSimilarity(embeddings[i], embeddings[i + 1]);
                        const distance = 1 - similarity; // Convert similarity to distance
                        distances.push(distance);
                    }

                    // Step 5: Calculate adaptive threshold
                    const threshold = this.calculateBreakpointThreshold(distances);

                    // Step 6: Identify breakpoints where distance > threshold
                    const breakpoints = [0]; // Start with first sentence
                    for (let i = 0; i < distances.length; i++) {
                        if (distances[i] > threshold) {
                            breakpoints.push(i + 1);
                            console.log(`ðŸ“ Breakpoint at sentence ${i + 1} (distance: ${distances[i].toFixed(3)})`);
                        }
                    }
                    breakpoints.push(sentences.length); // End with last sentence

                    // Step 7: Merge sentences between breakpoints into chunks
                    const chunks = [];
                    let charIndex = 0;

                    for (let i = 0; i < breakpoints.length - 1; i++) {
                        const startIdx = breakpoints[i];
                        const endIdx = breakpoints[i + 1];
                        const chunkSentences = sentences.slice(startIdx, endIdx);
                        const chunkText = chunkSentences.join(' ');

                        chunks.push({
                            text: chunkText,
                            start: charIndex,
                            end: charIndex + chunkText.length
                        });

                        charIndex += chunkText.length + 1; // +1 for space
                    }

                    console.log(`âœ… Semantic chunking complete: ${chunks.length} chunks (from ${sentences.length} sentences)`);
                    return chunks;

                } catch (error) {
                    console.error('âŒ Embedding-based chunking failed:', error);
                    console.log('Falling back to structural split');
                    return this.structuralSplit(text);
                }
            }
        }

        // =============================================================================
        // PAN & ZOOM SYSTEM
        // =============================================================================

        // Pan/Zoom state
        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startX = 0;
        let startY = 0;

        const MIN_ZOOM = 0.25;  // 25%
        const MAX_ZOOM = 3.0;   // 300%
        const ZOOM_STEP = 0.15; // 15% per click

        // Apply transform to tree
        function applyTransform() {
            const wrapper = document.getElementById('tree-transform-wrapper');
            if (wrapper) {
                wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
                updateZoomDisplay();
            }
        }

        // Update zoom level display
        function updateZoomDisplay() {
            const display = document.getElementById('zoom-level');
            if (display) {
                display.textContent = Math.round(zoomLevel * 100) + '%';
            }
        }

        // Zoom in
        function zoomIn() {
            if (zoomLevel < MAX_ZOOM) {
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
                applyTransform();
            }
        }

        // Zoom out
        function zoomOut() {
            if (zoomLevel > MIN_ZOOM) {
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
                applyTransform();
            }
        }

        // Reset view
        function resetZoom() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            applyTransform();
        }

        // Mouse wheel zoom
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY;

            if (delta < 0) {
                // Scroll up = zoom in
                zoomIn();
            } else {
                // Scroll down = zoom out
                zoomOut();
            }
        }

        // Mouse down - start panning
        function handleMouseDown(e) {
            // Don't pan if clicking on a node or button
            if (e.target.closest('.tree-node') || e.target.closest('button') || e.target.closest('.zoom-controls')) {
                return;
            }

            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;

            const container = document.getElementById('tree-container');
            container.classList.add('panning');
        }

        // Mouse move - pan
        function handleMouseMove(e) {
            if (!isPanning) return;

            panX = e.clientX - startX;
            panY = e.clientY - startY;
            applyTransform();
        }

        // Mouse up - stop panning
        function handleMouseUp(e) {
            if (isPanning) {
                isPanning = false;
                const container = document.getElementById('tree-container');
                container.classList.remove('panning');
            }
        }

        // Initialize pan/zoom after DOM loads
        function initPanZoom() {
            const container = document.getElementById('tree-container');

            // Zoom controls
            document.getElementById('zoom-in').addEventListener('click', zoomIn);
            document.getElementById('zoom-out').addEventListener('click', zoomOut);
            document.getElementById('zoom-reset').addEventListener('click', resetZoom);

            // Mouse wheel
            container.addEventListener('wheel', handleWheel, { passive: false });

            // Mouse drag
            container.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Prevent context menu on drag
            container.addEventListener('contextmenu', (e) => {
                if (isPanning) e.preventDefault();
            });

            console.log('âœ… Pan/Zoom initialized');
        }

        // =============================================================================
        // END PAN & ZOOM SYSTEM
        // =============================================================================

        // =============================================================================
        // AI TUNER - PERSONA PERSISTENCE
        // =============================================================================

        // Helper to get AI config with safe defaults
        function getAIConfig() {
            const defaults = {
                tone: 'neutral',        // neutral, critical, enthusiastic, socratic
                verbosity: 'concise',   // concise, balanced, verbose
                creativity: 0.5,        // 0.0 to 1.0 (maps to temperature)
                dialecticMode: false,   // Cognitive Citadel: force counter-arguments
                customInstructions: ''  // User override
            };

            // Merge saved config if it exists
            return { ...defaults, ...(capexTree.aiConfig || {}) };
        }

        // Apply persona tuning to system prompts
        function applyPersonaTuning(baseSystemPrompt) {
            const config = getAIConfig();
            let tuning = "";

            // 1. Tone Injection
            if (config.tone === 'critical') {
                tuning += "ROLE ADAPTATION: You are a ruthless Red Team critic. Challenge assumptions. Find flaws. Do not be polite.\n";
            } else if (config.tone === 'socratic') {
                tuning += "ROLE ADAPTATION: Do not give answers directly. Ask probing questions to guide the user to discover the solution themselves.\n";
            } else if (config.tone === 'enthusiastic') {
                tuning += "ROLE ADAPTATION: Be high-energy and encouraging. Focus on opportunities and 'yes, and' thinking. Use energizing language.\n";
            }
            // neutral = no injection

            // 2. Verbosity Injection
            if (config.verbosity === 'concise') {
                tuning += "OUTPUT STYLE: Be extremely brief. Use telegraphic style. No fluff. Bullet points preferred.\n";
            } else if (config.verbosity === 'verbose') {
                tuning += "OUTPUT STYLE: Be thorough and detailed. Explain reasoning fully. Provide comprehensive analysis with examples.\n";
            }
            // balanced = no injection

            // 3. DIALECTIC MODE (Cognitive Citadel)
            if (config.dialecticMode) {
                tuning += `
ðŸ›¡ï¸ DIALECTIC MODE ACTIVE:
Before responding to the user's request, you MUST:
1. Identify 2 hidden assumptions in their request
2. Generate 1 strong counter-argument or alternative perspective
3. Note 1 potential blind spot they may have

Present these briefly as "**ðŸ›¡ï¸ Considerations:**" (4-5 lines max), then proceed with the requested task.
Do not ask permissionâ€”just provide the critique, then help.
`;
            }

            // 4. User Override (HIGHEST PRIORITY)
            if (config.customInstructions && config.customInstructions.trim()) {
                tuning += `\nUSER PRIORITY INSTRUCTION: ${config.customInstructions.trim()}\n`;
            }

            // Prepend tuning to the base prompt
            if (tuning) {
                return `${tuning}\n${baseSystemPrompt}`;
            }
            return baseSystemPrompt;
        }

        // Open AI Settings Modal
        function openAISettingsModal() {
            const modal = document.getElementById('ai-settings-modal');
            const config = getAIConfig();

            // Load current settings
            document.querySelector(`input[name="ai-tone"][value="${config.tone}"]`).checked = true;
            document.querySelector(`input[name="ai-verbosity"][value="${config.verbosity}"]`).checked = true;

            const creativityValue = Math.round(config.creativity * 100);
            document.getElementById('creativity-slider').value = creativityValue;
            document.getElementById('creativity-value').textContent = config.creativity.toFixed(1);

            document.getElementById('custom-instructions').value = config.customInstructions;
            
            // Load Dialectic Mode (Cognitive Citadel)
            document.getElementById('ai-dialectic-mode').checked = config.dialecticMode || false;

            // Update preview
            updateAIPreview();

            modal.style.display = 'flex';
        }

        // Close AI Settings Modal
        function closeAISettingsModal() {
            document.getElementById('ai-settings-modal').style.display = 'none';
        }

        // Update Live Preview
        function updateAIPreview() {
            const tone = document.querySelector('input[name="ai-tone"]:checked').value;
            const verbosity = document.querySelector('input[name="ai-verbosity"]:checked').value;
            const creativity = document.getElementById('creativity-slider').value / 100;
            const customInstructions = document.getElementById('custom-instructions').value;
            const dialecticMode = document.getElementById('ai-dialectic-mode').checked;

            // Build preview tuning
            let tuning = "";

            if (tone === 'critical') {
                tuning += "ROLE ADAPTATION: You are a ruthless Red Team critic. Challenge assumptions. Find flaws. Do not be polite.\n";
            } else if (tone === 'socratic') {
                tuning += "ROLE ADAPTATION: Do not give answers directly. Ask probing questions to guide the user to discover the solution themselves.\n";
            } else if (tone === 'enthusiastic') {
                tuning += "ROLE ADAPTATION: Be high-energy and encouraging. Focus on opportunities and 'yes, and' thinking. Use energizing language.\n";
            }

            if (verbosity === 'concise') {
                tuning += "OUTPUT STYLE: Be extremely brief. Use telegraphic style. No fluff. Bullet points preferred.\n";
            } else if (verbosity === 'verbose') {
                tuning += "OUTPUT STYLE: Be thorough and detailed. Explain reasoning fully. Provide comprehensive analysis with examples.\n";
            }

            if (dialecticMode) {
                tuning += "ðŸ›¡ï¸ DIALECTIC MODE: Identify assumptions and counter-arguments before helping.\n";
            }

            if (customInstructions.trim()) {
                tuning += `\nUSER PRIORITY INSTRUCTION: ${customInstructions.trim()}\n`;
            }

            const basePrompt = "You are an expert project manager specializing in breaking down complex tasks...";
            const finalPrompt = tuning ? `${tuning}\n${basePrompt}` : basePrompt;

            document.getElementById('preview-after').textContent = finalPrompt;
        }

        // Save AI Settings
        function saveAISettings() {
            const tone = document.querySelector('input[name="ai-tone"]:checked').value;
            const verbosity = document.querySelector('input[name="ai-verbosity"]:checked').value;
            const creativity = document.getElementById('creativity-slider').value / 100;
            const customInstructions = document.getElementById('custom-instructions').value;
            const dialecticMode = document.getElementById('ai-dialectic-mode').checked;

            // Save to tree
            capexTree.aiConfig = {
                tone,
                verbosity,
                creativity,
                dialecticMode,
                customInstructions
            };

            // Persist to localStorage
            saveToLocalStorage();

            console.log('âœ… AI Settings saved:', capexTree.aiConfig);

            // Show toast notification
            showToast('âœ… AI Settings Saved - Your AI persona preferences have been saved to this tree.');

            closeAISettingsModal();
        }

        // Reset to Defaults
        function resetAISettings() {
            document.querySelector('input[name="ai-tone"][value="neutral"]').checked = true;
            document.querySelector('input[name="ai-verbosity"][value="concise"]').checked = true;
            document.getElementById('creativity-slider').value = 50;
            document.getElementById('creativity-value').textContent = '0.5';
            document.getElementById('custom-instructions').value = '';
            document.getElementById('ai-dialectic-mode').checked = false;

            updateAIPreview();
        }

        // Event Listeners for AI Settings Modal
        window.addEventListener('DOMContentLoaded', () => {
            // AI Settings button
            const aiSettingsBtn = document.getElementById('ai-settings-btn');
            if (aiSettingsBtn) {
                aiSettingsBtn.addEventListener('click', openAISettingsModal);
            }

            // Tone radio buttons
            const toneRadios = document.querySelectorAll('input[name="ai-tone"]');
            toneRadios.forEach(radio => {
                radio.addEventListener('change', updateAIPreview);
            });

            // Verbosity radio buttons
            const verbosityRadios = document.querySelectorAll('input[name="ai-verbosity"]');
            verbosityRadios.forEach(radio => {
                radio.addEventListener('change', updateAIPreview);
            });

            // Creativity slider
            const slider = document.getElementById('creativity-slider');
            if (slider) {
                slider.addEventListener('input', (e) => {
                    const value = (e.target.value / 100).toFixed(1);
                    document.getElementById('creativity-value').textContent = value;
                    updateAIPreview();
                });
            }

            // Custom instructions
            const customInstructions = document.getElementById('custom-instructions');
            if (customInstructions) {
                customInstructions.addEventListener('input', updateAIPreview);
            }

            // Dialectic Mode checkbox (Cognitive Citadel)
            const dialecticCheckbox = document.getElementById('ai-dialectic-mode');
            if (dialecticCheckbox) {
                dialecticCheckbox.addEventListener('change', updateAIPreview);
            }

            // Pattern selector - handle pattern switching with translation
            const patternSelect = document.getElementById('pattern-select');
            if (patternSelect) {
                patternSelect.addEventListener('change', (e) => {
                    const oldPattern = currentPattern;
                    const newPattern = e.target.value;

                    // Check if a translation rule exists
                    const ruleKey = `${oldPattern}->${newPattern}`;
                    if (TRANSLATION_RULES[ruleKey]) {
                        const patternNames = {
                            generic: 'Generic Project',
                            sales: 'Sales Pipeline',
                            thesis: 'Academic Writing',
                            roadmap: 'Product Roadmap',
                            book: 'Book Writing',
                            film: 'Film Production',
                            veo3: 'Veo3 (Google)',
                            sora2: 'Sora2 (OpenAI)',
                            prompting: 'AI Prompt Design',
                            gmail: 'Gmail Threads',
                            eventplanning: 'Event Planning',
                            fitness: 'Fitness Program',
                            strategy: 'Strategy Consulting',
                            coursedesign: 'Course Design',
                            familytree: 'Family Tree',
                            philosophy: 'Philosophy Dialogue',
                            rhetoric: 'Rhetoric Analysis',
                            filesystem: 'Filesystem'
                        };

                        const confirmTranslation = confirm(
                            `âœ¨ Translate data from ${patternNames[oldPattern] || oldPattern} to ${patternNames[newPattern] || newPattern}?\n\n` +
                            `This will intelligently map fields (e.g., Cost â†’ Deal Value).\n\n` +
                            `Your original data will be preserved in shadow storage and can be restored.`
                        );

                        if (confirmTranslation) {
                            // Save state for undo
                            saveState(`Pattern Switch: ${oldPattern} â†’ ${newPattern}`);

                            // Apply translation
                            translateTree(oldPattern, newPattern);

                            // Update current pattern
                            currentPattern = newPattern;

                            // Re-render
                            render();

                            // Update cluster-by options for new pattern
                            if (typeof updateClusterByOptions === 'function') {
                                updateClusterByOptions();
                            }

                            showToast('âœ… Data translated successfully', `Fields mapped from ${patternNames[oldPattern]} to ${patternNames[newPattern]}`);
                        } else {
                            // User cancelled - revert dropdown
                            e.target.value = oldPattern;
                        }
                    } else {
                        // No translation rule - just switch pattern
                        saveState(`Pattern Switch: ${oldPattern} â†’ ${newPattern}`);
                        currentPattern = newPattern;
                        render();

                        // Update cluster-by options for new pattern
                        if (typeof updateClusterByOptions === 'function') {
                            updateClusterByOptions();
                        }
                    }
                });
            }
        });

        // =============================================================================
        // END AI TUNER
        // =============================================================================

        // =============================================================================
        // PATTERN TRANSLATION ENGINE - Shadow Data Preservation
        // =============================================================================

        // Translation rules: Map fields from one pattern to another
        const TRANSLATION_RULES = {
            'generic->sales': (item) => {
                const updates = {};

                // 1. Map Cost â†’ Deal Value
                if (item.cost !== undefined && item.cost !== null) {
                    updates.dealValue = item.cost;
                }

                // 2. Map Status â†’ Stage Probability (Heuristic)
                if (item.pmStatus) {
                    if (item.pmStatus === 'Done' || item.pmStatus === 'Completed') {
                        updates.stageProbability = 100;
                    } else if (item.pmStatus === 'In Progress') {
                        updates.stageProbability = 60;
                    } else {
                        updates.stageProbability = 10;
                    }
                }

                // 3. Map Lead Time â†’ Notes (preserve as context)
                if (item.leadTime) {
                    updates.notes = (item.notes || '') + `\n[Original Lead Time: ${item.leadTime}]`;
                }

                // 4. Map Owner Email â†’ Contact Person
                if (item.pmOwnerEmail) {
                    updates.contactPerson = item.pmOwnerEmail;
                }

                // 5. Map Description
                if (item.description) {
                    updates.description = item.description;
                }

                return updates;
            },

            'sales->generic': (item) => {
                const updates = {};

                // Reverse mapping: Sales â†’ Generic
                if (item.dealValue !== undefined && item.dealValue !== null) {
                    updates.cost = item.dealValue;
                }

                if (item.stageProbability !== undefined) {
                    if (item.stageProbability >= 90) {
                        updates.pmStatus = 'Done';
                    } else if (item.stageProbability >= 50) {
                        updates.pmStatus = 'In Progress';
                    } else {
                        updates.pmStatus = 'Not Started';
                    }
                }

                if (item.contactPerson) {
                    updates.pmOwnerEmail = item.contactPerson;
                }

                return updates;
            }
        };

        // Recursively translate a node and its children
        function translateNode(node, fromPattern, toPattern) {
            const ruleKey = `${fromPattern}->${toPattern}`;
            const translator = TRANSLATION_RULES[ruleKey];

            if (!translator) {
                console.log(`âš ï¸ No translation rule for ${ruleKey}`);
                return; // No rule exists
            }

            // 1. Initialize shadow storage if missing
            if (!node.shadowData) {
                node.shadowData = {};
            }

            // 2. Backup current pattern data (only fields being translated)
            if (!node.shadowData[fromPattern]) {
                node.shadowData[fromPattern] = {};
                // Store only fields that will be changed
                const updates = translator(node);
                Object.keys(updates).forEach(key => {
                    if (node[key] !== undefined) {
                        node.shadowData[fromPattern][key] = node[key];
                    }
                });
            }

            // 3. Apply translation updates
            const updates = translator(node);
            Object.assign(node, updates);

            console.log(`âœ… Translated node: ${node.name}`, updates);

            // 4. Process children recursively
            if (node.items) {
                node.items.forEach(child => translateNode(child, fromPattern, toPattern));
            }
            if (node.children) {
                node.children.forEach(child => translateNode(child, fromPattern, toPattern));
            }
            if (node.subItems) {
                node.subItems.forEach(child => translateNode(child, fromPattern, toPattern));
            }
        }

        // Translate entire tree
        function translateTree(fromPattern, toPattern) {
            console.log(`ðŸ”„ Starting tree translation: ${fromPattern} â†’ ${toPattern}`);

            // Start from root's children (phases)
            if (capexTree.children) {
                capexTree.children.forEach(phase => {
                    translateNode(phase, fromPattern, toPattern);
                });
            }

            console.log(`âœ… Tree translation complete`);
        }

        // =============================================================================
        // END PATTERN TRANSLATION ENGINE
        // =============================================================================

        // =============================================================================
        // REAL AI INTEGRATION - Claude by Anthropic (via Netlify Function)
        // =============================================================================

        // API Configuration - Supports both local API key and Netlify serverless function
        const AI_CONFIG = {
            provider: 'anthropic',
            get model() {
                // Dynamic model selection - user can choose Haiku (fast) or Sonnet (best)
                return getClaudeModelId();
            },
            // Netlify function endpoint (fallback)
            apiEndpoint: 'https://treelisty.netlify.app/.netlify/functions/claude-proxy',
            // Direct Anthropic API endpoint (when using local API key)
            directEndpoint: 'https://api.anthropic.com/v1/messages'
        };

        // Multi-provider API key management
        function getLocalAPIKey(provider = 'anthropic') {
            return localStorage.getItem(`${provider}_api_key`);
        }

        function setLocalAPIKey(key, provider = 'anthropic') {
            localStorage.setItem(`${provider}_api_key`, key);
        }

        function clearLocalAPIKey(provider = 'anthropic') {
            localStorage.removeItem(`${provider}_api_key`);
        }

        // Get AI provider preference
        function getAIProvider() {
            return localStorage.getItem('ai_provider') || 'anthropic';
        }

        function setAIProvider(provider) {
            localStorage.setItem('ai_provider', provider);
        }

        // Get redundancy mode preference
        function getRedundancyMode() {
            return localStorage.getItem('ai_redundancy_mode') === 'true';
        }

        function setRedundancyMode(enabled) {
            localStorage.setItem('ai_redundancy_mode', enabled.toString());
        }

        // Unified AI Mode management (combines provider, model, and processing mode)
        function getUnifiedAIMode() {
            return localStorage.getItem('unified_ai_mode') || 'server-sonnet';
        }

        function setUnifiedAIMode(mode) {
            localStorage.setItem('unified_ai_mode', mode);
            console.log(`âœ… Unified AI mode set to: ${mode}`);

            // Update the dropdown
            const select = document.getElementById('unified-ai-mode-select');
            if (select) {
                select.value = mode;
            }
        }

        // Parse unified mode into components
        function parseUnifiedMode(mode = null) {
            const unifiedMode = mode || getUnifiedAIMode();

            if (unifiedMode === 'off') {
                return {
                    enabled: false,
                    provider: null,
                    model: null,
                    mode: 'off',
                    requiresKey: false,
                    description: 'AI features disabled'
                };
            }

            // Model definitions - all available models with their API IDs and metadata
            const MODEL_DEFINITIONS = {
                // Claude models (server = uses our Netlify proxy key, user = user's key)
                'server-haiku': {
                    provider: 'anthropic',
                    model: 'haiku',
                    modelId: 'claude-3-haiku-20240307',
                    useServerKey: true,
                    description: 'Fast & cheap - 200 req/hr limit'
                },
                'server-sonnet': {
                    provider: 'anthropic',
                    model: 'sonnet',
                    modelId: 'claude-sonnet-4-20250514',
                    useServerKey: true,
                    description: 'Best reasoning - 200 req/hr limit'
                },
                'user-haiku': {
                    provider: 'anthropic',
                    model: 'haiku',
                    modelId: 'claude-3-5-haiku-20241022',
                    useServerKey: false,
                    description: 'Fast - Claude 3.5 Haiku (~$1/1M in, $5/1M out)'
                },
                'user-sonnet': {
                    provider: 'anthropic',
                    model: 'sonnet',
                    modelId: 'claude-sonnet-4-20250514',
                    useServerKey: false,
                    description: 'Best reasoning (~$3/1M in, $15/1M out)'
                },
                'user-opus': {
                    provider: 'anthropic',
                    model: 'opus',
                    modelId: 'claude-opus-4-20250514',
                    useServerKey: false,
                    description: 'Most capable (~$15/1M in, $75/1M out)'
                },
                // Gemini models (always user key, direct API = no timeout!)
                'user-gemini-flash': {
                    provider: 'gemini',
                    model: 'gemini-flash',
                    modelId: 'gemini-2.0-flash',
                    useServerKey: false,
                    description: 'Fast - Gemini 2.0 Flash (Free tier available)'
                },
                'user-gemini-pro': {
                    provider: 'gemini',
                    model: 'gemini-pro',
                    modelId: 'gemini-2.5-pro-preview-05-06',
                    useServerKey: false,
                    description: 'Most capable - Gemini 2.5 Pro Preview'
                },
                // Legacy: user-gemini maps to flash
                'user-gemini': {
                    provider: 'gemini',
                    model: 'gemini-flash',
                    modelId: 'gemini-2.0-flash',
                    useServerKey: false,
                    description: 'Gemini 2.0 Flash'
                },
                // ChatGPT models (always user key, direct API = no timeout!)
                'user-gpt4o-mini': {
                    provider: 'openai',
                    model: 'gpt-4o-mini',
                    modelId: 'gpt-4o-mini',
                    useServerKey: false,
                    description: 'Fast & cheap - GPT-4o Mini (~$0.15/1M in, $0.60/1M out)'
                },
                'user-gpt4o': {
                    provider: 'openai',
                    model: 'gpt-4o',
                    modelId: 'gpt-4o',
                    useServerKey: false,
                    description: 'Flagship - GPT-4o (~$2.50/1M in, $10/1M out)'
                },
                'user-o1': {
                    provider: 'openai',
                    model: 'o1',
                    modelId: 'o1',
                    useServerKey: false,
                    description: 'Reasoning model - o1 (~$15/1M in, $60/1M out)'
                },
                // Legacy: user-chatgpt maps to gpt-4o
                'user-chatgpt': {
                    provider: 'openai',
                    model: 'gpt-4o',
                    modelId: 'gpt-4o',
                    useServerKey: false,
                    description: 'GPT-4o'
                }
            };

            const modelDef = MODEL_DEFINITIONS[unifiedMode];

            if (!modelDef) {
                console.warn(`Unknown AI mode: ${unifiedMode}, falling back to server-sonnet`);
                return parseUnifiedMode('server-sonnet');
            }

            // Determine processing mode: server key = quick (10s limit), user key = deep (no limit for Gemini/ChatGPT)
            const processingMode = modelDef.useServerKey ? 'quick' : 'deep';

            return {
                enabled: true,
                provider: modelDef.provider,
                model: modelDef.model,
                modelId: modelDef.modelId,
                mode: processingMode,
                useServerKey: modelDef.useServerKey,
                requiresKey: !modelDef.useServerKey,
                description: modelDef.description
            };
        }

        // Legacy compatibility functions (for existing code)
        function getGlobalAIMode() {
            const parsed = parseUnifiedMode();
            return parsed.enabled ? parsed.mode : 'off';
        }

        function getAIProvider() {
            const parsed = parseUnifiedMode();
            return parsed.provider || 'anthropic';
        }

        function getClaudeModelId() {
            const parsed = parseUnifiedMode();
            return parsed.modelId || 'claude-sonnet-4-20250514';
        }

        function canUseServerlessAI() {
            return Boolean(AI_CONFIG && typeof AI_CONFIG.apiEndpoint === 'string' && AI_CONFIG.apiEndpoint.length > 0);
        }

        function showApiKeyModal(prefillExisting = false) {
            const apiKeyModal = document.getElementById('api-key-modal');
            const claudeInput = document.getElementById('claude-api-key-input');
            const geminiInput = document.getElementById('gemini-api-key-input');
            const openaiInput = document.getElementById('openai-api-key-input');
            const providerSelect = document.getElementById('provider-select');

            // Load existing keys
            const claudeKey = getLocalAPIKey('anthropic');
            const geminiKey = getLocalAPIKey('gemini');
            const openaiKey = getLocalAPIKey('openai');
            const currentProvider = getAIProvider();

            // Prefill keys if requested
            claudeInput.value = prefillExisting && claudeKey ? claudeKey : '';
            geminiInput.value = prefillExisting && geminiKey ? geminiKey : '';
            openaiInput.value = prefillExisting && openaiKey ? openaiKey : '';

            // Set provider dropdown
            providerSelect.value = currentProvider;

            // Update status badges
            updateKeyStatusBadges();

            // Reset show checkbox
            document.getElementById('api-key-show').checked = false;

            apiKeyModal.style.display = 'flex';
        }

        function updateKeyStatusBadges() {
            const claudeStatus = document.getElementById('claude-key-status');
            const geminiStatus = document.getElementById('gemini-key-status');
            const openaiStatus = document.getElementById('openai-key-status');

            const claudeKey = getLocalAPIKey('anthropic');
            const geminiKey = getLocalAPIKey('gemini');
            const openaiKey = getLocalAPIKey('openai');

            if (claudeKey) {
                claudeStatus.textContent = 'âœ“ Saved';
                claudeStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                claudeStatus.style.color = '#22c55e';
            } else {
                claudeStatus.textContent = 'Not saved';
                claudeStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                claudeStatus.style.color = '#9ca3af';
            }

            if (geminiKey) {
                geminiStatus.textContent = 'âœ“ Saved';
                geminiStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                geminiStatus.style.color = '#22c55e';
            } else {
                geminiStatus.textContent = 'Not saved';
                geminiStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                geminiStatus.style.color = '#9ca3af';
            }

            if (openaiKey) {
                openaiStatus.textContent = 'âœ“ Saved';
                openaiStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                openaiStatus.style.color = '#22c55e';
            } else {
                openaiStatus.textContent = 'Not saved';
                openaiStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                openaiStatus.style.color = '#9ca3af';
            }
        }

        // Helper: Direct API call to Anthropic (bypasses Netlify, no timeout limit)
        async function callClaudeDirectAPI(requestData, apiKey) {
            console.log('ðŸš€ Direct API: Calling Anthropic Claude directly (no Netlify timeout)');

            try {
                const response = await fetch(AI_CONFIG.directEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    throw new Error(error.error?.message || `Claude API error: ${response.status}`);
                }

                return response;
            } catch (error) {
                // CORS errors show as "Failed to fetch" or TypeError
                if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
                    console.error('âŒ CORS Error: Browser blocked direct API call to api.anthropic.com');
                    throw new Error('Failed to fetch'); // Re-throw for upstream handling
                }
                throw error;
            }
        }

        // Helper: Direct API call to Google Gemini
        async function callGeminiDirectAPI(prompt, systemPrompt, maxTokens, apiKey) {
            console.log('ðŸš€ Direct API: Calling Google Gemini directly');

            // Gemini API format is different from Claude
            const geminiRequest = {
                contents: [{
                    parts: [{
                        text: (systemPrompt ? systemPrompt + '\n\n' : '') + prompt
                    }]
                }],
                generationConfig: {
                    maxOutputTokens: maxTokens,
                    temperature: 0.7
                }
            };

            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(geminiRequest)
                }
            );

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `Gemini API error: ${response.status}`);
            }

            const data = await response.json();

            // Convert Gemini response format to Claude-like format for consistency
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                throw new Error('Invalid Gemini response structure');
            }

            return {
                json: async () => ({
                    content: [{
                        text: data.candidates[0].content.parts[0].text
                    }]
                }),
                ok: true
            };
        }

        // Helper: Direct API call to OpenAI ChatGPT
        async function callOpenAIDirectAPI(prompt, systemPrompt, maxTokens, apiKey) {
            console.log('ðŸš€ Direct API: Calling OpenAI ChatGPT directly');

            // OpenAI API format
            const openaiRequest = {
                model: 'gpt-4o', // Using GPT-4o (latest optimized model)
                max_tokens: maxTokens,
                temperature: 0.7,
                messages: [
                    {
                        role: 'system',
                        content: systemPrompt || 'You are an expert project analyst specializing in breaking down complex projects into manageable components.'
                    },
                    {
                        role: 'user',
                        content: prompt
                    }
                ]
            };

            const response = await fetch(
                'https://api.openai.com/v1/chat/completions',
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(openaiRequest)
                }
            );

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `OpenAI API error: ${response.status}`);
            }

            const data = await response.json();

            // Convert OpenAI response format to Claude-like format for consistency
            if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                throw new Error('Invalid OpenAI response structure');
            }

            return {
                json: async () => ({
                    content: [{
                        text: data.choices[0].message.content
                    }]
                }),
                ok: true
            };
        }

        // Unified AI API caller - supports multiple providers (Claude, Gemini, OpenAI)
        async function callClaudeAPI(prompt, systemPrompt = '', maxTokens = 1024, useExtendedThinking = false, retryCount = 0) {
            const MAX_RETRIES = 2;
            const provider = getAIProvider();

            // Apply AI Tuner persona settings to system prompt
            systemPrompt = applyPersonaTuning(systemPrompt);

            // Debug logging for Deep Mode routing
            if (useExtendedThinking) {
                console.log('ðŸ” Deep Mode requested:', { provider, useExtendedThinking, hasLocalKey: !!getLocalAPIKey('anthropic') });
            }

            // If Gemini is selected and user has Gemini key, use Gemini directly
            if (provider === 'gemini') {
                const geminiKey = getLocalAPIKey('gemini');
                if (geminiKey) {
                    // Check if running from local file - CORS will block Gemini API
                    const isLocalFile = window.location.protocol === 'file:';
                    if (isLocalFile) {
                        console.error('âŒ Gemini API blocked - running from local file');
                        console.warn('ðŸ’¡ Gemini requires web server deployment to avoid CORS');
                        console.warn('âœ… Solution 1: Deploy to Netlify/Vercel for Gemini support');
                        console.warn('âœ… Solution 2: Use Claude (has proxy fallback for local files)');
                        throw new Error(`Gemini API requires web server deployment (CORS policy).\n\nðŸ’¡ Solutions:\n1. Deploy to Netlify/Vercel - full Gemini support\n2. Use Claude provider - works from local files via proxy\n3. Open in web server (not file://)\n\nðŸ” Running from: ${window.location.protocol}\nâœ… Claude has proxy fallback, Gemini requires deployment`);
                    }

                    console.log('ðŸ”· Using Google Gemini');
                    try {
                        const response = await callGeminiDirectAPI(prompt, systemPrompt, maxTokens, geminiKey);
                        const data = await response.json();
                        return data.content[0].text;
                    } catch (error) {
                        console.error('âŒ Gemini API error:', error);
                        throw new Error(`Gemini error: ${error.message}`);
                    }
                } else {
                    // Gemini selected but no key - show helpful error
                    throw new Error('Gemini API key not found. Please add your Gemini API key (ðŸ”‘ button) or switch to Claude.');
                }
            }

            // If OpenAI is selected and user has OpenAI key, use OpenAI directly
            if (provider === 'openai') {
                const openaiKey = getLocalAPIKey('openai');
                if (openaiKey) {
                    // Check if running from local file - CORS will block OpenAI API
                    const isLocalFile = window.location.protocol === 'file:';
                    if (isLocalFile) {
                        console.error('âŒ ChatGPT API blocked - running from local file');
                        console.warn('ðŸ’¡ ChatGPT requires web server deployment to avoid CORS');
                        console.warn('âœ… Solution 1: Deploy to Netlify/Vercel for ChatGPT support');
                        console.warn('âœ… Solution 2: Use Claude (has proxy fallback for local files)');
                        throw new Error(`ChatGPT API requires web server deployment (CORS policy).\n\nðŸ’¡ Solutions:\n1. Deploy to Netlify/Vercel - full ChatGPT support\n2. Use Claude provider - works from local files via proxy\n3. Open in web server (not file://)\n\nðŸ” Running from: ${window.location.protocol}\nâœ… Claude has proxy fallback, ChatGPT requires deployment`);
                    }

                    console.log('ðŸ’¬ Using OpenAI ChatGPT');
                    try {
                        const response = await callOpenAIDirectAPI(prompt, systemPrompt, maxTokens, openaiKey);
                        const data = await response.json();
                        return data.content[0].text;
                    } catch (error) {
                        console.error('âŒ OpenAI API error:', error);
                        throw new Error(`OpenAI error: ${error.message}`);
                    }
                } else {
                    // OpenAI selected but no key - show helpful error
                    throw new Error('OpenAI API key not found. Please add your OpenAI API key (ðŸ”‘ button) or switch to Claude.');
                }
            }

            // Otherwise, use Claude (existing logic below)
            const localApiKey = getLocalAPIKey('anthropic'); // Get Claude key for Claude logic

            // ENFORCE: Deep Mode requires user API key (consistent with Gemini/ChatGPT)
            if (useExtendedThinking && !localApiKey) {
                throw new Error(`ðŸ§  Deep Mode requires your own API key to avoid Netlify's 10-second timeout.\n\nâœ… Solutions:\n1. Add your Anthropic API key (ðŸ”‘ button) - enables Deep Mode with Extended Thinking\n2. Switch to âš¡ Fast Mode - works with server API key\n\nðŸ’¡ Deep Mode uses Extended Thinking (5000 token reasoning budget) which can take 15-30 seconds - too slow for Netlify's free tier limit.\n\nGemini and ChatGPT also require user API keys for the same reason.`);
            }

            // Apply AI Tuner persona settings to system prompt
            const aiConfig = getAIConfig(); // Get AI config for temperature
            const finalSystemPrompt = applyPersonaTuning(systemPrompt || 'You are an expert project analyst specializing in breaking down complex projects into manageable components.');

            const requestData = {
                model: AI_CONFIG.model,
                max_tokens: maxTokens,
                temperature: aiConfig.creativity, // âœ… INJECTED: Maps slider (0.0-1.0) to API temperature
                system: finalSystemPrompt,
                messages: [{
                    role: 'user',
                    content: prompt
                }]
            };

            // Use extended thinking for JSON generation to avoid syntax errors
            if (useExtendedThinking) {
                requestData.thinking = {
                    type: "enabled",
                    budget_tokens: 5000  // Increased from 2000 for Deep Mode (more reasoning time)
                };
                // CRITICAL: Temperature MUST be 1 when thinking is enabled
                // https://docs.claude.com/en/docs/build-with-claude/extended-thinking#important-considerations-when-using-extended-thinking
                requestData.temperature = 1;
            }

            let response;

            // CRITICAL: Deep Mode with user key MUST use direct API (never Netlify)
            // Gemini and ChatGPT always use direct API, Sonnet must too

            // Auto-detect local file access (file:// protocol)
            const isLocalFile = window.location.protocol === 'file:';

            if (useExtendedThinking && localApiKey) {
                // Check if running from local file - CORS will block direct API
                if (isLocalFile) {
                    console.warn('âš ï¸ Deep Mode requested but running from local file');
                    console.warn('ðŸ”„ Auto-switching to Fast Mode (Netlify proxy) to avoid CORS');
                    console.warn('ðŸ’¡ Deploy to web server for full Deep Mode support');

                    // Show user-facing info message about the auto-switch
                    console.info('â„¹ï¸ Running from local file - using Fast Mode instead of Deep Mode to avoid CORS errors');
                    console.info('âœ… Fast Mode still works great from local files via Netlify proxy');

                    // Fall through to Fast Mode (Netlify proxy) below
                    // This will work from local files but has 10s timeout limit
                } else {
                    // Running from deployed web server
                    // IMPORTANT: Anthropic's API does NOT allow direct browser calls (CORS blocked)
                    // We MUST use Netlify proxy, but Extended Thinking often exceeds 10s timeout
                    console.warn('âš ï¸ Deep Mode: Anthropic API blocks direct browser calls (CORS policy)');
                    console.warn('ðŸ”„ Using Netlify proxy with Extended Thinking - may timeout on complex requests');
                    console.warn('ðŸ’¡ For guaranteed Deep Mode: Use Gemini (allows direct API) or upgrade to Netlify Pro');

                    // Keep Extended Thinking enabled - let it try via Netlify
                    // User will get timeout error if it takes >10s, but smaller requests may work
                    // Fall through to Netlify proxy below
                }
            }

            // ALL Claude API calls go through Netlify proxy (Anthropic blocks direct browser calls via CORS)
            // This includes both Fast Mode and Deep Mode - Deep Mode may timeout on complex requests
            if (true) { // Always use Netlify for Claude
                // Log the mode being used
                if (requestData.thinking) {
                    console.log('ðŸ§  Deep Mode: Using Netlify proxy with Extended Thinking');
                    console.log('âš ï¸ Complex requests may timeout (Netlify free tier: 10s limit)');
                }
                console.log(localApiKey ? 'ðŸ”‘ Using Netlify function with your API key' : 'ðŸŒ Using Netlify function with server API key');

                const netlifyRequestBody = {
                    ...requestData,
                    // Include local API key if available (Netlify function will use it)
                    userApiKey: localApiKey || undefined
                };

                // Add timeout to prevent hanging on Netlify's 10s function limit
                // Increased to 25s to give Netlify full time (Sonnet can be slow)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 25000); // 25s timeout (Netlify has 10s limit on free tier)

                try {
                    response = await fetch(AI_CONFIG.apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(netlifyRequestBody),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                } catch (fetchError) {
                    clearTimeout(timeoutId);

                    // AUTOMATIC FALLBACK: If timeout AND user has API key, try direct API (only from local files)
                    if (fetchError.name === 'AbortError' && localApiKey) {
                        const isLocalFile = window.location.protocol === 'file:';

                        if (isLocalFile) {
                            // Running from file:// - try direct API fallback
                            console.warn('âš ï¸ Netlify timeout detected. Falling back to direct API (no timeout limit)...');
                            try {
                                response = await callClaudeDirectAPI(requestData, localApiKey);
                                console.log('âœ… Direct API fallback successful!');
                            } catch (directError) {
                                console.error('âŒ Direct API fallback failed:', directError);
                                throw new Error(`Netlify timeout AND direct API failed.\n\nâœ… Solutions:\n1. Run via local server: python -m http.server 8000\n2. Use deployed site: https://treelisty.netlify.app\n3. Use âš¡ Fast Mode (Haiku) - faster and works everywhere`);
                            }
                        } else {
                            // Running from web deployment (https://) - Claude API doesn't support CORS
                            throw new Error(`â±ï¸ Request timeout (Netlify 10-second limit exceeded)

âŒ Claude API doesn't support CORS - cannot bypass Netlify from browser

This happened because:
â€¢ Your request took longer than 10 seconds
â€¢ Netlify free tier has 10-second function timeout
â€¢ Claude's API blocks direct browser calls (CORS policy)
â€¢ Unlike Gemini/ChatGPT, Claude requires a proxy server

âœ… Solutions:
1. Use server-sonnet or server-haiku (Fast Mode) - usually completes in <10s
2. Reduce your request size - fewer nodes, shorter text
3. Self-host with backend that has no timeout limits

ðŸ’¡ The Chat Builder works best with Fast Mode on Netlify.`);
                        }
                    } else if (fetchError.name === 'AbortError') {
                        // Timeout but no user API key - can't fallback
                        throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nAdd your API key (ðŸ”‘ button) to bypass Netlify timeout.\n\nOr use âš¡ Fast Mode (Haiku) - faster and works everywhere.`);
                    } else {
                        throw fetchError;
                    }
                }

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));

                    // Log detailed error info for debugging
                    console.error('âŒ AI API Error Details:', {
                        status: response.status,
                        statusText: response.statusText,
                        usingLocalKey: !!localApiKey,
                        error: error
                    });

                    // Check for common errors
                    if (response.status === 0 || !response.status) {
                        throw new Error('Cannot connect to AI service. Please check your internet connection.');
                    }
                    if (response.status === 401) {
                        if (localApiKey) {
                            clearLocalAPIKey();
                            throw new Error('Invalid API key. Please check your Anthropic API key and try again.');
                        }
                        throw new Error('Authentication failed. Please configure your API key.');
                    }
                    if (response.status === 404) {
                        throw new Error('Netlify function not found (404). The serverless function may not be deployed.');
                    }
                    if (response.status === 504) {
                        // Gateway timeout from Netlify
                        if (localApiKey) {
                            // Fallback to direct API if user has key
                            console.warn('âš ï¸ Netlify 504 timeout. Falling back to direct API...');
                            try {
                                response = await callClaudeDirectAPI(requestData, localApiKey);
                                console.log('âœ… Direct API fallback successful after 504!');
                                // Exit error handling - response is now successful
                            } catch (directError) {
                                console.error('âŒ Direct API fallback failed:', directError);

                                // Check if this is a CORS error
                                if (directError.message === 'Failed to fetch' || directError.name === 'TypeError') {
                                    throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nDirect API fallback blocked by browser (CORS - you're running from file://).\n\nâœ… Solutions:\n1. Run via local server: python -m http.server 8000\n2. Use deployed site: https://treelisty.netlify.app\n3. Use âš¡ Fast Mode (Haiku) - faster and works everywhere\n\nðŸ’¡ Sonnet is powerful but slow - works best on deployed sites or with local server.`);
                                }

                                throw new Error(`Netlify 504 timeout AND direct API failed. Error: ${directError.message}`);
                            }
                        } else {
                            throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nAdd your API key (ðŸ”‘ button) to bypass Netlify timeout.\n\nOr use âš¡ Fast Mode (Haiku) - faster and works everywhere.`);
                        }
                    }

                    // If response is now ok (after fallback), skip remaining error checks
                    if (response.ok) {
                        // Continue to response parsing below
                    } else if (response.status === 429) {
                        // Rate limit - retry with exponential backoff
                        if (retryCount < MAX_RETRIES) {
                            const delay = Math.pow(2, retryCount) * 3000; // 3s, 6s
                            console.log(`ðŸ”„ Rate limit hit. Retrying in ${delay/1000} seconds... (attempt ${retryCount + 1}/${MAX_RETRIES})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callClaudeAPI(prompt, systemPrompt, maxTokens, useExtendedThinking, retryCount + 1);
                        }
                        throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                    } else if (response.status === 529) {
                        // API overloaded - retry with exponential backoff
                        if (retryCount < MAX_RETRIES) {
                            const delay = Math.pow(2, retryCount) * 2000; // 2s, 4s
                            console.log(`ðŸ”„ API overloaded. Retrying in ${delay/1000} seconds... (attempt ${retryCount + 1}/${MAX_RETRIES})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callClaudeAPI(prompt, systemPrompt, maxTokens, useExtendedThinking, retryCount + 1);
                        }
                        throw new Error('Anthropic API is temporarily overloaded. Please wait 10-30 seconds and try again.');
                    } else if (response.status === 500 && error.error?.message?.includes('configuration')) {
                        throw new Error('AI service is not configured. Please set up your API key.');
                    } else {
                        // Generic error
                        throw new Error(error.error?.message || `AI Service Error: ${response.status}`);
                    }
                }
            } // End of Fast Mode (Netlify) path

            // Common response handling (works for both Deep Mode direct API and Fast Mode Netlify)
            const data = await response.json();
            console.log('âœ… AI analysis successful');
            console.log('API Response data:', data);

            // Handle response - check if content exists
            if (!data.content || !Array.isArray(data.content) || data.content.length === 0) {
                console.error('Invalid API response structure:', data);
                throw new Error('Invalid response from AI service');
            }

            return data.content[0].text;
        }

        // Generate intelligent project analysis
        async function generateAIAnalysis(item, analysisType = 'item') {
            // Determine if this is a subtask or regular item/phase
            const isSubtask = item.type === 'subtask';

            let systemPrompt = '';
            let userPrompt = '';

            if (isSubtask) {
                // SUBTASK AI: Pattern-aware analysis for subtasks
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;

                // Pattern-specific subtask analysis
                if (currentPattern === 'philosophy') {
                    systemPrompt = `You are a philosophy professor specializing in philosophical argumentation and dialectical reasoning.`;

                    userPrompt = `Analyze this philosophical ${levels.subtask.toLowerCase()}:

**${levels.subtask}:** ${item.name}
**Description:** ${item.description || 'N/A'}
${item.textualReference ? `**Textual Reference:** ${item.textualReference}\n` : ''}${item.notes ? `**Notes:** ${item.notes}\n` : ''}
Provide philosophical analysis covering:
1. **Argumentative Function** - How does this support strengthen the parent claim?
2. **Logical Structure** - Is the reasoning valid? Are there gaps?
3. **Evidence Quality** - How strong is the supporting evidence or reasoning?
4. **Objections** - What counter-arguments might challenge this support?
5. **Recommendations** - How to strengthen this supporting argument`;

                } else {
                    // Generic PM analysis for non-philosophy patterns
                    systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                    userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;
                }

            } else if (analysisType === 'subtask') {
                // Fallback - same as isSubtask, pattern-aware
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;

                if (currentPattern === 'philosophy') {
                    systemPrompt = `You are a philosophy professor specializing in philosophical argumentation and dialectical reasoning.`;

                    userPrompt = `Analyze this philosophical ${levels.subtask.toLowerCase()}:

**${levels.subtask}:** ${item.name}
**Description:** ${item.description || 'N/A'}
${item.textualReference ? `**Textual Reference:** ${item.textualReference}\n` : ''}${item.notes ? `**Notes:** ${item.notes}\n` : ''}
Provide philosophical analysis covering:
1. **Argumentative Function** - How does this support strengthen the parent claim?
2. **Logical Structure** - Is the reasoning valid? Are there gaps?
3. **Evidence Quality** - How strong is the supporting evidence or reasoning?
4. **Objections** - What counter-arguments might challenge this support?
5. **Recommendations** - How to strengthen this supporting argument`;

                } else {
                    systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                    userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;
                }

            } else if (analysisType === 'item') {
                // PROJECT ITEM AI: Pattern-aware analysis
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;

                // Pattern-specific system prompts and analysis
                if (currentPattern === 'philosophy') {
                    systemPrompt = `You are a philosophy professor specializing in classical and contemporary philosophical arguments, dialectical reasoning, and philosophical methodology.`;

                    userPrompt = `Analyze this philosophical ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.speaker ? `**Speaker/Philosopher:** ${item.speaker}\n` : ''}${item.argumentType ? `**Argument Type:** ${item.argumentType}\n` : ''}${item.premise1 ? `**Premise 1:** ${item.premise1}\n` : ''}${item.premise2 ? `**Premise 2:** ${item.premise2}\n` : ''}${item.conclusion ? `**Conclusion:** ${item.conclusion}\n` : ''}${item.keyTerms ? `**Key Terms:** ${item.keyTerms}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a philosophical analysis covering:
1. **Logical Validity** - Is the argument structure sound? Are the premises valid?
2. **Dialectical Strength** - How does this argument engage with opposing views?
3. **Conceptual Clarity** - Are key terms well-defined? Any ambiguities?
4. **Objections to Consider** - What counter-arguments should be addressed?
5. **Historical/Textual Context** - Relevant philosophical traditions or sources
6. **Recommendations** - How to strengthen this argument or explore it further`;

                } else if (currentPattern === 'sales') {
                    systemPrompt = `You are a sales strategist with 20 years of enterprise B2B experience, specializing in deal progression, competitive positioning, and revenue forecasting.`;

                    userPrompt = `Analyze this sales ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.dealValue ? `**Deal Value:** $${(item.dealValue || 0).toLocaleString()}\n` : ''}${item.expectedCloseDate ? `**Expected Close:** ${new Date(item.expectedCloseDate).toLocaleDateString()}\n` : ''}${item.leadSource ? `**Lead Source:** ${item.leadSource}\n` : ''}${item.contactPerson ? `**Contact:** ${item.contactPerson}\n` : ''}${item.stageProbability ? `**Close Probability:** ${item.stageProbability}%\n` : ''}${item.competitorInfo ? `**Competitive Intel:** ${item.competitorInfo}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a sales analysis covering:
1. **Deal Health** - Is this deal progressing appropriately for its stage?
2. **Competitive Positioning** - How to differentiate from competitors?
3. **Next Steps** - Specific actions to advance this deal (meetings, demos, proposals)
4. **Risk Factors** - What could derail this opportunity?
5. **Close Strategy** - Recommended approach to accelerate close
6. **Upsell/Cross-sell** - Opportunities to expand deal value`;

                } else if (currentPattern === 'thesis') {
                    systemPrompt = `You are an academic advisor helping graduate students structure rigorous research, with expertise in thesis development, argumentation, and scholarly writing.`;

                    userPrompt = `Analyze this academic ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.wordCount ? `**Current Words:** ${item.wordCount}\n` : ''}${item.targetWordCount ? `**Target Words:** ${item.targetWordCount}\n` : ''}${item.keyCitations ? `**Key Citations:** ${item.keyCitations}\n` : ''}${item.keyArgument ? `**Main Argument:** ${item.keyArgument}\n` : ''}${item.evidenceType ? `**Evidence Type:** ${item.evidenceType}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide an academic analysis covering:
1. **Argument Strength** - Is the thesis argument clear and defensible?
2. **Evidence Quality** - Is the evidence sufficient and appropriate?
3. **Citation Coverage** - Are key sources adequately referenced?
4. **Structural Coherence** - Does this fit logically within the overall thesis?
5. **Scholarly Rigor** - Areas to strengthen academic quality
6. **Recommendations** - Specific next steps for development`;

                } else if (currentPattern === 'roadmap') {
                    systemPrompt = `You are a product manager experienced in agile development, feature prioritization, and engineering execution strategy.`;

                    userPrompt = `Analyze this product ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.storyPoints ? `**Story Points:** ${item.storyPoints}\n` : ''}${item.userImpact ? `**User Impact:** ${item.userImpact}\n` : ''}${item.technicalRisk ? `**Technical Risk:** ${item.technicalRisk}\n` : ''}${item.engineeringEstimate ? `**Engineering Estimate:** ${item.engineeringEstimate}\n` : ''}${item.featureFlag ? `**Feature Flag:** ${item.featureFlag}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a product analysis covering:
1. **User Value** - Does this feature deliver clear user benefit?
2. **Technical Feasibility** - Are the story points and risk assessment realistic?
3. **Prioritization** - Where should this rank given impact vs effort?
4. **Dependencies** - Are upstream features properly identified?
5. **Implementation Strategy** - Recommended approach (MVP, feature flag, phased rollout)
6. **Success Metrics** - How to measure if this feature succeeds`;

                } else if (currentPattern === 'prompting') {
                    systemPrompt = `You are an AI/ML engineer expert in prompt engineering for Claude and GPT-4, specializing in system design, agent workflows, and prompt optimization.`;

                    userPrompt = `Analyze this prompt ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.systemPrompt ? `**System Prompt:** ${item.systemPrompt.substring(0, 200)}${item.systemPrompt.length > 200 ? '...' : ''}\n` : ''}${item.userPromptTemplate ? `**User Template:** ${item.userPromptTemplate.substring(0, 200)}${item.userPromptTemplate.length > 200 ? '...' : ''}\n` : ''}${item.modelTarget ? `**Model:** ${item.modelTarget}\n` : ''}${item.temperature ? `**Temperature:** ${item.temperature}\n` : ''}${item.maxTokens ? `**Max Tokens:** ${item.maxTokens}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a prompt engineering analysis covering:
1. **Prompt Quality** - Is the system/user prompt clear and well-structured?
2. **Best Practices** - OpenAI/Anthropic recommendations being followed?
3. **Few-Shot Examples** - Are examples sufficient and high-quality?
4. **Chain-of-Thought** - Should CoT be added for better reasoning?
5. **Edge Cases** - What failure modes should be addressed?
6. **Optimization** - How to improve accuracy, cost, or latency`;

                } else if (currentPattern === 'book') {
                    systemPrompt = `You are a professional fiction editor and writing coach, specializing in narrative structure, character development, and storytelling craft.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.wordCount ? `**Current Words:** ${item.wordCount}\n` : ''}${item.targetWordCount ? `**Target Words:** ${item.targetWordCount}\n` : ''}${item.plotPoints ? `**Plot Points:** ${item.plotPoints}\n` : ''}${item.characterArcs ? `**Character Arcs:** ${item.characterArcs}\n` : ''}${item.pacing ? `**Pacing:** ${item.pacing}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a narrative analysis covering:
1. **Story Structure** - Does this chapter serve the overall narrative arc?
2. **Character Development** - Are character arcs progressing appropriately?
3. **Pacing** - Is the rhythm and tension appropriate for this section?
4. **Plot Points** - Are key story beats landing effectively?
5. **Scene Craft** - Suggestions for strengthening individual scenes
6. **Recommendations** - Specific revisions to improve this chapter`;

                } else if (currentPattern === 'film') {
                    systemPrompt = `You are a cinematographer and film director specializing in AI video production (Sora, Veo, Runway Gen-3), with expertise in visual storytelling, camera work, and production planning.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.aiPlatform ? `**AI Platform:** ${item.aiPlatform}\n` : ''}${item.videoPrompt ? `**Video Prompt:** ${item.videoPrompt.substring(0, 200)}${item.videoPrompt.length > 200 ? '...' : ''}\n` : ''}${item.visualStyle ? `**Visual Style:** ${item.visualStyle}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.cameraMovement ? `**Camera Movement:** ${item.cameraMovement}\n` : ''}${item.lightingMood ? `**Lighting:** ${item.lightingMood}\n` : ''}${item.motionIntensity ? `**Motion Intensity:** ${item.motionIntensity}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a production analysis covering:
1. **Prompt Quality** - Is the video prompt detailed enough for Sora/Veo?
2. **Visual Cohesion** - Does this scene match the project's visual style?
3. **Camera & Lighting** - Are technical specs appropriate for the mood?
4. **Production Feasibility** - Can current AI platforms deliver this vision?
5. **Sequence Flow** - How does this scene connect to dependencies?
6. **Optimization** - How to improve prompt for better AI generation`;

                } else if (currentPattern === 'course') {
                    systemPrompt = `You are an instructional designer specializing in curriculum development, learning objectives, and educational best practices.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.learningObjectives ? `**Learning Objectives:** ${item.learningObjectives}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.difficultyLevel ? `**Difficulty:** ${item.difficultyLevel}\n` : ''}${item.prerequisites ? `**Prerequisites:** ${item.prerequisites}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a pedagogical analysis covering:
1. **Learning Objectives** - Are objectives clear, measurable, and achievable?
2. **Content Structure** - Is the lesson logically organized for learning?
3. **Difficulty Progression** - Is this appropriately paced within the course?
4. **Engagement** - Are activities and assessments well-designed?
5. **Prerequisites** - Are dependencies and prior knowledge appropriate?
6. **Recommendations** - How to improve learning outcomes`;

                } else if (currentPattern === 'fitness') {
                    systemPrompt = `You are a certified personal trainer and exercise physiologist with expertise in program design, exercise science, progressive overload, and injury prevention.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.targetMuscleGroups ? `**Target Muscles:** ${item.targetMuscleGroups}\n` : ''}${item.sets ? `**Sets:** ${item.sets}\n` : ''}${item.reps ? `**Reps:** ${item.reps}\n` : ''}${item.restTime ? `**Rest:** ${item.restTime}\n` : ''}${item.intensity ? `**Intensity:** ${item.intensity}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a fitness analysis covering:
1. **Exercise Selection** - Are exercises appropriate for the training goal?
2. **Volume & Intensity** - Are sets, reps, and intensity optimized for progression?
3. **Progressive Overload** - Is the program structured for strength/endurance gains?
4. **Injury Prevention** - Are there any form cues or mobility prerequisites needed?
5. **Recovery** - Is rest time and workout spacing appropriate?
6. **Recommendations** - How to optimize this workout for better results`;

                } else if (currentPattern === 'event') {
                    systemPrompt = `You are a professional event planner with experience in corporate events, weddings, and large-scale conferences, specializing in logistics, vendor coordination, and timeline management.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.venue ? `**Venue:** ${item.venue}\n` : ''}${item.attendeeCount ? `**Attendees:** ${item.attendeeCount}\n` : ''}${item.startTime ? `**Start Time:** ${item.startTime}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.vendor ? `**Vendor:** ${item.vendor}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide an event planning analysis covering:
1. **Timeline Feasibility** - Is the activity appropriately scheduled and paced?
2. **Logistics** - Are venue, equipment, and vendor requirements clear?
3. **Guest Experience** - How does this contribute to attendee satisfaction?
4. **Dependencies** - Are setup/breakdown and sequential activities properly coordinated?
5. **Contingency Planning** - What backup plans are needed for this activity?
6. **Recommendations** - How to improve execution and guest experience`;

                } else if (currentPattern === 'strategy') {
                    systemPrompt = `You are a business strategy consultant specializing in strategic planning, KPI development, organizational transformation, and competitive positioning.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.kpi ? `**KPI:** ${item.kpi}\n` : ''}${item.targetValue ? `**Target:** ${item.targetValue}\n` : ''}${item.currentValue ? `**Current:** ${item.currentValue}\n` : ''}${item.owner ? `**Owner:** ${item.owner}\n` : ''}${item.timeframe ? `**Timeframe:** ${item.timeframe}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a strategic analysis covering:
1. **Strategic Alignment** - Does this initiative support the overall strategic pillar?
2. **KPI Quality** - Are metrics measurable, achievable, and meaningful?
3. **Resource Requirements** - What capabilities or investments are needed?
4. **Dependencies** - Are prerequisite initiatives or decisions identified?
5. **Risk Assessment** - What could prevent success and how to mitigate?
6. **Recommendations** - How to maximize strategic impact`;

                } else if (currentPattern === 'familytree') {
                    systemPrompt = `You are a professional genealogist and family historian specializing in genealogical research, family tree documentation, and historical record analysis.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.birthDate ? `**Birth:** ${item.birthDate}\n` : ''}${item.deathDate ? `**Death:** ${item.deathDate}\n` : ''}${item.birthPlace ? `**Birth Place:** ${item.birthPlace}\n` : ''}${item.occupation ? `**Occupation:** ${item.occupation}\n` : ''}${item.spouse ? `**Spouse:** ${item.spouse}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a genealogical analysis covering:
1. **Record Completeness** - Are key vital records (birth, death, marriage) documented?
2. **Source Quality** - Are sources reliable and properly cited?
3. **Relationship Verification** - Are family connections well-supported by evidence?
4. **Research Gaps** - What additional records or information should be sought?
5. **Conflicting Data** - Are there any inconsistencies to resolve?
6. **Recommendations** - Next steps for strengthening this family branch documentation`;

                } else if (currentPattern === 'dialogue') {
                    systemPrompt = `You are a rhetoric and argumentation expert specializing in debate analysis, logical fallacies, persuasive communication, and interpersonal psychology. Your expertise includes classical rhetoric (Aristotle, Cicero), modern argumentation theory, and political theater analysis.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Speaker:** ${item.speaker || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.verbatimQuote ? `**Verbatim Quote:** "${item.verbatimQuote}"\n` : ''}${item.rhetoricalDevice ? `**Rhetorical Device:** ${item.rhetoricalDevice}\n` : ''}${item.logicalStructure ? `**Logical Structure:** ${item.logicalStructure}\n` : ''}${item.fallaciesPresent ? `**Fallacies Identified:** ${item.fallaciesPresent}\n` : ''}${item.hiddenMotivation ? `**Hidden Motivation:** ${item.hiddenMotivation}\n` : ''}${item.emotionalTone ? `**Emotional Tone:** ${item.emotionalTone}\n` : ''}${item.evidenceQuality ? `**Evidence Quality:** ${item.evidenceQuality}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a rhetorical analysis covering:
1. **Argument Strength** - Evaluate the logical validity and persuasive power of this statement
2. **Rhetorical Techniques** - What persuasive devices are employed? How effective are they?
3. **Logical Fallacies** - Identify any fallacies (ad hominem, straw man, false dichotomy, etc.) and their impact
4. **Hidden Motivations** - What unstated goals or biases might be driving this argument?
5. **Counterargument Strategy** - What would be the most effective rebuttal or opposing position?
6. **Evidence Assessment** - How strong is the supporting evidence? What's missing?
7. **Recommendations** - How could this argument be strengthened or how should an opponent respond?`;

                } else if (currentPattern === 'filesystem') {
                    systemPrompt = `You are "LibrarianAI" for TreeListy.

Your job is to manage and enrich a **single filesystem** (one TreeListy tree) without ever directly deleting or renaming anything. You operate only by updating node metadata and proposing non-destructive actions.

Given a list of nodes (files and folders) with:
- node_id, path, is_folder
- basic metadata (size, timestamps, mime/type hints)
- existing AI fields (if any)

Do the following for **this filesystem only**:

1. **Enrich metadata for each node**
   - Infer and/or update:
     - summary_short: 1â€“2 line human-readable description.
     - tags: topical keywords.
     - project_guess: likely project or collection name (string).
     - status: one of draft | working | final | archive_candidate.
     - sensitivity_level: low | medium | high (e.g. legal/financial/personal = high).
     - lifecycle_stage: active | stale | historical | junk_candidate.
     - ai_confidence: 0â€“1 float for your overall judgment.
   - Never invent impossible details; base everything on filenames, paths, and any provided content/metadata.

2. **Detect redundancy and clusters**
   - Group near-duplicate or strongly related files into clusters.
   - For each node, set:
     - cluster_id: stable ID shared by similar files, or null.
     - canonical_id: the node_id of the best representative in that cluster, or equal to its own node_id if it is canonical.
   - Prefer canonical files that are more recent, more complete, and more likely to be in the correct folder.

3. **Assess data quality**
   - For each node, compute:
     - data_quality_score: 0â€“100, based on naming clarity, location, redundancy, and completeness.
   - Higher scores = clearer, better placed, non-redundant, and likely still useful.

4. **Propose safe actions only**
   - Do **not** delete, rename, or move anything directly.
   - Instead, populate an ai_actions_pending list per node with suggested operations, for example:
     - {"action": "move", "target_folder": "...", "reason": "...", "confidence": 0.82}
     - {"action": "archive", "reason": "...", "confidence": 0.76}
   - Be conservative: when in doubt, lower confidence and prefer suggestion over aggressive cleanup.

Act as a cautious, explainable librarian: improve structure and clarity, reduce redundancy, and surface suggestions, but never take irreversible or destructive actions yourself.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'File'}
**Path:** ${item.filePath || 'N/A'}
${item.isFolder ? `**Is Folder:** Yes\n` : ''}${item.fileSize ? `**Size:** ${(item.fileSize / 1024).toFixed(1)} KB\n` : ''}${item.fileExtension ? `**Extension:** ${item.fileExtension}\n` : ''}${item.dateModified ? `**Modified:** ${new Date(item.dateModified).toLocaleDateString()}\n` : ''}${item.dateCreated ? `**Created:** ${new Date(item.dateCreated).toLocaleDateString()}\n` : ''}${item.fileOwner ? `**Owner:** ${item.fileOwner}\n` : ''}${item.mimeType ? `**MIME Type:** ${item.mimeType}\n` : ''}**Description:** ${item.description || 'None'}
**Notes:** ${item.notes || 'None'}

Provide a LibrarianAI analysis covering:
1. **Metadata Enrichment** - Suggest summary_short, tags, project_guess, status, sensitivity_level, lifecycle_stage, ai_confidence
2. **Redundancy Detection** - Is this part of a cluster? Suggest cluster_id and canonical_id if similar files exist
3. **Data Quality Score** - Rate 0-100 based on naming clarity, location appropriateness, redundancy, and usefulness
4. **Proposed Actions** - Suggest safe, non-destructive actions (move, archive, tag) with confidence scores
5. **Organization Insights** - How does this fit within the overall filesystem structure?
6. **Recommendations** - Conservative suggestions to improve organization without destructive changes`;

                } else {
                    // Generic/default pattern - PM and CFO perspective
                    systemPrompt = `You are an experienced Project Manager and CFO with deep expertise in budget management, resource allocation, risk mitigation, and financial planning for complex projects. Provide strategic insights on cost optimization, timeline management, and delivery excellence.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${pattern.fields?.cost ? `**Cost:** $${(item.cost || 0).toLocaleString()}\n` : ''}${pattern.fields?.leadTime ? `**Lead Time:** ${item.leadTime || 'Not specified'}\n` : ''}${pattern.fields?.alternateSource ? `**Alternate Source:** ${item.alternateSource || 'Not specified'}\n` : ''}${item.pmRAGStatus ? `**RAG Status:** ${item.pmRAGStatus}\n` : ''}${item.pmOwnerEmail ? `**Owner:** ${item.pmOwnerEmail}\n` : ''}${item.pmEstimatedHours ? `**Estimated Hours:** ${item.pmEstimatedHours}h\n` : ''}${item.pmActualHours ? `**Actual Hours:** ${item.pmActualHours}h\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None provided'}

From a PM and CFO perspective, provide analysis covering:
1. **Financial Health** - Budget status, cost drivers, burn rate concerns, ROI considerations
2. **Risk Assessment** - Financial risks, schedule risks, resource constraints, mitigation strategies
3. **Time & Resource Management** - Timeline realism, resource allocation efficiency, critical path impacts
4. **Vendor & Procurement** - Supplier reliability, alternate source evaluation, contract considerations
5. **Stakeholder & Governance** - Approval gates, change management, reporting requirements
6. **Strategic Recommendations** - 2-3 actionable steps to improve delivery, reduce cost, or mitigate risk`;
                }

            } else if (analysisType === 'project') {
                // Project-level analysis (PATTERN-AWARE)
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;
                const allItems = getAllProjectItems();

                // Build phase breakdown
                const phaseBreakdown = capexTree.children?.map((phase, idx) => {
                    const phaseItems = allItems.filter(i => i.id?.startsWith(`p${idx}`));
                    let phaseLine = `- ${phase.name}`;

                    if (phase.subtitle) phaseLine += ` (${phase.subtitle})`;
                    phaseLine += `: ${phaseItems.length} ${levels.item.toLowerCase()}s`;

                    if (pattern.fields?.cost) {
                        const phaseTotal = phaseItems.reduce((sum, i) => sum + (i.cost || 0), 0);
                        phaseLine += `, $${phaseTotal.toLocaleString()}`;
                    }

                    return phaseLine;
                }).join('\n') || 'No phases defined';

                // Pattern-specific prompts
                if (currentPattern === 'book') {
                    systemPrompt = `You are a literary consultant specializing in narrative structure and book development. Provide insights on story structure, pacing, character development, and writing best practices.`;

                    userPrompt = `Analyze this book writing project:

**Title:** ${capexTree.name}
**Pattern:** Book Writing

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Story Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} builds on ${i.dependencies.length} previous element(s)`
).join('\n')}

` : ''}Provide an executive summary for this book project covering:
1. **Narrative Structure Assessment** - Is the part/chapter breakdown balanced and logical?
2. **Story Flow** - Comment on pacing and progression based on dependencies
3. **Development Recommendations** - Suggestions for strengthening the narrative structure
4. **Potential Issues** - Any structural concerns or gaps in the story arc
5. **Next Steps** - Actionable recommendations for the author

Focus on narrative structure and storytelling best practices.`;

                } else if (currentPattern === 'prompting') {
                    systemPrompt = `You are a prompt engineering expert specializing in LLM workflows, agent design, and AI system architecture. Provide insights on prompt structure, agent orchestration, and best practices.`;

                    userPrompt = `Analyze this AI prompt design project:

**Prompt Workbook:** ${capexTree.name}
**Pattern:** AI Prompt Design

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Agent Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} requires ${i.dependencies.length} upstream component(s)`
).join('\n')}

` : ''}Provide an executive summary for this prompt engineering project covering:
1. **Architecture Assessment** - Is the stage/module breakdown logical for an AI workflow?
2. **Agent Orchestration** - Comment on dependencies and data flow between modules
3. **Prompt Engineering Best Practices** - Recommendations for improving prompt quality
4. **Potential Issues** - Any architectural concerns or missing components
5. **Next Steps** - Actionable recommendations for the prompt engineer

Focus on prompt engineering and agent design best practices.`;

                } else if (pattern.fields?.cost) {
                    // Financial patterns (generic, sales, roadmap, etc.)
                    systemPrompt = `You are a senior project analyst specializing in project planning, budgeting, and execution strategy. Provide insights on project structure, resource allocation, and execution best practices.`;

                    const totalCost = calculateTotal(capexTree);

                    userPrompt = `Analyze this ${pattern.name.toLowerCase()} project:

**Project:** ${capexTree.name}
**Pattern:** ${pattern.name}
**Total Budget:** $${totalCost.toLocaleString()}

**${levels.phase} Breakdown:**
${phaseBreakdown}

${allItems.filter(i => i.cost > 1000000).length > 0 ? `**Major Line Items (>$1M):**
${allItems.filter(i => i.cost > 1000000).map(i =>
    `- ${i.name}: $${i.cost.toLocaleString()}${i.itemType ? ` (${i.itemType})` : ''}`
).join('\n')}

` : ''}${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Key Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} depends on ${i.dependencies.length} item(s)`
).join('\n')}

` : ''}Provide an executive-level analysis covering:
1. **Budget Assessment** - Is the allocation realistic for this type of project?
2. **Critical Path** - Key dependencies and timeline bottlenecks
3. **Risk Factors** - Top 3 risks to budget or timeline
4. **Optimization Opportunities** - Potential cost savings or efficiency gains
5. **Strategic Recommendations** - High-level guidance for stakeholders

Format for presentation to executives. Be concise but comprehensive.`;

                } else {
                    // Non-financial patterns (philosophy, thesis, etc.)
                    systemPrompt = `You are an expert consultant specializing in structured thinking and project organization. Provide insights on project structure, logical flow, and development best practices.`;

                    userPrompt = `Analyze this ${pattern.name.toLowerCase()} project:

**Project:** ${capexTree.name}
**Pattern:** ${pattern.name}

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Logical Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} builds on ${i.dependencies.length} previous element(s)`
).join('\n')}

` : ''}Provide an executive summary covering:
1. **Structure Assessment** - Is the ${levels.phase.toLowerCase()}/${levels.item.toLowerCase()} breakdown logical and well-organized?
2. **Logical Flow** - Comment on progression and dependencies between elements
3. **Development Recommendations** - Suggestions for strengthening the structure
4. **Potential Issues** - Any structural concerns or gaps in coverage
5. **Next Steps** - Actionable recommendations for the author/creator

Focus on logical structure and content organization best practices.`;
                }
            }

            return await callClaudeAPI(userPrompt, systemPrompt);
        }

        // Helper to get all items from tree
        function getAllProjectItems(node = capexTree, items = []) {
            if (node.items) items.push(...node.items);
            if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
            return items;
        }

        // =============================================================================
        // END AI INTEGRATION
        // =============================================================================

        // Data - "Explore TreeListy" starter tree - self-describing and beautiful in both views
        let capexTree = {
            id: 'root',
            name: 'âœ¨ Explore TreeListy',
            type: 'root',
            icon: 'ðŸŒ³',
            expanded: true,
            description: 'Welcome! This tree teaches you TreeListy by example. Try both Tree View and Canvas View - they show the same content!',
            hyperedges: [],
            pattern: { key: 'generic' },
            children: [
                {
                    id: 'phase-discover',
                    name: 'ðŸ” Discover',
                    subtitle: 'Learn the basics',
                    description: 'Start here to understand how TreeListy organizes information',
                    type: 'phase',
                    icon: 'ðŸ”',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 100,
                    canvasY: 200,
                    items: [
                        {
                            id: 'item-views',
                            name: 'ðŸ‘ï¸ Two Views, One Tree',
                            description: 'Toggle between Tree View (structured list) and Canvas View (visual map) using the buttons in the header. Both show the same data!',
                            type: 'item',
                            icon: 'ðŸ‘ï¸',
                            expanded: true,
                            canvasX: 300,
                            canvasY: 100,
                            pmStatus: 'To Do',
                            subItems: [
                                {
                                    id: 'sub-tree-view',
                                    name: 'ðŸ“‹ Tree View: Organized list with expand/collapse',
                                    description: 'Click arrows to expand/collapse. Great for detailed editing.',
                                    type: 'subtask',
                                    icon: 'ðŸ“‹',
                                    pmStatus: 'To Do',
                                    canvasX: 550,
                                    canvasY: 50,
                                    subItems: []
                                },
                                {
                                    id: 'sub-canvas-view',
                                    name: 'ðŸŽ¨ Canvas View: Visual map with drag & drop',
                                    description: 'Drag nodes to arrange. Scroll to zoom. See connections visually.',
                                    type: 'subtask',
                                    icon: 'ðŸŽ¨',
                                    pmStatus: 'To Do',
                                    canvasX: 550,
                                    canvasY: 150,
                                    subItems: []
                                }
                            ]
                        },
                        {
                            id: 'item-hierarchy',
                            name: 'ðŸ“‚ Infinite Hierarchy',
                            description: 'Phases contain Items, Items contain Subtasks, Subtasks can nest infinitely deep. Right-click to add children anywhere!',
                            type: 'item',
                            icon: 'ðŸ“‚',
                            expanded: true,
                            canvasX: 300,
                            canvasY: 280,
                            pmStatus: 'Done',
                            pmProgress: 100,
                            subItems: []
                        }
                    ]
                },
                {
                    id: 'phase-create',
                    name: 'ðŸ› ï¸ Create',
                    subtitle: 'Build your ideas',
                    description: 'Multiple ways to add content - manual or AI-powered',
                    type: 'phase',
                    icon: 'ðŸ› ï¸',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 100,
                    canvasY: 450,
                    items: [
                        {
                            id: 'item-manual',
                            name: 'âœï¸ Manual Editing',
                            description: 'Right-click any node for options: Add, Edit, Delete, Duplicate. Or use the + buttons.',
                            type: 'item',
                            icon: 'âœï¸',
                            expanded: true,
                            canvasX: 300,
                            canvasY: 400,
                            pmStatus: 'To Do',
                            subItems: []
                        },
                        {
                            id: 'item-ai-wizard',
                            name: 'ðŸ¤– AI Chat Builder',
                            description: 'Click "Chat Builder" in sidebar. Describe your project in plain English - AI builds the tree structure for you!',
                            type: 'item',
                            icon: 'ðŸ¤–',
                            expanded: true,
                            canvasX: 300,
                            canvasY: 500,
                            pmStatus: 'To Do',
                            subItems: []
                        },
                        {
                            id: 'item-import',
                            name: 'ðŸ“¥ Import Text',
                            description: 'Click "Import Text" in sidebar. Paste any document, notes, or outline - AI extracts structure automatically!',
                            type: 'item',
                            icon: 'ðŸ“¥',
                            expanded: true,
                            canvasX: 300,
                            canvasY: 600,
                            pmStatus: 'To Do',
                            subItems: []
                        }
                    ]
                },
                {
                    id: 'phase-enhance',
                    name: 'âœ¨ Enhance',
                    subtitle: 'AI superpowers',
                    description: 'Let AI help you think deeper and fill in details',
                    type: 'phase',
                    icon: 'âœ¨',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 700,
                    canvasY: 200,
                    items: [
                        {
                            id: 'item-smart-suggest',
                            name: 'ðŸ’¡ Smart Suggest',
                            description: 'Right-click any field â†’ "AI Suggest" â†’ AI improves your text with domain expertise!',
                            type: 'item',
                            icon: 'ðŸ’¡',
                            expanded: true,
                            canvasX: 900,
                            canvasY: 150,
                            pmStatus: 'To Do',
                            subItems: []
                        },
                        {
                            id: 'item-smart-expand',
                            name: 'ðŸŒ± Smart Expand',
                            description: 'Click "Smart Expand" in sidebar - AI adds subtasks, fills descriptions, and enriches your tree!',
                            type: 'item',
                            icon: 'ðŸŒ±',
                            expanded: true,
                            canvasX: 900,
                            canvasY: 250,
                            pmStatus: 'To Do',
                            subItems: []
                        },
                        {
                            id: 'item-quality-check',
                            name: 'ðŸ©º Quality Check',
                            description: 'Click "Check Quality" - AI reviews your tree for gaps, inconsistencies, and missing dependencies!',
                            type: 'item',
                            icon: 'ðŸ©º',
                            expanded: true,
                            canvasX: 900,
                            canvasY: 350,
                            pmStatus: 'To Do',
                            subItems: []
                        }
                    ]
                },
                {
                    id: 'phase-share',
                    name: 'ðŸš€ Share',
                    subtitle: 'Collaborate & export',
                    description: 'Share your work with others or export for use elsewhere',
                    type: 'phase',
                    icon: 'ðŸš€',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 700,
                    canvasY: 500,
                    items: [
                        {
                            id: 'item-share-url',
                            name: 'ðŸ”— Share via URL',
                            description: 'Click "Share" button â†’ Copy link â†’ Anyone can open your exact tree instantly, no account needed!',
                            type: 'item',
                            icon: 'ðŸ”—',
                            expanded: true,
                            canvasX: 900,
                            canvasY: 450,
                            pmStatus: 'To Do',
                            subItems: []
                        },
                        {
                            id: 'item-collaborate',
                            name: 'ðŸ¤ Collaborate',
                            description: 'Right-click a node â†’ "Share for collaboration" â†’ Send branch to teammate â†’ They edit â†’ You merge changes back!',
                            type: 'item',
                            icon: 'ðŸ¤',
                            expanded: true,
                            canvasX: 900,
                            canvasY: 550,
                            pmStatus: 'To Do',
                            subItems: []
                        },
                        {
                            id: 'item-save-json',
                            name: 'ðŸ’¾ Save & Load',
                            description: 'File menu: Save as JSON to keep your work. Load it anytime. Also auto-saves to browser storage!',
                            type: 'item',
                            icon: 'ðŸ’¾',
                            expanded: true,
                            canvasX: 900,
                            canvasY: 650,
                            pmStatus: 'To Do',
                            subItems: []
                        }
                    ]
                }
            ]
        };

        // =====================================================================
        // CANVAS VIEW INTEGRATION
        // =====================================================================

        let viewMode = 'tree';
        let canvasNodes = [];
        let canvasPan = { x: 0, y: 0 };
        let canvasZoom = 1;
        let isPanningCanvas = false;
        let isDraggingCanvasNode = false;
        let draggedCanvasNode = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let panStartX = 0;
        let panStartY = 0;
        let maxExpandedDepth = Infinity;  // Track how deep we're currently showing
        let gridEnabled = false;
        const gridSize = 40;  // Grid snap size
        let clusterByField = '';  // Track which metadata field to cluster by (itemType, owner, etc.)

        // Multi-selection state
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionEnd = { x: 0, y: 0 };
        let selectedNodes = [];
        let isDraggingSelection = false;
        let selectionDragStart = { x: 0, y: 0 };

        /**
         * Get hyperedge membership for a node ID
         * Returns the hyperedge object if node is a member, null otherwise
         */
        function getNodeHyperedge(nodeId) {
            const hyperedges = capexTree.hyperedges || [];
            for (const he of hyperedges) {
                if (he.nodeIds && he.nodeIds.includes(nodeId)) {
                    return he;
                }
            }
            return null;
        }

        /**
         * Generate a unique color for a Deep Dive hyperedge based on index
         * Uses a palette of visually distinct, pleasant colors
         */
        const HYPEREDGE_COLOR_PALETTE = [
            { h: 270, s: 70, l: 60 },  // Purple (default analysis)
            { h: 200, s: 80, l: 55 },  // Blue
            { h: 160, s: 70, l: 45 },  // Teal
            { h: 340, s: 75, l: 60 },  // Pink
            { h: 30, s: 85, l: 55 },   // Orange
            { h: 280, s: 65, l: 65 },  // Violet
            { h: 180, s: 60, l: 45 },  // Cyan
            { h: 0, s: 70, l: 60 },    // Red
            { h: 45, s: 80, l: 50 },   // Gold
            { h: 220, s: 75, l: 60 },  // Royal Blue
            { h: 300, s: 60, l: 55 },  // Magenta
            { h: 140, s: 65, l: 45 },  // Green
        ];

        function generateHyperedgeColor(index) {
            const palette = HYPEREDGE_COLOR_PALETTE;
            const color = palette[index % palette.length];
            const { h, s, l } = color;

            return {
                fill: `hsla(${h}, ${s}%, ${l}%, 0.25)`,
                border: `hsla(${h}, ${s}%, ${l}%, 0.8)`,
                glow: `hsla(${h}, ${s}%, ${l}%, 0.5)`,
                solid: `hsl(${h}, ${s}%, ${l}%)`,
                hsl: { h, s, l }
            };
        }

        /**
         * Get hyperedge color - uses custom color if set, else type-based or generated
         */
        function getHyperedgeColor(hyperedge) {
            // If hyperedge has a custom color, use it
            if (hyperedge?.metadata?.color) {
                const c = hyperedge.metadata.color;
                return {
                    fill: c.fill || c,
                    border: c.border || c,
                    glow: c.glow || c,
                    solid: c.solid || c.border || c
                };
            }

            const typeColors = {
                'montage': { fill: 'rgba(251, 146, 60, 0.25)', border: 'rgba(251, 146, 60, 0.8)', glow: 'rgba(251, 146, 60, 0.4)' },
                'argument': { fill: 'rgba(59, 130, 246, 0.25)', border: 'rgba(59, 130, 246, 0.8)', glow: 'rgba(59, 130, 246, 0.4)' },
                'theme': { fill: 'rgba(168, 85, 247, 0.25)', border: 'rgba(168, 85, 247, 0.8)', glow: 'rgba(168, 85, 247, 0.4)' },
                'dependency-cluster': { fill: 'rgba(34, 197, 94, 0.25)', border: 'rgba(34, 197, 94, 0.8)', glow: 'rgba(34, 197, 94, 0.4)' },
                'analysis': { fill: 'rgba(139, 92, 246, 0.25)', border: 'rgba(139, 92, 246, 0.8)', glow: 'rgba(139, 92, 246, 0.5)' },
                'default': { fill: 'rgba(156, 163, 175, 0.25)', border: 'rgba(156, 163, 175, 0.8)', glow: 'rgba(156, 163, 175, 0.4)' }
            };
            return typeColors[hyperedge?.type] || typeColors.default;
        }

        // Track which hyperedge is being focused (null = show all)
        let focusedHyperedgeId = null;

        /**
         * Focus canvas view on a specific hyperedge
         * - Hides all nodes not in the hyperedge
         * - Auto-arranges member nodes in a clean layout
         * - Centers the view on the hyperedge
         */
        function focusOnHyperedge(hyperedgeId) {
            const hyperedge = (capexTree.hyperedges || []).find(h => h.id === hyperedgeId);
            if (!hyperedge) {
                console.warn('Hyperedge not found:', hyperedgeId);
                return;
            }

            console.log('ðŸŽ¯ Focusing on hyperedge:', hyperedge.label);
            focusedHyperedgeId = hyperedgeId;

            // Get all nodes that belong to this hyperedge
            const memberIds = new Set(hyperedge.nodeIds || []);

            // Find actual node objects and arrange them
            const memberNodes = [];
            function findNodes(node) {
                if (memberIds.has(node.id)) {
                    memberNodes.push(node);
                }
                // Check subitems
                if (node.subItems) {
                    node.subItems.forEach(sub => findNodes(sub));
                }
                if (node.children) {
                    node.children.forEach(child => findNodes(child));
                }
            }

            // Search through all phases
            capexTree.children.forEach(phase => {
                const nodeList = phase.items || phase.children || [];
                nodeList.forEach(item => findNodes(item));
            });

            console.log(`ðŸŽ¯ Found ${memberNodes.length} member nodes`);

            // Separate parent nodes from subitems
            const parentNodes = memberNodes.filter(n => !n.id.startsWith('subitem-'));
            const subitemNodes = memberNodes.filter(n => n.id.startsWith('subitem-'));

            // Calculate layout dimensions
            const canvasContainer = document.getElementById('canvas-container');
            const containerWidth = canvasContainer?.offsetWidth || 1200;
            const containerHeight = canvasContainer?.offsetHeight || 800;

            // Layout parameters
            const nodeWidth = 320;
            const nodeHeight = 150;
            const padding = 80;
            const centerX = containerWidth / 2;
            const centerY = containerHeight / 2;

            // Arrange parent nodes in a row at the top
            const parentStartX = centerX - ((parentNodes.length * (nodeWidth + padding)) / 2) + padding / 2;
            parentNodes.forEach((node, idx) => {
                node.canvasX = parentStartX + idx * (nodeWidth + padding);
                node.canvasY = 100;
                node.expanded = true; // Ensure expanded to show subitems
            });

            // Arrange subitems below their parents or in a grid
            if (subitemNodes.length > 0) {
                // Try to position subitems below their parent
                subitemNodes.forEach((subitem, idx) => {
                    // Find parent by checking which parent's subItems contains this subitem
                    let parentNode = null;
                    for (const parent of parentNodes) {
                        if (parent.subItems && parent.subItems.some(s => s.id === subitem.id)) {
                            parentNode = parent;
                            break;
                        }
                    }

                    if (parentNode) {
                        // Position below parent
                        const siblingIdx = parentNode.subItems.findIndex(s => s.id === subitem.id);
                        subitem.canvasX = parentNode.canvasX + 50 + (siblingIdx % 2) * 180;
                        subitem.canvasY = parentNode.canvasY + nodeHeight + 60 + Math.floor(siblingIdx / 2) * (nodeHeight + 40);
                    } else {
                        // No parent found, arrange in grid below
                        const cols = Math.ceil(Math.sqrt(subitemNodes.length));
                        const row = Math.floor(idx / cols);
                        const col = idx % cols;
                        subitem.canvasX = centerX - (cols * (nodeWidth + padding) / 2) + col * (nodeWidth + padding);
                        subitem.canvasY = 350 + row * (nodeHeight + 60);
                    }
                });
            }

            // Re-render canvas with focus filter active
            renderCanvasWithFocus(memberIds);

            // Center the view
            canvasPan = { x: 50, y: 50 };
            canvasZoom = 0.9;
            updateCanvasTransform();

            // Show "exit focus" button
            showFocusModeIndicator(hyperedge);
        }

        /**
         * Exit focus mode and show all nodes
         */
        function exitFocusMode() {
            console.log('ðŸŽ¯ Exiting focus mode');
            focusedHyperedgeId = null;
            hideFocusModeIndicator();
            renderCanvas();
        }

        /**
         * Render canvas showing only focused nodes (or all if no focus)
         */
        function renderCanvasWithFocus(memberIds) {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('canvas-connections');

            if (!canvas || !svg) {
                console.error('Canvas elements not found');
                return;
            }

            // Clear existing content
            canvas.querySelectorAll('.canvas-node').forEach(n => n.remove());
            svg.innerHTML = '';
            canvasNodes = [];

            // Render only member nodes
            capexTree.children.forEach((phase, phaseIdx) => {
                if (phase.showInCanvas === false) return;

                const nodeList = phase.items || phase.children || [];
                nodeList.forEach((item) => {
                    renderFocusedNodeAndDescendants(item, phase, null, 0, memberIds);
                });
            });

            // Draw connections and hyperedges
            drawConnections();
            updateCanvasTransform();
        }

        /**
         * Recursively render nodes, but only if they're in the focus set
         */
        function renderFocusedNodeAndDescendants(node, phase, parentNode, nestingLevel, memberIds) {
            // Only render if this node is in the focus set
            if (!memberIds.has(node.id)) {
                // But still check children in case they're members
                const childList = node.subItems || node.children || [];
                childList.forEach(child => {
                    renderFocusedNodeAndDescendants(child, phase, node, nestingLevel + 1, memberIds);
                });
                return;
            }

            // Check if parent is collapsed
            if (parentNode && parentNode.expanded === false) {
                return;
            }

            // Render this node
            renderCanvasNode(node, phase, parentNode, nestingLevel);

            // Recursively render children that are also members
            const childList = node.subItems || node.children || [];
            if (childList.length > 0 && node.expanded !== false) {
                childList.forEach((child, childIdx) => {
                    renderFocusedNodeAndDescendants(child, phase, node, nestingLevel + 1, memberIds);
                });
            }
        }

        /**
         * Show focus mode indicator with exit button
         */
        function showFocusModeIndicator(hyperedge) {
            // Remove existing indicator
            hideFocusModeIndicator();

            const indicator = document.createElement('div');
            indicator.id = 'focus-mode-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(139, 92, 246, 0.95);
                color: white;
                padding: 12px 24px;
                border-radius: 30px;
                display: flex;
                align-items: center;
                gap: 16px;
                z-index: 1000;
                box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);
                font-size: 14px;
            `;
            indicator.innerHTML = `
                <span>ðŸŽ¯ Focused: <strong>${hyperedge.label}</strong></span>
                <button onclick="exitFocusMode()" style="
                    background: rgba(255,255,255,0.2);
                    border: 1px solid rgba(255,255,255,0.3);
                    color: white;
                    padding: 6px 12px;
                    border-radius: 15px;
                    cursor: pointer;
                    font-size: 12px;
                ">âœ• Show All</button>
            `;

            document.body.appendChild(indicator);
        }

        /**
         * Hide focus mode indicator
         */
        function hideFocusModeIndicator() {
            const indicator = document.getElementById('focus-mode-indicator');
            if (indicator) {
                indicator.remove();
            }
        }

        // Track which hyperedges are hidden
        let hiddenHyperedges = new Set();

        /**
         * Toggle hyperedge visibility panel
         */
        function toggleHyperedgePanel() {
            const existing = document.getElementById('hyperedge-visibility-panel');
            if (existing) {
                existing.remove();
                return;
            }

            const hyperedges = capexTree.hyperedges || [];
            if (hyperedges.length === 0) {
                showToast('No hyperedges to manage', 'info');
                return;
            }

            // Check if info panel is open to adjust position
            const infoPanel = document.getElementById('info-panel');
            const infoPanelOpen = infoPanel && infoPanel.classList.contains('open');
            const rightOffset = infoPanelOpen ? 470 : 20; // 450px panel + 20px margin

            const panel = document.createElement('div');
            panel.id = 'hyperedge-visibility-panel';
            panel.style.cssText = `
                position: fixed;
                top: 120px;
                right: ${rightOffset}px;
                width: 280px;
                max-height: 400px;
                background: var(--surface-elevated);
                border: 1px solid var(--border-color);
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                z-index: 999;
                overflow: hidden;
                transition: right 0.3s;
            `;

            const header = document.createElement('div');
            header.style.cssText = `
                padding: 16px;
                border-bottom: 1px solid var(--border-color);
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;
            header.innerHTML = `
                <span style="font-weight: 600; color: var(--text-primary);">ðŸ”— Hyperedges (${hyperedges.length})</span>
                <button onclick="document.getElementById('hyperedge-visibility-panel').remove()"
                    style="background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 18px;">âœ•</button>
            `;

            const list = document.createElement('div');
            list.style.cssText = `
                max-height: 320px;
                overflow-y: auto;
                padding: 8px;
            `;

            hyperedges.forEach(he => {
                const colorObj = getHyperedgeColor(he);
                const isHidden = hiddenHyperedges.has(he.id);

                const item = document.createElement('div');
                item.style.cssText = `
                    padding: 10px 12px;
                    margin-bottom: 6px;
                    background: ${isHidden ? 'rgba(0,0,0,0.2)' : 'rgba(139, 92, 246, 0.1)'};
                    border: 1px solid ${isHidden ? 'var(--border-color)' : colorObj.border};
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    transition: all 0.2s;
                    opacity: ${isHidden ? '0.5' : '1'};
                `;
                item.innerHTML = `
                    <input type="checkbox" ${isHidden ? '' : 'checked'}
                        onchange="toggleHyperedgeVisibility('${he.id}')"
                        style="width: 18px; height: 18px; cursor: pointer; accent-color: ${colorObj.solid || '#8B5CF6'};">
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-size: 13px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${he.label}
                        </div>
                        <div style="font-size: 11px; color: var(--text-secondary);">
                            ${he.nodeIds?.length || 0} nodes
                        </div>
                    </div>
                    <button onclick="event.stopPropagation(); focusOnHyperedge('${he.id}'); document.getElementById('hyperedge-visibility-panel').remove();"
                        style="background: rgba(139, 92, 246, 0.2); border: none; padding: 4px 8px; border-radius: 4px; color: #8B5CF6; cursor: pointer; font-size: 11px;">
                        ðŸŽ¯
                    </button>
                `;
                list.appendChild(item);
            });

            const footer = document.createElement('div');
            footer.style.cssText = `
                padding: 12px 16px;
                border-top: 1px solid var(--border-color);
                display: flex;
                gap: 8px;
            `;
            footer.innerHTML = `
                <button onclick="showAllHyperedges()"
                    style="flex: 1; padding: 8px; background: rgba(34, 197, 94, 0.2); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 6px; color: #22C55E; cursor: pointer; font-size: 12px;">
                    Show All
                </button>
                <button onclick="hideAllHyperedges()"
                    style="flex: 1; padding: 8px; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 6px; color: #EF4444; cursor: pointer; font-size: 12px;">
                    Hide All
                </button>
            `;

            panel.appendChild(header);
            panel.appendChild(list);
            panel.appendChild(footer);
            document.body.appendChild(panel);
        }

        /**
         * Toggle visibility of a specific hyperedge
         */
        function toggleHyperedgeVisibility(hyperedgeId) {
            if (hiddenHyperedges.has(hyperedgeId)) {
                hiddenHyperedges.delete(hyperedgeId);
            } else {
                hiddenHyperedges.add(hyperedgeId);
            }
            renderCanvas();
            // Refresh the panel
            const panel = document.getElementById('hyperedge-visibility-panel');
            if (panel) {
                panel.remove();
                toggleHyperedgePanel();
            }
        }

        /**
         * Show all hyperedges
         */
        function showAllHyperedges() {
            hiddenHyperedges.clear();
            renderCanvas();
            const panel = document.getElementById('hyperedge-visibility-panel');
            if (panel) {
                panel.remove();
                toggleHyperedgePanel();
            }
        }

        /**
         * Hide all hyperedges
         */
        function hideAllHyperedges() {
            (capexTree.hyperedges || []).forEach(he => {
                hiddenHyperedges.add(he.id);
            });
            renderCanvas();
            const panel = document.getElementById('hyperedge-visibility-panel');
            if (panel) {
                panel.remove();
                toggleHyperedgePanel();
            }
        }

        function toggleViewMode() {
            viewMode = viewMode === 'tree' ? 'canvas' : 'tree';

            if (viewMode === 'canvas') {
                console.log('ðŸŽ¨ Switching to Canvas View');
                document.getElementById('view-mode-icon').textContent = 'ðŸ“Š';
                document.getElementById('view-mode-text').textContent = 'Tree View';
                document.querySelector('.tree-view-container').classList.add('hidden');
                document.getElementById('canvas-container').classList.add('active');

                const toolbar = document.getElementById('canvas-toolbar');
                if (toolbar) {
                    toolbar.classList.add('active');
                    console.log('âœ… Canvas toolbar activated');
                } else {
                    console.error('âŒ Canvas toolbar not found!');
                }

                // Migrate coordinates if needed
                const firstPhase = capexTree.children[0];
                const firstItem = firstPhase?.items?.[0] || firstPhase?.children?.[0];
                if (!firstItem?.canvasX) {
                    migrateToCanvasCoordinates();
                } else {
                    // Even if coordinates exist, ensure expanded state is initialized
                    capexTree.children.forEach(phase => {
                        const nodeList = phase.items || phase.children || [];
                        nodeList.forEach(item => {
                            initializeExpandedState(item);
                        });
                    });
                }

                // Initialize arrow markers first time
                initializeArrowMarkers();

                renderCanvas();
                updateZoomDisplay();
                console.log('âœ… Canvas View ready');
            } else {
                console.log('ðŸ“Š Switching to Tree View');
                document.getElementById('view-mode-icon').textContent = 'ðŸŽ¨';
                document.getElementById('view-mode-text').textContent = 'Canvas View';
                document.querySelector('.tree-view-container').classList.remove('hidden');
                document.getElementById('canvas-container').classList.remove('active');

                const toolbar = document.getElementById('canvas-toolbar');
                if (toolbar) {
                    toolbar.classList.remove('active');
                }

                render();
                console.log('âœ… Tree View ready');
            }
        }

        function migrateToCanvasCoordinates() {
            let xOffset = 200;
            const ySpacing = 180;

            capexTree.children.forEach((phase, phaseIdx) => {
                let yOffset = 100;
                // Support both 'items' (standard) and 'children' (filesystem pattern)
                const nodeList = phase.items || phase.children || [];
                nodeList.forEach((item) => {
                    item.canvasX = xOffset + 50;
                    item.canvasY = yOffset;
                    yOffset += ySpacing;

                    // Ensure all items with subItems have expanded state initialized
                    initializeExpandedState(item);
                });
                xOffset += 400;
            });
        }

        // Clear all canvas coordinates recursively to force re-positioning
        function clearCanvasCoordinates(node) {
            delete node.canvasX;
            delete node.canvasY;

            // Recursively clear for all child types
            const childList = node.items || node.children || node.subItems || [];
            childList.forEach(child => clearCanvasCoordinates(child));
        }

        // Recursively initialize expanded state for all items with children
        function initializeExpandedState(item) {
            // Support both 'subItems' (standard) and 'children' (filesystem pattern)
            const childList = item.subItems || item.children || [];
            if (childList.length > 0) {
                // Default to expanded if not explicitly set
                if (item.expanded === undefined) {
                    item.expanded = true;
                    console.log('Initializing expanded=true for:', item.name);
                }

                // Recursively initialize for all descendants
                childList.forEach(child => {
                    initializeExpandedState(child);
                });
            }
        }

        function renderCanvas() {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('canvas-connections');

            // Clear existing content
            canvas.querySelectorAll('.canvas-node').forEach(n => n.remove());
            svg.innerHTML = '';
            canvasNodes = [];

            // Render all nodes recursively
            capexTree.children.forEach((phase, phaseIdx) => {
                // Check if phase is visible in Canvas View (default: true)
                if (phase.showInCanvas === false) {
                    console.log(`Skipping phase "${phase.name}" - hidden in Canvas View`);
                    return; // Skip this phase
                }

                // Support both 'items' (standard) and 'children' (filesystem pattern)
                const nodeList = phase.items || phase.children || [];
                nodeList.forEach((item, itemIdx) => {
                    // Preserve existing positions for root items to prevent jumping
                    // Only set initial position if not already set
                    if (!item.canvasX || !item.canvasY) {
                        item.canvasX = item.canvasX || 50;
                        item.canvasY = item.canvasY || (50 + itemIdx * 180);
                    }
                    renderNodeAndDescendants(item, phase, null, 0);
                });
            });

            // Draw connection lines after all nodes are positioned
            drawConnections();
            updateCanvasTransform();
        }

        // Recursive function to render a node and all its descendants
        function renderNodeAndDescendants(node, phase, parentNode, nestingLevel) {
            // Check if parent is collapsed - if so, don't render this node
            if (parentNode && parentNode.expanded === false) {
                return;  // Parent is collapsed, skip this node
            }

            // Render this node with hierarchical depth
            renderCanvasNode(node, phase, parentNode, nestingLevel);

            // Recursively render all descendants only if this node is expanded (or has no explicit state)
            // Support both 'subItems' (standard) and 'children' (filesystem pattern)
            const childList = node.subItems || node.children || [];
            if (childList.length > 0) {
                // Default to expanded if not set
                if (node.expanded === undefined) {
                    node.expanded = true;
                }

                childList.forEach((child, childIdx) => {
                    // Auto-position children based on nesting level
                    if (!child.canvasX) {
                        // Each nesting level moves further right
                        child.canvasX = (node.canvasX || 0) + 350;
                        child.canvasY = (node.canvasY || 0) + (childIdx * 120);
                    }

                    // Recursively render this child and its descendants
                    renderNodeAndDescendants(child, phase, node, nestingLevel + 1);
                });
            }
        }

        // =============================================================================
        // CONVEX HULL COMPUTATION (Graham Scan Algorithm)
        // =============================================================================

        /**
         * Compute convex hull using Graham scan algorithm
         * @param {Array} points - Array of {x, y} points
         * @returns {Array} Points forming the convex hull in counter-clockwise order
         */
        function computeConvexHull(points) {
            if (points.length < 3) return points;

            // Sort points by y-coordinate (bottom to top), then x-coordinate (left to right)
            const sorted = [...points].sort((a, b) => {
                if (a.y !== b.y) return a.y - b.y;
                return a.x - b.x;
            });

            // Helper: Compute cross product of vectors OA and OB
            const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

            // Build lower hull
            const lower = [];
            for (const p of sorted) {
                while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                    lower.pop();
                }
                lower.push(p);
            }

            // Build upper hull
            const upper = [];
            for (let i = sorted.length - 1; i >= 0; i--) {
                const p = sorted[i];
                while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                    upper.pop();
                }
                upper.push(p);
            }

            // Remove last point of each half because it's repeated
            lower.pop();
            upper.pop();

            return lower.concat(upper);
        }

        /**
         * Create a capsule/pill SVG path connecting two points
         * Used for 2-node hyperedges where convex hull fails
         */
        function createCapsulePath(p1, p2, radius) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.hypot(dx, dy);

            // If points overlap, create a circle
            if (dist < 1) {
                return `M ${p1.x - radius} ${p1.y}
                        a ${radius} ${radius} 0 1 0 ${radius * 2} 0
                        a ${radius} ${radius} 0 1 0 ${-radius * 2} 0 Z`;
            }

            // Normalize direction vector
            const nx = dx / dist;
            const ny = dy / dist;

            // Perpendicular vector scaled by radius
            const px = -ny * radius;
            const py = nx * radius;

            // Four corners of the capsule body
            const c1 = { x: p1.x + px, y: p1.y + py };
            const c2 = { x: p1.x - px, y: p1.y - py };
            const c3 = { x: p2.x - px, y: p2.y - py };
            const c4 = { x: p2.x + px, y: p2.y + py };

            // SVG path: straight sides + semicircle end caps
            return `M ${c1.x} ${c1.y}
                    L ${c4.x} ${c4.y}
                    A ${radius} ${radius} 0 0 1 ${c3.x} ${c3.y}
                    L ${c2.x} ${c2.y}
                    A ${radius} ${radius} 0 0 1 ${c1.x} ${c1.y} Z`;
        }

        // =============================================================================
        // HYPEREDGE VISUALIZATION
        // =============================================================================

        // SVG offset to match the large canvas-connections area (top: -5000px, left: -5000px)
        const SVG_OFFSET = 5000;

        /**
         * Draw all hyperedges as convex hull blobs
         * Performance optimized: Uses O(1) Map lookup instead of O(N) recursive getNodeById
         * Enhanced: Groups each hyperedge for hover/focus interactions
         */
        function drawHyperedges() {
            const svg = document.getElementById('canvas-connections');
            const allHyperedges = getAllHyperedges();

            // Filter out hidden hyperedges
            const hyperedges = (allHyperedges || []).filter(he => !hiddenHyperedges.has(he.id));

            console.log('ðŸ”— drawHyperedges called, found', allHyperedges?.length || 0, 'hyperedges,', hyperedges.length, 'visible');
            console.log('ðŸ”— canvasNodes array has', canvasNodes.length, 'entries');

            if (!hyperedges || hyperedges.length === 0) {
                console.log('ðŸ”— No visible hyperedges to draw');
                return;
            }

            // Track all hyperedge groups for hover interactions
            const hyperedgeGroups = [];

            // Build O(1) lookup map from canvasNodes to avoid O(N) getNodeById calls per node
            // This reduces complexity from O(H * N * TreeDepth) to O(H * N) where H = hyperedges, N = nodes per edge
            const nodeLookup = new Map();
            canvasNodes.forEach(n => {
                if (n.data && n.data.id) {
                    nodeLookup.set(n.data.id, n.data);
                }
            });
            console.log('ðŸ”— nodeLookup built with', nodeLookup.size, 'nodes. Keys:', Array.from(nodeLookup.keys()).slice(0, 15));

            // Color palette for hyperedge types
            const typeColors = {
                'montage': 'rgba(251, 146, 60, 0.15)',       // Orange
                'argument': 'rgba(59, 130, 246, 0.15)',      // Blue
                'theme': 'rgba(168, 85, 247, 0.15)',         // Purple
                'dependency-cluster': 'rgba(34, 197, 94, 0.15)', // Green
                'analysis': 'rgba(139, 92, 246, 0.25)',      // Violet/Purple for Deep Dive (slightly more opaque)
                'default': 'rgba(156, 163, 175, 0.15)'       // Gray
            };

            hyperedges.forEach((hyperedge, idx) => {
                console.log(`ðŸ”— Processing hyperedge[${idx}]: "${hyperedge.label}" with nodeIds:`, hyperedge.nodeIds);

                // Get all nodes in this hyperedge using O(1) lookup
                const nodes = hyperedge.nodeIds.map(id => {
                    const found = nodeLookup.get(id);
                    if (!found) {
                        console.warn(`  âŒ Node ID "${id}" NOT found in canvasNodes`);
                    } else {
                        console.log(`  âœ… Node ID "${id}" found at (${found.canvasX}, ${found.canvasY})`);
                    }
                    return found;
                }).filter(n => n);

                console.log(`ðŸ”— Hyperedge "${hyperedge.label}": ${hyperedge.nodeIds.length} nodeIds â†’ ${nodes.length} found in canvasNodes`);

                if (nodes.length < 2) {
                    console.warn(`âŒ Hyperedge ${hyperedge.id} has < 2 valid nodes, skipping. NodeIds:`, hyperedge.nodeIds);
                    return;
                }

                // Create SVG group for this hyperedge (enables hover/focus interactions)
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'hyperedge-group');
                group.setAttribute('data-hyperedge-id', hyperedge.id);
                group.style.transition = 'opacity 0.3s ease';
                hyperedgeGroups.push({ group, hyperedge });

                // Get node positions (center of each node card) + SVG offset
                const points = nodes.map(node => ({
                    x: (node.canvasX || 0) + 160 + SVG_OFFSET,  // Center X (320px width / 2) + offset
                    y: (node.canvasY || 0) + 60 + SVG_OFFSET   // Center Y (120px height / 2) + offset
                }));
                console.log('ðŸ”— Raw points (with SVG_OFFSET):', points);

                // =====================================================================
                // SPECIAL CASE: 2-node hyperedges use capsule/pill shape
                // Convex hull fails for 2 points (collinear), so we draw a capsule
                // =====================================================================
                if (nodes.length === 2) {
                    const p1 = points[0];
                    const p2 = points[1];
                    const capsuleRadius = 80;  // Generous radius for visibility

                    const colorObj = getHyperedgeColor(hyperedge);
                    const capsulePath = createCapsulePath(p1, p2, capsuleRadius);

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('class', 'hyperedge-capsule');
                    path.setAttribute('d', capsulePath);
                    path.setAttribute('fill', colorObj.fill);
                    path.setAttribute('stroke', colorObj.border);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('stroke-dasharray', '8,4');
                    path.style.cursor = 'pointer';
                    path.style.transition = 'opacity 0.2s';
                    path.addEventListener('mouseenter', () => path.style.opacity = '0.8');
                    path.addEventListener('mouseleave', () => path.style.opacity = '1');
                    path.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });

                    group.appendChild(path);
                    console.log('ðŸ”— Capsule path created for 2-node hyperedge');

                    // Add label at midpoint
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;

                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', midX);
                    label.setAttribute('y', midY - 35);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', colorObj.solid || colorObj.border);
                    label.setAttribute('font-size', '14');
                    label.setAttribute('font-weight', 'bold');
                    label.style.cursor = 'pointer';
                    label.style.textShadow = '0 0 6px rgba(0,0,0,0.8)';
                    label.textContent = hyperedge.label;
                    label.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });
                    group.appendChild(label);

                    const hint = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    hint.setAttribute('x', midX);
                    hint.setAttribute('y', midY - 18);
                    hint.setAttribute('text-anchor', 'middle');
                    hint.setAttribute('fill', 'rgba(255,255,255,0.6)');
                    hint.setAttribute('font-size', '11');
                    hint.style.cursor = 'pointer';
                    hint.style.textShadow = '0 0 4px rgba(0,0,0,0.8)';
                    hint.textContent = 'â–¶ click to explore relationship';
                    hint.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });
                    group.appendChild(hint);

                    // Append group to SVG and return (skip hull processing)
                    svg.appendChild(group);
                    return;
                }

                // Add padding around the hull with SAFE division (avoid NaN from div-by-zero)
                const padding = 60;  // Increased for better visibility
                const centroid = {
                    x: points.reduce((sum, p) => sum + p.x, 0) / points.length,
                    y: points.reduce((sum, p) => sum + p.y, 0) / points.length
                };
                console.log('ðŸ”— Centroid:', centroid);

                // Safe padding: avoid division by zero when point equals centroid
                const paddedPoints = points.map(p => {
                    const dx = p.x - centroid.x;
                    const dy = p.y - centroid.y;
                    const dist = Math.hypot(dx, dy);

                    // If point is at centroid (dist=0), expand outward in a default direction
                    if (dist < 1) {
                        // Use point index to spread overlapping points
                        const angle = (points.indexOf(p) / points.length) * 2 * Math.PI;
                        return {
                            x: centroid.x + Math.cos(angle) * padding,
                            y: centroid.y + Math.sin(angle) * padding
                        };
                    }

                    return {
                        x: p.x + dx * (padding / dist),
                        y: p.y + dy * (padding / dist)
                    };
                });
                console.log('ðŸ”— Padded points:', paddedPoints);

                // Check for NaN values
                const hasNaN = paddedPoints.some(p => isNaN(p.x) || isNaN(p.y));
                if (hasNaN) {
                    console.error('âŒ NaN detected in padded points! Skipping hyperedge.');
                    return;
                }

                // Compute convex hull
                const hull = computeConvexHull(paddedPoints);
                console.log('ðŸ”— Convex hull computed with', hull.length, 'points');

                if (hull.length < 3) {
                    // Fallback: if hull fails (collinear points), create a simple rounded rect around the centroid
                    console.warn(`âš ï¸ Hyperedge ${hyperedge.id} hull has < 3 points, using fallback rectangle`);

                    // Calculate bounding box
                    const minX = Math.min(...paddedPoints.map(p => p.x)) - 20;
                    const maxX = Math.max(...paddedPoints.map(p => p.x)) + 20;
                    const minY = Math.min(...paddedPoints.map(p => p.y)) - 20;
                    const maxY = Math.max(...paddedPoints.map(p => p.y)) + 20;

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', minX);
                    rect.setAttribute('y', minY);
                    rect.setAttribute('width', maxX - minX);
                    rect.setAttribute('height', maxY - minY);
                    rect.setAttribute('rx', '20');
                    rect.setAttribute('ry', '20');

                    // Get color object (custom from metadata, or type-based fallback)
                    const colorObj = getHyperedgeColor(hyperedge);
                    rect.setAttribute('fill', colorObj.fill);
                    rect.setAttribute('stroke', colorObj.border);
                    rect.setAttribute('stroke-width', '2');
                    rect.setAttribute('stroke-dasharray', '8,4');
                    rect.style.cursor = 'pointer';
                    rect.style.transition = 'opacity 0.2s';
                    rect.addEventListener('mouseenter', () => rect.style.opacity = '0.8');
                    rect.addEventListener('mouseleave', () => rect.style.opacity = '1');
                    rect.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });

                    group.appendChild(rect);
                    console.log('ðŸ”— Fallback rect created');
                } else {
                    // Create SVG polygon for the hull
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const pointsStr = hull.map(p => `${p.x},${p.y}`).join(' ');
                    polygon.setAttribute('points', pointsStr);

                    // Get color object (custom from metadata, or type-based fallback)
                    const colorObj = getHyperedgeColor(hyperedge);
                    polygon.setAttribute('fill', colorObj.fill);
                    polygon.setAttribute('stroke', colorObj.border);
                    polygon.setAttribute('stroke-width', '2');
                    polygon.setAttribute('stroke-dasharray', '8,4');
                    polygon.style.cursor = 'pointer';
                    polygon.style.transition = 'opacity 0.2s';
                    polygon.addEventListener('mouseenter', () => polygon.style.opacity = '0.8');
                    polygon.addEventListener('mouseleave', () => polygon.style.opacity = '1');
                    polygon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });

                    group.appendChild(polygon);
                    console.log('ðŸ”— Polygon appended to group');
                }

                // Add label at centroid (also clickable)
                const labelColorObj = getHyperedgeColor(hyperedge);

                // Main label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', centroid.x);
                label.setAttribute('y', centroid.y - 35);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', labelColorObj.solid || labelColorObj.border);
                label.setAttribute('font-size', '14');
                label.setAttribute('font-weight', 'bold');
                label.style.cursor = 'pointer';
                label.style.textShadow = '0 0 6px rgba(0,0,0,0.8)';
                label.textContent = hyperedge.label;
                label.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showHyperedgeInfo(hyperedge);
                });
                group.appendChild(label);

                // Subtitle hint "click to explore"
                const hint = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                hint.setAttribute('x', centroid.x);
                hint.setAttribute('y', centroid.y - 18);
                hint.setAttribute('text-anchor', 'middle');
                hint.setAttribute('fill', 'rgba(255,255,255,0.6)');
                hint.setAttribute('font-size', '11');
                hint.style.cursor = 'pointer';
                hint.style.textShadow = '0 0 4px rgba(0,0,0,0.8)';
                hint.textContent = 'â–¶ click to explore relationship';
                hint.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showHyperedgeInfo(hyperedge);
                });
                group.appendChild(hint);

                // Append group to SVG
                svg.appendChild(group);
                console.log('ðŸ”— Group added to SVG');
            });

            // =========================================================================
            // HOVER INTERACTIONS: Dim other hyperedges AND unrelated nodes when hovering one
            // =========================================================================
            hyperedgeGroups.forEach(({ group, hyperedge }) => {
                group.addEventListener('mouseenter', () => {
                    // Dim all other hyperedge groups
                    hyperedgeGroups.forEach(({ group: otherGroup, hyperedge: otherHyperedge }) => {
                        if (otherHyperedge.id !== hyperedge.id) {
                            otherGroup.style.opacity = '0.2';
                        }
                    });

                    // Dim all canvas nodes NOT in this hyperedge
                    const memberNodeIds = new Set(hyperedge.nodeIds || []);
                    document.querySelectorAll('.canvas-node').forEach(nodeEl => {
                        const nodeId = nodeEl.dataset.itemId;  // Canvas nodes use data-item-id
                        if (!memberNodeIds.has(nodeId)) {
                            nodeEl.style.opacity = '0.25';
                            nodeEl.style.transition = 'opacity 0.3s ease';
                        } else {
                            // Highlight member nodes
                            nodeEl.style.opacity = '1';
                            nodeEl.style.boxShadow = '0 0 20px rgba(139, 92, 246, 0.6)';
                            nodeEl.style.transition = 'opacity 0.3s ease, box-shadow 0.3s ease';
                        }
                    });
                });

                group.addEventListener('mouseleave', () => {
                    // Restore all hyperedge groups
                    hyperedgeGroups.forEach(({ group: otherGroup }) => {
                        otherGroup.style.opacity = '1';
                    });

                    // Restore all canvas nodes
                    document.querySelectorAll('.canvas-node').forEach(nodeEl => {
                        nodeEl.style.opacity = '1';
                        nodeEl.style.boxShadow = '';
                    });
                });
            });

            console.log('ðŸ”— drawHyperedges complete with', hyperedgeGroups.length, 'groups');
        }

        /**
         * Show hyperedge info panel with philosophy relationship fields
         */
        function showHyperedgeInfo(hyperedge) {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            const meta = hyperedge.metadata || {};
            const philo = meta.philosophyFields || {};
            const isPhilosophy = currentPattern === 'philosophy';

            // Build analyzed nodes list
            const analyzedNodesList = (meta.analyzedNodes || []).map(n =>
                `<li style="margin-bottom: 8px;">
                    <strong>${n.name}</strong>
                    ${n.itemType ? `<span style="margin-left: 8px; padding: 2px 8px; background: rgba(99, 102, 241, 0.2); border-radius: 4px; font-size: 11px;">${n.itemType}</span>` : ''}
                </li>`
            ).join('');

            // Philosophy-specific fields
            let philosophySection = '';
            if (isPhilosophy && Object.keys(philo).length > 0) {
                philosophySection = `
                    <div style="margin-top: 20px; padding: 16px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px;">
                        <h4 style="color: rgba(139, 92, 246, 1); margin-bottom: 16px; display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 20px;">ðŸ›ï¸</span> Philosophy Relationship Analysis
                        </h4>

                        <div style="display: grid; gap: 12px;">
                            <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;">Dialectical Relation</div>
                                <div style="font-size: 14px; color: var(--text-primary);">${philo.dialecticalRelation || 'Not determined'}</div>
                            </div>

                            <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;">Argumentative Flow</div>
                                <div style="font-size: 14px; color: var(--text-primary);">${philo.argumentativeFlow || 'Not determined'}</div>
                            </div>

                            <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;">Conceptual Bridge</div>
                                <div style="font-size: 14px; color: var(--text-primary);">${philo.conceptualBridge || 'Not determined'}</div>
                            </div>

                            ${philo.tension ? `
                            <div style="padding: 12px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 6px;">
                                <div style="font-size: 11px; color: rgba(239, 68, 68, 0.8); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;">âš¡ Philosophical Tension</div>
                                <div style="font-size: 14px; color: var(--text-primary);">${philo.tension}</div>
                            </div>
                            ` : ''}

                            ${philo.synthesis ? `
                            <div style="padding: 12px; background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.2); border-radius: 6px;">
                                <div style="font-size: 11px; color: rgba(34, 197, 94, 0.8); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;">ðŸ”„ Synthesis</div>
                                <div style="font-size: 14px; color: var(--text-primary);">${philo.synthesis}</div>
                            </div>
                            ` : ''}

                            ${philo.speakers && philo.speakers.length > 0 ? `
                            <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;">Speakers/Interlocutors</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 4px;">
                                    ${philo.speakers.map(s => `<span style="padding: 4px 10px; background: rgba(99, 102, 241, 0.2); border-radius: 12px; font-size: 12px;">${s}</span>`).join('')}
                                </div>
                            </div>
                            ` : ''}

                            ${philo.tradition ? `
                            <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;">Philosophical Tradition</div>
                                <div style="font-size: 14px; color: var(--text-primary);">${philo.tradition}</div>
                            </div>
                            ` : ''}
                        </div>

                        ${philo.aiGenerated ? `
                        <div style="margin-top: 12px; padding: 8px 12px; background: rgba(139, 92, 246, 0.1); border-radius: 4px; display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 14px;">ðŸ§ </span>
                            <span style="font-size: 11px; color: rgba(139, 92, 246, 0.8);">Analysis generated by AI based on node content</span>
                        </div>
                        ` : ''}
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div style="padding: 30px; max-width: 600px;">
                    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 24px;">
                        <div style="font-size: 48px;">ðŸ”—</div>
                        <div>
                            <h3 style="color: var(--treeplex-primary); margin-bottom: 4px;">${hyperedge.label}</h3>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${hyperedge.type} hyperedge â€¢ ${hyperedge.nodeIds?.length || 0} connected nodes
                            </div>
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <p style="color: var(--text-secondary); line-height: 1.6; margin: 0;">
                            ${hyperedge.description || 'No description available.'}
                        </p>
                    </div>

                    <div style="padding: 16px; background: rgba(99, 102, 241, 0.1); border-radius: 8px; margin-bottom: 16px;">
                        <h4 style="color: var(--treeplex-primary); margin-bottom: 12px;">ðŸ“Š Analysis Summary</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 13px;">
                            <div>
                                <div style="color: var(--text-secondary);">Method</div>
                                <div style="color: var(--text-primary); font-weight: 600;">${meta.analysisMethod || 'Manual'}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary);">Pattern</div>
                                <div style="color: var(--text-primary); font-weight: 600;">${meta.pattern || currentPattern}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary);">SubItems Generated</div>
                                <div style="color: var(--text-primary); font-weight: 600;">${meta.totalSubItemsGenerated || 0}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary);">Created</div>
                                <div style="color: var(--text-primary); font-weight: 600;">${hyperedge.createdAt ? new Date(hyperedge.createdAt).toLocaleDateString() : 'Unknown'}</div>
                            </div>
                        </div>
                    </div>

                    ${analyzedNodesList ? `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: var(--text-primary); margin-bottom: 12px;">ðŸ“ Analyzed Nodes</h4>
                        <ul style="margin: 0; padding-left: 20px; color: var(--text-secondary); line-height: 1.8;">
                            ${analyzedNodesList}
                        </ul>
                    </div>
                    ` : ''}

                    ${philosophySection}

                    <div style="margin-top: 24px; display: flex; gap: 12px; justify-content: flex-end;">
                        <button onclick="deleteHyperedgeWithConfirm('${hyperedge.id}')"
                            style="padding: 10px 20px; background: rgba(239, 68, 68, 0.2); color: #EF4444; border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 6px; cursor: pointer; font-size: 13px;">
                            ðŸ—‘ï¸ Delete
                        </button>
                        <button onclick="document.getElementById('modal').style.display='none'; focusOnHyperedge('${hyperedge.id}')"
                            style="padding: 10px 20px; background: rgba(139, 92, 246, 0.2); color: #8B5CF6; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 6px; cursor: pointer; font-size: 13px;">
                            ðŸŽ¯ Focus View
                        </button>
                        <button onclick="document.getElementById('modal').style.display='none'"
                            style="padding: 10px 20px; background: var(--treeplex-primary); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">
                            Close
                        </button>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';
        }

        /**
         * Delete hyperedge with confirmation
         */
        function deleteHyperedgeWithConfirm(hyperedgeId) {
            if (confirm('Delete this hyperedge? Member nodes will remain but lose their visual grouping.')) {
                window.deleteHyperedge(hyperedgeId);
                document.getElementById('modal').style.display = 'none';
            }
        }

        // =============================================================================
        // END HYPEREDGE VISUALIZATION
        // =============================================================================

        function drawConnections() {
            // Skip drawing connections for filesystem pattern (uses indent-based hierarchy)
            if (currentPattern === 'filesystem') {
                return;
            }

            const svg = document.getElementById('canvas-connections');
            svg.innerHTML = '';

            // Draw hyperedges first (so they appear behind regular connections)
            drawHyperedges();

            // Recursively draw connections for all nodes
            capexTree.children.forEach(phase => {
                // Skip hidden phases - don't draw connections for nodes that aren't visible
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach(item => {
                    drawNodeConnections(item);
                });
            });
        }

        // Recursive function to draw connections for a node and its descendants
        function drawNodeConnections(node) {
            // Only draw connections if this node is expanded (showing children)
            if (node.expanded !== false && node.subItems && node.subItems.length > 0) {
                node.subItems.forEach(subtask => {
                    // Only draw line if subtask is actually visible
                    if (isNodeVisible(subtask.id)) {
                        drawConnection(
                            node.canvasX + 160, node.canvasY + 60,      // From parent center-right
                            subtask.canvasX, subtask.canvasY + 60,      // To subtask center-left
                            'rgba(99, 102, 241, 0.5)',                  // Purple for parent-child
                            'solid'
                        );
                    }

                    // Recursively draw connections for this subtask's descendants
                    drawNodeConnections(subtask);
                });
            }

            // Draw lines for dependencies only if both nodes are visible
            if (node.dependencies && node.dependencies.length > 0) {
                node.dependencies.forEach(depId => {
                    const depNode = canvasNodes.find(n => n.data.id === depId);
                    if (depNode && depNode.data) {
                        // Only draw if both the dependency and this node are visible
                        if (isNodeVisible(depId) && isNodeVisible(node.id)) {
                            drawConnection(
                                depNode.data.canvasX + 160, depNode.data.canvasY + 60,  // From dependency
                                node.canvasX, node.canvasY + 60,                        // To dependent item
                                'rgba(239, 68, 68, 0.4)',                               // Red for dependencies
                                'dashed'
                            );
                        }
                    }
                });
            }
        }

        function drawConnection(x1, y1, x2, y2, color, style = 'solid') {
            const svg = document.getElementById('canvas-connections');

            // Adjust coordinates for SVG offset
            x1 += SVG_OFFSET;
            y1 += SVG_OFFSET;
            x2 += SVG_OFFSET;
            y2 += SVG_OFFSET;

            // Create curved path (Bezier curve)
            const midX = (x1 + x2) / 2;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

            // Curved line from x1,y1 to x2,y2
            const d = `M ${x1} ${y1} Q ${midX} ${y1}, ${midX} ${(y1 + y2) / 2} T ${x2} ${y2}`;

            path.setAttribute('d', d);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            if (style === 'dashed') {
                path.setAttribute('stroke-dasharray', '5,5');
            }

            // Add arrow marker
            path.setAttribute('marker-end', 'url(#arrowhead-' + style + ')');

            svg.appendChild(path);
        }

        // Initialize arrow markers for SVG
        function initializeArrowMarkers() {
            const svg = document.getElementById('canvas-connections');

            // Define arrow markers
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Solid arrow (for parent-child)
            const solidMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            solidMarker.setAttribute('id', 'arrowhead-solid');
            solidMarker.setAttribute('markerWidth', '10');
            solidMarker.setAttribute('markerHeight', '10');
            solidMarker.setAttribute('refX', '9');
            solidMarker.setAttribute('refY', '3');
            solidMarker.setAttribute('orient', 'auto');
            const solidPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            solidPath.setAttribute('points', '0 0, 10 3, 0 6');
            solidPath.setAttribute('fill', 'rgba(99, 102, 241, 0.5)');
            solidMarker.appendChild(solidPath);

            // Dashed arrow (for dependencies)
            const dashedMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            dashedMarker.setAttribute('id', 'arrowhead-dashed');
            dashedMarker.setAttribute('markerWidth', '10');
            dashedMarker.setAttribute('markerHeight', '10');
            dashedMarker.setAttribute('refX', '9');
            dashedMarker.setAttribute('refY', '3');
            dashedMarker.setAttribute('orient', 'auto');
            const dashedPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            dashedPath.setAttribute('points', '0 0, 10 3, 0 6');
            dashedPath.setAttribute('fill', 'rgba(239, 68, 68, 0.4)');
            dashedMarker.appendChild(dashedPath);

            defs.appendChild(solidMarker);
            defs.appendChild(dashedMarker);
            svg.appendChild(defs);
        }

        /**
         * Show dialog to create a hyperedge from selected nodes
         */
        function showHyperedgeDialog() {
            // Remove any existing dialog
            const existingDialog = document.getElementById('hyperedge-dialog');
            if (existingDialog) existingDialog.remove();

            // Create modal dialog
            const dialog = document.createElement('div');
            dialog.id = 'hyperedge-dialog';
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--card-bg);
                border: 2px solid var(--border);
                border-radius: 12px;
                padding: 24px;
                z-index: 10001;
                box-shadow: 0 12px 48px rgba(0,0,0,0.8);
                min-width: 400px;
                max-width: 500px;
            `;

            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: var(--text-primary);">Create Hyperedge</h3>
                <p style="color: var(--text-secondary); font-size: 14px;">
                    Creating hyperedge with ${selectedNodes.length} selected nodes
                </p>

                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-primary); font-weight: 600;">
                        Hyperedge Type:
                    </label>
                    <select id="hyperedge-type" style="
                        width: 100%;
                        padding: 10px;
                        background: var(--input-bg);
                        border: 1px solid var(--border);
                        border-radius: 6px;
                        color: var(--text-primary);
                        font-size: 14px;
                    ">
                        <option value="montage">ðŸŽ¬ Montage (Film)</option>
                        <option value="argument">ðŸ—£ï¸ Argument (Philosophy)</option>
                        <option value="theme">ðŸŽ¯ Theme (Roadmap/Product)</option>
                        <option value="dependency-cluster">ðŸ“¦ Dependency Cluster</option>
                        <option value="location">ðŸ“ Location Group (Film)</option>
                        <option value="character">ðŸ‘¥ Character Arc (Film)</option>
                        <option value="custom">âœï¸ Custom</option>
                    </select>
                </div>

                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-primary); font-weight: 600;">
                        Label:
                    </label>
                    <input type="text" id="hyperedge-label" placeholder="e.g., 'Training Montage', 'Socratic Refutation'" style="
                        width: 100%;
                        padding: 10px;
                        background: var(--input-bg);
                        border: 1px solid var(--border);
                        border-radius: 6px;
                        color: var(--text-primary);
                        font-size: 14px;
                    ">
                </div>

                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button id="hyperedge-create-btn" style="
                        flex: 1;
                        padding: 12px 24px;
                        background: var(--treeplex-primary);
                        border: none;
                        border-radius: 6px;
                        color: white;
                        font-weight: 600;
                        cursor: pointer;
                        font-size: 14px;
                    ">Create Hyperedge</button>
                    <button id="hyperedge-cancel-btn" style="
                        flex: 1;
                        padding: 12px 24px;
                        background: var(--input-bg);
                        border: 1px solid var(--border);
                        border-radius: 6px;
                        color: var(--text-primary);
                        font-weight: 600;
                        cursor: pointer;
                        font-size: 14px;
                    ">Cancel</button>
                </div>
            `;

            // Add backdrop
            const backdrop = document.createElement('div');
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
            `;
            backdrop.id = 'hyperedge-backdrop';

            document.body.appendChild(backdrop);
            document.body.appendChild(dialog);

            // Focus label input
            const labelInput = document.getElementById('hyperedge-label');
            labelInput.focus();

            // Handle create button
            const createBtn = document.getElementById('hyperedge-create-btn');
            createBtn.addEventListener('click', () => {
                const type = document.getElementById('hyperedge-type').value;
                const label = labelInput.value.trim();

                if (!label) {
                    alert('Please enter a label for the hyperedge');
                    return;
                }

                // Get node IDs
                const nodeIds = selectedNodes.map(n => n.id);

                // Create hyperedge
                const hyperedge = addHyperedge(type, label, nodeIds);

                if (hyperedge) {
                    console.log('âœ… Hyperedge created:', hyperedge);

                    // Clear selection
                    selectedNodes = [];
                    document.querySelectorAll('.canvas-node').forEach(n => n.classList.remove('selected'));
                    updateSelectionCounter();

                    // Re-render canvas to show the new hyperedge
                    renderCanvas();

                    // Close dialog
                    dialog.remove();
                    backdrop.remove();
                } else {
                    alert('Failed to create hyperedge');
                }
            });

            // Handle cancel button
            const cancelBtn = document.getElementById('hyperedge-cancel-btn');
            cancelBtn.addEventListener('click', () => {
                dialog.remove();
                backdrop.remove();
            });

            // Close on backdrop click
            backdrop.addEventListener('click', () => {
                dialog.remove();
                backdrop.remove();
            });

            // Close on Escape
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    dialog.remove();
                    backdrop.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }

        function showCanvasContextMenu(x, y, item) {
            console.log('Showing canvas context menu for:', item.name);

            // Remove any existing context menu
            const existing = document.getElementById('canvas-context-menu');
            if (existing) existing.remove();

            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'canvas-context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                background: var(--card-bg);
                border: 2px solid var(--border);
                border-radius: 8px;
                padding: 8px;
                z-index: 10000;
                box-shadow: 0 8px 24px rgba(0,0,0,0.6);
                min-width: 200px;
            `;

            const menuItems = [
                { label: 'âœï¸ Edit Details', action: () => {
                    console.log('Edit Details clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's native handleEdit function
                    if (typeof handleEdit === 'function') {
                        console.log('Calling TreeListy handleEdit function');
                        handleEdit();
                    } else {
                        console.error('handleEdit function not found!');
                    }
                }},
                { label: 'âž• Add Subtask', action: () => {
                    console.log('Add Subtask clicked for:', item.name);
                    activeNode = item;

                    if (!item.subItems) item.subItems = [];
                    const newSubtask = {
                        id: 'subtask-' + Date.now(),
                        name: 'New Subtask',
                        type: 'subtask',
                        description: '',
                        pmStatus: 'To Do',
                        pmProgress: 0,
                        pmRAGStatus: 'Amber',
                        pmPriority: 'Medium',
                        icon: 'ðŸ“‹',
                        itemType: 'Feature'  // Add itemType to match pattern
                    };
                    item.subItems.push(newSubtask);

                    // Set the new subtask as active and open edit
                    activeNode = newSubtask;

                    // Save state for undo before opening edit
                    if (typeof saveState === 'function') {
                        saveState('Add subtask');
                    }

                    if (typeof handleEdit === 'function') {
                        console.log('Opening edit for new subtask');
                        handleEdit();

                        // Re-render canvas AFTER modal closes (when user saves)
                        // Listen for modal close event
                        const modal = document.getElementById('edit-modal');
                        const renderOnClose = () => {
                            if (modal.style.display === 'none') {
                                console.log('Edit modal closed, re-rendering canvas');
                                renderCanvas();
                                modal.removeEventListener('DOMSubtreeModified', renderOnClose);
                            }
                        };

                        // Watch for modal close
                        setTimeout(() => {
                            const observer = new MutationObserver((mutations) => {
                                mutations.forEach((mutation) => {
                                    if (mutation.attributeName === 'style') {
                                        if (modal.style.display === 'none') {
                                            console.log('Edit modal closed, re-rendering canvas');
                                            renderCanvas();
                                            observer.disconnect();
                                        }
                                    }
                                });
                            });
                            observer.observe(modal, { attributes: true });
                        }, 100);
                    }
                }},
                { label: 'ðŸ’¡ Smart Suggest', action: () => {
                    activeNode = item;
                    alert('Smart Suggest: Use the Edit dialog to access AI-powered field suggestions');
                }},
                { label: 'ðŸ¤– AI Analysis', action: () => {
                    activeNode = item;
                    alert('AI Analysis: This feature analyzes the item with AI. Access via Edit dialog AI buttons.');
                }},
                { label: 'ðŸ“Š Show Info Panel', action: () => {
                    console.log('Show Info Panel clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's showInfo function
                    if (typeof showInfo === 'function') {
                        console.log('Calling TreeListy showInfo function');
                        showInfo(item);
                    } else {
                        console.error('showInfo function not found!');
                    }
                }},
                { label: 'ðŸ—‘ï¸ Delete Item', action: () => {
                    console.log('Delete clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's native handleDelete function
                    if (typeof handleDelete === 'function') {
                        console.log('Calling TreeListy handleDelete function');
                        handleDelete();
                        // Re-render canvas after deletion
                        renderCanvas();
                    } else {
                        console.error('handleDelete function not found!');
                    }
                }}
            ];

            // Add "Create Hyperedge" option if 2+ nodes are selected
            if (selectedNodes.length >= 2) {
                menuItems.push({
                    label: `ðŸ”— Create Hyperedge (${selectedNodes.length} nodes)`,
                    action: () => {
                        console.log('Create Hyperedge clicked');
                        showHyperedgeDialog();
                    }
                });
            }

            // Add "Analyze Selection" - Deep Dive feature (Structured Scholar)
            // Works for single node or multiple nodes
            const nodesToAnalyze = selectedNodes.length > 0 ? selectedNodes : [item];
            const analyzeLabel = nodesToAnalyze.length > 1
                ? `ðŸŽ“ Deep Dive (${nodesToAnalyze.length} nodes)`
                : 'ðŸŽ“ Deep Dive Analysis';

            menuItems.push({
                label: analyzeLabel,
                action: () => {
                    console.log('Deep Dive Analysis clicked for:', nodesToAnalyze.map(n => n.name));
                    handleAnalyzeSelection(nodesToAnalyze);
                }
            });

            // Add "Share for Collaboration" option (works for 1+ nodes)
            const shareNodes = selectedNodes.length > 0 ? selectedNodes : [item];
            const shareLabel = shareNodes.length > 1
                ? `ðŸ“¤ Share ${shareNodes.length} nodes for collaboration`
                : 'ðŸ“¤ Share for collaboration';

            menuItems.push({
                label: shareLabel,
                action: () => {
                    console.log('Share for collaboration clicked for:', shareNodes.map(n => n.name));
                    showShareBranchModal(shareNodes.map(n => n.id));
                }
            });

            menuItems.forEach(menuItem => {
                const btn = document.createElement('button');
                btn.textContent = menuItem.label;
                btn.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 10px 12px;
                    background: transparent;
                    border: none;
                    color: var(--text-primary);
                    text-align: left;
                    cursor: pointer;
                    border-radius: 4px;
                    font-size: 14px;
                    margin-bottom: 4px;
                `;
                btn.onmouseover = () => btn.style.background = 'var(--treeplex-primary)';
                btn.onmouseout = () => btn.style.background = 'transparent';
                btn.onclick = (e) => {
                    console.log('Context menu button clicked:', menuItem.label);
                    e.preventDefault();
                    e.stopPropagation();

                    // Execute action first
                    try {
                        menuItem.action();
                    } catch (error) {
                        console.error('Error executing menu action:', error);
                    }

                    // Remove menu after a tiny delay to ensure action completes
                    setTimeout(() => menu.remove(), 10);
                };
                menu.appendChild(btn);
            });

            document.body.appendChild(menu);

            // Close menu on click outside
            setTimeout(() => {
                const closeMenu = (e) => {
                    // Don't close if clicking inside the menu
                    if (menu.contains(e.target)) {
                        console.log('Click inside menu, not closing');
                        return;
                    }
                    console.log('Click outside menu, closing');
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                };
                document.addEventListener('click', closeMenu);
            }, 100);

            // Also close on Escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    menu.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }

        function renderCanvasNode(item, phase, parentItem = null, nestingLevel = 0) {
            const canvas = document.getElementById('canvas');
            const node = document.createElement('div');
            node.className = 'canvas-node';

            // Check if this node belongs to a hyperedge
            const hyperedge = getNodeHyperedge(item.id);
            const heColors = hyperedge ? getHyperedgeColor(hyperedge) : null;

            // Calculate hierarchical shadow based on nesting level
            // Level 0 (root items): High elevation (big shadow)
            // Level 1+ (subtasks): Lower elevation (smaller shadow)
            const shadowIntensity = Math.max(0, 5 - nestingLevel);  // 5, 4, 3, 2, 1, 0
            const shadowBlur = 8 + (shadowIntensity * 4);  // 8-28px blur
            const shadowSpread = shadowIntensity * 2;  // 0-10px spread
            const shadowOffset = 2 + (shadowIntensity * 2);  // 2-12px offset

            // Apply hyperedge glow if member, otherwise default shadow
            if (heColors) {
                // Hyperedge member: tinted glow effect
                node.style.boxShadow = `
                    0 ${shadowOffset}px ${shadowBlur}px rgba(0, 0, 0, 0.3),
                    0 0 20px ${heColors.glow},
                    inset 0 0 30px ${heColors.fill}
                `;
                node.style.border = `3px solid ${heColors.border}`;
                node.dataset.hyperedgeId = hyperedge.id;
            } else {
                node.style.boxShadow = `
                    0 ${shadowOffset}px ${shadowBlur}px rgba(0, 0, 0, 0.3),
                    0 ${shadowOffset / 2}px ${shadowBlur / 2}px rgba(99, 102, 241, ${0.1 + shadowIntensity * 0.05})
                `;

                // Add visual distinction for subtasks
                if (parentItem || item.type === 'subtask') {
                    node.style.border = '2px dashed rgba(99, 102, 241, 0.4)';
                    node.style.opacity = '0.95';
                } else {
                    // Root items get solid border with glow
                    node.style.border = '2px solid rgba(99, 102, 241, 0.3)';
                }
            }

            node.style.left = `${item.canvasX}px`;
            node.style.top = `${item.canvasY}px`;
            node.dataset.itemId = item.id;
            node.dataset.nestingLevel = nestingLevel;

            // Check if node has children (support both subItems and children)
            const childList = item.subItems || item.children || [];
            const hasChildren = childList.length > 0;

            // Dynamic tooltip based on whether node has children
            node.title = hasChildren
                ? 'Left-click: Expand/Collapse | Double-click: Edit | Right-click: Menu | Middle-click: Drag'
                : 'Left-click: Info | Double-click: Edit | Right-click: Menu | Middle-click: Drag';

            // Add collapse/expand indicator if node has children
            let expandIndicator = '';
            if (hasChildren) {
                const isExpanded = item.expanded !== false;
                const indicatorIcon = isExpanded ? 'â–¼' : 'â–¶';
                expandIndicator = `<div style="position: absolute; top: 8px; right: 8px; font-size: 12px; cursor: pointer; padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; user-select: none;" class="expand-indicator" data-item-id="${item.id}">${indicatorIcon} ${childList.length}</div>`;
            }

            // RAG status indicator
            let ragHtml = '';
            if (item.pmRAGStatus) {
                const ragColors = { Green: '#22C55E', Amber: '#F59E0B', Red: '#EF4444' };
                const ragColor = ragColors[item.pmRAGStatus];
                ragHtml = `<span style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: ${ragColor}; margin-left: 8px; box-shadow: 0 0 6px ${ragColor}80;"></span>`;
            }

            // Cost badge - only show if pattern supports cost AND cost > 0
            let costHtml = '';
            const patternSupportsCost = PATTERNS[currentPattern]?.fields?.cost;
            if (patternSupportsCost && item.cost && item.cost > 0) {
                const costStr = item.cost >= 1000000 ? `$${(item.cost/1000000).toFixed(1)}M` :
                               item.cost >= 1000 ? `$${(item.cost/1000).toFixed(0)}K` :
                               `$${item.cost}`;
                costHtml = `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; background: rgba(34, 197, 94, 0.2); color: #22C55E;">${costStr}</span>`;
            }

            // Type badge
            let typeHtml = '';
            if (item.itemType) {
                typeHtml = `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; background: rgba(99, 102, 241, 0.2); color: var(--treeplex-primary);">${item.itemType}</span>`;
            }

            // Progress indicator
            let progressHtml = '';
            if (item.pmProgress) {
                progressHtml = `<div style="margin-top: 8px; background: rgba(255,255,255,0.1); height: 4px; border-radius: 2px; overflow: hidden;">
                    <div style="background: var(--treeplex-primary); height: 100%; width: ${item.pmProgress}%;"></div>
                </div>`;
            }

            node.innerHTML = `
                ${expandIndicator}
                <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                    <div style="font-size: 24px;">${item.icon || 'ðŸ“¦'}</div>
                    <div style="flex: 1;">
                        <div style="font-size: 14px; font-weight: 600; margin-bottom: 4px;">
                            ${item.name}${ragHtml}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                            ${(item.description || 'No description').substring(0, 100)}${item.description?.length > 100 ? '...' : ''}
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    ${typeHtml}
                    ${costHtml}
                    ${item.pmOwnerEmail ? `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; background: rgba(255,255,255,0.1);">ðŸ‘¤ ${item.pmOwnerEmail.split('@')[0]}</span>` : ''}
                </div>
                ${progressHtml}
            `;

            // Add expand/collapse handler
            const expandBtn = node.querySelector('.expand-indicator');
            if (expandBtn) {
                expandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    item.expanded = !item.expanded;
                    console.log('Toggling expand for:', item.name, 'expanded:', item.expanded);
                    renderCanvas();
                });
            }

            // Left-click to expand/collapse if has children, otherwise show info panel
            // CTRL+CLICK to multi-select
            node.addEventListener('click', (e) => {
                console.log('Left-click detected on:', item.name);
                e.stopPropagation();

                // CTRL+CLICK or CMD+CLICK: Toggle selection (multi-select)
                if (e.ctrlKey || e.metaKey) {
                    console.log('Ctrl+Click detected - toggling selection');

                    // Check if already selected
                    const index = selectedNodes.indexOf(item);

                    if (index > -1) {
                        // Already selected - DESELECT
                        selectedNodes.splice(index, 1);
                        node.classList.remove('selected');
                        console.log(`Deselected: ${item.name}. Now ${selectedNodes.length} selected.`);
                    } else {
                        // Not selected - ADD TO SELECTION
                        selectedNodes.push(item);
                        node.classList.add('selected');
                        console.log(`Selected: ${item.name}. Now ${selectedNodes.length} selected.`);
                    }

                    // Set most recently clicked as activeNode
                    activeNode = item;

                    // Update selection counter
                    updateSelectionCounter();

                } else {
                    // NORMAL CLICK: Clear all selections and select only this node

                    // Clear all selections
                    selectedNodes = [];
                    document.querySelectorAll('.canvas-node').forEach(n => n.classList.remove('selected'));

                    // Select this node
                    activeNode = item;
                    selectedNodes = [item];
                    node.classList.add('selected');

                    // Update selection counter
                    updateSelectionCounter();

                    // Check if node has children (support both subItems and children)
                    const hasChildren = (item.subItems && item.subItems.length > 0) ||
                                      (item.children && item.children.length > 0);

                    if (hasChildren) {
                        // Toggle expand/collapse
                        item.expanded = !item.expanded;
                        console.log('Toggling expand for:', item.name, 'expanded:', item.expanded);
                        renderCanvas();
                    } else {
                        // Leaf node - show info panel
                        if (typeof showInfo === 'function') {
                            console.log('Calling TreeListy showInfo function');
                            showInfo(item);
                        } else {
                            console.error('showInfo function not found!');
                        }
                    }
                }
            });

            // Double-click to edit (HIGHEST PRIORITY)
            node.addEventListener('dblclick', (e) => {
                console.log('Double-click detected on:', item.name);
                e.preventDefault();
                e.stopPropagation();

                // Cancel any drag that might have started
                isDraggingCanvasNode = false;
                draggedCanvasNode = null;
                node.classList.remove('dragging');

                // Set active node and call TreeListy's edit function
                activeNode = item;
                console.log('Opening edit dialog for:', item.name);

                if (typeof handleEdit === 'function') {
                    console.log('Calling TreeListy handleEdit function');
                    handleEdit();
                } else {
                    console.error('handleEdit function not found!');
                }
            });

            // Right-click context menu
            node.addEventListener('contextmenu', (e) => {
                console.log('Right-click detected on:', item.name);
                e.preventDefault();
                e.stopPropagation();

                // Cancel any drag
                isDraggingCanvasNode = false;
                draggedCanvasNode = null;
                node.classList.remove('dragging');

                activeNode = item;

                // Show simple inline context menu
                showCanvasContextMenu(e.pageX, e.pageY, item);
            });

            // Drag with MIDDLE MOUSE BUTTON (button 1) only - left button reserved for panning
            node.addEventListener('mousedown', (e) => {
                const containerRect = document.getElementById('canvas-container').getBoundingClientRect();

                // Middle-click - drag group if node is selected, otherwise drag individual
                if (e.button === 1) {
                    e.preventDefault(); // Prevent browser's middle-click scroll
                    e.stopPropagation();

                    // Check if this node is part of a selection
                    if (selectedNodes.includes(item) && selectedNodes.length > 1) {
                        console.log('Middle-click drag group activated (', selectedNodes.length, 'nodes )');
                        isDraggingSelection = true;
                        const clickX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                        const clickY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                        selectionDragStart = { x: clickX, y: clickY };
                    } else {
                        // Individual node drag
                        console.log('Middle-click drag activated for:', item.name);
                        isDraggingCanvasNode = true;
                        draggedCanvasNode = item;
                        dragStartX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x - item.canvasX;
                        dragStartY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y - item.canvasY;
                        node.classList.add('dragging');
                    }
                }
                // Left-click (button 0) is reserved for panning
                // Right-click (button 2) is free for context menu
            });

            canvas.appendChild(node);
            canvasNodes.push({ element: node, data: item, phase: phase });
        }

        function updateCanvasTransform() {
            const canvas = document.getElementById('canvas');
            if (canvas) {
                canvas.style.transform = `translate(${canvasPan.x}px, ${canvasPan.y}px) scale(${canvasZoom})`;
            }
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const zoomLevel = document.getElementById('zoom-level');
            if (zoomLevel) {
                zoomLevel.textContent = Math.round(canvasZoom * 100) + '%';
            }
        }

        function updateSelectionCounter() {
            const counter = document.getElementById('selection-counter');
            const countSpan = document.getElementById('selection-count');

            if (counter && countSpan) {
                if (selectedNodes.length > 1) {
                    countSpan.textContent = selectedNodes.length;
                    counter.style.display = 'block';
                } else {
                    counter.style.display = 'none';
                }
            }
        }

        function resetView() {
            canvasPan = { x: 0, y: 0 };
            canvasZoom = 1;
            updateCanvasTransform();
        }

        function fitToView() {
            if (canvasNodes.length === 0) return;

            // Find bounding box of all nodes
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            canvasNodes.forEach(({ data }) => {
                minX = Math.min(minX, data.canvasX);
                minY = Math.min(minY, data.canvasY);
                maxX = Math.max(maxX, data.canvasX + 320);  // node width
                maxY = Math.max(maxY, data.canvasY + 120);  // node height
            });

            const container = document.getElementById('canvas-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const contentWidth = maxX - minX + 200;  // padding
            const contentHeight = maxY - minY + 200;

            const scaleX = containerWidth / contentWidth;
            const scaleY = containerHeight / contentHeight;
            canvasZoom = Math.min(scaleX, scaleY, 1);  // Don't zoom in beyond 100%

            // Center the content
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            canvasPan.x = containerWidth / 2 - centerX * canvasZoom;
            canvasPan.y = containerHeight / 2 - centerY * canvasZoom;

            updateCanvasTransform();
        }

        function snapToGrid(value) {
            if (!gridEnabled) return value;
            return Math.round(value / gridSize) * gridSize;
        }

        function clearSelection() {
            // Remove selected class from all nodes
            selectedNodes.forEach(nodeData => {
                const nodeEl = canvasNodes.find(n => n.data.id === nodeData.id)?.element;
                if (nodeEl) {
                    nodeEl.classList.remove('selected');
                }
            });
            selectedNodes = [];
            updateSelectionCounter();
        }

        function toggleGrid() {
            gridEnabled = !gridEnabled;
            const gridBtn = document.getElementById('grid-toggle');
            const gridSvg = document.getElementById('canvas-grid');

            if (gridBtn) {
                if (gridEnabled) {
                    gridBtn.style.background = 'rgba(99, 102, 241, 0.6)';
                    gridBtn.style.borderColor = 'rgba(99, 102, 241, 0.8)';
                    gridBtn.style.color = 'white';
                } else {
                    gridBtn.style.background = 'rgba(99, 102, 241, 0.1)';
                    gridBtn.style.borderColor = 'rgba(99, 102, 241, 0.3)';
                    gridBtn.style.color = 'var(--text-primary)';
                }
            }

            if (gridSvg) {
                gridSvg.style.opacity = gridEnabled ? '1' : '0';
            }

            console.log('Grid:', gridEnabled ? 'ON (visible + snapping)' : 'OFF');
        }

        // Auto-layout algorithms
        function applyAutoLayout(layoutType) {
            console.log('Applying layout:', layoutType);

            if (layoutType === 'hierarchical') {
                applyHierarchicalLayout();
            } else if (layoutType === 'timeline') {
                applyTimelineLayout();
            } else if (layoutType === 'force') {
                applyForceDirectedLayout();
            } else if (layoutType === 'radial') {
                applyRadialLayout();
            } else if (layoutType === 'grid') {
                applyGridLayout();
            }

            renderCanvas();
            fitToView();
        }

        function applyHierarchicalLayout() {
            let currentY = 100;
            const levelGap = 250;
            const nodeGap = 350;

            capexTree.children.forEach((phase, phaseIdx) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                let currentX = 200;

                phase.items?.forEach((item) => {
                    item.canvasX = currentX;
                    item.canvasY = currentY;

                    // Layout subtasks to the right and down
                    layoutSubtasksHierarchical(item, currentX + nodeGap, currentY, 1);

                    currentX += nodeGap;
                });

                currentY += levelGap;
            });
        }

        function layoutSubtasksHierarchical(item, startX, startY, level) {
            if (!item.subItems || item.subItems.length === 0) return;

            let currentY = startY;
            const verticalGap = 140;

            item.subItems.forEach((subtask, idx) => {
                subtask.canvasX = startX;
                subtask.canvasY = currentY;

                layoutSubtasksHierarchical(subtask, startX + 350, currentY, level + 1);

                currentY += verticalGap;
            });
        }

        function applyTimelineLayout() {
            let currentX = 200;
            const xGap = 400;
            let currentY = 100;

            capexTree.children.forEach((phase) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach((item) => {
                    item.canvasX = currentX;
                    item.canvasY = currentY;

                    // Layout subtasks vertically below
                    if (item.subItems) {
                        let subY = currentY + 150;
                        item.subItems.forEach(subtask => {
                            subtask.canvasX = currentX;
                            subtask.canvasY = subY;
                            subY += 140;
                        });
                    }

                    currentX += xGap;
                });
            });
        }

        function applyGridLayout() {
            const cols = 4;
            const nodeWidth = 350;
            const nodeHeight = 180;
            let index = 0;

            capexTree.children.forEach((phase) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach((item) => {
                    const col = index % cols;
                    const row = Math.floor(index / cols);

                    item.canvasX = 100 + col * nodeWidth;
                    item.canvasY = 100 + row * nodeHeight;

                    index++;

                    // Layout subtasks in continuation of grid
                    if (item.subItems) {
                        item.subItems.forEach(subtask => {
                            index++;
                            const col = index % cols;
                            const row = Math.floor(index / cols);
                            subtask.canvasX = 100 + col * nodeWidth;
                            subtask.canvasY = 100 + row * nodeHeight;
                        });
                    }
                });
            });
        }

        function applyRadialLayout() {
            const centerX = 600;
            const centerY = 400;
            const radius = 300;
            let totalItems = 0;

            // Count items (only from visible phases)
            capexTree.children.forEach(phase => {
                if (phase.showInCanvas !== false) {
                    totalItems += phase.items?.length || 0;
                }
            });

            let index = 0;

            capexTree.children.forEach((phase) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach((item) => {
                    const angle = (index / totalItems) * Math.PI * 2;
                    item.canvasX = centerX + Math.cos(angle) * radius;
                    item.canvasY = centerY + Math.sin(angle) * radius;

                    // Place subtasks further out
                    if (item.subItems) {
                        item.subItems.forEach((subtask, subIdx) => {
                            const subAngle = angle + (subIdx * 0.2);
                            subtask.canvasX = centerX + Math.cos(subAngle) * (radius + 200);
                            subtask.canvasY = centerY + Math.sin(subAngle) * (radius + 200);
                        });
                    }

                    index++;
                });
            });
        }

        // Barnes-Hut Quadtree for O(n log n) force approximation
        class QuadtreeNode {
            constructor(x, y, width, height, depth = 0) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.depth = depth;  // Track recursion depth
                this.mass = 0;
                this.centerX = 0;
                this.centerY = 0;
                this.children = [];
                this.node = null;  // Actual canvas node if leaf
                this.subdivided = false;
            }

            insert(node) {
                // Check if node is within bounds
                if (node.canvasX < this.x || node.canvasX > this.x + this.width ||
                    node.canvasY < this.y || node.canvasY > this.y + this.height) {
                    return false;
                }

                // If this is empty, place node here
                if (this.mass === 0) {
                    this.node = node;
                    this.mass = 1;
                    this.centerX = node.canvasX;
                    this.centerY = node.canvasY;
                    return true;
                }

                // PREVENT INFINITE RECURSION: Max depth or minimum size check
                const MAX_DEPTH = 15;
                const MIN_SIZE = 1;
                if (this.depth >= MAX_DEPTH || this.width < MIN_SIZE || this.height < MIN_SIZE) {
                    // Can't subdivide further - keep both nodes at this level
                    // Update center of mass to include both
                    const totalMass = this.mass + 1;
                    this.centerX = (this.centerX * this.mass + node.canvasX) / totalMass;
                    this.centerY = (this.centerY * this.mass + node.canvasY) / totalMass;
                    this.mass = totalMass;
                    return true;
                }

                // If this is a leaf, subdivide
                if (!this.subdivided) {
                    this.subdivide();
                }

                // Update center of mass
                const totalMass = this.mass + 1;
                this.centerX = (this.centerX * this.mass + node.canvasX) / totalMass;
                this.centerY = (this.centerY * this.mass + node.canvasY) / totalMass;
                this.mass = totalMass;

                // Insert into appropriate child
                for (let child of this.children) {
                    if (child.insert(node)) {
                        return true;
                    }
                }

                // SAFETY: If no child accepted it, keep it here (prevents infinite recursion)
                // This can happen with floating point precision issues or nodes exactly on boundaries
                return true;
            }

            subdivide() {
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;

                // Create 4 quadrants: NW, NE, SW, SE (pass depth + 1)
                this.children = [
                    new QuadtreeNode(this.x, this.y, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x + halfWidth, this.y, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x, this.y + halfHeight, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x + halfWidth, this.y + halfHeight, halfWidth, halfHeight, this.depth + 1)
                ];

                // Reinsert existing node
                if (this.node) {
                    for (let child of this.children) {
                        if (child.insert(this.node)) {
                            break;
                        }
                    }
                    this.node = null;
                }

                this.subdivided = true;
            }

            calculateForce(node, force, repulsion, theta = 0.5) {
                // Skip if this is the same node
                if (this.node === node) {
                    return;
                }

                const dx = this.centerX - node.canvasX;
                const dy = this.centerY - node.canvasY;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                // If this is a leaf or far enough, treat as single body
                if (!this.subdivided || (this.width / dist < theta)) {
                    const forceMag = repulsion * this.mass / (dist * dist);
                    force.x -= (dx / dist) * forceMag;
                    force.y -= (dy / dist) * forceMag;
                } else {
                    // Recurse into children
                    for (let child of this.children) {
                        if (child.mass > 0) {
                            child.calculateForce(node, force, repulsion, theta);
                        }
                    }
                }
            }
        }

        function buildQuadtree(nodes) {
            // Find bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.canvasX);
                minY = Math.min(minY, node.canvasY);
                maxX = Math.max(maxX, node.canvasX);
                maxY = Math.max(maxY, node.canvasY);
            });

            // Add padding
            const padding = 100;
            minX -= padding;
            minY -= padding;
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;

            // Build tree
            const root = new QuadtreeNode(minX, minY, width, height);
            nodes.forEach(node => root.insert(node));
            return root;
        }

        function applyForceDirectedLayout() {
            // Enhanced force-directed layout with Barnes-Hut, collision detection, and phase-aware forces
            const iterations = 500;  // Increased from 100 for better convergence
            const baseRepulsion = 8000;  // Stronger repulsion
            const baseAttraction = 0.02;  // Stronger attraction
            const nodeRadius = 120;  // Collision detection radius
            const phaseAttractionStrength = 0.008;  // Keep nodes near their phase
            const centerPull = 0.001;  // Weak pull toward center

            // Collect all nodes and track phase membership
            let allNodes = [];
            const phaseMap = new Map();  // Map node ID to phase

            // Recursive function to add node and all its descendants
            function addNodeAndDescendants(node, phase) {
                allNodes.push(node);
                phaseMap.set(node.id, phase);

                // Recursively add all subItems
                if (node.subItems) {
                    node.subItems.forEach(subtask => {
                        addNodeAndDescendants(subtask, phase);
                    });
                }

                // Also handle 'children' for filesystem pattern
                if (node.children) {
                    node.children.forEach(child => {
                        addNodeAndDescendants(child, phase);
                    });
                }
            }

            capexTree.children.forEach(phase => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach(item => {
                    addNodeAndDescendants(item, phase);
                });
            });

            // Calculate initial phase centers for phase-aware forces
            const phaseCenters = new Map();
            capexTree.children.forEach(phase => {
                const phaseNodes = allNodes.filter(n => phaseMap.get(n.id) === phase);
                if (phaseNodes.length > 0) {
                    const avgX = phaseNodes.reduce((sum, n) => sum + n.canvasX, 0) / phaseNodes.length;
                    const avgY = phaseNodes.reduce((sum, n) => sum + n.canvasY, 0) / phaseNodes.length;
                    phaseCenters.set(phase.id, { x: avgX, y: avgY });
                }
            });

            // Main simulation loop with progressive damping
            for (let iter = 0; iter < iterations; iter++) {
                const progress = iter / iterations;
                const damping = 0.95 - (progress * 0.45);  // Progressive cooling: 0.95 â†’ 0.5
                const tempRepulsion = baseRepulsion * (1 - progress * 0.3);  // Reduce repulsion over time

                // Build quadtree for Barnes-Hut approximation (O(n log n) instead of O(nÂ²))
                const quadtree = buildQuadtree(allNodes);

                // Apply repulsion using Barnes-Hut approximation
                allNodes.forEach(node => {
                    const force = { x: 0, y: 0 };
                    quadtree.calculateForce(node, force, tempRepulsion);
                    node.canvasX += force.x * damping;
                    node.canvasY += force.y * damping;
                });

                // Collision detection: prevent overlaps (still O(nÂ²) but necessary for precision)
                for (let i = 0; i < allNodes.length; i++) {
                    for (let j = i + 1; j < allNodes.length; j++) {
                        const dx = allNodes[j].canvasX - allNodes[i].canvasX;
                        const dy = allNodes[j].canvasY - allNodes[i].canvasY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        const minDist = nodeRadius * 2;
                        if (dist < minDist && dist > 0) {
                            // Push nodes apart to prevent overlap
                            const pushForce = (minDist - dist) / dist * 0.5;
                            const pushX = dx * pushForce;
                            const pushY = dy * pushForce;

                            allNodes[i].canvasX -= pushX;
                            allNodes[i].canvasY -= pushY;
                            allNodes[j].canvasX += pushX;
                            allNodes[j].canvasY += pushY;
                        }
                    }
                }

                // Apply attraction for parent-child relationships (recursive)
                function applyParentChildAttraction(parent, damping) {
                    const childList = parent.subItems || parent.children || [];
                    childList.forEach(child => {
                        const dx = child.canvasX - parent.canvasX;
                        const dy = child.canvasY - parent.canvasY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 0) {
                            // Spring-like attraction
                            const force = baseAttraction * dist;
                            const fx = (dx / dist) * force;
                            const fy = (dy / dist) * force;

                            parent.canvasX += fx * damping;
                            parent.canvasY += fy * damping;
                            child.canvasX -= fx * damping;
                            child.canvasY -= fy * damping;
                        }

                        // Recursively apply to this child's children
                        applyParentChildAttraction(child, damping);
                    });
                }

                capexTree.children.forEach(phase => {
                    // Skip hidden phases
                    if (phase.showInCanvas === false) {
                        return;
                    }

                    phase.items?.forEach(item => {
                        applyParentChildAttraction(item, damping);
                    });
                });

                // Apply phase-aware forces (keep nodes grouped by phase)
                allNodes.forEach(node => {
                    const phase = phaseMap.get(node.id);
                    if (phase) {
                        const phaseCenter = phaseCenters.get(phase.id);
                        if (phaseCenter) {
                            const dx = phaseCenter.x - node.canvasX;
                            const dy = phaseCenter.y - node.canvasY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist > 0) {
                                // Gentle pull toward phase center (weaker over time)
                                const force = phaseAttractionStrength * dist * (1 - progress);
                                node.canvasX += (dx / dist) * force;
                                node.canvasY += (dy / dist) * force;
                            }
                        }
                    }
                });

                // Apply metadata-based clustering (if enabled)
                if (clusterByField) {
                    const clusterStrength = 0.015;  // Strength of clustering attraction

                    // Helper function to get comparable value for clustering
                    const getClusterValue = (node, field) => {
                        if (field === 'cost') {
                            // Group by cost ranges (0-10k, 10k-50k, 50k-200k, 200k+)
                            const cost = node.cost || 0;
                            if (cost < 10000) return 'low';
                            if (cost < 50000) return 'medium';
                            if (cost < 200000) return 'high';
                            return 'very-high';
                        } else if (field === 'modifiedDate') {
                            // Group by month
                            if (!node.modifiedDate) return 'unknown';
                            return node.modifiedDate.substring(0, 7); // YYYY-MM
                        } else {
                            // Direct field value (itemType, owner, pmRAGStatus, etc.)
                            return node[field] || 'unknown';
                        }
                    };

                    // Apply clustering forces between nodes with matching metadata
                    for (let i = 0; i < allNodes.length; i++) {
                        for (let j = i + 1; j < allNodes.length; j++) {
                            const valueA = getClusterValue(allNodes[i], clusterByField);
                            const valueB = getClusterValue(allNodes[j], clusterByField);

                            // If nodes share the same metadata value, attract them
                            if (valueA === valueB && valueA !== 'unknown') {
                                const dx = allNodes[j].canvasX - allNodes[i].canvasX;
                                const dy = allNodes[j].canvasY - allNodes[i].canvasY;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist > 0) {
                                    // Gentle attraction between similar nodes
                                    const force = clusterStrength * dist * (1 - progress * 0.5);
                                    const fx = (dx / dist) * force;
                                    const fy = (dy / dist) * force;

                                    allNodes[i].canvasX += fx;
                                    allNodes[i].canvasY += fy;
                                    allNodes[j].canvasX -= fx;
                                    allNodes[j].canvasY -= fy;
                                }
                            }
                        }
                    }
                }

                // Pull towards global center (very weak)
                allNodes.forEach(node => {
                    node.canvasX -= (node.canvasX - 600) * centerPull * damping;
                    node.canvasY -= (node.canvasY - 400) * centerPull * damping;
                });

                // Recalculate phase centers every 50 iterations for better clustering
                if (iter % 50 === 0) {
                    capexTree.children.forEach(phase => {
                        const phaseNodes = allNodes.filter(n => phaseMap.get(n.id) === phase);
                        if (phaseNodes.length > 0) {
                            const avgX = phaseNodes.reduce((sum, n) => sum + n.canvasX, 0) / phaseNodes.length;
                            const avgY = phaseNodes.reduce((sum, n) => sum + n.canvasY, 0) / phaseNodes.length;
                            phaseCenters.set(phase.id, { x: avgX, y: avgY });
                        }
                    });
                }
            }

            const clusterMsg = clusterByField ? ` with clustering by ${clusterByField}` : '';
            console.log(`Force-directed layout complete: ${iterations} iterations, ${allNodes.length} nodes${clusterMsg}`);
        }

        // Canvas container event listeners
        function initializeCanvasEvents() {
            const container = document.getElementById('canvas-container');

            container.addEventListener('mousedown', (e) => {
                const containerRect = container.getBoundingClientRect();

                // Middle mouse button - start selection
                if (e.button === 1 && (e.target === container || e.target.id === 'canvas')) {
                    e.preventDefault();
                    isSelecting = true;
                    const x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                    selectionStart = { x, y };
                    selectionEnd = { x, y };

                    // Clear previous selection
                    clearSelection();

                    // Create selection overlay
                    let selectionBox = document.getElementById('selection-box');
                    if (!selectionBox) {
                        selectionBox = document.createElement('div');
                        selectionBox.id = 'selection-box';
                        selectionBox.style.position = 'absolute';
                        selectionBox.style.border = '2px dashed var(--treeplex-primary)';
                        selectionBox.style.background = 'rgba(0, 166, 125, 0.1)';
                        selectionBox.style.pointerEvents = 'none';
                        selectionBox.style.zIndex = '9999';
                        document.getElementById('canvas').appendChild(selectionBox);
                    }
                    selectionBox.style.display = 'block';
                    return;
                }

                // Left mouse button on canvas background - pan
                if (e.button === 0 && (e.target === container || e.target.id === 'canvas')) {
                    // Clear selection when clicking on empty space
                    if (selectedNodes.length > 0 && !e.ctrlKey) {
                        clearSelection();
                    }

                    // Start panning
                    isPanningCanvas = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    container.classList.add('grabbing');
                }
            });

            container.addEventListener('mousemove', (e) => {
                const containerRect = container.getBoundingClientRect();

                // Drawing selection box with middle mouse
                if (isSelecting) {
                    const x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                    selectionEnd = { x, y };

                    // Update selection box visual
                    const selectionBox = document.getElementById('selection-box');
                    if (selectionBox) {
                        const minX = Math.min(selectionStart.x, selectionEnd.x);
                        const minY = Math.min(selectionStart.y, selectionEnd.y);
                        const maxX = Math.max(selectionStart.x, selectionEnd.x);
                        const maxY = Math.max(selectionStart.y, selectionEnd.y);

                        // Convert canvas coordinates back to screen coordinates (reverse the zoom/pan transformation)
                        const screenMinX = (minX + canvasPan.x) * canvasZoom;
                        const screenMinY = (minY + canvasPan.y) * canvasZoom;
                        const screenMaxX = (maxX + canvasPan.x) * canvasZoom;
                        const screenMaxY = (maxY + canvasPan.y) * canvasZoom;

                        selectionBox.style.left = `${screenMinX}px`;
                        selectionBox.style.top = `${screenMinY}px`;
                        selectionBox.style.width = `${screenMaxX - screenMinX}px`;
                        selectionBox.style.height = `${screenMaxY - screenMinY}px`;
                    }
                    return;
                }

                // Dragging multiple selected nodes
                if (isDraggingSelection && selectedNodes.length > 0) {
                    const currentX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const currentY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;

                    const deltaX = currentX - selectionDragStart.x;
                    const deltaY = currentY - selectionDragStart.y;

                    // Move all selected nodes
                    selectedNodes.forEach(nodeData => {
                        nodeData.canvasX += deltaX;
                        nodeData.canvasY += deltaY;

                        const nodeEl = canvasNodes.find(n => n.data.id === nodeData.id)?.element;
                        if (nodeEl) {
                            nodeEl.style.left = `${nodeData.canvasX}px`;
                            nodeEl.style.top = `${nodeData.canvasY}px`;
                        }

                        // Move children of each selected node
                        function moveChildren(node, dx, dy) {
                            const childList = node.items || node.children || node.subItems || [];
                            childList.forEach(child => {
                                if (child.canvasX !== undefined && child.canvasY !== undefined) {
                                    child.canvasX += dx;
                                    child.canvasY += dy;

                                    const childEl = canvasNodes.find(n => n.data.id === child.id)?.element;
                                    if (childEl) {
                                        childEl.style.left = `${child.canvasX}px`;
                                        childEl.style.top = `${child.canvasY}px`;
                                    }

                                    moveChildren(child, dx, dy);
                                }
                            });
                        }
                        moveChildren(nodeData, deltaX, deltaY);
                    });

                    selectionDragStart = { x: currentX, y: currentY };
                    drawConnections();
                    return;
                }

                if (isPanningCanvas) {
                    const dx = (e.clientX - panStartX) / canvasZoom;
                    const dy = (e.clientY - panStartY) / canvasZoom;
                    canvasPan.x += dx;
                    canvasPan.y += dy;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    updateCanvasTransform();
                } else if (isDraggingCanvasNode && draggedCanvasNode) {
                    const containerRect = container.getBoundingClientRect();
                    let x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x - dragStartX;
                    let y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y - dragStartY;

                    // Apply grid snapping if enabled
                    x = snapToGrid(x);
                    y = snapToGrid(y);

                    // Calculate delta (how much the node moved)
                    const deltaX = x - draggedCanvasNode.canvasX;
                    const deltaY = y - draggedCanvasNode.canvasY;

                    // Update parent position
                    draggedCanvasNode.canvasX = x;
                    draggedCanvasNode.canvasY = y;

                    const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                    if (nodeEl) {
                        nodeEl.style.left = `${x}px`;
                        nodeEl.style.top = `${y}px`;
                    }

                    // Recursively move all children by the same delta
                    function moveChildren(node, dx, dy) {
                        const childList = node.items || node.children || node.subItems || [];
                        childList.forEach(child => {
                            if (child.canvasX !== undefined && child.canvasY !== undefined) {
                                child.canvasX += dx;
                                child.canvasY += dy;

                                // Update child DOM element
                                const childEl = canvasNodes.find(n => n.data.id === child.id)?.element;
                                if (childEl) {
                                    childEl.style.left = `${child.canvasX}px`;
                                    childEl.style.top = `${child.canvasY}px`;
                                }

                                // Recursively move grandchildren
                                moveChildren(child, dx, dy);
                            }
                        });
                    }

                    // Move all descendants
                    if (deltaX !== 0 || deltaY !== 0) {
                        moveChildren(draggedCanvasNode, deltaX, deltaY);
                    }

                    // Redraw connections while dragging
                    drawConnections();
                }
            });

            container.addEventListener('mouseup', (e) => {
                // Finalize selection
                if (isSelecting) {
                    isSelecting = false;

                    // Hide selection box
                    const selectionBox = document.getElementById('selection-box');
                    if (selectionBox) {
                        selectionBox.style.display = 'none';
                    }

                    // Calculate selection bounds
                    const minX = Math.min(selectionStart.x, selectionEnd.x);
                    const minY = Math.min(selectionStart.y, selectionEnd.y);
                    const maxX = Math.max(selectionStart.x, selectionEnd.x);
                    const maxY = Math.max(selectionStart.y, selectionEnd.y);

                    // Find nodes within selection
                    const containerRect = container.getBoundingClientRect();
                    canvasNodes.forEach(nodeObj => {
                        const node = nodeObj.data;
                        const nodeEl = nodeObj.element;

                        if (node.canvasX !== undefined && node.canvasY !== undefined) {
                            const rect = nodeEl.getBoundingClientRect();
                            const nodeX = (rect.left - containerRect.left) / canvasZoom - canvasPan.x;
                            const nodeY = (rect.top - containerRect.top) / canvasZoom - canvasPan.y;
                            const nodeW = rect.width / canvasZoom;
                            const nodeH = rect.height / canvasZoom;

                            // Check if node intersects with selection box
                            if (nodeX < maxX && nodeX + nodeW > minX &&
                                nodeY < maxY && nodeY + nodeH > minY) {
                                selectedNodes.push(node);
                                nodeEl.classList.add('selected');
                            }
                        }
                    });

                    console.log(`Selected ${selectedNodes.length} nodes`);
                    return;
                }

                // End dragging selection
                if (isDraggingSelection) {
                    isDraggingSelection = false;
                    return;
                }

                isPanningCanvas = false;
                container.classList.remove('grabbing');

                // Clean up dragging state
                if (isDraggingCanvasNode || draggedCanvasNode) {
                    if (draggedCanvasNode) {
                        const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                        if (nodeEl) {
                            nodeEl.classList.remove('dragging');
                        }
                    }
                    isDraggingCanvasNode = false;
                    draggedCanvasNode = null;
                }
            });

            // Also handle mouseleave to stop dragging when mouse leaves container
            container.addEventListener('mouseleave', () => {
                isPanningCanvas = false;
                container.classList.remove('grabbing');

                if (isDraggingCanvasNode || draggedCanvasNode) {
                    if (draggedCanvasNode) {
                        const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                        if (nodeEl) {
                            nodeEl.classList.remove('dragging');
                        }
                    }
                    isDraggingCanvasNode = false;
                    draggedCanvasNode = null;
                }
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                canvasZoom = Math.max(0.1, Math.min(5, canvasZoom * delta));
                updateCanvasTransform();
            }, { passive: false });
        }

        // =====================================================================
        // PROGRESSIVE EXPAND/COLLAPSE - Works in both Tree and Canvas Views
        // =====================================================================

        // Calculate the maximum depth of the tree
        function getMaxDepth(node = capexTree, depth = 0) {
            let maxDepth = depth;
            if (node.children) {
                node.children.forEach(child => {
                    maxDepth = Math.max(maxDepth, getMaxDepth(child, depth + 1));
                });
            }
            if (node.items) {
                node.items.forEach(item => {
                    maxDepth = Math.max(maxDepth, getItemMaxDepth(item, depth + 1));
                });
            }
            return maxDepth;
        }

        function getItemMaxDepth(item, depth = 0) {
            let maxDepth = depth;
            if (item.subItems && item.subItems.length > 0) {
                item.subItems.forEach(subItem => {
                    maxDepth = Math.max(maxDepth, getItemMaxDepth(subItem, depth + 1));
                });
            }
            return maxDepth;
        }

        // Collapse one level at a time (deepest first)
        function collapseOneLevel() {
            console.log('ðŸ” collapseOneLevel called');

            // Find all items with subItems that are currently expanded
            let deepestExpandedWithChildren = [];
            let maxDepthFound = 0;

            function findExpandedWithChildren(node, depth = 0, path = []) {
                // For phases (node.children)
                if (node.children) {
                    node.children.forEach(child => {
                        findExpandedWithChildren(child, depth + 1, [...path, node]);
                    });
                }

                // For items
                if (node.items) {
                    node.items.forEach(item => {
                        findExpandedItems(item, depth + 1, [...path, node]);
                    });
                }
            }

            function findExpandedItems(item, depth, path) {
                // If this item has subItems and is expanded, record it
                if (item.subItems && item.subItems.length > 0 && item.expanded !== false) {
                    deepestExpandedWithChildren.push({ item, depth, path });
                    maxDepthFound = Math.max(maxDepthFound, depth);

                    // Recurse into subItems
                    item.subItems.forEach(subItem => {
                        findExpandedItems(subItem, depth + 1, [...path, item]);
                    });
                } else if (item.subItems) {
                    // Has children but collapsed - still check children in case some are expanded
                    item.subItems.forEach(subItem => {
                        findExpandedItems(subItem, depth + 1, [...path, item]);
                    });
                }
            }

            findExpandedWithChildren(capexTree);

            console.log('Found', deepestExpandedWithChildren.length, 'expanded items with children');
            console.log('Max depth:', maxDepthFound);

            if (deepestExpandedWithChildren.length === 0) {
                console.log('âœ… Already fully collapsed - no items with children are expanded');
                return;
            }

            // Collapse only the items at the deepest level
            const toCollapse = deepestExpandedWithChildren.filter(x => x.depth === maxDepthFound);
            console.log('Collapsing', toCollapse.length, 'items at depth', maxDepthFound);

            toCollapse.forEach(({ item }) => {
                console.log('  - Collapsing:', item.name);
                item.expanded = false;
            });
        }

        // Expand one level at a time (shallowest first)
        function expandOneLevel() {
            console.log('ðŸ” expandOneLevel called');

            // Find all items with subItems that are currently collapsed
            let collapsedWithChildren = [];
            let minDepthFound = Infinity;

            function findCollapsedWithChildren(node, depth = 0, path = []) {
                // For phases (node.children)
                if (node.children) {
                    node.children.forEach(child => {
                        findCollapsedWithChildren(child, depth + 1, [...path, node]);
                    });
                }

                // For items
                if (node.items) {
                    node.items.forEach(item => {
                        findCollapsedItems(item, depth + 1, [...path, node]);
                    });
                }
            }

            function findCollapsedItems(item, depth, path) {
                // If this item has subItems and is collapsed, record it
                if (item.subItems && item.subItems.length > 0 && item.expanded === false) {
                    collapsedWithChildren.push({ item, depth, path });
                    minDepthFound = Math.min(minDepthFound, depth);
                }

                // Still recurse into subItems even if collapsed (to find deeper collapsed items)
                if (item.subItems) {
                    item.subItems.forEach(subItem => {
                        findCollapsedItems(subItem, depth + 1, [...path, item]);
                    });
                }
            }

            findCollapsedWithChildren(capexTree);

            console.log('Found', collapsedWithChildren.length, 'collapsed items with children');
            console.log('Min depth:', minDepthFound);

            if (collapsedWithChildren.length === 0) {
                console.log('âœ… Already fully expanded - no collapsed items with children');
                return;
            }

            // Expand only the items at the shallowest level
            const toExpand = collapsedWithChildren.filter(x => x.depth === minDepthFound);
            console.log('Expanding', toExpand.length, 'items at depth', minDepthFound);

            toExpand.forEach(({ item }) => {
                console.log('  - Expanding:', item.name);
                item.expanded = true;
            });
        }

        // Canvas-aware expand/collapse handlers
        window.canvasExpandOneLevel = function() {
            console.log('ðŸŽ¯ canvasExpandOneLevel called, viewMode:', viewMode);
            expandOneLevel();

            // Always update tree view
            if (typeof render === 'function') {
                console.log('Calling render() for tree view');
                render();
            }

            // Update canvas view if we're in canvas mode
            if (viewMode === 'canvas') {
                console.log('Calling renderCanvas() for canvas view');
                renderCanvas();
            }

            console.log('âœ… Expand complete');
        };

        window.canvasCollapseOneLevel = function() {
            console.log('ðŸŽ¯ canvasCollapseOneLevel called, viewMode:', viewMode);
            collapseOneLevel();

            // Always update tree view
            if (typeof render === 'function') {
                console.log('Calling render() for tree view');
                render();
            }

            // Update canvas view if we're in canvas mode
            if (viewMode === 'canvas') {
                console.log('Calling renderCanvas() for canvas view');
                renderCanvas();
            }

            console.log('âœ… Collapse complete');
        };

        // Helper to check if a node is visible (not hidden by collapsed parent)
        function isNodeVisible(nodeId) {
            // Find the node and check all its ancestors
            function findAndCheckNode(searchId, node = capexTree, ancestors = []) {
                if (node.id === searchId) {
                    // Check if any ancestor is collapsed
                    return ancestors.every(ancestor => ancestor.expanded !== false);
                }

                if (node.items) {
                    for (const item of node.items) {
                        if (checkItemVisibility(searchId, item, ancestors)) {
                            return true;
                        }
                    }
                }

                if (node.children) {
                    for (const child of node.children) {
                        const result = findAndCheckNode(searchId, child, [...ancestors, node]);
                        if (result !== undefined) return result;
                    }
                }

                return undefined;
            }

            function checkItemVisibility(searchId, item, ancestors = []) {
                if (item.id === searchId) {
                    return ancestors.every(ancestor => ancestor.expanded !== false);
                }

                if (item.subItems) {
                    for (const subItem of item.subItems) {
                        const result = checkItemVisibility(searchId, subItem, [...ancestors, item]);
                        if (result !== undefined) return result;
                    }
                }

                return undefined;
            }

            const result = findAndCheckNode(nodeId);
            return result === undefined ? true : result;  // Default to visible if not found
        }

        window.isNodeVisible = isNodeVisible;


        // =============================================================================
        // UNDO/REDO SYSTEM
        // =============================================================================

        // History stack for undo functionality
        const historyStack = [];
        const MAX_HISTORY = 50; // Keep last 50 states

        // Save current state to history before making changes
        function saveState(actionName = 'Unknown action') {
            const state = {
                tree: JSON.parse(JSON.stringify(capexTree)), // Deep copy
                pattern: currentPattern,
                timestamp: Date.now(),
                action: actionName
            };

            historyStack.push(state);

            // Limit history size
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift(); // Remove oldest
            }

            updateUndoButton();

            // Mark tree as changed (for auto-save)
            if (typeof treeManager !== 'undefined') {
                treeManager.markAsChanged();
            }
            console.log(`ðŸ’¾ State saved: ${actionName} (${historyStack.length} states in history)`);
        }

        // Undo last action
        function undo() {
            if (historyStack.length === 0) {
                console.warn('âš ï¸ No history to undo');
                return;
            }

            const previousState = historyStack.pop();

            // Restore previous state
            capexTree = previousState.tree;
            currentPattern = previousState.pattern;
            document.getElementById('pattern-select').value = currentPattern;

            // Re-render
            render();

            updateUndoButton();

            console.log(`â†©ï¸ Undo: Restored state from "${previousState.action}" (${historyStack.length} states remaining)`);

            // Show toast notification
            showToast(`Undone: ${previousState.action}`);
        }

        // Update undo button state
        function updateUndoButton() {
            const undoBtn = document.getElementById('undo-btn');
            if (undoBtn) {
                if (historyStack.length > 0) {
                    undoBtn.disabled = false;
                    undoBtn.style.opacity = '1';
                    const lastAction = historyStack[historyStack.length - 1].action;
                    undoBtn.title = `Undo: ${lastAction}`;
                } else {
                    undoBtn.disabled = true;
                    undoBtn.style.opacity = '0.5';
                    undoBtn.title = 'Nothing to undo';
                }
            }
        }

        // Toast notification for undo
        function showToast(message) {
            // Remove existing toast if any
            const existingToast = document.getElementById('undo-toast');
            if (existingToast) {
                existingToast.remove();
            }

            // Create toast
            const toast = document.createElement('div');
            toast.id = 'undo-toast';
            toast.style.cssText = `
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.85);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                animation: slideUp 0.3s ease-out;
            `;
            toast.textContent = message;

            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideUp {
                    from {
                        opacity: 0;
                        transform: translateX(-50%) translateY(20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(toast);

            // Auto-remove after 2 seconds
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        // Attach undo button handler
        const undoBtnEl = document.getElementById('undo-btn');
        if (undoBtnEl) {
            undoBtnEl.addEventListener('click', undo);
        }

        // Keyboard shortcut for undo (Ctrl+Z / Cmd+Z)
        document.addEventListener('keydown', (e) => {
            // Check for Ctrl+Z (Windows/Linux) or Cmd+Z (Mac)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                // Don't trigger undo if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle undo in text fields
                }

                e.preventDefault();
                undo();
            }

            // Check for Ctrl+S (Windows/Linux) or Cmd+S (Mac) - Save shortcut
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                // Don't trigger save if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle save in text fields if needed
                }

                e.preventDefault();
                console.log('âŒ¨ï¸ Ctrl+S pressed - triggering manual save');
                if (typeof treeManager !== 'undefined') {
                    treeManager.save(capexTree, { forceSaveAs: false });
                } else {
                    console.warn('TreeManager not initialized yet');
                }
            }

            // Check for Ctrl+A (Windows/Linux) or Cmd+A (Mac) - Select all nodes in Canvas View
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                // Only work in Canvas View and not when typing in text fields
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle Ctrl+A in text fields
                }

                // Only work in Canvas View
                if (currentView === 'canvas' && canvasNodes.length > 0) {
                    e.preventDefault();
                    console.log('âŒ¨ï¸ Ctrl+A pressed - selecting all visible nodes');

                    // Clear current selection
                    selectedNodes = [];

                    // Select all visible canvas nodes
                    canvasNodes.forEach(nodeObj => {
                        const node = nodeObj.data;
                        const nodeEl = nodeObj.element;

                        if (node.canvasX !== undefined && node.canvasY !== undefined) {
                            selectedNodes.push(node);
                            nodeEl.classList.add('selected');
                        }
                    });

                    updateSelectionCounter();
                    console.log(`Selected ${selectedNodes.length} nodes`);
                }
            }

            // Check for Escape - Clear selection in Canvas View
            if (e.key === 'Escape') {
                // Only work in Canvas View
                if (currentView === 'canvas' && selectedNodes.length > 0) {
                    console.log('âŒ¨ï¸ Escape pressed - clearing selection');
                    clearSelection();
                }
            }
        });

        // =============================================================================
        // END UNDO/REDO SYSTEM
        // =============================================================================

// TREEPLEXITY PATTERN SELECTOR
// Insert this code into treelisty.html

// ============================================================================
// PATTERN DEFINITIONS
// ============================================================================

const PATTERNS = {
    generic: {
        name: 'Generic Project',
        icon: 'ðŸ“‹',
        levels: {
            root: 'Project',
            phase: 'Phase',
            item: 'Item',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Seed', 'Seed', 'Build'],
        types: [
            { value: 'land', label: 'Land' },
            { value: 'engineering', label: 'Engineering' },
            { value: 'equipment', label: 'Equipment' },
            { value: 'infrastructure', label: 'Infrastructure' },
            { value: 'corporate', label: 'Corporate' },
            { value: 'professional', label: 'Professional' },
            { value: 'contingency', label: 'Contingency' }
        ],
        description: 'Universal structure for any project',
        sortOptions: [
            { value: 'cost-high', label: 'ðŸ’° Cost (Highest First)', field: 'cost', order: 'desc', type: 'number' },
            { value: 'cost-low', label: 'ðŸ’° Cost (Lowest First)', field: 'cost', order: 'asc', type: 'number' },
            { value: 'leadtime-soonest', label: 'â±ï¸ Lead Time (Soonest First)', field: 'leadTime', order: 'asc', type: 'leadtime' },
            { value: 'leadtime-latest', label: 'â±ï¸ Lead Time (Latest First)', field: 'leadTime', order: 'desc', type: 'leadtime' },
            { value: 'name-az', label: 'ðŸ”¤ Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ðŸ”¤ Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ],
        fields: {
            cost: { label: 'Cost ($)', type: 'number', step: 1000, helpText: 'ðŸ’° Budget allocated for this item' },
            alternateSource: { label: 'Alternate Source', type: 'text', placeholder: 'Backup vendor, supplier, or alternative solution...', helpText: 'ðŸ“¦ Alternative supplier or backup option for risk mitigation' },
            leadTime: { label: 'Lead Time', type: 'text', placeholder: 'e.g., 12-18 months, 6 weeks, 90 days...', helpText: 'â±ï¸ Expected procurement or delivery timeline' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    sales: {
        name: 'Sales Pipeline',
        icon: 'ðŸ’¼',
        levels: {
            root: 'Pipeline',
            phase: 'Quarter',
            item: 'Deal',
            subtask: 'Action'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'inbound', label: 'Inbound Lead' },
            { value: 'outbound', label: 'Outbound Prospect' },
            { value: 'partnership', label: 'Partnership' },
            { value: 'expansion', label: 'Account Expansion' },
            { value: 'renewal', label: 'Renewal' },
            { value: 'upsell', label: 'Upsell' },
            { value: 'cross-sell', label: 'Cross-sell' },
            { value: 'enterprise', label: 'Enterprise Deal' }
        ],
        description: 'Track sales opportunities through quarters',
        sortOptions: [
            { value: 'dealvalue-high', label: 'ðŸ’° Deal Value (Largest First)', field: 'dealValue', order: 'desc', type: 'number' },
            { value: 'dealvalue-low', label: 'ðŸ’° Deal Value (Smallest First)', field: 'dealValue', order: 'asc', type: 'number' },
            { value: 'closedate-soonest', label: 'ðŸ“… Close Date (Soonest First)', field: 'expectedCloseDate', order: 'asc', type: 'date' },
            { value: 'closedate-latest', label: 'ðŸ“… Close Date (Latest First)', field: 'expectedCloseDate', order: 'desc', type: 'date' },
            { value: 'probability-high', label: 'ðŸ“Š Probability (Highest First)', field: 'stageProbability', order: 'desc', type: 'number' },
            { value: 'probability-low', label: 'ðŸ“Š Probability (Lowest First)', field: 'stageProbability', order: 'asc', type: 'number' },
            { value: 'name-az', label: 'ðŸ”¤ Deal Name (A-Z)', field: 'name', order: 'asc', type: 'text' }
        ],
        fields: {
            dealValue: { label: 'Deal Value ($)', type: 'number', step: 1000, helpText: 'ðŸ’° Potential revenue from this deal' },
            expectedCloseDate: { label: 'Expected Close Date', type: 'date', helpText: 'ðŸ“… Target date to close this deal' },
            leadSource: { label: 'Lead Source', type: 'text', placeholder: 'Inbound, Referral, Cold Outreach...', helpText: 'ðŸ“ How did this lead originate?' },
            contactPerson: { label: 'Contact Person', type: 'text', placeholder: 'Primary contact name...', helpText: 'ðŸ‘¤ Main decision maker or champion' },
            stageProbability: { label: 'Stage Probability (%)', type: 'number', min: 0, max: 100, step: 5, helpText: 'ðŸ“Š Likelihood of closing this deal' },
            competitorInfo: { label: 'Competitor Info', type: 'textarea', placeholder: 'Who else is competing for this deal...', helpText: 'ðŸŽ¯ Other vendors in consideration' },
            includeDependencies: false,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    thesis: {
        name: 'Academic Writing',
        icon: 'ðŸŽ“',
        levels: {
            root: 'Thesis',
            phase: 'Chapter',
            item: 'Section',
            subtask: 'Point'
        },
        phaseSubtitles: ['Introduction', 'Body', 'Conclusion'],
        types: [
            { value: 'literature-review', label: 'Literature Review' },
            { value: 'methodology', label: 'Methodology' },
            { value: 'analysis', label: 'Analysis' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'theory', label: 'Theoretical Framework' },
            { value: 'evidence', label: 'Evidence' },
            { value: 'argument', label: 'Argument' },
            { value: 'conclusion', label: 'Conclusion' }
        ],
        description: 'Structure academic papers and dissertations',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'ðŸ“ Current word count for this section' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'ðŸŽ¯ Goal word count for this section' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: 'âœï¸ Current revision stage' },
            citations: { label: 'Key Citations', type: 'textarea', placeholder: 'List main sources and references...', helpText: 'ðŸ“š Important sources for this section' },
            keyArgument: { label: 'Key Argument', type: 'textarea', placeholder: 'Main point of this section...', helpText: 'ðŸ’¡ Central claim or thesis' },
            evidenceType: { label: 'Evidence Type', type: 'select', options: ['Empirical', 'Theoretical', 'Mixed', 'N/A'], helpText: 'ðŸ”¬ Nature of supporting evidence' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    roadmap: {
        name: 'Product Roadmap',
        icon: 'ðŸš€',
        levels: {
            root: 'Product',
            phase: 'Quarter',
            item: 'Feature',
            subtask: 'Story'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'core-feature', label: 'Core Feature' },
            { value: 'enhancement', label: 'Enhancement' },
            { value: 'bug-fix', label: 'Bug Fix' },
            { value: 'technical-debt', label: 'Technical Debt' },
            { value: 'research', label: 'Research/Spike' },
            { value: 'platform', label: 'Platform' },
            { value: 'integration', label: 'Integration' },
            { value: 'ux', label: 'UX Improvement' }
        ],
        description: 'Plan product features across quarters',
        fields: {
            storyPoints: { label: 'Story Points', type: 'number', min: 0, step: 1, placeholder: '1, 2, 3, 5, 8, 13...', helpText: 'ðŸŽ¯ Effort estimate (Fibonacci scale)' },
            engineeringEstimate: { label: 'Engineering Estimate', type: 'text', placeholder: '2 weeks, 1 sprint, 3 days...', helpText: 'â±ï¸ Time estimate from engineering' },
            userImpact: { label: 'User Impact', type: 'select', options: ['High', 'Medium', 'Low'], helpText: 'ðŸ‘¥ How many users does this affect?' },
            technicalRisk: { label: 'Technical Risk', type: 'select', options: ['Low', 'Medium', 'High', 'Unknown'], helpText: 'âš ï¸ Complexity and technical uncertainty' },
            featureFlag: { label: 'Feature Flag', type: 'text', placeholder: 'flag_name...', helpText: 'ðŸš© Feature flag for gradual rollout' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    book: {
        name: 'Book Writing',
        icon: 'ðŸ“š',
        levels: {
            root: 'Book',
            phase: 'Part',
            item: 'Chapter',
            subtask: 'Scene'
        },
        phaseSubtitles: ['Act I', 'Act II', 'Act III'],
        types: [
            { value: 'narrative', label: 'Narrative' },
            { value: 'dialogue', label: 'Dialogue' },
            { value: 'description', label: 'Description' },
            { value: 'action', label: 'Action' },
            { value: 'reflection', label: 'Reflection' },
            { value: 'transition', label: 'Transition' },
            { value: 'climax', label: 'Climax' },
            { value: 'exposition', label: 'Exposition' }
        ],
        description: 'Organize books into parts, chapters, and scenes',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'ðŸ“ Current word count' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'ðŸŽ¯ Goal word count' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: 'âœï¸ Current revision stage' },
            povCharacter: { label: 'POV Character', type: 'text', placeholder: 'Whose perspective...', helpText: 'ðŸ‘¤ Point-of-view character' },
            sceneSetting: { label: 'Scene Setting', type: 'textarea', placeholder: 'Location, time, mood...', helpText: 'ðŸŽ­ Where and when this takes place' },
            plotFunction: { label: 'Plot Function', type: 'select', options: ['Setup', 'Conflict', 'Resolution', 'Transition'], helpText: 'ðŸ“– Role in story structure' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    event: {
        name: 'Event Planning',
        icon: 'ðŸŽ‰',
        levels: {
            root: 'Event',
            phase: 'Stage',
            item: 'Activity',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Event', 'Event Day', 'Post-Event'],
        types: [
            { value: 'logistics', label: 'Logistics' },
            { value: 'catering', label: 'Catering' },
            { value: 'entertainment', label: 'Entertainment' },
            { value: 'venue', label: 'Venue' },
            { value: 'marketing', label: 'Marketing' },
            { value: 'registration', label: 'Registration' },
            { value: 'follow-up', label: 'Follow-up' },
            { value: 'av-tech', label: 'AV/Tech' }
        ],
        description: 'Plan events from prep to execution to follow-up',
        fields: {
            budget: { label: 'Budget ($)', type: 'number', step: 100, helpText: 'ðŸ’° Budget for this activity' },
            vendor: { label: 'Vendor/Supplier', type: 'text', placeholder: 'Company or person name...', helpText: 'ðŸ¢ External vendor or supplier' },
            bookingDeadline: { label: 'Booking Deadline', type: 'date', helpText: 'ðŸ“… Last date to book/reserve' },
            guestCount: { label: 'Guest Count', type: 'number', min: 0, placeholder: 'Expected attendees...', helpText: 'ðŸ‘¥ Number of expected guests' },
            location: { label: 'Location', type: 'text', placeholder: 'Venue, room, area...', helpText: 'ðŸ“ Where this takes place' },
            responsiblePerson: { label: 'Responsible Person', type: 'text', placeholder: 'Team member name...', helpText: 'ðŸ‘¤ Who\'s handling this' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    fitness: {
        name: 'Fitness Program',
        icon: 'ðŸ’ª',
        levels: {
            root: 'Program',
            phase: 'Phase',
            item: 'Workout',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Foundation', 'Build', 'Peak'],
        types: [
            { value: 'strength', label: 'Strength Training' },
            { value: 'cardio', label: 'Cardio' },
            { value: 'flexibility', label: 'Flexibility' },
            { value: 'recovery', label: 'Recovery' },
            { value: 'nutrition', label: 'Nutrition' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'conditioning', label: 'Conditioning' },
            { value: 'mobility', label: 'Mobility' }
        ],
        description: 'Structure training programs with periodization',
        fields: {
            sets: { label: 'Sets', type: 'number', min: 0, step: 1, placeholder: 'Number of sets...', helpText: 'ðŸ”¢ Number of sets' },
            reps: { label: 'Reps', type: 'text', placeholder: '8-12, 10, AMRAP...', helpText: 'ðŸ” Repetitions per set' },
            duration: { label: 'Duration', type: 'text', placeholder: '30 minutes, 45 sec...', helpText: 'â±ï¸ Time for this exercise/workout' },
            intensity: { label: 'Intensity Level', type: 'select', options: ['Light', 'Moderate', 'High', 'Max'], helpText: 'ðŸ”¥ Effort level' },
            equipment: { label: 'Equipment Needed', type: 'text', placeholder: 'Dumbbells, Barbell, Bodyweight...', helpText: 'ðŸ‹ï¸ Required equipment' },
            formCues: { label: 'Form Cues', type: 'textarea', placeholder: 'Key technique reminders...', helpText: 'âœ… Important form tips' },
            restPeriod: { label: 'Rest Period', type: 'text', placeholder: '60 sec, 2 min...', helpText: 'â¸ï¸ Rest between sets' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    strategy: {
        name: 'Strategic Plan',
        icon: 'ðŸ“Š',
        levels: {
            root: 'Strategy',
            phase: 'Pillar',
            item: 'Initiative',
            subtask: 'Action'
        },
        phaseSubtitles: ['Planning', 'Execution', 'Review'],
        types: [
            { value: 'market-expansion', label: 'Market Expansion' },
            { value: 'operational', label: 'Operational Excellence' },
            { value: 'financial', label: 'Financial' },
            { value: 'hr', label: 'Human Resources' },
            { value: 'technology', label: 'Technology' },
            { value: 'risk-management', label: 'Risk Management' },
            { value: 'innovation', label: 'Innovation' },
            { value: 'customer', label: 'Customer Experience' }
        ],
        description: 'Organize business strategy into pillars and initiatives',
        fields: {
            investment: { label: 'Investment ($)', type: 'number', step: 10000, helpText: 'ðŸ’° Capital investment required' },
            keyMetric: { label: 'Key Metric', type: 'text', placeholder: 'What defines success...', helpText: 'ðŸ“Š Success measurement' },
            targetValue: { label: 'Target Value', type: 'text', placeholder: 'Goal for metric...', helpText: 'ðŸŽ¯ Goal to achieve' },
            responsibleExecutive: { label: 'Responsible Executive', type: 'text', placeholder: 'C-level owner...', helpText: 'ðŸ‘” Executive sponsor' },
            strategicTheme: { label: 'Strategic Theme', type: 'select', options: ['Growth', 'Efficiency', 'Innovation', 'Transformation', 'Risk Mitigation'], helpText: 'ðŸŽ­ Strategic category' },
            riskLevel: { label: 'Risk Level', type: 'select', options: ['Low', 'Medium', 'High'], helpText: 'âš ï¸ Implementation risk' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    course: {
        name: 'Course Design',
        icon: 'ðŸ“–',
        levels: {
            root: 'Course',
            phase: 'Unit',
            item: 'Lesson',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Beginning', 'Middle', 'Advanced'],
        types: [
            { value: 'lecture', label: 'Lecture' },
            { value: 'lab', label: 'Lab/Practical' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'reading', label: 'Reading' },
            { value: 'project', label: 'Project' },
            { value: 'workshop', label: 'Workshop' },
            { value: 'field-work', label: 'Field Work' }
        ],
        description: 'Build educational curricula with units and lessons',
        fields: {
            learningObjectives: { label: 'Learning Objectives', type: 'textarea', placeholder: 'What students will learn...', helpText: 'ðŸŽ“ Expected learning outcomes' },
            duration: { label: 'Duration', type: 'text', placeholder: '50 minutes, 2 hours...', helpText: 'â±ï¸ Class time needed' },
            difficultyLevel: { label: 'Difficulty Level', type: 'select', options: ['Beginner', 'Intermediate', 'Advanced'], helpText: 'ðŸ“Š Complexity level' },
            prerequisites: { label: 'Prerequisites', type: 'textarea', placeholder: 'Prior knowledge needed...', helpText: 'ðŸ“‹ Required background' },
            assessmentType: { label: 'Assessment Type', type: 'select', options: ['Quiz', 'Assignment', 'Project', 'Discussion', 'Exam', 'None'], helpText: 'âœ… How learning is evaluated' },
            resourcesNeeded: { label: 'Resources Needed', type: 'textarea', placeholder: 'Textbook chapters, videos, materials...', helpText: 'ðŸ“š Required materials' },
            homework: { label: 'Homework', type: 'textarea', placeholder: 'Out-of-class work...', helpText: 'ðŸ“ Assignments for students' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    film: {
        name: 'AI Video Production',
        icon: 'ðŸŽ¬',
        levels: {
            root: 'Film',
            phase: 'Act',
            item: 'Scene',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Act I - Setup', 'Act II - Conflict', 'Act III - Resolution'],
        types: [
            { value: 'establishing', label: 'Establishing Shot' },
            { value: 'character-intro', label: 'Character Introduction' },
            { value: 'dialogue', label: 'Dialogue Scene' },
            { value: 'action', label: 'Action Sequence' },
            { value: 'montage', label: 'Montage' },
            { value: 'transition', label: 'Transition' },
            { value: 'climax', label: 'Climax' },
            { value: 'resolution', label: 'Resolution' }
        ],
        description: 'Create films using AI video generation (Sora, Veo, Runway, Pika)',
        fields: {
            aiPlatform: { label: 'AI Platform', type: 'select', options: ['Sora (OpenAI)', 'Veo 3 (Google)', 'Runway Gen-3', 'Pika 2.0', 'Kling AI', 'Luma Dream Machine', 'Haiper', 'Testing Multiple'], helpText: 'ðŸ¤– Which AI video model to use' },
            videoPrompt: { label: 'Video Prompt', type: 'textarea', placeholder: 'Detailed text-to-video prompt...', helpText: 'âœï¸ Primary prompt describing the scene (be specific: camera movement, lighting, mood, action)' },
            visualStyle: { label: 'Visual Style', type: 'select', options: ['Photorealistic', 'Cinematic', 'Documentary', 'Anime', 'Pixar 3D', 'Stop Motion', 'Vintage Film', 'Noir', 'Sci-Fi', 'Fantasy'], helpText: 'ðŸŽ¨ Overall aesthetic and look' },
            duration: { label: 'Duration', type: 'select', options: ['2 seconds', '4 seconds', '6 seconds', '10 seconds', '20 seconds', 'Extended (loop)'], helpText: 'â±ï¸ Video clip length' },
            aspectRatio: { label: 'Aspect Ratio', type: 'select', options: ['16:9 (Widescreen)', '9:16 (Vertical/Mobile)', '1:1 (Square)', '2.39:1 (Cinematic)', '4:3 (Classic)'], helpText: 'ðŸ“ Video dimensions for target platform' },
            cameraMovement: { label: 'Camera Movement', type: 'select', options: ['Static', 'Slow Pan', 'Dolly In', 'Dolly Out', 'Tracking Shot', 'Crane Up', 'Crane Down', 'Handheld', 'Orbiting'], helpText: 'ðŸŽ¥ How camera moves through scene' },
            motionIntensity: { label: 'Motion Intensity', type: 'select', options: ['Minimal', 'Subtle', 'Moderate', 'Dynamic', 'Intense'], helpText: 'ðŸŒŠ Amount of movement and action' },
            lightingMood: { label: 'Lighting Mood', type: 'select', options: ['Golden Hour', 'Overcast', 'Night', 'Neon', 'Dramatic', 'Soft Natural', 'High Contrast', 'Backlit'], helpText: 'ðŸ’¡ Lighting setup and atmosphere' },
            iterationNotes: { label: 'Generation Notes', type: 'textarea', placeholder: 'Prompt refinements, variations tried, best practices learned...', helpText: 'ðŸ“ What worked, what didn\'t, prompt engineering insights' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        },
        sortOptions: [
            { value: 'visualstyle', label: 'ðŸŽ¨ Visual Style', field: 'visualStyle', order: 'asc', type: 'text' },
            { value: 'lightingmood', label: 'ðŸ’¡ Lighting Mood', field: 'lightingMood', order: 'asc', type: 'text' },
            { value: 'cameramovement', label: 'ðŸŽ¥ Camera Movement', field: 'cameraMovement', order: 'asc', type: 'text' },
            { value: 'aiplatform', label: 'ðŸ¤– AI Platform', field: 'aiPlatform', order: 'asc', type: 'text' },
            { value: 'duration', label: 'â±ï¸ Duration', field: 'duration', order: 'asc', type: 'text' },
            { value: 'name-az', label: 'ðŸ”¤ Scene Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ðŸ”¤ Scene Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ]
    },
    veo3: {
        name: 'Veo3 (Google)',
        icon: 'ðŸŽ¥',
        levels: {
            root: 'Project',
            phase: 'Sequence',
            item: 'Scene',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Opening Sequence', 'Development', 'Climax Sequence'],
        types: [
            { value: 'ingredients', label: 'Ingredients to Video' },
            { value: 'frames', label: 'Frames to Video' },
            { value: 'extend', label: 'Extend Video' },
            { value: 'standard', label: 'Standard Generation' }
        ],
        description: 'Google Veo 3.1 AI video generation with Flow workflow',
        fields: {
            flowMode: { label: 'Flow Mode', type: 'select', options: ['Ingredients to Video', 'Frames to Video', 'Extend', 'Standard'], helpText: 'ðŸŽ¬ Veo 3 generation mode (ingredients, frame bridging, or extension)' },
            videoPrompt: { label: 'Video Prompt', type: 'textarea', placeholder: 'Detailed text-to-video prompt...', helpText: 'âœï¸ Primary prompt for Veo 3 generation' },
            ingredientImages: { label: 'Ingredient Images', type: 'textarea', placeholder: 'URLs of reference images (character, objects, style)...', helpText: 'ðŸ–¼ï¸ Reference images for character/object/style control (Ingredients mode)' },
            startFrame: { label: 'Start Frame', type: 'text', placeholder: 'URL or ID...', helpText: 'ðŸŽžï¸ Starting frame for frame bridging (Frames mode)' },
            endFrame: { label: 'End Frame', type: 'text', placeholder: 'URL or ID...', helpText: 'ðŸŽžï¸ Ending frame for frame bridging (Frames mode)' },
            extendDuration: { label: 'Extend Duration', type: 'select', options: ['10 seconds', '20 seconds', '30 seconds', '60+ seconds'], helpText: 'â±ï¸ Target duration for extended video (Extend mode)' },
            duration: { label: 'Duration', type: 'select', options: ['4 seconds', '6 seconds', '8 seconds'], helpText: 'â±ï¸ Standard Veo 3 durations @ 24 FPS' },
            resolution: { label: 'Resolution', type: 'select', options: ['720p', '1080p'], helpText: 'ðŸ“º Output resolution' },
            audioType: { label: 'Audio Type', type: 'select', options: ['Dialogue', 'Sound Effects', 'Ambience', 'Mixed', 'Silent'], helpText: 'ðŸ”Š Native audio generation type' },
            cinematicStyle: { label: 'Cinematic Style', type: 'select', options: ['Realistic', 'Dramatic', 'Documentary', 'Commercial', 'Artistic', 'Music Video'], helpText: 'ðŸŽ­ Veo 3 cinematic style understanding' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    sora2: {
        name: 'Sora2 (OpenAI)',
        icon: 'ðŸŽ¬',
        levels: {
            root: 'Project',
            phase: 'Sequence',
            item: 'Beat',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Setup', 'Conflict', 'Resolution'],
        types: [
            { value: 'cameo', label: 'Cameo Shot' },
            { value: 'remix', label: 'Remix Variant' },
            { value: 'standard', label: 'Standard Generation' },
            { value: 'physics-complex', label: 'Complex Physics' }
        ],
        description: 'OpenAI Sora 2 AI video generation with cameo and remix capabilities',
        fields: {
            videoPrompt: { label: 'Video Prompt', type: 'textarea', placeholder: 'Detailed text-to-video prompt for Sora 2...', helpText: 'âœï¸ Primary prompt for Sora 2 generation (physics-aware)' },
            beatType: { label: 'Beat Type', type: 'select', options: ['Setup', 'Conflict', 'Transition', 'Resolution', 'Character Moment'], helpText: 'ðŸŽ¯ Narrative beat purpose in storyboard' },
            cameoUsed: { label: 'Uses Cameo', type: 'select', options: ['None', 'Cameo ID 1', 'Cameo ID 2', 'Cameo ID 3'], helpText: 'ðŸ‘¤ Insert pre-recorded cameo (person/object) into scene' },
            remixSource: { label: 'Remix Source', type: 'text', placeholder: 'Source shot ID...', helpText: 'ðŸ”„ Source shot for remix/modification (instead of full regeneration)' },
            physicsComplexity: { label: 'Physics Complexity', type: 'select', options: ['Simple', 'Medium', 'Complex (Gymnastics/Water/Ballistics)'], helpText: 'âš¡ Physics accuracy level needed' },
            duration: { label: 'Duration', type: 'select', options: ['4 seconds', '8 seconds', '12 seconds'], helpText: 'â±ï¸ Sora 2 Pro fixed durations' },
            resolution: { label: 'Resolution', type: 'select', options: ['720p', '1080p'], helpText: 'ðŸ“º Output resolution for cinematic quality' },
            nleExportFormat: { label: 'NLE Export', type: 'select', options: ['Premiere Pro', 'Final Cut Pro', 'DaVinci Resolve', 'After Effects', 'Raw Files'], helpText: 'ðŸ“¤ Post-production NLE format' },
            audioSync: { label: 'Audio Sync', type: 'select', options: ['Synchronized Dialogue', 'Sound Effects', 'Background Score', 'Silent'], helpText: 'ðŸŽµ Sora 2 synchronized audio generation' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    philosophy: {
        name: 'Philosophy',
        icon: 'ðŸ¤”',
        levels: {
            root: 'Dialogue',
            phase: 'Movement',
            item: 'Claim',
            subtask: 'Support'
        },
        phaseSubtitles: ['Opening Question', 'First Definition', 'Refutation', 'Second Attempt', 'Deeper Inquiry', 'Resolution'],
        types: [
            // Dialectical moves
            { value: 'question', label: 'â“ Question' },
            { value: 'definition', label: 'ðŸ“ Definition' },
            { value: 'refutation', label: 'âŒ Refutation/Elenchus' },
            { value: 'premise', label: 'ðŸ“ Premise' },
            { value: 'conclusion', label: 'âœ“ Conclusion' },
            { value: 'objection', label: 'âš ï¸ Objection' },
            { value: 'response', label: 'ðŸ’¬ Response' },
            { value: 'example', label: 'ðŸ“– Example' },
            { value: 'analogy', label: 'ðŸ”„ Analogy' },
            { value: 'distinction', label: 'âš–ï¸ Distinction' },
            { value: 'paradox', label: 'ðŸŒ€ Paradox' },
            { value: 'thought-experiment', label: 'ðŸ’­ Thought Experiment' },
            { value: 'aporia', label: 'ðŸ¤· Aporia (Impasse)' },
            // Philosophical domains
            { value: 'metaphysical', label: 'ðŸŒŒ Metaphysical' },
            { value: 'epistemological', label: 'ðŸ§  Epistemological' },
            { value: 'ethical', label: 'âš–ï¸ Ethical' },
            { value: 'political', label: 'ðŸ›ï¸ Political' },
            { value: 'logical', label: 'ðŸ”¢ Logical' }
        ],
        description: 'Structure philosophical dialogues, treatises, and arguments with dialectical precision',
        fields: {
            speaker: { label: 'Speaker', type: 'text', placeholder: 'Socrates, Meno, etc...', helpText: 'ðŸ—£ï¸ Who makes this claim or argument' },
            argumentType: { label: 'Argument Type', type: 'select', options: ['Deductive', 'Inductive', 'Abductive', 'Dialectical', 'Reductio ad Absurdum', 'Socratic Elenchus'], helpText: 'ðŸŽ¯ Type of reasoning employed' },
            validity: { label: 'Logical Validity', type: 'select', options: ['Valid', 'Invalid', 'Sound', 'Unsound', 'Uncertain'], helpText: 'âœ“ Logical soundness' },
            keyTerms: { label: 'Key Terms', type: 'text', placeholder: 'virtue, knowledge, piety...', helpText: 'ðŸ“ Central concepts defined or discussed' },
            premise1: { label: 'Premise 1', type: 'textarea', placeholder: 'First premise of argument...', helpText: '1ï¸âƒ£ First assumption or claim' },
            premise2: { label: 'Premise 2', type: 'textarea', placeholder: 'Second premise...', helpText: '2ï¸âƒ£ Second assumption or claim' },
            conclusion: { label: 'Conclusion', type: 'textarea', placeholder: 'What follows from premises...', helpText: 'âœ“ Logical conclusion' },
            objection: { label: 'Objection', type: 'textarea', placeholder: 'Main counterargument...', helpText: 'âŒ Key objection raised' },
            response: { label: 'Response to Objection', type: 'textarea', placeholder: 'How objection is addressed...', helpText: 'ðŸ’¡ Defense or reply to objection' },
            textualReference: { label: 'Textual Reference', type: 'text', placeholder: 'e.g., Meno 70a-72c, Republic 347c...', helpText: 'ðŸ“– Stephanus number or page reference' },
            philosophicalSchool: { label: 'School of Thought', type: 'select', options: ['Pre-Socratic', 'Platonic', 'Aristotelian', 'Stoic', 'Epicurean', 'Skeptic', 'Medieval', 'Rationalist', 'Empiricist', 'Kantian', 'Hegelian', 'Phenomenological', 'Analytic', 'Continental', 'Pragmatist', 'Other'], helpText: 'ðŸ›ï¸ Philosophical tradition or school' },
            includeDependencies: true,
            includeTracking: false
        },
        sortOptions: [
            { value: 'speaker-az', label: 'ðŸ—£ï¸ Speaker (A-Z)', field: 'speaker', order: 'asc', type: 'text' },
            { value: 'speaker-za', label: 'ðŸ—£ï¸ Speaker (Z-A)', field: 'speaker', order: 'desc', type: 'text' },
            { value: 'argumenttype', label: 'ðŸŽ¯ Argument Type', field: 'argumentType', order: 'asc', type: 'text' },
            { value: 'validity', label: 'âœ“ Logical Validity', field: 'validity', order: 'asc', type: 'text' },
            { value: 'school', label: 'ðŸ›ï¸ Philosophical School', field: 'philosophicalSchool', order: 'asc', type: 'text' },
            { value: 'name-az', label: 'ðŸ”¤ Claim Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ðŸ”¤ Claim Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ]
    },
    prompting: {
        name: 'Prompt Engineering',
        icon: 'ðŸ§ ',
        levels: {
            root: 'Prompt Library',
            phase: 'Category',
            item: 'Prompt',
            subtask: 'Test Case'
        },
        phaseSubtitles: ['Customer Support', 'Content Generation', 'Data Analysis', 'Code Assistance', 'Research', 'Creative Writing'],
        types: [
            { value: 'task-instruction', label: 'ðŸ’¬ Task Instruction' },
            { value: 'few-shot', label: 'ðŸ“š Few-Shot Examples' },
            { value: 'chain-of-thought', label: 'ðŸ§  Chain-of-Thought' },
            { value: 'structured-output', label: 'ðŸ“ Structured Output' },
            { value: 'xml-guided', label: 'ðŸ—ï¸ XML-Guided (Anthropic)' },
            { value: 'prefill-guided', label: 'ðŸŽ¯ Prefill-Guided (Claude)' },
            { value: 'production', label: 'âœ… Production-Ready' },
            { value: 'experimental', label: 'ðŸ§ª Experimental' }
        ],
        description: 'Design and test AI prompts with best practices from OpenAI and Anthropic',
        fields: {
            systemPrompt: {
                label: 'System Prompt (Required)',
                type: 'textarea',
                placeholder: 'You are an expert customer support agent with 10 years of experience. You are helpful, empathetic, and solution-focused. Always maintain a professional yet friendly tone.',
                helpText: 'ðŸ‘¤ Define the AI\'s role, expertise, and behavior. This sets the foundation for all responses.'
            },
            userPromptTemplate: {
                label: 'User Prompt (Required)',
                type: 'textarea',
                placeholder: 'Analyze the following customer support ticket and provide a recommended response:\n\nTicket: {{ticket_text}}\nPriority: {{priority}}\nCustomer Tier: {{tier}}\n\nProvide:\n1. Issue summary\n2. Recommended resolution\n3. Escalation needed (yes/no)',
                helpText: 'ðŸ’¬ The main instruction telling the AI what to do. Use {{variables}} for dynamic content.'
            },
            fewShotExamples: {
                label: 'Examples (Recommended)',
                type: 'textarea',
                placeholder: '<example>\nInput: Customer reports login issue on mobile app\nOutput: {\n  "summary": "Authentication failure on iOS app",\n  "resolution": "Clear app cache and reinstall",\n  "escalate": "no"\n}\n</example>\n\n<example>\nInput: Customer requests refund for annual subscription\nOutput: {\n  "summary": "Refund request - annual plan",\n  "resolution": "Process pro-rated refund per policy",\n  "escalate": "yes"\n}\n</example>',
                helpText: 'ðŸ“š Show 2-3 examples of input â†’ output. This dramatically improves accuracy and consistency.'
            },
            outputFormat: {
                label: 'Output Format (Recommended)',
                type: 'textarea',
                placeholder: 'Return your response as JSON with this exact structure:\n{\n  "summary": "brief issue description",\n  "resolution": "recommended action",\n  "escalate": "yes or no"\n}',
                helpText: 'ðŸ“ Specify exactly how you want the output structured (JSON, markdown, bullet points, etc.)'
            },
            chainOfThought: {
                label: 'Chain-of-Thought (Optional)',
                type: 'textarea',
                placeholder: 'Before providing your answer, think through this step-by-step:\n1. What is the core issue?\n2. What are possible solutions?\n3. Which solution is best and why?',
                helpText: 'ðŸ§  Ask the AI to "think out loud" before answering. Improves reasoning quality.'
            },
            modelTarget: {
                label: 'Target Model',
                type: 'select',
                options: ['Claude 3.5 Sonnet', 'Claude 3 Opus', 'GPT-4o', 'GPT-4 Turbo', 'o1-preview'],
                helpText: 'ðŸ¤– Which AI model this prompt is optimized for'
            },
            temperature: {
                label: 'Temperature',
                type: 'number',
                min: 0,
                max: 1,
                step: 0.1,
                placeholder: '0.7',
                helpText: 'ðŸŒ¡ï¸ 0 = consistent/factual, 1 = creative/varied. Use 0-0.3 for analysis, 0.7-1.0 for creative writing.'
            },
            testResults: {
                label: 'Test Results',
                type: 'textarea',
                placeholder: 'Tested on 50 examples:\nâœ… 94% accuracy\nâš¡ Avg response time: 1.3s\nðŸ’° Cost per request: $0.015',
                helpText: 'âœ… Track how well this prompt performs on real test cases'
            },
            testStatus: {
                label: 'Status',
                type: 'select',
                options: ['Draft', 'Testing', 'Validated', 'Production', 'Deprecated'],
                helpText: 'âœ… Development stage'
            },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    familytree: {
        name: 'Family Tree',
        icon: 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦',
        levels: {
            root: 'Family',
            phase: 'Generation',
            item: 'Person',
            subtask: 'Event'
        },
        phaseSubtitles: ['Self/Siblings', 'Parents', 'Grandparents', 'Great-Grandparents', 'Great-Great-Grandparents', 'Children', 'Grandchildren', 'Great-Grandchildren'],
        types: [
            { value: 'paternal', label: 'Paternal Line' },
            { value: 'maternal', label: 'Maternal Line' },
            { value: 'spouse', label: 'Spouse' },
            { value: 'biological', label: 'Biological' },
            { value: 'adopted', label: 'Adopted' },
            { value: 'step', label: 'Step-Family' },
            { value: 'foster', label: 'Foster' },
            { value: 'half', label: 'Half-Sibling' }
        ],
        description: 'Build and document your family genealogy',
        fields: {
            fullName: { label: 'Full Name', type: 'text', placeholder: 'First Middle Last...', helpText: 'ðŸ‘¤ Complete name including middle names' },
            maidenName: { label: 'Maiden Name', type: 'text', placeholder: 'Birth surname if different...', helpText: 'ðŸ’ Birth surname (if changed after marriage)' },
            gender: { label: 'Gender', type: 'select', options: ['Male', 'Female', 'Other', 'Unknown'], helpText: 'âš§ Gender identity' },
            birthDate: { label: 'Birth Date', type: 'date', helpText: 'ðŸŽ‚ Date of birth' },
            birthPlace: { label: 'Birth Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'ðŸ“ Place of birth (city, state, country)' },
            livingStatus: { label: 'Living Status', type: 'select', options: ['Living', 'Deceased', 'Unknown'], helpText: 'ðŸ’š Current living status' },
            deathDate: { label: 'Death Date', type: 'date', helpText: 'ðŸ•Šï¸ Date of death (if deceased)' },
            deathPlace: { label: 'Death Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'ðŸ“ Place of death (if deceased)' },
            marriageDate: { label: 'Marriage Date', type: 'date', helpText: 'ðŸ’’ Date of marriage' },
            marriagePlace: { label: 'Marriage Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'ðŸ“ Place of marriage ceremony' },
            spouseName: { label: 'Spouse Name', type: 'text', placeholder: 'Name of spouse...', helpText: 'ðŸ’‘ Current or former spouse' },
            occupation: { label: 'Occupation', type: 'text', placeholder: 'Profession or career...', helpText: 'ðŸ’¼ Primary occupation or career' },
            photoURL: { label: 'Photo URL', type: 'text', placeholder: 'https://...', helpText: 'ðŸ“· Link to portrait or photo' },
            dnaInfo: { label: 'DNA/Genetic Info', type: 'textarea', placeholder: 'Haplogroup, DNA matches, test results...', helpText: 'ðŸ§¬ DNA test results, haplogroups, genetic markers' },
            sources: { label: 'Sources/Citations', type: 'textarea', placeholder: 'Documents, certificates, records...', helpText: 'ðŸ“„ Birth certificates, census records, documents' },
            relationshipType: { label: 'Relationship Type', type: 'select', options: ['Biological', 'Adopted', 'Step', 'Foster', 'Half-Sibling', 'Unknown'], helpText: 'ðŸ”— Type of family relationship' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    dialogue: {
        name: 'Dialogue & Rhetoric',
        icon: 'ðŸ’¬',
        levels: {
            root: 'Conversation',
            phase: 'Speaker',
            item: 'Statement',
            subtask: 'Point'
        },
        phaseSubtitles: ['Speaker A', 'Speaker B', 'Speaker C', 'Moderator'],
        types: [
            { value: 'logical', label: 'ðŸ§  Logical Argument' },
            { value: 'emotional', label: 'â¤ï¸ Emotional Appeal (Pathos)' },
            { value: 'ethical', label: 'âš–ï¸ Ethical Appeal (Ethos)' },
            { value: 'statistical', label: 'ðŸ“Š Statistical Evidence' },
            { value: 'anecdotal', label: 'ðŸ“– Anecdotal Evidence' },
            { value: 'rhetorical-question', label: 'â“ Rhetorical Question' },
            { value: 'counterargument', label: 'ðŸ”„ Counterargument' },
            { value: 'deflection', label: 'â†©ï¸ Deflection/Dodge' },
            { value: 'concession', label: 'ðŸ¤ Concession/Agreement' }
        ],
        description: 'Analyze conversations, debates, and rhetoric to uncover hidden logic, fallacies, and motivations',
        fields: {
            speaker: {
                label: 'Speaker/Character',
                type: 'text',
                placeholder: 'e.g., Senator Jane Smith, John (protagonist), Anonymous commenter...',
                helpText: 'ðŸ‘¤ Who is making this statement? Include role, title, or context if known'
            },
            verbatimQuote: {
                label: 'Verbatim Quote',
                type: 'textarea',
                placeholder: 'Copy/paste the exact words spoken or written...',
                helpText: 'ðŸ’¬ The actual statement, word-for-word. Essential for accurate analysis of rhetoric and tone'
            },
            rhetoricalDevice: {
                label: 'Rhetorical Device Used',
                type: 'select',
                options: ['Logos (Logic)', 'Pathos (Emotion)', 'Ethos (Credibility)', 'Kairos (Timing)', 'Metaphor', 'Analogy', 'Repetition', 'Hyperbole', 'Irony', 'Appeal to Authority', 'None'],
                helpText: 'ðŸŽ­ Primary rhetorical technique used to persuade or communicate. Identify the dominant device'
            },
            logicalStructure: {
                label: 'Logical Structure',
                type: 'textarea',
                placeholder: 'Premise 1: All experts agree...\nPremise 2: Dr. Chen is an expert...\nConclusion: Therefore, Dr. Chen\'s view is valid',
                helpText: 'ðŸ§© Break down the argument into premises and conclusion. How does the speaker construct their logic?'
            },
            fallaciesPresent: {
                label: 'Fallacies Present',
                type: 'textarea',
                placeholder: 'Ad hominem: Attacks opponent\'s character instead of argument\nStraw man: Misrepresents opponent\'s position...',
                helpText: 'âš ï¸ Identify any logical fallacies (ad hominem, straw man, slippery slope, false dichotomy, etc.) and explain how they appear'
            },
            hiddenMotivation: {
                label: 'Hidden Motivation/Subtext',
                type: 'textarea',
                placeholder: 'Surface: Arguing for policy change\nHidden: Positioning for re-election, deflecting from scandal, protecting financial interests...',
                helpText: 'ðŸ” What unstated goals or motivations might underlie this statement? Consider political, financial, or personal incentives'
            },
            emotionalTone: {
                label: 'Emotional Tone',
                type: 'select',
                options: ['Calm/Neutral', 'Passionate', 'Angry', 'Defensive', 'Condescending', 'Empathetic', 'Dismissive', 'Fearful', 'Confident', 'Sarcastic'],
                helpText: 'ðŸŽ­ The emotional delivery and affect. How does tone enhance or undermine the message?'
            },
            counterargument: {
                label: 'Strongest Counterargument',
                type: 'textarea',
                placeholder: 'The strongest rebuttal would be: "While the speaker claims X, evidence shows Y because..."',
                helpText: 'ðŸ”„ What is the most effective counter to this statement? Build the opposing case using logic and evidence'
            },
            evidenceQuality: {
                label: 'Evidence Quality',
                type: 'select',
                options: ['Strong (Peer-reviewed, verified)', 'Moderate (Credible sources)', 'Weak (Anecdotal, unverified)', 'None (Opinion only)', 'Misleading (Cherry-picked data)'],
                helpText: 'ðŸ“Š Assess the strength and credibility of any evidence or data cited. Is it rigorous or rhetorical?'
            },
            effectivenessRating: {
                label: 'Persuasiveness Rating',
                type: 'number',
                min: 1,
                max: 10,
                step: 1,
                placeholder: '7',
                helpText: 'ðŸŽ¯ Rate 1-10: How persuasive is this statement to the target audience? (1=unconvincing, 10=highly compelling)'
            },
            includeDependencies: true,
            includeTracking: false
        }
    },
    filesystem: {
        name: 'File System',
        icon: 'ðŸ’¾',
        isFlexibleDepth: true,
        levels: {
            root: 'Drive',
            phase: 'Folder',
            item: 'File/Folder',
            subtask: 'File'
        },
        phaseSubtitles: ['Documents', 'Downloads', 'Desktop', 'Pictures', 'Videos', 'Projects'],
        types: [
            // Folder types
            { value: 'folder', label: 'ðŸ“ Folder' },
            { value: 'folder-shared', label: 'ðŸ“‚ Shared Folder' },
            { value: 'folder-cloud', label: 'â˜ï¸ Cloud Folder' },

            // Document types
            { value: 'pdf', label: 'ðŸ“• PDF' },
            { value: 'word', label: 'ðŸ“˜ Word Doc' },
            { value: 'excel', label: 'ðŸ“— Spreadsheet' },
            { value: 'powerpoint', label: 'ðŸ“™ Presentation' },
            { value: 'text', label: 'ðŸ“ Text File' },
            { value: 'document', label: 'ðŸ“„ Document' },

            // Media types
            { value: 'image', label: 'ðŸ–¼ï¸ Image' },
            { value: 'video', label: 'ðŸŽ¬ Video' },
            { value: 'audio', label: 'ðŸŽµ Audio' },

            // Code types
            { value: 'code', label: 'ðŸ’» Code' },
            { value: 'html', label: 'ðŸŒ HTML' },
            { value: 'css', label: 'ðŸŽ¨ CSS' },
            { value: 'javascript', label: 'âš¡ JavaScript' },
            { value: 'python', label: 'ðŸ Python' },

            // Archive types
            { value: 'archive', label: 'ðŸ“¦ Archive' },
            { value: 'zip', label: 'ðŸ—œï¸ ZIP' },

            // Other
            { value: 'executable', label: 'âš™ï¸ Executable' },
            { value: 'database', label: 'ðŸ—„ï¸ Database' },
            { value: 'unknown', label: 'â“ Unknown' }
        ],
        description: 'Organize files and folders from local drives, Google Drive, and OneDrive',
        sortOptions: [
            { value: 'name-az', label: 'ðŸ”¤ Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ðŸ”¤ Name (Z-A)', field: 'name', order: 'desc', type: 'text' },
            { value: 'size-large', label: 'ðŸ“Š Size (Largest First)', field: 'fileSize', order: 'desc', type: 'number' },
            { value: 'size-small', label: 'ðŸ“Š Size (Smallest First)', field: 'fileSize', order: 'asc', type: 'number' },
            { value: 'modified-newest', label: 'ðŸ•’ Modified (Newest First)', field: 'dateModified', order: 'desc', type: 'date' },
            { value: 'modified-oldest', label: 'ðŸ•’ Modified (Oldest First)', field: 'dateModified', order: 'asc', type: 'date' },
            { value: 'created-newest', label: 'ðŸ“… Created (Newest First)', field: 'dateCreated', order: 'desc', type: 'date' },
            { value: 'created-oldest', label: 'ðŸ“… Created (Oldest First)', field: 'dateCreated', order: 'asc', type: 'date' },
            { value: 'type-folders-first', label: 'ðŸ“ Type (Folders First)', field: 'isFolder', order: 'desc', type: 'boolean' },
            { value: 'type-files-first', label: 'ðŸ“„ Type (Files First)', field: 'isFolder', order: 'asc', type: 'boolean' },
            { value: 'extension-az', label: 'ðŸ·ï¸ Extension (A-Z)', field: 'fileExtension', order: 'asc', type: 'text' },
            { value: 'extension-za', label: 'ðŸ·ï¸ Extension (Z-A)', field: 'fileExtension', order: 'desc', type: 'text' },
            { value: 'owner-az', label: 'ðŸ‘¤ Owner (A-Z)', field: 'fileOwner', order: 'asc', type: 'text' },
            { value: 'owner-za', label: 'ðŸ‘¤ Owner (Z-A)', field: 'fileOwner', order: 'desc', type: 'text' }
        ],
        fields: {
            fileSize: {
                label: 'File Size (bytes)',
                type: 'number',
                min: 0,
                step: 1,
                placeholder: '2500000',
                helpText: 'ðŸ“Š Size in bytes (will be formatted as KB/MB/GB)'
            },
            fileExtension: {
                label: 'File Extension',
                type: 'text',
                placeholder: '.pdf, .docx, .jpg...',
                helpText: 'ðŸ·ï¸ File type extension (e.g., .pdf, .docx, .mp4)'
            },
            filePath: {
                label: 'Full Path',
                type: 'text',
                placeholder: 'C:\\Users\\Documents\\file.pdf',
                helpText: 'ðŸ“‚ Complete file path'
            },
            dateModified: {
                label: 'Date Modified',
                type: 'datetime-local',
                helpText: 'ðŸ•’ Last modification date and time'
            },
            dateCreated: {
                label: 'Date Created',
                type: 'datetime-local',
                helpText: 'ðŸ“… Creation date and time'
            },
            fileOwner: {
                label: 'Owner',
                type: 'text',
                placeholder: 'john.doe@company.com',
                helpText: 'ðŸ‘¤ File owner (for cloud files)'
            },
            sharedWith: {
                label: 'Shared With',
                type: 'textarea',
                placeholder: 'user1@email.com, user2@email.com...',
                helpText: 'ðŸ‘¥ Users with access (for cloud files)'
            },
            permissions: {
                label: 'Permissions',
                type: 'select',
                options: ['Read Only', 'Read/Write', 'Owner', 'Viewer', 'Editor', 'Commenter'],
                helpText: 'ðŸ”’ Access permissions'
            },
            driveType: {
                label: 'Drive Type',
                type: 'select',
                options: ['Local Drive', 'Google Drive', 'OneDrive', 'Dropbox', 'Network Drive', 'External Drive'],
                helpText: 'ðŸ’¾ Storage location type'
            },
            mimeType: {
                label: 'MIME Type',
                type: 'text',
                placeholder: 'application/pdf, image/jpeg...',
                helpText: 'ðŸ“‹ File MIME type (for web/cloud files)'
            },
            tags: {
                label: 'Tags',
                type: 'text',
                placeholder: 'work, important, archive...',
                helpText: 'ðŸ·ï¸ Custom tags for organization'
            },
            fileUrl: {
                label: 'Cloud URL',
                type: 'text',
                placeholder: 'https://drive.google.com/...',
                helpText: 'ðŸ”— Direct link to cloud file'
            },
            isFolder: {
                label: 'Is Folder',
                type: 'checkbox',
                helpText: 'ðŸ“ Check if this is a folder (not a file)'
            },
            includeDependencies: false,
            includeTracking: false
        }
    },
    gmail: {
        name: 'Email Workflow',
        icon: 'ðŸ“§',
        levels: {
            root: 'Inbox/Campaign',
            phase: 'Label/Stage',
            item: 'Thread',
            subtask: 'Message'
        },
        phaseSubtitles: ['Inbox', 'Sent', 'Important', 'Archive'],
        types: [
            { value: 'cold-outreach', label: 'â„ï¸ Cold Outreach' },
            { value: 'newsletter', label: 'ðŸ“° Newsletter' },
            { value: 'response', label: 'â†©ï¸ Response' },
            { value: 'follow-up', label: 'âž¡ï¸ Follow-up' },
            { value: 'internal', label: 'ðŸ¢ Internal Update' },
            { value: 'transactional', label: 'ðŸ§¾ Transactional' }
        ],
        description: 'Import and analyze Gmail threads with full conversation context',
        sortOptions: [
            { value: 'date-newest', label: 'ðŸ“… Date (Newest First)', field: 'sendDate', order: 'desc', type: 'date' },
            { value: 'date-oldest', label: 'ðŸ“… Date (Oldest First)', field: 'sendDate', order: 'asc', type: 'date' },
            { value: 'subject-az', label: 'ðŸ”¤ Subject (A-Z)', field: 'subjectLine', order: 'asc', type: 'text' },
            { value: 'subject-za', label: 'ðŸ”¤ Subject (Z-A)', field: 'subjectLine', order: 'desc', type: 'text' },
            { value: 'messages-most', label: 'ðŸ’¬ Messages (Most First)', field: 'messageCount', order: 'desc', type: 'number' },
            { value: 'messages-least', label: 'ðŸ’¬ Messages (Least First)', field: 'messageCount', order: 'asc', type: 'number' }
        ],
        fields: {
            recipientEmail: {
                label: 'To (Email)',
                type: 'text',
                placeholder: 'client@company.com',
                helpText: 'ðŸ‘¤ Primary recipient address'
            },
            ccEmail: {
                label: 'CC',
                type: 'text',
                placeholder: 'manager@company.com',
                helpText: 'ðŸ‘¥ Carbon copy recipients'
            },
            subjectLine: {
                label: 'Subject Line',
                type: 'text',
                placeholder: 'Meeting Request: Q4 Planning',
                helpText: 'ðŸ“ The email subject line'
            },
            emailBody: {
                label: 'Email Body',
                type: 'textarea',
                placeholder: 'Hi [Name],\n\nWriting to follow up on...',
                helpText: 'âœï¸ The main content of the email'
            },
            sendDate: {
                label: 'Date Sent',
                type: 'date',
                helpText: 'ðŸ“… When this email was sent/received'
            },
            status: {
                label: 'Status',
                type: 'select',
                options: ['Draft', 'Ready', 'Sent', 'Replied', 'Archived'],
                helpText: 'ðŸ“¬ Email status'
            },
            threadId: {
                label: 'Thread ID',
                type: 'text',
                placeholder: 'Gmail thread ID',
                helpText: 'ðŸ”— Gmail thread identifier'
            },
            messageCount: {
                label: 'Message Count',
                type: 'number',
                min: 1,
                helpText: 'ðŸ’¬ Number of messages in this thread'
            },
            sender: {
                label: 'Sender',
                type: 'text',
                placeholder: 'john@company.com',
                helpText: 'ðŸ‘¤ Email sender'
            },
            labels: {
                label: 'Gmail Labels',
                type: 'text',
                placeholder: 'INBOX, IMPORTANT, SENT',
                helpText: 'ðŸ·ï¸ Gmail labels/categories'
            },
            includeDependencies: true,
            includeTracking: true
        }
    },
    custom: {
        name: 'Custom Names',
        icon: 'âœï¸',
        levels: {
            root: 'Level 0',
            phase: 'Level 1',
            item: 'Level 2',
            subtask: 'Level 3'
        },
        description: 'Define your own names for all four levels',
        customizable: true
    }
};

// =============================================================================
// MIGRATION & SCHEMA MANAGEMENT (Cognitive Citadel Foundation)
// =============================================================================

const SCHEMA_VERSION = 1;

/**
 * Recursively normalizes node structure and adds defense fields
 */
function normalizeNode(node, source = 'legacy') {
    if (!node) return;
    
    // 1. Provenance Stamping
    if (!node.provenance) {
        node.provenance = {
            source: source,
            timestamp: new Date().toISOString(),
            modelId: null
        };
    }

    // 2. Phenomenology (The "Residue" - node-specific reflections)
    if (!node.phenomenology) {
        node.phenomenology = [];
    }

    // 3. Metrics (Attention Economics)
    if (!node.metrics) {
        node.metrics = {
            editCount: 0,
            focusTime: 0,
            lastModified: Date.now()
        };
    }

    // Recurse through all child types
    if (node.children) node.children.forEach(child => normalizeNode(child, source));
    if (node.items) node.items.forEach(child => normalizeNode(child, source));
    if (node.subItems) node.subItems.forEach(child => normalizeNode(child, source));
}

/**
 * Migrates tree to current SCHEMA_VERSION
 * Called on every file load to ensure backward compatibility
 */
function migrateTree(tree) {
    const currentVersion = tree.schemaVersion || 0;

    if (currentVersion < 1) {
        console.log(`ðŸ›¡ï¸ Migrating tree from v${currentVersion} to v1 (Cognitive Citadel Foundation)`);
        
        // Initialize Hyperedges if missing
        if (!tree.hyperedges) tree.hyperedges = [];
        
        // Initialize Snapshot references (for future IndexedDB storage)
        if (!tree.snapshotRefs) tree.snapshotRefs = [];

        // Normalize all nodes with legacy source
        normalizeNode(tree, 'legacy');

        tree.schemaVersion = 1;
        console.log('âœ… Migration to v1 complete');
    }

    // Future migrations stack here:
    // if (currentVersion < 2) { ... }

    return tree;
}

// ============================================================================
// FILE SYSTEM ICON MAPPING
// ============================================================================

const FILE_ICON_MAP = {
    // Documents
    '.pdf': { icon: 'ðŸ“•', type: 'pdf' },
    '.doc': { icon: 'ðŸ“˜', type: 'word' },
    '.docx': { icon: 'ðŸ“˜', type: 'word' },
    '.odt': { icon: 'ðŸ“˜', type: 'document' },

    // Spreadsheets
    '.xls': { icon: 'ðŸ“—', type: 'excel' },
    '.xlsx': { icon: 'ðŸ“—', type: 'excel' },
    '.csv': { icon: 'ðŸ“Š', type: 'excel' },
    '.ods': { icon: 'ðŸ“Š', type: 'excel' },

    // Presentations
    '.ppt': { icon: 'ðŸ“™', type: 'powerpoint' },
    '.pptx': { icon: 'ðŸ“™', type: 'powerpoint' },
    '.key': { icon: 'ðŸ“™', type: 'powerpoint' },
    '.odp': { icon: 'ðŸ“™', type: 'powerpoint' },

    // Text
    '.txt': { icon: 'ðŸ“', type: 'text' },
    '.md': { icon: 'ðŸ“', type: 'text' },
    '.rtf': { icon: 'ðŸ“', type: 'text' },

    // Images
    '.jpg': { icon: 'ðŸ–¼ï¸', type: 'image' },
    '.jpeg': { icon: 'ðŸ–¼ï¸', type: 'image' },
    '.png': { icon: 'ðŸ–¼ï¸', type: 'image' },
    '.gif': { icon: 'ðŸŽ¨', type: 'image' },
    '.bmp': { icon: 'ðŸ–¼ï¸', type: 'image' },
    '.svg': { icon: 'ðŸŽ¨', type: 'image' },
    '.webp': { icon: 'ðŸ–¼ï¸', type: 'image' },

    // Videos
    '.mp4': { icon: 'ðŸŽ¬', type: 'video' },
    '.avi': { icon: 'ðŸŽ¬', type: 'video' },
    '.mov': { icon: 'ðŸŽ¬', type: 'video' },
    '.mkv': { icon: 'ðŸŽ¬', type: 'video' },
    '.webm': { icon: 'ðŸŽ¬', type: 'video' },
    '.flv': { icon: 'ðŸŽ¬', type: 'video' },

    // Audio
    '.mp3': { icon: 'ðŸŽµ', type: 'audio' },
    '.wav': { icon: 'ðŸŽµ', type: 'audio' },
    '.flac': { icon: 'ðŸŽµ', type: 'audio' },
    '.aac': { icon: 'ðŸŽµ', type: 'audio' },
    '.ogg': { icon: 'ðŸŽµ', type: 'audio' },
    '.m4a': { icon: 'ðŸŽµ', type: 'audio' },

    // Code
    '.html': { icon: 'ðŸŒ', type: 'html' },
    '.htm': { icon: 'ðŸŒ', type: 'html' },
    '.css': { icon: 'ðŸŽ¨', type: 'css' },
    '.js': { icon: 'âš¡', type: 'javascript' },
    '.jsx': { icon: 'âš¡', type: 'javascript' },
    '.ts': { icon: 'ðŸ’™', type: 'javascript' },
    '.tsx': { icon: 'ðŸ’™', type: 'javascript' },
    '.py': { icon: 'ðŸ', type: 'python' },
    '.java': { icon: 'â˜•', type: 'code' },
    '.cpp': { icon: 'âš™ï¸', type: 'code' },
    '.c': { icon: 'âš™ï¸', type: 'code' },
    '.php': { icon: 'ðŸ˜', type: 'code' },
    '.rb': { icon: 'ðŸ’Ž', type: 'code' },
    '.go': { icon: 'ðŸ”µ', type: 'code' },
    '.rs': { icon: 'ðŸ¦€', type: 'code' },
    '.json': { icon: 'ðŸ“‹', type: 'code' },
    '.xml': { icon: 'ðŸ“‹', type: 'code' },
    '.yaml': { icon: 'ðŸ“‹', type: 'code' },
    '.yml': { icon: 'ðŸ“‹', type: 'code' },

    // Archives
    '.zip': { icon: 'ðŸ—œï¸', type: 'zip' },
    '.rar': { icon: 'ðŸ“¦', type: 'archive' },
    '.7z': { icon: 'ðŸ“¦', type: 'archive' },
    '.tar': { icon: 'ðŸ“¦', type: 'archive' },
    '.gz': { icon: 'ðŸ“¦', type: 'archive' },

    // Executables
    '.exe': { icon: 'âš™ï¸', type: 'executable' },
    '.msi': { icon: 'âš™ï¸', type: 'executable' },
    '.app': { icon: 'âš™ï¸', type: 'executable' },
    '.dmg': { icon: 'ðŸ’¿', type: 'executable' },
    '.deb': { icon: 'ðŸ“¦', type: 'executable' },

    // Database
    '.db': { icon: 'ðŸ—„ï¸', type: 'database' },
    '.sqlite': { icon: 'ðŸ—„ï¸', type: 'database' },
    '.sql': { icon: 'ðŸ—„ï¸', type: 'database' },

    // Default
    'default': { icon: 'â“', type: 'unknown' }
};

const FOLDER_ICON_MAP = {
    'default': 'ðŸ“',
    'open': 'ðŸ“‚',
    'shared': 'ðŸ‘¥',
    'cloud': 'â˜ï¸',
    'system': 'âš™ï¸',
    'user': 'ðŸ‘¤',
    'downloads': 'ðŸ“¥',
    'documents': 'ðŸ“„',
    'pictures': 'ðŸ–¼ï¸',
    'videos': 'ðŸŽ¬',
    'music': 'ðŸŽµ',
    'desktop': 'ðŸ–¥ï¸',
    'trash': 'ðŸ—‘ï¸'
};

function getFileIcon(fileName, isFolder = false) {
    if (isFolder) {
        // Check for special folder names
        const folderNameLower = fileName.toLowerCase();
        if (folderNameLower.includes('download')) return FOLDER_ICON_MAP.downloads;
        if (folderNameLower.includes('document')) return FOLDER_ICON_MAP.documents;
        if (folderNameLower.includes('picture') || folderNameLower.includes('photo')) return FOLDER_ICON_MAP.pictures;
        if (folderNameLower.includes('video') || folderNameLower.includes('movie')) return FOLDER_ICON_MAP.videos;
        if (folderNameLower.includes('music') || folderNameLower.includes('audio')) return FOLDER_ICON_MAP.music;
        if (folderNameLower.includes('desktop')) return FOLDER_ICON_MAP.desktop;
        if (folderNameLower.includes('trash') || folderNameLower.includes('recycle')) return FOLDER_ICON_MAP.trash;
        if (folderNameLower.includes('user')) return FOLDER_ICON_MAP.user;
        return FOLDER_ICON_MAP.default;
    }

    // Extract extension
    const ext = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
    const mapping = FILE_ICON_MAP[ext] || FILE_ICON_MAP.default;
    return mapping.icon;
}

function getFileType(fileName, isFolder = false) {
    if (isFolder) return 'folder';
    const ext = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
    const mapping = FILE_ICON_MAP[ext] || FILE_ICON_MAP.default;
    return mapping.type;
}

// ============================================================================
// PATTERN STATE
// ============================================================================

let currentPattern = 'generic';
let customPatternNames = null;
let currentSortConfig = null; // Stores current sort configuration

// ============================================================================
// PATTERN FUNCTIONS
// ============================================================================

// Helper: Get pattern key from either string or object format
function getPatternKey(pattern) {
    if (typeof pattern === 'string') {
        return pattern;
    } else if (pattern && pattern.key) {
        return pattern.key;
    }
    return null;
}

function getPatternLabels() {
    console.log('getPatternLabels called, currentPattern:', currentPattern);
    if (currentPattern === 'custom' && customPatternNames) {
        console.log('Returning custom labels:', customPatternNames);
        return customPatternNames;
    }
    const labels = PATTERNS[currentPattern].levels;
    console.log('Returning pattern labels:', labels);
    return labels;
}

function renameNodesForPattern(node, labels) {
    if (!node) return;

    // Collect all possible terms from all patterns for replacement
    const allRootTerms = ['Project', 'Pipeline', 'Thesis', 'Product', 'Book', 'Event', 'Program', 'Strategy', 'Course', 'Film', 'Treatise', 'Family'];
    const allPhaseTerms = ['Phase', 'Quarter', 'Chapter', 'Part', 'Stage', 'Pillar', 'Unit', 'Generation', 'Act', 'Sequence'];
    const allItemTerms = ['Item', 'Deal', 'Section', 'Feature', 'Chapter', 'Activity', 'Workout', 'Initiative', 'Lesson', 'Scene', 'Argument', 'Person', 'Beat'];
    const allSubtaskTerms = ['Task', 'Sub-task', 'Action', 'Point', 'Story', 'Scene', 'Exercise', 'Shot', 'Premise', 'Event', 'Frame', 'Remix'];

    // Rename based on node type - replace ANY pattern term with the new one
    if (node.type === 'root') {
        // Try to replace any root term from any pattern
        for (const term of allRootTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.root);
        }
    } else if (node.type === 'phase') {
        // Try to replace any phase term from any pattern
        for (const term of allPhaseTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.phase);
        }
        // Update phase subtitle based on pattern
        if (PATTERNS[currentPattern].phaseSubtitles && node.phase !== undefined) {
            const phaseIndex = parseInt(node.phase);
            if (!isNaN(phaseIndex) && phaseIndex < PATTERNS[currentPattern].phaseSubtitles.length) {
                node.subtitle = PATTERNS[currentPattern].phaseSubtitles[phaseIndex];
            }
        }
    } else if (node.type === 'item') {
        // Try to replace any item term from any pattern
        for (const term of allItemTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.item);
        }
    } else if (node.type === 'subtask') {
        // Try to replace any subtask term from any pattern
        for (const term of allSubtaskTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.subtask);
        }
    }

    // Recursively process children
    if (node.children) {
        node.children.forEach(child => renameNodesForPattern(child, labels));
    }

    // Process items in phases
    if (node.items) {
        node.items.forEach(item => {
            renameNodesForPattern(item, labels);
            // Process subtasks
            if (item.subItems) {
                item.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
            }
        });
    }

    // Process nested subtasks
    if (node.subItems) {
        node.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
    }
}

function applyPattern(patternKey) {
    console.log('applyPattern called with:', patternKey);
    currentPattern = patternKey;

    if (patternKey === 'custom') {
        showCustomPatternDialog();
    } else {
        // Store in data
        if (!capexTree.pattern) {
            capexTree.pattern = {};
        }
        capexTree.pattern.key = patternKey;
        capexTree.pattern.labels = PATTERNS[patternKey].levels;
        console.log('Pattern applied:', PATTERNS[patternKey].name);
        console.log('New labels:', PATTERNS[patternKey].levels);

        // Auto-rename existing nodes to match pattern
        renameNodesForPattern(capexTree, PATTERNS[patternKey].levels);
        console.log('Nodes renamed to match pattern');

        // Re-render to apply new labels
        render();

        // Update sort dropdown for new pattern
        updateSortDropdown();

        // Update AI button label to match pattern
        updateAIButtonLabel();
    }
}

// Update AI Analysis button label based on active pattern
function updateAIButtonLabel() {
    const btn = document.getElementById('ai-btn');
    if (!btn) return;

    const span = btn.querySelector('span');
    if (!span) return;

    const labelMap = {
        'generic': { text: 'ðŸ“Š Project Report', tooltip: 'Generate executive summary and risk assessment' },
        'sales': { text: 'ðŸ’° Deal Scorecard', tooltip: 'Analyze deal probability, revenue weight, and blockers' },
        'film': { text: 'ðŸŽ¬ Scene Breakdown', tooltip: 'Analyze shot lists, camera moves, and continuity' },
        'book': { text: 'ðŸ“– Story Arc Review', tooltip: 'Analyze pacing, character beats, and plot structure' },
        'philosophy': { text: 'ðŸ§  Logic Audit', tooltip: 'Check validity of premises and argument strength' },
        'thesis': { text: 'ðŸ“š Academic Review', tooltip: 'Analyze structure, citations, and argumentation' },
        'roadmap': { text: 'ðŸš€ Roadmap Analysis', tooltip: 'Check feature dependencies and timeline coherence' },
        'prompting': { text: 'ðŸ§ª Prompt Test', tooltip: 'Analyze prompt structure against best practices' },
        'gmail': { text: 'ðŸ“§ Thread Summary', tooltip: 'Summarize conversation and identify action items' },
        'event': { text: 'ðŸŽ‰ Event Checklist', tooltip: 'Check logistics, timeline, and vendor coordination' },
        'fitness': { text: 'ðŸ’ª Workout Audit', tooltip: 'Analyze progression, volume, and recovery balance' },
        'strategy': { text: 'ðŸŽ¯ Strategy Review', tooltip: 'Analyze objectives, initiatives, and resource alignment' },
        'course': { text: 'ðŸŽ“ Curriculum Check', tooltip: 'Check learning objectives and scaffolding' },
        'family': { text: 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family Tree Analysis', tooltip: 'Analyze relationships and genealogical connections' },
        'rhetoric': { text: 'ðŸ—£ï¸ Argument Review', tooltip: 'Analyze rhetorical devices and persuasion structure' },
        'filesystem': { text: 'ðŸ§¹ Clean Up Files', tooltip: 'Find duplicates, suggest better names and organization' },
        'default': { text: 'ðŸ“Š Project Report', tooltip: 'Generate analysis report for this tree' }
    };

    const config = labelMap[currentPattern] || labelMap.default;
    span.textContent = config.text;
    btn.title = config.tooltip;
    btn.setAttribute('data-icon', config.text.split(' ')[0]); // Extract emoji for collapsed view

    console.log(`âœ… AI button updated for "${currentPattern}" pattern: ${config.text}`);
}

// Populate sort dropdown based on current pattern
function updateSortDropdown() {
    console.log('ðŸ”„ updateSortDropdown called, currentPattern:', currentPattern);

    const sortSection = document.getElementById('sort-section');
    const sortSelect = document.getElementById('pattern-sort-select');

    if (!sortSection || !sortSelect) {
        console.log('âŒ Sort elements not found in DOM');
        return;
    }

    const pattern = PATTERNS[currentPattern];
    console.log('Pattern object:', pattern ? pattern.name : 'undefined');

    // Check if pattern has sortOptions
    if (pattern && pattern.sortOptions && pattern.sortOptions.length > 0) {
        // Show sort section
        sortSection.style.display = 'flex';

        // Clear existing options
        const previousCount = sortSelect.options.length;
        sortSelect.innerHTML = '<option value="">Default Order</option>';

        // Add pattern-specific sort options
        pattern.sortOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.label;
            opt.dataset.field = option.field;
            opt.dataset.order = option.order;
            opt.dataset.type = option.type;
            sortSelect.appendChild(opt);
        });

        console.log(`âœ… Sort dropdown updated: ${previousCount} â†’ ${sortSelect.options.length} options (${pattern.sortOptions.length} + Default) for "${currentPattern}" pattern`);
    } else {
        // Hide sort section if pattern has no sort options
        sortSection.style.display = 'none';
        console.log(`âš ï¸ Pattern "${currentPattern}" has no sort options`);
    }
}

// Dynamically populate cluster-by dropdown based on current pattern
function updateClusterByOptions() {
    const clusterBySelect = document.getElementById('cluster-by-select');
    if (!clusterBySelect) {
        console.log('âš ï¸ Cluster-by select not found in DOM');
        return;
    }

    const currentValue = clusterBySelect.value;
    clusterBySelect.innerHTML = '';

    // Always start with default option
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = 'ðŸ”— Cluster By';
    defaultOption.style.cssText = 'background: #1a1a2e; color: #ffffff;';
    clusterBySelect.appendChild(defaultOption);

    // Universal fields (work for all patterns)
    const universalFields = [
        { value: 'itemType', label: 'ðŸ“¦ Type' },
        { value: 'owner', label: 'ðŸ‘¤ Owner' },
        { value: 'pmRAGStatus', label: 'ðŸš¦ Status' },
        { value: 'cost', label: 'ðŸ’° Cost Range' },
        { value: 'modifiedDate', label: 'ðŸ“… Date' }
    ];

    // Pattern-specific fields
    const patternFields = {
        philosophy: [
            { value: 'argumentType', label: 'ðŸŽ¯ Argument Type' },
            { value: 'validity', label: 'âœ“ Logical Validity' },
            { value: 'speaker', label: 'ðŸ—£ï¸ Speaker' },
            { value: 'philosophicalSchool', label: 'ðŸ›ï¸ School of Thought' }
        ],
        film: [
            { value: 'visualStyle', label: 'ðŸŽ¨ Visual Style' },
            { value: 'lightingMood', label: 'ðŸ’¡ Lighting Mood' },
            { value: 'cameraMovement', label: 'ðŸŽ¥ Camera Movement' },
            { value: 'aiPlatform', label: 'ðŸ¤– AI Platform' }
        ],
        veo3: [
            { value: 'flowMode', label: 'ðŸŽ¬ Flow Mode' },
            { value: 'audioType', label: 'ðŸ”Š Audio Type' },
            { value: 'cinematicStyle', label: 'ðŸŽ¨ Cinematic Style' }
        ],
        sora2: [
            { value: 'beatType', label: 'ðŸŽµ Beat Type' },
            { value: 'cameoUsed', label: 'ðŸ‘¤ Cameo Used' },
            { value: 'physicsComplexity', label: 'âš›ï¸ Physics Complexity' }
        ],
        sales: [
            { value: 'leadStage', label: 'ðŸ“Š Lead Stage' },
            { value: 'leadSource', label: 'ðŸ“ Lead Source' },
            { value: 'dealSize', label: 'ðŸ’° Deal Size' }
        ],
        roadmap: [
            { value: 'priority', label: 'â­ Priority' },
            { value: 'stakeholder', label: 'ðŸ‘¥ Stakeholder' },
            { value: 'featureCategory', label: 'ðŸ“¦ Feature Category' }
        ]
    };

    // Get pattern-specific fields for current pattern
    const specificFields = patternFields[currentPattern] || [];

    // Add universal fields first
    universalFields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.value;
        option.textContent = field.label;
        option.style.cssText = 'background: #1a1a2e; color: #ffffff;';
        clusterBySelect.appendChild(option);
    });

    // Add separator if we have pattern-specific fields
    if (specificFields.length > 0) {
        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
        separator.style.cssText = 'background: #1a1a2e; color: #555;';
        clusterBySelect.appendChild(separator);

        // Add pattern-specific fields
        specificFields.forEach(field => {
            const option = document.createElement('option');
            option.value = field.value;
            option.textContent = field.label;
            option.style.cssText = 'background: #1a1a2e; color: #ffffff;';
            clusterBySelect.appendChild(option);
        });
    }

    // Restore previous value if it still exists
    if (currentValue) {
        const optionExists = Array.from(clusterBySelect.options).some(opt => opt.value === currentValue);
        if (optionExists) {
            clusterBySelect.value = currentValue;
        }
    }

    console.log(`âœ… Cluster-by options updated for pattern: ${currentPattern} (${specificFields.length} pattern-specific fields)`);
}

function showCustomPatternDialog() {
    const pattern = PATTERNS[currentPattern];
    const currentLabels = customPatternNames || pattern.levels;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = `
        <div style="padding: 20px;">
            <h3 style="color: var(--treeplex-primary); margin-bottom: 20px;">Custom Pattern Names</h3>
            <p style="margin-bottom: 20px; color: var(--text-secondary); font-size: 14px;">
                Define your own names for each level of your project structure.
            </p>

            <div style="display: flex; flex-direction: column; gap: 16px;">
                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 0 (Root):
                    </label>
                    <input type="text" id="custom-root" value="${currentLabels.root}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Project, Campaign, Thesis">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 1 (Phase):
                    </label>
                    <input type="text" id="custom-phase" value="${currentLabels.phase}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Phase, Quarter, Chapter">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 2 (Item):
                    </label>
                    <input type="text" id="custom-item" value="${currentLabels.item}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Item, Feature, Section">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 3 (Subtask):
                    </label>
                    <input type="text" id="custom-subtask" value="${currentLabels.subtask}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Task, Story, Point">
                </div>
            </div>

            <div style="display: flex; gap: 12px; margin-top: 24px;">
                <button class="btn btn-primary" onclick="saveCustomPattern()" style="flex: 1;">
                    âœ“ Apply Custom Names
                </button>
                <button class="btn" onclick="closeModal()" style="flex: 1;">
                    Cancel
                </button>
            </div>
        </div>
    `;

    document.getElementById('modal').style.display = 'flex';
}

function saveCustomPattern() {
    const root = document.getElementById('custom-root').value.trim() || 'Level 0';
    const phase = document.getElementById('custom-phase').value.trim() || 'Level 1';
    const item = document.getElementById('custom-item').value.trim() || 'Level 2';
    const subtask = document.getElementById('custom-subtask').value.trim() || 'Level 3';

    customPatternNames = { root, phase, item, subtask };

    // Store in data
    if (!capexTree.pattern) {
        capexTree.pattern = {};
    }
    capexTree.pattern.key = 'custom';
    capexTree.pattern.labels = customPatternNames;

    closeModal();
    render();
}

// ============================================================================
// INITIALIZATION
// ============================================================================


function showPatternDescription() {
    const select = document.getElementById('pattern-select');
    const selectedOption = select.options[select.selectedIndex];
    const desc = selectedOption.getAttribute('data-desc');

    if (desc) {
        select.setAttribute('title', desc);
    }
}

function hidePatternDescription() {
    // Keep title for basic tooltip
}

        // State
        let activeNode = null;

        // Utilities
        function formatCost(cost) {
            // Handle null, undefined, or non-numeric values
            if (cost === null || cost === undefined || cost === '' || isNaN(cost)) {
                return '$0';
            }

            // Convert to number if it's a string
            const numCost = typeof cost === 'string' ? parseFloat(cost) : cost;

            if (numCost >= 1000000) return '$' + (numCost / 1000000).toFixed(1) + 'M';
            if (numCost >= 1000) return '$' + (numCost / 1000).toFixed(0) + 'k';
            return '$' + numCost.toLocaleString();
        }

        // Calculate total including all children (for root node)
        function calculateTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            if (node.children) {
                node.children.forEach(child => {
                    total += calculateTotal(child);
                });
            }
            return total;
        }

        // Calculate only items in this phase (NOT children phases)
        function calculatePhaseTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            return total;
        }

        function findNode(id, node = capexTree) {
            if (node.id === id) return node;
            if (node.children) {
                for (let child of node.children) {
                    const found = findNode(id, child);
                    if (found) return found;
                }
            }
            return null;
        }

        // Render tree - phases flow left to right
        function render() {
            const container = document.getElementById('tree-root');
            container.innerHTML = '';

            const tableEl = document.createElement('div');
            tableEl.className = 'tree';

            // FILESYSTEM PATTERN: Use vertical tree layout
            if (currentPattern === 'filesystem') {
                tableEl.classList.add('filesystem-tree');

                function buildFilesystemNode(node, depth = 0) {
                    // Initialize expanded property if not set
                    if (node.expanded === undefined) {
                        node.expanded = (depth === 0 || depth === 1); // Auto-expand root and drives
                    }

                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = `tree-node ${node.type} filesystem-indent-${depth}`;
                    if (node.expanded) nodeDiv.classList.add('expanded');
                    else nodeDiv.classList.add('collapsed');
                    nodeDiv.dataset.nodeId = node.id;

                    // Build node content
                    if (node.type === 'root') {
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0) || (node.children && node.children.length > 0);
                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? 'â–¼' : 'â–¶') + '</span>' : ''}
                                <span class="node-icon">${node.icon || 'ðŸ“'}</span>
                                <div class="node-content">
                                    <div class="node-title">${node.name}</div>
                                </div>
                            </div>
                        `;
                    } else if (node.type === 'phase') {
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0) || (node.children && node.children.length > 0);
                        const isVisibleInCanvas = node.showInCanvas !== false;
                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? 'â–¼' : 'â–¶') + '</span>' : ''}
                                <span class="node-icon">${node.icon || 'ðŸ“‹'}</span>
                                <div class="node-content">
                                    <div class="node-title">${node.name}</div>
                                </div>
                                <button class="canvas-visibility-toggle" title="${isVisibleInCanvas ? 'Hide from Canvas View' : 'Show in Canvas View'}" style="background: none; border: none; cursor: pointer; padding: 4px; margin-left: 8px; font-size: 16px; opacity: ${isVisibleInCanvas ? '1' : '0.3'};">
                                    ${isVisibleInCanvas ? 'ðŸ‘ï¸' : 'ðŸ‘ï¸'}
                                </button>
                            </div>
                        `;
                    } else {
                        // Item/Subtask - file or folder
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0);
                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? 'â–¼' : 'â–¶') + '</span>' : ''}
                                <span class="node-icon">${node.icon || 'ðŸ“„'}</span>
                                <div class="node-content">
                                    <span class="item-name">${node.name}</span>
                                </div>
                            </div>
                        `;
                    }

                    // Add event listener for canvas visibility toggle (phases only)
                    if (node.type === 'phase') {
                        const toggleBtn = nodeDiv.querySelector('.canvas-visibility-toggle');
                        if (toggleBtn) {
                            toggleBtn.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();

                                // Toggle visibility
                                node.showInCanvas = !(node.showInCanvas !== false);
                                console.log(`Phase "${node.name}" showInCanvas: ${node.showInCanvas}`);

                                // Re-render tree to update button appearance
                                const treeContainer = document.getElementById('tree-container');
                                const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;
                                render();
                                if (treeContainer) {
                                    setTimeout(() => {
                                        treeContainer.scrollTop = scrollTop;
                                        treeContainer.scrollLeft = scrollLeft;
                                    }, 0);
                                }

                                // If in Canvas View, re-render canvas
                                if (currentView === 'canvas') {
                                    renderCanvas();
                                }
                            });
                        }
                    }

                    // Event listeners
                    nodeDiv.addEventListener('click', (e) => {
                        e.stopPropagation();

                        const hasChildren = (node.items && node.items.length > 0) ||
                                          (node.subItems && node.subItems.length > 0) ||
                                          (node.children && node.children.length > 0);

                        console.log('Clicked node:', node.name, {
                            type: node.type,
                            hasItems: node.items?.length || 0,
                            hasSubItems: node.subItems?.length || 0,
                            hasChildren: node.children?.length || 0,
                            expanded: node.expanded,
                            hasChildrenTotal: hasChildren
                        });

                        if (hasChildren) {
                            node.expanded = !node.expanded;
                            console.log('â†’ Toggled', node.name, 'to', node.expanded ? 'EXPANDED' : 'COLLAPSED');

                            // Preserve scroll position during re-render (both vertical and horizontal)
                            const treeContainer = document.getElementById('tree-container');
                            const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                            const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                            render();

                            // Restore scroll position after render
                            if (treeContainer) {
                                setTimeout(() => {
                                    treeContainer.scrollTop = scrollTop;
                                    treeContainer.scrollLeft = scrollLeft;
                                }, 0);
                            }
                        } else {
                            console.log('â†’ No children, showing info panel');
                            showInfo(node);
                        }
                    });

                    nodeDiv.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        activeNode = node;
                        showContextMenu(e.pageX, e.pageY);
                    });

                    tableEl.appendChild(nodeDiv);

                    // Recursively render children if expanded
                    if (node.expanded) {
                        if (node.children && node.children.length > 0) {
                            node.children.forEach(child => buildFilesystemNode(child, depth + 1));
                        }
                        if (node.items && node.items.length > 0) {
                            node.items.forEach(item => buildFilesystemNode(item, depth + 1));
                        }
                        if (node.subItems && node.subItems.length > 0) {
                            node.subItems.forEach(subItem => buildFilesystemNode(subItem, depth + 1));
                        }
                    }
                }

                // Start rendering from root
                buildFilesystemNode(capexTree, 0);

                container.appendChild(tableEl);
                return;
            }

            // DEFAULT PATTERN: Use horizontal column layout
            // Traverse and build columns
            function buildColumn(node) {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'tree-level';

                // Render current node
                const nodeDiv = document.createElement('div');
                nodeDiv.className = `tree-node ${node.type}`;
                if (node.type === 'phase') nodeDiv.classList.add(`phase-${node.phase}`);
                if (node.expanded) nodeDiv.classList.add('expanded');
                else nodeDiv.classList.add('collapsed');

                nodeDiv.dataset.nodeId = node.id;

                if (node.type === 'root') {
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon || 'ðŸŒ³'}</span>
                            <div class="node-content">
                                <div class="node-title">${node.name}</div>
                                <div class="node-subtitle">by geej</div>
                            </div>
                            ${node.children ? '<span class="expand-toggle">â–¶</span>' : ''}
                        </div>
                    `;
                } else if (node.type === 'phase') {
                    const total = calculatePhaseTotal(node);
                    const isVisibleInCanvas = node.showInCanvas !== false;
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon || 'ðŸ“‹'}</span>
                            <div class="node-content">
                                <div class="node-title">${node.name}</div>
                                ${node.subtitle ? `<div class="node-subtitle">${node.subtitle}</div>` : ''}
                                ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<div class="node-cost">${formatCost(total)}</div>` : ''}
                            </div>
                            <button class="canvas-visibility-toggle" title="${isVisibleInCanvas ? 'Hide from Canvas View' : 'Show in Canvas View'}" style="background: none; border: none; cursor: pointer; padding: 4px 8px; margin-right: 8px; font-size: 18px; opacity: ${isVisibleInCanvas ? '1' : '0.3'};">
                                ${isVisibleInCanvas ? 'ðŸ‘ï¸' : 'ðŸ‘ï¸'}
                            </button>
                            ${node.items || node.children ? '<span class="expand-toggle">â–¶</span>' : ''}
                        </div>
                    `;
                } else {
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon || 'ðŸ“„'}</span>
                            <div class="node-content">
                                <div class="item-name">${node.name}</div>
                                ${node.description ? `<div class="item-description">${node.description}</div>` : ''}
                                <div class="item-meta">
                                    ${node.itemType ? `<span class="badge badge-${node.itemType}">${node.itemType}</span>` : ''}
                                    ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<span class="item-cost">${formatCost(node.cost)}</span>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Add event listener for canvas visibility toggle (phases only)
                if (node.type === 'phase') {
                    const toggleBtn = nodeDiv.querySelector('.canvas-visibility-toggle');
                    if (toggleBtn) {
                        toggleBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            // Toggle visibility
                            node.showInCanvas = !(node.showInCanvas !== false);
                            console.log(`Phase "${node.name}" showInCanvas: ${node.showInCanvas}`);

                            // Re-render tree to update button appearance
                            const treeContainer = document.getElementById('tree-container');
                            const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                            const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;
                            render();
                            if (treeContainer) {
                                setTimeout(() => {
                                    treeContainer.scrollTop = scrollTop;
                                    treeContainer.scrollLeft = scrollLeft;
                                }, 0);
                            }

                            // If in Canvas View, re-render canvas
                            if (currentView === 'canvas') {
                                renderCanvas();
                            }
                        });
                    }
                }

                nodeDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if ((node.items && node.items.length > 0) || (node.children && node.children.length > 0)) {
                        node.expanded = !node.expanded;

                        // Preserve scroll position during re-render (both vertical and horizontal)
                        const treeContainer = document.getElementById('tree-container');
                        const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                        const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                        render();

                        // Restore scroll position after render
                        if (treeContainer) {
                            setTimeout(() => {
                                treeContainer.scrollTop = scrollTop;
                                treeContainer.scrollLeft = scrollLeft;
                            }, 0);
                        }
                    } else {
                        showInfo(node);
                    }
                });

                nodeDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    activeNode = node;
                    showContextMenu(e.pageX, e.pageY);
                });

                levelDiv.appendChild(nodeDiv);
                tableEl.appendChild(levelDiv);

                // If expanded, show items in next column, then next phase in following column
                if (node.expanded) {
                    // Show items if any
                    if (node.items && node.items.length > 0) {
                        const itemsColumn = document.createElement('div');
                        itemsColumn.className = 'tree-level';

                        // Get all item IDs in this phase to check for same-phase dependencies
                        const phaseItemIds = node.items.map(i => i.id);

                        // Topological sort: order items by dependencies
                        // Items with no same-phase dependencies first, then items that depend on them
                        function topologicalSort(items, phaseIds) {
                            const sorted = [];
                            const visited = new Set();
                            const visiting = new Set();

                            function visit(item) {
                                if (visited.has(item.id)) return;
                                if (visiting.has(item.id)) {
                                    // Circular dependency - just add it
                                    sorted.push(item);
                                    visited.add(item.id);
                                    return;
                                }

                                visiting.add(item.id);

                                // Visit dependencies first (only same-phase dependencies)
                                if (item.dependencies) {
                                    // Handle both array and string formats
                                    const deps = Array.isArray(item.dependencies) ? item.dependencies : [];
                                    deps.forEach(depId => {
                                        if (phaseIds.includes(depId)) {
                                            const depItem = items.find(i => i.id === depId);
                                            if (depItem) {
                                                visit(depItem);
                                            }
                                        }
                                    });
                                }

                                visiting.delete(item.id);
                                visited.add(item.id);
                                sorted.push(item);
                            }

                            items.forEach(item => visit(item));
                            return sorted;
                        }

                        // Calculate dependency depth/level for hierarchical indentation
                        // Returns the depth in the dependency chain (0 = no deps, 1 = direct child, 2 = grandchild, etc.)
                        function calculateDependencyLevel(item, phaseItems, phaseItemIds, visited = new Set()) {
                            // Base case: no same-phase dependencies
                            if (!item.dependencies || item.dependencies.length === 0) {
                                return 0;
                            }

                            const samePhaseDeps = item.dependencies.filter(depId => phaseItemIds.includes(depId));
                            if (samePhaseDeps.length === 0) {
                                return 0;
                            }

                            // Prevent circular dependency infinite loops
                            if (visited.has(item.id)) {
                                return 0;
                            }

                            visited.add(item.id);

                            // Find max depth among all same-phase dependencies
                            let maxLevel = 0;
                            samePhaseDeps.forEach(depId => {
                                const depItem = phaseItems.find(i => i.id === depId);
                                if (depItem) {
                                    const depLevel = calculateDependencyLevel(depItem, phaseItems, phaseItemIds, new Set(visited));
                                    maxLevel = Math.max(maxLevel, depLevel + 1);
                                }
                            });

                            return maxLevel;
                        }

                        // Use topological sort only when no custom sort is active
                        const sortedItems = (typeof currentSortConfig !== 'undefined' && currentSortConfig !== null)
                            ? node.items  // Use existing order when user has sorted
                            : topologicalSort(node.items, phaseItemIds);  // Use dependency-based order otherwise

                        sortedItems.forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = `tree-node item phase-${node.phase}`;
                            itemDiv.dataset.itemId = item.id; // Add item ID for dependency linking

                            // Calculate dependency depth for hierarchical indentation
                            const dependencyLevel = calculateDependencyLevel(item, node.items, phaseItemIds);

                            // Add multi-level indentation based on dependency depth
                            // Level 0 = no indent, Level 1 = 20px, Level 2 = 40px, Level 3 = 60px, etc.
                            if (dependencyLevel > 0) {
                                itemDiv.classList.add('has-same-phase-dependency');
                                itemDiv.style.marginLeft = `${dependencyLevel * 20}px`;
                                itemDiv.style.position = 'relative';
                                itemDiv.dataset.dependencyLevel = dependencyLevel; // Store for potential visual enhancements
                            }

                            // Add expanded class if item has subtasks and is expanded
                            if (item.subItems && item.subItems.length > 0 && item.expanded) {
                                itemDiv.classList.add('has-expanded-subtasks');
                            }

                            // Add dependency indicator
                            const depInfo = item.dependencies && item.dependencies.length > 0
                                ? `<div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">Depends: ${item.dependencies.join(', ')}</div>`
                                : '';

                            // Check if item has subtasks for expand/collapse indicator
                            const hasSubtasks = item.subItems && item.subItems.length > 0;
                            const expandIndicator = hasSubtasks
                                ? `<span class="expand-toggle" onclick="event.stopPropagation(); window.toggleSubtasks('${item.id}');" style="margin-left: 8px; font-size: 12px; opacity: 0.7; cursor: pointer; user-select: none;">${item.expanded ? 'â–¼' : 'â–¶'}</span>`
                                : '';

                            // RAG Status indicator
                            const ragStatusColors = {
                                'Green': '#22C55E',
                                'Amber': '#F59E0B',
                                'Red': '#EF4444'
                            };
                            const itemRAGStatus = item.pmRAGStatus;
                            const ragIndicator = itemRAGStatus ?
                                `<span style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: ${ragStatusColors[itemRAGStatus]}; margin-left: 8px; box-shadow: 0 0 6px ${ragStatusColors[itemRAGStatus]}80; vertical-align: middle;" title="RAG Status: ${itemRAGStatus}"></span>` : '';

                            // PM Status badge
                            const pmStatusBadge = item.pmStatus && item.pmStatus !== 'To Do' ?
                                `<span style="font-size: 10px; padding: 2px 6px; border-radius: 4px; background: ${item.pmStatus === 'Completed' ? '#22C55E' : item.pmStatus === 'Blocked' ? '#EF4444' : '#3B82F6'}; color: white; margin-left: 8px; font-weight: 600;">${item.pmStatus}</span>` : '';

                            itemDiv.innerHTML = `
                                <div class="node-header">
                                    <span class="node-icon">${item.icon}</span>
                                    <div class="node-content">
                                        <div class="item-name">
                                            ${item.name}
                                            ${ragIndicator}
                                            ${pmStatusBadge}
                                            ${expandIndicator}
                                            ${hasSubtasks ? `<span style="font-size: 10px; color: var(--text-secondary); margin-left: 8px;">(${item.subItems.length} tasks)</span>` : ''}
                                        </div>
                                        <div class="item-description">${item.description}</div>
                                        <div class="item-meta">
                                            ${item.itemType ? `<span class="badge badge-${item.itemType}">${item.itemType}</span>` : ''}
                                            ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<span class="item-cost">${formatCost(item.cost)}</span>` : ''}
                                            ${item.pmOwnerEmail ? `<span style="font-size: 10px; color: var(--text-secondary); margin-left: 12px;">ðŸ‘¤ ${item.pmOwnerEmail.split('@')[0]}</span>` : ''}
                                            ${item.pmProgress > 0 ? `<span style="font-size: 10px; color: var(--treeplex-primary); margin-left: 12px; font-weight: 600;">${item.pmProgress}%</span>` : ''}
                                        </div>
                                        ${depInfo}
                                    </div>
                                </div>
                            `;
                            itemDiv.addEventListener('click', (e) => {
                                e.stopPropagation();

                                const panel = document.getElementById('info-panel');
                                const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === item.id;

                                if (isPanelOpen) {
                                    // Second click: Close panel and collapse subtasks
                                    panel.classList.remove('open');
                                    currentOpenItemId = null;
                                    if (hasSubtasks) {
                                        item.expanded = false;

                                        // Preserve scroll position during re-render (both vertical and horizontal)
                                        const treeContainer = document.getElementById('tree-container');
                                        const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                        const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                        render();

                                        // Restore scroll position after render
                                        if (treeContainer) {
                                            setTimeout(() => {
                                                treeContainer.scrollTop = scrollTop;
                                                treeContainer.scrollLeft = scrollLeft;
                                            }, 0);
                                        }
                                    }
                                } else {
                                    // First click: Open panel and expand subtasks
                                    showInfo(item);
                                    if (hasSubtasks) {
                                        item.expanded = true;

                                        // Preserve scroll position during re-render (both vertical and horizontal)
                                        const treeContainer = document.getElementById('tree-container');
                                        const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                        const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                        render();

                                        // Restore scroll position after render
                                        if (treeContainer) {
                                            setTimeout(() => {
                                                treeContainer.scrollTop = scrollTop;
                                                treeContainer.scrollLeft = scrollLeft;
                                            }, 0);
                                        }
                                    }
                                }
                            });

                            itemDiv.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                activeNode = item;
                                showContextMenu(e.pageX, e.pageY);
                            });

                            itemsColumn.appendChild(itemDiv);

                            // RECURSIVE function to render subtasks - keeps same generation on horizontal plane
                            function renderSubtasks(parentItem, containerEl, phaseNum, nestLevel = 0) {
                                if (!parentItem.expanded || !parentItem.subItems || parentItem.subItems.length === 0) {
                                    return;
                                }

                                const subtaskContainer = document.createElement('div');
                                subtaskContainer.className = 'subtask-container';
                                subtaskContainer.style.marginLeft = `${(dependencyLevel + nestLevel) * 20}px`;

                                // Get sub-item IDs for dependency calculations
                                const subItemIds = parentItem.subItems.map(s => s.id);

                                // Sort sub-items by dependencies (topological sort)
                                const sortedSubItems = topologicalSort(parentItem.subItems, subItemIds);

                                // Collect all expanded children that need rendering in next generation
                                const allExpandedGrandchildren = [];

                                // Render all subtasks horizontally first (same generation on same row)
                                sortedSubItems.forEach((subItem, index) => {
                                    const subItemDiv = document.createElement('div');
                                    subItemDiv.className = `tree-node item phase-${phaseNum} subtask`;
                                    subItemDiv.dataset.itemId = subItem.id;

                                    // Ensure subItem has type set
                                    if (!subItem.type) {
                                        subItem.type = 'subtask';
                                    }

                                    // Status color indicator
                                    const statusColors = {
                                        'To Do': '#9CA3AF',
                                        'In Progress': '#3B82F6',
                                        'Completed': '#10B981',
                                        'Done': '#10B981',
                                        'Blocked': '#EF4444'
                                    };
                                    const statusColor = statusColors[subItem.pmStatus] || '#9CA3AF';

                                    // Get initials from assignee name
                                    const getInitials = (name) => {
                                        if (!name || name === 'Unassigned') return '?';
                                        const parts = name.trim().split(' ');
                                        if (parts.length === 1) return parts[0].substring(0, 2).toUpperCase();
                                        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                                    };

                                    // Check if this task has children
                                    const hasChildren = subItem.subItems && subItem.subItems.length > 0;
                                    const chevronIcon = hasChildren ? (subItem.expanded ? 'â–¼' : 'â–¶') : '';

                                    // RAG Status for subtasks
                                    const subRAGColors = {
                                        'Green': '#22C55E',
                                        'Amber': '#F59E0B',
                                        'Red': '#EF4444'
                                    };
                                    const subRAGStatus = subItem.pmRAGStatus;
                                    const ragDot = subRAGStatus ?
                                        `<div style="width: 8px; height: 8px; border-radius: 50%; background: ${subRAGColors[subRAGStatus]}; box-shadow: 0 0 4px ${subRAGColors[subRAGStatus]}; flex-shrink: 0; position: absolute; top: -2px; right: -2px; border: 1.5px solid var(--card-bg-light);" title="RAG: ${subRAGStatus}"></div>` : '';

                                    subItemDiv.innerHTML = `
                                        <div style="display: flex; flex-direction: column; gap: 6px; width: 100%; height: 100%;">
                                            <!-- Task Title with optional chevron -->
                                            <div style="display: flex; align-items: flex-start; gap: 4px;">
                                                ${chevronIcon ? `<span style="font-size: 8px; color: var(--text-secondary); cursor: pointer; margin-top: 2px;" class="task-chevron">${chevronIcon}</span>` : ''}
                                                <div style="font-size: 11px; font-weight: 600; line-height: 1.2; color: var(--text-primary); flex: 1; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                                                    ${subItem.name}
                                                </div>
                                            </div>

                                            <!-- Visual Indicators Row -->
                                            <div style="display: flex; align-items: center; gap: 6px; margin-top: auto;">
                                                <!-- Status Dot with RAG overlay -->
                                                <div style="position: relative; width: 12px; height: 12px; flex-shrink: 0;">
                                                    <div style="width: 12px; height: 12px; border-radius: 50%; background: ${statusColor}; box-shadow: 0 0 6px ${statusColor}; flex-shrink: 0;" title="${subItem.pmStatus || 'To Do'}"></div>
                                                    ${ragDot}
                                                </div>

                                                <!-- Owner Badge -->
                                                <div style="width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; color: white; flex-shrink: 0;" title="${subItem.pmOwnerEmail || subItem.pmAssignee || 'Unassigned'}">
                                                    ${getInitials(subItem.pmOwnerEmail || subItem.pmAssignee)}
                                                </div>

                                                <!-- Progress % -->
                                                <div style="font-size: 11px; font-weight: 700; color: var(--treeplex-primary); margin-left: auto;" title="Progress">
                                                    ${subItem.pmProgress || 0}%
                                                </div>
                                            </div>

                                            <!-- Mini Progress Bar -->
                                            <div style="width: 100%; height: 3px; background: rgba(0, 0, 0, 0.3); border-radius: 2px; overflow: hidden;">
                                                <div style="height: 100%; width: ${subItem.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                                            </div>
                                        </div>
                                    `;

                                    // Click to show info panel AND toggle nested subtasks
                                    subItemDiv.addEventListener('click', (e) => {
                                        e.stopPropagation();

                                        const panel = document.getElementById('info-panel');
                                        const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === subItem.id;

                                        if (isPanelOpen) {
                                            // Second click: Close panel and collapse nested subtasks
                                            panel.classList.remove('open');
                                            currentOpenItemId = null;
                                            if (hasChildren) {
                                                subItem.expanded = false;

                                                // Preserve scroll position during re-render (both vertical and horizontal)
                                                const treeContainer = document.getElementById('tree-container');
                                                const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                                const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                                render();

                                                // Restore scroll position after render
                                                if (treeContainer) {
                                                    setTimeout(() => {
                                                        treeContainer.scrollTop = scrollTop;
                                                        treeContainer.scrollLeft = scrollLeft;
                                                    }, 0);
                                                }
                                            }
                                        } else {
                                            // First click: Open panel and expand nested subtasks
                                            showInfo(subItem);
                                            if (hasChildren) {
                                                subItem.expanded = true;

                                                // Preserve scroll position during re-render (both vertical and horizontal)
                                                const treeContainer = document.getElementById('tree-container');
                                                const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                                const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                                render();

                                                // Restore scroll position after render
                                                if (treeContainer) {
                                                    setTimeout(() => {
                                                        treeContainer.scrollTop = scrollTop;
                                                        treeContainer.scrollLeft = scrollLeft;
                                                    }, 0);
                                                }
                                            }
                                        }
                                    });

                                    subItemDiv.addEventListener('contextmenu', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        activeNode = subItem;
                                        showContextMenu(e.pageX, e.pageY);
                                    });

                                    subtaskContainer.appendChild(subItemDiv);

                                    // Collect expanded children for next generation
                                    if (subItem.expanded && subItem.subItems && subItem.subItems.length > 0) {
                                        allExpandedGrandchildren.push(subItem);
                                    }
                                });

                                containerEl.appendChild(subtaskContainer);

                                // Now render ALL children of this generation on the NEXT horizontal row below
                                allExpandedGrandchildren.forEach(expandedChild => {
                                    renderSubtasks(expandedChild, containerEl, phaseNum, nestLevel + 1);
                                });
                            }

                            // Initial call to render subtasks
                            renderSubtasks(item, itemsColumn, node.phase, 0);
                        });

                        tableEl.appendChild(itemsColumn);
                    }

                    // Recursively render next phase
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => buildColumn(child));
                    }
                }
            }

            buildColumn(capexTree);
            container.appendChild(tableEl);

            // Draw dependency lines after rendering
            setTimeout(drawDependencyLines, 100);
        }

        // Draw dependency lines using SVG
        function drawDependencyLines() {
            const svg = document.getElementById('dependency-svg');
            const treeEl = document.getElementById('tree-root');
            const wrapperEl = document.getElementById('tree-transform-wrapper');

            // Clear existing lines
            svg.innerHTML = '';

            // Set SVG dimensions to be large enough for panning/zooming
            // Use a fixed large size that the CSS will position correctly
            svg.setAttribute('width', '20000');
            svg.setAttribute('height', '20000');

            // Add arrow marker definitions
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Create markers for each phase color - using darker vibrant colors
            const colors = {
                'phase-0': '#4CAF50',
                'phase-1': '#2196F3',
                'phase-2': '#FB8C00',
                'cross-phase': '#008F6D'
            };

            Object.entries(colors).forEach(([className, color]) => {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', `arrow-${className}`);
                marker.setAttribute('viewBox', '0 0 10 10');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '5');
                marker.setAttribute('markerWidth', '8');
                marker.setAttribute('markerHeight', '8');
                marker.setAttribute('orient', 'auto');

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                path.setAttribute('fill', color);
                path.setAttribute('opacity', '0.8');
                path.setAttribute('filter', 'drop-shadow(0 2px 2px rgba(0,0,0,0.2))');

                marker.appendChild(path);
                defs.appendChild(marker);
            });

            svg.appendChild(defs);

            // Find all items with dependencies
            function getAllItems(node, items = [], phase = null) {
                if (node.phase !== undefined) phase = node.phase;
                if (node.items) {
                    node.items.forEach(item => items.push({ ...item, currentPhase: phase }));
                }
                if (node.children) {
                    node.children.forEach(child => getAllItems(child, items, phase));
                }
                return items;
            }

            const allItems = getAllItems(capexTree);

            // Helper to find item phase
            function findItemPhase(itemId) {
                const item = allItems.find(i => i.id === itemId);
                return item ? item.currentPhase : null;
            }

            // Draw lines for each dependency
            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    const targetEl = document.querySelector(`[data-item-id="${item.id}"]`);
                    if (!targetEl) return;

                    item.dependencies.forEach(depId => {
                        const sourceEl = document.querySelector(`[data-item-id="${depId}"]`);
                        if (!sourceEl) return;

                        // Get positions in tree's local coordinate space (not viewport)
                        // This accounts for the transform by using offsetLeft/Top instead of getBoundingClientRect
                        function getElementPosition(el) {
                            let x = 0;
                            let y = 0;
                            let current = el;

                            // Walk up to the tree root to get cumulative offset
                            while (current && current !== treeEl.parentElement) {
                                x += current.offsetLeft || 0;
                                y += current.offsetTop || 0;
                                current = current.offsetParent;
                            }

                            return { x, y, width: el.offsetWidth, height: el.offsetHeight };
                        }

                        const sourcePos = getElementPosition(sourceEl);
                        const targetPos = getElementPosition(targetEl);

                        // SVG offset constant (matches CSS top/left offset)
                        const SVG_OFFSET = 5000;

                        const x1 = sourcePos.x + sourcePos.width + SVG_OFFSET;
                        const y1 = sourcePos.y + sourcePos.height / 2 + SVG_OFFSET;
                        const x2 = targetPos.x + SVG_OFFSET;
                        const y2 = targetPos.y + targetPos.height / 2 + SVG_OFFSET;

                        // Determine if cross-phase dependency
                        const sourcePhase = findItemPhase(depId);
                        const targetPhase = item.currentPhase;
                        const isCrossPhase = sourcePhase !== targetPhase;

                        // Skip same-phase dependencies - only draw cross-phase arrows
                        if (!isCrossPhase) return;

                        const lineClass = 'cross-phase';

                        // Create curved path (quadratic bezier)
                        const midX = (x1 + x2) / 2;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const d = `M ${x1} ${y1} Q ${midX} ${y1}, ${midX} ${(y1 + y2) / 2} T ${x2} ${y2}`;

                        path.setAttribute('d', d);
                        path.setAttribute('class', `dependency-line ${lineClass}`);
                        path.setAttribute('marker-end', `url(#arrow-${lineClass})`);

                        // Add tooltip
                        const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                        title.textContent = `${depId} â†’ ${item.id}${isCrossPhase ? ' (cross-phase)' : ''}`;
                        path.appendChild(title);

                        svg.appendChild(path);
                    });
                }
            });

            // =================================================================
            // DRAW PARENT-CHILD CONNECTORS FOR TASKS (Symmetrical Grey Lines)
            // =================================================================
            // Find all subtasks and draw symmetrical connectors to their parent items
            function getAllSubtasksWithParent(node, subtasks = []) {
                if (node.items) {
                    node.items.forEach(item => {
                        if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                            // Collect parent with all its children for symmetrical layout
                            subtasks.push({
                                parent: item,
                                children: item.subItems
                            });

                            // Recursively handle nested tasks
                            item.subItems.forEach(subtask => {
                                if (subtask.subItems && Array.isArray(subtask.subItems) && subtask.subItems.length > 0) {
                                    subtasks.push({
                                        parent: subtask,
                                        children: subtask.subItems
                                    });
                                }
                            });
                        }
                    });
                }
                if (node.children) {
                    node.children.forEach(child => getAllSubtasksWithParent(child, subtasks));
                }
                return subtasks;
            }

            const allParentChildPairs = getAllSubtasksWithParent(capexTree);

            // Helper to get element position
            function getElementPosition(el) {
                let x = 0;
                let y = 0;
                let current = el;

                while (current && current !== treeEl.parentElement) {
                    x += current.offsetLeft || 0;
                    y += current.offsetTop || 0;
                    current = current.offsetParent;
                }

                return { x, y, width: el.offsetWidth, height: el.offsetHeight };
            }

            const SVG_OFFSET = 5000;

            allParentChildPairs.forEach(({ parent, children }) => {
                const parentEl = document.querySelector(`[data-item-id="${parent.id}"]`);
                if (!parentEl) return;

                const parentPos = getElementPosition(parentEl);

                // Draw symmetrical lines from parent to each child
                children.forEach(child => {
                    const childEl = document.querySelector(`[data-item-id="${child.id}"]`);
                    if (!childEl) return;

                    const childPos = getElementPosition(childEl);

                    // Start from bottom-center of parent
                    const x1 = parentPos.x + parentPos.width / 2 + SVG_OFFSET;
                    const y1 = parentPos.y + parentPos.height + SVG_OFFSET;

                    // End at top-center of child
                    const x2 = childPos.x + childPos.width / 2 + SVG_OFFSET;
                    const y2 = childPos.y + SVG_OFFSET;

                    // Create symmetrical line (no arrow head)
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', 'rgba(128, 128, 128, 0.4)');  // Grey
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('opacity', '0.6');

                    // Add tooltip
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = `${parent.name} â†’ ${child.name}`;
                    line.appendChild(title);

                    svg.appendChild(line);
                });
            });
        }


        // Info Panel
        function showInfo(node) {
            const panel = document.getElementById('info-panel');
            const titleElement = document.getElementById('info-title');

            // Enhanced title for subtasks - just the name, prominent
            if (node.type === 'subtask') {
                titleElement.innerHTML = `
                    <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); line-height: 1.3;">
                        ${node.name}
                    </div>
                `;
            } else {
                titleElement.textContent = `${node.icon || 'ðŸ“„'} ${node.name}`;
            }

            const body = document.getElementById('info-body');

            // Build dependencies section
            let depsHtml = '';
            if (node.dependencies && node.dependencies.length > 0) {
                const depNames = node.dependencies.map(depId => {
                    // Find the dependency item to get its name
                    function findItemById(id, n = capexTree) {
                        if (n.id === id) return n;
                        if (n.items) {
                            const found = n.items.find(i => i.id === id);
                            if (found) return found;
                        }
                        if (n.children) {
                            for (let child of n.children) {
                                const found = findItemById(id, child);
                                if (found) return found;
                            }
                        }
                        return null;
                    }
                    const depItem = findItemById(depId);
                    return depItem ? `${depItem.icon} ${depItem.name}` : depId;
                }).join('<br>');

                depsHtml = `
                    <div class="info-section">
                        <h4>Dependencies</h4>
                        <p style="line-height: 1.8;">${depNames}</p>
                    </div>
                `;
            }

            // Build dependents section (items that depend on this one)
            let dependentsHtml = '';
            if (node.id) {
                function findDependents(nodeId, n = capexTree, dependents = []) {
                    if (n.items) {
                        n.items.forEach(item => {
                            if (item.dependencies && item.dependencies.includes(nodeId)) {
                                dependents.push(item);
                            }
                        });
                    }
                    if (n.children) {
                        n.children.forEach(child => findDependents(nodeId, child, dependents));
                    }
                    return dependents;
                }

                const dependents = findDependents(node.id);
                if (dependents.length > 0) {
                    const depList = dependents.map(d => `${d.icon} ${d.name}`).join('<br>');
                    dependentsHtml = `
                        <div class="info-section">
                            <h4>Required By</h4>
                            <p style="line-height: 1.8;">${depList}</p>
                        </div>
                    `;
                }
            }

            // Build PM Dashboard section for subtasks (only if pattern has tracking enabled)
            let pmDashboardHtml = '';
            const pattern = PATTERNS[currentPattern];
            const hasTracking = pattern.fields?.includeTracking === true;

            if (node.type === 'subtask' && hasTracking) {
                const statusColors = {
                    'To Do': { bg: 'rgba(156, 163, 175, 0.3)', color: '#9CA3AF' },
                    'In Progress': { bg: 'rgba(59, 130, 246, 0.3)', color: '#3B82F6' },
                    'Completed': { bg: 'rgba(16, 185, 129, 0.3)', color: '#10B981' },
                    'Blocked': { bg: 'rgba(239, 68, 68, 0.3)', color: '#EF4444' }
                };
                const statusStyle = statusColors[node.pmStatus] || statusColors['To Do'];

                const priorityEmojis = { 'Low': 'ðŸŸ¢', 'Medium': 'ðŸŸ¡', 'High': 'ðŸŸ ', 'Critical': 'ðŸ”´' };
                const priorityEmoji = priorityEmojis[node.pmPriority] || 'âšª';

                // Calculate days until/since due date
                let dueDateInfo = '';
                if (node.pmDueDate) {
                    const dueDate = new Date(node.pmDueDate);
                    const today = new Date();
                    const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                    if (diffDays < 0) {
                        dueDateInfo = `<span style="color: #EF4444; font-weight: 600;">âš ï¸ ${Math.abs(diffDays)} days overdue</span>`;
                    } else if (diffDays === 0) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">ðŸ“… Due today!</span>`;
                    } else if (diffDays <= 3) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">â° ${diffDays} days left</span>`;
                    } else {
                        dueDateInfo = `<span style="color: var(--text-secondary);">${diffDays} days left</span>`;
                    }
                }

                pmDashboardHtml = `
                    <!-- Status + Progress Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: ${statusStyle.bg}; border-radius: 10px; border: 2px solid ${statusStyle.color};">
                            <div style="font-size: 28px; font-weight: 700; color: ${statusStyle.color};">
                                ${node.pmStatus || 'To Do'}
                            </div>
                        </div>
                        <div style="flex: 1; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); border-radius: 10px; border: 2px solid rgba(0, 166, 125, 0.4); display: flex; flex-direction: column; justify-content: center;">
                            <div style="font-size: 36px; font-weight: 700; color: var(--treeplex-primary); line-height: 1;">${node.pmProgress || 0}%</div>
                            <div style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden; margin-top: 8px;">
                                <div style="height: 100%; width: ${node.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Owner + Priority Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; align-items: center; gap: 12px;">
                            <div style="width: 48px; height: 48px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: 700; color: white; flex-shrink: 0;">
                                ${node.pmAssignee ? node.pmAssignee.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2) : '?'}
                            </div>
                            <div style="font-size: 18px; font-weight: 600;">${node.pmAssignee || 'Unassigned'}</div>
                        </div>
                        <div style="width: 120px; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <div style="font-size: 40px; margin-bottom: 4px;">${priorityEmoji}</div>
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-secondary);">${node.pmPriority || 'Medium'}</div>
                        </div>
                    </div>

                    <!-- Timeline -->
                    <div style="padding: 16px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-around; margin-bottom: 12px;">
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">ðŸ“…</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmStartDate ? new Date(node.pmStartDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                            <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
                                <div style="height: 2px; flex: 1; background: linear-gradient(90deg, var(--treeplex-primary), transparent);"></div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">ðŸŽ¯</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmDueDate ? new Date(node.pmDueDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                        </div>
                        ${dueDateInfo ? `<div style="text-align: center; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; font-size: 13px;">${dueDateInfo}</div>` : ''}
                    </div>

                    <!-- Notes -->
                    ${node.pmNotes ? `
                        <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; border-left: 4px solid var(--treeplex-primary); margin-bottom: 16px;">
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary);">${node.pmNotes}</div>
                        </div>
                    ` : ''}

                    <!-- Blocking Issue -->
                    ${node.pmBlockingIssue ? `
                        <div style="padding: 14px; background: rgba(239, 68, 68, 0.15); border-radius: 10px; border-left: 4px solid #EF4444; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">ðŸš§</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #FCA5A5;">${node.pmBlockingIssue}</div>
                        </div>
                    ` : ''}

                    <!-- Next Steps -->
                    ${node.pmNextSteps ? `
                        <div style="padding: 14px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; border-left: 4px solid #3B82F6; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">âž¡ï¸</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #93C5FD;">${node.pmNextSteps}</div>
                        </div>
                    ` : ''}

                    <!-- Latest Updates -->
                    ${node.pmUpdates && node.pmUpdates.length > 0 ? `
                        <div style="max-height: 300px; overflow-y: auto;">
                            ${node.pmUpdates.map(update => `
                                <div style="margin-bottom: 10px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 6px;">
                                        ðŸ“… ${new Date(update.timestamp).toLocaleString('en-US', {month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'})}
                                    </div>
                                    <div style="font-size: 13px; line-height: 1.5; white-space: pre-wrap;">${update.text}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            }

            // Build pattern-specific infographic (geometric and visual)
            let patternInfoHtml = '';

            // SALES PIPELINE - Funnel with probability
            if (currentPattern === 'sales' && (node.dealValue || node.stageProbability || node.expectedCloseDate || node.competitorInfo)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(16, 185, 129, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #10B981; margin-bottom: 8px;">ðŸ’¼ Sales Deal Pipeline</div>
                        </div>

                        <!-- Deal Value + Probability Row -->
                        <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                            ${node.dealValue ? `
                                <div style="flex: 1; padding: 20px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ðŸ’° Deal Value</div>
                                    <div style="font-size: 32px; font-weight: 700; color: #10B981;">$${node.dealValue.toLocaleString()}</div>
                                </div>
                            ` : ''}
                            ${node.stageProbability !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ðŸ“Š Close Probability</div>
                                    <div style="font-size: 32px; font-weight: 700; color: #3B82F6;">${node.stageProbability}%</div>
                                    <div style="width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; overflow: hidden; margin-top: 12px;">
                                        <div style="height: 100%; width: ${node.stageProbability}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Expected Revenue (Value Ã— Probability) -->
                        ${node.dealValue && node.stageProbability !== undefined ? `
                            <div style="text-align: center; padding: 16px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; margin-bottom: 20px;">
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">Expected Revenue (Value Ã— Probability)</div>
                                <div style="font-size: 24px; font-weight: 700; color: #F59E0B;">$${Math.round(node.dealValue * (node.stageProbability / 100)).toLocaleString()}</div>
                            </div>
                        ` : ''}

                        <!-- Timeline & Contact -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.expectedCloseDate ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“… Target Close</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${new Date(node.expectedCloseDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                            ${node.contactPerson ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‘¤ Contact</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.contactPerson}</div>
                                </div>
                            ` : ''}
                            ${node.leadSource ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“ Source</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.leadSource}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Competitor Info -->
                        ${node.competitorInfo ? `
                            <div style="padding: 16px; background: rgba(239, 68, 68, 0.12); border-left: 4px solid #EF4444; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #EF4444; margin-bottom: 8px; text-transform: uppercase;">ðŸŽ¯ Competitive Landscape</div>
                                <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.competitorInfo}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILM/VIDEO - Scene storyboard card
            else if (currentPattern === 'film' && (node.videoPrompt || node.aiPlatform || node.cameraMovement)) {
                const platformColors = {
                    'Sora (OpenAI)': '#74aa9c',
                    'Veo 3 (Google)': '#4285f4',
                    'Runway Gen-3': '#6366f1',
                    'Pika 2.0': '#f59e0b',
                    'Testing Multiple': '#8b5cf6'
                };
                const platformColor = platformColors[node.aiPlatform] || '#9ca3af';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ðŸŽ¬ AI Video Scene</div>
                        </div>

                        <!-- Platform & Technical Specs -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.aiPlatform ? `
                                <div style="padding: 12px; background: rgba(${parseInt(platformColor.slice(1, 3), 16)}, ${parseInt(platformColor.slice(3, 5), 16)}, ${parseInt(platformColor.slice(5, 7), 16)}, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Platform</div>
                                    <div style="font-size: 13px; font-weight: 600; color: ${platformColor};">ðŸ¤– ${node.aiPlatform}</div>
                                </div>
                            ` : ''}
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #3B82F6;">â±ï¸ ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.aspectRatio ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Ratio</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #10B981;">ðŸ“ ${node.aspectRatio.split(' ')[0]}</div>
                                </div>
                            ` : ''}
                            ${node.visualStyle ? `
                                <div style="padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Style</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #A78BFA;">ðŸŽ¨ ${node.visualStyle}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Cinematography -->
                        ${node.cameraMovement || node.lightingMood || node.motionIntensity ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 12px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 12px; text-transform: uppercase;">ðŸŽ¥ Cinematography</div>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                    ${node.cameraMovement && node.cameraMovement !== 'Static' ? `
                                        <div style="padding: 8px 14px; background: rgba(245, 158, 11, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #F59E0B;">
                                            ðŸ“¹ ${node.cameraMovement}
                                        </div>
                                    ` : ''}
                                    ${node.lightingMood ? `
                                        <div style="padding: 8px 14px; background: rgba(251, 191, 36, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #FCD34D;">
                                            ðŸ’¡ ${node.lightingMood}
                                        </div>
                                    ` : ''}
                                    ${node.motionIntensity ? `
                                        <div style="padding: 8px 14px; background: rgba(59, 130, 246, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #60A5FA;">
                                            ðŸŒŠ ${node.motionIntensity}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}

                        <!-- Video Prompt (Main) -->
                        ${node.videoPrompt ? `
                            <div style="padding: 16px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid var(--treeplex-primary); border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px; text-transform: uppercase;">âœï¸ Video Prompt</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">${node.videoPrompt}</div>
                            </div>
                        ` : ''}

                        <!-- Iteration Notes -->
                        ${node.iterationNotes ? `
                            <div style="padding: 14px; background: rgba(139, 92, 246, 0.12); border-left: 4px solid #A78BFA; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #A78BFA; margin-bottom: 6px; text-transform: uppercase;">ðŸ“ Generation Notes</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.iterationNotes}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // PHILOSOPHY - Logical argument structure (already implemented)
            else if (currentPattern === 'philosophy' && (node.premise1 || node.premise2 || node.conclusion || node.objection || node.response)) {
                // Philosophy Pattern Infographic
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ðŸ¤” Philosophical Argument Structure</div>
                            ${node.speaker ? `<div style="font-size: 14px; color: var(--text-secondary);">ðŸ—£ï¸ Speaker: <span style="color: var(--text-primary); font-weight: 600;">${node.speaker}</span></div>` : ''}
                        </div>

                        <!-- Argument Metadata Row -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.argumentType ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Argument Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #60A5FA;">ðŸŽ¯ ${node.argumentType}</div>
                                </div>
                            ` : ''}
                            ${node.validity ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: ${node.validity === 'Valid' || node.validity === 'Sound' ? 'rgba(16, 185, 129, 0.15)' : 'rgba(239, 68, 68, 0.15)'}; border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Validity</div>
                                    <div style="font-size: 14px; font-weight: 600; color: ${node.validity === 'Valid' || node.validity === 'Sound' ? '#10B981' : '#EF4444'};">âœ“ ${node.validity}</div>
                                </div>
                            ` : ''}
                            ${node.philosophicalSchool ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">School</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">ðŸ›ï¸ ${node.philosophicalSchool}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Argument Flow: Premises â†’ Conclusion -->
                        ${node.premise1 || node.premise2 || node.conclusion ? `
                            <div style="margin-bottom: 24px;">
                                <div style="text-align: center; font-size: 13px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px;">âš¡ Logical Structure</div>

                                ${node.premise1 ? `
                                    <div style="position: relative; margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">1ï¸âƒ£ Premise 1</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.premise1}</div>
                                        </div>
                                        <div style="text-align: center; margin: 8px 0; font-size: 20px; color: var(--treeplex-primary);">â†“</div>
                                    </div>
                                ` : ''}

                                ${node.premise2 ? `
                                    <div style="position: relative; margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">2ï¸âƒ£ Premise 2</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.premise2}</div>
                                        </div>
                                        <div style="text-align: center; margin: 8px 0; font-size: 20px; color: var(--treeplex-primary);">â†“</div>
                                    </div>
                                ` : ''}

                                ${node.conclusion ? `
                                    <div style="position: relative;">
                                        <div style="text-align: center; margin-bottom: 8px;">
                                            <span style="display: inline-block; padding: 6px 16px; background: var(--treeplex-primary); color: white; border-radius: 20px; font-size: 13px; font-weight: 700;">âˆ´ THEREFORE</span>
                                        </div>
                                        <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1)); border: 2px solid #10B981; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">âœ“ Conclusion</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; font-weight: 500;">${node.conclusion}</div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Objection & Response (Dialectic) -->
                        ${node.objection || node.response ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 13px; font-weight: 700; color: #F59E0B; margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px;">âš”ï¸ Dialectical Challenge</div>

                                ${node.objection ? `
                                    <div style="margin-bottom: 12px;">
                                        <div style="background: rgba(239, 68, 68, 0.12); border-left: 4px solid #EF4444; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #EF4444; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">âŒ Objection</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.objection}</div>
                                        </div>
                                    </div>
                                ` : ''}

                                ${node.response ? `
                                    <div style="text-align: center; margin: 12px 0; font-size: 16px; color: var(--treeplex-primary);">â¤·</div>
                                    <div style="margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">ðŸ’¡ Response to Objection</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.response}</div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Key Concepts & References -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.keyTerms ? `
                                <div style="flex: 1; min-width: 200px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“ Key Terms</div>
                                    <div style="font-size: 13px; line-height: 1.5; color: var(--text-primary);">${node.keyTerms}</div>
                                </div>
                            ` : ''}
                            ${node.textualReference ? `
                                <div style="flex: 1; min-width: 200px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“– Reference</div>
                                    <div style="font-size: 13px; line-height: 1.5; color: var(--text-primary); font-family: monospace;">${node.textualReference}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // THESIS - Academic structure with argument â†’ evidence
            else if (currentPattern === 'thesis' && (node.keyArgument || node.citations || node.evidenceType)) {
                const progressPercent = node.targetWordCount ? Math.min(100, Math.round((node.wordCount / node.targetWordCount) * 100)) : 0;

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(16, 185, 129, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #10B981; margin-bottom: 8px;">ðŸŽ“ Academic Section</div>
                        </div>

                        <!-- Word Count Progress -->
                        ${node.wordCount !== undefined || node.targetWordCount ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-radius: 10px; margin-bottom: 20px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="font-size: 13px; color: var(--text-secondary);">ðŸ“ Word Count</span>
                                    <span style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.wordCount || 0} / ${node.targetWordCount || '?'} words</span>
                                </div>
                                ${node.targetWordCount ? `
                                    <div style="width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; overflow: hidden;">
                                        <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                    <div style="text-align: center; margin-top: 6px; font-size: 12px; color: var(--text-secondary);">${progressPercent}% complete</div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Draft Status + Evidence Type -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.draftStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Status</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B;">âœï¸ ${node.draftStatus}</div>
                                </div>
                            ` : ''}
                            ${node.evidenceType ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Evidence</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">ðŸ”¬ ${node.evidenceType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Key Argument (Central claim) -->
                        ${node.keyArgument ? `
                            <div style="padding: 16px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase;">ðŸ’¡ Key Argument</div>
                                <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.keyArgument}</div>
                            </div>
                        ` : ''}

                        <!-- Citations -->
                        ${node.citations ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid #9ca3af; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">ðŸ“š Key Citations</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.citations}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // ROADMAP - Feature card with user impact & technical risk
            else if (currentPattern === 'roadmap' && (node.storyPoints || node.userImpact || node.technicalRisk)) {
                const impactColors = { 'High': '#10B981', 'Medium': '#F59E0B', 'Low': '#9CA3AF' };
                const riskColors = { 'Low': '#10B981', 'Medium': '#F59E0B', 'High': '#EF4444', 'Unknown': '#9CA3AF' };

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ðŸš€ Product Feature</div>
                        </div>

                        <!-- Story Points (Large) -->
                        ${node.storyPoints !== undefined ? `
                            <div style="text-align: center; padding: 24px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.1)); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">Effort Estimate</div>
                                <div style="font-size: 48px; font-weight: 700; color: var(--treeplex-primary); line-height: 1;">${node.storyPoints}</div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">Story Points</div>
                            </div>
                        ` : ''}

                        <!-- Impact & Risk Matrix -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
                            ${node.userImpact ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(impactColors[node.userImpact].slice(1, 3), 16)}, ${parseInt(impactColors[node.userImpact].slice(3, 5), 16)}, ${parseInt(impactColors[node.userImpact].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">User Impact</div>
                                    <div style="font-size: 20px; font-weight: 700; color: ${impactColors[node.userImpact]};">ðŸ‘¥ ${node.userImpact}</div>
                                </div>
                            ` : ''}
                            ${node.technicalRisk ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(riskColors[node.technicalRisk].slice(1, 3), 16)}, ${parseInt(riskColors[node.technicalRisk].slice(3, 5), 16)}, ${parseInt(riskColors[node.technicalRisk].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Technical Risk</div>
                                    <div style="font-size: 20px; font-weight: 700; color: ${riskColors[node.technicalRisk]};">âš ï¸ ${node.technicalRisk}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Engineering Estimate & Feature Flag -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.engineeringEstimate ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">â±ï¸ Estimate</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.engineeringEstimate}</div>
                                </div>
                            ` : ''}
                            ${node.featureFlag ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸš© Feature Flag</div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--treeplex-primary); font-family: monospace;">${node.featureFlag}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // PROMPTING - Layered prompt structure
            else if (currentPattern === 'prompting' && (node.systemPrompt || node.userPromptTemplate || node.fewShotExamples)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(167, 139, 250, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(139, 92, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #8B5CF6; margin-bottom: 8px;">ðŸ§  Prompt Structure</div>
                        </div>

                        <!-- Model + Temperature -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.modelTarget ? `
                                <div style="flex: 1; min-width: 180px; padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Target Model</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #60A5FA;">ðŸ¤– ${node.modelTarget}</div>
                                </div>
                            ` : ''}
                            ${node.temperature !== undefined ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Temperature</div>
                                    <div style="font-size: 18px; font-weight: 700; color: #F59E0B;">ðŸ”¥ ${node.temperature}</div>
                                </div>
                            ` : ''}
                            ${node.maxTokens ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Max Tokens</div>
                                    <div style="font-size: 18px; font-weight: 700; color: #10B981;">ðŸ“ ${node.maxTokens}</div>
                                </div>
                            ` : ''}
                            ${node.testStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Status</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #A78BFA;">âœ… ${node.testStatus}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Layered Structure -->
                        ${node.systemPrompt ? `
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #8B5CF6; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 1: SYSTEM</span>
                                </div>
                                <div style="padding: 14px; background: rgba(139, 92, 246, 0.12); border-left: 4px solid #8B5CF6; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.systemPrompt}</div>
                                </div>
                            </div>
                        ` : ''}

                        ${node.userPromptTemplate ? `
                            <div style="text-align: center; margin: 12px 0; font-size: 18px; color: var(--treeplex-primary);">â†“</div>
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #3B82F6; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 2: USER PROMPT</span>
                                </div>
                                <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.userPromptTemplate}</div>
                                </div>
                            </div>
                        ` : ''}

                        ${node.fewShotExamples ? `
                            <div style="text-align: center; margin: 12px 0; font-size: 18px; color: var(--treeplex-primary);">â†“</div>
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #10B981; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 3: FEW-SHOT EXAMPLES</span>
                                </div>
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.fewShotExamples}</div>
                                </div>
                            </div>
                        ` : ''}

                        <!-- Test Results -->
                        ${node.testResults ? `
                            <div style="padding: 14px; background: rgba(245, 158, 11, 0.12); border-left: 4px solid #F59E0B; border-radius: 8px; margin-top: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 6px; text-transform: uppercase;">âœ… Test Results</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.testResults}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // BOOK - Narrative arc card
            else if (currentPattern === 'book' && (node.povCharacter || node.sceneSetting || node.plotFunction)) {
                const progressPercent = node.targetWordCount ? Math.min(100, Math.round((node.wordCount / node.targetWordCount) * 100)) : 0;

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.08), rgba(251, 146, 60, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(245, 158, 11, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #F59E0B; margin-bottom: 8px;">ðŸ“š Narrative Scene</div>
                        </div>

                        <!-- Word Count -->
                        ${node.wordCount !== undefined || node.targetWordCount ? `
                            <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-radius: 10px; margin-bottom: 16px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 12px; color: var(--text-secondary);">ðŸ“ Words</span>
                                    <span style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.wordCount || 0} / ${node.targetWordCount || '?'}</span>
                                </div>
                                ${node.targetWordCount ? `
                                    <div style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden;">
                                        <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- POV + Plot Function -->
                        <div style="display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">
                            ${node.povCharacter ? `
                                <div style="flex: 1; min-width: 180px; padding: 14px; background: rgba(139, 92, 246, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‘¤ POV Character</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #A78BFA;">${node.povCharacter}</div>
                                </div>
                            ` : ''}
                            ${node.plotFunction ? `
                                <div style="flex: 1; min-width: 180px; padding: 14px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“– Plot Function</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #10B981;">${node.plotFunction}</div>
                                </div>
                            ` : ''}
                            ${node.draftStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 14px; background: rgba(245, 158, 11, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">Status</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #F59E0B;">âœï¸ ${node.draftStatus}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Scene Setting -->
                        ${node.sceneSetting ? `
                            <div style="padding: 16px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid #F59E0B; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 8px; text-transform: uppercase;">ðŸŽ­ Scene Setting</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.sceneSetting}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // COURSE - Learning module
            else if (currentPattern === 'course' && (node.learningObjectives || node.duration || node.assessmentType)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(96, 165, 250, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">ðŸ“– Learning Module</div>
                        </div>

                        <!-- Duration + Difficulty + Assessment -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #10B981;">â±ï¸ ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.difficultyLevel ? `
                                <div style="padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Level</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B;">ðŸ“Š ${node.difficultyLevel}</div>
                                </div>
                            ` : ''}
                            ${node.assessmentType ? `
                                <div style="padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Assessment</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">âœ… ${node.assessmentType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Learning Objectives -->
                        ${node.learningObjectives ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase;">ðŸŽ“ Learning Objectives</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.learningObjectives}</div>
                            </div>
                        ` : ''}

                        <!-- Prerequisites & Resources -->
                        ${node.prerequisites || node.resourcesNeeded ? `
                            <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                                ${node.prerequisites ? `
                                    <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">ðŸ“‹ Prerequisites</div>
                                        <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.prerequisites}</div>
                                    </div>
                                ` : ''}
                                ${node.resourcesNeeded ? `
                                    <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">ðŸ“š Resources</div>
                                        <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.resourcesNeeded}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // EVENT PLANNING - Timeline with logistics grid
            else if (currentPattern === 'event' && (node.budget || node.vendor || node.guestCount || node.bookingDeadline)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(236, 72, 153, 0.08), rgba(219, 39, 119, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(236, 72, 153, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #EC4899; margin-bottom: 8px;">ðŸŽ‰ Event Activity</div>
                        </div>

                        <!-- Budget + Guest Count -->
                        <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                            ${node.budget !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ðŸ’° Budget</div>
                                    <div style="font-size: 28px; font-weight: 700; color: #10B981;">$${node.budget.toLocaleString()}</div>
                                </div>
                            ` : ''}
                            ${node.guestCount !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ðŸ‘¥ Guests</div>
                                    <div style="font-size: 28px; font-weight: 700; color: #3B82F6;">${node.guestCount}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Vendor + Location + Deadline -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            ${node.vendor ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ¢ Vendor</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.vendor}</div>
                                </div>
                            ` : ''}
                            ${node.location ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“ Location</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.location}</div>
                                </div>
                            ` : ''}
                            ${node.responsiblePerson ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‘¤ Owner</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.responsiblePerson}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Booking Deadline (Urgent Banner) -->
                        ${node.bookingDeadline ? `
                            <div style="padding: 16px; background: rgba(245, 158, 11, 0.15); border-left: 4px solid #F59E0B; border-radius: 8px; text-align: center;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 6px; text-transform: uppercase;">ðŸ“… Booking Deadline</div>
                                <div style="font-size: 18px; font-weight: 700; color: var(--text-primary);">${new Date(node.bookingDeadline).toLocaleDateString('en-US', {weekday: 'long', month: 'short', day: 'numeric', year: 'numeric'})}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FITNESS PROGRAM - Exercise card with sets/reps grid
            else if (currentPattern === 'fitness' && (node.sets || node.reps || node.duration || node.intensity)) {
                const intensityColors = { 'Light': '#10B981', 'Moderate': '#F59E0B', 'High': '#EF4444', 'Max': '#DC2626' };
                const intensityColor = intensityColors[node.intensity] || '#9CA3AF';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.08), rgba(220, 38, 38, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(239, 68, 68, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #EF4444; margin-bottom: 8px;">ðŸ’ª Exercise Specification</div>
                        </div>

                        <!-- Sets Ã— Reps (Large Display) -->
                        ${node.sets || node.reps ? `
                            <div style="text-align: center; padding: 24px; background: rgba(239, 68, 68, 0.15); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 48px; font-weight: 700; color: #EF4444; line-height: 1;">
                                    ${node.sets || '?'} <span style="font-size: 32px; color: var(--text-secondary);">Ã—</span> ${node.reps || '?'}
                                </div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-top: 8px;">Sets Ã— Reps</div>
                            </div>
                        ` : ''}

                        <!-- Duration + Intensity + Rest -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #3B82F6;">â±ï¸ ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.intensity ? `
                                <div style="padding: 12px; background: rgba(${parseInt(intensityColor.slice(1, 3), 16)}, ${parseInt(intensityColor.slice(3, 5), 16)}, ${parseInt(intensityColor.slice(5, 7), 16)}, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Intensity</div>
                                    <div style="font-size: 16px; font-weight: 600; color: ${intensityColor};">ðŸ”¥ ${node.intensity}</div>
                                </div>
                            ` : ''}
                            ${node.restPeriod ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Rest</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #10B981;">â¸ï¸ ${node.restPeriod}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Equipment -->
                        ${node.equipment ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‹ï¸ Equipment</div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.equipment}</div>
                            </div>
                        ` : ''}

                        <!-- Form Cues -->
                        ${node.formCues ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase;">âœ… Form Cues</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.formCues}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // STRATEGY - Strategic initiative card with metrics
            else if (currentPattern === 'strategy' && (node.investment || node.keyMetric || node.strategicTheme)) {
                const themeColors = { 'Growth': '#10B981', 'Efficiency': '#3B82F6', 'Innovation': '#8B5CF6', 'Transformation': '#F59E0B', 'Risk Mitigation': '#EF4444' };
                const themeColor = themeColors[node.strategicTheme] || '#9CA3AF';
                const riskColors = { 'Low': '#10B981', 'Medium': '#F59E0B', 'High': '#EF4444' };

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(37, 99, 235, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">ðŸ“Š Strategic Initiative</div>
                        </div>

                        <!-- Investment (Large) -->
                        ${node.investment !== undefined ? `
                            <div style="text-align: center; padding: 24px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">Capital Investment</div>
                                <div style="font-size: 40px; font-weight: 700; color: #10B981; line-height: 1;">$${node.investment.toLocaleString()}</div>
                            </div>
                        ` : ''}

                        <!-- Strategic Theme + Risk Level -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
                            ${node.strategicTheme ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(themeColor.slice(1, 3), 16)}, ${parseInt(themeColor.slice(3, 5), 16)}, ${parseInt(themeColor.slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Theme</div>
                                    <div style="font-size: 18px; font-weight: 700; color: ${themeColor};">ðŸŽ­ ${node.strategicTheme}</div>
                                </div>
                            ` : ''}
                            ${node.riskLevel ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(riskColors[node.riskLevel].slice(1, 3), 16)}, ${parseInt(riskColors[node.riskLevel].slice(3, 5), 16)}, ${parseInt(riskColors[node.riskLevel].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Risk</div>
                                    <div style="font-size: 18px; font-weight: 700; color: ${riskColors[node.riskLevel]};">âš ï¸ ${node.riskLevel}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Key Metric â†’ Target Value -->
                        ${node.keyMetric || node.targetValue ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 12px; font-weight: 700; color: #3B82F6; margin-bottom: 12px; text-transform: uppercase;">ðŸ“ˆ Success Metrics</div>
                                ${node.keyMetric ? `
                                    <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 10px;">
                                        <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 4px; text-transform: uppercase;">ðŸ“Š Key Metric</div>
                                        <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.keyMetric}</div>
                                    </div>
                                ` : ''}
                                ${node.targetValue ? `
                                    <div style="text-align: center; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸŽ¯ Target</div>
                                        <div style="font-size: 20px; font-weight: 700; color: #10B981;">${node.targetValue}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Executive Owner -->
                        ${node.responsibleExecutive ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‘” Executive Sponsor</div>
                                <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.responsibleExecutive}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FAMILY TREE - Person card with genealogy info
            else if (currentPattern === 'familytree' && (node.fullName || node.birthDate || node.birthPlace)) {
                const isLiving = node.livingStatus === 'Living';
                const statusColor = isLiving ? '#10B981' : '#9CA3AF';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(124, 58, 237, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(139, 92, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #8B5CF6; margin-bottom: 8px;">ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family Member</div>
                        </div>

                        <!-- Full Name + Living Status -->
                        ${node.fullName ? `
                            <div style="text-align: center; padding: 20px; background: rgba(139, 92, 246, 0.15); border-radius: 10px; margin-bottom: 20px;">
                                <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">${node.fullName}</div>
                                ${node.maidenName ? `<div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">(nÃ©e ${node.maidenName})</div>` : ''}
                                ${node.livingStatus ? `
                                    <div style="display: inline-block; padding: 6px 14px; background: rgba(${parseInt(statusColor.slice(1, 3), 16)}, ${parseInt(statusColor.slice(3, 5), 16)}, ${parseInt(statusColor.slice(5, 7), 16)}, 0.2); border-radius: 20px; font-size: 12px; font-weight: 600; color: ${statusColor};">
                                        ${isLiving ? 'ðŸ’š' : 'ðŸ•Šï¸'} ${node.livingStatus}
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Birth & Death Info -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            ${node.birthDate || node.birthPlace ? `
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase;">ðŸŽ‚ Birth</div>
                                    ${node.birthDate ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${new Date(node.birthDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                    ${node.birthPlace ? `<div style="font-size: 13px; color: var(--text-secondary);">ðŸ“ ${node.birthPlace}</div>` : ''}
                                </div>
                            ` : ''}
                            ${node.deathDate || node.deathPlace ? `
                                <div style="padding: 14px; background: rgba(156, 163, 175, 0.12); border-left: 4px solid #9CA3AF; border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: #9CA3AF; margin-bottom: 8px; text-transform: uppercase;">ðŸ•Šï¸ Death</div>
                                    ${node.deathDate ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${new Date(node.deathDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                    ${node.deathPlace ? `<div style="font-size: 13px; color: var(--text-secondary);">ðŸ“ ${node.deathPlace}</div>` : ''}
                                </div>
                            ` : ''}
                        </div>

                        <!-- Marriage & Family -->
                        ${node.spouseName || node.marriageDate ? `
                            <div style="padding: 14px; background: rgba(236, 72, 153, 0.12); border-left: 4px solid #EC4899; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #EC4899; margin-bottom: 8px; text-transform: uppercase;">ðŸ’‘ Marriage</div>
                                ${node.spouseName ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">Spouse: ${node.spouseName}</div>` : ''}
                                ${node.marriageDate ? `<div style="font-size: 13px; color: var(--text-secondary);">${new Date(node.marriageDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                ${node.marriagePlace ? `<div style="font-size: 13px; color: var(--text-secondary);">ðŸ“ ${node.marriagePlace}</div>` : ''}
                            </div>
                        ` : ''}

                        <!-- Occupation & Gender & Relationship -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 16px;">
                            ${node.gender ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Gender</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">âš§ ${node.gender}</div>
                                </div>
                            ` : ''}
                            ${node.occupation ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Occupation</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">ðŸ’¼ ${node.occupation}</div>
                                </div>
                            ` : ''}
                            ${node.relationshipType ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Relationship</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">ðŸ”— ${node.relationshipType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- DNA Info -->
                        ${node.dnaInfo ? `
                            <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 6px; text-transform: uppercase;">ðŸ§¬ DNA / Genetic Info</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.dnaInfo}</div>
                            </div>
                        ` : ''}

                        <!-- Sources -->
                        ${node.sources ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid #9ca3af; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“„ Sources</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.sources}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILE SYSTEM - File preview/open button with thumbnail
            else if (currentPattern === 'filesystem' && !node.isFolder && (node.fileUrl || node.filePath)) {
                // Format file size
                const formatFileSize = (bytes) => {
                    if (!bytes) return 'Unknown size';
                    if (bytes < 1024) return bytes + ' B';
                    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                    if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                    return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
                };

                // Get file icon based on extension
                const fileIcon = node.icon || getFileIcon(node.name, false);
                const fileSize = formatFileSize(node.fileSize);

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ðŸ’¾ File Details</div>
                        </div>

                        <!-- File Thumbnail/Icon & Open Button -->
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 16px; margin-bottom: 20px;">
                            <!-- Large Icon -->
                            <div style="font-size: 80px; line-height: 1;">${fileIcon}</div>

                            <!-- File Name -->
                            <div style="font-size: 18px; font-weight: 600; color: var(--text-primary); text-align: center; word-break: break-all;">
                                ${node.name}
                            </div>

                            <!-- Open File Button -->
                            ${node.fileUrl ? `
                                <button onclick="window.open('${node.fileUrl}', '_blank')"
                                        style="padding: 14px 32px;
                                               background: linear-gradient(135deg, #6366f1, #8b5cf6);
                                               border: none;
                                               border-radius: 12px;
                                               color: white;
                                               font-size: 16px;
                                               font-weight: 700;
                                               cursor: pointer;
                                               transition: all 0.2s;
                                               box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);"
                                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(99, 102, 241, 0.4)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(99, 102, 241, 0.3)'">
                                    ðŸ”— Open File
                                </button>
                            ` : ''}
                        </div>

                        <!-- File Metadata Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.fileSize ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ“Š Size</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${fileSize}</div>
                                </div>
                            ` : ''}
                            ${node.fileExtension ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ·ï¸ Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.fileExtension}</div>
                                </div>
                            ` : ''}
                            ${node.dateModified ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ•’ Modified</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary);">${new Date(node.dateModified).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                            ${node.dateCreated ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ“… Created</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary);">${new Date(node.dateCreated).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- File Path -->
                        ${node.filePath ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid var(--treeplex-primary); border-radius: 8px; margin-bottom: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“‚ Path</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); font-family: monospace; word-break: break-all;">${node.filePath}</div>
                            </div>
                        ` : ''}

                        <!-- Permissions & Owner -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.permissions ? `
                                <div style="flex: 1; min-width: 150px; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">ðŸ”’ Permissions</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #10B981;">${node.permissions}</div>
                                </div>
                            ` : ''}
                            ${node.fileOwner ? `
                                <div style="flex: 1; min-width: 150px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">ðŸ‘¤ Owner</div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${node.fileOwner}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Shared With -->
                        ${node.sharedWith ? `
                            <div style="padding: 14px; background: rgba(168, 85, 247, 0.15); border-left: 4px solid #a855f7; border-radius: 8px; margin-top: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: #a855f7; margin-bottom: 6px; text-transform: uppercase;">ðŸ‘¥ Shared With</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary);">${node.sharedWith}</div>
                            </div>
                        ` : ''}

                        <!-- Tags -->
                        ${node.tags ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-top: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ·ï¸ Tags</div>
                                <div style="font-size: 13px; color: var(--text-primary);">${node.tags}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILESYSTEM - File/Folder info card with Open button
            let filesystemInfoHtml = '';
            if (currentPattern === 'filesystem' && node.type === 'item') {
                const formatFileSize = (bytes) => {
                    if (!bytes || bytes === 0) return 'N/A';
                    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
                    let size = bytes;
                    let unitIndex = 0;
                    while (size >= 1024 && unitIndex < units.length - 1) {
                        size /= 1024;
                        unitIndex++;
                    }
                    return `${size.toFixed(2)} ${units[unitIndex]}`;
                };

                const formatDate = (dateStr) => {
                    if (!dateStr) return 'N/A';
                    try {
                        return new Date(dateStr).toLocaleString('en-US', {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                    } catch (e) {
                        return dateStr;
                    }
                };

                // Determine if it's a folder or file
                const isFolder = node.isFolder === true;
                const entityType = isFolder ? 'Folder' : 'File';
                const entityIcon = isFolder ? 'ðŸ“' : node.icon || 'ðŸ“„';

                filesystemInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(99, 102, 241, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">${entityIcon} ${entityType} Details</div>
                        </div>

                        <!-- Open Button (Prominent) -->
                        ${node.fileUrl || node.filePath ? `
                            <div style="text-align: center; margin-bottom: 20px;">
                                <button onclick="window.open('${node.fileUrl || node.filePath}', '_blank')" style="
                                    padding: 16px 32px;
                                    background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
                                    color: white;
                                    border: none;
                                    border-radius: 12px;
                                    font-size: 16px;
                                    font-weight: 700;
                                    cursor: pointer;
                                    display: inline-flex;
                                    align-items: center;
                                    gap: 10px;
                                    transition: all 0.3s;
                                    box-shadow: 0 4px 12px rgba(0, 166, 125, 0.3);
                                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0, 166, 125, 0.4)';" onmouseout="this.style.transform=''; this.style.boxShadow='0 4px 12px rgba(0, 166, 125, 0.3)';">
                                    <span style="font-size: 20px;">ðŸ”—</span>
                                    <span>Open ${isFolder ? 'Folder' : 'File'}</span>
                                </button>
                            </div>
                        ` : ''}

                        <!-- File/Folder Metadata Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 16px;">
                            ${!isFolder && node.fileSize !== undefined ? `
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ’¾ Size</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #10B981;">${formatFileSize(node.fileSize)}</div>
                                </div>
                            ` : ''}
                            ${node.fileExtension ? `
                                <div style="padding: 14px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ“‹ Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B; font-family: monospace;">${node.fileExtension}</div>
                                </div>
                            ` : ''}
                            ${node.mimeType ? `
                                <div style="padding: 14px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ”– MIME</div>
                                    <div style="font-size: 11px; font-weight: 600; color: #A78BFA; font-family: monospace; word-break: break-all;">${node.mimeType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Dates -->
                        ${node.dateModified || node.dateCreated ? `
                            <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                                ${node.dateModified ? `
                                    <div style="flex: 1; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“… Modified</div>
                                        <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${formatDate(node.dateModified)}</div>
                                    </div>
                                ` : ''}
                                ${node.dateCreated ? `
                                    <div style="flex: 1; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ†• Created</div>
                                        <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${formatDate(node.dateCreated)}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Owner & Path -->
                        ${node.fileOwner ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‘¤ Owner</div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.fileOwner}</div>
                            </div>
                        ` : ''}
                        ${node.filePath ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“‚ Path</div>
                                <div style="font-size: 12px; color: var(--text-primary); font-family: monospace; word-break: break-all;">${node.filePath}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            body.innerHTML = `
                ${pmDashboardHtml}
                ${patternInfoHtml}
                ${filesystemInfoHtml}
                <div class="info-section">
                    <h4>ID</h4>
                    <p><code style="background: var(--bg); padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 12px;">${node.id || 'N/A'}</code></p>
                </div>
                ${PATTERNS[currentPattern].fields?.cost && node.type !== 'root' ? `
                <div class="info-section">
                    <h4>Cost</h4>
                    <p class="value">${formatCost(node.cost || 0)}</p>
                </div>
                ` : ''}
                ${node.type === 'root' ? `
                <div class="info-section">
                    <h4>Total Cost</h4>
                    <p class="value">${formatCost(calculateTotal(node))}</p>
                </div>
                ` : ''}
                <div class="info-section">
                    <h4>Description</h4>
                    <p>${node.description || node.subtitle || 'N/A'}</p>
                </div>
                <div class="info-section">
                    <h4>Type</h4>
                    <p>${node.itemType || node.type || 'N/A'}</p>
                </div>
                ${node.alternateSource ? `
                    <div class="info-section">
                        <h4>Alternate Source</h4>
                        <p style="font-size: 14px; line-height: 1.6;">ðŸ“¦ ${node.alternateSource}</p>
                    </div>
                ` : ''}
                ${node.leadTime ? `
                    <div class="info-section">
                        <h4>Lead Time</h4>
                        <p style="font-size: 14px; line-height: 1.6;">â±ï¸ ${node.leadTime}</p>
                    </div>
                ` : ''}
                ${node.notes ? `
                    <div class="info-section">
                        <h4>Context Notes</h4>
                        <p style="background: var(--bg); padding: 12px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary); font-size: 13px; line-height: 1.6; white-space: pre-wrap;">${node.notes}</p>
                    </div>
                ` : ''}
                ${depsHtml}
                ${dependentsHtml}
                ${node.type === 'phase' ? `
                    <div class="info-section">
                        <h4>Phase Total</h4>
                        <p class="value">${formatCost(calculatePhaseTotal(node))}</p>
                    </div>
                ` : ''}
                ${node.type === 'root' ? `
                    <div class="info-section">
                        <h4>Total Cost</h4>
                        <p class="value">${formatCost(calculateTotal(node))}</p>
                    </div>
                ` : ''}
                ${node.type === 'root' && node.hyperedges && node.hyperedges.length > 0 ? `
                    <div class="info-section">
                        <h4>Hyperedges (Groups)</h4>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            ${node.hyperedges.map(h => `
                                <div style="display: flex; align-items: center; justify-content: space-between; background: rgba(255,255,255,0.05); padding: 10px 12px; border-radius: 8px; border-left: 3px solid ${h.type === 'montage' ? '#fb923c' : h.type === 'argument' ? '#3b82f6' : h.type === 'theme' ? '#a855f7' : h.type === 'dependency-cluster' ? '#22c55e' : '#9ca3af'};">
                                    <div style="flex: 1;">
                                        <span style="font-size: 14px; font-weight: 500;">${h.label || 'Unnamed Group'}</span>
                                        <span style="opacity: 0.5; font-size: 12px; margin-left: 8px;">(${h.type || 'group'})</span>
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">${h.nodeIds?.length || 0} nodes</div>
                                    </div>
                                    <button onclick="window.deleteHyperedge('${h.id}')" style="background: rgba(239, 68, 68, 0.2); border: none; cursor: pointer; font-size: 14px; padding: 6px 10px; border-radius: 6px; color: #ef4444;" title="Delete hyperedge">ðŸ—‘ï¸</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            `;

            panel.classList.add('open');
            currentOpenItemId = node.id;

            // Reposition hyperedge panel if it's open
            repositionHyperedgePanel(true);
        }

        // Track which item's panel is currently open
        let currentOpenItemId = null;

        /**
         * Reposition the hyperedge visibility panel based on info panel state
         * @param {boolean} infoPanelOpen - Whether info panel is open
         */
        function repositionHyperedgePanel(infoPanelOpen) {
            const hyperedgePanel = document.getElementById('hyperedge-visibility-panel');
            if (hyperedgePanel) {
                const rightOffset = infoPanelOpen ? 470 : 20;
                hyperedgePanel.style.right = `${rightOffset}px`;
            }
        }

        document.getElementById('close-info').addEventListener('click', () => {
            document.getElementById('info-panel').classList.remove('open');
            currentOpenItemId = null;

            // Reposition hyperedge panel back to right edge
            repositionHyperedgePanel(false);
        });

        // Context Menu
        function showContextMenu(x, y) {
            const menu = document.getElementById('context-menu');
            const labels = getPatternLabels();

            // Build menu dynamically based on node type
            let menuHtml = '';

            if (activeNode.type === 'item') {
                // Item context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">ðŸ“‹ View Details</div>
                    <div class="context-item" id="ctx-edit">âœï¸ Edit ${labels.item}</div>
                    <div class="context-item" id="ctx-add-subtask">âž• Add ${labels.subtask}</div>
                    <div class="context-item" id="ctx-delete">ðŸ—‘ï¸ Delete ${labels.item}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ðŸ¤– AI Analysis</div>
                    <div class="context-item" id="ctx-deep-dive">ðŸŽ“ Deep Dive Analysis</div>
                `;
            } else if (activeNode.type === 'subtask') {
                // Subtask context menu (can now have nested subtasks)
                menuHtml = `
                    <div class="context-item" id="ctx-view">ðŸ“‹ View Details</div>
                    <div class="context-item" id="ctx-edit">âœï¸ Edit ${labels.subtask}</div>
                    <div class="context-item" id="ctx-add-subtask">âž• Add Nested ${labels.subtask}</div>
                    <div class="context-item" id="ctx-delete">ðŸ—‘ï¸ Delete ${labels.subtask}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ðŸ¤– AI Analysis</div>
                    <div class="context-item" id="ctx-deep-dive">ðŸŽ“ Deep Dive Analysis</div>
                `;
            } else if (activeNode.type === 'phase') {
                // Phase context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">ðŸ“‹ View Details</div>
                    <div class="context-item" id="ctx-edit">âœï¸ Edit ${labels.phase}</div>
                    <div class="context-item" id="ctx-create">âž• Add ${labels.item} to ${activeNode.name}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ðŸ¤– AI Analysis</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">ðŸ’¾ Download JSON</div>
                    <div class="context-item" id="ctx-upload">ðŸ“‚ Upload JSON</div>
                `;
            } else if (activeNode.type === 'root') {
                // Root context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">ðŸ“‹ View Details</div>
                    <div class="context-item" id="ctx-edit">âœï¸ Edit ${labels.root}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-expand">ðŸ“‚ Expand All</div>
                    <div class="context-item" id="ctx-collapse">ðŸ“ Collapse All</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ðŸ¤– ${labels.root} AI Analysis</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">ðŸ’¾ Download JSON</div>
                    <div class="context-item" id="ctx-upload">ðŸ“‚ Upload JSON</div>
                `;
            }

            menu.innerHTML = menuHtml;
            menu.style.display = 'block';

            // Position menu first (to measure dimensions)
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Check if menu goes off screen and adjust position
            const menuRect = menu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            let finalX = x;
            let finalY = y;

            // Adjust horizontal position if menu goes off right edge
            if (menuRect.right > viewportWidth) {
                finalX = viewportWidth - menuRect.width - 10;
            }

            // Adjust vertical position if menu goes off bottom edge
            if (menuRect.bottom > viewportHeight) {
                finalY = viewportHeight - menuRect.height - 10;
            }

            // Ensure menu doesn't go off left edge
            if (finalX < 10) finalX = 10;

            // Ensure menu doesn't go off top edge
            if (finalY < 10) finalY = 10;

            menu.style.left = finalX + 'px';
            menu.style.top = finalY + 'px';

            // Re-attach event listeners
            attachContextMenuListeners();
        }

        function attachContextMenuListeners() {
            const viewBtn = document.getElementById('ctx-view');
            const editBtn = document.getElementById('ctx-edit');
            const createBtn = document.getElementById('ctx-create');
            const addSubtaskBtn = document.getElementById('ctx-add-subtask');
            const deleteBtn = document.getElementById('ctx-delete');
            const aiBtn = document.getElementById('ctx-ai');
            const deepDiveBtn = document.getElementById('ctx-deep-dive');
            const downloadBtn = document.getElementById('ctx-download');
            const uploadBtn = document.getElementById('ctx-upload');
            const expandBtn = document.getElementById('ctx-expand');
            const collapseBtn = document.getElementById('ctx-collapse');

            if (viewBtn) viewBtn.onclick = handleViewDetails;
            if (editBtn) editBtn.onclick = handleEdit;
            if (createBtn) createBtn.onclick = handleCreate;
            if (addSubtaskBtn) addSubtaskBtn.onclick = handleAddSubtask;
            if (deleteBtn) deleteBtn.onclick = handleDelete;
            if (aiBtn) aiBtn.onclick = handleAI;
            if (deepDiveBtn) deepDiveBtn.onclick = () => handleAnalyzeSelection([activeNode]);
            if (downloadBtn) downloadBtn.onclick = handleDownload;
            if (uploadBtn) uploadBtn.onclick = handleUpload;
            if (expandBtn) expandBtn.onclick = handleExpandAll;
            if (collapseBtn) collapseBtn.onclick = handleCollapseAll;
        }

        document.addEventListener('click', () => {
            document.getElementById('context-menu').style.display = 'none';
        });

        // Context menu handlers
        function handleViewDetails() {
            if (activeNode) showInfo(activeNode);
        }

        // =============================================================================
        // SMART SUGGESTION ENGINE - AI-Powered with Pattern Expertise
        // =============================================================================

        // Helper: Extract tree context for AI suggestions
        function extractTreeContext(itemContext) {
            const allItems = getAllProjectItems(capexTree);

            // Find current phase
            let currentPhase = null;
            let siblingItems = [];
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    if (phase.items && phase.items.find(item => item.id === itemContext.id)) {
                        currentPhase = phase;
                        siblingItems = phase.items.filter(item => item.id !== itemContext.id);
                        break;
                    }
                }
            }

            // Find items this depends on
            const dependencies = [];
            if (itemContext.dependencies) {
                itemContext.dependencies.forEach(depId => {
                    const depItem = allItems.find(item => item.id === depId);
                    if (depItem) dependencies.push(depItem);
                });
            }

            // Find items that depend on this
            const dependents = allItems.filter(item =>
                item.dependencies && item.dependencies.includes(itemContext.id)
            );

            return {
                projectName: capexTree.name || 'Project',
                projectDescription: capexTree.description || '',
                pattern: currentPattern,
                totalItems: allItems.length,
                currentPhase: currentPhase ? {
                    name: currentPhase.name,
                    subtitle: currentPhase.subtitle,
                    itemCount: currentPhase.items?.length || 0
                } : null,
                siblingItems: siblingItems.slice(0, 5), // Limit to 5 for context
                dependencies: dependencies.slice(0, 3),
                dependents: dependents.slice(0, 3),
                allItems: allItems.slice(0, 10) // Sample for pattern learning
            };
        }

        // Helper: Build pattern-expert AI prompts
        function buildPatternExpertPrompt(fieldType, itemContext, treeContext) {
            const pattern = currentPattern;

            // Base context shared across all patterns
            let prompt = `You are a subject matter expert for ${pattern} pattern projects. `;

            // Pattern-specific expert persona
            const expertPersonas = {
                philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments.',
                sales: 'You are a sales strategist with 20 years of enterprise B2B experience.',
                thesis: 'You are an academic advisor helping graduate students structure rigorous research.',
                roadmap: 'You are a product manager experienced in agile development and feature prioritization.',
                prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude and GPT-4.',
                book: 'You are a professional fiction editor and writing coach.',
                film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway).',
                course: 'You are an instructional designer with expertise in curriculum development.',
                fitness: 'You are a certified personal trainer and exercise physiologist with expertise in program design, exercise science, and progressive overload.',
                event: 'You are a professional event planner with experience in corporate events, weddings, and large-scale conferences.',
                strategy: 'You are a business strategy consultant specializing in strategic planning, KPI development, and organizational transformation.',
                familytree: 'You are a professional genealogist and family historian specializing in genealogical research and family tree documentation.',
                dialogue: 'You are a rhetoric and argumentation expert specializing in debate analysis, persuasive communication, and identifying logical fallacies.',
                gmail: 'You are an expert email analyst and communication strategist. You analyze email threads for tone, intent, rhetoric, and relationship dynamics. You provide context-aware suggestions for responses based on the full conversation history.',
                generic: 'You are an experienced Project Manager and CFO with deep expertise in budget management, resource allocation, risk mitigation, and financial planning for complex projects.'
            };

            prompt += expertPersonas[pattern] || expertPersonas.generic;
            prompt += `\n\n`;

            // Project context (trimmed for speed)
            prompt += `PROJECT: ${treeContext.projectName}`;
            if (treeContext.currentPhase) {
                prompt += ` - ${treeContext.currentPhase.name}`;
            }
            prompt += `\n\n`;

            // Current item context (trimmed)
            prompt += `ITEM: ${itemContext.name || 'New Item'}\n`;
            if (itemContext.description && itemContext.description.length < 200) {
                prompt += `${itemContext.description.substring(0, 200)}\n`;
            }

            // Add existing field values for context
            const relevantFields = ['speaker', 'conclusion', 'premise1', 'premise2',
                                    'dealValue', 'contactPerson', 'leadSource',
                                    'keyArgument', 'evidenceType',
                                    'videoPrompt', 'visualStyle', 'cameraMovement',
                                    'itemType', 'notes'];
            relevantFields.forEach(field => {
                if (itemContext[field] && field !== fieldType) {
                    prompt += `- ${field}: ${itemContext[field]}\n`;
                }
            });

            // Dependencies (minimal, for speed)
            if (treeContext.dependencies.length > 0) {
                prompt += `Builds on: ${treeContext.dependencies.map(d => d.name).join(', ')}\n`;
            }

            // Sibling examples (limit to 2, show only relevant field)
            if (treeContext.siblingItems.length > 0) {
                const examples = treeContext.siblingItems
                    .filter(sib => sib[fieldType])
                    .slice(0, 2)
                    .map(sib => String(sib[fieldType]).substring(0, 60));
                if (examples.length > 0) {
                    prompt += `Examples: ${examples.join('; ')}\n`;
                }
            }

            prompt += `\n`;

            // CONTINUITY INSTRUCTIONS for sequential/narrative patterns
            const sequentialPatterns = ['film', 'book', 'roadmap'];
            if (sequentialPatterns.includes(pattern) && treeContext.siblingItems.length > 0) {
                const lastSibling = treeContext.siblingItems[treeContext.siblingItems.length - 1];
                prompt += `âš ï¸ CONTINUITY REQUIREMENT:\n`;
                prompt += `This item follows: "${lastSibling.name}"\n`;

                if (pattern === 'film') {
                    prompt += `Ensure visual/narrative continuity from previous scene:\n`;
                    if (lastSibling.description) prompt += `- Previous scene: ${lastSibling.description.substring(0, 100)}\n`;
                    if (lastSibling.lightingMood) prompt += `- Previous lighting: ${lastSibling.lightingMood}\n`;
                    prompt += `- If previous scene ended with location change/fade, this scene must establish new context\n`;
                    prompt += `- Maintain consistent visual style and tone unless intentionally shifting\n`;
                } else if (pattern === 'book') {
                    prompt += `Ensure narrative continuity from previous chapter/section:\n`;
                    if (lastSibling.description) prompt += `- Previous: ${lastSibling.description.substring(0, 100)}\n`;
                    prompt += `- Maintain character consistency, plot coherence, and thematic threads\n`;
                    prompt += `- If starting new section/arc, provide logical handover from previous\n`;
                } else if (pattern === 'roadmap') {
                    prompt += `Ensure feature sequencing makes sense:\n`;
                    if (lastSibling.description) prompt += `- Previous feature: ${lastSibling.description.substring(0, 100)}\n`;
                    prompt += `- Check dependencies: does this feature build on or require the previous one?\n`;
                    prompt += `- If starting new phase, ensure logical progression from previous phase goals\n`;
                }
                prompt += `\n`;
            }

            // Pattern-specific field instructions
            prompt += buildFieldInstructions(pattern, fieldType, itemContext);

            // CRITICAL: For video prompts and other direct-use fields, be VERY strict
            const directUseFields = ['videoPrompt', 'visualStyle', 'cameraMovement', 'flowMode', 'audioType',
                                     'cinematicStyle', 'beatType', 'physicsComplexity', 'nleExportFormat', 'audioSync'];
            if (directUseFields.includes(fieldType)) {
                prompt += `\nâš ï¸ CRITICAL OUTPUT FORMAT âš ï¸
Return ONLY the raw ${fieldType} text that will be used directly with AI video generation.
NO conversational introductions like "Okay, buckle up..." or "Get ready..." or "Here's..." or "Let me..."
NO explanations, NO context, NO meta-commentary, NO exclamation marks before the actual content
JUST the actual ${fieldType} text itself, ready to paste directly into Sora/Veo/Runway.

Example WRONG: "Okay, buckle up! Here's an amazing prompt: [actual prompt]"
Example WRONG: "Get ready to ignite the screen with this: [actual prompt]"
Example CORRECT: "[actual prompt]"

Your response:`;
            } else {
                prompt += `\nReturn ONLY the ${fieldType} value (1-3 sentences, no explanation).\n`;
            }

            return prompt;
        }

        // Helper: Pattern-specific field instructions
        function buildFieldInstructions(pattern, fieldType, itemContext) {
            let instructions = `YOUR TASK: Suggest a ${fieldType} for the current item.\n\n`;

            // Philosophy pattern
            if (pattern === 'philosophy') {
                const fieldInstructions = {
                    speaker: 'Suggest the most appropriate philosophical speaker/author for this argument based on the topic and historical context.',
                    premise1: 'Suggest a first premise that would logically support the conclusion. Use clear, precise philosophical language.',
                    premise2: 'Suggest a second premise that bridges premise1 to the conclusion, creating a valid logical inference.',
                    premise3: 'Suggest a third premise if needed to complete the argument structure.',
                    conclusion: 'Suggest a philosophical conclusion that follows from the premises. State it clearly and precisely.',
                    objection: 'Suggest a strong objection to this argument - what would a critic say? Be specific and philosophically rigorous.',
                    response: 'Suggest how the author would respond to the objection. Use careful distinctions and counterarguments.',
                    keyTerms: 'List 3-5 key philosophical terms central to this argument (comma-separated).',
                    textualReference: 'Suggest specific textual references (work and section numbers) where this argument appears or is discussed.',
                    description: 'Write a 2-3 sentence description of this philosophical argument, its method, and its significance.',
                    name: 'Suggest a concise title for this philosophical argument that captures its core claim.',
                    notes: 'Suggest key considerations for evaluating this argument: validity, soundness, implications, objections.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Sales pattern
            else if (pattern === 'sales') {
                const fieldInstructions = {
                    dealValue: 'Suggest a realistic deal value (in thousands $K) based on the deal type and company size.',
                    contactPerson: 'Suggest the most likely decision-maker title for this type of deal.',
                    leadSource: 'Suggest the most probable lead source for this deal type.',
                    competitorInfo: 'Suggest realistic competitive intelligence: who are we competing against and how do we differentiate? (2-3 sentences)',
                    expectedCloseDate: 'Suggest a realistic close date based on deal size and sales cycle.',
                    stageProbability: 'Suggest a close probability (0-100) based on the deal stage and context.',
                    description: 'Write a 2-3 sentence description of this sales opportunity, key stakeholders, and success factors.',
                    name: 'Suggest a descriptive name for this deal that includes company type and solution.',
                    notes: 'Suggest key considerations: budget timing, decision process, procurement, champion identification.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Thesis pattern
            else if (pattern === 'thesis') {
                const fieldInstructions = {
                    keyArgument: 'Suggest the main thesis argument for this chapter/section. What gap does it address? What contribution does it make?',
                    citations: 'Suggest 3-5 realistic academic citations (Author Year format) relevant to this topic.',
                    evidenceType: 'Suggest the most appropriate evidence type (Empirical, Theoretical, Mixed, Case Study, etc.).',
                    wordCount: 'Suggest a realistic current word count for this section.',
                    targetWordCount: 'Suggest an appropriate target word count based on section type.',
                    description: 'Write a 2-3 sentence description of this chapter/section: its argument, evidence, and contribution.',
                    name: 'Suggest a clear chapter/section title that reflects its content and argument.',
                    notes: 'Suggest key considerations: citation completeness, argument coherence, methodological rigor.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Film pattern
            else if (pattern === 'film') {
                const fieldInstructions = {
                    videoPrompt: 'Suggest a detailed Sora/Veo prompt (100-200 chars) for this scene. Include: subject, action, camera movement, lighting, style. Be cinematic and specific.',
                    cameraMovement: 'Suggest the most appropriate camera movement for this scene type and mood.',
                    lightingMood: 'Suggest the best lighting mood based on time of day, genre, and emotional tone.',
                    visualStyle: 'Suggest the visual style that best matches this scene\'s purpose and genre.',
                    duration: 'Suggest appropriate clip duration based on scene complexity and action.',
                    aiPlatform: 'Suggest the best AI platform (Sora, Veo 3, Runway Gen-3) for this scene type.',
                    description: 'Write a 2-3 sentence description of this scene: what happens, mood, visual approach.',
                    name: 'Suggest a concise scene name that captures the key action or emotion.',
                    notes: 'Suggest key considerations: continuity, platform strengths, prompt specificity, motion artifacts.',
                    iterationNotes: 'Suggest prompt engineering tips specific to this scene type.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Veo3 pattern
            else if (pattern === 'veo3') {
                const fieldInstructions = {
                    videoPrompt: 'Suggest a detailed Veo 3 prompt optimized for Google\'s model. Include: subject, action, camera movement, lighting, cinematic style.',
                    flowMode: 'Suggest the best Veo 3 Flow mode (Ingredients/Frames/Extend/Standard) for this scene.',
                    ingredientImages: 'Suggest what reference images would be needed for character/object/style consistency.',
                    startFrame: 'Suggest description of the starting frame for frame-to-frame bridging.',
                    endFrame: 'Suggest description of the ending frame for frame-to-frame bridging.',
                    extendDuration: 'Suggest target duration for video extension based on scene complexity.',
                    audioType: 'Suggest the best native audio type (Dialogue/SFX/Ambience/Mixed) for this scene.',
                    cinematicStyle: 'Suggest the Veo 3 cinematic style that best matches this scene.',
                    description: 'Write 2-3 sentences: what this scene shows, the Flow workflow, and visual approach.',
                    name: 'Suggest a concise scene name capturing the key visual or action.',
                    notes: 'Suggest key considerations: ingredient image quality, frame coherence, extension strategy.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Sora2 pattern
            else if (pattern === 'sora2') {
                const fieldInstructions = {
                    videoPrompt: 'Suggest a detailed Sora 2 prompt optimized for OpenAI\'s physics-accurate model. Include: subject, action, physics requirements, lighting, style.',
                    beatType: 'Suggest the narrative beat type (Setup/Conflict/Transition/Resolution) for this shot.',
                    cameoUsed: 'Suggest if this shot should use cameo integration and which cameo ID.',
                    remixSource: 'Suggest if this should be a remix of an existing shot, and which shot ID.',
                    physicsComplexity: 'Suggest physics complexity level (Simple/Medium/Complex) based on motion requirements.',
                    duration: 'Suggest Sora 2 duration (4s/8s/12s) based on action complexity.',
                    nleExportFormat: 'Suggest the best NLE format for post-production workflow.',
                    audioSync: 'Suggest audio type (Synchronized Dialogue/SFX/Background Score) for this beat.',
                    description: 'Write 2-3 sentences: what this beat accomplishes, physics requirements, and narrative purpose.',
                    name: 'Suggest a concise beat name capturing the narrative moment.',
                    notes: 'Suggest key considerations: physics accuracy, cameo setup, remix strategy, NLE workflow.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Roadmap pattern
            else if (pattern === 'roadmap') {
                const fieldInstructions = {
                    storyPoints: 'Suggest story point estimate (Fibonacci: 1,2,3,5,8,13) based on feature complexity.',
                    userImpact: 'Suggest user impact level (Low/Medium/High/Critical) based on affected user percentage and importance.',
                    technicalRisk: 'Suggest technical risk (Low/Medium/High) considering dependencies, unknowns, and complexity.',
                    engineeringEstimate: 'Suggest time estimate in sprints/weeks based on complexity.',
                    featureFlag: 'Suggest a feature flag name following naming conventions (feature_*).',
                    description: 'Write 2-3 sentences: what this feature does, who it affects, and key success metrics.',
                    name: 'Suggest a clear feature name that describes the user-facing capability.',
                    notes: 'Suggest key considerations: testing requirements, rollout strategy, monitoring, documentation.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Prompting pattern
            else if (pattern === 'prompting') {
                const fieldInstructions = {
                    systemPrompt: 'Suggest a clear, specific system prompt defining the AI\'s role, capabilities, and constraints. Use Anthropic best practices.',
                    userPromptTemplate: 'Suggest a user prompt template with {{variables}} and XML tags for structure.',
                    fewShotExamples: 'Suggest 1-2 few-shot examples in <examples><example> format showing input/output patterns.',
                    chainOfThought: 'Suggest CoT instructions: "Think step by step..." tailored to this task.',
                    outputFormat: 'Suggest the expected output structure (markdown, JSON, specific sections).',
                    structuralTags: 'Suggest XML tags for this task (e.g., <thinking>, <answer>, <critique>).',
                    assistantPrefill: 'Suggest an assistant prefill to guide tone and format.',
                    toolDefinitions: 'Suggest tool/function definitions if this task needs tool calling (JSON schema).',
                    modelTarget: 'Suggest the best model (Claude 3.5 Sonnet, GPT-4o, etc.) for this use case.',
                    temperature: 'Suggest temperature (0-1). Use 0-0.3 for deterministic tasks, 0.7-1.0 for creative.',
                    description: 'Write 2-3 sentences: what this prompt does, its approach, and optimization goals.',
                    name: 'Suggest a descriptive name for this prompt use case.',
                    notes: 'Suggest OpenAI/Anthropic best practices applied to this specific prompt.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Generic pattern - PM and CFO perspective
            else if (pattern === 'generic') {
                const fieldInstructions = {
                    cost: 'Suggest a realistic cost estimate based on the item type, scope, and market rates. Consider labor, materials, overhead.',
                    leadTime: 'Suggest a realistic timeline considering procurement cycles, dependencies, and resource availability.',
                    alternateSource: 'Suggest a credible backup vendor or alternative approach to mitigate supply chain/delivery risks.',
                    pmNextSteps: 'Suggest 2-3 specific, actionable next steps a PM would take to advance this task.',
                    pmBlockingIssue: 'Identify likely blockers: budget constraints, resource conflicts, vendor delays, approvals needed.',
                    description: 'Write 2-3 sentences describing this deliverable, its business value, and key execution considerations.',
                    name: 'Suggest a clear deliverable name that communicates scope and business value.',
                    notes: 'Suggest PM considerations: budget burn rate, stakeholder alignment, risk mitigation, change management.',
                    pmOwnerEmail: 'Suggest the most appropriate role/person to own this (e.g., engineering-lead@, procurement@, finance@).'
                };
                instructions += fieldInstructions[fieldType] || `From a PM and CFO perspective, suggest a realistic ${fieldType} value considering budget, timeline, and risk factors.`;
            }

            // Gmail pattern - Email analysis and response generation
            else if (pattern === 'gmail') {
                const fieldInstructions = {
                    subjectLine: 'Suggest 2-3 high-converting subject lines based on the email context. Keep under 50 characters. Avoid spammy words. Focus on value or curiosity.',
                    emailBody: 'Analyze the full conversation thread and suggest a contextually-appropriate response. Reference previous messages. Match the tone and formality level. Include a clear call to action if appropriate.',
                    recipientEmail: 'Suggest the likely recipient based on the conversation context and sender patterns.',
                    status: 'Suggest the appropriate email status (Draft/Sent/Replied/Archived) based on the conversation state.',
                    name: 'Suggest a short internal name for this email thread that captures the main topic or business context.',
                    description: 'Analyze this email thread: summarize the key points, identify the tone/sentiment, note any action items, and assess relationship dynamics.',
                    notes: 'Suggest key observations: communication style, negotiation position, objections raised, next steps needed, relationship temperature (warm/neutral/cold).'
                };
                instructions += fieldInstructions[fieldType] || `Analyze the email context and conversation history to suggest an appropriate ${fieldType} value.`;
            }

            // Event Planning pattern
            else if (pattern === 'event') {
                const fieldInstructions = {
                    budget: 'Suggest realistic budget based on activity type. Catering: $25-75/person, Venue: $2-10K, AV/Tech: $1-5K, Entertainment: $500-5K. Consider event scale and location.',
                    vendor: 'Suggest appropriate vendor type and realistic company name. Include specialization (e.g., "ABC Catering - Corporate Events", "Premier AV - Full-service production").',
                    bookingDeadline: 'Suggest booking deadline based on vendor type: Venues (6-12 months ahead), Catering (2-3 months), Entertainment (3-6 months), AV/Tech (1-2 months).',
                    guestCount: 'Suggest realistic guest count based on event type: Corporate (50-500), Wedding (100-250), Conference (100-1000), Team building (20-100).',
                    location: 'Suggest specific location based on activity. Be detailed: "Grand Ballroom, 2nd floor" not just "Hotel". Include practical details.',
                    responsiblePerson: 'Suggest appropriate role based on activity type: Event Manager (overall), AV Coordinator (tech), Catering Manager (food), Registration Lead (check-in).',
                    description: 'Write 2-3 sentences: what this activity entails, its role in the event, and key success factors.',
                    name: 'Suggest a clear activity name that includes the type and purpose.',
                    notes: 'Suggest key considerations: vendor contracts, backup plans, timing dependencies, permits needed, weather contingencies.'
                };
                instructions += fieldInstructions[fieldType] || `From an event planner\'s perspective, suggest a realistic ${fieldType} value considering logistics, timeline, and vendor coordination.`;
            }

            // Fitness pattern
            else if (pattern === 'fitness') {
                const fieldInstructions = {
                    sets: 'Suggest sets based on training goal: Hypertrophy (3-4 sets), Strength (5+ sets), Endurance (2-3 sets), Skill work (3-5 sets). Consider training age and recovery capacity.',
                    reps: 'Suggest rep ranges by goal: Strength (3-6 reps), Hypertrophy (8-12 reps), Endurance (15+ reps), Power (1-5 reps explosive). Match to exercise type (compound vs isolation).',
                    duration: 'Suggest duration based on workout type: Strength session (45-75 min), Cardio (20-60 min), Circuit training (30-45 min), Recovery/mobility (15-30 min).',
                    intensity: 'Suggest intensity level based on training phase, exercise type, and proximity to competition/testing. Consider recovery status.',
                    equipment: 'Suggest realistic equipment based on exercise. Be specific: "Olympic Barbell, 45lb plates" not just "weights". Consider gym vs home setup.',
                    formCues: 'Provide 3 specific biomechanical safety cues focusing on joint angles, spine position, and common injury risks. Example: "Deadlift: Neutral spine, shoulders over bar, drive through heels." Reference anatomy.',
                    restPeriod: 'Suggest rest based on goal: Strength (3-5 min - CNS recovery), Hypertrophy (60-90s - metabolic stress), Endurance (30-45s - conditioning), Power (2-3 min).',
                    description: 'Write 2-3 sentences: training stimulus, primary muscle groups, and how this fits into the program phase.',
                    name: 'Suggest a descriptive workout name indicating focus (e.g., "Upper Body Hypertrophy A", "Lower Power Day").',
                    notes: 'Suggest key considerations: progression scheme (linear, wave, double progression), deload timing, exercise substitutions, injury prevention.'
                };
                instructions += fieldInstructions[fieldType] || `From a certified strength coach perspective (CSCS), suggest a ${fieldType} value based on training science and periodization principles.`;
            }

            // Strategic Planning pattern
            else if (pattern === 'strategy') {
                const fieldInstructions = {
                    investment: 'Suggest realistic capital investment based on initiative scope. Consider: Technology ($100K-$5M), Market expansion ($500K-$10M), Operational improvements ($50K-$2M). Include CAPEX and OPEX.',
                    keyMetric: 'Suggest a specific, measurable KPI that defines success. Use SMART criteria. Examples: "Revenue growth %", "Customer acquisition cost", "Market share %", "Employee retention rate".',
                    targetValue: 'Suggest a specific, ambitious but achievable target for the metric. Base on industry benchmarks. Example: "Increase revenue by 25% YoY", "Reduce CAC by $150".',
                    responsibleExecutive: 'Suggest appropriate C-level owner: CEO (transformation), CFO (financial), CTO (technology), CMO (marketing), COO (operations), CHRO (people).',
                    strategicTheme: 'Assign theme based on initiative nature: Growth (revenue expansion), Efficiency (cost reduction), Innovation (new products), Transformation (business model change), Risk Mitigation (compliance, security).',
                    riskLevel: 'Assess risk considering: Market uncertainty, technical complexity, regulatory factors, resource constraints. High risk: unproven, complex, resource-intensive.',
                    description: 'Write 2-3 sentences: strategic rationale, expected business impact, and key success factors.',
                    name: 'Suggest a clear initiative name that communicates strategic intent and business value.',
                    notes: 'Suggest key considerations: competitive response, regulatory requirements, change management, ROI timeline, resource conflicts.'
                };
                instructions += fieldInstructions[fieldType] || `From a strategy consultant perspective (McKinsey/BCG), suggest a ${fieldType} value considering competitive dynamics, market forces, and organizational capabilities.`;
            }

            // Course Design pattern
            else if (pattern === 'course') {
                const fieldInstructions = {
                    learningObjectives: 'Write 2-3 specific learning objectives using Bloom\'s Taxonomy action verbs (Remember: define, list; Understand: explain, summarize; Apply: demonstrate, solve; Analyze: compare, critique; Evaluate: judge, defend; Create: design, compose). Make them measurable and specific.',
                    duration: 'Suggest duration based on lesson type: Lecture (50-75 min), Lab/Practical (90-120 min), Discussion (30-60 min), Workshop (2-4 hours), Field work (half-day to full-day).',
                    difficultyLevel: 'Suggest level based on prerequisite knowledge, cognitive complexity (Bloom\'s level), and abstraction required. Beginner: foundational concepts. Intermediate: application/analysis. Advanced: synthesis/evaluation.',
                    prerequisites: 'List specific prior knowledge, skills, or courses needed. Be concrete: "Understanding of basic statistics (mean, median, standard deviation)" not just "some statistics".',
                    assessmentType: 'Suggest assessment matching learning objectives. Use Bloom\'s level: Quiz (remember/understand), Assignment (apply/analyze), Project (analyze/evaluate/create), Discussion (understand/evaluate), Exam (comprehensive).',
                    resourcesNeeded: 'List specific resources: Textbook chapters with page numbers, required readings with citations, software/tools, datasets, lab equipment, handouts.',
                    homework: 'Suggest homework that reinforces learning objectives. Estimate time required (typically 2-3x class time for college courses). Make it specific and scaffolded.',
                    description: 'Write 2-3 sentences: key concepts covered, pedagogical approach, and how this builds toward course goals.',
                    name: 'Suggest a clear lesson title that reflects content and cognitive level.',
                    notes: 'Suggest key considerations: active learning strategies, accommodation needs, technology requirements, formative assessment touchpoints.'
                };
                instructions += fieldInstructions[fieldType] || `From an instructional designer perspective (ADDIE model, Bloom\'s Taxonomy), suggest a ${fieldType} value considering learning science and curriculum design principles.`;
            }

            // Family Tree pattern
            else if (pattern === 'familytree') {
                const fieldInstructions = {
                    fullName: 'Suggest full legal name including middle names. Use historical naming conventions for era (e.g., patronymics, matronymics in certain cultures).',
                    maidenName: 'Suggest maiden name (birth surname) if person changed name after marriage. Consider cultural naming traditions.',
                    gender: 'Suggest gender based on name and historical context. Use "Unknown" if insufficient evidence.',
                    birthDate: 'Suggest realistic birth date based on generation, parent ages, and historical context. Parents typically 20-35 years older than children.',
                    birthPlace: 'Suggest birth location with specificity appropriate to era and records. Format: City, State/Province, Country. Consider migration patterns.',
                    livingStatus: 'Determine based on birth year and typical lifespan. Anyone born before 1920 likely deceased. Use "Unknown" if uncertain.',
                    deathDate: 'Suggest death date if deceased. Consider typical lifespan for era: pre-1900 (40-60 years), 1900-1950 (60-70 years), post-1950 (70-85 years).',
                    deathPlace: 'Suggest death location considering migration history and family patterns. Often different from birthplace.',
                    marriageDate: 'Suggest marriage date considering historical marriage ages: Pre-1900 (women 18-22, men 22-26), Modern (women 25-30, men 27-32). Check birth dates of children.',
                    marriagePlace: 'Suggest marriage location based on family residence patterns and cultural traditions.',
                    spouseName: 'Suggest spouse name if married. Consider multiple marriages if dates suggest (remarriage after death/divorce).',
                    occupation: 'Suggest historically appropriate occupation for era, location, and social class. Be specific: "Locomotive Engineer" not just "Railroad worker".',
                    photoURL: 'Suggest type of photo if known: "Portrait photo circa 1920s" or "Family photo, wedding day". Note if no photo available.',
                    dnaInfo: 'Suggest relevant genetic information: Haplogroups (Y-DNA for paternal line, mtDNA for maternal line), ethnic percentages, DNA matches, genetic markers.',
                    sources: 'Suggest appropriate primary sources: Birth/death certificates, census records (1850-1940 US), marriage licenses, military records, church records, immigration documents.',
                    relationshipType: 'Classify relationship: Biological (default), Adopted, Step (remarriage), Foster, Half-Sibling (shared one parent). Consider family dynamics.',
                    description: 'Write 2-3 sentences: brief biography, significant life events, and family role/legacy.',
                    name: 'Suggest identifying name (often nickname or commonly used name): "John Smith (Big John)" or "Mary Johnson (nÃ©e Williams)".',
                    notes: 'Suggest key considerations: Missing records, conflicting data, DNA confirmation status, historical context, research leads to pursue.'
                };
                instructions += fieldInstructions[fieldType] || `From a genealogist perspective (NGSQ standards), suggest a ${fieldType} value based on historical records, naming patterns, and genealogical best practices.`;
            }

            // Dialogue & Rhetoric pattern
            else if (pattern === 'dialogue') {
                const fieldInstructions = {
                    speaker: 'Identify speaker and relevant context: Name, role/title, political affiliation, expertise, or motivation. Example: "Senator Jane Smith (R-TX, Healthcare Committee Chair)".',
                    verbatimQuote: 'Extract the exact statement word-for-word. Capture tone indicators (emphasis, pauses). Essential for accurate rhetorical analysis.',
                    rhetoricalDevice: 'Identify primary persuasion technique: Logos (logical reasoning), Pathos (emotional appeal), Ethos (credibility), Metaphor, Analogy, Repetition, Hyperbole, Irony, Appeal to Authority.',
                    logicalStructure: 'Break down argument into formal logic: "Premise 1: [claim], Premise 2: [claim], Conclusion: [claim]". Identify deductive/inductive/abductive reasoning.',
                    fallaciesPresent: 'Identify logical fallacies with examples: Ad hominem (attack person not argument), Straw man (misrepresent position), Slippery slope, False dichotomy, Appeal to emotion, Hasty generalization. Explain how fallacy appears.',
                    hiddenMotivation: 'Analyze subtext and hidden agenda. What is the speaker really trying to achieve? Consider: Political positioning, fundraising, deflection, changing topic, rallying base.',
                    description: 'Write 2-3 sentences: summarize the argument, identify rhetorical strategy, and assess persuasive effectiveness.',
                    name: 'Suggest a short label capturing the argument\'s core claim or tactic (e.g., "Healthcare Cost Deflection", "Moral Authority Appeal").',
                    notes: 'Suggest key observations: Communication style, negotiation position, emotional valence, audience targeting, cultural context, historical parallels.'
                };
                instructions += fieldInstructions[fieldType] || `From a rhetoric expert perspective (Aristotelian persuasion, critical discourse analysis), suggest a ${fieldType} value analyzing argument structure, persuasion techniques, and logical coherence.`;
            }

            // Filesystem pattern - Digital Librarian AI
            else if (pattern === 'filesystem') {
                const fieldInstructions = {
                    tags: 'Suggest 3-5 taxonomic tags based on the filename, location, and file extension. Use consistent casing (lowercase-kebab). Examples: "financial-report", "customer-data", "design-asset", "code-source", "archive-2024".',
                    fileOwner: 'Suggest the most likely owner/creator based on the folder context, file type, and naming patterns. Format as email or department: "finance@company.com", "engineering-dept", "john.doe", "admin".',
                    permissions: 'Suggest appropriate permissions (Read Only, Read/Write, Owner, Viewer, Editor) based on file type, sensitivity, and likely use case. Financial data â†’ Read Only, Shared docs â†’ Read/Write, System files â†’ Owner only.',
                    description: 'Write a clear 1-2 sentence summary of what this file/folder likely contains based on its name, extension, location, and context. Be specific about content type and purpose.',
                    name: 'Suggest a clean, standardized filename if the current one is messy. Use ISO 8601 dates (YYYY-MM-DD), no spaces (use hyphens or underscores), descriptive keywords, and proper casing. Example: "2024-Q3-financial-report.pdf" instead of "report final FINAL (1).pdf".',
                    notes: 'Suggest data governance notes: retention policy (how long to keep), backup priority (critical/standard/low), security classification (public/internal/confidential/restricted), compliance requirements (GDPR, HIPAA, SOX), and archival recommendations.',
                    fileSize: 'Estimate realistic file size in bytes based on file type and likely content. Documents (50KB-5MB), Images (100KB-10MB), Videos (10MB-2GB), Code (10KB-500KB), Archives (1MB-500MB).',
                    fileExtension: 'Suggest the correct file extension based on the filename and file type. Be specific: .pdf, .docx, .xlsx, .pptx, .jpg, .png, .mp4, .zip, .py, .js, .html, etc.',
                    filePath: 'Suggest a logical full file path based on the file type, organizational context, and best practices for file organization. Use clear folder hierarchies.',
                    dateModified: 'Suggest when this file was likely last modified based on context clues (project timelines, version numbers, naming patterns). Use ISO 8601 format.',
                    dateCreated: 'Suggest when this file was likely created based on naming conventions, project context, or folder structure. Use ISO 8601 format.',
                    sharedWith: 'Suggest who should have access to this file based on content type, sensitivity, and organizational context. List email addresses or group names.',
                    driveType: 'Suggest the appropriate storage location (Local Drive, Google Drive, OneDrive, Dropbox, Network Drive, External Drive) based on file type, sharing needs, and organizational policies.',
                    mimeType: 'Suggest the MIME type based on file extension. Examples: application/pdf, image/jpeg, text/html, video/mp4, application/zip, text/plain, application/json.',
                    fileUrl: 'Suggest whether this should be stored in cloud storage and note the URL pattern (e.g., "Google Drive - shared link", "OneDrive - team folder", "Local only").',
                    isFolder: 'Determine if this should be a folder or file based on naming patterns. Folders typically have generic names (Documents, 2024-Reports, Assets) while files have extensions.'
                };
                instructions += fieldInstructions[fieldType] || `Act as a Digital Librarian and File Management expert. Suggest appropriate metadata for this file/folder, considering: organizational best practices, data governance, security classification, and clean naming conventions. Help tame messy filesystems.`;
            }

            // Other patterns
            else {
                instructions += `Consider the project context, dependencies, and sibling items. Suggest a realistic, specific ${fieldType} value that fits the pattern.`;
            }

            return instructions;
        }

        // MAIN AI SUGGESTION FUNCTION (async with AI integration)
        async function generateAISuggestion(fieldType, itemContext) {
            console.log('ðŸ¤– generateAISuggestion called:', fieldType);

            // Check global AI mode
            const aiMode = getGlobalAIMode();
            console.log('ðŸ¤– Global AI Mode:', aiMode);

            if (aiMode === 'off') {
                console.log('âŒ AI features disabled, using static fallback');
                return generateStaticSuggestion(fieldType, itemContext);
            }

            // Check if API key is available (needed for all modes)
            const apiKey = getLocalAPIKey(getAIProvider());
            console.log('ðŸ”‘ API Key present:', !!apiKey);

            if (!apiKey && aiMode === 'deep') {
                console.log('âš ï¸ Deep Mode requires API key, falling back to static');
                alert('ðŸ”¬ Deep Mode requires your own API key.\n\nPlease configure your API key (ðŸ”‘ button) or switch to Quick Mode in the header.');
                return generateStaticSuggestion(fieldType, itemContext);
            }

            if (!apiKey && aiMode === 'quick') {
                console.log('âš¡ Quick Mode: Will use server API key');
            }

            try {
                // Extract full tree context
                console.log('ðŸ“Š Extracting tree context...');
                const treeContext = extractTreeContext(itemContext);
                console.log('ðŸ“Š Tree context extracted:', treeContext);

                // Build pattern-expert prompt
                console.log('ðŸ“ Building expert prompt...');
                const expertPrompt = buildPatternExpertPrompt(fieldType, itemContext, treeContext);
                console.log('ðŸ“ Expert prompt built, length:', expertPrompt.length);

                // Call Claude API for intelligent suggestion (low token limit for speed)
                console.log('â˜ï¸ Calling Claude API...');
                const suggestion = await callClaudeAPI(expertPrompt, '', 256); // 256 tokens max = faster, stays under 10s Netlify limit
                console.log('â˜ï¸ Claude API response:', suggestion);

                // Clean up the response (remove quotes, trim)
                let cleaned = suggestion.trim();
                if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
                    cleaned = cleaned.slice(1, -1);
                }
                if (cleaned.startsWith("'") && cleaned.endsWith("'")) {
                    cleaned = cleaned.slice(1, -1);
                }

                console.log('âœ¨ Returning cleaned suggestion:', cleaned);
                return cleaned || generateStaticSuggestion(fieldType, itemContext);

            } catch (error) {
                console.error('âŒ AI suggestion failed, falling back to static:', error);
                console.error('Error details:', error.message, error.stack);
                return generateStaticSuggestion(fieldType, itemContext);
            }
        }

        // STATIC SUGGESTION ENGINE (fallback when no API key)
        function generateStaticSuggestion(fieldType, itemContext) {
            const pattern = PATTERNS[currentPattern];
            const itemType = itemContext.itemType || '';
            const phase = itemContext.id ? itemContext.id.split('-')[0] : 'p0';
            const notes = itemContext.notes || '';

            // Get all existing items for contextual analysis
            function getAllProjectItems(node = capexTree, items = []) {
                if (node.items) items.push(...node.items);
                if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
                return items;
            }
            const existingItems = getAllProjectItems();

            // Pattern-aware AI suggestion templates - Subject matter experts for each domain
            const patternSuggestions = {
                philosophy: {
                    name: ['Knowledge is Virtue', 'The Nature of Justice', 'Definition of Piety', 'Forms vs Particulars', 'The Good Life', 'Moral Relativism Critique', 'Socratic Paradox', 'The Cave Allegory', 'Mind-Body Problem', 'Free Will vs Determinism'],
                    description: 'Dialectical examination of fundamental concepts through logical argumentation. Present premises systematically, consider objections, and respond with careful distinctions. Ground claims in textual evidence and philosophical tradition.',
                    speaker: ['Socrates', 'Plato', 'Aristotle', 'Meno', 'Euthyphro', 'Thrasymachus', 'Glaucon', 'Adeimantus'],
                    premise1: 'All humans desire what is genuinely good for them.',
                    premise2: 'If someone pursues what is harmful, they must not recognize it as harmful.',
                    conclusion: 'Therefore, wrongdoing is a form of ignorance, not deliberate evil.',
                    objection: 'Some people knowingly pursue harmful pleasures despite understanding the consequences.',
                    response: 'True knowledge of harm would necessarily prevent pursuit; what appears as knowledge may be mere belief.',
                    keyTerms: 'virtue, knowledge, piety, justice, wisdom, excellence (arete)',
                    textualReference: 'Meno 77b-78b, Protagoras 352-358',
                    notes: 'Consider: logical validity of argument, strength of premises, historical context, counterexamples from lived experience, implications for ethics and epistemology.'
                },
                sales: {
                    name: ['Enterprise Cloud Migration', 'SaaS Platform Expansion', 'Strategic Partnership Deal', 'Fortune 500 Account', 'Multi-Year Service Agreement', 'Technology Integration Project'],
                    description: 'High-value opportunity requiring executive engagement and multi-stakeholder alignment. Key success factors: clear ROI demonstration, competitive differentiation, and relationship-building with economic buyer.',
                    leadSource: 'Inbound marketing, industry conference referral, or strategic partner introduction',
                    contactPerson: 'VP of IT, CFO, or Chief Digital Officer',
                    competitorInfo: 'Competing against 2-3 established vendors. Differentiation: superior support, proven ROI, and industry-specific features.',
                    notes: 'Key considerations: budget approval timing, decision-making process, technical evaluation criteria, procurement requirements, champion identification, stakeholder mapping.'
                },
                thesis: {
                    name: ['Literature Review', 'Theoretical Framework', 'Methodology Design', 'Data Analysis', 'Results Interpretation', 'Discussion of Findings', 'Limitations & Future Research'],
                    description: 'Critical analysis of existing scholarship establishing theoretical foundation for research. Synthesize major debates, identify gaps in literature, and position current study within academic discourse.',
                    keyArgument: 'Previous research has overlooked [specific aspect], creating need for [your contribution]. This study addresses gap through [your approach].',
                    citations: 'Smith (2020), Johnson & Lee (2019), Martinez et al. (2018), Chen (2021)',
                    evidenceType: 'Mixed: quantitative data analysis combined with qualitative case studies',
                    notes: 'Key considerations: citation completeness, argument coherence, gap identification, methodological rigor, contribution to field, clarity of research questions.'
                },
                roadmap: {
                    name: ['User Authentication V2', 'Mobile App Redesign', 'API Performance Optimization', 'Analytics Dashboard', 'Third-Party Integration', 'Search Functionality'],
                    description: 'User-facing feature delivering measurable business value. Requires cross-functional coordination between product, engineering, and design. Success metrics defined upfront.',
                    userImpact: 'High - affects 80% of active users',
                    technicalRisk: 'Medium - depends on third-party API stability',
                    engineeringEstimate: '2 sprints (4 weeks)',
                    featureFlag: 'feature_new_search_v2',
                    notes: 'Key considerations: user testing requirements, performance benchmarks, rollout strategy, rollback plan, monitoring and alerting, documentation needs.'
                },
                prompting: {
                    name: ['Customer Support Agent', 'Code Reviewer with CoT', 'RAG Query Handler', 'Content Generator', 'Multi-Agent Router', 'Safety Classifier', 'Summarizer with Examples', 'Function Calling Orchestrator'],
                    description: 'Production prompt engineered using OpenAI/Anthropic best practices. Clear role definition, task breakdown, few-shot examples, output format specification, and evaluation criteria. Optimized for consistency and reliability.',
                    systemPrompt: 'You are an expert customer support agent for a SaaS platform. Your goal is to resolve customer issues quickly while maintaining a friendly, professional tone. Always prioritize customer satisfaction. If you cannot resolve an issue, escalate appropriately with clear context.',
                    userPromptTemplate: 'A customer has reported the following issue:\n\n<customer_issue>\n{{issue}}\n</customer_issue>\n\n<context>\nAccount: {{account_tier}}\nPrevious tickets: {{ticket_history}}\n</context>\n\nAnalyze the issue and provide: 1) Root cause, 2) Resolution steps, 3) Prevention advice.',
                    fewShotExamples: '<examples>\n<example>\n<user>Login broken after password reset</user>\n<assistant>Root cause: Session cache not cleared. Resolution: Clear browser cache or wait 5 minutes for auto-refresh. Prevention: Use incognito mode during password changes.</assistant>\n</example>\n</examples>',
                    structuralTags: '<thinking>\nAnalyze issue type and severity\n</thinking>\n\n<answer>\nProvide structured response\n</answer>',
                    assistantPrefill: 'Here is my analysis of the customer issue:',
                    chainOfThought: 'Think step by step: First identify the symptom, then trace back to root cause, then propose the minimal effective solution.',
                    outputFormat: 'Use this structure:\n**Root Cause:** [one sentence]\n**Resolution:** [numbered steps]\n**Prevention:** [actionable advice]',
                    modelTarget: 'Claude 3.5 Sonnet',
                    temperature: 0.3,
                    maxTokens: 1500,
                    testResults: 'Golden set: 94% accuracy on 200 support tickets\nAvg latency: 1.8s\nCost: $0.025 per call\nCustomer satisfaction: 4.7/5',
                    toolDefinitions: '{\n  "escalate_ticket": {\n    "description": "Escalate to human agent",\n    "parameters": {"reason": "string", "priority": "high|medium|low"}\n  }\n}',
                    agentWorkflow: 'Single agent (support responder)\nâ†’ Optionally calls escalate_ticket function\nâ†’ Human agent takes over if escalated',
                    contextManagement: 'Sliding window: keep last 6 messages (3 turns)\nCompress older history with summarization\nToken budget: 8K context, 1.5K completion',
                    promptInjectionDefense: 'Use XML tags to separate user input: <customer_issue>{{untrusted}}</customer_issue>\nValidate output doesn\'t leak system prompt\nMonitor for jailbreak patterns',
                    iterationNotes: 'v1: Too verbose, 350 tokens avg\nv2: Added output format, reduced to 180 tokens\nv3: Few-shot examples improved consistency to 94%\nv4: Lowered temp from 0.7â†’0.3 for more deterministic responses',
                    notes: 'OpenAI/Anthropic best practices applied:\n- Clear system role (Anthropic: system parameter)\n- XML tags for structure (Anthropic recommendation)\n- Few-shot examples in <examples> tags\n- Assistant prefill to guide tone (Claude-specific)\n- Chain-of-thought instruction for reasoning\n- Explicit output format\n- Prompt injection defense with delimiters\n- Golden test set for validation\n- Iterative refinement based on metrics'
                },
                book: {
                    name: ['Opening Scene', 'Character Introduction', 'Rising Action', 'Climactic Confrontation', 'Resolution', 'Twist Reveal', 'Emotional Payoff', 'Transition Chapter'],
                    description: 'Narrative chapter advancing plot through character development, conflict escalation, or thematic exploration. Balance dialogue, action, and description. Maintain pacing and reader engagement.',
                    wordCount: 3500,
                    targetWordCount: 4000,
                    draftStatus: 'First Draft',
                    povCharacter: 'Sarah Chen (protagonist)',
                    sceneSetting: 'Downtown coffee shop, early morning, rain outside',
                    plotFunction: 'Establishes protagonist motivation and introduces central conflict',
                    notes: 'Key considerations: POV consistency, show vs tell balance, scene vs sequel structure, sensory details, dialogue authenticity, pacing variation, emotional beats, foreshadowing.'
                },
                film: {
                    name: ['Opening Establishing Shot', 'Character Introduction', 'Emotional Dialogue', 'Action Chase Sequence', 'Atmospheric Transition', 'Climactic Confrontation', 'Dream/Memory Sequence', 'Final Resolution'],
                    description: 'AI-generated video scene created through detailed text-to-video prompting. Specify camera movement, lighting, mood, action, and visual style. Iterate on prompt wording for best results. Consider continuity across shots.',
                    aiPlatform: 'Sora (OpenAI)',
                    videoPrompt: 'A cinematic close-up shot slowly pulling back to reveal a woman in her 30s standing at a rain-streaked window overlooking a neon-lit city at night. Soft blue and purple lighting from the city illuminates her contemplative expression. Camera movement: slow dolly back. Mood: melancholic, cyberpunk aesthetic. Shot on 35mm film, shallow depth of field, bokeh lights in background.',
                    visualStyle: 'Cinematic',
                    duration: '10 seconds',
                    aspectRatio: '16:9 (Widescreen)',
                    cameraMovement: 'Dolly Out',
                    motionIntensity: 'Subtle',
                    lightingMood: 'Neon',
                    iterationNotes: 'Best practices: Be extremely specific about camera movement and speed. Mention lighting sources explicitly. Use cinematography terms (bokeh, depth of field, shot types). Reference film stock or camera models for aesthetic cues. Specify exact actions and their duration. Include mood/emotion words. Test multiple aspect ratios - some models handle certain ratios better. Start with shorter durations for complex scenes. Use "slow", "gradual", "subtle" for smoother motion.',
                    notes: 'Key considerations: Prompt engineering (specificity vs brevity), continuity between shots, aspect ratio consistency, motion artifacts detection, prompt variations for A/B testing, platform-specific strengths (Sora: physics/realism, Veo: motion control, Runway: speed), generation cost budgeting, style consistency across scenes, temporal coherence for extended clips, copyright/likeness considerations.'
                },
                course: {
                    name: ['Introduction to Topic', 'Foundational Concepts', 'Hands-On Lab Exercise', 'Case Study Analysis', 'Group Discussion', 'Skill Application Project', 'Assessment', 'Review Session'],
                    description: 'Instructional session designed to build student knowledge and skills through active learning. Combines lecture, practice, and assessment. Aligned with course learning objectives.',
                    learningObjectives: 'Students will be able to: 1) Define key concepts, 2) Apply techniques to novel problems, 3) Analyze real-world examples, 4) Evaluate trade-offs',
                    duration: '90 minutes',
                    difficultyLevel: 'Intermediate',
                    prerequisites: 'Completion of Module 2, basic programming knowledge, familiarity with data structures',
                    assessmentType: 'Quiz',
                    resourcesNeeded: 'Textbook Chapter 5, online simulation tool, practice dataset, reference handout',
                    homework: 'Complete problem set 4 (problems 1-10), read Chapter 6, prepare discussion questions',
                    notes: 'Key considerations: accessibility accommodations, engagement strategies, timing flexibility, technology backup plans, formative assessment checkpoints, inclusive pedagogy, active learning techniques.'
                },
                strategic: {
                    name: ['Digital Transformation Initiative', 'Market Expansion Strategy', 'Operational Excellence Program', 'Customer Experience Overhaul', 'Innovation Portfolio', 'Risk Mitigation Plan', 'Sustainability Initiative'],
                    description: 'Strategic initiative aligned with organizational priorities. Requires executive sponsorship, cross-functional resources, and measurable outcomes. Board-level visibility and quarterly review cadence.',
                    investment: 2500000,
                    keyMetric: 'Revenue growth in target segment',
                    targetValue: '25% year-over-year increase',
                    responsibleExecutive: 'Chief Strategy Officer',
                    strategicTheme: 'Growth',
                    riskLevel: 'Medium',
                    notes: 'Key considerations: stakeholder alignment, resource allocation, change management, governance structure, milestone tracking, competitive response, market timing, regulatory compliance.'
                },
                generic: {
                    name: {
                        land: ['Land Acquisition & Title', 'Site Purchase & Legal', 'Property Option Agreement'],
                        engineering: ['Engineering Design Services', 'Technical Specification Development', 'System Architecture'],
                        equipment: ['Equipment Procurement', 'Hardware Purchase & Installation', 'Capital Equipment'],
                        infrastructure: ['Infrastructure Development', 'Site Preparation', 'Facility Build-Out'],
                        corporate: ['Corporate Administration', 'Business Operations', 'Management Overhead'],
                        professional: ['Professional Services', 'Consulting & Advisory', 'Expert Services'],
                        contingency: ['Contingency Reserve', 'Risk Mitigation Fund', 'Budget Reserve']
                    },
                    description: {
                        equipment: 'Procurement of capital equipment with extended lead times. Requires vendor evaluation, competitive bidding, and early commitment to secure production slots.',
                        default: 'Detailed specification of deliverables, timeline, dependencies, and success criteria. Coordinate with stakeholders and manage risks proactively.'
                    },
                    cost: { p0: [50000, 100000, 250000], p1: [500000, 1000000, 2000000], p2: [25000000, 50000000, 100000000] },
                    alternateSource: 'Secondary vendors, in-house capability, strategic partnerships, or alternative procurement strategies',
                    leadTime: { p0: '2-8 weeks', p1: '3-6 months', p2: '12-24 months' },
                    notes: 'Key considerations: timeline, budget allocation, vendor selection, risk mitigation, quality assurance, regulatory compliance.'
                }
            };

            // PATTERN-AWARE SUGGESTION GENERATION - Each pattern acts as subject expert
            const patternKey = currentPattern;
            const patternData = patternSuggestions[patternKey] || patternSuggestions.generic;

            // Handle pattern-specific fields (philosophy, sales, thesis, etc.)
            if (patternData[fieldType]) {
                const suggestion = patternData[fieldType];

                // If array, pick random option
                if (Array.isArray(suggestion)) {
                    return suggestion[Math.floor(Math.random() * suggestion.length)];
                }

                // If string, return directly
                return suggestion;
            }

            // Common fields handled for all patterns
            if (fieldType === 'name') {
                if (patternKey === 'generic' && patternData.name[itemType]) {
                    const options = patternData.name[itemType];
                    return options[Math.floor(Math.random() * options.length)];
                }
                return `New ${pattern.levels.item || 'Item'}`;
            }

            if (fieldType === 'description') {
                if (patternKey === 'generic' && itemType) {
                    return patternData.description[itemType] || patternData.description.default;
                }
                return patternData.description || 'Enter detailed description here...';
            }

            if (fieldType === 'notes') {
                return patternData.notes || 'Key considerations and implementation notes...';
            }

            if (fieldType === 'icon') {
                const iconMap = {
                    philosophy: ['ðŸ¤”', 'ðŸ’­', 'ðŸ“œ', 'ðŸ›ï¸', 'âš–ï¸'],
                    sales: ['ðŸ’¼', 'ðŸ’°', 'ðŸ“Š', 'ðŸ¤', 'ðŸ“ˆ'],
                    thesis: ['ðŸ“š', 'ðŸ“', 'ðŸŽ“', 'ðŸ“–', 'âœï¸'],
                    roadmap: ['ðŸš€', 'âš¡', 'ðŸ”§', 'ðŸ’¡', 'ðŸŽ¯'],
                    prompting: ['ðŸ§ ', 'ðŸ¤–', 'âš™ï¸', 'ðŸ”®', 'ðŸ’¬'],
                    book: ['ðŸ“–', 'âœï¸', 'ðŸ“š', 'ðŸ–‹ï¸', 'ðŸ“'],
                    film: ['ðŸŽ¬', 'ðŸŽ¥', 'ðŸŽžï¸', 'ðŸŽ­', 'ðŸ“¹'],
                    course: ['ðŸ“–', 'ðŸŽ“', 'ðŸ“š', 'ðŸ‘¨â€ðŸ«', 'ðŸ“'],
                    strategic: ['ðŸŽ¯', 'ðŸ“Š', 'ðŸ›ï¸', 'ðŸ’¼', 'ðŸ—ºï¸'],
                    generic: ['ðŸ“¦', 'âš™ï¸', 'ðŸ”§', 'ðŸ“Š', 'ðŸ’¼']
                };
                const icons = iconMap[patternKey] || iconMap.generic;
                return icons[Math.floor(Math.random() * icons.length)];
            }

            // Generic pattern: cost and leadTime (other patterns don't use these)
            if (fieldType === 'cost' && patternKey === 'generic') {
                const similarItems = existingItems.filter(item => item.itemType === itemType && item.cost > 0);
                if (similarItems.length > 0) {
                    const costs = similarItems.map(i => i.cost).sort((a, b) => a - b);
                    const median = costs[Math.floor(costs.length / 2)];
                    return Math.round(median * (0.9 + Math.random() * 0.2));
                }
                const costRanges = patternData.cost[phase] || patternData.cost.p1;
                return costRanges[Math.floor(Math.random() * costRanges.length)];
            }

            if (fieldType === 'leadTime' && patternKey === 'generic') {
                return patternData.leadTime[phase] || patternData.leadTime.p1;
            }

            if (fieldType === 'alternateSource' && patternKey === 'generic') {
                return patternData.alternateSource;
            }

            return '';
        }

        // Add AI suggestion capability to text fields
        function enableAISuggestionsOnField(fieldElement, fieldType, itemContext) {
            fieldElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Check if API key available for AI mode
                const hasAPIKey = getLocalAPIKey();
                const modeLabel = hasAPIKey ? 'âœ¨ AI Suggest' : 'ðŸ’¡ Quick Suggest';
                const modeDesc = hasAPIKey ? 'AI-powered contextual suggestion' : 'Template-based suggestion (add API key for AI mode)';

                // Show smart suggestion context menu
                const menu = document.getElementById('context-menu');
                menu.innerHTML = `
                    <div class="context-item" id="ai-suggest-field">${modeLabel}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" style="font-size: 11px; color: var(--text-secondary); cursor: default; padding: 8px 14px;" onmouseover="this.style.background='transparent'">${modeDesc}</div>
                `;
                menu.style.display = 'block';

                // Position menu
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';

                // Smart positioning to avoid going off screen
                const menuRect = menu.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                let finalX = e.pageX;
                let finalY = e.pageY;

                if (menuRect.right > viewportWidth) {
                    finalX = viewportWidth - menuRect.width - 10;
                }
                if (menuRect.bottom > viewportHeight) {
                    finalY = viewportHeight - menuRect.height - 10;
                }
                if (finalX < 10) finalX = 10;
                if (finalY < 10) finalY = 10;

                menu.style.left = finalX + 'px';
                menu.style.top = finalY + 'px';

                // Attach AI suggest handler (ASYNC)
                const aiSuggestBtn = document.getElementById('ai-suggest-field');
                aiSuggestBtn.onclick = async () => {
                    console.log('ðŸ” Smart Suggest clicked:', fieldType, hasAPIKey ? 'AI mode' : 'Quick mode');
                    menu.style.display = 'none';

                    // Get current context including notes field value
                    const currentContext = { ...itemContext };
                    const notesField = document.getElementById('edit-notes');
                    if (notesField) {
                        currentContext.notes = notesField.value;
                    }

                    console.log('ðŸ“‹ Context:', currentContext);

                    // Show loading state
                    const originalValue = fieldElement.value;
                    const originalPlaceholder = fieldElement.placeholder;
                    fieldElement.value = '';
                    fieldElement.placeholder = hasAPIKey ? 'âœ¨ AI is thinking...' : 'ðŸ’¡ Generating suggestion...';
                    fieldElement.style.transition = 'all 0.3s';
                    fieldElement.style.background = 'rgba(99, 102, 241, 0.1)';
                    fieldElement.disabled = true;

                    try {
                        console.log('â³ Calling generateAISuggestion...');
                        // Call AI suggestion (async)
                        const suggestion = await generateAISuggestion(fieldType, currentContext);
                        console.log('âœ… Got suggestion:', suggestion);

                        // Apply suggestion
                        fieldElement.value = suggestion;

                        // Trigger input event for any listeners
                        fieldElement.dispatchEvent(new Event('input', { bubbles: true }));

                        // Success feedback
                        fieldElement.style.background = 'rgba(0, 166, 125, 0.15)';
                        setTimeout(() => {
                            fieldElement.style.background = 'var(--bg)';
                        }, 600);

                    } catch (error) {
                        console.error('âŒ Smart Suggest error:', error);
                        console.error('Error stack:', error.stack);

                        // Restore original value on error
                        fieldElement.value = originalValue;

                        // Error feedback
                        fieldElement.style.background = 'rgba(239, 68, 68, 0.1)';
                        setTimeout(() => {
                            fieldElement.style.background = 'var(--bg)';
                        }, 600);

                        // Show error to user
                        alert(`Smart Suggest Error: ${error.message}\n\nCheck browser console (F12) for details.`);
                    } finally {
                        console.log('ðŸ”„ Re-enabling field');
                        // Re-enable field
                        fieldElement.disabled = false;
                        fieldElement.placeholder = originalPlaceholder;
                    }
                };
            });
        }

        // Helper function to generate dynamic field HTML based on pattern
        function generateFieldHTML(fieldKey, fieldConfig, node) {
            const value = node[fieldKey] || '';
            const fieldId = `edit-${fieldKey}`;

            let inputHTML = '';

            if (fieldConfig.type === 'select') {
                const options = fieldConfig.options.map(opt =>
                    `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`
                ).join('');
                inputHTML = `<select id="${fieldId}">${options}</select>`;
            } else if (fieldConfig.type === 'textarea') {
                inputHTML = `<textarea id="${fieldId}" placeholder="${fieldConfig.placeholder || ''}" style="min-height: 80px;">${value}</textarea>`;
            } else if (fieldConfig.type === 'number') {
                const min = fieldConfig.min !== undefined ? `min="${fieldConfig.min}"` : '';
                const max = fieldConfig.max !== undefined ? `max="${fieldConfig.max}"` : '';
                const step = fieldConfig.step !== undefined ? `step="${fieldConfig.step}"` : '';
                inputHTML = `<input type="number" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" ${min} ${max} ${step} />`;
            } else if (fieldConfig.type === 'date') {
                inputHTML = `<input type="date" id="${fieldId}" value="${value}" />`;
            } else {
                // default to text
                inputHTML = `<input type="text" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" />`;
            }

            return `
                <div class="form-group">
                    <label>${fieldConfig.label} <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                    ${inputHTML}
                    ${fieldConfig.helpText ? `<p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">${fieldConfig.helpText}</p>` : ''}
                </div>
            `;
        }

        function handleEdit() {
            if (!activeNode) return;

            // Simple name editing for root and phase nodes
            if (activeNode.type === 'root' || activeNode.type === 'phase') {
                const labels = getPatternLabels();
                const nodeType = activeNode.type === 'root' ? labels.root : labels.phase;
                const newName = prompt(`Enter new ${nodeType} name:`, activeNode.name);

                if (newName && newName !== activeNode.name) {
                    activeNode.name = newName;
                    render();
                }
                return;
            }

            // Full edit modal for items and subtasks
            if (activeNode.type === 'item' || activeNode.type === 'subtask') {
                const modal = document.getElementById('edit-modal');
                const body = document.getElementById('edit-modal-body');

                // Get all items from all phases for dependency selection
                function getAllItems(node, items = [], phaseName = '') {
                    if (node.phase !== undefined) phaseName = `Phase ${node.phase}`;
                    if (node.items) {
                        node.items.forEach(item => {
                            items.push({ ...item, phaseName });
                        });
                    }
                    if (node.children) {
                        node.children.forEach(child => getAllItems(child, items, phaseName));
                    }
                    return items;
                }

                const allItems = getAllItems(capexTree).filter(item => item.id !== activeNode.id);

                // Build dependency checkboxes
                const currentDeps = activeNode.dependencies || [];
                const depsHtml = allItems.map(item => {
                    const checked = currentDeps.includes(item.id) ? 'checked' : '';
                    return `
                        <label style="display: flex; align-items: center; gap: 10px; padding: 8px 10px; cursor: pointer; font-weight: normal; text-transform: none; letter-spacing: normal; border-radius: 6px; transition: background 0.2s; margin-bottom: 4px;" onmouseover="this.style.background='var(--card-bg-light)'" onmouseout="this.style.background='transparent'">
                            <input type="checkbox" class="dep-checkbox" value="${item.id}" ${checked} style="flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; accent-color: var(--treeplex-primary);" />
                            <span style="flex: 1; display: flex; align-items: center; gap: 8px; font-size: 14px;">
                                <span style="font-size: 18px; flex-shrink: 0;">${item.icon}</span>
                                <span style="flex: 1; color: var(--text-primary);">${item.name}</span>
                                <span style="color: var(--text-secondary); font-size: 11px; padding: 2px 8px; background: var(--card-bg); border-radius: 4px; border: 1px solid var(--border);">${item.phaseName}</span>
                            </span>
                        </label>
                    `;
                }).join('');

                // Get current pattern and its fields configuration
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                // Check if PM tracking should be shown
                const showTracking = fields.includeTracking &&
                                    fields.trackingFor &&
                                    fields.trackingFor.includes(activeNode.type);

                // Build field HTML
                let fieldsHTML = '';

                // 1. PM Tracking Section (conditional)
                if (showTracking) {
                    // Calculate RAG status color
                    const ragStatus = activeNode.pmRAGStatus || 'Amber';
                    const ragColors = {
                        'Green': '#22C55E',
                        'Amber': '#F59E0B',
                        'Red': '#EF4444'
                    };
                    const ragColor = ragColors[ragStatus] || ragColors.Amber;

                    // Calculate time tracking metrics
                    const estHours = activeNode.pmEstimatedHours || 0;
                    const actHours = activeNode.pmActualHours || 0;
                    const remHours = activeNode.pmRemainingHours || estHours - actHours;
                    const timeProgress = estHours > 0 ? Math.min(100, (actHours / estHours) * 100) : 0;
                    const isOverBudget = actHours > estHours;

                    fieldsHTML += `
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--treeplex-primary);">ðŸŽ¯ Project Management</h3>

                        <!-- PM Infographic Dashboard -->
                        <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(99, 102, 241, 0.05) 100%); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 16px;">
                                <!-- RAG Status Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">RAG Status</div>
                                    <div style="width: 48px; height: 48px; border-radius: 50%; background: ${ragColor}; margin: 0 auto; box-shadow: 0 4px 12px ${ragColor}40, inset 0 2px 4px rgba(255,255,255,0.3);"></div>
                                    <div style="font-size: 13px; font-weight: 600; margin-top: 8px; color: ${ragColor};">${ragStatus}</div>
                                </div>

                                <!-- Progress Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Progress</div>
                                    <div style="position: relative; width: 64px; height: 64px; margin: 0 auto;">
                                        <svg width="64" height="64" style="transform: rotate(-90deg);">
                                            <circle cx="32" cy="32" r="28" stroke="var(--border)" stroke-width="6" fill="none"></circle>
                                            <circle cx="32" cy="32" r="28" stroke="var(--treeplex-primary)" stroke-width="6" fill="none"
                                                stroke-dasharray="${(activeNode.pmProgress || 0) * 1.759} 175.9"
                                                stroke-linecap="round"
                                                style="transition: stroke-dasharray 0.3s ease;"></circle>
                                        </svg>
                                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 16px; font-weight: 700; color: var(--treeplex-primary);">${activeNode.pmProgress || 0}%</div>
                                    </div>
                                </div>

                                <!-- Priority Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Priority</div>
                                    <div style="margin-top: 4px;">
                                        ${(() => {
                                            const priority = activeNode.pmPriority || 'Medium';
                                            const priorityIcons = {
                                                'Low': 'ðŸŸ¢',
                                                'Medium': 'ðŸŸ¡',
                                                'High': 'ðŸŸ ',
                                                'Critical': 'ðŸ”´'
                                            };
                                            return `<div style="font-size: 32px; margin: 4px 0;">${priorityIcons[priority] || priorityIcons.Medium}</div>
                                                   <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${priority}</div>`;
                                        })()}
                                    </div>
                                </div>
                            </div>

                            <!-- Time Tracking Visualization -->
                            ${estHours > 0 ? `
                            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
                                <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Time Tracking</div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 12px;">
                                    <span>â±ï¸ Estimated: <strong>${estHours}h</strong></span>
                                    <span>âœ… Actual: <strong style="color: ${isOverBudget ? '#EF4444' : '#22C55E'};">${actHours}h</strong></span>
                                    <span>â³ Remaining: <strong>${remHours}h</strong></span>
                                </div>
                                <div style="width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
                                    <div style="width: ${timeProgress}%; height: 100%; background: ${isOverBudget ? '#EF4444' : '#22C55E'}; transition: width 0.3s ease;"></div>
                                </div>
                                ${isOverBudget ? `<div style="font-size: 11px; color: #EF4444; margin-top: 4px; font-weight: 600;">âš ï¸ Over Budget by ${actHours - estHours}h</div>` : ''}
                            </div>
                            ` : ''}
                        </div>

                        <!-- PM Form Fields -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                            <div class="form-group">
                                <label>Status</label>
                                <select id="edit-pm-status">
                                    <option value="To Do" ${activeNode.pmStatus === 'To Do' ? 'selected' : ''}>To Do</option>
                                    <option value="In Progress" ${activeNode.pmStatus === 'In Progress' ? 'selected' : ''}>In Progress</option>
                                    <option value="Completed" ${activeNode.pmStatus === 'Completed' ? 'selected' : ''}>Completed</option>
                                    <option value="Blocked" ${activeNode.pmStatus === 'Blocked' ? 'selected' : ''}>Blocked</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>RAG Status ðŸš¦</label>
                                <select id="edit-pm-rag-status">
                                    <option value="Green" ${ragStatus === 'Green' ? 'selected' : ''}>ðŸŸ¢ Green - On Track</option>
                                    <option value="Amber" ${ragStatus === 'Amber' ? 'selected' : ''}>ðŸŸ¡ Amber - At Risk</option>
                                    <option value="Red" ${ragStatus === 'Red' ? 'selected' : ''}>ðŸ”´ Red - Critical</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Owner Email ðŸ‘¤</label>
                            <input type="email" id="edit-pm-owner-email" value="${activeNode.pmOwnerEmail || activeNode.pmAssignee || ''}" placeholder="owner@company.com" />
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 4px; font-style: italic;">ðŸ“§ Email for collaborative pipeline reviews</p>
                        </div>
                        <div class="form-group">
                            <label>Progress (%)</label>
                            <input type="number" id="edit-pm-progress" value="${activeNode.pmProgress || 0}" min="0" max="100" step="5" />
                        </div>
                        <div class="form-group">
                            <label>Priority</label>
                            <select id="edit-pm-priority">
                                <option value="Low" ${activeNode.pmPriority === 'Low' ? 'selected' : ''}>Low</option>
                                <option value="Medium" ${activeNode.pmPriority === 'Medium' ? 'selected' : ''}>Medium</option>
                                <option value="High" ${activeNode.pmPriority === 'High' ? 'selected' : ''}>High</option>
                                <option value="Critical" ${activeNode.pmPriority === 'Critical' ? 'selected' : ''}>Critical</option>
                            </select>
                        </div>

                        <!-- Time Management Fields -->
                        <div style="margin-top: 16px; padding: 16px; background: rgba(99, 102, 241, 0.05); border: 1px dashed var(--border); border-radius: 8px;">
                            <h4 style="font-size: 14px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">â±ï¸ Time Management</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Estimated (hours)</label>
                                    <input type="number" id="edit-pm-estimated-hours" value="${estHours}" min="0" step="0.5" placeholder="0" />
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Actual (hours)</label>
                                    <input type="number" id="edit-pm-actual-hours" value="${actHours}" min="0" step="0.5" placeholder="0" />
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Remaining (hours)</label>
                                    <input type="number" id="edit-pm-remaining-hours" value="${remHours}" min="0" step="0.5" placeholder="Auto" />
                                </div>
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">ðŸ’¡ Remaining auto-calculates if left empty (Estimated - Actual)</p>
                        </div>
                        <div class="form-group">
                            <label>Start Date</label>
                            <input type="date" id="edit-pm-start-date" value="${activeNode.pmStartDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>Due Date</label>
                            <input type="date" id="edit-pm-due-date" value="${activeNode.pmDueDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>ðŸš§ Blocking Issue <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                            <textarea id="edit-pm-blocking-issue" style="min-height: 60px;" placeholder="What's preventing progress?">${activeNode.pmBlockingIssue || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>âž¡ï¸ Next Steps <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                            <textarea id="edit-pm-next-steps" style="min-height: 80px;" placeholder="Specific actions needed...">${activeNode.pmNextSteps || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>PM Notes</label>
                            <textarea id="edit-pm-notes" style="min-height: 80px;" placeholder="Task-specific notes, blockers, action items...">${activeNode.pmNotes || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>ðŸ“ Latest Updates</label>
                            <div style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 8px; max-height: 200px; overflow-y: auto;">
                                ${activeNode.pmUpdates && activeNode.pmUpdates.length > 0 ? activeNode.pmUpdates.map((update, idx) => `
                                    <div style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border);">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">${new Date(update.timestamp).toLocaleString()}</div>
                                        <div style="font-size: 13px; line-height: 1.5;">${update.text}</div>
                                        <button onclick="window.deleteUpdate(${idx})" style="margin-top: 6px; padding: 2px 8px; font-size: 10px; background: rgba(239, 68, 68, 0.2); border: 1px solid #EF4444; border-radius: 4px; color: #EF4444; cursor: pointer;">Delete</button>
                                    </div>
                                `).join('') : '<p style="color: var(--text-secondary); font-size: 13px; text-align: center; padding: 20px;">No updates yet</p>'}
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <textarea id="edit-pm-new-update" style="flex: 1; min-height: 60px;" placeholder="Add a new update..."></textarea>
                                <button onclick="window.addUpdate()" style="padding: 8px 16px; background: var(--treeplex-primary); border: none; border-radius: 6px; color: white; font-weight: 600; cursor: pointer; white-space: nowrap;">Add Update</button>
                            </div>
                        </div>
                        <hr style="margin: 24px 0; border: none; border-top: 1px solid var(--border);" />
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--text-secondary);">Details</h3>
                    `;
                }

                // 2. Universal Fields (always shown)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Name <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                        <input type="text" id="edit-name" value="${activeNode.name || ''}" />
                    </div>
                    <div class="form-group">
                        <label>Description <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                        <textarea id="edit-description">${activeNode.description || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label>Icon <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                        <input type="text" id="edit-icon" value="${activeNode.icon || ''}" maxlength="2" />
                    </div>
                    <div class="form-group">
                        <label>Type</label>
                        <select id="edit-type">
                            ${PATTERNS[currentPattern].types.map(type =>
                                `<option value="${type.value}" ${activeNode.itemType === type.value ? 'selected' : ''}>${type.label}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;

                // 3. Pattern-Specific Custom Fields (dynamic)
                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }
                    const fieldConfig = fields[fieldKey];
                    fieldsHTML += generateFieldHTML(fieldKey, fieldConfig, activeNode);
                });

                // 4. Notes (universal)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Notes <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                        <textarea id="edit-notes" style="min-height: 100px;" placeholder="Additional notes...">${activeNode.notes || ''}</textarea>
                    </div>
                `;

                // 5. Dependencies (conditional)
                if (fields.includeDependencies) {
                    fieldsHTML += `
                        <div class="form-group">
                            <label>Dependencies</label>
                            <div style="max-height: 240px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 6px; background: var(--bg);">
                                ${depsHtml || '<p style="color: var(--text-secondary); font-size: 13px; margin: 0; padding: 10px; text-align: center;">No other items available</p>'}
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">âœ“ Select prerequisite items that must be completed first</p>
                        </div>
                    `;
                }

                body.innerHTML = fieldsHTML;

                modal.style.display = 'flex';

                // Enable AI suggestions on text fields after modal is displayed
                setTimeout(() => {
                    // Universal fields
                    const nameField = document.getElementById('edit-name');
                    const descField = document.getElementById('edit-description');
                    const iconField = document.getElementById('edit-icon');
                    const notesField = document.getElementById('edit-notes');

                    if (nameField) enableAISuggestionsOnField(nameField, 'name', activeNode);
                    if (descField) enableAISuggestionsOnField(descField, 'description', activeNode);
                    if (iconField) enableAISuggestionsOnField(iconField, 'icon', activeNode);
                    if (notesField) enableAISuggestionsOnField(notesField, 'notes', activeNode);

                    // Pattern-specific fields (dynamic)
                    Object.keys(fields).forEach(fieldKey => {
                        if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                            return;
                        }
                        const fieldElement = document.getElementById(`edit-${fieldKey}`);
                        if (fieldElement) {
                            enableAISuggestionsOnField(fieldElement, fieldKey, activeNode);
                        }
                    });

                    // Enable AI suggestions for PM fields (conditional)
                    if (showTracking) {
                        const pmBlockingIssueField = document.getElementById('edit-pm-blocking-issue');
                        const pmNextStepsField = document.getElementById('edit-pm-next-steps');

                        if (pmBlockingIssueField) enableAISuggestionsOnField(pmBlockingIssueField, 'pmBlockingIssue', activeNode);
                        if (pmNextStepsField) enableAISuggestionsOnField(pmNextStepsField, 'pmNextSteps', activeNode);
                    }
                }, 50);
            }
        }

        function handleCreate() {
            if (activeNode && activeNode.type === 'phase') {
                // Save state for undo
                saveState(`Create item in ${activeNode.name}`);

                // Create new item in this phase
                const labels = getPatternLabels();
                const defaultType = PATTERNS[currentPattern].types[0].value;
                const newItem = {
                    id: `p${activeNode.phase}-${Date.now()}`,
                    name: `New ${labels.item}`,
                    description: 'Enter description',
                    cost: 0,
                    icon: 'ðŸ“¦',
                    itemType: defaultType,
                    type: 'item',
                    dependencies: [],
                    provenance: {
                        source: 'user',
                        timestamp: new Date().toISOString()
                    }
                };

                if (!activeNode.items) activeNode.items = [];
                activeNode.items.push(newItem);
                activeNode.expanded = true;
                render();
            }
        }

        function handleAddSubtask() {
            // Allow both items AND subtasks to have nested sub-tasks
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask')) {
                const labels = getPatternLabels();
                const isNestedSubtask = activeNode.type === 'subtask';
                const promptLabel = isNestedSubtask ? `nested ${labels.subtask}` : labels.subtask;

                // Prompt for sub-task name
                const subtaskName = prompt(`Enter ${promptLabel} name:`, `New ${isNestedSubtask ? 'Nested ' : ''}${labels.subtask}`);
                if (!subtaskName) return;

                // Save state for undo
                saveState(`Add subtask to ${activeNode.name}`);

                // Get today's date in YYYY-MM-DD format
                const today = new Date().toISOString().split('T')[0];

                // Create new sub-task with PM fields
                const newSubtask = {
                    id: `${activeNode.id}-sub-${Date.now()}`,
                    name: subtaskName,
                    description: 'Task description',
                    cost: 0,
                    icon: 'ðŸ“‹',
                    itemType: 'subtask',
                    type: 'subtask',
                    dependencies: [],
                    parentId: activeNode.id,
                    // Project Management fields
                    pmStatus: 'To Do',
                    pmAssignee: 'Unassigned',
                    pmStartDate: today,
                    pmDueDate: today,
                    pmProgress: 0,
                    pmPriority: 'Medium',
                    pmNotes: '',
                    pmBlockingIssue: '',
                    pmNextSteps: '',
                    pmUpdates: [],
                    // Initialize subItems for nested support
                    subItems: [],
                    // Provenance stamping
                    provenance: {
                        source: 'user',
                        timestamp: new Date().toISOString()
                    }
                };

                // Initialize subItems array if it doesn't exist
                if (!activeNode.subItems) activeNode.subItems = [];
                activeNode.subItems.push(newSubtask);

                // Mark parent as expanded to show sub-tasks
                activeNode.expanded = true;

                render();
                document.getElementById('context-menu').style.display = 'none';
            }
        }

        function handleDelete() {
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask')) {
                const itemType = activeNode.type === 'subtask' ? 'sub-task' : 'item';
                if (confirm(`Delete "${activeNode.name}" ${itemType}?`)) {
                    // Save state for undo
                    saveState(`Delete ${itemType}: ${activeNode.name}`);
                    if (activeNode.type === 'subtask') {
                        // Remove subtask from its parent item
                        function removeSubtask(subtaskId, node = capexTree) {
                            if (node.items) {
                                for (let item of node.items) {
                                    if (item.subItems) {
                                        const index = item.subItems.findIndex(s => s.id === subtaskId);
                                        if (index !== -1) {
                                            item.subItems.splice(index, 1);
                                            return true;
                                        }
                                    }
                                }
                            }
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeSubtask(subtaskId, child)) return true;
                                }
                            }
                            return false;
                        }
                        removeSubtask(activeNode.id);
                    } else {
                        // Find and remove the item from its parent phase
                        function removeItem(itemId, node = capexTree) {
                            if (node.items) {
                                const index = node.items.findIndex(i => i.id === itemId);
                                if (index !== -1) {
                                    node.items.splice(index, 1);
                                    return true;
                                }
                            }
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeItem(itemId, child)) return true;
                                }
                            }
                            return false;
                        }
                        removeItem(activeNode.id);
                    }
                    render();
                }
            }
        }

        // =============================================================================
        // TREE MANAGER - Save/Load with Auto-Save & Organized Folders
        // =============================================================================

        class TreeManager {
            constructor() {
                this.currentTreeId = null;
                this.lastSaveTimestamp = null;
                this.hasUnsavedChanges = false;
                this.autoSaveInterval = null;
            }

            initialize() {
                console.log('ðŸŒ³ TreeManager: Initializing...');
                console.log('ðŸ’¾ Save mode: LocalStorage + Download to Downloads folder');
                this.loadTreeFromURLOrStorage();
                this.startAutoSave(120);
                this.startIndicatorUpdates();
                this.watchForChanges();
            }

            getTimestamp() {
                const now = new Date();
                const y = now.getFullYear();
                const m = String(now.getMonth() + 1).padStart(2, '0');
                const d = String(now.getDate()).padStart(2, '0');
                const h = String(now.getHours()).padStart(2, '0');
                const min = String(now.getMinutes()).padStart(2, '0');
                const s = String(now.getSeconds()).padStart(2, '0');
                return `${y}${m}${d}-${h}${min}${s}`;
            }

            slugify(text) {
                return text.toString().toLowerCase().trim()
                    .replace(/\s+/g, '-').replace(/[^\w\-]+/g, '')
                    .replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
            }

            generateFilename(tree) {
                const pattern = tree.pattern?.key || 'generic';
                const treeName = tree.name || 'project';
                const slug = this.slugify(treeName);
                const timestamp = this.getTimestamp();

                // Format: treelisty-<pattern>-<name>-<timestamp>.json
                // Example: treelisty-philosophy-plato-cave-20251118-153045.json
                return `treelisty-${pattern}-${slug}-${timestamp}.json`;
            }

            saveToLocalStorage(tree) {
                try {
                    const treeId = tree.id || 'default';
                    const jsonStr = JSON.stringify(tree, null, 2);
                    localStorage.setItem(`treelisty:tree:${treeId}`, jsonStr);
                    const metadata = this.extractMetadata(tree);
                    localStorage.setItem(`treelisty:meta:${treeId}`, JSON.stringify(metadata));
                    this.lastSaveTimestamp = Date.now();
                    this.hasUnsavedChanges = false;
                    console.log(`ðŸ’¾ Saved to LocalStorage: ${treeId}`);
                    return true;
                } catch (error) {
                    console.error('âŒ LocalStorage save failed:', error);
                    return false;
                }
            }

            extractMetadata(tree) {
                return {
                    id: tree.id || 'default',
                    name: tree.name || 'Untitled',
                    pattern: tree.pattern?.key || 'generic',
                    itemCount: this.countItems(tree),
                    lastModified: Date.now(),
                    lastSaved: this.lastSaveTimestamp
                };
            }

            countItems(tree) {
                let count = 0;
                if (tree.children) {
                    tree.children.forEach(phase => {
                        if (phase.items) {
                            count += phase.items.length;
                            phase.items.forEach(item => {
                                if (item.subItems) count += item.subItems.length;
                                if (item.subtasks) count += item.subtasks.length;
                            });
                        }
                    });
                }
                return count;
            }

            downloadJSON(tree) {
                try {
                    const filename = this.generateFilename(tree);
                    const jsonStr = JSON.stringify(tree, null, 2);
                    const blob = new Blob([jsonStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    console.log(`ðŸ’¾ Downloaded: ${filename}`);
                    if (typeof showToast === 'function') showToast(`âœ… Saved: ${filename}`);
                    return true;
                } catch (error) {
                    console.error('âŒ Download failed:', error);
                    return false;
                }
            }

            save(tree, options = {}) {
                const { silent = false, forceSaveAs = false } = options;

                // Save to LocalStorage for auto-save tracking
                this.saveToLocalStorage(tree);

                // Download JSON file (only on manual save, not auto-save)
                if (!silent) {
                    this.downloadJSON(tree);
                    this.updateSaveIndicator('saved');
                }

                this.addToRecentFiles(tree);
            }

            startAutoSave(intervalSeconds) {
                console.log(`â° Auto-save enabled: every ${intervalSeconds} seconds`);
                this.autoSaveInterval = setInterval(() => {
                    if (this.hasUnsavedChanges) {
                        console.log('ðŸ’¾ Auto-saving...');
                        this.save(capexTree, { silent: true });
                    }
                }, intervalSeconds * 1000);
            }

            startIndicatorUpdates() {
                // Update save indicator every 30 seconds to keep "Saved Xm ago" current
                setInterval(() => {
                    if (this.lastSaveTimestamp && !this.hasUnsavedChanges) {
                        this.updateSaveIndicator('saved');
                    }
                }, 30000); // 30 seconds
            }

            watchForChanges() {
                this.hasUnsavedChanges = true;
            }

            markAsChanged() {
                this.hasUnsavedChanges = true;
                this.updateSaveIndicator('unsaved');
            }

            updateSaveIndicator(status) {
                const indicator = document.getElementById('save-indicator');
                if (!indicator) return;
                if (status === 'saving') {
                    indicator.textContent = 'ðŸ’¾ Saving...';
                    indicator.style.color = '#9DA3B4';
                } else if (status === 'saved') {
                    const timeAgo = this.getTimeAgo(this.lastSaveTimestamp);
                    indicator.textContent = `âœ“ Saved ${timeAgo}`;
                    indicator.style.color = '#5FA463';
                } else if (status === 'unsaved') {
                    indicator.textContent = 'â— Unsaved changes';
                    indicator.style.color = '#D68A2E';
                }
            }

            getTimeAgo(timestamp) {
                if (!timestamp) return 'just now';
                const seconds = Math.floor((Date.now() - timestamp) / 1000);
                if (seconds < 10) return 'just now';
                if (seconds < 60) return `${seconds}s ago`;
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            }

            addToRecentFiles(tree) {
                try {
                    let recent = this.getRecentFiles();
                    const metadata = this.extractMetadata(tree);
                    recent = recent.filter(r => r.id !== metadata.id);
                    recent.unshift(metadata);
                    recent = recent.slice(0, 10);
                    localStorage.setItem('treelisty:recent', JSON.stringify(recent));
                } catch (error) {
                    console.error('âŒ Failed to update recent files:', error);
                }
            }

            getRecentFiles() {
                try {
                    const data = localStorage.getItem('treelisty:recent');
                    return data ? JSON.parse(data) : [];
                } catch (error) {
                    return [];
                }
            }

            loadTreeFromURLOrStorage() {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('data')) {
                    console.log('ðŸ“¥ Loading tree from shared URL...');
                    return;
                }
                const treeId = 'default';
                const treeData = localStorage.getItem(`treelisty:tree:${treeId}`);
                if (treeData) {
                    try {
                        const tree = JSON.parse(treeData);
                        
                        // Migrate tree to current schema (Cognitive Citadel Foundation)
                        migrateTree(tree);
                        
                        console.log('ðŸ“¥ Loaded tree from LocalStorage:', treeId);
                        Object.assign(capexTree, tree);
                        this.currentTreeId = treeId;
                    } catch (error) {
                        console.error('âŒ Failed to load tree from LocalStorage:', error);
                    }
                }
            }
        }

        const treeManager = new TreeManager();
        window.addEventListener('DOMContentLoaded', () => {
            treeManager.initialize();
        });

        // Enhanced save function
        function handleDownload() {
            treeManager.save(capexTree, { forceSaveAs: false });
        }

        function handleUpload() {
            document.getElementById('json-upload-input').click();
        }

        function handleExpandAll() {
            function expandAll(node) {
                if (node.children) {
                    node.expanded = true;
                    node.children.forEach(expandAll);
                }
            }
            expandAll(capexTree);
            render();
        }

        function handleCollapseAll() {
            function collapseAll(node) {
                if (node.children) {
                    node.expanded = false;
                    node.children.forEach(collapseAll);
                }
            }
            capexTree.children.forEach(collapseAll);
            render();
        }

        // Toggle subtasks for a specific item
        window.toggleSubtasks = function(itemId) {
            function findAndToggle(node) {
                if (node.items) {
                    const item = node.items.find(i => i.id === itemId);
                    if (item) {
                        item.expanded = !item.expanded;
                        render();
                        return true;
                    }
                }
                if (node.children) {
                    for (let child of node.children) {
                        if (findAndToggle(child)) return true;
                    }
                }
                return false;
            }
            findAndToggle(capexTree);
        };

        // Add update to current activeNode
        window.addUpdate = function() {
            if (!activeNode) return;
            const updateText = document.getElementById('edit-pm-new-update').value.trim();
            if (!updateText) {
                alert('Please enter an update message');
                return;
            }

            if (!activeNode.pmUpdates) activeNode.pmUpdates = [];
            activeNode.pmUpdates.unshift({
                timestamp: new Date().toISOString(),
                text: updateText
            });

            // Clear the input and re-render the modal
            document.getElementById('edit-pm-new-update').value = '';
            handleEdit(); // Re-render the edit modal to show the new update
        };

        // Delete update from current activeNode
        window.deleteUpdate = function(index) {
            if (!activeNode || !activeNode.pmUpdates) return;
            if (confirm('Delete this update?')) {
                activeNode.pmUpdates.splice(index, 1);
                handleEdit(); // Re-render the edit modal
            }
        };

        async function handleAI() {
            if (activeNode) {
                const modal = document.getElementById('modal');
                const modalBody = document.getElementById('modal-body');

                // Show loading state
                modalBody.innerHTML = `
                    <div style="padding: 40px; text-align: center;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">AI is analyzing ${activeNode.name}...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                `;
                modal.style.display = 'flex';

                try {
                    // Determine analysis type (subtask, item, or project)
                    let analysisType = 'item';
                    if (activeNode.type === 'root') {
                        analysisType = 'project';
                    } else if (activeNode.type === 'subtask') {
                        analysisType = 'subtask';
                    }

                    // Call real AI
                    const aiResponse = await generateAIAnalysis(activeNode, analysisType);

                    // Display AI response with markdown-like formatting
                    modalBody.innerHTML = `
                        <div style="padding: 20px; line-height: 1.8;">
                            <div style="white-space: pre-wrap; font-size: 14px; color: var(--text-primary);">${aiResponse}</div>
                            <div style="margin-top: 24px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ðŸ¤– Analysis powered by Claude Sonnet â€¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;

                } catch (error) {
                    // Show error
                    modalBody.innerHTML = `
                        <div style="padding: 30px; text-align: center;">
                            <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                            <h3 style="margin-bottom: 16px; color: var(--text-primary);">AI Analysis Failed</h3>
                            <p style="margin-bottom: 24px; color: var(--text-secondary); line-height: 1.6;">
                                ${error.message}
                            </p>
                            <p style="font-size: 12px; color: var(--text-secondary);">
                                If this problem persists, contact geej support.
                            </p>
                        </div>
                    `;
                }
            }
        }

        // =============================================================================
        // DEEP DIVE ANALYSIS - Structured Scholar for Selected Nodes
        // =============================================================================
        // PHILOSOPHY RELATIONSHIP INFERENCE HELPERS
        // =============================================================================

        /**
         * Infer dialectical relation between nodes based on their types
         */
        function inferDialecticalRelation(nodes) {
            const types = nodes.map(n => n.itemType).filter(Boolean);

            // Check for thesis-antithesis patterns
            if (types.includes('premise') && types.includes('objection')) {
                return 'Thesis-Antithesis: A claim is challenged by a counter-argument';
            }
            if (types.includes('premise') && types.includes('refutation')) {
                return 'Dialectical Exchange: Premises face critical refutation';
            }
            if (types.includes('conclusion') && types.includes('objection')) {
                return 'Conclusion Under Scrutiny: Final claim faces objection';
            }
            if (types.includes('definition') && types.includes('distinction')) {
                return 'Conceptual Clarification: Definitions refined through distinction';
            }
            if (types.includes('implicit-premise') && types.includes('premise')) {
                return 'Hidden Foundations: Explicit claims rest on implicit assumptions';
            }
            if (types.every(t => t === 'premise')) {
                return 'Cumulative Argument: Multiple premises building toward conclusion';
            }
            if (types.includes('thought-experiment')) {
                return 'Exploratory Dialectic: Thought experiments probe conceptual boundaries';
            }

            return 'Conceptual Network: Interrelated philosophical claims';
        }

        /**
         * Infer argumentative flow direction
         */
        function inferArgumentativeFlow(nodes) {
            const types = nodes.map(n => n.itemType).filter(Boolean);

            if (types.includes('premise') && types.includes('conclusion')) {
                return 'Deductive: Premises â†’ Conclusion';
            }
            if (types.includes('objection') && types.includes('refutation')) {
                return 'Refutational: Objection â†’ Counter-Response';
            }
            if (types.filter(t => t === 'premise').length >= 2) {
                return 'Synthetic: Multiple premises converging';
            }
            if (types.includes('distinction')) {
                return 'Analytical: Concepts being differentiated';
            }
            if (types.includes('definition')) {
                return 'Foundational: Establishing base definitions';
            }

            return 'Exploratory: Mapping conceptual territory';
        }

        /**
         * Infer the conceptual bridge connecting the nodes
         */
        function inferConceptualBridge(nodes) {
            // Look for shared key terms or speakers
            const allKeyTerms = nodes.flatMap(n => n.keyTerms || []);
            const termCounts = {};
            allKeyTerms.forEach(t => {
                const term = typeof t === 'string' ? t : t.term;
                if (term) termCounts[term] = (termCounts[term] || 0) + 1;
            });

            // Find terms appearing in multiple nodes
            const sharedTerms = Object.entries(termCounts)
                .filter(([_, count]) => count > 1)
                .map(([term, _]) => term);

            if (sharedTerms.length > 0) {
                return `Shared Concepts: ${sharedTerms.slice(0, 3).join(', ')}`;
            }

            // Check speakers
            const speakers = [...new Set(nodes.map(n => n.speaker).filter(Boolean))];
            if (speakers.length === 1) {
                return `Single Voice: All claims attributed to ${speakers[0]}`;
            }
            if (speakers.length > 1) {
                return `Dialogue: Exchange between ${speakers.slice(0, 2).join(' and ')}`;
            }

            return 'Thematic Unity: Connected through subject matter';
        }

        // =============================================================================
        // DEEP DIVE ANALYSIS (Structured Scholar)
        // =============================================================================
        // Enriches selected nodes with:
        // - subItems (objections, counter-arguments, implications)
        // - Missing fields (speaker, keyTerms, textualReference)
        // - Creates hyperedge linking analyzed nodes
        // =============================================================================

        async function handleAnalyzeSelection(nodes) {
            if (!nodes || nodes.length === 0) {
                console.warn('No nodes to analyze');
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            // Get pattern context
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;
            const isPhilosophy = currentPattern === 'philosophy';

            // Show loading state with progress
            const nodeNames = nodes.map(n => n.name).join(', ');
            const truncatedNames = nodeNames.length > 100 ? nodeNames.substring(0, 100) + '...' : nodeNames;

            modalBody.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <div class="spinner" style="margin: 0 auto 20px;"></div>
                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px;">ðŸŽ“ Deep Dive Analysis</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 8px;">
                        Analyzing ${nodes.length} node${nodes.length > 1 ? 's' : ''}...
                    </p>
                    <p style="font-size: 12px; color: var(--text-secondary); opacity: 0.7;">
                        ${truncatedNames}
                    </p>
                    <div style="margin-top: 20px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 8px;">
                        <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                            ðŸ”¬ Structured Scholar technique: Identifying objections, implications, and hidden premises...
                        </p>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';

            try {
                // Build context from tree
                const treeContext = {
                    projectName: capexTree.name,
                    projectDescription: capexTree.description,
                    pattern: currentPattern,
                    metadata: capexTree.metadata || {}
                };

                // Find parent phases for context
                const nodesWithContext = nodes.map(node => {
                    let parentPhase = null;
                    if (capexTree.children) {
                        for (const phase of capexTree.children) {
                            if (phase.items && phase.items.find(item => item.id === node.id)) {
                                parentPhase = { name: phase.name, subtitle: phase.subtitle };
                                break;
                            }
                        }
                    }
                    return { ...node, parentPhase };
                });

                // Build the Structured Scholar prompt
                const prompt = buildDeepDivePrompt(nodesWithContext, treeContext, isPhilosophy);

                // Call AI
                const response = await callDeepDiveAI(prompt, isPhilosophy);

                // Parse and merge the enriched data (new format returns { nodes, relationshipAnalysis })
                const parseResult = parseDeepDiveResponse(response, nodes);
                const enrichedNodes = parseResult.nodes || parseResult; // Handle both new and legacy format
                const aiRelationshipAnalysis = parseResult.relationshipAnalysis || null;

                if (enrichedNodes && enrichedNodes.length > 0) {
                    // Save state for undo
                    saveState('Deep Dive Analysis');

                    // Merge enriched data into actual nodes
                    let totalSubItemsAdded = 0;
                    enrichedNodes.forEach(enriched => {
                        const originalNode = nodes.find(n => n.id === enriched.id);
                        if (originalNode) {
                            // Merge fields (don't overwrite existing non-empty values)
                            if (enriched.speaker && !originalNode.speaker) originalNode.speaker = enriched.speaker;
                            if (enriched.keyTerms && !originalNode.keyTerms) originalNode.keyTerms = enriched.keyTerms;
                            if (enriched.textualReference && !originalNode.textualReference) originalNode.textualReference = enriched.textualReference;
                            if (enriched.argumentType && !originalNode.argumentType) originalNode.argumentType = enriched.argumentType;

                            // Merge subItems (add new ones, don't duplicate)
                            if (enriched.subItems && enriched.subItems.length > 0) {
                                if (!originalNode.subItems) originalNode.subItems = [];
                                enriched.subItems.forEach(newSubItem => {
                                    // Check if similar subItem already exists
                                    const exists = originalNode.subItems.some(
                                        existing => existing.name.toLowerCase() === newSubItem.name.toLowerCase()
                                    );
                                    if (!exists) {
                                        // Add ID and type if missing
                                        newSubItem.id = newSubItem.id || `subitem-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
                                        newSubItem.type = newSubItem.type || 'subtask';
                                        originalNode.subItems.push(newSubItem);
                                        totalSubItemsAdded++;
                                    }
                                });
                            }
                        }
                    });

                    // Create hyperedge if multiple nodes were analyzed
                    // Include BOTH original nodes AND their newly generated subitems (Venn diagram effect)
                    let hyperedgeCreated = false;
                    if (nodes.length >= 2) {
                        // Collect all node IDs including subitems
                        const allNodeIds = [];
                        nodes.forEach(n => {
                            allNodeIds.push(n.id);
                            // Include subitems in the hyperedge
                            if (n.subItems) {
                                n.subItems.forEach(sub => allNodeIds.push(sub.id));
                            }
                        });
                        const nodeIds = allNodeIds;
                        console.log('ðŸ”— Creating Deep Dive hyperedge with nodeIds:', nodeIds);

                        // Build analysis metadata - USE AI's relationship analysis if available
                        const analysisMetadata = {
                            analyzedNodes: nodes.map(n => ({ id: n.id, name: n.name, itemType: n.itemType })),
                            totalSubItemsGenerated: totalSubItemsAdded,
                            analysisMethod: 'Structured Scholar',
                            pattern: currentPattern
                        };

                        // Use AI-generated relationship analysis if available, else fallback to inference
                        if (aiRelationshipAnalysis) {
                            // AI provided scholarly analysis of the relationship
                            analysisMetadata.philosophyFields = {
                                dialecticalRelation: aiRelationshipAnalysis.dialecticalRelation || '',
                                argumentativeFlow: aiRelationshipAnalysis.argumentativeFlow || '',
                                conceptualBridge: aiRelationshipAnalysis.conceptualBridge || '',
                                tension: aiRelationshipAnalysis.tension || '',
                                synthesis: aiRelationshipAnalysis.synthesis || '',
                                relationshipType: aiRelationshipAnalysis.relationshipType || '',
                                speakers: [...new Set(nodes.map(n => n.speaker).filter(Boolean))],
                                itemTypes: [...new Set(nodes.map(n => n.itemType).filter(Boolean))],
                                tradition: capexTree.metadata?.tradition || 'Unknown',
                                aiGenerated: true  // Flag that this came from AI analysis
                            };
                            console.log('ðŸ§  Using AI-generated relationship analysis:', aiRelationshipAnalysis);
                        } else if (isPhilosophy) {
                            // Fallback to rule-based inference
                            const itemTypes = nodes.map(n => n.itemType).filter(Boolean);
                            const speakers = nodes.map(n => n.speaker).filter(Boolean);

                            analysisMetadata.philosophyFields = {
                                dialecticalRelation: inferDialecticalRelation(nodes),
                                argumentativeFlow: inferArgumentativeFlow(nodes),
                                conceptualBridge: inferConceptualBridge(nodes),
                                speakers: [...new Set(speakers)],
                                itemTypes: [...new Set(itemTypes)],
                                tradition: capexTree.metadata?.tradition || 'Unknown',
                                aiGenerated: false
                            };
                        }

                        // Generate label from AI's relationshipType or fallback
                        let hyperedgeLabel = 'ðŸŽ“ Deep Dive Analysis';
                        if (aiRelationshipAnalysis?.relationshipType) {
                            // Use AI's concise relationship type as the label
                            hyperedgeLabel = `ðŸ›ï¸ ${aiRelationshipAnalysis.relationshipType}`;
                        } else if (isPhilosophy && analysisMetadata.philosophyFields) {
                            // Fallback to inferred dialectical relation
                            const dialectical = analysisMetadata.philosophyFields.dialecticalRelation || '';
                            const labelType = dialectical.split(':')[0].trim();
                            if (labelType && labelType !== 'Conceptual Network') {
                                hyperedgeLabel = `ðŸ›ï¸ ${labelType}`;
                            }
                        }

                        // Generate unique color based on number of existing analysis hyperedges
                        if (!capexTree.hyperedges) capexTree.hyperedges = [];
                        const existingAnalysisCount = capexTree.hyperedges.filter(h => h.type === 'analysis').length;
                        const uniqueColor = generateHyperedgeColor(existingAnalysisCount);

                        // Store the color in metadata
                        analysisMetadata.color = uniqueColor;

                        const hyperedge = {
                            id: `hyperedge-deepdive-${Date.now()}`,
                            nodeIds: nodeIds,
                            label: hyperedgeLabel,
                            description: aiRelationshipAnalysis?.dialecticalRelation || `Structured Scholar analysis linking: ${nodes.map(n => n.name).join(', ')}`,
                            createdAt: new Date().toISOString(),
                            type: 'analysis',
                            metadata: analysisMetadata
                        };

                        capexTree.hyperedges.push(hyperedge);
                        hyperedgeCreated = true;

                        console.log('ðŸ”— Hyperedge created:', hyperedge);
                        console.log('ðŸ”— Total hyperedges now:', capexTree.hyperedges.length);
                    }

                    // Re-render
                    render();
                    // Check if canvas view is active by looking at container class
                    const canvasContainer = document.getElementById('canvas-container');
                    const isCanvasActive = canvasContainer && canvasContainer.classList.contains('active');

                    // If hyperedge was created, auto-focus on it for clean visualization
                    if (hyperedgeCreated && isCanvasActive) {
                        // Short delay to ensure modal is shown first
                        setTimeout(() => {
                            focusOnHyperedge(hyperedge.id);
                        }, 100);
                    } else if (isCanvasActive) {
                        renderCanvas();
                        drawHyperedges();
                    }

                    // Show success with summary
                    modalBody.innerHTML = `
                        <div style="padding: 30px;">
                            <div style="text-align: center; margin-bottom: 24px;">
                                <div style="font-size: 48px; margin-bottom: 16px;">ðŸŽ“</div>
                                <h3 style="color: var(--treeplex-primary); margin-bottom: 8px;">Deep Dive Complete!</h3>
                                <p style="color: var(--text-secondary);">
                                    Analyzed ${nodes.length} node${nodes.length > 1 ? 's' : ''} using Structured Scholar
                                </p>
                            </div>

                            <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                                <h4 style="color: #10B981; margin-bottom: 12px;">ðŸ“Š Analysis Summary</h4>
                                <ul style="margin: 0; padding-left: 20px; color: var(--text-primary); line-height: 1.8;">
                                    <li><strong>${totalSubItemsAdded}</strong> new sub-items added (objections, implications, etc.)</li>
                                    <li><strong>${enrichedNodes.filter(n => n.speaker).length}</strong> speaker attributions</li>
                                    <li><strong>${enrichedNodes.filter(n => n.keyTerms).length}</strong> key term annotations</li>
                                    ${hyperedgeCreated ? `<li>ðŸ”— <strong>Hyperedge created</strong> linking analyzed nodes</li>` : ''}
                                </ul>
                            </div>

                            <div style="background: rgba(99, 102, 241, 0.1); border-radius: 8px; padding: 16px;">
                                <h4 style="color: var(--treeplex-primary); margin-bottom: 8px;">ðŸ’¡ What's New</h4>
                                <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                                    Expand the analyzed nodes to see new sub-items including objections, counter-arguments,
                                    hidden premises, and philosophical implications. ${hyperedgeCreated ? 'The purple hyperedge in Canvas View shows the conceptual relationship between these nodes.' : ''}
                                </p>
                            </div>

                            <div style="margin-top: 20px; text-align: center;">
                                <button onclick="document.getElementById('modal').style.display='none'"
                                    style="padding: 12px 24px; background: var(--treeplex-primary); color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
                                    Got it!
                                </button>
                            </div>
                        </div>
                    `;

                } else {
                    throw new Error('AI returned no enrichment data. Try again or select different nodes.');
                }

            } catch (error) {
                console.error('Deep Dive Analysis failed:', error);
                modalBody.innerHTML = `
                    <div style="padding: 30px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                        <h3 style="margin-bottom: 16px; color: var(--text-primary);">Deep Dive Analysis Failed</h3>
                        <p style="margin-bottom: 24px; color: var(--text-secondary); line-height: 1.6;">
                            ${error.message}
                        </p>
                        <button onclick="document.getElementById('modal').style.display='none'"
                            style="padding: 10px 20px; background: var(--treeplex-primary); color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Close
                        </button>
                    </div>
                `;
            }
        }

        // Build the Structured Scholar deep dive prompt
        function buildDeepDivePrompt(nodesWithContext, treeContext, isPhilosophy) {
            const nodesJson = JSON.stringify(nodesWithContext, null, 2);
            const multipleNodes = nodesWithContext.length >= 2;

            if (isPhilosophy) {
                return {
                    system: `You are a philosophy professor using the "Structured Scholar" technique for deep textual analysis.
Your expertise includes: identifying hidden premises, reconstructing arguments, citing secondary sources, anticipating objections, and ANALYZING RELATIONSHIPS between philosophical claims.

You will receive JSON data for philosophical nodes to analyze. Your tasks:
1. For EACH node: Fill in missing fields and generate 2-4 subItems
2. ${multipleNodes ? 'CRITICAL: Analyze the RELATIONSHIP between these nodes - what is their dialectical connection?' : ''}

SubItem types to generate:
- "implicit-premise" (ðŸ”®): Hidden assumptions the argument relies on
- "objection" (âš”ï¸): Named philosophical objections with specific critics (e.g., "Carnap", "Ryle")
- "refutation" (ðŸ”„): Responses to objections
- "implication" (ðŸ’¡): Philosophical consequences or downstream effects
- "distinction" (âš–ï¸): Important conceptual distinctions

CRITICAL: Return ONLY valid JSON. No markdown, no explanations.`,

                    user: `Analyze these philosophical nodes and enrich them with deeper analysis.

PROJECT CONTEXT:
- Name: ${treeContext.projectName}
- Pattern: ${treeContext.pattern}
${treeContext.metadata?.tradition ? `- Tradition: ${treeContext.metadata.tradition}` : ''}
${treeContext.metadata?.method ? `- Method: ${treeContext.metadata.method}` : ''}
${treeContext.metadata?.secondarySources ? `- Secondary Sources Available: ${treeContext.metadata.secondarySources.slice(0, 3).join(', ')}` : ''}

NODES TO ANALYZE:
${nodesJson}

Return a JSON object with this structure:
{
  "enrichedNodes": [
    {
      "id": "original-node-id",
      "speaker": "Philosopher name",
      "keyTerms": ["term1", "term2"],
      "textualReference": "Specific citation",
      "argumentType": "deductive|inductive|transcendental|dialectical",
      "subItems": [
        {
          "id": "sub-unique-id",
          "name": "Objection/Implication name",
          "type": "subtask",
          "itemType": "objection|implicit-premise|implication|distinction",
          "speaker": "Critic name if applicable",
          "description": "Detailed description with citations...",
          "icon": "âš”ï¸|ðŸ”®|ðŸ’¡|âš–ï¸"
        }
      ]
    }
  ]${multipleNodes ? `,
  "relationshipAnalysis": {
    "relationshipType": "Short label (3-5 words) e.g., 'Thesis-Antithesis Dialectic', 'Premises Supporting Conclusion', 'Conceptual Dependency Chain'",
    "dialecticalRelation": "One sentence describing how these claims relate dialectically",
    "argumentativeFlow": "How arguments flow between these nodes (e.g., 'Node A provides grounds for Node B')",
    "conceptualBridge": "The key concept or term that connects these nodes",
    "tension": "Any philosophical tension or contradiction between the nodes",
    "synthesis": "If applicable, what synthesis emerges from considering these nodes together"
  }` : ''}
}

${multipleNodes ? `IMPORTANT: The relationshipAnalysis must reflect YOUR scholarly analysis of how these specific philosophical claims relate to each other based on their CONTENT, not just their types. Consider:
- Are they premises building toward a conclusion?
- Is one an objection to another?
- Do they represent different aspects of the same problem?
- Is there a dialectical progression (thesis â†’ antithesis â†’ synthesis)?
- Do they share conceptual dependencies?` : ''}

Return ONLY the JSON object, no other text.`
                };
            } else {
                // Generic pattern - still useful for non-philosophy
                return {
                    system: `You are an expert analyst performing deep-dive analysis on project items.
Your job is to identify risks, dependencies, hidden assumptions, and generate actionable sub-tasks.

Return ONLY valid JSON. No markdown, no explanations.`,

                    user: `Analyze these project items and enrich them with deeper analysis.

PROJECT: ${treeContext.projectName}
PATTERN: ${treeContext.pattern}

ITEMS TO ANALYZE:
${nodesJson}

Return a JSON array with the SAME item IDs, enriched with:
1. Any missing fields you can infer
2. subItems: Array of 2-4 actionable sub-tasks or considerations

Each subItem needs: id (generate unique), name, type: "subtask", itemType, description, icon

Return ONLY the JSON array.`
                };
            }
        }

        // Call AI for deep dive analysis
        async function callDeepDiveAI(prompt, isPhilosophy) {
            // Use the existing unified AI infrastructure (callClaudeAPI handles all providers)
            const aiProvider = document.getElementById('ai-provider')?.value || 'gemini';
            const modelSelect = document.getElementById('ai-model-select');
            const selectedModel = modelSelect?.value || '';

            console.log(`Deep Dive using ${aiProvider} (${selectedModel})`);

            // callClaudeAPI is the unified wrapper that routes to Gemini/OpenAI/Claude
            // based on the selected provider in the UI
            const maxTokens = 4096; // Allow room for detailed subItems
            const useExtendedThinking = false; // Fast mode for now

            return await callClaudeAPI(prompt.user, prompt.system, maxTokens, useExtendedThinking);
        }

        // Parse AI response and extract enriched nodes + relationship analysis
        function parseDeepDiveResponse(response, originalNodes) {
            try {
                // Try to extract JSON from response
                let jsonStr = response;

                // Remove markdown code blocks if present
                if (jsonStr.includes('```json')) {
                    jsonStr = jsonStr.replace(/```json\s*/g, '').replace(/```\s*/g, '');
                } else if (jsonStr.includes('```')) {
                    jsonStr = jsonStr.replace(/```\s*/g, '');
                }

                // Trim whitespace
                jsonStr = jsonStr.trim();

                // Parse JSON
                const parsedData = JSON.parse(jsonStr);

                // Handle new structure with enrichedNodes + relationshipAnalysis
                let enrichedData;
                let relationshipAnalysis = null;

                if (parsedData.enrichedNodes) {
                    // New format: { enrichedNodes: [...], relationshipAnalysis: {...} }
                    enrichedData = parsedData.enrichedNodes;
                    relationshipAnalysis = parsedData.relationshipAnalysis || null;
                    console.log('ðŸ”— AI Relationship Analysis:', relationshipAnalysis);
                } else if (Array.isArray(parsedData)) {
                    // Legacy format: just an array
                    enrichedData = parsedData;
                } else {
                    // Single object, wrap it
                    console.warn('Deep Dive response is not expected format, wrapping...');
                    enrichedData = [parsedData];
                }

                // Map enriched data back to original node IDs
                const mappedNodes = enrichedData.map(enriched => {
                    // Try to match by ID or name
                    const matchingOriginal = originalNodes.find(
                        orig => orig.id === enriched.id || orig.name === enriched.name
                    );

                    if (matchingOriginal) {
                        return {
                            id: matchingOriginal.id,
                            speaker: enriched.speaker,
                            keyTerms: enriched.keyTerms,
                            textualReference: enriched.textualReference,
                            argumentType: enriched.argumentType,
                            subItems: enriched.subItems || []
                        };
                    }
                    return enriched;
                });

                // Return both enriched nodes and relationship analysis
                return {
                    nodes: mappedNodes,
                    relationshipAnalysis: relationshipAnalysis
                };

            } catch (parseError) {
                console.error('Failed to parse Deep Dive response:', parseError);
                console.log('Raw response:', response);
                throw new Error('AI response was not valid JSON. Please try again.');
            }
        }

        // Edit modal save/cancel handlers
        document.getElementById('edit-save').addEventListener('click', () => {
            if (activeNode) {
                // Save state for undo
                saveState(`Edit ${activeNode.type}: ${activeNode.name}`);

                // Save universal fields
                activeNode.name = document.getElementById('edit-name').value;
                activeNode.description = document.getElementById('edit-description').value;
                activeNode.icon = document.getElementById('edit-icon').value;
                activeNode.itemType = document.getElementById('edit-type').value;
                activeNode.notes = document.getElementById('edit-notes').value;

                // Save pattern-specific fields dynamically
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    const fieldElement = document.getElementById(`edit-${fieldKey}`);
                    if (fieldElement) {
                        const fieldConfig = fields[fieldKey];
                        if (fieldConfig.type === 'number') {
                            activeNode[fieldKey] = parseInt(fieldElement.value) || 0;
                        } else {
                            activeNode[fieldKey] = fieldElement.value;
                        }
                    }
                });

                // Collect selected dependencies from checkboxes (conditional)
                if (fields.includeDependencies) {
                    const depCheckboxes = document.querySelectorAll('.dep-checkbox');
                    const selectedDeps = [];
                    depCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedDeps.push(checkbox.value);
                        }
                    });
                    activeNode.dependencies = selectedDeps;
                }

                // Save PM fields for subtasks
                if (activeNode.type === 'subtask') {
                    const pmStatus = document.getElementById('edit-pm-status');
                    const pmRAGStatus = document.getElementById('edit-pm-rag-status');
                    const pmOwnerEmail = document.getElementById('edit-pm-owner-email');
                    const pmStartDate = document.getElementById('edit-pm-start-date');
                    const pmDueDate = document.getElementById('edit-pm-due-date');
                    const pmProgress = document.getElementById('edit-pm-progress');
                    const pmPriority = document.getElementById('edit-pm-priority');
                    const pmEstimatedHours = document.getElementById('edit-pm-estimated-hours');
                    const pmActualHours = document.getElementById('edit-pm-actual-hours');
                    const pmRemainingHours = document.getElementById('edit-pm-remaining-hours');
                    const pmNotes = document.getElementById('edit-pm-notes');
                    const pmBlockingIssue = document.getElementById('edit-pm-blocking-issue');
                    const pmNextSteps = document.getElementById('edit-pm-next-steps');

                    if (pmStatus) activeNode.pmStatus = pmStatus.value;
                    if (pmRAGStatus) activeNode.pmRAGStatus = pmRAGStatus.value;
                    if (pmOwnerEmail) {
                        activeNode.pmOwnerEmail = pmOwnerEmail.value;
                        // Backward compatibility: also save as pmAssignee
                        activeNode.pmAssignee = pmOwnerEmail.value;
                    }
                    if (pmStartDate) activeNode.pmStartDate = pmStartDate.value;
                    if (pmDueDate) activeNode.pmDueDate = pmDueDate.value;
                    if (pmProgress) activeNode.pmProgress = parseInt(pmProgress.value) || 0;
                    if (pmPriority) activeNode.pmPriority = pmPriority.value;
                    if (pmEstimatedHours) activeNode.pmEstimatedHours = parseFloat(pmEstimatedHours.value) || 0;
                    if (pmActualHours) activeNode.pmActualHours = parseFloat(pmActualHours.value) || 0;
                    if (pmRemainingHours) {
                        // If remaining is explicitly set, use it; otherwise auto-calculate
                        const remValue = parseFloat(pmRemainingHours.value);
                        if (remValue > 0) {
                            activeNode.pmRemainingHours = remValue;
                        } else {
                            // Auto-calculate: Estimated - Actual
                            const est = parseFloat(pmEstimatedHours?.value) || 0;
                            const act = parseFloat(pmActualHours?.value) || 0;
                            activeNode.pmRemainingHours = Math.max(0, est - act);
                        }
                    }
                    if (pmNotes) activeNode.pmNotes = pmNotes.value;
                    if (pmBlockingIssue) activeNode.pmBlockingIssue = pmBlockingIssue.value;
                    if (pmNextSteps) activeNode.pmNextSteps = pmNextSteps.value;
                    // pmUpdates are managed separately via window.addUpdate and window.deleteUpdate
                }

                document.getElementById('edit-modal').style.display = 'none';
                render();
            }
        });

        document.getElementById('edit-cancel').addEventListener('click', () => {
            document.getElementById('edit-modal').style.display = 'none';
        });

        // JSON upload handler
        document.getElementById('json-upload-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        // Migrate tree to current schema (Cognitive Citadel Foundation)
                        migrateTree(data);
                        
                        // Validate basic structure
                        if (data.id && data.children) {
                            // Replace the tree data
                            Object.assign(capexTree, data);

                            // Restore pattern if saved
                            if (capexTree.pattern) {
                                // Handle both string and object formats
                                if (typeof capexTree.pattern === 'string') {
                                    currentPattern = capexTree.pattern;
                                } else if (capexTree.pattern.key) {
                                    currentPattern = getPatternKey(capexTree.pattern);
                                    if (currentPattern === 'custom' && capexTree.pattern.labels) {
                                        customPatternNames = capexTree.pattern.labels;
                                    }
                                }

                                const patternSelect = document.getElementById('pattern-select');
                                if (patternSelect) {
                                    patternSelect.value = currentPattern;
                                }

                                console.log('Pattern loaded from file:', currentPattern);

                                // Update sort dropdown immediately after setting pattern
                                updateSortDropdown();

                                // Update cluster-by dropdown for loaded pattern
                                if (typeof updateClusterByOptions === 'function') {
                                    updateClusterByOptions();
                                }
                            } else {
                                // No pattern in file - use current pattern
                                console.log('No pattern in file, using current:', currentPattern);
                                updateSortDropdown();

                                // Update cluster-by dropdown for current pattern
                                if (typeof updateClusterByOptions === 'function') {
                                    updateClusterByOptions();
                                }
                            }

                            render();

                            // Apply default sort for filesystem pattern (folders first + alphabetical)
                            if (currentPattern === 'filesystem') {
                                sortTree(null); // This will trigger the default filesystem sort
                            }

                            alert('JSON loaded successfully!');
                        } else {
                            alert('Invalid JSON structure. Must have "id" and "children" properties.');
                        }
                    } catch (err) {
                        alert('Error parsing JSON: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
            // Reset input
            e.target.value = '';
        });

        // Controls - Expand/Collapse All
        const expandBtn = document.getElementById('expand-btn');
        const collapseBtn = document.getElementById('collapse-btn');

        if (expandBtn) {
            console.log('âœ… Expand button found, attaching event listener');
            expandBtn.addEventListener('click', () => {
                console.log('â¬‡ï¸ Expand button clicked!');
                console.log('Current tree state:', capexTree);

                function expandAll(node) {
                    // Set expanded on this node
                    node.expanded = true;

                    // Recursively expand all children (phases/folders in filesystem)
                    if (node.children) {
                        node.children.forEach(expandAll);
                    }

                    // Recursively expand all items (standard patterns)
                    if (node.items) {
                        node.items.forEach(expandAll);
                    }

                    // Recursively expand all subItems (nested tasks)
                    if (node.subItems) {
                        node.subItems.forEach(expandAll);
                    }
                }
                expandAll(capexTree);

                console.log('Tree after expand:', capexTree);
                render();
                console.log('Render complete');
            });
        } else {
            console.error('âŒ Expand button not found!');
        }

        if (collapseBtn) {
            console.log('âœ… Collapse button found, attaching event listener');
            collapseBtn.addEventListener('click', () => {
                console.log('â¬†ï¸ Collapse button clicked!');
                console.log('Current tree state:', capexTree);

                function collapseAll(node) {
                    // Set collapsed on this node
                    node.expanded = false;

                    // Recursively collapse all children (phases/folders in filesystem)
                    if (node.children) {
                        node.children.forEach(collapseAll);
                    }

                    // Recursively collapse all items (standard patterns)
                    if (node.items) {
                        node.items.forEach(collapseAll);
                    }

                    // Recursively collapse all subItems (nested tasks)
                    if (node.subItems) {
                        node.subItems.forEach(collapseAll);
                    }
                }

                // Start from the root's children
                if (capexTree.children) {
                    capexTree.children.forEach(collapseAll);
                }
                if (capexTree.items) {
                    capexTree.items.forEach(collapseAll);
                }

                console.log('Tree after collapse:', capexTree);
                render();
                console.log('Render complete');
            });
        } else {
            console.error('âŒ Collapse button not found!');
        }

        // Search functionality
        document.getElementById('search-btn').addEventListener('click', () => {
            const modal = document.getElementById('search-modal');
            modal.style.display = 'flex';
            document.getElementById('search-input').focus();
        });

        document.getElementById('close-search-modal').addEventListener('click', () => {
            document.getElementById('search-modal').style.display = 'none';
        });

        // Recursive search function
        function searchNodes(query, node, path = [], results = []) {
            const queryLower = query.toLowerCase();

            // Helper to check if a value contains the query
            function matchesQuery(value) {
                if (value === null || value === undefined) return false;
                return String(value).toLowerCase().includes(queryLower);
            }

            // Search all fields in this node
            const matches = [];
            Object.keys(node).forEach(key => {
                // Skip non-searchable fields
                if (['children', 'items', 'subItems', 'dependencies', 'expanded', 'type', 'canvasX', 'canvasY'].includes(key)) {
                    return;
                }

                if (matchesQuery(node[key])) {
                    matches.push({ field: key, value: node[key] });
                }
            });

            // If this node has matches, add it to results
            if (matches.length > 0) {
                results.push({
                    node: node,
                    path: path,
                    matches: matches
                });
            }

            // Recursively search children (support both standard and filesystem patterns)
            const childList = node.children || node.items || node.subItems || [];
            childList.forEach((child, idx) => {
                searchNodes(query, child, [...path, { name: node.name || node.id, index: idx }], results);
            });

            return results;
        }

        // Perform search and display results
        function performSearch() {
            const query = document.getElementById('search-input').value.trim();
            const resultsContainer = document.getElementById('search-results');
            const emptyState = document.getElementById('search-results-empty');

            if (!query) {
                resultsContainer.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }

            const results = [];

            // Search through all phases
            if (capexTree.children) {
                capexTree.children.forEach((phase, phaseIdx) => {
                    // Search the phase itself
                    searchNodes(query, phase, [{ name: capexTree.name, index: phaseIdx }], results);
                });
            }

            // Display results
            if (results.length === 0) {
                resultsContainer.style.display = 'none';
                emptyState.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 12px;">ðŸ¤·</div>
                    <div style="font-size: 14px;">No results found for "${query}"</div>
                `;
                emptyState.style.display = 'block';
            } else {
                emptyState.style.display = 'none';
                resultsContainer.style.display = 'block';

                resultsContainer.innerHTML = `
                    <div style="margin-bottom: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px;">
                        <strong style="color: var(--treeplex-primary);">${results.length}</strong> result${results.length !== 1 ? 's' : ''} found
                    </div>
                    ${results.map((result, idx) => {
                        const pathStr = result.path.map(p => p.name).join(' â†’ ') + ' â†’ ' + result.node.name;
                        const matchesHtml = result.matches.map(m => {
                            const value = String(m.value).substring(0, 200);
                            return `<div style="margin: 4px 0;"><strong>${m.field}:</strong> ${highlightMatch(value, query)}</div>`;
                        }).join('');

                        return `
                            <div class="search-result-item" data-node-id="${result.node.id}" style="padding: 12px 16px; margin-bottom: 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px; display: flex; align-items: center; gap: 8px;">
                                    ${result.node.icon || 'ðŸ“„'} ${result.node.name}
                                </div>
                                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                                    ${pathStr}
                                </div>
                                <div style="font-size: 13px; color: var(--text-primary); padding: 8px; background: var(--bg-secondary); border-radius: 4px;">
                                    ${matchesHtml}
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;

                // Add click handlers to results
                resultsContainer.querySelectorAll('.search-result-item').forEach((el, idx) => {
                    el.addEventListener('click', () => {
                        const nodeId = el.dataset.nodeId;
                        // Close search modal
                        document.getElementById('search-modal').style.display = 'none';
                        // Highlight and scroll to the node
                        highlightNode(nodeId);
                    });

                    // Hover effect
                    el.addEventListener('mouseenter', () => {
                        el.style.borderColor = 'var(--treeplex-primary)';
                        el.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                    el.addEventListener('mouseleave', () => {
                        el.style.borderColor = 'var(--border)';
                        el.style.background = 'var(--card-bg)';
                    });
                });
            }
        }

        // Highlight matched text
        function highlightMatch(text, query) {
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<mark style="background: rgba(255, 187, 0, 0.3); padding: 2px 4px; border-radius: 3px; font-weight: 600;">$1</mark>');
        }

        // Highlight node in tree view
        function highlightNode(nodeId) {
            // Find and expand ancestors to make node visible
            function findAndExpandNode(node, targetId, ancestors = []) {
                if (node.id === targetId) {
                    // Expand all ancestors
                    ancestors.forEach(ancestor => {
                        ancestor.expanded = true;
                    });
                    render();

                    // Scroll to node after render
                    setTimeout(() => {
                        const nodeEl = document.querySelector(`[data-item-id="${nodeId}"]`);
                        if (nodeEl) {
                            nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            // Flash highlight
                            nodeEl.style.background = 'rgba(99, 102, 241, 0.2)';
                            nodeEl.style.transition = 'background 0.3s';
                            setTimeout(() => {
                                nodeEl.style.background = '';
                            }, 1500);
                        }
                    }, 100);
                    return true;
                }

                // Recursively search children
                const childList = node.children || node.items || node.subItems || [];
                for (const child of childList) {
                    if (findAndExpandNode(child, targetId, [...ancestors, node])) {
                        return true;
                    }
                }
                return false;
            }

            // Search through all phases
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    if (findAndExpandNode(phase, nodeId, [capexTree])) {
                        break;
                    }
                }
            }
        }

        // Search on input
        const searchInput = document.getElementById('search-input');
        searchInput.addEventListener('input', debounce(performSearch, 300));
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });

        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Save and Load JSON buttons in console
        // New Project button - Start fresh
        document.getElementById('new-project-btn').addEventListener('click', () => {
            const confirmNew = confirm(
                'ðŸ†• Start New Project?\n\n' +
                'This will clear your current project.\n\n' +
                'Make sure to save first if you want to keep your work!'
            );

            if (confirmNew) {
                saveState('New Project');

                // Use current pattern from dropdown (pattern-aware)
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;
                const fields = pattern.fields || {};

                // Build starter item with only pattern-specific fields
                const starterItem = {
                    id: 'item-' + Date.now(),
                    name: `New ${levels.item}`,
                    description: 'Enter description',
                    icon: 'ðŸ“¦',
                    itemType: '',
                    type: 'item',
                    dependencies: [],
                    subItems: [],
                    expanded: true
                };

                // Add pattern-specific fields
                Object.keys(fields).forEach(fieldKey => {
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return; // Skip meta fields
                    }

                    const fieldConfig = fields[fieldKey];

                    // Set default values based on field type
                    if (fieldConfig.type === 'number') {
                        starterItem[fieldKey] = 0;
                    } else if (fieldConfig.type === 'date') {
                        starterItem[fieldKey] = '';
                    } else if (fieldConfig.type === 'select') {
                        starterItem[fieldKey] = '';
                    } else if (fieldConfig.type === 'textarea') {
                        starterItem[fieldKey] = '';
                    } else {
                        starterItem[fieldKey] = '';
                    }
                });

                // Reset to fresh tree with pattern-specific structure
                capexTree = {
                    id: 'root',
                    name: `My ${levels.root}`,
                    type: 'root',
                    icon: pattern.icon,
                    expanded: true,
                    children: [
                        {
                            id: 'phase-0',
                            name: `${levels.phase} 0`,
                            subtitle: pattern.phaseSubtitles ? pattern.phaseSubtitles[0] : '',
                            type: 'phase',
                            phase: 0,
                            icon: '1ï¸âƒ£',
                            expanded: true,
                            items: [starterItem],
                            children: []
                        }
                    ],
                    pattern: {
                        key: currentPattern,
                        labels: levels
                    }
                };

                render();
                renderCanvas();  // Also update canvas view if visible
                showToast(`âœ… New ${pattern.name} project started!`);
                console.log(`ðŸ†• New ${pattern.name} project created`);
            }
        });

        document.getElementById('save-json-btn').addEventListener('click', handleDownload);
        document.getElementById('load-json-btn').addEventListener('click', handleUpload);

        // Share button - Generate shareable URL
        document.getElementById('share-btn').addEventListener('click', () => {
            const shareableURL = generateShareableURL();

            // Show modal with URL
            const modal = document.getElementById('share-modal');
            const urlInput = document.getElementById('share-url-input');
            urlInput.value = shareableURL;

            // Update stats
            const nodeCount = countAllNodes(capexTree);
            document.getElementById('share-node-count').textContent = nodeCount;
            document.getElementById('share-url-length').textContent = shareableURL.length;

            // Show warning if URL is very long (>2000 chars might have issues in some apps)
            const warning = document.getElementById('share-size-warning');
            if (shareableURL.length > 2000) {
                warning.style.display = 'block';
            } else {
                warning.style.display = 'none';
            }

            modal.style.display = 'flex';

            // Select the URL text for easy copying
            setTimeout(() => urlInput.select(), 100);
        });

        // Share modal - Copy button
        document.getElementById('copy-share-url').addEventListener('click', () => {
            const urlInput = document.getElementById('share-url-input');
            urlInput.select();
            document.execCommand('copy');

            // Change button text temporarily
            const btn = document.getElementById('copy-share-url');
            const originalText = btn.textContent;
            btn.textContent = 'âœ… Copied!';
            btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';

            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
            }, 2000);
        });

        // Share modal - Open in new tab button
        document.getElementById('open-share-url').addEventListener('click', () => {
            const url = document.getElementById('share-url-input').value;
            window.open(url, '_blank');
        });

        // Share modal - Close button
        document.getElementById('share-close').addEventListener('click', () => {
            document.getElementById('share-modal').style.display = 'none';
        });

        // Generate shareable URL with compressed data
        function generateShareableURL() {
            // DEBUG: Check cost values before serialization
            if (capexTree.children && capexTree.children[0] && capexTree.children[0].items && capexTree.children[0].items[0]) {
                console.log('First item cost before stringify:', capexTree.children[0].items[0].cost);
            }

            const jsonData = JSON.stringify(capexTree);

            // DEBUG: Log first 500 chars of JSON
            console.log('JSON before compress (first 500 chars):', jsonData.substring(0, 500));

            const compressed = LZString.compressToEncodedURIComponent(jsonData);
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?p=${compressed}`;
        }

        // Count all nodes in tree (for stats)
        function countAllNodes(node) {
            let count = 1; // Count this node
            if (node.children) {
                node.children.forEach(child => {
                    if (child.items) {
                        count += child.items.length;
                        child.items.forEach(item => {
                            if (item.subtasks) {
                                count += item.subtasks.length;
                            }
                        });
                    } else {
                        count += countAllNodes(child);
                    }
                });
            }
            return count;
        }

        // =============================================================================
        // AI WIZARD SYSTEM
        // =============================================================================

        // Wizard state
        let wizardState = {
            active: false,
            conversation: [],
            questionsAsked: 0,
            fieldsCompleted: new Set(),
            totalFields: 0,
            awaitingResponse: false,
            workingTree: null,
            patternKey: null
        };

        // Check if tree has meaningful content
        function hasExistingContent() {
            // Check if any phase has items or children (filesystem pattern uses 'children')
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    // Support both 'items' (standard patterns) and 'children' (filesystem pattern)
                    const nodeList = phase.items || phase.children || [];
                    if (nodeList.length > 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Start wizard
        document.getElementById('wizard-btn').addEventListener('click', () => {
            // Check global AI mode
            const aiMode = getGlobalAIMode();
            if (aiMode === 'off') {
                alert('âŒ AI features are currently disabled.\n\nPlease enable AI mode in the header (ðŸ¤– AI Mode dropdown) to use the AI Wizard.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            // If tree has content, ask user if they want to enhance or start fresh
            if (hasExistingContent()) {
                showWizardModeChoice();
            } else {
                startWizard(false); // false = start fresh
            }
        });

        // Show modal to choose wizard mode
        function showWizardModeChoice() {
            const pattern = PATTERNS[currentPattern];
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸª„ AI Wizard Mode';

            // Count existing items
            const itemCount = capexTree.children?.reduce((sum, phase) =>
                sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 24px;">
                        Your tree already has <strong style="color: var(--treeplex-primary);">${itemCount} ${pattern.levels.item.toLowerCase()}(s)</strong>.
                        How would you like to proceed?
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="mode-enhance" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">âœ¨</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Enhance Existing
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Keep your current tree and use the wizard to add more detail, fill gaps, or expand sections.
                            </div>
                        </div>

                        <div id="mode-fresh" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">ðŸŒ±</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Start Fresh
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Clear the current tree and build a completely new structure from scratch.
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 16px; padding: 12px; background: rgba(163, 85, 247, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                        ðŸ’¡ <strong>Tip:</strong> Enhancement mode is great for iterative refinement. The wizard will see your existing structure and help you improve it.
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Add click handlers
            document.getElementById('mode-enhance').onclick = () => {
                modal.style.display = 'none';
                startWizard(true); // true = enhance mode
            };

            document.getElementById('mode-fresh').onclick = () => {
                modal.style.display = 'none';
                startWizard(false); // false = start fresh
            };
        }

        async function startWizard(enhanceMode = false) {
            // Reset wizard state
            wizardState = {
                active: true,
                conversation: [],
                questionsAsked: 0,
                fieldsCompleted: new Set(),
                totalFields: 0,
                awaitingResponse: false,
                workingTree: JSON.parse(JSON.stringify(capexTree)), // Deep copy
                patternKey: currentPattern,
                enhanceMode: enhanceMode,
                retryCount: 0 // Track recovery attempts
            };

            // Get pattern info
            const pattern = PATTERNS[currentPattern];
            const patternFields = pattern.fields || {};
            wizardState.totalFields = Object.keys(patternFields).length;

            // Update modal title
            const modeLabel = enhanceMode ? 'âœ¨ Enhancing' : 'ðŸª„ Building';
            document.getElementById('wizard-title').textContent = `${modeLabel} Your ${pattern.name}`;
            document.getElementById('wizard-fields-total').textContent = wizardState.totalFields;

            // Clear chat and preview
            document.getElementById('wizard-chat-history').innerHTML = '';
            updateWizardPreview();

            // Show modal
            document.getElementById('wizard-modal').style.display = 'flex';

            // Start conversation
            await wizardAsk();
        }

        // Add message to chat
        function addWizardMessage(role, content) {
            const chatHistory = document.getElementById('wizard-chat-history');
            const messageDiv = document.createElement('div');

            if (role === 'ai') {
                // Neutral Slate Grey for AI (modern ChatGPT/Claude aesthetic)
                messageDiv.style.cssText = `
                    background: #2A2F3C;
                    color: #E2E2E2;
                    padding: 16px 20px;
                    border-radius: 12px;
                    border-top-left-radius: 2px;
                    max-width: 85%;
                    align-self: flex-start;
                    line-height: 1.6;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    border: 1px solid #3A3F4D;
                    font-size: 14px;
                `;
                messageDiv.innerHTML = content.replace(/\n/g, '<br>');
            } else {
                // Vibrant Primary for User
                messageDiv.style.cssText = `
                    background: linear-gradient(135deg, #6366f1, #4f46e5);
                    color: white;
                    padding: 12px 18px;
                    border-radius: 12px;
                    border-bottom-right-radius: 2px;
                    max-width: 80%;
                    align-self: flex-end;
                    line-height: 1.5;
                    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
                    font-size: 14px;
                `;
                messageDiv.textContent = content;
            }

            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        // Ask AI for next question
        async function wizardAsk() {
            if (wizardState.awaitingResponse) return;
            wizardState.awaitingResponse = true;

            // Disable input while waiting
            document.getElementById('wizard-user-input').disabled = true;
            document.getElementById('wizard-send').disabled = true;

            try {
                const systemPrompt = buildWizardSystemPrompt();
                const conversationContext = wizardState.conversation.map(msg =>
                    `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`
                ).join('\n\n');

                const userPrompt = conversationContext ||
                    (wizardState.enhanceMode ?
                        "The user wants to enhance their existing tree. Acknowledge what they have and ask how you can help improve it." :
                        "Start the wizard conversation. Ask the user what they want to build.");

                console.log('ðŸª„ Wizard asking AI...');
                console.log('ðŸª„ System prompt length:', systemPrompt.length);
                console.log('ðŸª„ User prompt length:', userPrompt.length);

                // SMART MODEL SELECTION for large trees
                // Large trees (50+ items) should use fast models to avoid timeout/cutoff
                const itemCount = (wizardState.workingTree.children || []).reduce((acc, phase) =>
                    acc + (phase.items || []).length, 0);
                const isLargeTree = itemCount >= 50;

                // Check if user selected Deep Mode (user-sonnet, user-gemini, user-chatgpt)
                const aiModeInfo = parseUnifiedMode();
                let useDeepMode = aiModeInfo.mode === 'deep'; // Deep Mode = Extended Thinking

                // Check if we're in fallback mode (from previous cutoff error)
                const useFastFallback = wizardState.useFastFallback || false;

                if (isLargeTree && !useFastFallback) {
                    console.log(`ðŸª„ Large tree detected (${itemCount} items) - recommending fast model`);
                    // For large trees, warn but still try their selected mode first
                    if (useDeepMode) {
                        console.warn('âš ï¸ Deep Mode on large tree may timeout. Will auto-fallback to fast model if needed.');
                    }
                }

                if (useFastFallback) {
                    console.log('ðŸš€ Using fast fallback mode (previous response was cut off)');
                    useDeepMode = false; // Force fast mode
                }

                if (useDeepMode) {
                    console.log('ðŸ§  Wizard using Deep Mode (Extended Thinking enabled)');
                }

                const response = await callClaudeAPI(userPrompt, systemPrompt, 8000, useDeepMode); // Increased to 8000 for complex patterns (Film, Philosophy, etc.)

                console.log('ðŸª„ AI Raw Response:', response);

                // Guard against undefined response
                if (!response) {
                    throw new Error('AI returned empty response. The request may have timed out or failed silently.');
                }

                // Try to extract JSON if AI added text before/after
                let jsonStr = response.trim();

                // If response has markdown code blocks, extract JSON from them
                if (jsonStr.includes('```json')) {
                    const match = jsonStr.match(/```json\s*\n([\s\S]*?)\n```/);
                    if (match) {
                        jsonStr = match[1];
                        console.log('ðŸª„ Extracted from ```json block');
                    }
                } else if (jsonStr.includes('```')) {
                    const match = jsonStr.match(/```\s*\n([\s\S]*?)\n```/);
                    if (match) {
                        jsonStr = match[1];
                        console.log('ðŸª„ Extracted from ``` block');
                    }
                }

                // Find the FIRST complete JSON object using proper brace matching
                // This handles cases where AI adds text before/after the JSON
                const firstBrace = jsonStr.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response. AI may not be following instructions.');
                }

                if (firstBrace > 0) {
                    console.log('ðŸª„ Skipping text before JSON:', jsonStr.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonStr.length; i++) {
                    const char = jsonStr[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    console.error('ðŸª„ Incomplete JSON - Wizard response was cut off!');
                    console.error('ðŸª„ Full response length:', response.length);
                    console.error('ðŸª„ Response (first 500 chars):', response.substring(0, 500));
                    console.error('ðŸª„ Response (last 500 chars):', response.substring(Math.max(0, response.length - 500)));

                    // Check retry limit
                    wizardState.retryCount = (wizardState.retryCount || 0) + 1;
                    if (wizardState.retryCount > 3) {
                        throw new Error('Response was cut off multiple times. Try asking the wizard to add fewer items at once, or click "Finish & Apply" to save current progress.');
                    }

                    // SMART FALLBACK: After first cutoff, switch to fast mode
                    if (wizardState.retryCount === 1 && !wizardState.useFastFallback) {
                        console.log('ðŸš€ First cutoff - enabling fast fallback mode for subsequent requests');
                        wizardState.useFastFallback = true;
                        addWizardMessage('ai', "âš¡ Switching to fast mode for better reliability with your large project...");
                    }

                    // Try to recover by asking AI to simplify
                    console.log('ðŸª„ Attempting auto-recovery (attempt ' + wizardState.retryCount + '/3)...');

                    // Add a recovery message to conversation
                    wizardState.conversation.push({
                        role: 'system',
                        content: 'Your last response was cut off (too long). CRITICAL: Return ONLY a short message and treeUpdate: null. Do NOT include any tree data. Just ask a simple question.'
                    });

                    // Show user-friendly message
                    addWizardMessage('ai', "Oops! My response was too long. Let me try with a much shorter answer...");

                    // Retry with simplified prompt
                    document.getElementById('wizard-user-input').disabled = false;
                    document.getElementById('wizard-send').disabled = false;
                    wizardState.awaitingResponse = false;
                    setTimeout(() => wizardAsk(), 500);
                    return;
                }

                jsonStr = jsonStr.substring(firstBrace, endPos);

                if (endPos < response.length) {
                    console.log('ðŸª„ Skipping text after JSON:', response.substring(endPos, endPos + 50) + '...');
                }

                console.log('ðŸª„ Extracted JSON (first 200 chars):', jsonStr.substring(0, 200) + '...');
                console.log('ðŸª„ JSON length:', jsonStr.length);

                // Sanitize JSON: Fix control characters in string values
                // This handles cases where AI generates unescaped newlines/tabs in strings
                let parsed;
                try {
                    // First, try parsing as-is
                    parsed = JSON.parse(jsonStr);
                } catch (firstError) {
                    console.warn('ðŸª„ JSON parse failed, attempting sanitization...', firstError.message);

                    // Sanitize by escaping control characters within string values
                    // Strategy: Replace literal newlines/tabs/etc with escaped versions
                    // but only within quoted string values (not in JSON structure)

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonStr.length; i++) {
                        const char = jsonStr[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                // Other control characters - escape as unicode
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonStr = sanitized;
                    console.log('ðŸª„ Sanitized JSON:', jsonStr.substring(0, 200) + '...');

                    // Try parsing again after sanitization
                    parsed = JSON.parse(jsonStr);
                }

                // Validate required fields
                if (!parsed.message) {
                    throw new Error('AI response missing "message" field');
                }

                // Success! Reset retry count
                wizardState.retryCount = 0;

                // Add AI message to conversation history
                wizardState.conversation.push({role: 'assistant', content: parsed.message});
                addWizardMessage('ai', parsed.message);

                // Update tree if provided
                if (parsed.treeUpdate) {
                    console.log('ðŸª„ Applying tree update:', parsed.treeUpdate);
                    const aiSource = `ai-${aiModeInfo.model}`;  // e.g., 'ai-sonnet', 'ai-gemini', 'ai-chatgpt'
                    mergeTreeUpdate(parsed.treeUpdate, aiSource);
                    updateWizardPreview();
                }

                // Update progress
                if (parsed.fieldsUpdated && Array.isArray(parsed.fieldsUpdated)) {
                    parsed.fieldsUpdated.forEach(field => wizardState.fieldsCompleted.add(field));
                    document.getElementById('wizard-fields-complete').textContent = wizardState.fieldsCompleted.size;
                }

                // Update progress bar (from AI's progress field 0.0 to 1.0)
                if (parsed.progress !== undefined) {
                    const percentComplete = Math.round(parsed.progress * 100);
                    document.getElementById('wizard-progress-percent').textContent = `${percentComplete}%`;
                    document.getElementById('wizard-progress-bar').style.width = `${percentComplete}%`;
                }

                // Check if done
                if (parsed.done) {
                    document.getElementById('wizard-completion').style.display = 'block';
                    document.getElementById('wizard-progress-bar').style.width = '100%';
                    document.getElementById('wizard-progress-percent').textContent = '100%';
                }

            } catch (error) {
                console.error('ðŸª„ Wizard error details:', {
                    error: error.message,
                    stack: error.stack,
                    conversation: wizardState.conversation
                });

                // SMART FALLBACK: Detect timeout and auto-retry with fast mode
                const isTimeout = error.message?.includes('timeout') || error.message?.includes('10-second') || error.message?.includes('10s');

                if (isTimeout && !wizardState.useFastFallback) {
                    console.log('ðŸš€ Timeout detected - enabling fast fallback mode and retrying...');
                    wizardState.useFastFallback = true;
                    wizardState.retryCount = (wizardState.retryCount || 0) + 1;

                    if (wizardState.retryCount <= 2) {
                        addWizardMessage('ai', "âš¡ Request timed out. Switching to fast mode and trying again...");

                        // Retry with fast mode
                        document.getElementById('wizard-user-input').disabled = false;
                        document.getElementById('wizard-send').disabled = false;
                        wizardState.awaitingResponse = false;
                        setTimeout(() => wizardAsk(), 500);
                        return;
                    }
                }

                // Show error message in chat
                const errorMsg = error.message || 'Unknown error occurred';

                // Simplify timeout errors for users
                if (isTimeout) {
                    addWizardMessage('ai', `â±ï¸ Request timed out. Try:\n\n1. Switch to Gemini (Settings â†’ Provider) - no timeout limit\n2. Use Fast Mode (Haiku) - usually faster\n3. Ask me to make smaller changes at a time`);
                } else {
                    addWizardMessage('ai', `I'm having trouble: ${errorMsg}\n\nPlease check:\n1. Is your API key configured? (Settings â†’ API Key)\n2. Try refreshing the page\n3. Check browser console for details (F12)`);
                }
            }

            // Re-enable input
            document.getElementById('wizard-user-input').disabled = false;
            document.getElementById('wizard-send').disabled = false;
            document.getElementById('wizard-user-input').focus();
            wizardState.awaitingResponse = false;
        }

        // User sends message
        document.getElementById('wizard-send').addEventListener('click', async () => {
            const input = document.getElementById('wizard-user-input');
            const message = input.value.trim();

            if (!message || wizardState.awaitingResponse) return;

            // Add to conversation
            wizardState.conversation.push({role: 'user', content: message});
            addWizardMessage('user', message);
            wizardState.questionsAsked++;
            document.getElementById('wizard-question-count').textContent = wizardState.questionsAsked;

            // Clear input
            input.value = '';

            // Get AI response
            await wizardAsk();
        });

        // Build system prompt for wizard
        function buildWizardSystemPrompt() {
            const pattern = PATTERNS[wizardState.patternKey];
            const levels = pattern.levels;
            const fields = pattern.fields || {};

            // Build a summary of current tree (not full JSON to save tokens)
            const treeSummary = wizardState.workingTree.name || 'Empty';
            const phaseCount = (wizardState.workingTree.children || []).length;
            const itemCount = (wizardState.workingTree.children || []).reduce((acc, phase) =>
                acc + (phase.items || []).length, 0);

            // Build detailed existing structure summary for enhance mode
            let existingStructure = '';
            if (wizardState.enhanceMode && itemCount > 0) {
                existingStructure = '\n\nðŸŒ³ EXISTING TREE STRUCTURE (DO NOT DELETE - ADD TO THIS):\n\n';
                existingStructure += `**${wizardState.workingTree.name}**\n`;
                if (wizardState.workingTree.description) {
                    existingStructure += `Description: ${wizardState.workingTree.description}\n`;
                }
                existingStructure += '\n';

                (wizardState.workingTree.children || []).forEach((phase, idx) => {
                    existingStructure += `${levels.phase} ${idx + 1}: ${phase.name}`;
                    if (phase.subtitle) existingStructure += ` (${phase.subtitle})`;
                    existingStructure += `\n`;

                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach(item => {
                            existingStructure += `  - ${item.name}`;
                            if (item.description) {
                                existingStructure += `: ${item.description.substring(0, 60)}${item.description.length > 60 ? '...' : ''}`;
                            }
                            existingStructure += `\n`;

                            if (item.subtasks && item.subtasks.length > 0) {
                                existingStructure += `    (${item.subtasks.length} subtasks)\n`;
                            }
                        });
                    } else {
                        existingStructure += `  (no items yet)\n`;
                    }
                    existingStructure += '\n';
                });

                existingStructure += `Total: ${phaseCount} ${levels.phase.toLowerCase()}(s), ${itemCount} ${levels.item.toLowerCase()}(s)\n\n`;
                existingStructure += `ðŸŽ¯ YOUR MISSION: Help the user ENHANCE this existing tree by:\n`;
                existingStructure += `- Adding more detail to existing items\n`;
                existingStructure += `- Filling gaps or missing sections\n`;
                existingStructure += `- Expanding phases that seem incomplete\n`;
                existingStructure += `- Adding subtasks to items that need them\n\n`;
                existingStructure += `\nâš ï¸âš ï¸âš ï¸ CRITICAL - DO NOT ECHO THE ENTIRE TREE âš ï¸âš ï¸âš ï¸\n`;
                existingStructure += `The tree already has ${itemCount} items. Your treeUpdate MUST contain ONLY:\n`;
                existingStructure += `- NEW items you are ADDING (not existing ones)\n`;
                existingStructure += `- Items you are MODIFYING (with changes)\n`;
                existingStructure += `- DO NOT include unchanged items - they are preserved automatically\n`;
                existingStructure += `- If just asking a question with no changes, use treeUpdate: null\n`;
                existingStructure += `\nâŒ WRONG: Echoing all ${itemCount} items back (wastes tokens, causes cutoff)\n`;
                existingStructure += `âœ… RIGHT: Only new/changed items, or null if just asking\n`;
            }

            const modeInstruction = wizardState.enhanceMode ?
                `You are ENHANCING an existing ${pattern.name} project. The user already has a tree with ${itemCount} items. Help them improve, expand, or fill gaps.` :
                `You are BUILDING a complete ${pattern.name} project from scratch. Extract NECESSARY and SUFFICIENT data in MINIMUM questions.`;

            return `âš ï¸ CRITICAL OUTPUT FORMAT: You MUST return ONLY a valid JSON object. NO text before the opening {. NO text after the closing }. NO explanations. NO commentary. JUST JSON.

You are an EXPERT INFORMATION EXTRACTION WIZARD. ${modeInstruction}

CURRENT STATE:
- Pattern: ${pattern.name}
- Structure: ${levels.root} â†’ ${levels.phase} â†’ ${levels.item} â†’ ${levels.subtask}
- Fields: ${Object.keys(fields).join(', ') || 'none'}
- Completed Fields: ${Array.from(wizardState.fieldsCompleted).join(', ') || 'none'}
- Tree: ${treeSummary} (${phaseCount} phases, ${itemCount} items)${existingStructure}

ðŸŽ¯ CORE MISSION: Extract 100% of required information in â‰¤5 strategic questions

ðŸ“Š STRATEGIC QUESTIONING FRAMEWORK:

ðŸŽ¯ QUESTIONING ORDER (CRITICAL - Follow this sequence):

**TURN 1 - UNDERSTAND THE GOAL**
First question MUST clarify: "What is this ${pattern.name.toLowerCase()} trying to ACHIEVE? What's the exact goal?"
- Example: "What specific problem does this ${pattern.name.toLowerCase()} solve?"
- Example: "What output/result should this ${pattern.name.toLowerCase()} produce?"
${pattern.name === 'Prompt Engineering' ? `- âš ï¸ META-LEVEL CLARITY: User is DESIGNING a prompt (not using one). Guide them to describe what THE PROMPT will do, not what THEY want to know.
  â†’ Good: "A prompt that takes X and returns Y"
  â†’ Bad: "I want to know about X"` : ''}
- DO NOT ask about safety, edge cases, or technical details yet
- DO NOT build the tree until you understand the GOAL

**TURN 2 - BUILD MAIN STRUCTURE**
After understanding the goal, propose the main phases/structure:
- "Based on your goal of [X], I'm thinking you need phases: [A, B, C]. Does that cover the main workflow?"
- Build 60-70% of the tree based on the goal
- Ask ONE clarifying question about structure

**TURN 3 - FILL CRITICAL DETAILS**
Add items and subtasks to each phase:
- "I've added [N] items across [M] phases. The biggest gap I see is [X]. Should I add that?"
- Build to 85-90% complete
- Focus on what's MISSING, not refinements

**TURN 4 - VALIDATE & REFINE**
Present near-complete tree and ask about completeness:
- "Does this capture the full workflow for [goal]? Or am I missing critical steps?"
- Now is when you can ask about edge cases, dependencies, special scenarios
- Build to 95%+ complete

**TURN 5 - CLOSE**
Final validation:
- "This looks complete for [goal]. Should I mark it done, or do you want to add/change anything?"
- Set done=true if approved

ðŸš« PRIORITY ORDER (What to ask when):

1. **THE GOAL** (Turn 1) - "What is this prompt trying to achieve exactly?"
2. **MAIN STRUCTURE** (Turn 2) - "What are the main phases/stages to achieve [goal]?"
3. **KEY ITEMS** (Turn 3) - "What are the critical items in each phase?"
4. **COMPLETENESS** (Turn 4) - "Am I missing any critical steps?"
5. **EDGE CASES/REFINEMENTS** (Turn 4) - "Any special scenarios or dependencies?"
6. **VALIDATION** (Turn 5) - "Does this fully capture everything?"

âŒ NEVER ask about these BEFORE understanding the goal:
- Safety considerations
- Model parameters (temperature, tokens)
- Edge cases
- Technical implementation details

âš¡ EFFICIENCY TARGETS (UPDATED):
- Turn 1: Ask about GOAL. Build NOTHING until you understand the purpose.
- Turn 2: Build 60-70% of tree based on goal + ask about structure
- Turn 3: Fill to 85-90% + ask about biggest gaps
- Turn 4: Fill to 95%+ + validate completeness
- Turn 5: Set done=true if approved

ðŸ” INFORMATION EXTRACTION TACTICS:
1. **EMBEDDED CONFIRMATION**: "I've added X, Y, Z as defaults. What am I missing?" (validates + extracts gaps)
2. **CONSTRAINT TESTING**: "I see this needs A. Does it also need B or is A sufficient?" (tests boundaries)
3. **DEPENDENCY PROBING**: "X blocks Y. Anything else blocked by X?" (maps critical paths)
4. **COMPLETENESS CHECK**: "I have N items for phase P. Too many/few/just right?" (validates scope)

ðŸ“‹ NECESSARY & SUFFICIENT DATA:
ALWAYS include in treeUpdate:
- Phases (3-6 typical)
- Items per phase (2-5 typical)
- âš ï¸ NESTED ITEMS${wizardState.patternKey === 'filesystem' ? ' (use "children" property for File System pattern)' : ' (use "subItems" property, NOT "subtasks")'}: Add 2-4 ${levels.subtask}s to items that need decomposition
  â†’ ${levels.subtask}s are PATTERN-SPECIFIC breakdowns:
    â€¢ ${pattern.name === 'Philosophy' ? 'Philosophy: premises, objections, evidence, citations' : ''}
    â€¢ ${pattern.name === 'Sales Pipeline' ? 'Sales: follow-up actions, next steps, deliverables' : ''}
    â€¢ ${pattern.name === 'Thesis' ? 'Thesis: arguments, evidence, citations, counter-arguments' : ''}
    â€¢ ${pattern.name === 'Product Roadmap' ? 'Roadmap: tasks, specs, acceptance criteria, tests' : ''}
    â€¢ ${pattern.name === 'Book' ? 'Book: scenes, character moments, plot points' : ''}
    â€¢ ${pattern.name === 'Course' ? 'Course: lessons, activities, assessments, exercises' : ''}
    â€¢ ${pattern.name === 'Film Production' ? 'Film: shots, camera movements, lighting, blocking' : ''}
    â€¢ ${pattern.name === 'Veo3 (Google)' ? 'Veo3: ingredient images, frame transitions, extensions, audio types (dialogue/SFX/ambience)' : ''}
    â€¢ ${pattern.name === 'Sora2 (OpenAI)' ? 'Sora2: cameo shots, remix variants, physics complexity, beat types (setup/conflict/resolution)' : ''}
    â€¢ ${pattern.name === 'Prompt Engineering' ? 'Prompting: test cases, variations, edge cases' : ''}
    â€¢ Generic: steps, components, or sub-elements
  â†’ Focus on ${pattern.name} deliverables, not generic task lists
  â†’ âœ¨ UNLIMITED NESTING: ${wizardState.patternKey === 'filesystem' ? 'children can have their own children for N-level depth (e.g., Folder â†’ Subfolder â†’ File)' : 'subItems can have their own subItems for N-level depth (e.g., Step 1 â†’ Step 1.1 â†’ Step 1.1.1)'}
- Dependency info in descriptions (e.g., "After Phase 1 completes...")
- Pattern-specific fields (infer from conversation)

NEVER ask about:
- Formatting preferences
- Nice-to-have details that can be added later
- Information already inferrable from context

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ RESPONSE FORMAT - MANDATORY: Return ONLY the JSON below âš ï¸
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO NOT write ANY text before or after the JSON.
Your ENTIRE response must be ONLY this JSON object:

${wizardState.patternKey === 'filesystem' ? `
âš ï¸ FILESYSTEM PATTERN - SPECIAL STRUCTURE:
For File System pattern, use "children" arrays at ALL levels (not "items" or "subItems"):

{
  "message": "I've built [X drives, Y folders]. [State what you added]. [Ask ONE follow-up question]",
  "treeUpdate": {
    "name": "My Computer",
    "description": "File system structure",
    "children": [
      {
        "name": "C:\\ Local Drive",
        "type": "phase",
        "icon": "ðŸ’¾",
        "children": [
          {
            "name": "Projects",
            "type": "item",
            "icon": "ðŸ“",
            "isFolder": true,
            "dateModified": "2025-11-15T14:30:00",
            "children": [
              {
                "name": "report.xlsx",
                "type": "item",
                "icon": "ðŸ“—",
                "isFolder": false,
                "fileSize": 15728640,
                "fileExtension": ".xlsx",
                "dateModified": "2025-11-10T16:45:00"
              }
            ]
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["fileSize", "isFolder"],
  "progress": 0.7,
  "done": false
}

âš ï¸ FILESYSTEM REQUIREMENTS:
- Use "children" for folders AND files (NOT "items" or "subItems")
- Set isFolder: true for folders, false for files
- Include fileSize (bytes), fileExtension, dateModified for files
- Auto-detect icons based on extension (.xlsxâ†’ðŸ“—, .pdfâ†’ðŸ“•, .jpgâ†’ðŸ–¼ï¸, etc.)
- Unlimited nesting depth supported via children arrays
` : wizardState.patternKey === 'prompting' ? `
âš ï¸ AI PROMPT DESIGN PATTERN - SPECIAL FIELDS:
For AI Prompt Design, items MUST include these pattern-specific fields:

{
  "message": "I've designed [X] prompt stages with system instructions, user templates, and examples. [Ask ONE follow-up question]",
  "treeUpdate": {
    "name": "Master Prompt Engineer",
    "description": "Transform weak prompts into highly effective, structured instructions using proven prompt engineering framework",
    "children": [
      {
        "name": "System Configuration",
        "subtitle": "Role, framework, and process",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Core System Prompt",
            "description": "Expert persona and meta-framework for prompt engineering",
            "itemType": "system-prompt",
            "systemPrompt": "You are a Master Prompt Engineer specializing in Large Language Model interactions. Your expertise is transforming vague, simple, or inefficient prompts into highly effective, structured instructions.\n\nYour Framework (apply to every prompt):\n1. PERSONA/ROLE - Assign specific expert identity\n2. TASK - Define objective with active verbs\n3. CONTEXT - Add necessary background\n4. CONSTRAINTS - Define rules (do's and don'ts)\n5. OUTPUT FORMAT - Specify exact structure (Table, JSON, Markdown, etc.)\n\nYour Process:\n1. INPUT ACQUISITION - If no prompt provided, request it\n2. ANALYSIS - Evaluate for Clarity, Context, Constraints (3C Framework)\n3. IMPROVEMENT - Rewrite using the 5-part framework above\n4. DELIVERY - Present as: Critique â†’ Optimized Prompt â†’ Explanation\n\nBe analytical, precise, and helpful. Every improved prompt must be copy-paste ready.",
            "subItems": [
              {
                "name": "Tone Guidelines",
                "description": "Analytical, precise, helpful. Focus on teaching principles, not just fixing."
              },
              {
                "name": "Quality Standards",
                "description": "Every output must be immediately usable. No placeholders unless explicitly requested."
              }
            ]
          }
        ]
      },
      {
        "name": "User Interaction",
        "subtitle": "How users engage with this prompt",
        "type": "phase",
        "phase": 1,
        "items": [
          {
            "name": "User Prompt Template",
            "description": "Ready-to-use prompt for improving other prompts",
            "itemType": "user-template",
            "userPromptTemplate": "Please provide the prompt you would like me to improve. I'll analyze it for clarity, context, and constraints, then rewrite it using proven prompt engineering principles (Persona â†’ Task â†’ Context â†’ Constraints â†’ Output Format). I'll deliver a structured response with: (1) Critique of the original, (2) Optimized version, and (3) Explanation of improvements.",
            "subItems": [
              {
                "name": "Alternative: Batch Mode",
                "description": "For multiple prompts: 'I have three prompts to improve. I'll share them one at a time. For each, provide: Critique â†’ Optimized Version â†’ Key Improvements. Ready for the first one?'"
              }
            ]
          }
        ]
      },
      {
        "name": "Examples & Training",
        "subtitle": "Before/after prompt transformations",
        "type": "phase",
        "phase": 2,
        "items": [
          {
            "name": "Example Set",
            "description": "Demonstrate weak â†’ strong prompt transformations",
            "itemType": "examples",
            "fewShotExamples": "Example 1 - Weak Prompt:\n'Write about climate change.'\n\nOptimized:\n'You are an environmental scientist specializing in climate policy. Write a 500-word article explaining the top 3 impacts of climate change on coastal cities for a general audience. Use concrete examples from Miami, Venice, and Jakarta. Structure: (1) Introduction with thesis, (2) Three impacts with data, (3) Conclusion with actionable steps. Tone: Informative but accessible, avoid jargon.'\n\nKey Improvement: Added persona (environmental scientist), specific task (3 impacts, 500 words, examples), constraints (avoid jargon), and output structure.\n\n---\n\nExample 2 - Weak Prompt:\n'Help me with my resume.'\n\nOptimized:\n'You are a senior tech recruiter with 15 years of experience at FAANG companies. Review my software engineer resume and provide feedback in this format:\n1. STRENGTHS - What stands out positively\n2. GAPS - What's missing or unclear\n3. IMPROVEMENTS - 3 specific changes to increase interview callbacks\n4. REWRITE - Rewrite the Experience section for my top role using STAR format (Situation, Task, Action, Result)\n\nFocus on quantifiable achievements and technical impact. Target: Senior SWE roles at large tech companies.'\n\nKey Improvement: Added expert persona (tech recruiter), clear analysis framework (4-part structure), constraints (quantifiable, STAR format), and target audience (senior roles, big tech).",
            "subItems": [
              {
                "name": "Domain-Specific Example: Gardening Assistant",
                "description": "Full prompt structure for fall/winter gardening in Victoria, BC. System: 'You are an expert Pacific Northwest gardening consultant specializing in fall and winter cultivation in USDA zones 8-9. You provide specific, actionable advice based on local climate patterns, soil conditions, and seasonal timing for Victoria, BC and surrounding regions.' User: 'I need fall/winter gardening advice for Victoria, BC. Start by asking me what plants I want to grow, my experience level, and my garden conditions (soil type, sun exposure). Then provide a tailored planting and maintenance guide based on my answers.' Output Format: '1. Planting Timeline (specific dates/months), 2. Soil Preparation (pH, amendments, prep steps), 3. Planting Instructions (depth, spacing, technique), 4. Maintenance Schedule (weekly tasks through season), 5. Harvest Timing (when and how to harvest).' This shows how the meta-framework applies to a concrete domain."
              }
            ]
          }
        ]
      },
      {
        "name": "Output Specification",
        "subtitle": "Standardized delivery format",
        "type": "phase",
        "phase": 3,
        "items": [
          {
            "name": "Response Structure",
            "description": "Consistent 3-part delivery format",
            "itemType": "output-format",
            "outputFormat": "Deliver every improved prompt in this format:\n\n**1. CRITIQUE OF ORIGINAL PROMPT**\n- Briefly explain weaknesses (e.g., 'Lacked persona,' 'Too vague on formatting,' 'No constraints')\n\n**2. OPTIMIZED PROMPT**\n> [Full rewritten prompt in blockquote or code block for easy copying]\n\n**3. EXPLANATION OF CHANGES**\n- Explain why specific changes improve results (e.g., 'Added expert persona to increase authority,' 'Specified output format to ensure consistency')\n\nOptional: If the original prompt is ambiguous, ask 1-2 clarifying questions before optimizing.",
            "chainOfThought": "Before rewriting, analyze using 3C Framework: (1) CLARITY - Is intent obvious? (2) CONTEXT - Does AI know its role and audience? (3) CONSTRAINTS - Are there guardrails on length, format, style? Then apply 5-part framework: Persona â†’ Task â†’ Context â†’ Constraints â†’ Output Format."
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["systemPrompt", "userPromptTemplate", "fewShotExamples", "outputFormat", "chainOfThought"],
  "progress": 0.8,
  "done": false
}

âš ï¸ CRITICAL for Prompt Engineering pattern:
- ALWAYS populate systemPrompt, userPromptTemplate, fewShotExamples, outputFormat fields
- TEACH THE META-FRAMEWORK: Persona â†’ Task â†’ Context â†’ Constraints â†’ Output Format
- SHOW THE PROCESS: Input Acquisition â†’ Analysis (3C: Clarity, Context, Constraints) â†’ Improvement â†’ Delivery
- NO PLACEHOLDER VARIABLES: Use interactive style (AI asks questions) or specific style (list concrete topics)
- READY-TO-USE: Prompts must work immediately when pasted (no {{variable}} substitution needed)
- Use subItems for supplementary details (tone guidelines, quality standards, alternatives)
- Each phase represents a component of the final prompt (System, User, Examples, Output)
- The Generate Prompt feature extracts these fields to create the executable prompt
` : `
âš ï¸ OPTION A - When just asking a question (NO tree changes):
{
  "message": "Your question here...",
  "treeUpdate": null,
  "fieldsUpdated": [],
  "progress": 0.5,
  "done": false
}

âš ï¸ OPTION B - When ADDING new items (include ONLY the new items):
{
  "message": "I've added [X]. [Ask ONE follow-up question]",
  "treeUpdate": {
    "name": "Project Name",
    "description": "Brief description",
    "children": [
      {
        "name": "Phase 1",
        "subtitle": "Phase subtitle",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Item name",
            "description": "Item description (include dependency notes like 'Requires X to complete first' if order matters)",
            "itemType": "type",
            "subItems": [
              {
                "name": "Step 1",
                "description": "Detail",
                "subItems": [
                  {"name": "Step 1.1", "description": "Nested detail (supports N-level depth)"}
                ]
              },
              {"name": "Step 2", "description": "Detail"}
            ]
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["field1", "field2"],
  "progress": 0.7,
  "done": false
}`}

ðŸŽ¯ CRITICAL RULES:
- Return ONLY JSON, no text before/after
- âš ï¸ KEEP RESPONSES CONCISE: Don't add too many items at once (max 5-7 items per turn)
- Turn 1: Build MINIMAL tree (just project name), ask about GOAL
- Turn 2+: Include treeUpdate with 2-4+ new items per turn
- INFER AGGRESSIVELY: Add details based on context, let user correct
- EVERY message must end with ONE strategic follow-up question (unless done=true)
- Follow the QUESTIONING ORDER above (Goal â†’ Structure â†’ Details â†’ Validation)
- Track progress field accurately (0.0 â†’ 1.0)
- Set done=true when tree is complete (typically turn 5)
- If tree is getting large (>20 items), add fewer items per turn to avoid truncation

ðŸš€ FIRST RESPONSE INSTRUCTION:
${wizardState.enhanceMode ? `
ENHANCE MODE - First response:
${itemCount > 30 ? `
â›” LARGE TREE DETECTED (${itemCount} items) - DO NOT ECHO THE TREE!
1. Set treeUpdate to NULL (the system already has all the data)
2. Set progress based on how complete the tree already is (0.5 to 0.8 typical)
3. Ask: "I can see you have ${phaseCount} ${levels.phase.toLowerCase()}s and ${itemCount} ${levels.item.toLowerCase()}s. What would you like me to help you with? Add more items, expand existing ones, or fill gaps?"

â›”â›”â›” CRITICAL: For trees with 30+ items, you MUST use treeUpdate: null
The existing tree is already loaded. Echoing it back wastes tokens and causes cutoff errors.
` : `
1. Return a SUMMARY of the tree structure in treeUpdate (max 5-10 representative items, NOT everything)
2. Set progress based on how complete the tree already is (0.5 to 0.8 typical)
3. Ask: "I can see you have [X]. What would you like me to help you with? Add more ${levels.item.toLowerCase()}s, expand existing ones with more detail, add subtasks, or fill gaps?"
`}

âš ï¸ ALL RESPONSES (including first): Include ONLY new or modified items. NEVER echo the full tree.
   - If just asking a question: Use treeUpdate: null
   - If adding new items to an existing phase: Include just that phase with the new items
   - If modifying an existing item: Include just that item with changes
   - If adding a new phase: Include just the new phase
   - Items not mentioned are automatically preserved!
` : `
BUILD MODE - First response:
1. Create minimal tree with just project name and empty description
2. Set progress to 0.1
3. ${pattern.name === 'Prompt Engineering' ? `Ask: "What prompt do you want to design? Describe what it should DO when someone uses it.

Examples:
â€¢ 'A prompt that takes a business idea and returns a 5-year financial projection with key metrics'
â€¢ 'A prompt that analyzes code for security vulnerabilities and suggests fixes with severity ratings'
â€¢ 'A prompt that converts casual emails into formal business communications'

Remember: You're DESIGNING a prompt (meta-level), not using one. Tell me what task the prompt should perform."` : `Ask: "What is the exact GOAL of this ${pattern.name.toLowerCase()}? What specific output/result should it produce?"`}

DO NOT build phases, items, or subtasks in Turn 1. Wait to understand the goal first.
`}`;
        }

        // Merge tree update into working tree (SMART MERGE - preserves existing data)
        function mergeTreeUpdate(update, aiSource = 'ai-sonnet') {
            if (update.name) wizardState.workingTree.name = update.name;
            if (update.description) wizardState.workingTree.description = update.description;

            if (update.children) {
                // Initialize existing children if none
                if (!wizardState.workingTree.children) {
                    wizardState.workingTree.children = [];
                }

                // Helper: Find matching phase by name (case-insensitive, fuzzy)
                function findMatchingPhase(phaseName, existingPhases) {
                    const normalizedName = phaseName.toLowerCase().trim();
                    return existingPhases.find(p =>
                        p.name.toLowerCase().trim() === normalizedName ||
                        p.name.toLowerCase().includes(normalizedName) ||
                        normalizedName.includes(p.name.toLowerCase())
                    );
                }

                // Helper: Find matching item by name (case-insensitive, fuzzy)
                function findMatchingItem(itemName, existingItems) {
                    const normalizedName = itemName.toLowerCase().trim();
                    return existingItems.find(i =>
                        i.name.toLowerCase().trim() === normalizedName ||
                        i.name.toLowerCase().includes(normalizedName) ||
                        normalizedName.includes(i.name.toLowerCase())
                    );
                }

                // Track which existing phases were matched
                const matchedPhaseIds = new Set();

                // Process each phase from update
                update.children.forEach((updatedPhase, phaseIdx) => {
                    const existingPhase = findMatchingPhase(updatedPhase.name, wizardState.workingTree.children);

                    if (existingPhase) {
                        // MERGE with existing phase
                        console.log(`ðŸ”„ Merging phase: ${updatedPhase.name}`);
                        matchedPhaseIds.add(existingPhase.id);

                        // Update phase-level fields (preserve existing if not in update)
                        existingPhase.name = updatedPhase.name || existingPhase.name;
                        existingPhase.subtitle = updatedPhase.subtitle || existingPhase.subtitle;
                        if (updatedPhase.description) existingPhase.description = updatedPhase.description;

                        // Merge items (standard patterns) OR children (filesystem pattern)
                        const itemsArrayName = updatedPhase.items ? 'items' : (updatedPhase.children ? 'children' : null);
                        if (itemsArrayName) {
                            if (!existingPhase[itemsArrayName]) existingPhase[itemsArrayName] = [];

                            const matchedItemIds = new Set();

                            updatedPhase[itemsArrayName].forEach((updatedItem, itemIdx) => {
                                const existingItem = findMatchingItem(updatedItem.name, existingPhase[itemsArrayName]);

                                if (existingItem) {
                                    // MERGE with existing item - preserve ALL existing fields
                                    console.log(`  ðŸ”„ Merging item: ${updatedItem.name}`);
                                    matchedItemIds.add(existingItem.id);

                                    // Merge all fields (keep existing if not in update)
                                    Object.keys(updatedItem).forEach(key => {
                                        if (key !== 'subItems' && key !== 'children' && updatedItem[key] !== undefined && updatedItem[key] !== '') {
                                            existingItem[key] = updatedItem[key];
                                        }
                                    });

                                    // Merge subItems (RECURSIVE for N-level depth support)
                                    // Supports both 'subItems' (standard) and 'children' (filesystem)
                                    function mergeSubItems(existingParent, updatedParent, parentPhase, parentItemIdx) {
                                        const nestedArrayName = updatedParent.subItems ? 'subItems' : (updatedParent.children ? 'children' : null);
                                        if (!nestedArrayName) return;
                                        if (!existingParent[nestedArrayName]) existingParent[nestedArrayName] = [];

                                        updatedParent[nestedArrayName].forEach(newSubItem => {
                                            const existingSubItem = existingParent[nestedArrayName].find(s =>
                                                s.name.toLowerCase().trim() === newSubItem.name.toLowerCase().trim()
                                            );

                                            if (existingSubItem) {
                                                // Update existing subItem
                                                Object.keys(newSubItem).forEach(key => {
                                                    if (key !== 'subItems' && key !== 'children' && newSubItem[key] !== undefined && newSubItem[key] !== '') {
                                                        existingSubItem[key] = newSubItem[key];
                                                    }
                                                });

                                                // RECURSIVE: Merge nested items (supports N-level depth)
                                                mergeSubItems(existingSubItem, newSubItem, parentPhase, parentItemIdx);
                                            } else {
                                                // Add new item with auto-generated ID
                                                const subIdx = existingParent[nestedArrayName].length;
                                                const newSubItemWithId = {
                                                    id: `${nestedArrayName === 'children' ? 'child' : 'subtask'}-${parentPhase}-${parentItemIdx}-${subIdx}`,
                                                    type: nestedArrayName === 'children' ? 'item' : 'subtask',
                                                    ...newSubItem,
                                                    provenance: {
                                                        source: aiSource,
                                                        timestamp: new Date().toISOString()
                                                    }
                                                };
                                                existingParent[nestedArrayName].push(newSubItemWithId);
                                            }
                                        });
                                    }

                                    mergeSubItems(existingItem, updatedItem, existingPhase.phase, existingPhase[itemsArrayName].indexOf(existingItem));
                                } else {
                                    // ADD new item to existing phase
                                    console.log(`  âœ… Adding new item: ${updatedItem.name}`);
                                    const newItemIdx = existingPhase[itemsArrayName].length;

                                    // RECURSIVE function to add IDs to nested items (supports both subItems and children)
                                    function addNestedItemIds(nestedItems, nestedArrayName, phaseIdx, itemIdx, parentPath = '') {
                                        if (!nestedItems) return [];
                                        return nestedItems.map((nestedItem, nestedIdx) => {
                                            const childArrayName = nestedItem.subItems ? 'subItems' : (nestedItem.children ? 'children' : null);
                                            const result = {
                                                id: `${nestedArrayName === 'children' ? 'child' : 'subtask'}-${phaseIdx}-${itemIdx}-${parentPath}${nestedIdx}`,
                                                type: nestedArrayName === 'children' ? 'item' : 'subtask',
                                                ...nestedItem
                                            };
                                            if (childArrayName) {
                                                result[childArrayName] = addNestedItemIds(nestedItem[childArrayName], childArrayName, phaseIdx, itemIdx, `${parentPath}${nestedIdx}-`);
                                            }
                                            return result;
                                        });
                                    }

                                    const nestedArrayName = updatedItem.subItems ? 'subItems' : (updatedItem.children ? 'children' : null);
                                    const newItem = {
                                        id: `item-${existingPhase.phase}-${newItemIdx}`,
                                        type: 'item',
                                        icon: 'ðŸ“„',
                                        expanded: false,
                                        ...updatedItem,
                                        provenance: {
                                            source: aiSource,
                                            timestamp: new Date().toISOString()
                                        }
                                    };
                                    if (nestedArrayName) {
                                        newItem[nestedArrayName] = addNestedItemIds(updatedItem[nestedArrayName], nestedArrayName, existingPhase.phase, newItemIdx);
                                    }
                                    existingPhase[itemsArrayName].push(newItem);
                                }
                            });

                            // PRESERVE existing items that weren't in the update
                            console.log(`  â„¹ï¸ Preserved ${existingPhase[itemsArrayName].filter(i => !matchedItemIds.has(i.id)).length} existing items not in update`);
                        }
                    } else {
                        // ADD new phase
                        console.log(`âœ… Adding new phase: ${updatedPhase.name}`);
                        const newPhaseIdx = wizardState.workingTree.children.length;

                        // RECURSIVE function to add IDs to nested subItems (reuse from above)
                        function addSubItemIds(subItems, phaseIdx, itemIdx, parentPath = '') {
                            if (!subItems) return [];
                            return subItems.map((subItem, subIdx) => ({
                                id: `subtask-${phaseIdx}-${itemIdx}-${parentPath}${subIdx}`,
                                type: 'subtask',
                                ...subItem,
                                provenance: {
                                    source: aiSource,
                                    timestamp: new Date().toISOString()
                                },
                                subItems: addSubItemIds(subItem.subItems, phaseIdx, itemIdx, `${parentPath}${subIdx}-`)
                            }));
                        }

                        wizardState.workingTree.children.push({
                            id: `phase-${newPhaseIdx}`,
                            type: 'phase',
                            phase: newPhaseIdx,
                            icon: 'ðŸ“‹',
                            expanded: true,
                            ...updatedPhase,
                            provenance: {
                                source: aiSource,
                                timestamp: new Date().toISOString()
                            },
                            items: (updatedPhase.items || []).map((item, itemIdx) => ({
                                id: `item-${newPhaseIdx}-${itemIdx}`,
                                type: 'item',
                                icon: 'ðŸ“„',
                                expanded: false,
                                ...item,
                                provenance: {
                                    source: aiSource,
                                    timestamp: new Date().toISOString()
                                },
                                subItems: addSubItemIds(item.subItems, newPhaseIdx, itemIdx)
                            }))
                        });
                    }
                });

                // PRESERVE existing phases that weren't in the update
                const preservedPhases = wizardState.workingTree.children.filter(p => !matchedPhaseIds.has(p.id));
                console.log(`â„¹ï¸ Preserved ${preservedPhases.length} existing phases not in update`);

                // Re-index phase numbers
                wizardState.workingTree.children.forEach((phase, idx) => {
                    phase.phase = idx;
                });

                console.log(`âœ… Smart merge complete: ${wizardState.workingTree.children.length} phases, ${wizardState.workingTree.children.reduce((sum, p) => sum + (p.items?.length || 0), 0)} items`);
            }
        }

        // =============================================================================
        // HYPEREDGE MANAGEMENT (Wolfram-style N-ary relationships)
        // =============================================================================

        /**
         * Add a new hyperedge to the root-level hyperedges array
         * @param {string} type - Type of hyperedge (e.g., 'montage', 'argument', 'theme', 'dependency-cluster')
         * @param {string} label - Human-readable label for the hyperedge
         * @param {string[]} nodeIds - Array of global node IDs (2+ nodes)
         * @param {object} metadata - Optional metadata (color, pattern, created, etc.)
         * @returns {object} The created hyperedge
         */
        function addHyperedge(type, label, nodeIds, metadata = {}) {
            if (!capexTree.hyperedges) {
                capexTree.hyperedges = [];
            }

            if (nodeIds.length < 2) {
                console.warn('Hyperedge requires at least 2 nodes');
                return null;
            }

            const hyperedge = {
                id: `hyperedge-${Date.now()}`,
                type: type,
                label: label,
                nodeIds: nodeIds,
                metadata: {
                    created: new Date().toISOString(),
                    ...metadata
                }
            };

            capexTree.hyperedges.push(hyperedge);
            console.log(`âœ… Created hyperedge: ${label} (${nodeIds.length} nodes)`);

            return hyperedge;
        }

        /**
         * Remove a hyperedge by ID
         * @param {string} hyperedgeId - The ID of the hyperedge to remove
         * @returns {boolean} True if removed, false if not found
         */
        function removeHyperedge(hyperedgeId) {
            if (!capexTree.hyperedges) {
                return false;
            }

            const initialLength = capexTree.hyperedges.length;
            capexTree.hyperedges = capexTree.hyperedges.filter(h => h.id !== hyperedgeId);

            const removed = capexTree.hyperedges.length < initialLength;
            if (removed) {
                console.log(`âœ… Removed hyperedge: ${hyperedgeId}`);
            }

            return removed;
        }

        /**
         * Global handler for deleting hyperedges from the info panel UI
         * @param {string} id - The hyperedge ID to delete
         */
        window.deleteHyperedge = function(id) {
            if (confirm('Delete this hyperedge group?')) {
                saveState('Delete Hyperedge');
                removeHyperedge(id);
                renderCanvas(); // Re-draw canvas to remove the visual blob
                showInfo(capexTree); // Refresh the info panel to update the list
            }
        }

        /**
         * Find all hyperedges containing a specific node
         * @param {string} nodeId - The node ID to search for
         * @returns {object[]} Array of hyperedges containing this node
         */
        function findHyperedgesForNode(nodeId) {
            if (!capexTree.hyperedges) {
                return [];
            }

            return capexTree.hyperedges.filter(h => h.nodeIds.includes(nodeId));
        }

        /**
         * Get a specific hyperedge by ID
         * @param {string} hyperedgeId - The hyperedge ID
         * @returns {object|null} The hyperedge or null if not found
         */
        function getHyperedgeById(hyperedgeId) {
            if (!capexTree.hyperedges) {
                return null;
            }

            return capexTree.hyperedges.find(h => h.id === hyperedgeId) || null;
        }

        /**
         * Get all hyperedges
         * @returns {object[]} Array of all hyperedges
         */
        function getAllHyperedges() {
            return capexTree.hyperedges || [];
        }

        /**
         * Helper: Get a node by its global ID (searches entire tree)
         * @param {string} nodeId - The node ID to find
         * @returns {object|null} The node or null if not found
         */
        function getNodeById(nodeId) {
            if (capexTree.id === nodeId) return capexTree;

            function searchNode(node) {
                if (node.id === nodeId) return node;

                // Search children (phases)
                if (node.children) {
                    for (const child of node.children) {
                        const found = searchNode(child);
                        if (found) return found;
                    }
                }

                // Search items
                if (node.items) {
                    for (const item of node.items) {
                        const found = searchNode(item);
                        if (found) return found;
                    }
                }

                // Search subItems
                if (node.subItems) {
                    for (const subItem of node.subItems) {
                        const found = searchNode(subItem);
                        if (found) return found;
                    }
                }

                return null;
            }

            return searchNode(capexTree);
        }

        // =============================================================================
        // END HYPEREDGE MANAGEMENT
        // =============================================================================

        // =============================================================================
        // COLLABORATION: Branch & Merge (Email-based async collaboration)
        // =============================================================================

        // Collaboration state
        let currentBranch = null;  // Set when editing a shared branch

        /**
         * Generate or retrieve a stable device fingerprint for contributor tracking
         * Uses canvas fingerprinting + localStorage persistence
         * @returns {string} Device fingerprint ID
         */
        function getDeviceFingerprint() {
            let fp = localStorage.getItem('treelisty-device-id');
            if (!fp) {
                // Generate fingerprint from canvas rendering (browser-specific)
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#6366f1';
                ctx.fillText('TreeListy-FP-2025', 10, 10);
                ctx.fillStyle = '#8b5cf6';
                ctx.fillRect(100, 20, 50, 20);

                // Extract hash from canvas data
                const dataURL = canvas.toDataURL();
                const hash = dataURL.slice(-24).replace(/[^a-zA-Z0-9]/g, '');

                fp = `device-${hash}-${Date.now().toString(36)}`;
                localStorage.setItem('treelisty-device-id', fp);
                console.log('ðŸ”‘ Generated new device fingerprint:', fp);
            }
            return fp;
        }

        /**
         * Get the ancestry path (breadcrumb) for a node
         * @param {string} nodeId - The node to find ancestry for
         * @returns {Array} Array of {id, name, type, icon} from root to parent
         */
        function getAncestryPath(nodeId) {
            const ancestry = [];

            function findPath(node, currentPath = []) {
                // Add this node to path
                const pathEntry = {
                    id: node.id,
                    name: node.name,
                    type: node.type,
                    icon: node.icon || 'ðŸ“„'
                };
                const newPath = [...currentPath, pathEntry];

                // Check if this is the target
                if (node.id === nodeId) {
                    // Return path WITHOUT the target node (just ancestors)
                    return currentPath;
                }

                // Search children (phases)
                if (node.children) {
                    for (const child of node.children) {
                        const found = findPath(child, newPath);
                        if (found) return found;
                    }
                }

                // Search items
                if (node.items) {
                    for (const item of node.items) {
                        const found = findPath(item, newPath);
                        if (found) return found;
                    }
                }

                // Search subItems
                if (node.subItems) {
                    for (const subItem of node.subItems) {
                        const found = findPath(subItem, newPath);
                        if (found) return found;
                    }
                }

                return null;
            }

            return findPath(capexTree) || [{ id: capexTree.id, name: capexTree.name, type: 'root', icon: capexTree.icon }];
        }

        /**
         * Count nodes in a subtree (for size estimation)
         * @param {object} node - Node to count from
         * @returns {number} Total node count including descendants
         */
        function countSubtreeNodes(node) {
            let count = 1;
            if (node.children) node.children.forEach(c => count += countSubtreeNodes(c));
            if (node.items) node.items.forEach(i => count += countSubtreeNodes(i));
            if (node.subItems) node.subItems.forEach(s => count += countSubtreeNodes(s));
            return count;
        }

        /**
         * Estimate compressed URL size for a branch
         * @param {object} branch - Branch token object
         * @returns {number} Estimated URL length in characters
         */
        function estimateBranchURLSize(branch) {
            const json = JSON.stringify(branch);
            // LZ-String typically achieves 30-50% compression
            // Add base URL length (~50 chars) + parameter name (~10 chars)
            const estimatedCompressed = Math.ceil(json.length * 0.6);
            return estimatedCompressed + 60;
        }

        // Maximum recommended URL length (safe for email clients, browsers)
        const MAX_BRANCH_URL_LENGTH = 8000;
        const WARN_BRANCH_URL_LENGTH = 4000;

        /**
         * Extract a subtree for sharing as a collaboration branch
         * @param {string[]} nodeIds - Array of node IDs to include
         * @param {string|null} hyperedgeId - Optional hyperedge ID if sharing a hyperedge
         * @returns {object} Branch token or error object
         */
        function extractSubtree(nodeIds, hyperedgeId = null) {
            if (!nodeIds || nodeIds.length === 0) {
                return { error: 'No nodes selected for sharing' };
            }

            // Get ancestry path from first node (they should share common ancestry)
            const ancestry = getAncestryPath(nodeIds[0]);

            // Deep clone selected nodes with all descendants
            const nodes = [];
            let totalNodeCount = 0;

            for (const id of nodeIds) {
                const node = getNodeById(id);
                if (node) {
                    const cloned = JSON.parse(JSON.stringify(node));
                    nodes.push(cloned);
                    totalNodeCount += countSubtreeNodes(cloned);
                } else {
                    console.warn(`âš ï¸ Node ${id} not found, skipping`);
                }
            }

            if (nodes.length === 0) {
                return { error: 'No valid nodes found to share' };
            }

            // Build branch token
            const branch = {
                branchId: `branch-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                sourceProjectId: capexTree.id,
                sourceProjectName: capexTree.name,
                sourcePattern: currentPattern,
                createdAt: new Date().toISOString(),
                createdBy: getDeviceFingerprint(),
                ancestry,
                hyperedgeId,
                selectedNodeIds: nodeIds,
                nodes,
                schemaVersion: 2
            };

            // Size validation
            const estimatedSize = estimateBranchURLSize(branch);
            if (estimatedSize > MAX_BRANCH_URL_LENGTH) {
                return {
                    error: `Selection too large to share via URL (${totalNodeCount} nodes, ~${Math.round(estimatedSize/1000)}KB)`,
                    nodeCount: totalNodeCount,
                    estimatedSize,
                    suggestion: 'Try selecting fewer nodes or a smaller subtree'
                };
            }

            // Add size info for warnings
            branch._meta = {
                nodeCount: totalNodeCount,
                estimatedURLSize: estimatedSize,
                sizeWarning: estimatedSize > WARN_BRANCH_URL_LENGTH
            };

            console.log(`ðŸ“¦ Extracted branch: ${nodes.length} root nodes, ${totalNodeCount} total nodes, ~${estimatedSize} chars`);
            return branch;
        }

        /**
         * Generate a shareable URL for a branch
         * @param {object} branch - Branch token from extractSubtree
         * @returns {string} Shareable URL with ?branch= parameter
         */
        function generateBranchURL(branch) {
            // Remove internal meta before encoding
            const branchToEncode = { ...branch };
            delete branchToEncode._meta;

            const json = JSON.stringify(branchToEncode);
            const compressed = LZString.compressToEncodedURIComponent(json);
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?branch=${compressed}`;
        }

        /**
         * Check if currently in branch editing mode
         * @returns {boolean} True if editing a shared branch
         */
        function isBranchMode() {
            return currentBranch !== null;
        }

        // Temporary storage for current branch being shared
        let pendingShareBranch = null;

        /**
         * Show the Share Branch modal for collaboration
         * @param {string[]} nodeIds - Array of node IDs to share
         * @param {string|null} hyperedgeId - Optional hyperedge ID
         */
        function showShareBranchModal(nodeIds, hyperedgeId = null) {
            const modal = document.getElementById('share-branch-modal');
            const body = document.getElementById('share-branch-body');

            // Extract subtree with size validation
            const branch = extractSubtree(nodeIds, hyperedgeId);

            // Check for errors
            if (branch.error) {
                body.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                        <h3 style="color: #f59e0b; margin-bottom: 12px;">Cannot Share Selection</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 16px;">${branch.error}</p>
                        ${branch.suggestion ? `<p style="color: var(--text-secondary); font-size: 13px;">${branch.suggestion}</p>` : ''}
                    </div>
                `;
                modal.style.display = 'flex';
                return;
            }

            // Store for button handlers
            pendingShareBranch = branch;

            // Generate URL
            const shareURL = generateBranchURL(branch);
            const meta = branch._meta || {};

            // Build ancestry breadcrumb
            const breadcrumb = branch.ancestry.map(a =>
                `<span style="display: inline-flex; align-items: center; gap: 4px;">${a.icon || 'ðŸ“„'} ${a.name}</span>`
            ).join(' <span style="color: var(--text-secondary);">â€º</span> ');

            // Build node list
            const nodeList = branch.nodes.map(n => `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--card-bg); border-radius: 6px; margin-bottom: 6px;">
                    <span>${n.icon || 'ðŸ“„'}</span>
                    <span style="font-weight: 500;">${n.name}</span>
                    ${n.subItems && n.subItems.length > 0 ? `<span style="font-size: 11px; color: var(--text-secondary);">(+${countSubtreeNodes(n) - 1} children)</span>` : ''}
                </div>
            `).join('');

            body.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 12px; font-size: 14px;">
                        Share these nodes for collaboration. The recipient can edit and send back their changes.
                    </p>

                    <!-- Ancestry Breadcrumb -->
                    <div style="background: var(--card-bg-light); padding: 10px 14px; border-radius: 6px; margin-bottom: 16px; font-size: 13px; color: var(--text-secondary);">
                        <span style="font-weight: 600; margin-right: 8px;">ðŸ“ Location:</span>
                        ${breadcrumb}
                    </div>

                    <!-- Nodes being shared -->
                    <div style="margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            ðŸ“¦ Sharing ${branch.nodes.length} node${branch.nodes.length > 1 ? 's' : ''} (${meta.nodeCount} total with children):
                        </div>
                        <div style="max-height: 150px; overflow-y: auto; padding-right: 8px;">
                            ${nodeList}
                        </div>
                    </div>

                    <!-- URL Input -->
                    <div style="background: var(--card-bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 12px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="share-branch-url-input" readonly
                                   style="flex: 1; background: var(--card-bg); border: 1px solid var(--border); color: var(--text-primary); padding: 10px; border-radius: 6px; font-family: monospace; font-size: 11px; user-select: all;"
                                   value="${shareURL}">
                        </div>
                    </div>

                    <!-- Stats -->
                    <div style="display: flex; gap: 20px; font-size: 13px; color: var(--text-secondary); margin-bottom: 16px;">
                        <div>ðŸ“Š ${meta.nodeCount} nodes</div>
                        <div>ðŸ“ ${shareURL.length.toLocaleString()} characters</div>
                        ${meta.sizeWarning ? '<div style="color: #f59e0b;">âš ï¸ Large selection - may not work in all email clients</div>' : ''}
                    </div>

                    <!-- Instructions -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #10b981;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #10b981;">
                            <span>ðŸ“‹</span> How Collaboration Works
                        </div>
                        <ol style="margin-left: 20px; color: var(--text-secondary); font-size: 13px; line-height: 1.8;">
                            <li>Send this link to your collaborator via email</li>
                            <li>They can view and edit the shared nodes</li>
                            <li>When done, they click "Share Back" and send you the new link</li>
                            <li>You open that link to merge their changes into your project</li>
                        </ol>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Select URL for easy copying
            setTimeout(() => {
                const urlInput = document.getElementById('share-branch-url-input');
                if (urlInput) urlInput.select();
            }, 100);
        }

        /**
         * Generate mailto link for collaboration email
         * @param {object} branch - Branch token
         * @param {string} shareURL - Shareable URL
         * @returns {string} mailto: link
         */
        function generateCollaborationEmail(branch, shareURL) {
            const subject = encodeURIComponent(
                `TreeListy Collaboration: ${branch.sourceProjectName}`
            );
            // Shorter email - just essentials with link at end
            const body = encodeURIComponent(
                `Hi,\n\n` +
                `I'd like your input on part of my TreeListy project "${branch.sourceProjectName}".\n\n` +
                `Click below to view and edit (${branch.nodes.length} node${branch.nodes.length > 1 ? 's' : ''}):\n\n` +
                `${shareURL}\n\n` +
                `When done, click "Share Back" and send me the new link.\n\n` +
                `Thanks!`
            );
            return `mailto:?subject=${subject}&body=${body}`;
        }

        /**
         * Copy rich HTML email to clipboard (for pasting into email clients)
         * @param {object} branch - Branch token
         * @param {string} shareURL - Shareable URL
         */
        async function copyRichEmailToClipboard(branch, shareURL) {
            const htmlContent = `
                <p>Hi,</p>
                <p>I'd like your input on part of my TreeListy project "<strong>${branch.sourceProjectName}</strong>".</p>
                <p>I'm sharing ${branch.nodes.length} node${branch.nodes.length > 1 ? 's' : ''} for you to review and edit.</p>
                <p style="margin: 20px 0;">
                    <a href="${shareURL}" style="display: inline-block; background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: bold;">
                        ðŸ¤ Click to View & Edit
                    </a>
                </p>
                <p style="font-size: 12px; color: #666;">When you're done making changes, click the "Share Back" button and send me the new link.</p>
                <p>Thanks!</p>
            `;

            const plainText = `Hi,

I'd like your input on part of my TreeListy project "${branch.sourceProjectName}".

Click to view and edit: ${shareURL}

When done, click "Share Back" and send me the new link.

Thanks!`;

            try {
                // Try to copy as rich HTML (works in modern browsers)
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const plainBlob = new Blob([plainText], { type: 'text/plain' });

                await navigator.clipboard.write([
                    new ClipboardItem({
                        'text/html': blob,
                        'text/plain': plainBlob
                    })
                ]);
                return true;
            } catch (err) {
                console.log('Rich copy failed, falling back to plain text:', err);
                // Fallback to plain text
                try {
                    await navigator.clipboard.writeText(plainText);
                    return true;
                } catch (err2) {
                    console.error('Clipboard write failed:', err2);
                    return false;
                }
            }
        }

        // Storage for pending merge operation (must be declared before IIFE)
        let pendingMergeBranch = null;

        // Initialize Share Branch modal event handlers
        // Use immediate execution with DOM check for reliability
        (function initCollaborationHandlers() {
            // If DOM not ready, wait for it
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initCollaborationHandlers);
                return;
            }

            // Close button
            document.getElementById('share-branch-close')?.addEventListener('click', () => {
                document.getElementById('share-branch-modal').style.display = 'none';
                pendingShareBranch = null;
            });

            // Copy URL button
            document.getElementById('share-branch-copy')?.addEventListener('click', () => {
                const urlInput = document.getElementById('share-branch-url-input');
                if (urlInput) {
                    urlInput.select();
                    document.execCommand('copy');

                    // Visual feedback
                    const btn = document.getElementById('share-branch-copy');
                    const originalText = btn.textContent;
                    btn.textContent = 'âœ… Copied!';
                    btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
                    }, 2000);
                }
            });

            // Email button (opens email app)
            document.getElementById('share-branch-email')?.addEventListener('click', () => {
                if (pendingShareBranch) {
                    const shareURL = document.getElementById('share-branch-url-input')?.value;
                    const mailtoLink = generateCollaborationEmail(pendingShareBranch, shareURL);
                    window.location.href = mailtoLink;
                }
            });

            // Copy Email button (copies rich HTML email to clipboard)
            document.getElementById('share-branch-copy-email')?.addEventListener('click', async () => {
                if (pendingShareBranch) {
                    const shareURL = document.getElementById('share-branch-url-input')?.value;
                    const success = await copyRichEmailToClipboard(pendingShareBranch, shareURL);

                    const btn = document.getElementById('share-branch-copy-email');
                    if (success) {
                        const originalText = btn.textContent;
                        btn.textContent = 'âœ… Copied!';
                        btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                        setTimeout(() => {
                            btn.textContent = originalText;
                            btn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                        }, 2000);
                    } else {
                        btn.textContent = 'âŒ Failed';
                        setTimeout(() => {
                            btn.textContent = 'ðŸ“§ Copy Email';
                        }, 2000);
                    }
                }
            });

            // Close on backdrop click
            document.getElementById('share-branch-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'share-branch-modal') {
                    document.getElementById('share-branch-modal').style.display = 'none';
                    pendingShareBranch = null;
                }
            });

            // =========== MERGE MODAL HANDLERS ===========

            // Cancel merge
            document.getElementById('merge-branch-cancel')?.addEventListener('click', () => {
                document.getElementById('merge-branch-modal').style.display = 'none';
                pendingMergeBranch = null;
            });

            // Accept merge
            const acceptBtn = document.getElementById('merge-branch-accept');
            console.log('ðŸ”€ merge-branch-accept button found:', !!acceptBtn);
            if (acceptBtn) {
                acceptBtn.addEventListener('click', () => {
                    console.log('ðŸ”€ Accept merge clicked, pendingMergeBranch:', !!pendingMergeBranch);
                    if (pendingMergeBranch) {
                        performBranchMerge(pendingMergeBranch);
                    } else {
                        console.error('ðŸ”€ No pendingMergeBranch set!');
                    }
                });
            } else {
                console.error('ðŸ”€ merge-branch-accept button NOT FOUND in DOM!');
            }

            // Close on backdrop click
            document.getElementById('merge-branch-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'merge-branch-modal') {
                    document.getElementById('merge-branch-modal').style.display = 'none';
                    pendingMergeBranch = null;
                }
            });

            // =========== BRANCH EDIT BANNER HANDLERS ===========

            // Share Back button
            document.getElementById('branch-share-back-btn')?.addEventListener('click', () => {
                shareBackBranch();
            });

            // Exit branch editing mode
            document.getElementById('branch-exit-btn')?.addEventListener('click', () => {
                exitBranchEditMode();
            });

            // =========== PASTE BRANCH URL MODAL HANDLERS ===========

            // Open paste branch modal
            document.getElementById('merge-branch-btn')?.addEventListener('click', () => {
                document.getElementById('paste-branch-modal').style.display = 'flex';
                document.getElementById('paste-branch-url-input').value = '';
                document.getElementById('paste-branch-url-input').focus();
            });

            // Cancel paste branch
            document.getElementById('paste-branch-cancel')?.addEventListener('click', () => {
                document.getElementById('paste-branch-modal').style.display = 'none';
            });

            // Parse and merge pasted URL
            document.getElementById('paste-branch-merge')?.addEventListener('click', () => {
                const urlInput = document.getElementById('paste-branch-url-input');
                const url = urlInput.value.trim();

                if (!url) {
                    showToast('âŒ Please paste a URL first', 'error');
                    return;
                }

                // Extract branch parameter from URL
                let branchParam = null;
                try {
                    const urlObj = new URL(url);
                    branchParam = urlObj.searchParams.get('branch');
                } catch (e) {
                    // Maybe they just pasted the branch parameter directly
                    if (url.includes('branch=')) {
                        branchParam = url.split('branch=')[1].split('&')[0];
                    }
                }

                if (!branchParam) {
                    showToast('âŒ Invalid URL - no branch parameter found', 'error');
                    return;
                }

                // Close paste modal
                document.getElementById('paste-branch-modal').style.display = 'none';

                // Parse and show merge modal
                const branch = parseBranchFromURL(branchParam);
                if (!branch) {
                    showToast('âŒ Failed to parse branch data', 'error');
                    return;
                }

                // Show appropriate modal based on branch type
                if (branch.isResponse) {
                    showMergeBranchModal(branch);
                } else {
                    // Original share - ask if they want to edit or merge
                    if (isOriginalBranchCreator(branch)) {
                        showToast('â„¹ï¸ This is your own shared branch', 'warning');
                    } else {
                        enterBranchEditMode(branch);
                    }
                }
            });

            // Close paste modal on backdrop click
            document.getElementById('paste-branch-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'paste-branch-modal') {
                    document.getElementById('paste-branch-modal').style.display = 'none';
                }
            });

            console.log('ðŸ¤ Collaboration event handlers initialized');
        })();

        /**
         * Parse a branch from URL parameter
         * @param {string} compressedBranch - LZString compressed branch data
         * @returns {object|null} Parsed branch or null on error
         */
        function parseBranchFromURL(compressedBranch) {
            try {
                const decompressed = LZString.decompressFromEncodedURIComponent(compressedBranch);
                if (!decompressed) {
                    console.error('âŒ Failed to decompress branch data');
                    return null;
                }
                const branch = JSON.parse(decompressed);
                console.log('ðŸ“¦ Parsed branch:', {
                    branchId: branch.branchId,
                    sourceProject: branch.sourceProjectName,
                    nodeCount: branch.nodes?.length,
                    createdBy: branch.createdBy
                });
                return branch;
            } catch (error) {
                console.error('âŒ Failed to parse branch:', error);
                return null;
            }
        }

        /**
         * Check if the current device is the original branch creator
         * @param {object} branch - Branch to check
         * @returns {boolean} True if this device created the branch
         */
        function isOriginalBranchCreator(branch) {
            const myFingerprint = getDeviceFingerprint();
            return branch.createdBy === myFingerprint;
        }

        /**
         * Enter branch editing mode (for collaborators)
         * @param {object} branch - The branch being edited
         */
        function enterBranchEditMode(branch) {
            currentBranch = branch;

            // Create a temporary tree from the branch nodes
            const tempTree = {
                id: `branch-edit-${branch.branchId}`,
                name: `Editing: ${branch.nodes[0]?.name || 'Shared Branch'}`,
                type: 'root',
                icon: 'ðŸ¤',
                description: `Shared from "${branch.sourceProjectName}" for collaboration`,
                pattern: { key: branch.sourcePattern },
                children: []
            };

            // If single node, wrap appropriately
            if (branch.nodes.length === 1 && branch.nodes[0].type === 'phase') {
                tempTree.children = branch.nodes;
            } else {
                // Create a container phase for the shared items
                tempTree.children = [{
                    id: 'shared-phase',
                    name: 'Shared Content',
                    type: 'phase',
                    icon: 'ðŸ“¦',
                    phaseNumber: 0,
                    expanded: true,
                    items: branch.nodes.filter(n => n.type === 'item' || n.type === 'subtask'),
                    showInCanvas: true
                }];
                // Also add any phases directly
                const phases = branch.nodes.filter(n => n.type === 'phase');
                if (phases.length > 0) {
                    tempTree.children = phases;
                }
            }

            // Set pattern
            if (branch.sourcePattern && PATTERNS[branch.sourcePattern]) {
                currentPattern = branch.sourcePattern;
            }

            // Load the branch as the current tree
            capexTree = tempTree;

            // Show the editing banner
            const banner = document.getElementById('branch-edit-banner');
            const info = document.getElementById('branch-edit-info');
            if (banner && info) {
                info.textContent = `From: ${branch.sourceProjectName} â€¢ ${branch.nodes.length} node(s)`;
                banner.style.display = 'block';

                // Adjust tree container to account for banner
                const treeContainer = document.querySelector('.tree-view-container');
                if (treeContainer) {
                    treeContainer.style.marginTop = '50px';
                }
            }

            // Render
            render();
            if (currentView === 'canvas') {
                renderCanvas();
            }

            console.log('ðŸ¤ Entered branch editing mode:', branch.branchId);
        }

        /**
         * Exit branch editing mode
         */
        function exitBranchEditMode() {
            if (!currentBranch) return;

            if (confirm('Exit editing mode? Any unsaved changes will be lost.\n\nTip: Use "Share Back" to send your changes before exiting.')) {
                currentBranch = null;

                // Hide banner
                const banner = document.getElementById('branch-edit-banner');
                if (banner) {
                    banner.style.display = 'none';
                }

                // Reset tree container margin
                const treeContainer = document.querySelector('.tree-view-container');
                if (treeContainer) {
                    treeContainer.style.marginTop = '0';
                }

                // Load default tree
                capexTree = JSON.parse(JSON.stringify(defaultCapexTree));
                render();
                if (currentView === 'canvas') {
                    renderCanvas();
                }

                // Clear URL parameter
                window.history.replaceState({}, document.title, window.location.pathname);

                console.log('ðŸ‘‹ Exited branch editing mode');
            }
        }

        /**
         * Share back the edited branch to the original creator
         */
        function shareBackBranch() {
            if (!currentBranch) {
                console.error('âŒ No branch to share back');
                return;
            }

            // Extract the edited nodes from current tree
            const editedNodes = [];

            // Collect all items and subtasks from the current tree
            function collectNodes(node) {
                if (node.type === 'item' || node.type === 'subtask' || node.type === 'phase') {
                    editedNodes.push(JSON.parse(JSON.stringify(node)));
                }
                if (node.children) node.children.forEach(collectNodes);
                if (node.items) node.items.forEach(collectNodes);
                if (node.subItems) node.subItems.forEach(collectNodes);
            }

            capexTree.children?.forEach(collectNodes);

            // Create a response branch
            const responseBranch = {
                ...currentBranch,
                branchId: `response-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                editedBy: getDeviceFingerprint(),
                editedAt: new Date().toISOString(),
                originalBranchId: currentBranch.branchId,
                nodes: editedNodes.length > 0 ? editedNodes : capexTree.children || [],
                isResponse: true
            };

            // Generate URL
            const shareURL = generateBranchURL(responseBranch);

            // Show the share modal with response context
            showShareBackModal(responseBranch, shareURL);
        }

        /**
         * Show the Share Back modal
         * @param {object} branch - Response branch
         * @param {string} shareURL - Shareable URL
         */
        function showShareBackModal(branch, shareURL) {
            const modal = document.getElementById('share-branch-modal');
            const body = document.getElementById('share-branch-body');

            // Count edited nodes
            let totalNodes = 0;
            function countNodes(n) {
                totalNodes++;
                if (n.items) n.items.forEach(countNodes);
                if (n.subItems) n.subItems.forEach(countNodes);
                if (n.children) n.children.forEach(countNodes);
            }
            branch.nodes.forEach(countNodes);

            body.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #6366f1; margin-bottom: 20px;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #6366f1;">
                            <span>ðŸ“¤</span> Sending Back Your Edits
                        </div>
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 0;">
                            Send this link to the original author so they can merge your changes into their project.
                        </p>
                    </div>

                    <!-- Stats -->
                    <div style="display: flex; gap: 20px; font-size: 13px; color: var(--text-secondary); margin-bottom: 16px; padding: 12px; background: var(--card-bg); border-radius: 6px;">
                        <div>ðŸ“Š ${totalNodes} nodes</div>
                        <div>ðŸ“ ${shareURL.length.toLocaleString()} characters</div>
                        <div>ðŸ  Original: ${branch.sourceProjectName}</div>
                    </div>

                    <!-- URL Input -->
                    <div style="background: var(--card-bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 12px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="share-branch-url-input" readonly
                                   style="flex: 1; background: var(--card-bg); border: 1px solid var(--border); color: var(--text-primary); padding: 10px; border-radius: 6px; font-family: monospace; font-size: 11px; user-select: all;"
                                   value="${shareURL}">
                        </div>
                    </div>

                    <!-- Instructions -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #10b981;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #10b981;">
                            <span>âœ…</span> Next Steps
                        </div>
                        <ol style="margin-left: 20px; color: var(--text-secondary); font-size: 13px; line-height: 1.8;">
                            <li>Copy the URL or click "Open Email"</li>
                            <li>Send to the original author</li>
                            <li>They'll see your changes and can merge them</li>
                        </ol>
                    </div>
                </div>
            `;

            // Store for email button
            pendingShareBranch = branch;

            modal.style.display = 'flex';

            // Select URL
            setTimeout(() => {
                const urlInput = document.getElementById('share-branch-url-input');
                if (urlInput) urlInput.select();
            }, 100);
        }

        /**
         * Show merge modal for incoming edited branch
         * @param {object} branch - The edited branch to potentially merge
         */
        function showMergeBranchModal(branch) {
            const modal = document.getElementById('merge-branch-modal');
            const body = document.getElementById('merge-branch-body');

            // Check if current project matches the source project
            const projectMismatch = capexTree.id !== branch.sourceProjectId &&
                                    capexTree.name !== branch.sourceProjectName;

            // Store branch for later (needed if user loads correct project)
            pendingMergeBranch = branch;

            // If project doesn't match, show warning modal instead
            if (projectMismatch) {
                body.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.1)); padding: 20px; border-radius: 8px; border-left: 3px solid #ef4444; margin-bottom: 20px;">
                            <div style="font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; color: #ef4444; font-size: 16px;">
                                <span>âš ï¸</span> Wrong Project Loaded
                            </div>
                            <p style="color: var(--text-secondary); font-size: 14px; margin: 0 0 12px 0;">
                                This collaboration response was created from a different project. You need to load the original project first.
                            </p>
                        </div>

                        <!-- Project Comparison -->
                        <div style="background: var(--card-bg); padding: 15px; border-radius: 8px; margin-bottom: 16px;">
                            <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 16px; font-size: 13px;">
                                <span style="color: var(--text-secondary);">Expected project:</span>
                                <span style="font-weight: 600; color: #10b981;">"${branch.sourceProjectName}"</span>

                                <span style="color: var(--text-secondary);">Currently loaded:</span>
                                <span style="font-weight: 600; color: #ef4444;">"${capexTree.name}"</span>
                            </div>
                        </div>

                        <!-- Instructions -->
                        <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #6366f1;">
                            <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #6366f1;">
                                <span>ðŸ“‹</span> How to Merge
                            </div>
                            <ol style="margin-left: 20px; color: var(--text-secondary); font-size: 13px; line-height: 1.8;">
                                <li>Close this modal</li>
                                <li>Load the project <strong>"${branch.sourceProjectName}"</strong> (File â†’ Open JSON)</li>
                                <li>Open this URL again (or click the link in your email)</li>
                                <li>The merge will proceed correctly</li>
                            </ol>
                        </div>

                        <!-- Alternative: Force merge anyway -->
                        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
                            <p style="color: var(--text-secondary); font-size: 12px; margin-bottom: 8px;">
                                <strong>Alternative:</strong> If you want to add these nodes to the current project anyway, you can force the merge.
                                The nodes will be added but may not replace the originals.
                            </p>
                        </div>
                    </div>
                `;

                // Update buttons for mismatch state
                const acceptBtn = document.getElementById('merge-branch-accept');
                if (acceptBtn) {
                    acceptBtn.textContent = 'âš¡ Force Merge Anyway';
                    acceptBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                }

                modal.style.display = 'flex';
                return;
            }

            // Count nodes
            let totalNodes = 0;
            function countNodes(n) {
                totalNodes++;
                if (n.items) n.items.forEach(countNodes);
                if (n.subItems) n.subItems.forEach(countNodes);
                if (n.children) n.children.forEach(countNodes);
            }
            branch.nodes.forEach(countNodes);

            // Build ancestry breadcrumb
            const breadcrumb = branch.ancestry?.map(a =>
                `<span style="display: inline-flex; align-items: center; gap: 4px;">${a.icon || 'ðŸ“„'} ${a.name}</span>`
            ).join(' <span style="color: var(--text-secondary);">â€º</span> ') || 'Root';

            // Build node preview
            const nodePreview = branch.nodes.slice(0, 5).map(n => `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--card-bg); border-radius: 6px; margin-bottom: 6px;">
                    <span>${n.icon || 'ðŸ“„'}</span>
                    <span style="font-weight: 500;">${n.name}</span>
                    <span style="font-size: 11px; color: var(--text-secondary);">(${n.type})</span>
                </div>
            `).join('');

            body.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(217, 119, 6, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #f59e0b; margin-bottom: 20px;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #f59e0b;">
                            <span>ðŸ”€</span> Incoming Collaboration Changes
                        </div>
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 0;">
                            A collaborator has edited your shared branch and sent back changes for you to merge.
                        </p>
                    </div>

                    <!-- Branch Info -->
                    <div style="background: var(--card-bg); padding: 15px; border-radius: 8px; margin-bottom: 16px;">
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 16px; font-size: 13px;">
                            <span style="color: var(--text-secondary);">Original Location:</span>
                            <span>${breadcrumb}</span>

                            <span style="color: var(--text-secondary);">Edited by:</span>
                            <span style="font-family: monospace; font-size: 11px;">${branch.editedBy || 'Unknown'}</span>

                            <span style="color: var(--text-secondary);">Edited at:</span>
                            <span>${branch.editedAt ? new Date(branch.editedAt).toLocaleString() : 'Unknown'}</span>

                            <span style="color: var(--text-secondary);">Nodes:</span>
                            <span>${totalNodes} total</span>
                        </div>
                    </div>

                    <!-- Node Preview -->
                    <div style="margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            ðŸ“¦ Changed Nodes (preview):
                        </div>
                        <div style="max-height: 200px; overflow-y: auto; padding-right: 8px;">
                            ${nodePreview}
                            ${branch.nodes.length > 5 ? `<div style="color: var(--text-secondary); font-size: 12px; padding: 8px;">...and ${branch.nodes.length - 5} more</div>` : ''}
                        </div>
                    </div>

                    <!-- Warning -->
                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #ef4444;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #ef4444;">
                            <span>âš ï¸</span> Merge Warning
                        </div>
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 0;">
                            Merging will <strong>replace</strong> the original nodes at the specified location with the edited versions.
                            This action can be undone using Ctrl+Z.
                        </p>
                    </div>
                </div>
            `;

            // Reset button state (in case previous modal showed mismatch warning)
            const acceptBtn = document.getElementById('merge-branch-accept');
            if (acceptBtn) {
                acceptBtn.textContent = 'âœ… Accept & Merge Changes';
                acceptBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
            }

            modal.style.display = 'flex';
        }

        /**
         * Perform the actual merge of a branch into the tree
         * @param {object} branch - The branch to merge
         */
        function performBranchMerge(branch) {
            if (!branch || !branch.nodes || branch.nodes.length === 0) {
                console.error('âŒ Invalid branch for merge');
                return;
            }

            // Save undo state
            saveToHistory('Merge collaboration branch');

            // Find the insertion point using ancestry
            const ancestry = branch.ancestry || [];
            let insertionParent = capexTree;

            // Navigate to the parent location
            for (const ancestor of ancestry) {
                if (ancestor.id === capexTree.id) continue; // Skip root

                const found = findNodeInTree(insertionParent, ancestor.id);
                if (found) {
                    insertionParent = found;
                } else {
                    console.warn(`âš ï¸ Could not find ancestor ${ancestor.id}, merging at current level`);
                    break;
                }
            }

            // For each node in the branch, find and replace or add
            for (const incomingNode of branch.nodes) {
                const existingNode = findNodeInTree(capexTree, incomingNode.id);

                if (existingNode) {
                    // Replace existing node's data (preserve position in tree)
                    Object.assign(existingNode, incomingNode);
                    console.log(`âœ… Updated existing node: ${incomingNode.name}`);
                } else {
                    // Add as new node to insertion parent
                    if (incomingNode.type === 'phase') {
                        insertionParent.children = insertionParent.children || [];
                        insertionParent.children.push(incomingNode);
                    } else if (incomingNode.type === 'item') {
                        // Find appropriate phase or add to first phase
                        const targetPhase = insertionParent.children?.[0] || insertionParent;
                        targetPhase.items = targetPhase.items || [];
                        targetPhase.items.push(incomingNode);
                    } else {
                        // Subtask - find parent item
                        const parentItem = findParentForSubtask(capexTree, branch.selectedNodeIds);
                        if (parentItem) {
                            parentItem.subItems = parentItem.subItems || [];
                            parentItem.subItems.push(incomingNode);
                        }
                    }
                    console.log(`âž• Added new node: ${incomingNode.name}`);
                }
            }

            // Close modal
            document.getElementById('merge-branch-modal').style.display = 'none';
            pendingMergeBranch = null;

            // Clear URL parameter
            window.history.replaceState({}, document.title, window.location.pathname);

            // Re-render
            render();
            if (currentView === 'canvas') {
                renderCanvas();
            }

            // Show success toast
            showToast('âœ… Changes merged successfully!', 'success');

            console.log('ðŸ”€ Branch merge completed:', branch.branchId);
        }

        /**
         * Find a node in the tree by ID
         * @param {object} node - Starting node
         * @param {string} id - ID to find
         * @returns {object|null} Found node or null
         */
        function findNodeInTree(node, id) {
            if (node.id === id) return node;

            if (node.children) {
                for (const child of node.children) {
                    const found = findNodeInTree(child, id);
                    if (found) return found;
                }
            }
            if (node.items) {
                for (const item of node.items) {
                    const found = findNodeInTree(item, id);
                    if (found) return found;
                }
            }
            if (node.subItems) {
                for (const subItem of node.subItems) {
                    const found = findNodeInTree(subItem, id);
                    if (found) return found;
                }
            }

            return null;
        }

        /**
         * Find parent item for a subtask
         * @param {object} tree - Tree to search
         * @param {string[]} nodeIds - Original node IDs
         * @returns {object|null} Parent item or null
         */
        function findParentForSubtask(tree, nodeIds) {
            // Try to find based on original selection
            // For now, return first item in tree
            if (tree.children?.[0]?.items?.[0]) {
                return tree.children[0].items[0];
            }
            return null;
        }

        /**
         * Show a toast notification
         * @param {string} message - Message to show
         * @param {string} type - 'success', 'error', 'warning'
         */
        function showToast(message, type = 'success') {
            const colors = {
                success: 'linear-gradient(135deg, #10b981, #059669)',
                error: 'linear-gradient(135deg, #ef4444, #dc2626)',
                warning: 'linear-gradient(135deg, #f59e0b, #d97706)'
            };

            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: ${colors[type] || colors.success};
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10001;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            document.body.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        /**
         * Handle branch URL on page load
         * Called from the main URL loading function
         */
        function handleBranchURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const branchParam = urlParams.get('branch');

            if (!branchParam) return false;

            console.log('ðŸ”— Branch URL detected, parsing...');

            const branch = parseBranchFromURL(branchParam);
            if (!branch) {
                showToast('âŒ Invalid branch URL', 'error');
                return false;
            }

            // Determine if this is a response (edited branch) or original share
            if (branch.isResponse) {
                // This is an edited branch being sent back - show merge dialog
                console.log('ðŸ“¥ Received edited branch for merge');
                showMergeBranchModal(branch);
            } else if (isOriginalBranchCreator(branch)) {
                // Creator opened their own branch link - just show info
                showToast('â„¹ï¸ This is your own shared branch', 'warning');
            } else {
                // Collaborator opening branch to edit
                console.log('ðŸ¤ Collaborator opening branch for editing');
                enterBranchEditMode(branch);
            }

            return true;
        }

        // =============================================================================
        // END COLLABORATION
        // =============================================================================

        // Update tree preview - copy working tree to main tree and render in real-time
        function updateWizardPreview() {
            // Copy working tree to main tree
            capexTree = JSON.parse(JSON.stringify(wizardState.workingTree));

            // Render to show real-time updates on the left
            render();

            console.log('âœ… Tree updated in real-time:', {
                name: capexTree.name,
                phases: capexTree.children?.length || 0,
                items: capexTree.children?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0
            });

            return;

            const preview = document.getElementById('wizard-tree-preview');
            const tree = wizardState.workingTree;

            let html = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 10px; color: var(--treeplex-primary); border-bottom: 2px solid var(--treeplex-primary); padding-bottom: 8px;">
                ${tree.icon || 'ðŸŒ³'} ${tree.name || 'Untitled Project'}
            </div>`;

            if (tree.description) {
                html += `<div style="color: var(--text-secondary); margin-bottom: 20px; font-size: 13px; font-style: italic;">
                    ${tree.description}
                </div>`;
            }

            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    // Phase header with background
                    html += `<div style="margin-bottom: 20px; border-left: 3px solid var(--treeplex-primary); padding-left: 12px;">
                        <div style="font-weight: 600; font-size: 14px; color: var(--treeplex-primary); margin-bottom: 8px;">
                            ${phase.icon || 'ðŸ“‹'} ${phase.name}
                            ${phase.subtitle ? `<div style="color: var(--text-secondary); font-weight: 400; font-size: 12px; margin-top: 2px;">${phase.subtitle}</div>` : ''}
                        </div>`;

                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            // Item
                            html += `<div style="margin-left: 15px; margin-bottom: 10px; padding: 8px; background: var(--card-bg-light); border-radius: 6px;">
                                <div style="color: var(--text-primary); font-weight: 500; font-size: 13px;">
                                    ${item.icon || 'ðŸ“„'} ${item.name}
                                </div>`;

                            // Item description
                            if (item.description) {
                                html += `<div style="color: var(--text-secondary); font-size: 11px; margin-top: 4px; margin-left: 20px;">
                                    ${item.description}
                                </div>`;
                            }

                            // Dependencies (if present - for backward compatibility)
                            if (item.dependencies) {
                                // Handle both array and string formats
                                const depText = Array.isArray(item.dependencies)
                                    ? item.dependencies.join(', ')
                                    : item.dependencies;
                                if (depText && depText.length > 0) {
                                    html += `<div style="color: #f59e0b; font-size: 11px; margin-top: 4px; margin-left: 20px;">
                                        âš ï¸ Depends on: ${depText}
                                    </div>`;
                                }
                            }

                            // Subtasks
                            if (item.subtasks && item.subtasks.length > 0) {
                                html += `<div style="margin-left: 20px; margin-top: 6px;">`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    html += `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 3px;">
                                        â–¸ ${subtask.name}${subtask.description ? ': ' + subtask.description : ''}
                                    </div>`;
                                });
                                html += `</div>`;
                            }

                            html += `</div>`; // End item
                        });
                    }

                    html += `</div>`; // End phase
                });
            } else {
                html += `<div style="color: var(--text-secondary); text-align: center; margin-top: 40px; padding: 40px 20px; border: 2px dashed var(--border); border-radius: 8px;">
                    <div style="font-size: 24px; margin-bottom: 10px;">ðŸŒ±</div>
                    <div>Waiting for conversation to start building the tree...</div>
                </div>`;
            }

            preview.innerHTML = html;
        }

        // Finish wizard
        document.getElementById('wizard-done').addEventListener('click', () => {
            // Save state for undo
            saveState('AI Wizard: Apply changes');

            // Apply working tree to main tree (deep copy to prevent reference issues)
            capexTree = JSON.parse(JSON.stringify(wizardState.workingTree));
            currentPattern = wizardState.patternKey;

            // Close modal
            document.getElementById('wizard-modal').style.display = 'none';

            // Render updated tree
            render();

            console.log('ðŸª„ Wizard complete! Tree applied.');
        });

        // Cancel wizard
        document.getElementById('wizard-cancel').addEventListener('click', () => {
            if (confirm('Are you sure? Your progress will be lost.')) {
                document.getElementById('wizard-modal').style.display = 'none';
            }
        });

        // Auto-Enhance: Run AI Review then enhance tree automatically
        async function runAutoEnhance() {
            // Check if tree has content
            if (!hasExistingContent()) {
                alert('âš ï¸ Your tree is empty.\n\nPlease add some content first, then use Auto-Enhance.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            try {
                // Open wizard modal first
                document.getElementById('wizard-modal').style.display = 'flex';

                // Show loading state in wizard
                const chatHistory = document.getElementById('wizard-chat-history');
                chatHistory.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">ðŸ” Step 1/2: Analyzing your tree for improvements...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Using your preferred AI model for review</p>
                    </div>
                `;

                // Step 1: Run AI Review to get suggestions
                const pattern = PATTERNS[currentPattern];
                const tree = capexTree;
                const reviewPrompt = buildReviewPrompt(tree, pattern);

                // Get current AI mode (respect user's choice of Gemini or ChatGPT)
                const currentAIMode = document.getElementById('unified-ai-mode-select').value;

                // Use user's selected model for review
                const reviewExperts = {
                    philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments. Review for logical validity, premise strength, and dialectical completeness.',
                    sales: 'You are a sales strategist with 20 years of enterprise B2B experience. Review for pipeline health, deal qualification, and revenue optimization.',
                    thesis: 'You are an academic advisor helping graduate students structure rigorous research. Review for argument progression, citation quality, and scholarly standards.',
                    roadmap: 'You are a product manager experienced in agile development and feature prioritization. Review for execution readiness, story completeness, and technical feasibility.',
                    prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude, GPT-4, and other LLMs. Review for prompt clarity, few-shot example quality, output format specification, and edge case handling.',
                    book: 'You are a professional fiction editor and writing coach. Review for narrative flow, character development, and pacing.',
                    film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway). Review for visual storytelling, shot composition, and production feasibility.',
                    course: 'You are an instructional designer with expertise in curriculum development. Review for learning progression, assessment alignment, and instructional scaffolding.',
                    dialogue: 'You are a debate coach and rhetoric expert specializing in argumentation theory, logical fallacies, and persuasive communication. Review for argument strength, rhetorical effectiveness, fallacy identification, and evidence quality.',
                    generic: `You are an expert ${pattern.name} analyst. Review the provided tree structure for completeness, redundancies, logical flow, and alignment with ${pattern.name} best practices.`
                };

                const expertPersona = reviewExperts[currentPattern] || reviewExperts.generic;

                console.log(`ðŸ”„ Auto-Enhance: Running AI Review with ${currentAIMode}...`);

                const reviewResponse = await callClaudeAPI(
                    reviewPrompt,
                    expertPersona + ' Provide specific, actionable suggestions.',
                    4096,
                    false // No extended thinking for faster review
                );

                // Extract improvements section
                const improvements = extractSection(reviewResponse, 'IMPROVEMENTS');

                if (!improvements) {
                    alert('âŒ No improvements were suggested.\n\nYour tree appears complete!');
                    document.getElementById('wizard-modal').style.display = 'none';
                    return;
                }

                console.log('âœ… Got improvements:', improvements.substring(0, 200) + '...');

                // Step 2: Start wizard in enhance mode with improvements
                chatHistory.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">âœ¨ Step 2/2: Starting enhancement wizard...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Using Sonnet for high-quality enhancements</p>
                    </div>
                `;

                // Force Sonnet for wizard enhancements (better quality)
                const originalAIMode = currentAIMode;
                document.getElementById('unified-ai-mode-select').value = 'server-sonnet';

                // Start wizard in enhance mode
                await startWizard(true); // true = enhance mode

                // Restore original AI mode selection
                document.getElementById('unified-ai-mode-select').value = originalAIMode;

                // Automatically send improvements as first message
                setTimeout(() => {
                    const userInput = document.getElementById('wizard-user-input');
                    const sendBtn = document.getElementById('wizard-send');

                    userInput.value = improvements;
                    sendBtn.click();
                }, 500);

                console.log('ðŸ”„ Auto-Enhance workflow started successfully!');

            } catch (error) {
                console.error('âŒ Auto-Enhance error:', error);
                alert(`âŒ Auto-Enhance failed:\n\n${error.message}`);

                // Clear loading state and close modal
                document.getElementById('wizard-chat-history').innerHTML = '';
                document.getElementById('wizard-modal').style.display = 'none';
            }
        }

        // Toolbar button handler
        document.getElementById('auto-enhance-btn').addEventListener('click', runAutoEnhance);

        // Wizard footer button handler
        document.getElementById('wizard-auto-enhance').addEventListener('click', runAutoEnhance);

        // =============================================================================
        // GENERATE PROMPT SYSTEM
        // =============================================================================

        // Generate Prompt button
        document.getElementById('generate-prompt-btn').addEventListener('click', () => {
            const promptText = generatePromptFromTree();

            // Some patterns (like film) handle display asynchronously via style selectors
            // and return null - don't show modal in that case
            if (promptText !== null && promptText !== undefined) {
                document.getElementById('generated-prompt-text').value = promptText;
                document.getElementById('generate-prompt-modal').style.display = 'flex';
            }
            // If null, the pattern is handling its own display logic (e.g., style selector first)
        });

        // Close prompt modal
        document.getElementById('close-prompt-modal').addEventListener('click', () => {
            document.getElementById('generate-prompt-modal').style.display = 'none';
        });

        // Copy prompt to clipboard
        document.getElementById('copy-prompt-btn').addEventListener('click', async () => {
            const textArea = document.getElementById('generated-prompt-text');
            try {
                await navigator.clipboard.writeText(textArea.value);
                const successMsg = document.getElementById('copy-success-message');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                textArea.select();
                document.execCommand('copy');
                const successMsg = document.getElementById('copy-success-message');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            }
        });

        // Generate prompt from tree structure
        function generatePromptFromTree() {
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;
            const tree = capexTree;

            let prompt = '';

            // Header based on pattern
            if (currentPattern === 'prompting') {
                prompt += generateAIPromptDesignPrompt(tree, pattern);
            } else {
                prompt += generateGenericPrompt(tree, pattern);
            }

            return prompt;
        }

        // Generate EXECUTABLE AI Prompt (not meta-description)
        // Synthesizes tree into ONE complete, copy-paste ready prompt
        function generateAIPromptDesignPrompt(tree, pattern) {
            // Collect all items to synthesize into one unified prompt
            const allItems = [];
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach(item => {
                            allItems.push({ ...item, phaseName: phase.name });
                        });
                    }
                });
            }

            if (allItems.length === 0) {
                return `*No prompts defined yet. Add items to your tree.*\n`;
            }

            // Extract components from first item (primary prompt)
            const firstItem = allItems[0];
            const systemPrompts = allItems.map(item => item.systemPrompt).filter(sp => sp && sp.length > 0);
            const userTemplates = allItems.map(item => item.userPromptTemplate).filter(ut => ut && ut.length > 0);
            const exampleItems = allItems.filter(item => item.fewShotExamples && item.fewShotExamples.length > 0);
            const formatItems = allItems.filter(item => item.outputFormat && item.outputFormat.length > 0);
            const cotItems = allItems.filter(item => item.chainOfThought && item.chainOfThought.length > 0);
            const structuralItems = allItems.filter(item => item.structuralTags && item.structuralTags.length > 0);

            // Build CLEAN EXECUTABLE prompt (no meta-instructions, just the raw prompt)
            let actualPrompt = '';

            // Add system context at the top (like a system message)
            if (systemPrompts.length > 0) {
                actualPrompt += `${systemPrompts[0]}\n\n---\n\n`;
            }

            // Add the main user instruction
            if (userTemplates.length > 0) {
                actualPrompt += userTemplates[0];
            } else {
                actualPrompt += `${tree.description || tree.name}`;
            }

            // Add few-shot examples inline if present
            if (exampleItems.length > 0) {
                actualPrompt += `\n\nHere are examples of the expected behavior:\n\n`;
                actualPrompt += exampleItems[0].fewShotExamples;
            }

            // Add output format specification
            if (formatItems.length > 0) {
                actualPrompt += `\n\n${formatItems[0].outputFormat}`;
            }

            // Add chain-of-thought instructions
            if (cotItems.length > 0) {
                actualPrompt += `\n\n${cotItems[0].chainOfThought}`;
            }

            // Add structural tags if present (Anthropic XML patterns)
            if (structuralItems.length > 0) {
                actualPrompt += `\n\n${structuralItems[0].structuralTags}`;
            }

            // RETURN CLEAN PROMPT - Ready to paste directly into AI chat
            // No markdown, no explanations, no meta-instructions
            return actualPrompt;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 122: TWO-STYLE VIDEO PROMPT GENERATOR
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Feature: Generate AI video prompts in two styles:
        //   1. Explainer/Documentary - Clean, educational, logical
        //   2. Narrative/Story - Character-driven, emotional, hero's journey
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function generateAIVideoPrompts(tree, pattern, style = null) {
            // If no style specified, show style selector and return
            if (!style) {
                showVideoStyleSelector((selectedStyle) => {
                    const prompt = generateAIVideoPrompts(tree, pattern, selectedStyle);
                    // Show the prompt in the modal (consistent with other patterns)
                    document.getElementById('generated-prompt-text').value = prompt;
                    document.getElementById('generate-prompt-modal').style.display = 'flex';
                });
                return null; // Will be called again with style
            }

            // 1. Determine the 'Hero' of the story (for Narrative mode)
            const hero = findProjectHero(tree);

            let output = `# ${tree.icon || 'ðŸŽ¬'} ${tree.name || 'Video Production'}\n\n`;
            output += `**Style:** ${style === 'narrative' ? 'ðŸŽ­ Narrative / Story Mode' : 'ðŸ“Š Explainer / Documentary Mode'}\n`;
            output += `**Format:** Copy-paste ready for Sora / Veo / Runway\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Hero info for narrative mode
            if (style === 'narrative') {
                output += `**Hero:** ${hero}\n`;
                output += `**Story Arc:** Three-act structure following the project completion journey\n\n`;
            }

            output += `---\n\n`;

            // Process Phases/Acts
            if (tree.children && tree.children.length > 0) {
                let previousScene = null;

                tree.children.forEach((phase, phaseIdx) => {
                    // Map Phase to Story Act (for narrative)
                    const actLabel = getStoryActLabel(phaseIdx, tree.children.length);

                    output += `## ${phase.name}`;
                    if (style === 'narrative') {
                        output += ` (${actLabel})`;
                    } else {
                        output += ` (Phase ${phaseIdx + 1})`;
                    }
                    output += `\n\n`;

                    if (phase.subtitle || phase.description) {
                        output += `*${phase.subtitle || phase.description}*\n\n`;
                    }

                    // Process Items/Scenes
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            const sceneNumber = `${phaseIdx + 1}.${itemIdx + 1}`;

                            // Generate the prompt based on style
                            const promptText = style === 'narrative'
                                ? synthesizeNarrativePrompt(item, hero, actLabel, previousScene)
                                : synthesizeExplainerPrompt(item);

                            output += `### Scene ${sceneNumber}: ${item.name}\n\n`;
                            output += `**Platform:** ${item.aiPlatform || 'Sora (OpenAI)'}\n\n`;
                            output += `**Prompt:**\n\`\`\`\n${promptText}\n\`\`\`\n\n`;

                            // Technical specs
                            const specs = [];
                            if (item.duration) specs.push(`Duration: ${item.duration}`);
                            if (item.aspectRatio) specs.push(`Aspect: ${item.aspectRatio}`);
                            if (item.visualStyle) specs.push(`Style: ${item.visualStyle}`);
                            if (specs.length > 0) {
                                output += `**Tech:** ${specs.join(' â€¢ ')}\n\n`;
                            }

                            output += `---\n\n`;

                            // Store for continuity
                            previousScene = item;
                        });
                    }
                });
            }

            // Usage instructions
            output += `\n## ðŸ“‹ Usage Instructions\n\n`;
            output += `1. Copy the prompt text (inside the code block)\n`;
            output += `2. Paste into your AI video platform:\n`;
            output += `   - **Sora** (OpenAI): Best for photorealistic, cinematic shots\n`;
            output += `   - **Veo 3** (Google): Great for consistent styles, longer clips\n`;
            output += `   - **Runway Gen-3**: Fast iteration, good for prototyping\n`;
            output += `   - **Pika 2.0**: Stylized, artistic effects\n`;
            output += `3. Adjust technical settings (duration, aspect ratio) as specified\n`;
            output += `4. Generate and review results\n`;
            output += `5. Iterate: Use the Notes section to refine prompts\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ Pro Tip:** ${style === 'narrative'
                ? 'Narrative videos work best for marketing, storytelling, and emotional connection. Consider adding background music and voiceover narration!'
                : 'Explainer videos work best for investor presentations, team onboarding, and educational content. Keep pacing consistent and visuals clean!'
            }\n`;

            return output;
        }

        // Helper: Find the Hero (Main Character)
        function findProjectHero(tree) {
            // Strategy 1: Find most frequently assigned person
            const assignees = {};

            function traverseTree(node) {
                if (node.pmAssignee && node.pmAssignee !== 'Unassigned') {
                    assignees[node.pmAssignee] = (assignees[node.pmAssignee] || 0) + 1;
                }
                if (node.children) {
                    node.children.forEach(child => traverseTree(child));
                }
                if (node.items) {
                    node.items.forEach(item => traverseTree(item));
                }
                if (node.subItems || node.subtasks) {
                    (node.subItems || node.subtasks).forEach(sub => traverseTree(sub));
                }
            }

            traverseTree(tree);

            // Return most frequent assignee
            const sorted = Object.entries(assignees).sort((a, b) => b[1] - a[1]);
            if (sorted.length > 0) return sorted[0][0];

            // Strategy 2: Extract name from descriptions
            function getAllText(node) {
                let text = (node.name || '') + ' ' + (node.description || '');
                if (node.children) {
                    node.children.forEach(child => text += ' ' + getAllText(child));
                }
                if (node.items) {
                    node.items.forEach(item => text += ' ' + getAllText(item));
                }
                return text;
            }

            const allText = getAllText(tree);
            const nameMatch = allText.match(/\b([A-Z][a-z]+ [A-Z][a-z]+)\b/);
            if (nameMatch) return nameMatch[1];

            // Strategy 3: Use tree owner or default
            return tree.owner || tree.createdBy || "The Project Lead";
        }

        // Helper: Map Phases to Story Acts
        function getStoryActLabel(index, total) {
            if (total <= 1) return "The Journey";
            const position = index / (total - 1);
            if (position < 0.4) return "Act I: The Challenge";
            if (position < 0.75) return "Act II: The Struggle";
            return "Act III: The Triumph";
        }

        // Style 1: Explainer / Documentary
        function synthesizeExplainerPrompt(item) {
            const visualSubject = item.name;
            const details = item.description || "Project details";

            // Financial context
            let financialGraphic = "";
            if (item.cost) {
                const costM = (item.cost / 1000000).toFixed(1);
                financialGraphic = `Budget graphic showing $${costM}M overlaid on screen.`;
            } else if (item.dealValue) {
                const valueM = (item.dealValue / 1000000).toFixed(1);
                financialGraphic = `Deal value of $${valueM}M displayed as infographic.`;
            } else if (item.investment) {
                const investM = (item.investment / 1000000).toFixed(1);
                financialGraphic = `Investment: $${investM}M shown in clean typography.`;
            }

            // Timeline context
            let timelineGraphic = "";
            if (item.leadTime) {
                timelineGraphic = `Timeline graphic animating: ${item.leadTime}.`;
            } else if (item.engineeringEstimate) {
                timelineGraphic = `Duration overlay: ${item.engineeringEstimate}.`;
            } else if (item.duration) {
                timelineGraphic = `Timeline: ${item.duration}.`;
            }

            // Location/Setting
            let setting = "Modern office environment or construction site";
            if (item.location) {
                setting = item.location;
            } else if (details.toLowerCase().includes('office')) {
                setting = "Modern glass office with city view";
            } else if (details.toLowerCase().includes('site') || details.toLowerCase().includes('land')) {
                setting = "Construction site or development location";
            } else if (details.toLowerCase().includes('lab') || details.toLowerCase().includes('research')) {
                setting = "Clean research laboratory";
            }

            return `Style: High-end Corporate Documentary. Photorealistic. 8k resolution.
Shot: Slow tracking shot or aerial drone view establishing the scope.
Subject: ${visualSubject}.
Action: ${details}. The visualization builds itself on screen with clean architectural lines.
Overlay Graphics: ${financialGraphic} ${timelineGraphic}
Setting: ${setting}.
Lighting: Bright, clean, clinical, "Apple store" aesthetic with soft shadows.
Mood: Competent, organized, futuristic, inspiring confidence.
Camera: Steady, professional gimbal movement. Wide to medium shots.`;
        }

        // Style 2: Narrative / Story
        function synthesizeNarrativePrompt(item, hero, act, previousScene) {
            const action = item.description || "working on the task";

            // Get dynamic mood based on context
            const moodData = getNarrativeMood(item, act);
            const mood = moodData.mood;
            const lighting = moodData.lighting;

            // Get appropriate setting
            const setting = getNarrativeSetting(item, act);

            // Emotional stakes
            const stakes = getEmotionalStakes(item);

            // Continuity from previous scene
            let continuity = "";
            if (previousScene) {
                continuity = `\nContinuity: Previous scene: "${previousScene.name}". This scene shows the consequence/progress of that action.`;
            }

            // Character details
            const characterDesc = `${hero} (30s-40s, professional, determined expression)`;

            return `Style: Cinematic Movie Scene. Anamorphic lens. Film grain.
Character: ${characterDesc}
Setting: ${setting}
Action: ${hero} is ${action}. ${mood}. ${stakes}${continuity}
Detail: Close-up on ${hero}'s face showing ${getEmotionalExpression(mood)}. Show determination and professionalism.
Lighting: ${lighting}. Cinematic contrast with dramatic shadows.
Mood: ${mood}. High stakes atmosphere.
Camera: Dynamic - Start wide, dolly in to close-up, or handheld for intensity.`;
        }

        // Helper: Dynamic Mood Detection
        function getNarrativeMood(item, act) {
            let mood = "Determined and focused";
            let lighting = "Natural daylight through windows";

            // Act-based default
            if (act.includes("Challenge")) {
                mood = "Optimistic but focused, ready to take on the world";
                lighting = "Morning sun streaming through windows, golden and hopeful";
            } else if (act.includes("Struggle")) {
                mood = "Stressed, high stakes, late night problem-solving";
                lighting = "Dark office, blue screen glow, single desk lamp, shadows";
            } else if (act.includes("Triumph")) {
                mood = "Relieved, celebratory, breakthrough moment";
                lighting = "Golden hour, warm sunset, victorious warm tones";
            }

            // Override with cost/value signals (high stakes)
            const monetaryValue = item.cost || item.dealValue || item.investment || 0;
            if (monetaryValue > 10000000) {
                mood = "Extreme pressure, multi-million dollar stakes, intense focus";
                lighting = "Dramatic boardroom lighting, spotlight effect, high contrast";
            } else if (monetaryValue > 5000000) {
                mood = "High pressure, massive responsibility, calculated decisions";
                lighting = "Serious office lighting, professional intensity";
            }

            // Override with status signals (crisis)
            if (item.pmStatus === 'Blocked' || item.pmBlockingIssue) {
                mood = "Crisis mode, urgent problem-solving, racing against time";
                lighting = "Harsh fluorescent, emergency meeting, red alert tones";
            }

            // Override with risk signals
            if (item.technicalRisk === 'High' || item.riskLevel === 'high') {
                mood = "Cautious, careful analysis, aware of dangers";
                lighting = "Moody, dramatic shadows, tension in the frame";
            }

            // Dependencies = coordination stress
            if (item.dependencies && item.dependencies.length > 3) {
                mood = "Coordination stress, juggling multiple priorities, multitasking energy";
            }

            return { mood, lighting };
        }

        // Helper: Setting Detection
        function getNarrativeSetting(item, act) {
            // Check if explicit setting exists
            if (item.location) return item.location;
            if (item.sceneSetting) return item.sceneSetting;

            // Infer from description
            const desc = (item.name + ' ' + (item.description || '')).toLowerCase();

            if (desc.includes('site') || desc.includes('construction') || desc.includes('land')) {
                return "Active construction site, equipment in background, dirt and machinery";
            }
            if (desc.includes('office') || desc.includes('meeting')) {
                return "Modern glass office, city skyline visible, professional environment";
            }
            if (desc.includes('lab') || desc.includes('research')) {
                return "Clean research laboratory, high-tech equipment, sterile environment";
            }
            if (desc.includes('field') || desc.includes('outdoor')) {
                return "Outdoor location, natural environment, sky visible";
            }

            // Default based on act
            if (act.includes("Challenge")) {
                return "Modern office conference room, early morning, project plans visible";
            } else if (act.includes("Struggle")) {
                return "Office late at night, desks cluttered with documents, pressure visible";
            } else if (act.includes("Triumph")) {
                return "Office or construction site, celebrating success, relieved atmosphere";
            }

            return "Professional office or work environment";
        }

        // Helper: Emotional Stakes
        function getEmotionalStakes(item) {
            const monetaryValue = item.cost || item.dealValue || item.investment || 0;
            const timeline = item.leadTime || item.engineeringEstimate || item.duration || "";

            if (monetaryValue > 5000000) {
                return `Career-defining moment. Millions on the line.`;
            }
            if (monetaryValue > 1000000) {
                return `Major project milestone. Success matters.`;
            }
            if (timeline.includes('month') && parseInt(timeline) < 6) {
                return `Tight deadline. Time pressure evident.`;
            }
            if (item.dependencies && item.dependencies.length > 2) {
                return `Complex dependencies. Everything must align.`;
            }

            return `Professional commitment. Doing this right matters.`;
        }

        // Helper: Emotional Expression
        function getEmotionalExpression(mood) {
            if (mood.includes("Optimistic")) return "hope mixed with determination";
            if (mood.includes("Stressed") || mood.includes("Crisis")) return "stress and urgent focus";
            if (mood.includes("Relieved") || mood.includes("celebratory")) return "relief and satisfaction";
            if (mood.includes("pressure")) return "intense concentration under pressure";
            if (mood.includes("Cautious")) return "careful calculation and wariness";
            return "professional determination and focus";
        }

        // UI: Style Selector Modal
        function showVideoStyleSelector(callback) {
            // Remove any existing modal
            const existingModal = document.querySelector('.video-style-modal');
            if (existingModal) existingModal.remove();

            const modalHTML = `
                <div class="modal-overlay video-style-modal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.85);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                ">
                    <div class="modal-content" style="
                        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                        border-radius: 16px;
                        padding: 32px;
                        max-width: 800px;
                        width: 90%;
                        color: #e4e4e7;
                        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
                    ">
                        <h2 style="
                            font-size: 28px;
                            margin-bottom: 8px;
                            background: linear-gradient(135deg, #60a5fa, #a78bfa);
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                            background-clip: text;
                        ">ðŸŽ¬ Choose Video Style</h2>

                        <p style="color: #9ca3af; margin-bottom: 24px; font-size: 14px;">
                            Generate AI video prompts in two different styles. Same project data, different storytelling approaches.
                        </p>

                        <div class="style-options" style="
                            display: grid;
                            grid-template-columns: 1fr 1fr;
                            gap: 20px;
                            margin-bottom: 24px;
                        ">
                            <div class="style-card" data-style="explainer" style="
                                background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                                border-radius: 12px;
                                padding: 24px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                border: 2px solid transparent;
                            ">
                                <div class="style-icon" style="font-size: 48px; margin-bottom: 12px;">ðŸ“Š</div>
                                <h3 style="font-size: 18px; margin-bottom: 12px; color: #fff;">Explainer / Documentary</h3>
                                <p style="font-size: 13px; margin-bottom: 16px; color: #dbeafe; line-height: 1.5;">
                                    Clean, professional, educational. Shows the project plan logically step-by-step.
                                </p>
                                <ul style="font-size: 12px; color: #dbeafe; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 6px;">âœ… Investor presentations</li>
                                    <li style="margin-bottom: 6px;">âœ… Team onboarding</li>
                                    <li style="margin-bottom: 6px;">âœ… Status updates</li>
                                    <li>âœ… Educational content</li>
                                </ul>
                            </div>

                            <div class="style-card" data-style="narrative" style="
                                background: linear-gradient(135deg, #8b5cf6, #6d28d9);
                                border-radius: 12px;
                                padding: 24px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                border: 2px solid transparent;
                            ">
                                <div class="style-icon" style="font-size: 48px; margin-bottom: 12px;">ðŸŽ­</div>
                                <h3 style="font-size: 18px; margin-bottom: 12px; color: #fff;">Narrative / Story</h3>
                                <p style="font-size: 13px; margin-bottom: 16px; color: #ede9fe; line-height: 1.5;">
                                    Character-driven drama. Shows someone completing the project successfully with emotional stakes.
                                </p>
                                <ul style="font-size: 12px; color: #ede9fe; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 6px;">âœ… Marketing videos</li>
                                    <li style="margin-bottom: 6px;">âœ… Hero's journey arc</li>
                                    <li style="margin-bottom: 6px;">âœ… Emotional storytelling</li>
                                    <li>âœ… Brand building</li>
                                </ul>
                            </div>
                        </div>

                        <p style="
                            text-align: center;
                            color: #60a5fa;
                            font-size: 13px;
                            margin-bottom: 16px;
                        ">ðŸ’¡ Tip: Both styles use the same project data</p>

                        <button class="modal-cancel" style="
                            width: 100%;
                            padding: 12px;
                            background: #374151;
                            color: #e4e4e7;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            transition: all 0.2s;
                        ">Cancel</button>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // Add hover effects
            const styleCards = document.querySelectorAll('.style-card');
            styleCards.forEach(card => {
                card.addEventListener('mouseenter', () => {
                    card.style.transform = 'scale(1.05)';
                    card.style.borderColor = '#60a5fa';
                    card.style.boxShadow = '0 10px 30px rgba(96, 165, 250, 0.3)';
                });
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'scale(1)';
                    card.style.borderColor = 'transparent';
                    card.style.boxShadow = 'none';
                });

                // Click handler
                card.addEventListener('click', () => {
                    const style = card.dataset.style;
                    document.querySelector('.video-style-modal').remove();
                    callback(style);
                });
            });

            // Cancel button
            document.querySelector('.modal-cancel').addEventListener('click', () => {
                document.querySelector('.video-style-modal').remove();
            });

            // Click outside to close
            document.querySelector('.video-style-modal').addEventListener('click', (e) => {
                if (e.target.classList.contains('video-style-modal')) {
                    document.querySelector('.video-style-modal').remove();
                }
            });
        }

        // UI: Display Generated Prompt
        function displayGeneratedPrompt(prompt, title) {
            // Copy to clipboard
            navigator.clipboard.writeText(prompt).then(() => {
                showNotification(`âœ… ${title} - Prompt copied to clipboard!`);
            }).catch(() => {
                // Fallback: show in console if clipboard fails
                console.log('=== GENERATED PROMPT ===');
                console.log(prompt);
                showNotification(`âœ… ${title} - See console for prompt`);
            });
        }

        // Synthesize all video fields into one cohesive professional prompt
        // Based on Sora/Veo3 best practices: comprehensive, detailed, cinematographic
        function synthesizeVideoPrompt(item) {
            let sections = [];

            // SECTION 1: CORE SCENE DESCRIPTION
            let sceneDesc = '';
            if (item.videoPrompt) {
                sceneDesc = item.videoPrompt;
            } else if (item.description) {
                sceneDesc = item.description;
            } else {
                sceneDesc = item.name;
            }
            sections.push(sceneDesc);

            // SECTION 2: CAMERA SPECIFICATIONS
            const cameraSpecs = [];

            // Camera movement (critical for Sora/Veo3)
            if (item.cameraMovement && item.cameraMovement !== 'Static') {
                const movement = item.cameraMovement.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(movement)) {
                    cameraSpecs.push(`${movement} camera`);
                }
            } else if (!sceneDesc.toLowerCase().includes('camera')) {
                cameraSpecs.push('static camera');
            }

            // Motion intensity affects pacing
            if (item.motionIntensity) {
                const intensity = item.motionIntensity.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(intensity) && !sceneDesc.toLowerCase().includes('motion')) {
                    cameraSpecs.push(`${intensity} motion`);
                }
            }

            if (cameraSpecs.length > 0) {
                sections.push(cameraSpecs.join(', '));
            }

            // SECTION 3: LIGHTING & ATMOSPHERE
            const lightingDetails = [];

            if (item.lightingMood) {
                const mood = item.lightingMood.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(mood) && !sceneDesc.toLowerCase().includes('light')) {
                    lightingDetails.push(`${mood} lighting`);
                }
            }

            // Visual style affects overall aesthetic
            if (item.visualStyle && item.visualStyle !== 'Photorealistic') {
                const style = item.visualStyle.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(style)) {
                    lightingDetails.push(`${style} aesthetic`);
                }
            }

            if (lightingDetails.length > 0) {
                sections.push(lightingDetails.join(', '));
            }

            // SECTION 4: TECHNICAL FORMAT (professional cinematography language)
            const technicalDetails = [];

            // Aspect ratio implies framing
            if (item.aspectRatio) {
                const ratio = item.aspectRatio;
                if (ratio.includes('16:9')) {
                    if (!sceneDesc.toLowerCase().includes('widescreen') && !sceneDesc.toLowerCase().includes('cinematic')) {
                        technicalDetails.push('widescreen composition');
                    }
                } else if (ratio.includes('9:16')) {
                    if (!sceneDesc.toLowerCase().includes('vertical')) {
                        technicalDetails.push('vertical framing');
                    }
                } else if (ratio.includes('2.39')) {
                    if (!sceneDesc.toLowerCase().includes('cinematic')) {
                        technicalDetails.push('anamorphic widescreen');
                    }
                }
            }

            if (technicalDetails.length > 0) {
                sections.push(technicalDetails.join(', '));
            }

            // SYNTHESIZE: Build comprehensive prompt
            let finalPrompt = sections.filter(s => s && s.length > 0).join('. ');

            // Ensure professional formatting
            if (!finalPrompt.endsWith('.') && !finalPrompt.endsWith('!') && !finalPrompt.endsWith('?')) {
                finalPrompt += '.';
            }

            // QUALITY CHECK: Professional prompts should be detailed (100+ chars minimum)
            // If still too short, add generic cinematography guidance
            if (finalPrompt.length < 100) {
                const defaultEnhancements = [];

                if (!finalPrompt.toLowerCase().includes('focus')) {
                    defaultEnhancements.push('sharp focus on subject');
                }

                if (!finalPrompt.toLowerCase().includes('detail')) {
                    defaultEnhancements.push('high attention to detail');
                }

                if (item.duration && item.duration.includes('seconds')) {
                    const seconds = item.duration.match(/\d+/)?.[0];
                    if (seconds) {
                        defaultEnhancements.push(`${seconds}-second clip`);
                    }
                }

                if (defaultEnhancements.length > 0) {
                    finalPrompt += ` ${defaultEnhancements.join(', ')}.`;
                }
            }

            return finalPrompt;
        }

        // Generate Product Roadmap prompt (sprint-ready, execution-focused)
        function generateRoadmapPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸš€'} ${tree.name || 'Product Roadmap'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate roadmap metrics
            let totalStoryPoints = 0;
            let highImpactFeatures = 0;
            let highRiskFeatures = 0;
            let totalFeatures = 0;
            const quarterMetrics = [];

            if (tree.children) {
                tree.children.forEach(quarter => {
                    if (quarter.type === 'phase' && quarter.items) {
                        let quarterPoints = 0;
                        let quarterHighImpact = 0;
                        let quarterHighRisk = 0;

                        quarter.items.forEach(feature => {
                            quarterPoints += feature.storyPoints || 0;
                            if (feature.userImpact === 'High' || feature.userImpact === 'Critical') {
                                quarterHighImpact++;
                            }
                            if (feature.technicalRisk === 'High') {
                                quarterHighRisk++;
                            }
                        });

                        quarterMetrics.push({
                            name: quarter.name || `Quarter ${quarter.phase + 1}`,
                            subtitle: quarter.subtitle,
                            features: quarter.items.length,
                            points: quarterPoints,
                            highImpact: quarterHighImpact,
                            highRisk: quarterHighRisk
                        });

                        totalStoryPoints += quarterPoints;
                        totalFeatures += quarter.items.length;
                        highImpactFeatures += quarterHighImpact;
                        highRiskFeatures += quarterHighRisk;
                    }
                });
            }

            // Roadmap Summary
            output += `## ðŸ“Š Roadmap Summary\n\n`;
            output += `**Delivery Capacity:**\n`;
            output += `- Total Features: ${totalFeatures}\n`;
            output += `- Total Story Points: ${totalStoryPoints}\n`;
            output += `- Average Feature Size: ${Math.round(totalStoryPoints / totalFeatures)} points\n`;
            output += `- High-Impact Features: ${highImpactFeatures} (${Math.round(highImpactFeatures / totalFeatures * 100)}%)\n`;
            output += `- High-Risk Features: ${highRiskFeatures} (${Math.round(highRiskFeatures / totalFeatures * 100)}%)\n\n`;

            // Quarterly Planning
            output += `## ðŸ“… Quarterly Planning\n\n`;
            quarterMetrics.forEach((q, idx) => {
                output += `### ${q.name}${q.subtitle ? ` â€” ${q.subtitle}` : ''}\n`;
                output += `- Features: ${q.features} (${q.points} story points)\n`;
                output += `- Velocity Target: ${Math.round(q.points / 6)} points/sprint (6 sprints)\n`;
                output += `- High Impact: ${q.highImpact} features\n`;
                output += `- High Risk: ${q.highRisk} features (${q.highRisk > 0 ? 'requires spike work' : 'low risk quarter'})\n\n`;
            });

            // Feature Details
            output += `---\n\n## ðŸš€ Feature Specifications\n\n`;

            if (tree.children) {
                tree.children.forEach((quarter, qIdx) => {
                    if (quarter.type === 'phase' && quarter.items && quarter.items.length > 0) {
                        output += `### ${quarter.name || `Quarter ${qIdx + 1}`}\n\n`;

                        quarter.items.forEach((feature, fIdx) => {
                            const storyPoints = feature.storyPoints || 0;
                            const userImpact = feature.userImpact || 'Medium';
                            const techRisk = feature.technicalRisk || 'Medium';

                            // Impact/Risk emoji indicators
                            const impactEmoji = userImpact === 'Critical' ? 'ðŸ”¥' : userImpact === 'High' ? 'âš¡' : userImpact === 'Medium' ? 'ðŸ“Š' : 'ðŸ“‰';
                            const riskEmoji = techRisk === 'High' ? 'âš ï¸' : techRisk === 'Medium' ? 'âš¡' : 'âœ…';

                            output += `#### ${fIdx + 1}. ${feature.name}\n\n`;

                            // Feature card
                            output += `**Feature Overview:**\n`;
                            output += `- ${impactEmoji} User Impact: ${userImpact}\n`;
                            output += `- ${riskEmoji} Technical Risk: ${techRisk}\n`;
                            output += `- ðŸ“ Story Points: ${storyPoints} (${Math.ceil(storyPoints / 3)} sprints)\n`;
                            if (feature.engineeringEstimate) {
                                output += `- â±ï¸ Engineering Estimate: ${feature.engineeringEstimate}\n`;
                            }
                            if (feature.featureFlag) {
                                output += `- ðŸš© Feature Flag: \`${feature.featureFlag}\`\n`;
                            }
                            output += `\n`;

                            if (feature.description) {
                                output += `**What it does:**\n${feature.description}\n\n`;
                            }

                            // Implementation tasks
                            if (feature.children && feature.children.length > 0) {
                                output += `**Implementation Tasks:**\n`;
                                feature.children.forEach((task, tIdx) => {
                                    output += `${tIdx + 1}. ${task.name}`;
                                    if (task.storyPoints) {
                                        output += ` (${task.storyPoints} pts)`;
                                    }
                                    output += `\n`;
                                    if (task.description) {
                                        output += `   ${task.description}\n`;
                                    }
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (feature.dependencies && feature.dependencies.length > 0) {
                                output += `**âš ï¸ Blocking Dependencies:** ${feature.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Execution Recommendations
            output += `## âš¡ Execution Recommendations\n\n`;
            output += `**Sprint Planning:**\n`;
            const avgVelocity = Math.round(totalStoryPoints / (quarterMetrics.length * 6)); // Assume 6 sprints per quarter
            output += `- Target Velocity: ${avgVelocity} story points per sprint\n`;
            output += `- High-risk features: Start with spike/POC stories (1-2 sprints)\n`;
            output += `- Critical user impact: Prioritize for early quarters\n`;
            output += `- Feature flags: Use for all features >5 story points\n\n`;

            output += `**Risk Mitigation:**\n`;
            output += `1. Technical Spikes: Create 2-point spike stories for high-risk features\n`;
            output += `2. Dependency Management: Resolve blocking dependencies 1 sprint ahead\n`;
            output += `3. Incremental Delivery: Break large features (>8 points) into smaller releases\n`;
            output += `4. User Validation: Beta test high-impact features before GA\n`;
            output += `5. Monitoring: Set up dashboards and alerts for each feature flag\n\n`;

            output += `**Release Strategy:**\n`;
            output += `- Feature Flags: All features behind flags for safe rollout\n`;
            output += `- Phased Rollout: 10% â†’ 50% â†’ 100% over 2 weeks\n`;
            output += `- Rollback Plan: Document rollback procedures in each PR\n`;
            output += `- Success Metrics: Define KPIs before development starts\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ AI Prompt Usage - Actionable Deliverables:**\n`;
            output += `\n`;
            output += `**For Product Managers:**\n`;
            output += `- "Generate PRD (Product Requirements Document) for [feature name]"\n`;
            output += `- "Create user stories with acceptance criteria for [feature]"\n`;
            output += `- "Write launch email announcing [feature] to customers"\n`;
            output += `- "Design A/B test plan to validate [feature] impact"\n\n`;
            output += `**For Engineering:**\n`;
            output += `- "Create technical design doc for [feature] with architecture diagrams"\n`;
            output += `- "Write API specification (OpenAPI/Swagger) for [feature] endpoints"\n`;
            output += `- "Generate test plan covering happy path, edge cases, and error scenarios"\n`;
            output += `- "Draft database migration script for [feature] schema changes"\n\n`;
            output += `**For Research:**\n`;
            output += `- "Find 3 competitor implementations of [feature] with screenshots"\n`;
            output += `- "Research best practices for [feature type] in SaaS applications"\n`;
            output += `- "Identify potential technical challenges for [feature] implementation"\n\n`;

            return output;
        }

        // Generate Book/Novel prompt (manuscript-ready, narrative-focused)
        function generateBookPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸ“š'} ${tree.name || 'Book Manuscript'}\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Calculate manuscript metrics
            let totalWordCount = 0;
            let targetWordCount = 0;
            let totalChapters = 0;
            const chapterMetrics = [];

            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.type === 'phase' && chapter.items) {
                        let chapterWords = 0;
                        let chapterTarget = 0;
                        let sceneCount = chapter.items.length;

                        chapter.items.forEach(scene => {
                            chapterWords += scene.wordCount || 0;
                            chapterTarget += scene.targetWordCount || 0;
                        });

                        chapterMetrics.push({
                            name: chapter.name || `Chapter ${chapter.phase + 1}`,
                            subtitle: chapter.subtitle,
                            current: chapterWords,
                            target: chapterTarget,
                            scenes: sceneCount,
                            progress: chapterTarget > 0 ? Math.round((chapterWords / chapterTarget) * 100) : 0
                        });

                        totalWordCount += chapterWords;
                        targetWordCount += chapterTarget;
                        totalChapters++;
                    }
                });
            }

            const overallProgress = targetWordCount > 0 ? Math.round((totalWordCount / targetWordCount) * 100) : 0;

            // Manuscript Overview
            output += `## ðŸ“– Manuscript Overview\n\n`;
            output += `**Writing Progress:**\n`;
            output += `- Current Length: ${totalWordCount.toLocaleString()} words\n`;
            output += `- Target Length: ${targetWordCount.toLocaleString()} words\n`;
            output += `- Completion: ${overallProgress}% ${overallProgress < 50 ? '(First Draft)' : overallProgress < 80 ? '(Revision Stage)' : '(Near Final)'}\n`;
            output += `- Structure: ${totalChapters} chapters\n`;
            output += `- Average Chapter: ${Math.round(totalWordCount / totalChapters).toLocaleString()} words\n\n`;

            // Story Arc Analysis
            output += `## ðŸŽ­ Story Arc Structure\n\n`;
            chapterMetrics.forEach((ch, idx) => {
                const position = idx / (totalChapters - 1);
                let arcStage = '';
                if (position < 0.25) arcStage = 'ðŸ“ Setup/Exposition';
                else if (position < 0.5) arcStage = 'â¬†ï¸ Rising Action';
                else if (position < 0.75) arcStage = 'ðŸ”¥ Climax/Conflict';
                else arcStage = 'â¬‡ï¸ Falling Action/Resolution';

                const progressBar = 'â–ˆ'.repeat(Math.floor(ch.progress / 10)) + 'â–‘'.repeat(10 - Math.floor(ch.progress / 10));
                output += `### ${ch.name} ${arcStage}\n`;
                output += `- Progress: [${progressBar}] ${ch.progress}%\n`;
                output += `- Word Count: ${ch.current.toLocaleString()} / ${ch.target.toLocaleString()} words\n`;
                output += `- Scenes: ${ch.scenes}\n\n`;
            });

            // Scene Breakdown
            output += `---\n\n## ðŸ“ Scene-by-Scene Breakdown\n\n`;

            if (tree.children) {
                tree.children.forEach((chapter, chIdx) => {
                    if (chapter.type === 'phase' && chapter.items && chapter.items.length > 0) {
                        output += `### ${chapter.name || `Chapter ${chIdx + 1}`}${chapter.subtitle ? ` â€” ${chapter.subtitle}` : ''}\n\n`;

                        chapter.items.forEach((scene, sIdx) => {
                            output += `#### Scene ${sIdx + 1}: ${scene.name}\n\n`;

                            // Scene metadata
                            const sceneMetadata = [];
                            if (scene.povCharacter) sceneMetadata.push(`**POV:** ${scene.povCharacter}`);
                            if (scene.sceneSetting) sceneMetadata.push(`**Setting:** ${scene.sceneSetting}`);
                            if (scene.plotFunction) sceneMetadata.push(`**Plot Function:** ${scene.plotFunction}`);

                            if (sceneMetadata.length > 0) {
                                output += sceneMetadata.join(' â€¢ ') + '\n\n';
                            }

                            // Scene description
                            if (scene.description) {
                                output += `**What Happens:**\n${scene.description}\n\n`;
                            }

                            // Writing progress
                            if (scene.wordCount !== undefined || scene.targetWordCount) {
                                const sceneProgress = scene.targetWordCount > 0 ? Math.round((scene.wordCount || 0) / scene.targetWordCount * 100) : 0;
                                output += `**Writing Status:** ${scene.wordCount || 0} words (${sceneProgress}% of ${scene.targetWordCount || '?'} target)`;
                                if (scene.draftStatus) {
                                    output += ` â€” ${scene.draftStatus}`;
                                }
                                output += `\n\n`;
                            }

                            // Beats/moments within scene
                            if (scene.children && scene.children.length > 0) {
                                output += `**Story Beats:**\n`;
                                scene.children.forEach((beat, bIdx) => {
                                    output += `${bIdx + 1}. ${beat.name}`;
                                    if (beat.description) {
                                        output += ` â€” ${beat.description}`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Writing Recommendations
            output += `## âœï¸ Writing Strategy & Next Steps\n\n`;
            output += `**Manuscript Status:**\n`;
            if (overallProgress < 50) {
                output += `- Stage: First Draft â€” focus on completing story structure\n`;
                output += `- Priority: Write forward, don't revise yet\n`;
                output += `- Goal: Reach "The End" before editing\n\n`;
            } else if (overallProgress < 80) {
                output += `- Stage: Revision â€” deepen character arcs and pacing\n`;
                output += `- Priority: Address plot holes and character motivation\n`;
                output += `- Goal: Complete second draft with all scenes polished\n\n`;
            } else {
                output += `- Stage: Final Polish â€” line edits and beta feedback\n`;
                output += `- Priority: Professional editing and proofreading\n`;
                output += `- Goal: Query-ready or publish-ready manuscript\n\n`;
            }

            output += `**Story Development Checklist:**\n`;
            output += `1. Character Arcs: Do all major characters change/grow?\n`;
            output += `2. Plot Coherence: Are there any unresolved threads?\n`;
            output += `3. Pacing: Does each scene advance plot or deepen character?\n`;
            output += `4. Setting: Is the world vivid and consistent?\n`;
            output += `5. Theme: Are thematic elements woven throughout?\n\n`;

            output += `**Scene-Level Quality:**\n`;
            output += `- Each scene should have: Goal, Conflict, Disaster (or Resolution)\n`;
            output += `- POV consistency within chapters\n`;
            output += `- Vary scene length for pacing (long for tension, short for action)\n`;
            output += `- End chapters with hooks to keep readers engaged\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ AI Prompt Usage - Manuscript Deliverables:**\n`;
            output += `\n`;
            output += `**For Drafting:**\n`;
            output += `- "Write a 1000-word opening scene for [chapter] from [POV character]'s perspective"\n`;
            output += `- "Expand [scene name] with more sensory details and emotional depth"\n`;
            output += `- "Draft dialogue between [character A] and [character B] about [conflict]"\n`;
            output += `- "Write the climax scene where [key plot event] happens"\n\n`;
            output += `**For Revision:**\n`;
            output += `- "Analyze character arc for [protagonist] - identify weak character development"\n`;
            output += `- "Find pacing issues in Act 2 - which scenes drag or feel rushed?"\n`;
            output += `- "Suggest ways to increase tension in [chapter name]"\n`;
            output += `- "Identify plot holes or inconsistencies in the manuscript"\n\n`;
            output += `**For Publishing:**\n`;
            output += `- "Write a compelling 300-word book blurb for marketing"\n`;
            output += `- "Generate 20 comp titles (comparable books) with explanation"\n`;
            output += `- "Draft query letter to literary agents highlighting unique elements"\n`;
            output += `- "Create chapter summaries for submission synopsis (1-2 sentences each)"\n\n`;

            return output;
        }

        // Generate Course/Training prompt (curriculum-ready, learning-focused)
        function generateCoursePrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸ“–'} ${tree.name || 'Course Curriculum'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate course metrics
            let totalDuration = 0;
            let totalLessons = 0;
            let assessmentCount = 0;
            const moduleMetrics = [];

            if (tree.children) {
                tree.children.forEach(module => {
                    if (module.type === 'phase' && module.items) {
                        let moduleDuration = 0;
                        let lessonCount = module.items.length;

                        module.items.forEach(lesson => {
                            // Parse duration (e.g., "2 hours", "45 minutes")
                            if (lesson.duration) {
                                const match = lesson.duration.match(/(\d+)\s*(hour|minute|min)/i);
                                if (match) {
                                    const value = parseInt(match[1]);
                                    const unit = match[2].toLowerCase();
                                    moduleDuration += unit.startsWith('hour') ? value * 60 : value;
                                }
                            }
                            if (lesson.assessmentType && lesson.assessmentType !== 'None') {
                                assessmentCount++;
                            }
                        });

                        moduleMetrics.push({
                            name: module.name || `Module ${module.phase + 1}`,
                            subtitle: module.subtitle,
                            duration: moduleDuration,
                            lessons: lessonCount
                        });

                        totalDuration += moduleDuration;
                        totalLessons += lessonCount;
                    }
                });
            }

            const totalHours = Math.floor(totalDuration / 60);
            const totalMinutes = totalDuration % 60;

            // Course Overview
            output += `## ðŸŽ“ Course Overview\n\n`;
            output += `**Course Specifications:**\n`;
            output += `- Total Duration: ${totalHours}h ${totalMinutes}m\n`;
            output += `- Total Modules: ${moduleMetrics.length}\n`;
            output += `- Total Lessons: ${totalLessons}\n`;
            output += `- Assessments: ${assessmentCount}\n`;
            output += `- Average Lesson: ${Math.round(totalDuration / totalLessons)} minutes\n\n`;

            // Learning Path
            output += `## ðŸ›¤ï¸ Learning Path Structure\n\n`;
            moduleMetrics.forEach((mod, idx) => {
                const modHours = Math.floor(mod.duration / 60);
                const modMinutes = mod.duration % 60;
                output += `### Module ${idx + 1}: ${mod.name}${mod.subtitle ? ` â€” ${mod.subtitle}` : ''}\n`;
                output += `- Duration: ${modHours}h ${modMinutes}m\n`;
                output += `- Lessons: ${mod.lessons}\n`;
                output += `- Average Lesson: ${Math.round(mod.duration / mod.lessons)} minutes\n\n`;
            });

            // Detailed Curriculum
            output += `---\n\n## ðŸ“š Detailed Curriculum\n\n`;

            if (tree.children) {
                tree.children.forEach((module, modIdx) => {
                    if (module.type === 'phase' && module.items && module.items.length > 0) {
                        output += `### Module ${modIdx + 1}: ${module.name || `Module ${modIdx + 1}`}\n\n`;
                        if (module.subtitle) {
                            output += `*${module.subtitle}*\n\n`;
                        }

                        module.items.forEach((lesson, lesIdx) => {
                            output += `#### Lesson ${modIdx + 1}.${lesIdx + 1}: ${lesson.name}\n\n`;

                            // Lesson metadata
                            const metadata = [];
                            if (lesson.duration) metadata.push(`â±ï¸ ${lesson.duration}`);
                            if (lesson.difficultyLevel) metadata.push(`ðŸ“Š ${lesson.difficultyLevel}`);
                            if (lesson.assessmentType && lesson.assessmentType !== 'None') metadata.push(`âœ… ${lesson.assessmentType}`);

                            if (metadata.length > 0) {
                                output += metadata.join(' â€¢ ') + '\n\n';
                            }

                            // Learning objectives
                            if (lesson.learningObjectives) {
                                output += `**Learning Objectives:**\n${lesson.learningObjectives}\n\n`;
                            }

                            // Lesson description
                            if (lesson.description) {
                                output += `**Lesson Content:**\n${lesson.description}\n\n`;
                            }

                            // Prerequisites
                            if (lesson.prerequisites) {
                                output += `**Prerequisites:** ${lesson.prerequisites}\n\n`;
                            }

                            // Resources
                            if (lesson.resourcesNeeded) {
                                output += `**Resources Needed:** ${lesson.resourcesNeeded}\n\n`;
                            }

                            // Activities/exercises
                            if (lesson.children && lesson.children.length > 0) {
                                output += `**Activities & Exercises:**\n`;
                                lesson.children.forEach((activity, aIdx) => {
                                    output += `${aIdx + 1}. ${activity.name}`;
                                    if (activity.duration) {
                                        output += ` (${activity.duration})`;
                                    }
                                    if (activity.description) {
                                        output += `\n   ${activity.description}`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (lesson.dependencies && lesson.dependencies.length > 0) {
                                output += `**âš ï¸ Requires Completion Of:** ${lesson.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Course Development Recommendations
            output += `## ðŸŽ¯ Course Development Strategy\n\n`;
            output += `**Instructional Design Checklist:**\n`;
            output += `1. Learning Objectives: Each lesson has clear, measurable outcomes\n`;
            output += `2. Scaffolding: Concepts build progressively from simple to complex\n`;
            output += `3. Active Learning: Mix of theory, practice, and assessment\n`;
            output += `4. Engagement: Vary content types (video, text, interactive, projects)\n`;
            output += `5. Assessment: Regular checkpoints to verify understanding\n\n`;

            output += `**Course Quality Standards:**\n`;
            output += `- Lesson Length: Keep videos 10-20 minutes for optimal retention\n`;
            output += `- Practice Ratio: 70% practice, 30% theory for skill-based courses\n`;
            output += `- Assessment Frequency: Quiz or exercise every 3-4 lessons\n`;
            output += `- Resource Quality: Provide downloadable templates, cheat sheets, references\n`;
            output += `- Community: Discussion forums or peer review for social learning\n\n`;

            output += `**Production Planning:**\n`;
            const avgLessonTime = Math.round(totalDuration / totalLessons);
            const videoHours = Math.ceil(totalHours * 2); // 2:1 production ratio
            output += `- Video Production Time: ~${videoHours} hours (2:1 ratio for recording/editing)\n`;
            output += `- Script Writing: ~2 hours per lesson (${totalLessons * 2} hours total)\n`;
            output += `- Assessment Creation: ~1 hour per quiz/exercise\n`;
            output += `- Platform Setup: LMS configuration, student enrollment, progress tracking\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ AI Prompt Usage - Course Deliverables:**\n`;
            output += `\n`;
            output += `**For Content Creation:**\n`;
            output += `- "Write a detailed lesson script for [lesson name] covering [learning objectives]"\n`;
            output += `- "Create 10 multiple-choice quiz questions for [module] with explanations"\n`;
            output += `- "Design a hands-on project assignment for [topic] with rubric"\n`;
            output += `- "Generate practice exercises with solutions for [concept]"\n\n`;
            output += `**For Course Materials:**\n`;
            output += `- "Create a 1-page cheat sheet summarizing [module] key concepts"\n`;
            output += `- "Write downloadable PDF guide for [technical skill] with examples"\n`;
            output += `- "Design flashcards for memorizing [terminology/concepts]"\n`;
            output += `- "Generate code templates/starter files for [programming lesson]"\n\n`;
            output += `**For Marketing & Launch:**\n`;
            output += `- "Write compelling course description highlighting unique value (300 words)"\n`;
            output += `- "Create course landing page copy with benefits, outcomes, testimonials"\n`;
            output += `- "Generate lesson previews and free samples to attract students"\n`;
            output += `- "Draft email sequence for course launch (5 emails over 2 weeks)"\n\n`;
            output += `**For Student Support:**\n`;
            output += `- "Create FAQ document answering common student questions"\n`;
            output += `- "Write discussion prompts for community engagement in forums"\n`;
            output += `- "Generate personalized feedback templates for assignment reviews"\n\n`;

            return output;
        }

        // Generate Academic Thesis prompt (manuscript-ready, scholarly)
        function generateThesisPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸŽ“'} ${tree.name || 'Thesis'}\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Calculate manuscript metrics
            let totalWordCount = 0;
            let targetWordCount = 0;
            let totalChapters = 0;
            const chapterMetrics = [];

            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.type === 'phase' && chapter.items) {
                        let chapterWords = 0;
                        let chapterTarget = 0;
                        let sectionCount = chapter.items.length;

                        chapter.items.forEach(section => {
                            chapterWords += section.wordCount || 0;
                            chapterTarget += section.targetWordCount || 0;
                        });

                        chapterMetrics.push({
                            name: chapter.name || `Chapter ${chapter.phase + 1}`,
                            subtitle: chapter.subtitle,
                            current: chapterWords,
                            target: chapterTarget,
                            sections: sectionCount,
                            progress: chapterTarget > 0 ? Math.round((chapterWords / chapterTarget) * 100) : 0
                        });

                        totalWordCount += chapterWords;
                        targetWordCount += chapterTarget;
                        totalChapters++;
                    }
                });
            }

            const overallProgress = targetWordCount > 0 ? Math.round((totalWordCount / targetWordCount) * 100) : 0;

            // Document Metadata
            output += `## ðŸ“„ Document Metadata\n\n`;
            output += `**Manuscript Status:**\n`;
            output += `- Current Length: ${totalWordCount.toLocaleString()} words\n`;
            output += `- Target Length: ${targetWordCount.toLocaleString()} words\n`;
            output += `- Completion: ${overallProgress}% (${totalWordCount}/${targetWordCount})\n`;
            output += `- Structure: ${totalChapters} chapters across ${pattern.levels.phase}\n`;
            output += `- Average Chapter: ${Math.round(totalWordCount / totalChapters).toLocaleString()} words\n\n`;

            // Chapter Breakdown with Progress
            output += `## ðŸ“š Chapter Structure\n\n`;
            chapterMetrics.forEach((ch, idx) => {
                const progressBar = 'â–ˆ'.repeat(Math.floor(ch.progress / 10)) + 'â–‘'.repeat(10 - Math.floor(ch.progress / 10));
                output += `### ${ch.name}${ch.subtitle ? ` â€” ${ch.subtitle}` : ''}\n`;
                output += `- Progress: [${progressBar}] ${ch.progress}%\n`;
                output += `- Word Count: ${ch.current.toLocaleString()} / ${ch.target.toLocaleString()} words\n`;
                output += `- Sections: ${ch.sections}\n\n`;
            });

            // Chapter Details
            output += `---\n\n## ðŸ“– Detailed Chapter Content\n\n`;

            if (tree.children) {
                tree.children.forEach((chapter, chIdx) => {
                    if (chapter.type === 'phase' && chapter.items && chapter.items.length > 0) {
                        output += `### ${chapter.name || `Chapter ${chIdx + 1}`}${chapter.subtitle ? ` â€” ${chapter.subtitle}` : ''}\n\n`;

                        chapter.items.forEach((section, sIdx) => {
                            output += `#### ${sIdx + 1}. ${section.name}\n\n`;

                            // Section metadata
                            if (section.keyArgument) {
                                output += `**Central Argument:**\n`;
                                output += `${section.keyArgument}\n\n`;
                            }

                            if (section.description) {
                                output += `**Section Overview:**\n`;
                                output += `${section.description}\n\n`;
                            }

                            // Evidence & Methodology
                            const hasMethodology = section.evidenceType || section.citations;
                            if (hasMethodology) {
                                output += `**Evidence & Methods:**\n`;
                                if (section.evidenceType) {
                                    output += `- Evidence Type: ${section.evidenceType}\n`;
                                }
                                if (section.citations) {
                                    output += `- Key Citations: ${section.citations}\n`;
                                }
                                output += `\n`;
                            }

                            // Writing Progress
                            if (section.wordCount !== undefined || section.targetWordCount) {
                                const sectionProgress = section.targetWordCount > 0 ? Math.round((section.wordCount || 0) / section.targetWordCount * 100) : 0;
                                output += `**Writing Progress:**\n`;
                                output += `- Current: ${section.wordCount || 0} words\n`;
                                output += `- Target: ${section.targetWordCount || 'TBD'} words\n`;
                                output += `- Status: ${sectionProgress}% complete`;
                                if (section.draftStatus) {
                                    output += ` (${section.draftStatus})`;
                                }
                                output += `\n\n`;
                            }

                            // Subsections/Arguments
                            if (section.children && section.children.length > 0) {
                                output += `**Sub-arguments:**\n`;
                                section.children.forEach((sub, subIdx) => {
                                    output += `${subIdx + 1}. ${sub.name}`;
                                    if (sub.keyArgument) {
                                        output += ` â€” ${sub.keyArgument}`;
                                    }
                                    if (sub.citations) {
                                        output += ` [${sub.citations}]`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (section.dependencies && section.dependencies.length > 0) {
                                output += `**âš ï¸ Dependencies:** This section builds on: ${section.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Writing Recommendations
            output += `## âœï¸ Writing Recommendations\n\n`;
            output += `**Manuscript Completeness:**\n`;
            output += `- Overall Progress: ${overallProgress}% complete\n`;
            if (overallProgress < 50) {
                output += `- Status: Early draft stage â€” focus on completing first drafts of all chapters\n`;
            } else if (overallProgress < 80) {
                output += `- Status: Mid-stage â€” focus on deepening arguments and adding evidence\n`;
            } else {
                output += `- Status: Late stage â€” focus on revision, citations, and cohesion\n`;
            }
            output += `- Remaining: ${(targetWordCount - totalWordCount).toLocaleString()} words to target length\n\n`;

            output += `**Chapter Balance:**\n`;
            const chapterLengths = chapterMetrics.map(ch => ch.current);
            const avgChapter = chapterLengths.reduce((a, b) => a + b, 0) / chapterLengths.length;
            const imbalanced = chapterLengths.filter(len => len < avgChapter * 0.5 || len > avgChapter * 1.5);
            if (imbalanced.length > 0) {
                output += `- âš ï¸ ${imbalanced.length} chapter(s) significantly differ from average length\n`;
                output += `- Consider redistributing content or adjusting targets\n`;
            } else {
                output += `- âœ“ Chapters are relatively balanced in length\n`;
            }
            output += `\n`;

            output += `**Academic Quality Checks:**\n`;
            output += `1. Citation Coverage: Ensure each major claim has 2-3 supporting citations\n`;
            output += `2. Argument Coherence: Check logical flow within and between chapters\n`;
            output += `3. Evidence Types: Balance theoretical, empirical, and case study evidence\n`;
            output += `4. Literature Gaps: Identify missing perspectives or counter-arguments\n`;
            output += `5. Methodological Rigor: Document methods, limitations, and validity\n\n`;

            output += `**Next Steps:**\n`;
            const incompleteSections = [];
            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.items) {
                        chapter.items.forEach(section => {
                            if (!section.wordCount || section.wordCount < (section.targetWordCount || 0) * 0.5) {
                                incompleteSections.push(section.name);
                            }
                        });
                    }
                });
            }
            if (incompleteSections.length > 0) {
                output += `- Priority: Complete ${incompleteSections.length} under-developed section(s)\n`;
                output += `- Focus areas: ${incompleteSections.slice(0, 3).join(', ')}${incompleteSections.length > 3 ? '...' : ''}\n`;
            }
            output += `- Review: Get feedback from advisors on completed chapters\n`;
            output += `- Citations: Update and complete bibliography\n`;
            output += `- Editing: Professional copyediting for polished sections\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ AI Prompt Usage:** This academic manuscript can be used to:\n`;
            output += `- Ask AI to critique arguments and suggest counter-arguments\n`;
            output += `- Generate literature review summaries for each chapter\n`;
            output += `- Draft section transitions and chapter conclusions\n`;
            output += `- Suggest additional citations based on argument types\n`;
            output += `- Create visual abstracts and conference presentations\n`;
            output += `- Identify methodological weaknesses and suggest improvements\n`;
            output += `- Generate research questions for future studies\n\n`;

            return output;
        }

        // Generate Sales Pipeline prompt (executive-ready, action-oriented)
        function generateSalesPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸ’¼'} ${tree.name || 'Sales Pipeline'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate pipeline metrics
            let totalPipelineValue = 0;
            let weightedPipelineValue = 0;
            let totalDeals = 0;
            const quarterMetrics = [];

            if (tree.children) {
                tree.children.forEach(quarter => {
                    if (quarter.type === 'phase' && quarter.items) {
                        let quarterTotal = 0;
                        let quarterWeighted = 0;
                        let quarterDeals = quarter.items.length;

                        quarter.items.forEach(deal => {
                            const dealValue = deal.dealValue || 0;
                            const probability = deal.stageProbability || deal.probability || 0;

                            quarterTotal += dealValue;
                            quarterWeighted += (dealValue * probability / 100);
                        });

                        quarterMetrics.push({
                            name: quarter.name || `Quarter ${quarter.phase + 1}`,
                            subtitle: quarter.subtitle,
                            total: quarterTotal,
                            weighted: quarterWeighted,
                            deals: quarterDeals
                        });

                        totalPipelineValue += quarterTotal;
                        weightedPipelineValue += quarterWeighted;
                        totalDeals += quarterDeals;
                    }
                });
            }

            // Executive Summary
            output += `## ðŸ“Š Executive Summary\n\n`;
            output += `**Pipeline Health:**\n`;
            output += `- Total Pipeline Value: $${totalPipelineValue.toLocaleString()}\n`;
            output += `- Weighted Pipeline (Probability Adjusted): $${Math.round(weightedPipelineValue).toLocaleString()}\n`;
            output += `- Total Active Deals: ${totalDeals}\n`;
            output += `- Average Deal Size: $${Math.round(totalPipelineValue / totalDeals).toLocaleString()}\n`;
            output += `- Weighted Close Rate: ${Math.round(weightedPipelineValue / totalPipelineValue * 100)}%\n\n`;

            // Quarterly Breakdown
            output += `## ðŸ“… Quarterly Breakdown\n\n`;
            quarterMetrics.forEach((q, idx) => {
                output += `### ${q.name}${q.subtitle ? ` - ${q.subtitle}` : ''}\n`;
                output += `- Pipeline: $${q.total.toLocaleString()} (${q.deals} deals)\n`;
                output += `- Expected Revenue: $${Math.round(q.weighted).toLocaleString()}\n`;
                output += `- Conversion Confidence: ${Math.round(q.weighted / q.total * 100)}%\n\n`;
            });

            // Deal Details by Quarter
            output += `---\n\n## ðŸ’¼ Deal Pipeline\n\n`;

            if (tree.children) {
                tree.children.forEach((quarter, qIdx) => {
                    if (quarter.type === 'phase' && quarter.items && quarter.items.length > 0) {
                        output += `### ${quarter.name || `Quarter ${qIdx + 1}`}\n\n`;

                        quarter.items.forEach((deal, dIdx) => {
                            const dealValue = deal.dealValue || 0;
                            const probability = deal.stageProbability || deal.probability || 0;
                            const expectedRevenue = Math.round(dealValue * probability / 100);

                            output += `#### ${dIdx + 1}. ${deal.name}\n\n`;

                            // Deal metrics bar
                            output += `**Deal Snapshot:**\n`;
                            output += `- ðŸ’° Value: $${dealValue.toLocaleString()}\n`;
                            output += `- ðŸ“Š Probability: ${probability}%\n`;
                            output += `- ðŸ’µ Expected Revenue: $${expectedRevenue.toLocaleString()}\n`;
                            if (deal.expectedCloseDate || deal.expectedClose) {
                                output += `- ðŸ“… Target Close: ${deal.expectedCloseDate || deal.expectedClose}\n`;
                            }
                            if (deal.accountExecutive) {
                                output += `- ðŸ‘¤ Account Executive: ${deal.accountExecutive}\n`;
                            }
                            if (deal.itemType) {
                                const typeLabel = pattern.types.find(t => t.value === deal.itemType)?.label || deal.itemType;
                                output += `- ðŸ·ï¸ Deal Type: ${typeLabel}\n`;
                            }
                            if (deal.status) {
                                output += `- ðŸ“ Status: ${deal.status}\n`;
                            }
                            if (deal.leadTime) {
                                output += `- â±ï¸ Sales Cycle: ${deal.leadTime}\n`;
                            }
                            output += `\n`;

                            if (deal.description) {
                                output += `**Overview:**\n${deal.description}\n\n`;
                            }

                            // Action items / Next steps
                            if (deal.children && deal.children.length > 0) {
                                output += `**Action Items:**\n`;
                                deal.children.forEach((action, aIdx) => {
                                    output += `${aIdx + 1}. **${action.name}**\n`;
                                    if (action.description) {
                                        output += `   ${action.description}\n`;
                                    }
                                    if (action.expectedClose || action.expectedCloseDate) {
                                        output += `   _Due: ${action.expectedClose || action.expectedCloseDate}_\n`;
                                    }
                                    if (action.dependencies && action.dependencies.length > 0) {
                                        output += `   _Depends on: ${action.dependencies.join(', ')}_\n`;
                                    }
                                    output += `\n`;
                                });
                            }

                            // Competitive intelligence
                            if (deal.competitorInfo) {
                                output += `**ðŸŽ¯ Competitive Landscape:**\n${deal.competitorInfo}\n\n`;
                            }

                            // Dependencies/blockers
                            if (deal.dependencies && deal.dependencies.length > 0) {
                                output += `**âš ï¸ Dependencies:** This deal depends on: ${deal.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Risk Analysis & Recommendations
            output += `## âš ï¸ Risk Analysis & Recommendations\n\n`;
            output += `**Pipeline Coverage:**\n`;
            const averageCloseRate = Math.round(weightedPipelineValue / totalPipelineValue * 100);
            output += `- Current weighted close rate: ${averageCloseRate}%\n`;
            output += `- To hit 100% of targets, maintain ${Math.round(100 / averageCloseRate)}x pipeline coverage\n`;
            output += `- Low-probability deals (<50%): Focus on advancing or disqualifying quickly\n`;
            output += `- High-value deals (>$500K): Ensure executive sponsorship and multi-threading\n\n`;

            output += `**Key Actions:**\n`;
            output += `1. Accelerate deals in late stages (>70% probability) to close within quarter\n`;
            output += `2. Qualify out deals stuck in discovery for >2 months\n`;
            output += `3. Build relationships with economic buyers, not just champions\n`;
            output += `4. Document competitive wins and losses for pattern analysis\n`;
            output += `5. Request customer references from recent wins for social proof\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ AI Prompt Usage:** This sales pipeline can be used to:\n`;
            output += `- Ask AI to analyze deal health and suggest next best actions\n`;
            output += `- Generate sales enablement materials (case studies, proposals, ROI calculators)\n`;
            output += `- Forecast quarterly revenue with Monte Carlo simulations\n`;
            output += `- Identify at-risk deals based on activity patterns\n`;
            output += `- Draft personalized executive emails for each stakeholder\n`;
            output += `- Create competitive battlecards from competitorInfo fields\n\n`;

            return output;
        }

        // Generate Philosophy prompts (executable, professional)
        function generatePhilosophyPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸ¤”'} ${tree.name || 'Philosophical Argument'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            output += `**Professional Philosophy Prompt** - Copy-paste ready for Claude/GPT-4\n\n`;
            output += `---\n\n`;

            // Collect all arguments
            const allArguments = [];
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach(item => {
                            allArguments.push({
                                ...item,
                                phaseName: phase.name,
                                phaseSubtitle: phase.subtitle
                            });
                        });
                    }
                });
            }

            if (allArguments.length === 0) {
                output += `*No arguments defined yet. Add items to your tree.*\n`;
                return output;
            }

            // Detect speakers and dialogue partners
            const speakers = [...new Set(allArguments.map(a => a.speaker).filter(s => s))];
            const primarySpeaker = speakers[0] || 'The Philosopher';
            const isDialogue = speakers.length > 1;

            // SYNTHESIZE: Create professional philosophical prompt

            // 1. CONTEXT & ROLE
            output += `## ðŸ“š Context\n\n`;
            output += `This is a ${isDialogue ? 'philosophical dialogue' : 'structured argument'} `;
            if (speakers.length > 0) {
                output += `featuring ${speakers.join(', ')}. `;
            }
            output += `The argument progresses through ${tree.children.length} major movements with ${allArguments.length} distinct claims.\n\n`;

            // 2. MAIN PROMPT
            output += `## ðŸ’­ Your Task\n\n`;
            output += `You are a philosophy professor preparing a comprehensive critical analysis. Write a 2500-word essay that:\n\n`;

            output += `**1. Reconstructs the Argument**\n`;
            output += `- Present each major claim in logical order\n`;
            output += `- Identify premises, inferences, and conclusions\n`;
            output += `- Map the dependency structure (which claims build on others)\n\n`;

            output += `**2. Evaluates Logical Validity**\n`;
            output += `- Are the inferences sound?\n`;
            output += `- Do the conclusions follow from the premises?\n`;
            output += `- What hidden assumptions are made?\n`;
            output += `- Are there logical fallacies?\n\n`;

            output += `**3. Engages Philosophically**\n`;
            output += `- What are the strongest objections to this view?\n`;
            output += `- How might the author respond?\n`;
            output += `- What implications does this have for ethics, epistemology, or metaphysics?\n`;
            output += `- How does this compare to contemporary philosophical positions?\n\n`;

            output += `**4. Applies to Modern Context**\n`;
            output += `- What modern issues does this illuminate?\n`;
            output += `- How would this argument address current debates?\n`;
            output += `- Is this view still defensible today? Why or why not?\n\n`;

            // 3. THE ARGUMENT STRUCTURE (as reference)
            output += `---\n\n`;
            output += `## ðŸ“– The Argument Structure\n\n`;
            output += `Use this as your reference material for the analysis above:\n\n`;

            tree.children.forEach((phase, phaseIdx) => {
                output += `### ${phase.name}\n`;
                if (phase.subtitle) {
                    output += `*${phase.subtitle}*\n`;
                }
                output += `\n`;

                if (phase.items && phase.items.length > 0) {
                    phase.items.forEach((item, itemIdx) => {
                        output += `**Argument ${phaseIdx + 1}.${itemIdx + 1}: ${item.name}**\n\n`;

                        if (item.description) {
                            output += `${item.description}\n\n`;
                        }

                        // Build structured argument info
                        const argDetails = [];

                        if (item.speaker) argDetails.push(`*Speaker*: ${item.speaker}`);
                        if (item.argumentType) argDetails.push(`*Type*: ${item.argumentType}`);
                        if (item.keyTerms) argDetails.push(`*Key Terms*: ${item.keyTerms}`);

                        if (argDetails.length > 0) {
                            output += argDetails.join(' â€¢ ') + '\n\n';
                        }

                        // Premises and conclusion in structured format
                        if (item.premise1 || item.premise2 || item.conclusion) {
                            output += `<argument>\n`;
                            if (item.premise1) output += `**P1**: ${item.premise1}\n\n`;
                            if (item.premise2) output += `**P2**: ${item.premise2}\n\n`;
                            if (item.premise3) output += `**P3**: ${item.premise3}\n\n`;
                            if (item.conclusion) output += `**âˆ´**: ${item.conclusion}\n`;
                            output += `</argument>\n\n`;
                        }

                        // Dependencies
                        if (item.dependencies && item.dependencies.length > 0) {
                            output += `*Builds on*: ${item.dependencies.join(', ')}\n\n`;
                        }

                        // Subtasks as supporting points
                        if (item.subtasks && item.subtasks.length > 0) {
                            output += `*Supporting points*:\n`;
                            item.subtasks.forEach(sub => {
                                output += `- ${sub.name}`;
                                if (sub.description) output += `: ${sub.description}`;
                                output += `\n`;
                            });
                            output += `\n`;
                        }
                    });
                }
            });

            // 4. OUTPUT STRUCTURE
            output += `---\n\n`;
            output += `## âœï¸ Essay Structure\n\n`;
            output += `Your 2500-word analysis should follow this structure:\n\n`;
            output += `**Introduction (300 words)**\n`;
            output += `- Introduce the philosophical problem\n`;
            output += `- State the main thesis being examined\n`;
            output += `- Preview your analytical approach\n\n`;

            output += `**Part I: Argument Reconstruction (600 words)**\n`;
            output += `- Present the argument structure clearly\n`;
            output += `- Identify all major premises and conclusions\n`;
            output += `- Map the logical flow and dependencies\n\n`;

            output += `**Part II: Logical Analysis (500 words)**\n`;
            output += `- Evaluate validity and soundness\n`;
            output += `- Identify hidden assumptions\n`;
            output += `- Note any fallacies or weak inferences\n\n`;

            output += `**Part III: Philosophical Engagement (600 words)**\n`;
            output += `- Present strongest objections\n`;
            output += `- Consider author's possible responses\n`;
            output += `- Discuss broader philosophical implications\n\n`;

            output += `**Part IV: Modern Application (400 words)**\n`;
            output += `- Connect to contemporary issues\n`;
            output += `- Assess relevance and defensibility today\n`;
            output += `- Suggest modifications or extensions\n\n`;

            output += `**Conclusion (100 words)**\n`;
            output += `- Summarize your analysis\n`;
            output += `- State your final evaluation of the argument\n\n`;

            // 5. EVALUATION CRITERIA
            output += `---\n\n`;
            output += `## âœ“ Success Criteria\n\n`;
            output += `Your essay should demonstrate:\n`;
            output += `- âœ… Accurate reconstruction of all ${allArguments.length} arguments\n`;
            output += `- âœ… Rigorous logical analysis using formal/informal logic\n`;
            output += `- âœ… Engagement with key philosophical concepts: ${getKeyTerms(allArguments)}\n`;
            output += `- âœ… Awareness of relevant philosophical traditions and debates\n`;
            output += `- âœ… Clear, precise philosophical writing (avoid vagueness)\n`;
            output += `- âœ… Fair-minded treatment (steel man, not straw man objections)\n`;
            output += `- âœ… Creative application to modern contexts\n`;
            output += `- âœ… Original insights, not mere summary\n\n`;

            // 6. ALTERNATIVE PROMPT MODES
            output += `---\n\n`;
            output += `## ðŸ”„ Alternative Prompt Modes\n\n`;

            if (isDialogue) {
                output += `**Mode 1: Continue the Dialogue**\n`;
                output += `\`\`\`\n`;
                output += `You are responding to ${primarySpeaker}'s arguments. Write a philosophical `;
                output += `dialogue where you (as an interlocutor) raise 3 sophisticated objections, `;
                output += `then have ${primarySpeaker} respond to each. Use the Socratic method `;
                output += `of questioning to probe deeper.\n`;
                output += `\`\`\`\n\n`;
            }

            output += `**Mode 2: Compare to Another Philosopher**\n`;
            output += `\`\`\`\n`;
            output += `Compare this argument to [Kant/Nietzsche/Rawls/Singer]. How would [philosopher] `;
            output += `respond to these claims? Where would they agree/disagree and why? What synthesis `;
            output += `might be possible between the two views?\n`;
            output += `\`\`\`\n\n`;

            output += `**Mode 3: Logical Formalization**\n`;
            output += `\`\`\`\n`;
            output += `Formalize this argument using predicate logic. Translate each premise and `;
            output += `conclusion into logical notation (âˆ€, âˆƒ, â†’, â†”, Â¬, âˆ§, âˆ¨). Prove validity using `;
            output += `natural deduction or truth tables. Identify which premises, if any, are dubious.\n`;
            output += `\`\`\`\n\n`;

            output += `**Mode 4: Teaching Guide**\n`;
            output += `\`\`\`\n`;
            output += `Create a teaching guide for undergraduate philosophy students. Include: `;
            output += `(1) Pre-reading questions, (2) Key concepts glossary, (3) Discussion prompts, `;
            output += `(4) Thought experiments to test understanding, (5) Essay topics.\n`;
            output += `\`\`\`\n\n`;

            // 7. PHILOSOPHICAL CONTEXT
            if (allArguments.some(a => a.argumentType)) {
                output += `---\n\n`;
                output += `## ðŸŽ“ Philosophical Methods Used\n\n`;
                const argTypes = [...new Set(allArguments.map(a => a.argumentType).filter(t => t))];
                argTypes.forEach(type => {
                    const count = allArguments.filter(a => a.argumentType === type).length;
                    output += `- **${type}** (${count} argument${count > 1 ? 's' : ''})\n`;
                });
                output += `\n`;
            }

            return output;
        }

        // Helper: Extract key terms for Philosophy prompt
        function getKeyTerms(arguments) {
            const allTerms = arguments
                .map(a => a.keyTerms)
                .filter(t => t)
                .join(', ')
                .split(',')
                .map(t => t.trim())
                .filter(t => t.length > 0);

            // Get unique terms, limit to top 8
            const uniqueTerms = [...new Set(allTerms)].slice(0, 8);
            return uniqueTerms.join(', ');
        }

        // Generate generic prompt format
        function generateGenericPrompt(tree, pattern) {
            // SPECIAL CASE: AI Video Production uses different format
            if (currentPattern === 'film') {
                return generateAIVideoPrompts(tree, pattern);
            }

            // SPECIAL CASE: Philosophy uses different format
            if (currentPattern === 'philosophy') {
                return generatePhilosophyPrompt(tree, pattern);
            }

            // SPECIAL CASE: Sales Pipeline uses different format
            if (currentPattern === 'sales') {
                return generateSalesPrompt(tree, pattern);
            }

            // SPECIAL CASE: Thesis/Academic uses different format
            if (currentPattern === 'thesis') {
                return generateThesisPrompt(tree, pattern);
            }

            // SPECIAL CASE: Product Roadmap uses different format
            if (currentPattern === 'roadmap') {
                return generateRoadmapPrompt(tree, pattern);
            }

            // SPECIAL CASE: Book/Novel uses different format
            if (currentPattern === 'book') {
                return generateBookPrompt(tree, pattern);
            }

            // SPECIAL CASE: Course/Training uses different format
            if (currentPattern === 'course') {
                return generateCoursePrompt(tree, pattern);
            }

            let prompt = `# ${tree.icon || 'ðŸ“‹'} ${tree.name || 'Project'}\n\n`;

            if (tree.description) {
                prompt += `${tree.description}\n\n`;
            }

            prompt += `---\n\n`;

            // Introduction based on pattern
            const patternIntros = {
                'sales': `You are a sales analyst. Follow this structured sales pipeline analysis:`,
                'thesis': `You are an academic advisor. Follow this thesis structure:`,
                'roadmap': `You are a product manager. Follow this product roadmap:`,
                'book': `You are a writing coach. Follow this book structure:`,
                'event': `You are an event planner. Follow this event plan:`,
                'fitness': `You are a fitness coach. Follow this training program:`,
                'strategy': `You are a business strategist. Follow this strategic plan:`,
                'course': `You are an educator. Follow this course structure:`,
                'philosophy': `You are a philosophy scholar. Follow this philosophical argument:`,
                'familytree': `You are a genealogist. Follow this family tree structure:`,
                'generic': `Follow this structured workflow:`
            };

            prompt += `${patternIntros[currentPattern] || patternIntros['generic']}\n\n`;

            // Process each phase
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    prompt += `## ${pattern.levels.phase} ${phaseIdx + 1}: ${phase.name}\n`;
                    if (phase.subtitle) {
                        prompt += `*${phase.subtitle}*\n`;
                    }
                    prompt += `\n`;

                    // Add items
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            prompt += `### ${itemIdx + 1}. ${item.name}\n`;

                            if (item.description) {
                                prompt += `${item.description}\n`;
                            }

                            // Add ALL pattern-specific fields dynamically
                            prompt += `\n`;
                            if (pattern.fields) {
                                Object.keys(pattern.fields).forEach(fieldKey => {
                                    const fieldConfig = pattern.fields[fieldKey];

                                    // Skip non-field properties
                                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                                        return;
                                    }

                                    const value = item[fieldKey];
                                    if (value !== undefined && value !== null && value !== '') {
                                        let displayValue = value;

                                        // Format based on field type
                                        if (fieldConfig.type === 'number') {
                                            if (fieldKey === 'cost' || fieldKey === 'dealValue') {
                                                displayValue = formatCost(value);
                                            } else {
                                                displayValue = value;
                                            }
                                        } else if (fieldConfig.type === 'date') {
                                            displayValue = new Date(value).toLocaleDateString();
                                        }

                                        prompt += `- **${fieldConfig.label}**: ${displayValue}\n`;
                                    }
                                });
                            }

                            // Add dependencies
                            if (item.dependencies && item.dependencies.length > 0) {
                                const deps = Array.isArray(item.dependencies) ? item.dependencies.join(', ') : item.dependencies;
                                prompt += `- **Dependencies**: ${deps}\n`;
                            }

                            // Add PM tracking fields if present
                            if (item.pmStatus) prompt += `- **Status**: ${item.pmStatus}\n`;
                            if (item.pmAssignee) prompt += `- **Assignee**: ${item.pmAssignee}\n`;
                            if (item.pmProgress !== undefined) prompt += `- **Progress**: ${item.pmProgress}%\n`;
                            if (item.pmPriority) prompt += `- **Priority**: ${item.pmPriority}\n`;
                            if (item.pmDueDate) prompt += `- **Due Date**: ${new Date(item.pmDueDate).toLocaleDateString()}\n`;

                            // Add subtasks
                            if (item.subtasks && item.subtasks.length > 0) {
                                prompt += `\nAction steps:\n`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    prompt += `${subIdx + 1}. ${subtask.name}`;
                                    if (subtask.description) {
                                        prompt += `: ${subtask.description}`;
                                    }
                                    // Add subtask PM tracking if present
                                    const pmInfo = [];
                                    if (subtask.pmStatus) pmInfo.push(`Status: ${subtask.pmStatus}`);
                                    if (subtask.pmAssignee) pmInfo.push(`Assignee: ${subtask.pmAssignee}`);
                                    if (subtask.pmProgress !== undefined) pmInfo.push(`${subtask.pmProgress}%`);
                                    if (pmInfo.length > 0) {
                                        prompt += ` [${pmInfo.join(', ')}]`;
                                    }
                                    prompt += `\n`;
                                });
                            }

                            prompt += `\n`;
                        });
                    }

                    prompt += `\n`;
                });
            }

            // Footer
            prompt += `---\n\n`;
            prompt += `Provide a comprehensive response following this structure, addressing each ${pattern.levels.phase.toLowerCase()} and ${pattern.levels.item.toLowerCase()} systematically.\n`;

            return prompt;
        }

        // AI Modal - Overall Project Analysis (Dynamic AI-Generated)
        document.getElementById('ai-btn').addEventListener('click', async () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;

            document.getElementById('modal-title').textContent = `âœ¨ ${pattern.name} Analysis`;

            // Count items by phase
            function countItems(node, counts = {p0: 0, p1: 0, p2: 0}) {
                if (node.items && node.phase !== undefined) {
                    counts[`p${node.phase}`] += node.items.length;
                }
                if (node.children) {
                    node.children.forEach(child => countItems(child, counts));
                }
                return counts;
            }

            const itemCounts = countItems(capexTree);

            // Pattern-aware summary cards
            let summaryHTML = '';

            // For financial patterns (generic, sales, roadmap, strategy)
            if (pattern.fields && pattern.fields.cost) {
                const totalCost = calculateTotal(capexTree);
                const getPhaseCost = (phaseId) => {
                    const phase = findNode(phaseId);
                    return phase ? calculatePhaseTotal(phase) : 0;
                };

                const phase0Cost = getPhaseCost('phase-0');
                const phase1Cost = getPhaseCost('phase-1');
                const phase2Cost = getPhaseCost('phase-2');

                summaryHTML = `
                    <div style="background: linear-gradient(135deg, var(--treeplex-primary), #009977); color: white; padding: 24px; border-radius: 12px; margin-bottom: 24px;">
                        <h2 style="margin-bottom: 8px; font-size: 32px;">${formatCost(totalCost)}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Total Project Investment</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-0);">
                            <div style="font-size: 11px; font-weight: 600; color: #2e7d32; margin-bottom: 4px;">${levels.phase.toUpperCase()} 1</div>
                            <div style="font-size: 20px; font-weight: 700; color: #1b5e20; margin-bottom: 4px;">${formatCost(phase0Cost)}</div>
                            <div style="font-size: 12px; color: #2e7d32;">${itemCounts.p0} ${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-1);">
                            <div style="font-size: 11px; font-weight: 600; color: #1565c0; margin-bottom: 4px;">${levels.phase.toUpperCase()} 2</div>
                            <div style="font-size: 20px; font-weight: 700; color: #0d47a1; margin-bottom: 4px;">${formatCost(phase1Cost)}</div>
                            <div style="font-size: 12px; color: #1565c0;">${itemCounts.p1} ${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #fff3e0; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-2);">
                            <div style="font-size: 11px; font-weight: 600; color: #e65100; margin-bottom: 4px;">${levels.phase.toUpperCase()} 3</div>
                            <div style="font-size: 20px; font-weight: 700; color: #bf360c; margin-bottom: 4px;">${formatCost(phase2Cost)}</div>
                            <div style="font-size: 12px; color: #e65100;">${itemCounts.p2} ${levels.item.toLowerCase()}s</div>
                        </div>
                    </div>`;
            } else {
                // For non-financial patterns (AI Prompt Design, Philosophy, etc.)
                const totalItems = itemCounts.p0 + itemCounts.p1 + itemCounts.p2;
                const totalSubtasks = capexTree.children?.reduce((acc, phase) => {
                    return acc + (phase.items?.reduce((itemAcc, item) => {
                        return itemAcc + (item.subtasks?.length || 0);
                    }, 0) || 0);
                }, 0) || 0;

                summaryHTML = `
                    <div style="background: linear-gradient(135deg, var(--treeplex-primary), #8b5cf6); color: white; padding: 24px; border-radius: 12px; margin-bottom: 24px;">
                        <h2 style="margin-bottom: 8px; font-size: 32px;">${pattern.icon} ${capexTree.name || pattern.levels.root}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">${capexTree.children?.length || 0} ${levels.phase}s â€¢ ${totalItems} ${levels.item}s â€¢ ${totalSubtasks} ${levels.subtask}s</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-0);">
                            <div style="font-size: 11px; font-weight: 600; color: #2e7d32; margin-bottom: 4px;">${levels.phase.toUpperCase()} 1</div>
                            <div style="font-size: 20px; font-weight: 700; color: #1b5e20; margin-bottom: 4px;">${itemCounts.p0}</div>
                            <div style="font-size: 12px; color: #2e7d32;">${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-1);">
                            <div style="font-size: 11px; font-weight: 600; color: #1565c0; margin-bottom: 4px;">${levels.phase.toUpperCase()} 2</div>
                            <div style="font-size: 20px; font-weight: 700; color: #0d47a1; margin-bottom: 4px;">${itemCounts.p1}</div>
                            <div style="font-size: 12px; color: #1565c0;">${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #fff3e0; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-2);">
                            <div style="font-size: 11px; font-weight: 600; color: #e65100; margin-bottom: 4px;">${levels.phase.toUpperCase()} 3</div>
                            <div style="font-size: 20px; font-weight: 700; color: #bf360c; margin-bottom: 4px;">${itemCounts.p2}</div>
                            <div style="font-size: 12px; color: #e65100;">${levels.item.toLowerCase()}s</div>
                        </div>
                    </div>`;
            }

            // Show summary + loading state for AI analysis
            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    ${summaryHTML}

                    <div id="ai-analysis-loading" style="padding: 40px; text-align: center; background: var(--card-bg); border-radius: 12px; margin-top: 20px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary); font-size: 14px;">AI is analyzing your ${pattern.name.toLowerCase()}...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Generating insights and recommendations</p>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Call AI to generate the analysis sections dynamically
            console.log('ðŸ¤– Calling AI analysis at:', AI_CONFIG.apiEndpoint);
            try {
                const aiResponse = await generateAIAnalysis(capexTree, 'project');

                // Replace loading with AI-generated content
                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                        <div style="margin-bottom: 20px;">
                            <div id="ai-generated-content" style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                                <div style="white-space: pre-wrap; font-size: 14px; line-height: 1.8; color: var(--text-primary);">${aiResponse}</div>
                            </div>
                            <div style="margin-top: 16px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ðŸ¤– Analysis powered by Claude Sonnet â€¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;
                }

            } catch (error) {
                // Fallback to static analysis when AI is unavailable
                console.warn('AI Analysis unavailable, using static fallback:', error.message);

                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">CRITICAL PATH ANALYSIS</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    â€¢ <strong>Land acquisition</strong> is the primary gating factor for Phase 1 execution<br>
                                    â€¢ <strong>Turbine PO deposit</strong> (${formatCost(2000000)}) secures manufacturing capacity for Phase 2<br>
                                    â€¢ <strong>Pipeline FEED</strong> and permitting run in parallel to optimize timeline<br>
                                    â€¢ Phase 2 equipment procurement has 12-18 month lead times requiring early commitment
                                </p>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">RISK ASSESSMENT</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    <strong style="color: #d32f2f;">High Risk:</strong> Phase 2 represents ${((phase2Cost/totalCost)*100).toFixed(0)}% of total budget concentrated in equipment and infrastructure.<br>
                                    <strong style="color: #f57c00;">Medium Risk:</strong> Regulatory approvals for land, pipeline, and permitting on critical path.<br>
                                    <strong style="color: #388e3c;">Low Risk:</strong> Phase 0 has manageable capital exposure with assignable land options.
                                </p>
                            </div>

                            <div style="background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); padding: 20px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--treeplex-primary); text-transform: uppercase; letter-spacing: 0.5px;">STRATEGIC RECOMMENDATIONS</h4>
                                <ul style="font-size: 14px; line-height: 2; margin: 0; padding-left: 20px; color: var(--text-primary);">
                                    <li>Secure Phase 0 land option immediately to unlock downstream activities</li>
                                    <li>Negotiate payment milestones tied to regulatory approvals</li>
                                    <li>Consider project financing for Phase 2 to preserve equity</li>
                                    <li>Establish vendor relationships early for long-lead equipment items</li>
                                    <li>Build 10-15% contingency buffer beyond stated ${formatCost(310000)} reserves</li>
                                </ul>
                            </div>
                        </div>
                        <div style="margin-top: 16px; padding: 12px; background: rgba(255, 152, 0, 0.1); border-radius: 6px; text-align: center; border: 1px solid rgba(255, 152, 0, 0.3);">
                            <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                â„¹ï¸ AI Analysis unavailable â€¢ Showing static analysis â€¢ Deploy to Netlify for dynamic AI insights
                            </p>
                        </div>
                    </div>
                `;
                }
            }
        });

        document.getElementById('modal-close').addEventListener('click', () => {
            document.getElementById('modal').style.display = 'none';
        });

        // =============================================================================
        // API KEY CONFIGURATION
        // =============================================================================

        // Show/hide API keys toggle
        document.getElementById('api-key-show').addEventListener('change', (e) => {
            const claudeInput = document.getElementById('claude-api-key-input');
            const geminiInput = document.getElementById('gemini-api-key-input');
            const openaiInput = document.getElementById('openai-api-key-input');
            const inputType = e.target.checked ? 'text' : 'password';
            claudeInput.type = inputType;
            geminiInput.type = inputType;
            openaiInput.type = inputType;
        });

        // Clear all API keys
        document.getElementById('api-key-clear').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all saved API keys? This action cannot be undone.')) {
                clearLocalAPIKey('anthropic');
                clearLocalAPIKey('gemini');
                clearLocalAPIKey('openai');
                document.getElementById('claude-api-key-input').value = '';
                document.getElementById('gemini-api-key-input').value = '';
                document.getElementById('openai-api-key-input').value = '';
                updateKeyStatusBadges();
                console.log('ðŸ—‘ï¸ All API keys cleared');
                alert('All API keys have been cleared.');
            }
        });

        // Cancel API key modal
        document.getElementById('api-key-cancel').addEventListener('click', () => {
            document.getElementById('api-key-modal').style.display = 'none';
        });

        document.getElementById('api-key-btn').addEventListener('click', () => {
            showApiKeyModal(true);
        });

        // Unified AI Mode selector
        document.getElementById('unified-ai-mode-select').addEventListener('change', (e) => {
            const newMode = e.target.value;
            const parsed = parseUnifiedMode(newMode);

            // Check if this mode requires an API key
            if (parsed.requiresKey) {
                const provider = parsed.provider;
                const hasKey = getLocalAPIKey(provider);

                if (!hasKey) {
                    // Show helpful message about needing API key
                    const providerName = provider === 'anthropic' ? 'Claude' :
                                       provider === 'gemini' ? 'Gemini' : 'OpenAI';

                    alert(`ðŸ”‘ This mode requires your ${providerName} API key.\n\nPlease click the ðŸ”‘ API Key button to configure your key, then try again.`);

                    // Revert to previous mode
                    const currentMode = getUnifiedAIMode();
                    e.target.value = currentMode;
                    return;
                }
            }

            // Save the new mode
            setUnifiedAIMode(newMode);

            // Show informational message
            console.log(`âœ… AI Mode: ${parsed.description}`);

            // Show user-friendly toast
            if (parsed.enabled) {
                const modeLabel = e.target.options[e.target.selectedIndex].text;
                showToast(`âœ… AI Mode: ${modeLabel}`);
            } else {
                showToast('âŒ AI features disabled');
            }
        });

        // Initialize unified AI mode selector on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Attach Canvas view toggle
            const toggleBtn = document.getElementById('toggle-view-mode');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleViewMode);
            }

            // Initialize canvas event listeners
            initializeCanvasEvents();

            // Rebind expand/collapse buttons to use progressive collapse/expand
            // Wait a bit for TreeListy to finish its initialization
            setTimeout(() => {
                const expandBtn = document.getElementById('expand-btn');
                const collapseBtn = document.getElementById('collapse-btn');

                if (expandBtn) {
                    // Remove all existing listeners by cloning the button
                    const newExpandBtn = expandBtn.cloneNode(true);
                    expandBtn.parentNode.replaceChild(newExpandBtn, expandBtn);

                    // Add new listener with progressive expand
                    newExpandBtn.addEventListener('click', () => {
                        console.log('â¬‡ï¸ Progressive Expand clicked');
                        if (typeof canvasExpandOneLevel === 'function') {
                            canvasExpandOneLevel();
                        }
                    });
                }

                if (collapseBtn) {
                    // Remove all existing listeners by cloning the button
                    const newCollapseBtn = collapseBtn.cloneNode(true);
                    collapseBtn.parentNode.replaceChild(newCollapseBtn, collapseBtn);

                    // Add new listener with progressive collapse
                    newCollapseBtn.addEventListener('click', () => {
                        console.log('â¬†ï¸ Progressive Collapse clicked');
                        if (typeof canvasCollapseOneLevel === 'function') {
                            canvasCollapseOneLevel();
                        }
                    });
                }
            }, 500);

            // Bind Canvas toolbar buttons
            const autoLayoutSelect = document.getElementById('auto-layout-select');
            const gridToggleBtn = document.getElementById('grid-toggle');
            const resetViewBtn = document.getElementById('reset-view');
            const fitViewBtn = document.getElementById('fit-view');
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');

            if (autoLayoutSelect) {
                autoLayoutSelect.addEventListener('change', (e) => {
                    if (e.target.value) {
                        applyAutoLayout(e.target.value);
                        e.target.value = '';  // Reset to default
                    }
                });
            }

            // Cluster-by selector event listener
            const clusterBySelect = document.getElementById('cluster-by-select');
            if (clusterBySelect) {
                // Populate on load
                updateClusterByOptions();

                clusterBySelect.addEventListener('change', (e) => {
                    clusterByField = e.target.value;
                    if (clusterByField) {
                        console.log(`Clustering enabled by: ${clusterByField}`);
                        // Re-apply force-directed layout if currently in canvas mode
                        if (viewMode === 'canvas') {
                            applyForceDirectedLayout();
                            renderCanvas();
                        }
                    } else {
                        console.log('Clustering disabled');
                    }
                });
            }

            if (gridToggleBtn) {
                gridToggleBtn.addEventListener('click', toggleGrid);
            }

            if (resetViewBtn) {
                resetViewBtn.addEventListener('click', resetView);
            }

            if (fitViewBtn) {
                fitViewBtn.addEventListener('click', fitToView);
            }

            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    canvasZoom = Math.min(5, canvasZoom * 1.2);
                    updateCanvasTransform();
                });
            }

            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    canvasZoom = Math.max(0.1, canvasZoom / 1.2);
                    updateCanvasTransform();
                });
            }

            const savedMode = getUnifiedAIMode();
            const select = document.getElementById('unified-ai-mode-select');
            if (select) {
                select.value = savedMode;
            }
        });

        // Save API key(s)
        document.getElementById('api-key-save').addEventListener('click', () => {
            const claudeKey = document.getElementById('claude-api-key-input').value.trim();
            const geminiKey = document.getElementById('gemini-api-key-input').value.trim();
            const openaiKey = document.getElementById('openai-api-key-input').value.trim();
            const selectedProvider = document.getElementById('provider-select').value;

            // Validate keys if provided
            if (claudeKey && !claudeKey.startsWith('sk-ant-')) {
                alert('Invalid Claude API key format. Anthropic API keys start with "sk-ant-"');
                return;
            }

            if (geminiKey && !geminiKey.startsWith('AIza')) {
                alert('Invalid Gemini API key format. Google API keys typically start with "AIza"');
                return;
            }

            if (openaiKey && !openaiKey.startsWith('sk-')) {
                alert('Invalid OpenAI API key format. OpenAI API keys start with "sk-"');
                return;
            }

            // Check if selected provider has a key
            if (selectedProvider === 'anthropic' && !claudeKey && !getLocalAPIKey('anthropic')) {
                alert('Please enter a Claude API key, or switch to another provider.');
                return;
            }

            if (selectedProvider === 'gemini' && !geminiKey && !getLocalAPIKey('gemini')) {
                alert('Please enter a Gemini API key, or switch to another provider.');
                return;
            }

            if (selectedProvider === 'openai' && !openaiKey && !getLocalAPIKey('openai')) {
                alert('Please enter an OpenAI API key, or switch to another provider.');
                return;
            }

            // Save keys if provided (preserves existing keys if not changed)
            if (claudeKey) {
                setLocalAPIKey(claudeKey, 'anthropic');
                console.log('âœ… Claude API key saved');
            }

            if (geminiKey) {
                setLocalAPIKey(geminiKey, 'gemini');
                console.log('âœ… Gemini API key saved');
            }

            if (openaiKey) {
                setLocalAPIKey(openaiKey, 'openai');
                console.log('âœ… OpenAI API key saved');
            }

            // Save provider preference
            setAIProvider(selectedProvider);
            console.log(`âœ… Primary AI provider set to: ${selectedProvider}`);

            // Close modal
            document.getElementById('api-key-modal').style.display = 'none';

            // If we came from Analysis Mode, reopen it
            if (window.pendingAnalysisMode) {
                window.pendingAnalysisMode = false;
                document.getElementById('analyze-text-btn').click();
            }
        });

        // Function to check if API key is configured
        function checkAPIKeyConfigured(options = {}) {
            const { forcePrompt = false } = options;
            const localKey = getLocalAPIKey();
            if (localKey) {
                return true;
            }

            if (!forcePrompt && canUseServerlessAI()) {
                console.log('ðŸŒ No local API key found. Using Netlify serverless function for AI calls.');
                return true;
            }

            // No local key and serverless unavailable (or prompt requested) - show modal
            showApiKeyModal(false);
            return false;
        }

        // =============================================================================
        // AI REVIEW & ENHANCE SYSTEM
        // =============================================================================

        // Open AI Review modal and analyze tree
        document.getElementById('ai-review-btn').addEventListener('click', async () => {
            // Check if AI is enabled
            const aiMode = getGlobalAIMode();
            if (aiMode === 'off') {
                alert('âŒ AI features are currently disabled.\n\nPlease enable AI mode in the header (ðŸ¤– AI dropdown) to use AI Review.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            // Check if tree has content
            if (!hasExistingContent()) {
                alert('âš ï¸ Your tree is empty.\n\nPlease add some content first, then use AI Review to get suggestions for improvements.');
                return;
            }

            // Open modal and start analysis
            document.getElementById('ai-review-modal').style.display = 'flex';
            document.getElementById('ai-review-status').style.display = 'block';
            document.getElementById('ai-review-results').style.display = 'none';

            await performAIReview();
        });

        // Close AI Review modal
        document.getElementById('close-ai-review-modal').addEventListener('click', () => {
            document.getElementById('ai-review-modal').style.display = 'none';
        });

        // Re-analyze button
        document.getElementById('ai-review-again').addEventListener('click', async () => {
            document.getElementById('ai-review-status').style.display = 'block';
            document.getElementById('ai-review-results').style.display = 'none';
            await performAIReview();
        });

        // Perform AI Review of the tree
        async function performAIReview() {
            const pattern = PATTERNS[currentPattern];
            const tree = capexTree;

            try {
                // Build pattern-specific review prompt
                const reviewPrompt = buildReviewPrompt(tree, pattern);

                console.log('ðŸ”¬ Starting AI Review...');
                console.log('Pattern:', currentPattern);
                console.log('Tree:', tree.name);

                // Call AI with extended thinking for deep analysis
                const aiMode = getGlobalAIMode();
                const useExtendedThinking = aiMode === 'deep';

                // Extended thinking has budget_tokens = 5000, so maxTokens must be > 5000
                // Using 8000 to give 3000 tokens for actual response content
                const maxTokensForReview = useExtendedThinking ? 8000 : 4096;

                // Pattern-specific expert personas for AI Review
                const reviewExperts = {
                    philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments. Review for logical validity, premise strength, and dialectical completeness.',
                    sales: 'You are a sales strategist with 20 years of enterprise B2B experience. Review for pipeline health, deal qualification, and revenue optimization.',
                    thesis: 'You are an academic advisor helping graduate students structure rigorous research. Review for argument progression, citation quality, and scholarly standards.',
                    roadmap: 'You are a product manager experienced in agile development and feature prioritization. Review for execution readiness, story completeness, and technical feasibility.',
                    prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude, GPT-4, and other LLMs. Review for prompt clarity, few-shot example quality, output format specification, and edge case handling.',
                    book: 'You are a professional fiction editor and writing coach. Review for narrative flow, character development, and pacing.',
                    film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway). Review for visual storytelling, shot composition, and production feasibility.',
                    course: 'You are an instructional designer with expertise in curriculum development. Review for learning progression, assessment alignment, and instructional scaffolding.',
                    dialogue: 'You are a debate coach and rhetoric expert specializing in argumentation theory, logical fallacies, and persuasive communication. Review for argument strength, rhetorical effectiveness, fallacy identification, and evidence quality.',
                    filesystem: 'You are LibrarianAI, a filesystem organization expert. Review for folder structure clarity, file naming consistency, redundancy reduction, data quality, and organizational best practices. Focus on metadata enrichment opportunities and safe, non-destructive improvements.',
                    generic: `You are an expert ${pattern.name} analyst. Review the provided tree structure for completeness, redundancies, logical flow, and alignment with ${pattern.name} best practices.`
                };

                const expertPersona = reviewExperts[currentPattern] || reviewExperts.generic;

                const content = await callClaudeAPI(
                    reviewPrompt,
                    expertPersona + ' Provide specific, actionable suggestions.',
                    maxTokensForReview,
                    useExtendedThinking
                );

                // Parse the AI response and display results
                displayReviewResults(content);

            } catch (error) {
                console.error('âŒ AI Review error:', error);
                document.getElementById('ai-review-status').innerHTML = `
                    <div style="padding: 15px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">âŒ Error during analysis</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            ${error.message}
                        </div>
                    </div>
                `;
            }
        }

        // Build pattern-specific review prompt
        function buildReviewPrompt(tree, pattern) {
            const levels = pattern.levels;
            let prompt = `# ${pattern.name} Tree Review\n\n`;
            prompt += `**Project:** ${tree.name}\n`;
            prompt += `**Pattern:** ${pattern.name}\n\n`;

            // Count items
            const itemCounts = {
                phases: tree.children ? tree.children.length : 0,
                items: 0,
                subtasks: 0
            };

            if (tree.children) {
                tree.children.forEach(phase => {
                    // Support both 'items' (standard) and 'children' (filesystem pattern)
                    const nodeList = phase.items || phase.children || [];
                    if (nodeList.length > 0) {
                        itemCounts.items += nodeList.length;
                        nodeList.forEach(item => {
                            if (item.subtasks || item.children) {
                                itemCounts.subtasks += (item.subtasks || item.children || []).length;
                            }
                        });
                    }
                });
            }

            prompt += `**Current Structure:**\n`;
            prompt += `- ${itemCounts.phases} ${levels.phase}(s)\n`;
            prompt += `- ${itemCounts.items} ${levels.item}(s)\n`;
            prompt += `- ${itemCounts.subtasks} ${levels.subtask}(s)\n\n`;

            // Add tree content
            prompt += `## Tree Structure\n\n`;
            if (tree.children) {
                tree.children.forEach((phase, pIdx) => {
                    prompt += `### ${pIdx + 1}. ${phase.name}\n\n`;
                    if (phase.description) {
                        prompt += `${phase.description}\n\n`;
                    }

                    // Support both 'items' (standard) and 'children' (filesystem pattern)
                    const nodeList = phase.items || phase.children || [];
                    if (nodeList.length > 0) {
                        nodeList.forEach((item, iIdx) => {
                            prompt += `  **${iIdx + 1}. ${item.name}**\n`;
                            if (item.description) {
                                prompt += `  ${item.description}\n`;
                            }

                            // Add pattern-specific fields
                            const fields = Object.keys(item).filter(k =>
                                !['id', 'name', 'icon', 'type', 'description', 'subtasks', 'children', 'dependencies'].includes(k)
                            );

                            if (fields.length > 0) {
                                prompt += `  Fields: ${fields.join(', ')}\n`;
                            }
                            prompt += `\n`;
                        });
                    }
                    prompt += `\n`;
                });
            }

            // Pattern-specific review criteria
            prompt += `\n## Review Criteria\n\n`;
            prompt += `Please analyze this ${pattern.name} tree and provide:\n\n`;

            prompt += `1. **Completeness Check:**\n`;
            prompt += `   - Are all necessary ${levels.item.toLowerCase()}s present?\n`;
            prompt += `   - Are there obvious gaps in the ${levels.phase.toLowerCase()} coverage?\n`;
            prompt += `   - Are critical fields missing values?\n\n`;

            prompt += `2. **Redundancy Analysis:**\n`;
            prompt += `   - Are there duplicate or overlapping ${levels.item.toLowerCase()}s?\n`;
            prompt += `   - Can any ${levels.item.toLowerCase()}s be merged or consolidated?\n\n`;

            prompt += `3. **Logical Flow:**\n`;
            prompt += `   - Do the ${levels.phase.toLowerCase()}s follow a logical sequence?\n`;
            prompt += `   - Are dependencies properly structured?\n`;
            prompt += `   - Does the tree structure make sense for this ${pattern.name}?\n\n`;

            prompt += `4. **Pattern Alignment:**\n`;
            prompt += `   - Does this follow ${pattern.name} best practices?\n`;
            prompt += `   - Are pattern-specific fields used appropriately?\n`;
            prompt += `   - What could improve alignment with ${pattern.name} standards?\n\n`;

            // Pattern-specific additions
            if (currentPattern === 'philosophy') {
                prompt += `5. **Philosophical Rigor:**\n`;
                prompt += `   - Are premises logically valid?\n`;
                prompt += `   - Are objections comprehensive?\n`;
                prompt += `   - Are textual references adequate?\n\n`;
            } else if (currentPattern === 'sales') {
                prompt += `5. **Pipeline Health:**\n`;
                prompt += `   - Are all pipeline stages represented?\n`;
                prompt += `   - Are deal values and probabilities realistic?\n`;
                prompt += `   - Are key competitors identified?\n\n`;
            } else if (currentPattern === 'thesis') {
                prompt += `5. **Academic Standards:**\n`;
                prompt += `   - Is the argument progression clear?\n`;
                prompt += `   - Are citations sufficient?\n`;
                prompt += `   - Is chapter balance appropriate?\n\n`;
            } else if (currentPattern === 'roadmap') {
                prompt += `5. **Execution Readiness:**\n`;
                prompt += `   - Are user stories well-defined?\n`;
                prompt += `   - Are story points assigned?\n`;
                prompt += `   - Are technical risks identified?\n\n`;
            } else if (currentPattern === 'book') {
                prompt += `5. **Narrative Structure:**\n`;
                prompt += `   - Does the story arc flow naturally?\n`;
                prompt += `   - Are character arcs developed?\n`;
                prompt += `   - Is pacing appropriate?\n\n`;
            } else if (currentPattern === 'course') {
                prompt += `5. **Instructional Design:**\n`;
                prompt += `   - Is learning progression scaffolded?\n`;
                prompt += `   - Are assessments aligned with objectives?\n`;
                prompt += `   - Is content appropriately chunked?\n\n`;
            } else if (currentPattern === 'prompting') {
                prompt += `5. **Prompt Engineering Quality:**\n`;
                prompt += `   - Are system prompts clear and specific?\n`;
                prompt += `   - Do few-shot examples cover edge cases?\n`;
                prompt += `   - Are output formats well-defined?\n`;
                prompt += `   - Are chain-of-thought instructions effective?\n`;
                prompt += `   - Are test cases comprehensive?\n\n`;
            }

            prompt += `## Output Format\n\n`;
            prompt += `Provide your analysis in the following format:\n\n`;
            prompt += `**SUMMARY:** (2-3 sentences overview of tree quality)\n\n`;
            prompt += `**STRENGTHS:** (Bullet list of what's working well)\n\n`;
            prompt += `**GAPS:** (Specific missing items or fields)\n\n`;
            prompt += `**REDUNDANCIES:** (Items that could be merged)\n\n`;
            prompt += `**IMPROVEMENTS:** (Actionable suggestions to enhance the tree)\n\n`;

            return prompt;
        }

        // Display AI review results
        function displayReviewResults(response) {
            // Hide status, show results
            document.getElementById('ai-review-status').style.display = 'none';
            document.getElementById('ai-review-results').style.display = 'block';

            // Parse response sections
            const sections = {
                summary: extractSection(response, 'SUMMARY'),
                strengths: extractSection(response, 'STRENGTHS'),
                gaps: extractSection(response, 'GAPS'),
                redundancies: extractSection(response, 'REDUNDANCIES'),
                improvements: extractSection(response, 'IMPROVEMENTS')
            };

            // Build summary HTML
            const summaryHTML = `
                <div style="padding: 16px; background: var(--card-bg); border-radius: 8px; margin-bottom: 16px;">
                    ${sections.summary || 'Analysis complete.'}
                </div>

                ${sections.strengths ? `
                <div style="padding: 16px; background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #10b981; font-size: 14px;">âœ… Strengths</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.strengths)}</div>
                </div>
                ` : ''}

                ${sections.gaps ? `
                <div style="padding: 16px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #ef4444; font-size: 14px;">âš ï¸ Gaps</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.gaps)}</div>
                </div>
                ` : ''}

                ${sections.redundancies ? `
                <div style="padding: 16px; background: rgba(245, 158, 11, 0.1); border-left: 3px solid #f59e0b; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #f59e0b; font-size: 14px;">ðŸ”„ Redundancies</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.redundancies)}</div>
                </div>
                ` : ''}
            `;

            document.getElementById('ai-review-summary').innerHTML = summaryHTML;

            // Build suggestions HTML
            const suggestionsHTML = sections.improvements ? `
                <div style="padding: 16px; background: rgba(99, 102, 241, 0.1); border-left: 3px solid #6366f1; border-radius: 6px;">
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.improvements)}</div>
                </div>
            ` : '<div style="color: var(--text-secondary);">No specific improvements suggested.</div>';

            document.getElementById('ai-review-suggestions').innerHTML = suggestionsHTML;

            console.log('âœ… AI Review complete');
        }

        // Extract section from AI response
        function extractSection(text, sectionName) {
            const regex = new RegExp(`\\*\\*${sectionName}:\\*\\*\\s*([\\s\\S]*?)(?=\\n\\*\\*[A-Z]+:|$)`, 'i');
            const match = text.match(regex);
            return match ? match[1].trim() : '';
        }

        // Format markdown to HTML (simple version)
        function formatMarkdown(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
                .replace(/^- (.+)$/gm, '<li>$1</li>') // List items
                .replace(/(<li>.*<\/li>)/s, '<ul style="margin: 8px 0; padding-left: 20px;">$1</ul>') // Wrap in ul
                .replace(/\n\n/g, '<br><br>'); // Paragraphs
        }

        // =============================================================================
        // ANALYSIS MODE - TEXT TO TREE CONVERSION
        // =============================================================================

        let analysisText = '';
        let analysisFileName = '';

        // Open Analysis Modal
        // Track analysis mode (fresh or append)
        let analysisAppendMode = false;

        document.getElementById('analyze-text-btn').addEventListener('click', () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                window.pendingAnalysisMode = true;
                return;
            }

            // If tree has content, ask user if they want to append or start fresh
            if (hasExistingContent()) {
                showAnalysisModeChoice();
            } else {
                openAnalysisModal(false); // false = start fresh
            }
        });

        // Show modal to choose analysis mode
        function showAnalysisModeChoice() {
            const pattern = PATTERNS[currentPattern];
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ” Analyze Text Mode';

            // Count existing items
            const itemCount = capexTree.children?.reduce((sum, phase) =>
                sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 24px;">
                        Your tree already has <strong style="color: var(--treeplex-primary);">${itemCount} ${pattern.levels.item.toLowerCase()}(s)</strong>.
                        How would you like to proceed?
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="analysis-mode-append" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">âž•</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Append to Existing
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Analyze the text and add the results to your current tree. Great for combining multiple documents.
                            </div>
                        </div>

                        <div id="analysis-mode-fresh" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">ðŸ”„</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Replace Tree
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Clear the current tree and replace it with the analysis results. Starts from scratch.
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                        ðŸ’¡ <strong>Tip:</strong> Append mode lets you analyze multiple documents and combine them into one comprehensive tree.
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Add click handlers
            document.getElementById('analysis-mode-append').onclick = () => {
                modal.style.display = 'none';
                openAnalysisModal(true); // true = append mode
            };

            document.getElementById('analysis-mode-fresh').onclick = () => {
                modal.style.display = 'none';
                openAnalysisModal(false); // false = start fresh
            };
        }

        // Open the analysis modal
        function openAnalysisModal(appendMode) {
            analysisAppendMode = appendMode;

            const modal = document.getElementById('analysis-modal');
            modal.style.display = 'flex';

            // Reset form
            document.getElementById('analysis-text-input').value = '';
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            document.getElementById('char-count').textContent = '0 characters';
            document.getElementById('analysis-warning').style.display = 'none';
            analysisText = '';
            analysisFileName = '';

            // Update the AI mode display to show current global mode
            updateAnalysisModeDisplay();
        }

        // Update the AI mode display in Analyze Text modal
        function updateAnalysisModeDisplay() {
            const mode = getGlobalAIMode();
            const label = document.getElementById('analyze-mode-label');
            const description = document.getElementById('analyze-mode-description');

            if (mode === 'off') {
                label.textContent = 'âŒ Off';
                description.textContent = 'AI features are disabled. Enable AI mode in the header to use this feature.';
                description.style.color = '#EF4444';
            } else if (mode === 'quick') {
                label.textContent = 'âš¡ Quick';
                description.textContent = 'Fast pattern detection + basic structure. Recommended for most uses. Uses server API key (rate limited).';
                description.style.color = 'var(--text-secondary)';
            } else if (mode === 'deep') {
                label.textContent = 'ðŸ”¬ Deep';
                description.textContent = 'Comprehensive parsing with extended thinking (8192 tokens). Handles 3x more text. Requires your API key. No timeouts.';
                description.style.color = 'var(--text-secondary)';
            }
        }

        // Close Analysis Modal
        document.getElementById('analysis-cancel').addEventListener('click', () => {
            document.getElementById('analysis-modal').style.display = 'none';
        });

        // File Drop Zone - Click to browse
        const fileDropZone = document.getElementById('file-drop-zone');
        const fileInput = document.getElementById('analysis-file-input');

        fileDropZone.addEventListener('click', () => {
            fileInput.click();
        });

        // File selected via browse
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Drag and Drop handlers
        fileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--treeplex-primary)';
            fileDropZone.style.background = 'rgba(99, 102, 241, 0.05)';
        });

        fileDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';
        });

        fileDropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';

            const file = e.dataTransfer.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Handle file upload
        async function handleAnalysisFile(file) {
            // Check file type
            const validTypes = ['.txt', '.md'];
            const fileName = file.name.toLowerCase();
            const isValid = validTypes.some(type => fileName.endsWith(type));

            if (!isValid) {
                alert('Please upload a .txt or .md file only.');
                return;
            }

            // Show file name
            document.getElementById('selected-file-name').textContent = file.name;
            document.getElementById('file-name-display').style.display = 'block';
            analysisFileName = file.name;

            // Read file content
            const reader = new FileReader();
            reader.onload = (e) => {
                analysisText = e.target.result;

                // Clear text area since we're using file
                document.getElementById('analysis-text-input').value = '';

                // Update character count
                updateCharCount(analysisText.length);

                // Check file size and show warning if needed
                checkFileSize(analysisText.length);
            };
            reader.readAsText(file);
        }

        // Clear file button
        document.getElementById('clear-file-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            analysisText = '';
            analysisFileName = '';
            updateCharCount(0);
            document.getElementById('analysis-warning').style.display = 'none';
        });

        // Text area character count
        const textInput = document.getElementById('analysis-text-input');
        textInput.addEventListener('input', (e) => {
            analysisText = e.target.value;
            updateCharCount(analysisText.length);
            checkFileSize(analysisText.length);

            // Clear file if typing in text area
            if (analysisText.length > 0 && analysisFileName) {
                document.getElementById('analysis-file-input').value = '';
                document.getElementById('file-name-display').style.display = 'none';
                analysisFileName = '';
            }
        });

        function updateCharCount(count) {
            const charCountEl = document.getElementById('char-count');
            const words = count > 0 ? analysisText.trim().split(/\s+/).length : 0;
            charCountEl.textContent = `${count.toLocaleString()} characters (~${words} words)`;

            if (count > 50000) {
                charCountEl.style.color = '#ff9f43';
            } else {
                charCountEl.style.color = 'var(--text-secondary)';
            }
        }

        function checkFileSize(charCount) {
            const warningEl = document.getElementById('analysis-warning');
            const warningText = document.getElementById('analysis-warning-text');

            // Rough token estimate: 1 token â‰ˆ 4 characters
            const estimatedTokens = Math.ceil(charCount / 4);
            const estimatedWords = Math.ceil(charCount / 5);

            if (charCount > 100000) { // Will be truncated
                warningEl.style.display = 'block';
                warningText.textContent = `âš ï¸ Text is ${charCount.toLocaleString()} characters (~${estimatedWords.toLocaleString()} words). Will be automatically truncated to 100,000 characters (~25,000 words) to prevent timeouts. Consider pasting a shorter excerpt for best results.`;
            } else if (charCount > 75000) { // Large but ok
                warningEl.style.display = 'block';
                warningText.textContent = `Very large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis may take 15-25 seconds. Quick Mode strongly recommended.`;
            } else if (charCount > 50000) { // Large
                warningEl.style.display = 'block';
                warningText.textContent = `Large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Deep Mode will provide richer analysis but may take 20-30 seconds.`;
            } else if (charCount > 5000) {
                warningEl.style.display = 'block';
                warningText.textContent = `Medium text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis should take 15-30 seconds.`;
            } else {
                warningEl.style.display = 'none';
            }
        }

        // =============================================================================
        // AI PATTERN DETECTION & TEXT-TO-TREE CONVERSION
        // =============================================================================

        // Pattern detection function
        async function detectPattern(text) {
            const prompt = `Analyze the following text and determine the 3 most appropriate TreeListy patterns for organizing it.

AVAILABLE PATTERNS:
1. Generic Project - Universal structure for any project (Project â†’ Phase â†’ Item â†’ Task)
2. Sales Pipeline - Deal tracking across quarters (Pipeline â†’ Quarter â†’ Deal â†’ Action)
3. Academic Writing - Thesis/research paper structure (Thesis â†’ Chapter â†’ Section â†’ Point)
4. Product Roadmap - Feature development timeline (Product â†’ Quarter â†’ Feature â†’ Story)
5. Book Writing - Narrative structure (Book â†’ Part â†’ Chapter â†’ Scene)
6. Event Planning - Event organization and logistics (Event â†’ Stage â†’ Activity â†’ Task)
7. Fitness Program - Workout programs and exercises (Program â†’ Phase â†’ Workout â†’ Exercise)
8. Strategic Plan - Business initiatives and metrics (Strategy â†’ Pillar â†’ Initiative â†’ Action)
9. Course Design - Educational curriculum structure (Course â†’ Unit â†’ Lesson â†’ Exercise)
10. Film Production - Film/video production workflow (Film â†’ Phase â†’ Scene â†’ Shot)
11. Veo3 (Google) - Google Veo 3 AI video generation (Project â†’ Sequence â†’ Scene â†’ Shot/Frame)
12. Sora2 (OpenAI) - OpenAI Sora 2 AI video generation (Project â†’ Sequence â†’ Beat â†’ Shot/Remix)
13. Philosophy - Philosophical arguments and treatises (Treatise â†’ Book â†’ Argument â†’ Premise)
14. Prompt Engineering - AI prompts and testing (Library â†’ Category â†’ Prompt â†’ Test Case)
15. Family Tree - Genealogical documentation (Family â†’ Generation â†’ Person â†’ Event)
16. Dialogue & Rhetoric - Analyze debates, conversations, and arguments (Conversation â†’ Speaker â†’ Statement â†’ Point)

TEXT TO ANALYZE:
${text.substring(0, 5000)}${text.length > 5000 ? '\n\n[... truncated for analysis ...]' : ''}

DETECTION HINTS:
- If text contains prompt-related terms like "system prompt", "user prompt", "few-shot examples", "chain-of-thought", "temperature", "max tokens" â†’ Prompt Engineering
- If text looks like AI instructions or discusses prompt design â†’ Prompt Engineering
- If text mentions AI models (Claude, GPT, Anthropic, OpenAI) in context of prompting â†’ Prompt Engineering
- If text contains debate/dialogue terms like "speaker", "argument", "rhetoric", "fallacy", "premise", "counterargument", "rebuttal", "debate", "conversation" â†’ Dialogue & Rhetoric
- If text is a transcript of a conversation, political debate, or online discussion â†’ Dialogue & Rhetoric
- If text analyzes persuasion, argumentation, or rhetorical techniques â†’ Dialogue & Rhetoric

Respond with ONLY a valid JSON object in this exact format:
{
  "recommendations": [
    {
      "pattern": "pattern-key",
      "patternName": "Pattern Display Name",
      "confidence": 9,
      "reasoning": "Brief explanation of why this pattern fits"
    }
  ]
}

Provide exactly 3 recommendations, ranked by confidence (1-10). Use these pattern keys: generic, sales, thesis, roadmap, book, event, fitness, strategy, course, film, philosophy, prompting, familytree, dialogue`;

            const response = await callClaudeAPI(prompt);

            try {
                // Extract JSON from response
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    return result.recommendations;
                }
            } catch (e) {
                console.error('Failed to parse pattern detection response:', e);
            }

            // Fallback to generic
            return [{
                pattern: 'generic',
                patternName: 'Generic Project',
                confidence: 5,
                reasoning: 'Default fallback pattern'
            }];
        }

        // Helper function to fix common JSON issues
        function repairJSON(jsonText) {
            // SIMPLE APPROACH: Replace all problematic characters with spaces or escaped versions
            // This is more reliable than complex regex matching

            // Replace literal newlines, carriage returns, and tabs with spaces
            // These shouldn't be in JSON strings - Claude should use \n instead
            jsonText = jsonText.replace(/\r\n/g, ' ');
            jsonText = jsonText.replace(/\r/g, ' ');
            jsonText = jsonText.replace(/\n/g, ' ');
            jsonText = jsonText.replace(/\t/g, ' ');

            // Remove other control characters (ASCII 0-31 except space)
            jsonText = jsonText.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');

            // Remove trailing commas before closing brackets/braces (run multiple times to catch nested cases)
            let previousText;
            do {
                previousText = jsonText;
                jsonText = jsonText.replace(/,(\s*[}\]])/g, '$1');
            } while (jsonText !== previousText);

            // Remove comments (// and /* */)
            jsonText = jsonText.replace(/\/\/.*$/gm, '');
            jsonText = jsonText.replace(/\/\*[\s\S]*?\*\//g, '');

            return jsonText;
        }

        // PROMPT IMPROVEMENT: Special handler for Prompt Engineering pattern
        // Takes a basic prompt and generates comprehensive improved version with best practices
        async function improvePromptWithAI(basicPrompt, mode = 'quick') {
            console.log(`ðŸ§  Improving prompt using ${mode} mode...`);

            const systemPrompt = `You are an expert prompt engineer who specializes in improving prompts using OpenAI and Anthropic best practices.

ðŸš¨ CRITICAL UNDERSTANDING: You are NOT answering questions. You are NOT providing information. You are CREATING PROMPTS.

Your ONLY task: Take a basic topic/idea/draft and CREATE a comprehensive prompt that another AI would use to help with that topic.

Example workflow:
- Input: "early signs of parkinsons" â†’ CREATE a prompt for an AI to help identify early Parkinson's signs
- Input: "analyze sentiment" â†’ CREATE a sentiment analysis prompt
- Input: "plan a vacation" â†’ CREATE a vacation planning prompt

You are a PROMPT BUILDER, not a question answerer.

BEST PRACTICES TO APPLY:
1. **System Prompt**: Clear role definition, context, constraints, tone
2. **User Prompt Template**: Structured with {{variables}}, clear instructions, step-by-step guidance
3. **Few-Shot Examples**: 2-3 high-quality inputâ†’output examples showing desired behavior
4. **Chain-of-Thought**: Instructions for showing reasoning process (if applicable)
5. **Output Format**: Exact structure specification (JSON schema, markdown template, etc.)
6. **Edge Cases**: Handle ambiguity, missing data, errors
7. **Variables**: Identify dynamic parts as {{variable_name}}
8. **Prefill** (Claude): Suggested response starter for tone/format control

CRITICAL: Return ONLY valid JSON. No explanations, no markdown, no text before or after.`;

            const userPrompt = `Your task: CREATE a production-ready prompt about the following topic/concept/use-case:

TOPIC: "${basicPrompt}"

Your job is to DESIGN A PROMPT that another AI could use to help with this topic. You are NOT answering this as a question. You are CREATING a ready-to-use prompt.

ðŸŽ¯ What you MUST do:
- Take the topic "${basicPrompt}" and design a comprehensive prompt FOR an AI to handle this topic
- Example: If topic is "early signs of parkinsons" â†’ CREATE a prompt FOR an AI to help identify/discuss Parkinson's signs
- Example: If topic is "skin care" â†’ CREATE a prompt FOR an AI to provide skin care guidance
- Example: If topic is a draft prompt â†’ IMPROVE it into a production version

ðŸš« What you must NOT do:
- DO NOT answer "${basicPrompt}" as if it's a question posed to you
- DO NOT try to provide information about the topic
- DO NOT give medical advice, recommendations, or analysis
- You are a PROMPT ARCHITECT building a tool, not a subject matter expert answering queries

ðŸŽ¨ CRITICAL: Create COMPREHENSIVE, INSTRUCTION-RICH prompts that guide AI behavior:
- Generate prompts that INSTRUCT and CONFIGURE the AI, not simple questions that get answered
- Combine system prompt + user prompt into one comprehensive instruction block
- Include: role definition, process steps, output format, examples, constraints
- The user will paste this entire block into ChatGPT/Claude to configure it

BAD (gets answered immediately): "Help me create a skin care routine"
GOOD (instructs the AI): "You are an expert dermatologist. When helping with skin care: 1) Ask about skin type and concerns 2) Provide structured routine with product recommendations 3) Return as JSON with ingredients, frequency, and reasoning for each step. Now help me create a comprehensive skin care routine."

Now create a SINGLE comprehensive prompt that combines:
1. Role definition and expertise (system-level instructions)
2. Process steps and methodology (how the AI should think)
3. Output format specification (structured data format)
4. Few-shot examples (if helpful)
5. Constraints and edge cases (what to avoid)
6. The actual user request (at the end)

This single prompt will be in the userPromptTemplate field.

Return ONLY this JSON structure:
{
  "projectName": "Descriptive name for this prompt (e.g., 'Skin Care Routine Assistant')",
  "description": "Brief 1-sentence description of what this prompt does",
  "phases": [
    {
      "name": "Production Prompt",
      "subtitle": "Ready to use with Claude/GPT-4",
      "items": [
        {
          "name": "Improved: [Brief name based on use case]",
          "description": "Production-ready prompt that works immediately",
          "itemType": "task-instruction",
          "systemPrompt": "You are an expert [domain]. [Context]. [Constraints]. [Tone].",
          "userPromptTemplate": "Comprehensive instruction-rich prompt combining: role definition + process steps + output format + constraints + user request. This entire text is what the user pastes into the AI.",
          "fewShotExamples": "<example>\\nUser: [example input 1]\\nAssistant: [example output 1]\\n</example>\\n\\n<example>\\nUser: [example input 2]\\nAssistant: [example output 2]\\n</example>",
          "chainOfThought": "Think step by step: 1) [step], 2) [step], 3) [step]. Show your reasoning.",
          "outputFormat": "Return JSON: {\\"field1\\": \\"description\\", \\"field2\\": \\"description\\"}",
          "structuralTags": "<thinking>\\nReasoning process\\n</thinking>\\n<answer>\\nFinal response\\n</answer>",
          "assistantPrefill": "Here is my analysis:",
          "modelTarget": "Claude 3.5 Sonnet",
          "temperature": 0.7,
          "maxTokens": 2000
        }
      ]
    }
  ]
}

RULES:
- Infer use case from basic prompt (chatbot? search? analysis? recommendation?)
- Create realistic, helpful few-shot examples
- userPromptTemplate must be COMPREHENSIVE and INSTRUCTION-RICH (not a simple question)
- Combine role + process + format + request into single prompt that configures AI behavior
- NO {{variables}} or placeholders - make it work immediately when pasted
- Chain-of-thought only if task requires reasoning
- Output format should match the use case (JSON for APIs, markdown for reports, etc.)
- System prompt should be professional and comprehensive
- NO trailing commas in JSON

EXAMPLE of a GOOD userPromptTemplate:
"You are an expert skin care advisor with dermatology knowledge. When providing skin care guidance: 1) First, ask clarifying questions about skin type, concerns, and sensitivities 2) Then provide a comprehensive routine with specific product recommendations 3) Include ingredients, application frequency, and scientific reasoning 4) Return your recommendation as JSON with 'routine' array and 'additional_tips' array. Now, help me create a personalized skin care routine."
- Escape quotes inside strings with backslash`;

            // Deep mode uses extended thinking (budget_tokens = 5000)
            // So maxTokens must be > 5000. Using 8000 to give 3000 tokens for actual response.
            const maxTokens = mode === 'deep' ? 8000 : 2048;
            const useThinking = mode === 'deep';

            const response = await callClaudeAPI(userPrompt, systemPrompt, maxTokens, useThinking);

            try {
                // Extract JSON from response
                let jsonText = response.trim();
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                const firstBrace = jsonText.indexOf('{');
                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ðŸ§  Skipping text before JSON:', jsonText.substring(0, firstBrace));
                    jsonText = jsonText.substring(firstBrace);
                }

                // Find matching closing brace
                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = 0; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Could not find matching closing brace in JSON');
                }

                jsonText = jsonText.substring(0, endPos + 1);

                const parsed = JSON.parse(jsonText);
                console.log('âœ… Prompt improved successfully:', parsed.projectName);
                return parsed;

            } catch (e) {
                console.error('âŒ JSON parsing error:', e);
                console.error('Response:', response);
                throw new Error(`Failed to improve prompt. AI response was not valid JSON: ${e.message}`);
            }
        }

        // Quick Mode: Basic structure conversion with semantic chunking
        async function convertTextToTreeQuick(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            // SPECIAL CASE: Prompt Engineering pattern - improve the prompt instead of extracting
            if (pattern === 'prompting') {
                return await improvePromptWithAI(text, 'quick');
            }

            // =========================================================================
            // SEMANTIC CHUNKING PREPROCESSING
            // =========================================================================
            console.log('ðŸ§  Starting semantic chunking preprocessing...');
            const chunker = new SemanticChunker();
            let chunks;

            // Show chunking status in UI
            const modalBody = document.getElementById('modal-body');
            if (modalBody) {
                modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">ðŸ§  Analyzing text structure...</p>';
            }

            // Tier 2: Scientific approach (if embedding provider available)
            if (EmbeddingManager.hasProvider()) {
                console.log('âœ… Embedding provider detected - using scientific semantic chunking');
                try {
                    chunks = await chunker.chunkByEmbedding(text);
                } catch (error) {
                    console.warn('âš ï¸ Semantic chunking failed, falling back to structural split:', error);
                    chunks = chunker.structuralSplit(text);
                }
            } else {
                // Tier 1: Structural fallback
                console.log('ðŸ“ No embedding provider - using structural split');
                chunks = chunker.structuralSplit(text);
            }

            console.log(`âœ… Text split into ${chunks.length} semantic chunks`);

            // Show chunk visualization
            if (modalBody && chunks.length > 1) {
                const chunkLengths = chunks.map(c => c.text.length);
                const maxLength = Math.max(...chunkLengths);
                const bars = chunks.map((chunk, i) => {
                    const width = (chunk.text.length / maxLength) * 100;
                    return `<div style="background: linear-gradient(90deg, rgba(99, 102, 241, 0.6), rgba(139, 92, 246, 0.6)); height: 8px; width: ${width}%; border-radius: 4px; margin: 2px 0;" title="Chunk ${i + 1}: ${chunk.text.length} chars"></div>`;
                }).join('');

                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div class="spinner"></div>
                            <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600;">
                                ðŸ§  Detected ${chunks.length} Semantic Sections
                            </p>
                            <p style="color: var(--text-secondary); font-size: 13px; margin-top: 4px;">
                                Processing each section with ${patternConfig.name} pattern...
                            </p>
                        </div>
                        <div style="padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3);">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Chunk size distribution:</div>
                            ${bars}
                        </div>
                    </div>
                `;
            }

            // Generate quick field hints (top 5 most important fields)
            let quickFieldHints = '';
            const importantFields = [];

            Object.keys(fields).forEach(fieldKey => {
                const fieldConfig = fields[fieldKey];
                // Skip non-field properties
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }
                if (fieldConfig.label) {
                    let hint = `- ${fieldKey}: ${fieldConfig.label}`;
                    if (fieldConfig.type === 'number') {
                        hint += ` (number)`;
                    } else if (fieldConfig.type === 'date') {
                        hint += ` (YYYY-MM-DD)`;
                    } else if (fieldConfig.type === 'select' && fieldConfig.options) {
                        hint += ` (${fieldConfig.options.slice(0, 3).join('/')})`;
                    }
                    importantFields.push(hint);
                }
            });

            if (importantFields.length > 0) {
                quickFieldHints = `\n\nKEY FIELDS TO EXTRACT (if mentioned in text):\n${importantFields.slice(0, 6).join('\n')}\n`;
            }

            // Add item types if available
            let itemTypeHints = '';
            if (patternConfig.types && patternConfig.types.length > 0) {
                const typesList = patternConfig.types.slice(0, 8).map(t => t.value).join(', ');
                itemTypeHints = `\n\nITEM TYPES: Use these specific types: ${typesList}\n`;
            }

            // Pattern-specific subtask guidance
            function getPatternSubtaskGuidance(pattern) {
                const guidance = {
                    philosophy: `For ${levels.item}s (Claims), REQUIRED 1-3 ${levels.subtask}s (Supports): premises, objections, supporting evidence, textual references. NEVER skip subItems.`,
                    sales: `For ${levels.item}s (deals), add ${levels.subtask}s like: follow-up actions, next steps, activities to close`,
                    thesis: `For ${levels.item}s (arguments), add ${levels.subtask}s like: supporting evidence, citations, counter-arguments`,
                    roadmap: `For ${levels.item}s (features), add ${levels.subtask}s like: implementation steps, technical tasks, acceptance criteria`,
                    book: `For ${levels.item}s (chapters), add ${levels.subtask}s like: scenes, key moments, character developments`,
                    course: `For ${levels.item}s (modules), add ${levels.subtask}s like: lessons, activities, assessments, practice exercises`,
                    film: `For ${levels.item}s (scenes), add ${levels.subtask}s like: specific shots, camera movements, lighting changes`,
                    prompting: `For ${levels.item}s (prompts), add ${levels.subtask}s like: test cases, variations, edge cases to handle`,
                    generic: `For ${levels.item}s, add ${levels.subtask}s like: steps, components, or sub-elements needed`
                };
                return guidance[pattern] || guidance.generic;
            }

            // Pattern-specific instructions for Quick Mode
            let patternSpecialInstructions = '';
            if (pattern === 'philosophy') {
                patternSpecialInstructions = `

âš ï¸ PHILOSOPHY PATTERN REQUIREMENTS (Academic Standard):

## SCHOLARLY REQUIREMENTS
Your output must include:
1. **NAMED SECONDARY SOURCES**: Cite at least 2-3 specific scholars who have written on this text (e.g., "Vlastos (1991)", "Williams (1978)")
2. **STANDARD OBJECTIONS**: Name specific objections with their associated philosophers (e.g., "Lichtenberg's objection", "Cartesian Circle")
3. **TRADITION PLACEMENT**: Identify the specific philosophical school (Platonic, Rationalist, Empiricist, etc.)

## STRUCTURE
1. Create 3-5 movements (phases) following the text's argumentative structure
2. EVERY claim MUST have 1-3 subItems (supporting premises, evidence, or reasoning)
3. Include IMPLICIT premises (unstated assumptions required for validity)

## ITEM TYPES (Use precisely)
- question: Interrogative moves that drive inquiry forward
- premise: Explicit foundational claims
- implicit-premise: Unstated assumptions required for validity
- definition: Attempts to characterize a concept
- distinction: Conceptual clarification separating ideas
- thought-experiment: Hypothetical scenario testing intuitions
- refutation: Counter-arguments that challenge positions
- objection: Standard criticism from the literature
- conclusion: Claims derived from prior reasoning

## METADATA (Required)
Include in root metadata: tradition, method, keyTerms, interlocutors, secondarySources, standardObjections

âš ï¸ KEY: Name SPECIFIC scholars and objections. Do not use generic placeholders.
`;
            } else if (pattern === 'film') {
                patternSpecialInstructions = `\n\nâš ï¸ AI VIDEO: Create ACTUAL SCENES (not workflows about making videos). Each item = one shot. Include videoPrompt, cameraMovement, visualStyle, duration.\n`;
            }

            // =========================================================================
            // CHUNK PROCESSING LOOP
            // =========================================================================
            const allPhasesCollected = [];
            let projectName = '';

            for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                const chunk = chunks[chunkIndex];
                console.log(`ðŸ”„ Processing chunk ${chunkIndex + 1}/${chunks.length} (${chunk.text.length} chars)`);

                // Pattern-aware context for this specific chunk
                const chunkPrompt = `Extract items for the ${patternConfig.name} pattern from this SPECIFIC SECTION of a larger document (Section ${chunkIndex + 1}/${chunks.length}).

PATTERN HIERARCHY:
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}
${itemTypeHints}${quickFieldHints}${patternSpecialInstructions}

SECTION TEXT:
${chunk.text}

INSTRUCTIONS (BE CONCISE TO AVOID TIMEOUT):
1. Identify hierarchical structure in THIS SECTION ONLY
2. Create 1-2 phases (${levels.phase}s) for content in this section
3. For each phase, create 2-4 items (${levels.item}s)
4. Add 2-3 ${levels.subtask}s to items that need them
   â†’ ${getPatternSubtaskGuidance(pattern)}
5. Keep descriptions SHORT (under 100 characters)
6. Extract key fields if mentioned
7. ONLY extract content from this section - don't infer content from other sections

JSON FORMATTING RULES (CRITICAL):
- NO trailing commas
- ONLY plain JSON - no markdown, no explanations
- Start response with { and end with }

Respond with ONLY valid JSON:
{
  "projectName": "Section ${chunkIndex + 1} or inferred name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle",
      "icon": "ðŸ“‹",
      "items": [
        {
          "name": "Item name",
          "description": "Brief description",
          "itemType": "type",
          "subItems": [
            { "name": "${levels.subtask} 1", "description": "Detail" }
          ]
        }
      ]
    }
  ]
}`;

                const response = await callClaudeAPI(chunkPrompt, '', 1500, false);

                // Parse JSON response from this chunk
                try {
                    let jsonText = response.trim();

                    // Remove markdown code blocks if present
                    jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    // Find the FIRST complete JSON object using proper brace matching
                    const firstBrace = jsonText.indexOf('{');

                    if (firstBrace === -1) {
                        console.warn(`âš ï¸ Chunk ${chunkIndex + 1}: No JSON found, skipping`);
                        continue;
                    }

                    if (firstBrace > 0) {
                        console.log(`ðŸª„ Chunk ${chunkIndex + 1}: Skipping text before JSON`);
                    }

                    let depth = 0;
                    let endPos = -1;
                    let inString = false;
                    let escapeNext = false;

                    for (let i = firstBrace; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            inString = !inString;
                            continue;
                        }

                        if (!inString) {
                            if (char === '{') depth++;
                            else if (char === '}') {
                                depth--;
                                if (depth === 0) {
                                    endPos = i + 1;
                                    break;
                                }
                            }
                        }
                    }

                    if (endPos === -1) {
                        console.warn(`âš ï¸ Chunk ${chunkIndex + 1}: Incomplete JSON, skipping`);
                        continue;
                    }

                    jsonText = jsonText.substring(firstBrace, endPos);

                    // Parse JSON
                    let parsed;
                    try {
                        parsed = JSON.parse(jsonText);
                    } catch (firstError) {
                        console.warn(`ðŸª„ Chunk ${chunkIndex + 1}: JSON parse failed, attempting sanitization...`, firstError.message);

                        // Sanitize JSON: Fix control characters in string values
                        let sanitized = '';
                        let inString = false;
                        let escapeNext = false;

                        for (let i = 0; i < jsonText.length; i++) {
                            const char = jsonText[i];

                            if (escapeNext) {
                                sanitized += char;
                                escapeNext = false;
                                continue;
                            }

                            if (char === '\\') {
                                sanitized += char;
                                escapeNext = true;
                                continue;
                            }

                            if (char === '"') {
                                sanitized += char;
                                inString = !inString;
                                continue;
                            }

                            // If we're inside a string value, escape control characters
                            if (inString) {
                                if (char === '\n') {
                                    sanitized += '\\n';
                                } else if (char === '\r') {
                                    sanitized += '\\r';
                                } else if (char === '\t') {
                                    sanitized += '\\t';
                                } else if (char.charCodeAt(0) < 32) {
                                    sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                                } else {
                                    sanitized += char;
                                }
                            } else {
                                sanitized += char;
                            }
                        }

                        jsonText = sanitized;
                        console.log(`âœ… Chunk ${chunkIndex + 1}: JSON sanitized successfully`);
                        parsed = JSON.parse(jsonText);
                    }

                    // Aggregate results from this chunk
                    if (!projectName && parsed.projectName) {
                        projectName = parsed.projectName;
                        console.log(`ðŸ“ Project name extracted from chunk ${chunkIndex + 1}: ${projectName}`);
                    }

                    if (parsed.phases && parsed.phases.length > 0) {
                        console.log(`âœ… Chunk ${chunkIndex + 1}: Extracted ${parsed.phases.length} phases`);
                        allPhasesCollected.push(...parsed.phases);
                    }

                } catch (e) {
                    console.error(`âŒ Chunk ${chunkIndex + 1} failed to parse:`, e);
                    console.error('Response (first 500 chars):', response.substring(0, 500));
                    // Continue to next chunk instead of failing entirely
                }
            }

            // =========================================================================
            // MERGE DUPLICATE PHASES AND RETURN AGGREGATED RESULT
            // =========================================================================
            console.log(`âœ… All chunks processed. Total phases collected: ${allPhasesCollected.length}`);

            // Merge phases with the same name
            const phaseMap = new Map();
            allPhasesCollected.forEach(phase => {
                const phaseName = phase.name;
                if (phaseMap.has(phaseName)) {
                    // Merge items into existing phase
                    const existingPhase = phaseMap.get(phaseName);
                    if (phase.items && phase.items.length > 0) {
                        existingPhase.items.push(...phase.items);
                    }
                } else {
                    // Add new phase
                    phaseMap.set(phaseName, { ...phase });
                }
            });

            const mergedPhases = Array.from(phaseMap.values());
            console.log(`âœ… After merging duplicates: ${mergedPhases.length} unique phases`);

            // Use a generic project name if none was extracted
            if (!projectName) {
                projectName = `${patternConfig.name} Project`;
            }

            return {
                projectName: projectName,
                phases: mergedPhases
            };
        }

        // OLD SINGLE-CHUNK FALLBACK (DEPRECATED - keeping for reference)
        async function convertTextToTreeQuick_LEGACY(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the FIRST complete JSON object using proper brace matching
                const firstBrace = jsonText.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ðŸª„ [Quick] Skipping text before JSON:', jsonText.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Incomplete JSON object in AI response (no closing brace found).');
                }

                if (endPos < jsonText.length) {
                    console.log('ðŸª„ [Quick] Skipping text after JSON:', jsonText.substring(endPos, Math.min(endPos + 100, jsonText.length)));
                }

                jsonText = jsonText.substring(firstBrace, endPos);

                console.log('ðŸª„ [Quick] Extracted JSON length:', jsonText.length);

                // Sanitize JSON: Fix control characters in string values (same as wizard)
                let parsed;
                try {
                    parsed = JSON.parse(jsonText);
                } catch (firstError) {
                    console.warn('ðŸª„ [Quick] JSON parse failed, attempting sanitization...', firstError.message);

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonText = sanitized;
                    console.log('âœ… [Quick] JSON sanitized successfully');
                    parsed = JSON.parse(jsonText);
                }

                return parsed;
            } catch (e) {
                console.error('Failed to parse quick conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('ðŸ”§ Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('âœ… JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('âŒ Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Deep Mode: Detailed parsing with field extraction
        async function convertTextToTreeDeep(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            // SPECIAL CASE: Prompt Engineering pattern - improve the prompt instead of extracting
            if (pattern === 'prompting') {
                return await improvePromptWithAI(text, 'deep');
            }

            // =========================================================================
            // SEMANTIC CHUNKING PREPROCESSING (Deep Mode)
            // =========================================================================
            console.log('ðŸ§  [Deep] Starting semantic chunking preprocessing...');
            const chunker = new SemanticChunker();
            let chunks;

            // Show chunking status in UI
            const modalBody = document.getElementById('modal-body');
            if (modalBody) {
                modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">ðŸ§  Analyzing text structure (Deep Mode)...</p>';
            }

            // Tier 2: Scientific approach (if embedding provider available)
            if (EmbeddingManager.hasProvider()) {
                console.log('âœ… [Deep] Embedding provider detected - using scientific semantic chunking');
                try {
                    chunks = await chunker.chunkByEmbedding(text);
                } catch (error) {
                    console.warn('âš ï¸ [Deep] Semantic chunking failed, falling back to structural split:', error);
                    chunks = chunker.structuralSplit(text);
                }
            } else {
                // Tier 1: Structural fallback
                console.log('ðŸ“ [Deep] No embedding provider - using structural split');
                chunks = chunker.structuralSplit(text);
            }

            console.log(`âœ… [Deep] Text split into ${chunks.length} semantic chunks`);

            // Show chunk visualization
            if (modalBody && chunks.length > 1) {
                const chunkLengths = chunks.map(c => c.text.length);
                const maxLength = Math.max(...chunkLengths);
                const bars = chunks.map((chunk, i) => {
                    const width = (chunk.text.length / maxLength) * 100;
                    return `<div style="background: linear-gradient(90deg, rgba(244, 63, 94, 0.6), rgba(251, 146, 60, 0.6)); height: 10px; width: ${width}%; border-radius: 4px; margin: 2px 0;" title="Chunk ${i + 1}: ${chunk.text.length} chars"></div>`;
                }).join('');

                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div class="spinner"></div>
                            <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600;">
                                ðŸ§  Deep Mode: ${chunks.length} Semantic Sections Detected
                            </p>
                            <p style="color: var(--text-secondary); font-size: 13px; margin-top: 4px;">
                                Performing comprehensive extraction on each section...
                            </p>
                        </div>
                        <div style="padding: 12px; background: rgba(244, 63, 94, 0.1); border-radius: 8px; border: 1px solid rgba(244, 63, 94, 0.3);">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Chunk size distribution:</div>
                            ${bars}
                        </div>
                    </div>
                `;
            }

            // Generate dynamic field extraction guide from pattern.fields
            function generateFieldExtractionGuide(pattern) {
                const patternDef = PATTERNS[pattern];
                const fields = patternDef.fields || {};

                let guide = `\n${patternDef.name.toUpperCase()} PATTERN - EXTRACT THESE FIELDS FOR EVERY ITEM:\n`;

                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];

                    // Skip non-field properties
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    if (fieldConfig.label) {
                        guide += `- ${fieldKey}: ${fieldConfig.label}`;

                        // Add extraction hints based on field type
                        if (fieldConfig.type === 'number') {
                            guide += ` (extract numeric value`;
                            if (fieldConfig.min !== undefined || fieldConfig.max !== undefined) {
                                guide += `, valid range ${fieldConfig.min || 0}-${fieldConfig.max || 'âˆž'}`;
                            }
                            if (fieldConfig.step !== undefined) {
                                guide += `, use increments of ${fieldConfig.step}`;
                            }
                            guide += `)`;
                        } else if (fieldConfig.type === 'date') {
                            guide += ` (extract date, format as YYYY-MM-DD)`;
                        } else if (fieldConfig.type === 'select' && fieldConfig.options) {
                            guide += ` (choose from: ${fieldConfig.options.join(', ')})`;
                        } else if (fieldConfig.type === 'textarea') {
                            guide += ` (detailed text, 100-300 characters)`;
                        } else if (fieldConfig.type === 'text' && fieldConfig.placeholder) {
                            guide += ` (e.g., "${fieldConfig.placeholder}")`;
                        }

                        if (fieldConfig.helpText) {
                            guide += ` - ${fieldConfig.helpText}`;
                        }

                        guide += `\n`;
                    }
                });

                // Add item types
                if (patternDef.types && patternDef.types.length > 0) {
                    guide += `\nITEM TYPES FOR ${patternDef.name.toUpperCase()}: Use specific types from this list:\n`;
                    const typesList = patternDef.types.map(t => t.value).join(', ');
                    guide += typesList + '\n';
                    guide += `(NOT generic types - use the specific types above to categorize each item)\n`;
                }

                // Add PM tracking fields if pattern supports it
                if (fields.includeTracking && patternDef.fields.trackingFor) {
                    guide += `\nPM TRACKING FIELDS (for ${patternDef.fields.trackingFor.join('/')}s):\n`;
                    guide += `- pmStatus: Task status (choose from: To Do, In Progress, Blocked, Done)\n`;
                    guide += `- pmAssignee: Person responsible (if mentioned in text)\n`;
                    guide += `- pmProgress: Completion percentage (0-100)\n`;
                    guide += `- pmPriority: Priority level (Low, Medium, High, Critical)\n`;
                    guide += `- pmDueDate: Deadline (format YYYY-MM-DD if mentioned)\n`;
                    guide += `- pmStartDate: Start date (format YYYY-MM-DD if mentioned)\n`;
                }

                // Add dependencies hint
                if (fields.includeDependencies) {
                    guide += `\nDEPENDENCIES:\n`;
                    guide += `- Identify which ${levels.item}s depend on others\n`;
                    guide += `- Look for: "depends on", "requires", "after", "builds on", "assumes"\n`;
                    guide += `- Format as array of item IDs: ["item-0-1", "item-0-2"]\n`;
                }

                return guide;
            }

            const patternFieldGuide = generateFieldExtractionGuide(pattern);

            // Pattern-specific subtask guidance for Deep Mode
            function getDeepModeSubtaskGuidance(pattern) {
                const guidance = {
                    philosophy: `Philosophy: ${levels.subtask}s = premises, objections, supporting evidence, citations. REQUIRED: 1-3 subItems per claim. NEVER skip subItems.`,
                    sales: `Sales: ${levels.subtask}s = follow-up actions, meeting notes, deliverables, next steps to advance the deal`,
                    thesis: `Academic: ${levels.subtask}s = supporting arguments, citations, evidence, counter-arguments to address`,
                    roadmap: `Engineering: ${levels.subtask}s = implementation tasks, technical specs, acceptance criteria, testing steps`,
                    book: `Narrative: ${levels.subtask}s = individual scenes, character moments, plot developments, transitions`,
                    course: `Education: ${levels.subtask}s = lessons, activities, assessments, practice exercises, readings`,
                    film: `Film: ${levels.subtask}s = specific shots, camera angles, lighting changes, actor blocking, technical details`,
                    prompting: `Prompting: ${levels.subtask}s = test cases, edge cases, variations to handle, example inputs/outputs`,
                    generic: `${levels.subtask}s = steps, components, or sub-elements needed to complete the ${levels.item}`
                };
                return guidance[pattern] || guidance.generic;
            }

            // Pattern-specific extraction instructions
            function getPatternSpecificInstructions(pattern) {
                const instructions = {
                    philosophy: `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ PHILOSOPHY PATTERN - CRITICAL REQUIREMENTS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“œ ARGUMENTATIVE STRUCTURE (3-5 PHASES):
Follow the text's own argumentative flow. Common patterns include:
- Problem/Question â†’ Method â†’ Analysis â†’ Conclusion
- Thesis â†’ Antithesis â†’ Synthesis
- Doubt â†’ Investigation â†’ Discovery â†’ Implications

ðŸ“‹ SUBITEMS REQUIREMENT:
- EVERY claim MUST have 1-3 subItems
- SubItems = premises, evidence, textual references, supporting reasoning
- NEVER create claims without supporting subItems

ðŸ·ï¸ ARGUMENT TYPES (Use correctly):
- question: Interrogative moves that drive the inquiry forward
- premise: Foundational claims or assumptions supporting later arguments
- definition: Explicit attempts to define or characterize concepts
- refutation: Counter-arguments that challenge or disprove prior claims
  âš ï¸ Includes: analogies, thought experiments, reductio arguments used to COUNTER a position
- conclusion: Claims derived from prior reasoning

âš ï¸ KEY DISTINCTION:
When an analogy or thought experiment is used to CHALLENGE or DISPROVE a claim,
it is a REFUTATION, not a question or premise. Look for the argumentative function.

âœ… CORRECT TYPING:
- "If a deceiver deceives me, I must exist to be deceived" â†’ refutation (self-refuting doubt)
- "What is the nature of X?" â†’ question
- "X is defined as Y" â†’ definition
- "Therefore, X must be true" â†’ conclusion
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`,
                    film: `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ AI VIDEO PRODUCTION - CRITICAL INSTRUCTIONS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

YOU ARE CREATING ACTUAL VIDEO SCENES, NOT META-WORKFLOWS!

ðŸŽ¬ WHAT TO CREATE:
- Each item = ONE SPECIFIC SHOT/SCENE
- Describe WHAT APPEARS IN THE FRAME
- Include: subject, action, camera movement, lighting, mood

âŒ DO NOT CREATE:
- Workflows about "creating prompts"
- Meta-tasks like "Generate a prompt for..."
- Process steps like "Use Sora to..."
- Planning tasks like "Write description of..."

âœ… CORRECT EXAMPLE (user says "drone flight over data center"):
{
  "phases": [{
    "name": "Establishing Sequence",
    "items": [
      {
        "name": "Wide aerial establishing shot",
        "description": "Camera starts at 500 feet showing vast data center campus in Saskatchewan plains",
        "videoPrompt": "Aerial drone shot ascending from ground level, revealing massive data center facility surrounded by snow-covered farmland. Wide establishing shot showing geometric rows of server buildings with steam rising from cooling towers. Camera rises smoothly from 50 feet to 200 feet over 10 seconds. Golden hour lighting with long shadows across white landscape. Cinematic widescreen aesthetic.",
        "aiPlatform": "Veo 3 (Google)",
        "visualStyle": "Cinematic",
        "duration": "10 seconds",
        "aspectRatio": "16:9 (Widescreen)",
        "cameraMovement": "Crane Up",
        "motionIntensity": "Moderate",
        "lightingMood": "Golden Hour"
      },
      {
        "name": "Dolly shot of server building exterior",
        "description": "Close-up tracking shot along reflective glass facade",
        "videoPrompt": "Slow dolly right along mirrored glass exterior of data center building. Reflections of winter sky and clouds move across glass surface. Camera tracks steadily at 6 feet height, revealing geometric patterns of windows and air vents. Overcast lighting with soft shadows. Modern architectural aesthetic. 6-second clip.",
        "cameraMovement": "Tracking Shot",
        "duration": "6 seconds"
      }
    ]
  }]
}

âŒ WRONG EXAMPLE (meta-workflow - DO NOT DO THIS):
{
  "phases": [{
    "name": "Content Creation",
    "items": [
      {
        "name": "Introduction Prompt",
        "description": "Create a natural language prompt for an introductory segment"  âŒ NO!
      },
      {
        "name": "Generate Drone Tour",
        "description": "Use Sora to produce drone footage"  âŒ NO!
      }
    ]
  }]
}

ðŸŽ¥ FOR EACH SCENE ITEM:
1. **name**: Short description of the shot (e.g., "Aerial reveal of campus")
2. **description**: What happens in the scene (action, subjects, context)
3. **videoPrompt**: DETAILED 100-300 character prompt describing:
   - What appears in frame
   - Camera movement and framing
   - Lighting and mood
   - Visual style
   - Duration
4. **aiPlatform**: Which AI to use (Sora, Veo 3, Runway, Pika)
5. **cameraMovement**: How camera moves (Dolly In, Crane Up, Tracking Shot, etc.)
6. **visualStyle**: Cinematic, Documentary, Photorealistic, etc.
7. **lightingMood**: Golden Hour, Dramatic, Soft Natural, etc.
8. **duration**: How long (2s, 4s, 6s, 10s, 20s)
9. **aspectRatio**: 16:9, 9:16, 2.39:1, etc.

REMEMBER: You are a cinematographer, not a project planner!
Describe the ACTUAL SHOTS, not the process of creating them.
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`
                };

                return instructions[pattern] || '';
            }

            const patternSpecificInstructions = getPatternSpecificInstructions(pattern);

            // =========================================================================
            // CHUNK PROCESSING LOOP (Deep Mode)
            // =========================================================================
            const allPhasesCollected = [];
            let projectName = '';

            for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                const chunk = chunks[chunkIndex];
                console.log(`ðŸ”„ [Deep] Processing chunk ${chunkIndex + 1}/${chunks.length} (${chunk.text.length} chars)`);

                // Update UI with chunk progress feedback
                const percent = Math.round(((chunkIndex + 1) / chunks.length) * 100);
                const modalBody = document.getElementById('modal-body');
                if (modalBody && chunks.length > 1) {
                    const progressBars = chunks.map((c, i) => {
                        const isProcessed = i < chunkIndex;
                        const isProcessing = i === chunkIndex;
                        const barColor = isProcessed ? 'rgba(16, 185, 129, 0.8)' : isProcessing ? 'rgba(251, 146, 60, 0.8)' : 'rgba(100, 100, 100, 0.3)';
                        return `<div style="flex: 1; height: 8px; background: ${barColor}; border-radius: 4px; transition: background 0.3s;"></div>`;
                    }).join('');

                    modalBody.innerHTML = `
                        <div style="padding: 20px;">
                            <div style="text-align: center; margin-bottom: 16px;">
                                <div class="spinner"></div>
                                <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600; font-size: 16px;">
                                    ðŸ§  Analyzing Section ${chunkIndex + 1} of ${chunks.length}
                                </p>
                                <p style="color: var(--text-secondary); font-size: 14px; margin-top: 4px;">
                                    ${percent}% complete â€¢ ${chunk.text.length.toLocaleString()} characters
                                </p>
                            </div>
                            <div style="display: flex; gap: 4px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                ${progressBars}
                            </div>
                            <div style="text-align: center; margin-top: 12px; font-size: 12px; color: var(--text-secondary);">
                                Deep Mode extracts comprehensive details from each section
                            </div>
                        </div>
                    `;
                }

                const chunkPrompt = `Convert this SPECIFIC SECTION of a larger document into a detailed hierarchical structure using the "${patternConfig.name}" pattern (Section ${chunkIndex + 1}/${chunks.length}).

PATTERN HIERARCHY (4 LEVELS):
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}
${patternFieldGuide}
${patternSpecificInstructions}

SECTION TEXT (Section ${chunkIndex + 1}/${chunks.length}):
${chunk.text}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
DEEP MODE INSTRUCTIONS - COMPREHENSIVE EXTRACTION (SECTION ${chunkIndex + 1}/${chunks.length})
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âš ï¸ CRITICAL REQUIREMENTS - YOU MUST MEET THESE MINIMUMS FOR THIS SECTION:

1. PHASES: Create 1-3 phases (${levels.phase}s) for THIS SECTION ONLY
   â†’ Do NOT summarize - extract actual phases present in this section
   â†’ Each major subsection/movement/chapter in THIS SECTION = separate phase

2. ITEMS PER PHASE: REQUIRED MINIMUM 3-8 items (${levels.item}s) per phase
   â†’ Do NOT create just 1 item per phase
   â†’ Extract ALL significant claims/arguments/features/sections
   â†’ Each distinct idea/component/argument = separate item

3. SUBTASKS: Add 2-5 ${levels.subtask}s to items that need decomposition
   â†’ ${levels.subtask}s are pattern-specific breakdowns of each ${levels.item}
   â†’ ${getDeepModeSubtaskGuidance(pattern)}
   â†’ Only skip ${levels.subtask}s for truly atomic items that cannot be decomposed

4. DEPTH: Go 3-4 levels deep in the hierarchy
   â†’ Phase â†’ Item â†’ Subtask â†’ (nested subtask if needed)
   â†’ Do NOT stop at 2 levels

5. FIELD POPULATION: Extract ALL pattern-specific field values listed above
   â†’ Populate EVERY field mentioned in the "${patternConfig.name.toUpperCase()}" pattern section
   â†’ Do NOT leave fields empty if information is available in the text
   â†’ If exact value not in text, make intelligent estimates (for word counts, story points, etc.)
   â†’ For dates, use YYYY-MM-DD format

6. DEPENDENCIES: Identify ALL logical prerequisites
   â†’ Look for: "depends on", "requires", "builds on", "follows from", "assumes", "after"
   â†’ Format: ["item-X-Y", "item-Z-W"]
   â†’ Map both intra-phase and inter-phase dependencies

7. NODE TYPES: Use specific types from the "${patternConfig.name.toUpperCase()}" item type list above
   â†’ Use the EXACT type values provided (not generic categories)
   â†’ Different items should have different types based on their function
   â†’ Do NOT use the same type for every item

8. DESCRIPTIONS: Write detailed descriptions (100-250 characters)
   â†’ Capture nuance, context, and significance
   â†’ NOT just repetition of title

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
EXAMPLE OF PROPER DEPTH (Philosophy Pattern)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

If text contains: "Socrates asks: What is justice? Callias replies it is giving each what they are owed. Socrates refutes this with the mad debtor example."

WRONG (too shallow):
{
  "phases": [{
    "name": "Movement 1",
    "items": [{"name": "Discussion of justice"}]
  }]
}

CORRECT (proper depth):
{
  "phases": [{
    "name": "Movement 1",
    "subtitle": "The Initial Inquiry",
    "items": [
      {
        "name": "Opening Question: What is Justice?",
        "itemType": "question",
        "speaker": "Socrates",
        "description": "Socrates initiates inquiry by asking Callias to define justice",
        "keyTerms": "justice, definition",
        "dependencies": []
      },
      {
        "name": "First Definition: Justice as Giving What is Owed",
        "itemType": "definition",
        "speaker": "Callias",
        "description": "Callias proposes justice means giving each person what they are owed",
        "keyTerms": "justice, debt, obligation",
        "dependencies": []
      },
      {
        "name": "Refutation via Mad Debtor Counterexample",
        "itemType": "refutation",
        "speaker": "Socrates",
        "argumentType": "Socratic Elenchus",
        "description": "Socrates refutes Callias's definition using case of returning sword to madman",
        "dependencies": ["item-0-1"],
        "subItems": [
          {
            "name": "Premise: Returning sword to madman is dangerous",
            "itemType": "premise",
            "premise1": "The madman is owed the sword (per Callias's definition)",
            "conclusion": "But returning it would be unjust (harmful)",
            "description": "Creates contradiction in Callias's definition"
          },
          {
            "name": "Conclusion: Definition is insufficient",
            "itemType": "conclusion",
            "description": "Justice cannot be merely giving what is owed, circumstances matter",
            "dependencies": ["subtask-0-2-0"]
          }
        ]
      }
    ]
  }]
}

See the difference? The CORRECT version:
âœ“ Has 3 items (not 1)
âœ“ Uses specific item types (question, definition, refutation)
âœ“ Populates fields (speaker, argumentType, keyTerms, premises)
âœ“ Has subtasks with proper nesting
âœ“ Maps dependencies between nodes

THIS IS THE LEVEL OF DETAIL REQUIRED IN DEEP MODE.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
FINAL REMINDER
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Deep Mode = COMPREHENSIVE EXTRACTION, not summarization
Extract EVERYTHING with maximum granularity and detail
Aim for 25-40 total nodes for complex texts (Haiku's 4096 token limit)

JSON FORMATTING RULES (CRITICAL - FOLLOW EXACTLY):
- NO trailing commas after the last element in arrays or objects
- NO line breaks or tabs inside string values - use spaces instead
- NO unescaped quotes inside strings
- ONLY plain JSON - no markdown code blocks, no backticks, no explanations
- Start response with { and end with }

CORRECT EXAMPLE (note: NO trailing comma after last item):
{"phases": [{"name": "Test", "items": [{"name": "Item"}]}]}

WRONG (trailing comma):
{"phases": [{"name": "Test", "items": [{"name": "Item"},]}]}

Respond with ONLY valid, parseable JSON:
{
  "projectName": "Extracted or inferred project name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle",
      "icon": "ðŸ“‹",
      "items": [
        {
          "name": "Item name",
          "description": "Detailed description",
          "itemType": "category",
          "cost": 1000,
          "dependencies": ["item-0-1", "item-1-2"],
          "subtasks": [
            {
              "name": "Subtask name",
              "description": "What needs to be done",
              "dependencies": []
            }
          ],
          "... other pattern-specific fields ...": "values"
        }
      ]
    }
  ]
}`;

                // Deep Mode: Higher limits with extended thinking
                const response = await callClaudeAPI(chunkPrompt, '', 8192, true); // 8192 tokens + extended thinking for comprehensive analysis

                // Parse JSON response from this chunk
                try {
                    let jsonText = response.trim();

                    // Remove markdown code blocks if present
                    jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    // Find the FIRST complete JSON object using proper brace matching
                    const firstBrace = jsonText.indexOf('{');

                    if (firstBrace === -1) {
                        console.warn(`âš ï¸ [Deep] Chunk ${chunkIndex + 1}: No JSON found, skipping`);
                        continue;
                    }

                    if (firstBrace > 0) {
                        console.log(`ðŸª„ [Deep] Chunk ${chunkIndex + 1}: Skipping text before JSON`);
                    }

                    let depth = 0;
                    let endPos = -1;
                    let inString = false;
                    let escapeNext = false;

                    for (let i = firstBrace; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            inString = !inString;
                            continue;
                        }

                        if (!inString) {
                            if (char === '{') depth++;
                            else if (char === '}') {
                                depth--;
                                if (depth === 0) {
                                    endPos = i + 1;
                                    break;
                                }
                            }
                        }
                    }

                    if (endPos === -1) {
                        console.warn(`âš ï¸ [Deep] Chunk ${chunkIndex + 1}: Incomplete JSON, skipping`);
                        continue;
                    }

                    jsonText = jsonText.substring(firstBrace, endPos);

                    // Parse JSON
                    let parsed;
                    try {
                        parsed = JSON.parse(jsonText);
                    } catch (firstError) {
                        console.warn(`ðŸª„ [Deep] Chunk ${chunkIndex + 1}: JSON parse failed, attempting sanitization...`, firstError.message);

                        // Sanitize JSON: Fix control characters in string values
                        let sanitized = '';
                        let inString = false;
                        let escapeNext = false;

                        for (let i = 0; i < jsonText.length; i++) {
                            const char = jsonText[i];

                            if (escapeNext) {
                                sanitized += char;
                                escapeNext = false;
                                continue;
                            }

                            if (char === '\\') {
                                sanitized += char;
                                escapeNext = true;
                                continue;
                            }

                            if (char === '"') {
                                sanitized += char;
                                inString = !inString;
                                continue;
                            }

                            // If we're inside a string value, escape control characters
                            if (inString) {
                                if (char === '\n') {
                                    sanitized += '\\n';
                                } else if (char === '\r') {
                                    sanitized += '\\r';
                                } else if (char === '\t') {
                                    sanitized += '\\t';
                                } else if (char.charCodeAt(0) < 32) {
                                    sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                                } else {
                                    sanitized += char;
                                }
                            } else {
                                sanitized += char;
                            }
                        }

                        jsonText = sanitized;
                        console.log(`âœ… [Deep] Chunk ${chunkIndex + 1}: JSON sanitized successfully`);
                        parsed = JSON.parse(jsonText);
                    }

                    // Aggregate results from this chunk
                    if (!projectName && parsed.projectName) {
                        projectName = parsed.projectName;
                        console.log(`ðŸ“ [Deep] Project name extracted from chunk ${chunkIndex + 1}: ${projectName}`);
                    }

                    if (parsed.phases && parsed.phases.length > 0) {
                        console.log(`âœ… [Deep] Chunk ${chunkIndex + 1}: Extracted ${parsed.phases.length} phases with comprehensive detail`);
                        allPhasesCollected.push(...parsed.phases);
                    }

                } catch (e) {
                    console.error(`âŒ [Deep] Chunk ${chunkIndex + 1} failed to parse:`, e);
                    console.error('Response (first 500 chars):', response.substring(0, 500));
                    // Continue to next chunk instead of failing entirely
                }
            }

            // =========================================================================
            // MERGE DUPLICATE PHASES AND RETURN AGGREGATED RESULT (Deep Mode)
            // =========================================================================
            console.log(`âœ… [Deep] All chunks processed. Total phases collected: ${allPhasesCollected.length}`);

            // Merge phases with the same name
            const phaseMap = new Map();
            allPhasesCollected.forEach(phase => {
                const phaseName = phase.name;
                if (phaseMap.has(phaseName)) {
                    // Merge items into existing phase
                    const existingPhase = phaseMap.get(phaseName);
                    if (phase.items && phase.items.length > 0) {
                        existingPhase.items.push(...phase.items);
                    }
                } else {
                    // Add new phase
                    phaseMap.set(phaseName, { ...phase });
                }
            });

            const mergedPhases = Array.from(phaseMap.values());
            console.log(`âœ… [Deep] After merging duplicates: ${mergedPhases.length} unique phases`);

            // Use a generic project name if none was extracted
            if (!projectName) {
                projectName = `${patternConfig.name} Project`;
            }

            return {
                projectName: projectName,
                phases: mergedPhases
            };
        }

        // OLD SINGLE-CHUNK DEEP MODE (DEPRECATED - keeping for reference)
        async function convertTextToTreeDeep_LEGACY(text, pattern) {
            const response = 'DEPRECATED'; // Legacy function - semantic chunking is now standard

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the FIRST complete JSON object using proper brace matching
                const firstBrace = jsonText.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ðŸª„ [Deep] Skipping text before JSON:', jsonText.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Incomplete JSON object in AI response (no closing brace found).');
                }

                if (endPos < jsonText.length) {
                    console.log('ðŸª„ [Deep] Skipping text after JSON:', jsonText.substring(endPos, Math.min(endPos + 100, jsonText.length)));
                }

                jsonText = jsonText.substring(firstBrace, endPos);

                console.log('ðŸª„ [Deep] Extracted JSON length:', jsonText.length);

                // Sanitize JSON: Fix control characters in string values (same as wizard)
                let parsed;
                try {
                    parsed = JSON.parse(jsonText);
                } catch (firstError) {
                    console.warn('ðŸª„ [Deep] JSON parse failed, attempting sanitization...', firstError.message);

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonText = sanitized;
                    console.log('âœ… [Deep] JSON sanitized successfully');
                    parsed = JSON.parse(jsonText);
                }

                return parsed;
            } catch (e) {
                console.error('Failed to parse deep conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('ðŸ”§ Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('âœ… JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('âŒ Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Main Analyze button handler
        document.getElementById('analysis-start-btn').addEventListener('click', async () => {
            // Get text from file or textarea
            const textFromTextarea = document.getElementById('analysis-text-input').value.trim();
            let finalText = analysisText || textFromTextarea;

            if (!finalText) {
                alert('Please upload a file or paste text to analyze.');
                return;
            }

            // Get global AI mode
            const mode = getGlobalAIMode();

            // Check if AI is disabled
            if (mode === 'off') {
                alert('âŒ AI features are currently disabled.\n\nPlease enable AI mode in the header (ðŸ¤– AI Mode dropdown) to use text analysis.');
                return;
            }

            // Auto-truncate very long texts to prevent timeouts
            // Different limits for Quick vs Deep Mode
            const MAX_CHARS_QUICK = 100000; // ~25,000 words for Quick Mode
            const MAX_CHARS_DEEP = 300000;  // ~75,000 words for Deep Mode (with user API key, no timeout)
            const MAX_CHARS = mode === 'deep' ? MAX_CHARS_DEEP : MAX_CHARS_QUICK;

            let wasTruncated = false;
            if (finalText.length > MAX_CHARS) {
                wasTruncated = true;
                finalText = finalText.substring(0, MAX_CHARS);
                console.warn(`âš ï¸ Text truncated from ${analysisText.length} to ${MAX_CHARS} characters for ${mode} mode`);
            }

            // Check if Deep Mode requires user's own API key
            if (mode === 'deep') {
                const userApiKey = getLocalAPIKey();
                if (!userApiKey) {
                    alert('ðŸ”¬ Deep Mode requires your own Anthropic API key.\n\nWhy?\nâ€¢ Deep Mode uses more tokens and takes longer\nâ€¢ Prevents timeout on Netlify free tier (10s limit)\nâ€¢ You only pay for what you use\n\nPlease:\n1. Click the ðŸ”‘ API Key button\n2. Enter your Anthropic API key\n3. Try Deep Mode again\n\nQuick Mode is available without an API key.');
                    return;
                }
                console.log('âœ… Deep Mode: Using your API key (bypasses rate limits and timeouts)');
            }

            // Warn if text was truncated
            if (wasTruncated) {
                const proceed = confirm(`âš ï¸ Your text is very long and has been automatically truncated to ${MAX_CHARS} characters (~${Math.floor(MAX_CHARS/4)} words) to prevent timeouts.\n\nOnly the first portion will be analyzed.\n\nDo you want to continue?`);
                if (!proceed) {
                    return;
                }
            }

            // Close analysis modal and show loading modal
            document.getElementById('analysis-modal').style.display = 'none';
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'ðŸ” Analyzing Text...';
            modal.style.display = 'flex';

            // Check if user pre-selected a specific pattern
            const preSelectedPattern = document.getElementById('analysis-pattern-select').value;

            try {
                let selectedPattern;

                // If user chose a specific pattern, skip detection and use that pattern directly
                if (preSelectedPattern && preSelectedPattern !== 'auto') {
                    selectedPattern = preSelectedPattern;
                    console.log(`âœ… Using pre-selected pattern: ${selectedPattern}`);

                    // Step 2: Convert text to tree (skip pattern detection)
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 1/2: Converting text to tree structure...</p>';

                    let treeData;
                    if (mode === 'quick') {
                        treeData = await convertTextToTreeQuick(finalText, selectedPattern);
                    } else {
                        treeData = await convertTextToTreeDeep(finalText, selectedPattern);
                    }

                    // Step 3: Preview and import
                    showAnalysisPreview(treeData, selectedPattern, analysisAppendMode);
                    return; // Exit early - we're done!
                }

                // Otherwise, proceed with auto-detection
                modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 1/3: Detecting optimal pattern...</p>';

                // Step 1: Detect pattern
                const recommendations = await detectPattern(finalText);

                // Show pattern selection
                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <h3 style="margin-bottom: 16px; color: var(--text-primary);">ðŸ“Š Recommended Patterns</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px; font-size: 14px;">
                            AI analyzed your text and recommends these patterns. Select one to continue:
                        </p>
                        <div id="pattern-recommendations" style="display: flex; flex-direction: column; gap: 12px;">
                            ${recommendations.map((rec, index) => `
                                <label style="display: flex; align-items: flex-start; padding: 16px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s; background: var(--card-bg);" class="pattern-rec-option" data-pattern="${rec.pattern}">
                                    <input type="radio" name="selected-pattern" value="${rec.pattern}" ${index === 0 ? 'checked' : ''} style="margin-top: 4px; margin-right: 12px;" />
                                    <div style="flex: 1;">
                                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                            <span style="font-weight: 600; color: var(--text-primary); font-size: 15px;">${rec.patternName}</span>
                                            <span style="background: ${rec.confidence >= 8 ? '#4caf50' : rec.confidence >= 6 ? '#ff9f43' : '#666'}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">
                                                ${rec.confidence}/10 confidence
                                            </span>
                                        </div>
                                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                            ${rec.reasoning}
                                        </div>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                        <div style="margin-top: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">
                                Analysis Mode: ${mode === 'quick' ? 'âš¡ Quick Mode' : 'ðŸ”¬ Deep Mode'}
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary);">
                                ${mode === 'quick' ? 'Fast analysis with basic structure extraction.' : 'Detailed analysis with field extraction and dependencies.'}
                            </div>
                        </div>
                    </div>
                `;

                // Add hover effects to pattern options
                document.querySelectorAll('.pattern-rec-option').forEach(option => {
                    option.addEventListener('mouseenter', () => {
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                    option.addEventListener('mouseleave', () => {
                        const radio = option.querySelector('input[type="radio"]');
                        if (!radio.checked) {
                            option.style.borderColor = 'var(--border)';
                            option.style.background = 'var(--card-bg)';
                        }
                    });
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.pattern-rec-option').forEach(opt => {
                            opt.style.borderColor = 'var(--border)';
                            opt.style.background = 'var(--card-bg)';
                        });
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                });

                // Update modal footer with continue button
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="pattern-select-cancel">Cancel</button>
                    <button class="btn btn-primary" id="pattern-select-continue" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Continue â†’</button>
                `;

                document.getElementById('pattern-select-cancel').addEventListener('click', () => {
                    modal.style.display = 'none';
                });

                document.getElementById('pattern-select-continue').addEventListener('click', async () => {
                    const selectedPattern = document.querySelector('input[name="selected-pattern"]:checked').value;

                    // Step 2: Convert text to tree
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 2/3: Converting text to tree structure...</p>';
                    document.querySelector('#modal .modal-footer').innerHTML = '';

                    try {
                        let treeData;
                        if (mode === 'quick') {
                            treeData = await convertTextToTreeQuick(finalText, selectedPattern);
                        } else {
                            treeData = await convertTextToTreeDeep(finalText, selectedPattern);
                        }

                        // Step 3: Preview and import
                        showAnalysisPreview(treeData, selectedPattern, analysisAppendMode);

                    } catch (error) {
                        modalBody.innerHTML = `
                            <div style="padding: 20px; text-align: center;">
                                <div style="font-size: 48px; margin-bottom: 16px;">âŒ</div>
                                <h3 style="color: #f44336; margin-bottom: 12px;">Analysis Failed</h3>
                                <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                            </div>
                        `;
                        document.querySelector('#modal .modal-footer').innerHTML = `
                            <button class="btn" id="error-close">Close</button>
                            <button class="btn btn-primary" id="error-retry">Try Again</button>
                        `;

                        document.getElementById('error-close').addEventListener('click', () => {
                            modal.style.display = 'none';
                        });

                        document.getElementById('error-retry').addEventListener('click', () => {
                            modal.style.display = 'none';
                            document.getElementById('analyze-text-btn').click();
                        });
                    }
                });

            } catch (error) {
                modalBody.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">âŒ</div>
                        <h3 style="color: #f44336; margin-bottom: 12px;">Pattern Detection Failed</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                    </div>
                `;
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="error-close">Close</button>
                `;

                document.getElementById('error-close').addEventListener('click', () => {
                    modal.style.display = 'none';
                });
            }
        });

        // Show preview before importing
        function showAnalysisPreview(treeData, selectedPattern, appendMode = false) {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            document.getElementById('modal-title').textContent = 'âœ… Analysis Complete - Preview';

            // Count phases and items
            const phaseCount = treeData.phases?.length || 0;
            const itemCount = treeData.phases?.reduce((sum, phase) => sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, #4caf50, #00a67d); color: white; padding: 20px; border-radius: 12px; margin-bottom: 24px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 8px;">âœ¨</div>
                        <h2 style="margin-bottom: 8px; font-size: 24px;">${treeData.projectName || 'Analyzed Project'}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Pattern: ${PATTERNS[selectedPattern].name}</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${phaseCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Phases Detected</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${itemCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Items Created</div>
                        </div>
                    </div>

                    <div style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 16px; background: var(--bg-secondary);">
                        <h4 style="margin-bottom: 12px; color: var(--text-primary);">Structure Preview:</h4>
                        ${treeData.phases?.map((phase, i) => `
                            <div style="margin-bottom: 16px;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px;">
                                    ${phase.icon || 'ðŸ“‹'} ${phase.name}
                                </div>
                                <div style="margin-left: 20px; font-size: 13px; color: var(--text-secondary);">
                                    ${phase.items?.slice(0, 3).map(item => `â€¢ ${item.name}`).join('<br>')}
                                    ${phase.items?.length > 3 ? `<br>... and ${phase.items.length - 3} more items` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-top: 20px; padding: 12px 16px; background: rgba(${appendMode ? '76, 175, 80' : '255, 159, 67'}, 0.1); border: 1px solid rgba(${appendMode ? '76, 175, 80' : '255, 159, 67'}, 0.3); border-radius: 6px;">
                        <div style="color: ${appendMode ? '#4caf50' : '#ff9f43'}; font-weight: 600; margin-bottom: 4px;">${appendMode ? 'âž• Append Mode' : 'âš ï¸ Replace Mode'}</div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            ${appendMode ?
                                'This will add the analyzed content to your existing tree. Phases will be merged or added.' :
                                'Importing will replace your current project. Your current project will be saved as a backup first.'}
                        </div>
                    </div>
                </div>
            `;

            // Create buttons directly with event listeners attached
            const modalFooter = document.querySelector('#modal .modal-footer');
            if (!modalFooter) {
                console.error('âŒ Modal footer not found!');
                alert('Error: Modal footer not found. Please refresh the page.');
                return;
            }

            // Clear existing content
            modalFooter.innerHTML = '';

            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => {
                console.log('ðŸš« Import cancelled');
                modal.style.display = 'none';
            };

            // Create import button
            const importBtn = document.createElement('button');
            importBtn.className = 'btn btn-primary';
            importBtn.style.cssText = 'background: linear-gradient(135deg, #4caf50, #00a67d);';
            importBtn.textContent = appendMode ? 'âž• Append to Tree' : 'ðŸ“¥ Import to TreeListy';
            importBtn.onclick = () => {
                console.log('ðŸ”„ Import button clicked!', { hasTreeData: !!treeData, hasPattern: !!selectedPattern, appendMode });
                try {
                    importAnalyzedTree(treeData, selectedPattern, appendMode);
                    modal.style.display = 'none';
                } catch (error) {
                    console.error('âŒ Import failed:', error);
                    alert('Import failed: ' + error.message);
                }
            };

            // Add buttons to footer
            modalFooter.appendChild(cancelBtn);
            modalFooter.appendChild(importBtn);

            console.log('âœ… Preview modal ready with import button');
        }

        // Import analyzed tree into TreeListy
        function importAnalyzedTree(treeData, selectedPattern, appendMode = false) {
            console.log('ðŸ“¥ Starting import...', { treeData, selectedPattern, appendMode });

            // Save state for undo
            saveState(appendMode ? 'Analyze Text: Append' : 'Analyze Text: Import');

            // Backup current project first
            const backup = JSON.stringify(capexTree, null, 2);
            const backupName = `treelisty_backup_${Date.now()}.json`;
            console.log('ðŸ’¾ Current project backed up as:', backupName);

            // Switch to selected pattern (only if not appending)
            if (!appendMode) {
                currentPattern = selectedPattern;
                document.getElementById('pattern-select').value = selectedPattern;
            }

            // Convert analyzed data to TreeListy format
            const newTree = {
                type: 'root',
                id: 'root',
                name: treeData.projectName || 'Analyzed Project',
                icon: 'ðŸŒ²',
                expanded: true,
                hyperedges: [], // Initialize empty hyperedges array to prevent data loss
                children: treeData.phases?.map((phase, phaseIndex) => ({
                    type: 'phase',
                    id: `phase-${phaseIndex}`,
                    phase: phaseIndex,
                    name: phase.name,
                    subtitle: phase.subtitle || PATTERNS[selectedPattern].phaseSubtitles?.[phaseIndex] || '',
                    icon: phase.icon || 'ðŸ“‹',
                    expanded: true,
                    cost: 0,
                    provenance: {
                        source: 'ai-import',
                        timestamp: new Date().toISOString(),
                        modelId: null
                    },
                    items: phase.items?.map((item, itemIndex) => {
                        const itemId = `item-${phaseIndex}-${itemIndex}`;

                        // Build item object with all required fields
                        const itemObj = {
                            type: 'item',
                            id: itemId,
                            name: item.name,
                            description: item.description || '',
                            itemType: item.itemType || '',
                            icon: item.icon || 'ðŸ“„',
                            cost: item.cost || 0,
                            dependencies: item.dependencies || [],
                            notes: item.notes || '',
                            leadTime: item.leadTime || '',
                            alternateSource: item.alternateSource || '',
                            expanded: false,
                            // Pattern-specific fields
                            dealValue: item.dealValue || 0,
                            wordCount: item.wordCount || 0,
                            storyPoints: item.storyPoints || 0,
                            // Provenance stamping (Cognitive Citadel)
                            provenance: {
                                source: 'ai-import',
                                timestamp: new Date().toISOString(),
                                modelId: null
                            },
                            // Add any other fields from AI
                            ...item
                        };

                        // Add subtasks if they exist (3rd level hierarchy)
                        if (item.subtasks && item.subtasks.length > 0) {
                            itemObj.children = item.subtasks.map((subtask, subtaskIndex) => ({
                                type: 'subtask',
                                id: `subtask-${phaseIndex}-${itemIndex}-${subtaskIndex}`,
                                name: subtask.name || subtask,
                                description: subtask.description || '',
                                icon: subtask.icon || 'ðŸ“Œ',
                                notes: subtask.notes || '',
                                dependencies: subtask.dependencies || [],
                                // Provenance stamping (Cognitive Citadel)
                                provenance: {
                                    source: 'ai-import',
                                    timestamp: new Date().toISOString(),
                                    modelId: null
                                },
                                // Pattern-specific fields
                                ...subtask
                            }));
                        }

                        return itemObj;
                    }) || []
                })) || []
            };

            if (appendMode) {
                // Append mode: merge phases and items
                console.log('âž• Append mode: merging trees...');

                // Keep existing project name if different
                if (capexTree.name !== newTree.name && capexTree.name !== 'My Project') {
                    // User has a custom name, keep it
                } else {
                    capexTree.name = newTree.name;
                }

                // Merge phases
                newTree.children.forEach((newPhase, newPhaseIndex) => {
                    // Find matching phase in existing tree by index or name
                    const existingPhase = capexTree.children?.[newPhaseIndex];

                    if (existingPhase) {
                        // Phase exists - append items to it
                        console.log(`Appending ${newPhase.items?.length || 0} items to existing phase: ${existingPhase.name}`);

                        // Update phase name if it was generic
                        if (existingPhase.name === `Phase ${newPhaseIndex}` && newPhase.name !== `Phase ${newPhaseIndex}`) {
                            existingPhase.name = newPhase.name;
                        }

                        // Append new items
                        if (newPhase.items && newPhase.items.length > 0) {
                            const currentItemCount = existingPhase.items?.length || 0;

                            // Re-ID the new items to avoid conflicts
                            const reIdedItems = newPhase.items.map((item, idx) => ({
                                ...item,
                                id: `item-${newPhaseIndex}-${currentItemCount + idx}`
                            }));

                            existingPhase.items = [...(existingPhase.items || []), ...reIdedItems];
                        }
                    } else {
                        // Phase doesn't exist - add it as new
                        console.log(`Adding new phase: ${newPhase.name}`);
                        if (!capexTree.children) capexTree.children = [];

                        // Re-ID the phase
                        newPhase.id = `phase-${capexTree.children.length}`;
                        newPhase.phase = capexTree.children.length;

                        capexTree.children.push(newPhase);
                    }
                });

                // Show success message for append
                const addedItems = treeData.phases?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0;
                const addedSubtasks = treeData.phases?.reduce((sum, p) =>
                    sum + (p.items?.reduce((subSum, item) => subSum + (item.subtasks?.length || 0), 0) || 0), 0) || 0;

                let message = `âœ… Successfully appended!\n\n${addedItems} items`;
                if (addedSubtasks > 0) {
                    message += ` and ${addedSubtasks} subtasks`;
                }
                message += ` have been added to your existing tree.`;
                alert(message);

            } else {
                // Replace mode: completely replace tree
                console.log('ðŸ”„ Replace mode: replacing tree...');
                capexTree = newTree;

                // Show success message for replace
                const totalItems = treeData.phases?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0;
                const totalSubtasks = treeData.phases?.reduce((sum, p) =>
                    sum + (p.items?.reduce((subSum, item) => subSum + (item.subtasks?.length || 0), 0) || 0), 0) || 0;

                let message = `âœ… Successfully imported!\n\n${treeData.phases?.length || 0} phases and ${totalItems} items`;
                if (totalSubtasks > 0) {
                    message += ` and ${totalSubtasks} subtasks`;
                }
                message += ` have been created.\n\nPattern: ${PATTERNS[selectedPattern].name}`;
                alert(message);
            }

            // Render
            render();

            // Auto-select first item to show detail panel
            // Find the first item in the tree
            let firstItem = null;
            if (capexTree.children && capexTree.children.length > 0) {
                for (const phase of capexTree.children) {
                    if (phase.items && phase.items.length > 0) {
                        firstItem = phase.items[0];
                        break;
                    }
                }
            }

            // Show detail panel for first item if found
            if (firstItem) {
                console.log('ðŸ“‹ Auto-selecting first item for detail panel:', firstItem.name);
                showInfo(firstItem);
            }
        }

        // How to Use button
        document.getElementById('how-to-btn').addEventListener('click', () => {
            const modal = document.getElementById('modal');
            document.getElementById('modal-title').textContent = 'ðŸ“– How to Use TreeListy';
            document.getElementById('modal-body').innerHTML = `
                <div style="padding: 20px; line-height: 1.8;">
                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">ðŸ’¡ What is TreeListy?</h3>
                    <p style="margin-bottom: 20px; font-size: 14px;">
                        <strong>TreeListy</strong> is a universal tool for breaking down any complex project, problem, or process into manageable parts.
                        Structure your work into phases, track dependencies between components, and analyze your entire plan at a glance.
                        Use it for software projects, sales pipelines, academic writing, product roadmaps, AI prompt design, or anything else that benefits from structured thinking! ðŸŒ³âœ¨ðŸŽ¯
                    </p>

                    <h3 style="color: var(--phase-1); margin-bottom: 16px; font-size: 20px;">ðŸš€ Quick Start</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-1);">
                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>1. Choose Your Pattern</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ Use the Pattern dropdown (top) to select your project type:</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">ðŸ“‹ Generic Project, ðŸ’¼ Sales Pipeline, ðŸŽ“ Academic Writing, ðŸš€ Product Roadmap</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">ðŸ“š Book Writing, ðŸ§  AI Prompt Design, ðŸ›ï¸ Philosophy, ðŸ’¡ Strategic Planning</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">ðŸŽ¬ Film Production, ðŸ“§ Email Workflow <em>(NEW!)</em>, ðŸ’¾ File System</p>
                        <p style="font-size: 12px; margin-bottom: 12px; padding-left: 16px;">...and more! (15 specialized patterns total)</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>2. Build Your Tree (3 Ways)</strong></p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">ðŸ§™ AI Wizard (Easiest!)</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Click "ðŸ§™ AI Wizard" button in toolbar</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Describe your project in plain language</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ AI asks strategic questions and builds your tree</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">â€¢ Works for new trees or enhancing existing ones!</p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">ðŸ“„ Analyze Text</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Click "ðŸ“„ Analyze Text" button</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Paste any document (plans, specs, articles)</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Choose Quick Mode (fast) or Deep Mode (thorough)</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">â€¢ Can append to existing trees or replace completely</p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">âœ‹ Manual Creation</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Right-click on any Phase â†’ "Add Item"</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">â€¢ Fill in fields manually with full control</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>3. Use Smart Features</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>AI Review ðŸ”¬</strong> - Click "ðŸ”¬ AI Review" for comprehensive tree analysis</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Smart Suggest ðŸ’¡</strong> - Right-click any field â†’ Choose "âœ¨ AI Suggest" or "ðŸ’¡ Quick Suggest"</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Dependencies</strong> - Edit an item â†’ Check boxes in Dependencies section</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>AI Analysis ðŸ¤–</strong> - Click any item â†’ "AI Analysis" for insights</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Undo</strong> - Click "â†©ï¸ Undo" or press Ctrl+Z (Cmd+Z on Mac)</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>4. Navigate & View</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Expand/Collapse</strong> - Click "â¬‡ï¸ Expand" or "â¬†ï¸ Collapse" buttons</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Click nodes</strong> to expand/collapse individually or view details</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Pan/Zoom</strong> - Use mouse wheel or pan controls</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>5. Export & Share</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ðŸ“ Generate Prompt</strong> - Export as AI-ready prompt (for Claude, GPT, etc.)</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ðŸ“Š Export Excel</strong> - Professional multi-sheet workbook</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ðŸ“¥ Import Excel</strong> - Import Excel files back into TreeListy</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ðŸ’¾ Save/Load</strong> - Save as JSON and reload anytime</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>ðŸ”— Share</strong> - Generate shareable URL</p>
                    </div>

                    <h3 style="color: var(--phase-2); margin-bottom: 16px; font-size: 20px;">ðŸ¤– AI-Powered Features</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-2);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ§™ AI Wizard</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Interactive project building</strong> - AI asks strategic questions<br>
                            â€¢ <strong>Conversational interface</strong> - Just describe what you need<br>
                            â€¢ <strong>Enhance mode</strong> - Add to existing trees without starting over<br>
                            â€¢ <strong>Real-time preview</strong> - Watch your tree build in the side panel<br>
                            â€¢ <strong>Smart Merge protection</strong> - Never loses your existing data<br>
                            â€¢ <strong>Auto-recovery</strong> - Handles errors gracefully
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ“„ Analyze Text + ðŸ§  Semantic Chunking (NEW!)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>ðŸ§  Semantic Chunking</strong> - Auto-segments large documents (5000+ words) using NLP<br>
                            â€¢ <strong>Prevents Hallucinations</strong> - Processes chunks independently instead of all at once<br>
                            â€¢ <strong>Visual Feedback</strong> - Shows chunk distribution with bar chart during analysis<br>
                            â€¢ <strong>Embedding-Based</strong> - Uses OpenAI/Gemini embeddings to detect semantic boundaries<br>
                            â€¢ <strong>Auto-Fallback</strong> - Structural parser (Markdown â†’ paragraphs) if no embedding API<br>
                            â€¢ <strong>Quick Mode</strong> - Fast analysis (1500 tokens per chunk) for straightforward documents<br>
                            â€¢ <strong>Deep Mode</strong> - Extended thinking (8192 tokens per chunk) for complex analysis<br>
                            â€¢ <strong>Append Mode</strong> - Combine multiple document analyses<br>
                            â€¢ <strong>Pattern-specific extraction</strong> - Philosophy extracts premises, Sales extracts deals, etc.<br>
                            â€¢ <strong>Prompt improvement</strong> - AI Prompt pattern turns basic prompts into comprehensive ones
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ”¬ AI Review & Enhance</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Comprehensive tree analysis</strong> - Reviews entire tree for completeness, logic, and flow<br>
                            â€¢ <strong>Pattern-aware review</strong> - Checks alignment with pattern best practices<br>
                            â€¢ <strong>Actionable suggestions</strong> - Get specific recommendations for improvements<br>
                            â€¢ <strong>Gap identification</strong> - Finds missing phases, items, or subtasks<br>
                            â€¢ <strong>Quality assessment</strong> - Identifies redundancies and structural issues
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ’¡ Smart Suggest (Dual Modes)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>âœ¨ AI Suggest</strong> - Context-aware suggestions with pattern expertise (Philosophy prof, Sales strategist, etc.)<br>
                            â€¢ <strong>ðŸ’¡ Quick Suggest</strong> - Instant static templates for common fields<br>
                            â€¢ <strong>Pattern intelligence</strong> - Philosophy gets premises/objections, Sales gets follow-ups, Film gets Sora/Veo prompts<br>
                            â€¢ <strong>Right-click any field</strong> - Choose your mode and watch AI fill in intelligent suggestions<br>
                            â€¢ <strong>Fallback protection</strong> - Auto-switches to Quick mode if AI fails
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ“ Generate Prompt</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Export as AI prompt</strong> - Use with Claude, GPT-4, or any LLM<br>
                            â€¢ <strong>Pattern-aware formatting</strong> - Adapts to your project type<br>
                            â€¢ <strong>Executable prompts</strong> - AI Prompt pattern creates paste-ready prompts (not meta-docs)<br>
                            â€¢ <strong>Copy to clipboard</strong> - One-click copy for easy sharing<br>
                            â€¢ <strong>Complete context</strong> - Includes all phases, items, and subtasks
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ¤– AI Analysis (Per Item)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Risk assessments</strong> - Identify potential issues<br>
                            â€¢ <strong>Cost optimization</strong> - Compare with similar items<br>
                            â€¢ <strong>Strategic insights</strong> - Powered by your chosen AI model<br>
                            â€¢ <strong>Pattern-specific analysis</strong> - Tailored to your project type
                        </p>
                    </div>

                    <h3 style="color: var(--phase-1); margin-bottom: 16px; font-size: 20px;">ðŸ”‘ AI Providers & API Keys</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-1);">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy supports multiple AI providers!</strong> Choose the model that fits your needs.
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ¤– Available Providers</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Anthropic Claude</strong> - Haiku 4.0 (fast, cheap) & Sonnet 4.5 (powerful, extended thinking)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Google Gemini</strong> - 1.5 Flash (fast) & 1.5 Pro (thorough)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>OpenAI ChatGPT</strong> - GPT-4o mini (fast) & GPT-4o (powerful)</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ” API Key Setup</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Click <strong>ðŸ”‘ Set API Key</strong> button in header</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Enter your API key from Anthropic, Google, or OpenAI</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Keys are stored in <strong>localStorage</strong> (persist across sessions)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ Get keys at: console.anthropic.com, aistudio.google.com, or platform.openai.com</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">âš¡ Rate Limits & Costs</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Server API key (default)</strong> - 200 requests/hour, 8192 max tokens per request</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Your API key</strong> - Unlimited requests (you pay for usage)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Extended Thinking</strong> - Deep Mode uses 5000 token thinking budget + response (Sonnet 4.5 only)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Tip</strong> - Use your own key to bypass rate limits and get faster responses</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ§  Extended Thinking Mode</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Available when using <strong>Sonnet 4.5</strong> in <strong>Deep Mode</strong><br>
                            â€¢ AI thinks for up to 5000 tokens before responding<br>
                            â€¢ Better reasoning, fewer errors, more comprehensive analysis<br>
                            â€¢ Ideal for complex trees, AI Review, and prompt improvement<br>
                            â€¢ Costs more but delivers significantly higher quality
                        </p>
                    </div>

                    <h3 style="color: var(--phase-3); margin-bottom: 16px; font-size: 20px;">ðŸ“Š Presentations & Sharing</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-3);">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy is perfect for investor meetings and stakeholder presentations!</strong>
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ¯ Visual Impact</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Use "â¬‡ï¸ Expand" button to show complete roadmap<br>
                            â€¢ Dependency arrows show critical path in real-time<br>
                            â€¢ Phase colors guide audience through timeline<br>
                            â€¢ Click individual nodes to drill down into details
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ“Š Excel Import & Export</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Export:</strong> Professional 4-sheet workbook (Executive Summary, Details, Dependencies, PM Tracking)<br>
                            â€¢ <strong>Import:</strong> Load Excel files back into TreeListy - edit in Excel, import changes<br>
                            â€¢ <strong>Append Mode:</strong> Import multiple Excel files into one tree<br>
                            â€¢ <strong>Pattern Detection:</strong> Automatically detects project type from Excel structure<br>
                            â€¢ Perfect for board meetings, investor due diligence, and team collaboration
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ’¼ Pattern-Based Presentations</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Sales Pipeline</strong> - Show deal flow and revenue forecast<br>
                            â€¢ <strong>Product Roadmap</strong> - Display feature timeline and engineering estimates<br>
                            â€¢ <strong>AI Prompt Design</strong> - Present prompt engineering workflows<br>
                            â€¢ <strong>Strategic Planning</strong> - Show KPIs and strategic initiatives
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ¤ Pro Tips</p>
                        <p style="font-size: 13px; margin-bottom: 8px; font-style: italic; color: var(--treeplex-primary);">
                            â€¢ <strong>Excel Workflow:</strong> Export â†’ Edit in Excel with team â†’ Import back to TreeListy<br>
                            â€¢ Use AI Wizard before meetings to quickly build comprehensive plans<br>
                            â€¢ Generate Prompt to share project structure with AI assistants<br>
                            â€¢ Import multiple Excel files using Append Mode to combine analyses<br>
                            â€¢ Use Undo (Ctrl+Z) to safely experiment during live demos
                        </p>
                    </div>

                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">âŒ¨ï¸ Keyboard Shortcuts & Tips</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--treeplex-primary);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Keyboard Shortcuts</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Ctrl+Z / Cmd+Z</strong> - Undo last action (keeps 50 states in history)<br>
                            â€¢ Works everywhere except when typing in text fields
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Navigation</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Click nodes</strong> to expand/collapse or view details<br>
                            â€¢ <strong>Right-click anywhere</strong> for context menus<br>
                            â€¢ <strong>â¬‡ï¸ Expand / â¬†ï¸ Collapse buttons</strong> - Control all phases at once<br>
                            â€¢ <strong>Mouse wheel</strong> - Zoom in/out<br>
                            â€¢ <strong>Pan controls</strong> - Navigate large trees
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Visual Cues</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">
                            â€¢ <strong>Indented items</strong> - Depend on items above them<br>
                            â€¢ <strong>Dependency arrows</strong> - Show cross-phase relationships<br>
                            â€¢ <strong>Phase colors</strong> - Guide through timeline (green â†’ blue â†’ orange â†’ purple)<br>
                            â€¢ <strong>Hover effects</strong> - 3D pop effects on items
                        </p>
                    </div>

                    <h3 style="color: var(--phase-4); margin-bottom: 16px; font-size: 20px;">ðŸ”§ Advanced Features</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; border-left: 3px solid var(--phase-4);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ­ Pattern System (9 Built-in + Custom)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Generic Project</strong> - Universal template for any project</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Sales Pipeline</strong> - Deals, contacts, follow-ups, close dates</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Academic Writing</strong> - Thesis, arguments, citations, evidence</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Product Roadmap</strong> - Features, story points, user impact, technical specs</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Book Writing</strong> - Chapters, scenes, character arcs, plot points</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Course Design</strong> - Modules, lessons, activities, assessments</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>AI Prompt Engineering</strong> - System prompts, few-shot examples, chain-of-thought</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Film Production</strong> - Scenes, Sora/Veo video prompts, camera angles, lighting</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Philosophy</strong> - Arguments, premises, objections, textual references</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ›¡ï¸ Smart Merge Data Protection</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Never loses your data</strong> - AI updates preserve all existing content</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Fuzzy name matching</strong> - Finds related items even if names differ slightly</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Additive updates only</strong> - AI can add or update, but never deletes</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Transparent logging</strong> - Console shows exactly what was merged, added, or preserved</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Safe experimentation</strong> - Try AI features without fear of data loss</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ¯ Pattern-Specific AI Behavior</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">Each pattern has specialized AI intelligence:</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Philosophy</strong> - AI suggests premises, objections, supporting evidence, textual citations</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Sales</strong> - AI suggests follow-up actions, next steps, competitive positioning, deal strategies</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Film</strong> - AI generates production-ready Sora/Veo prompts with camera angles, lighting, blocking</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>AI Prompt</strong> - AI transforms basic prompts into comprehensive prompts with system/user/examples</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Roadmap</strong> - AI suggests implementation tasks, technical specs, acceptance criteria, story points</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Book</strong> - AI suggests scenes, character moments, plot developments, narrative arcs</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">âš™ï¸ Other Advanced Features</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Dependencies</strong> - Track relationships between items across phases with visual arrows</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>PM Tracking</strong> - Status, assignees, dates, progress, priorities, blocking issues</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Context Notes</strong> - Add project background for better AI suggestions and team alignment</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Shareable URLs</strong> - Compress and share entire projects via URL (base64 encoding)</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Auto-save</strong> - Your work is preserved in browser localStorage automatically</p>
                        <p style="font-size: 13px;">â€¢ <strong>Custom Patterns</strong> - Create your own pattern with custom fields, labels, and hierarchies</p>
                    </div>

                    <div style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.1), rgba(59, 143, 204, 0.1)); border-radius: 8px; text-align: center;">
                        <p style="font-size: 14px; font-weight: 600; color: var(--treeplex-primary); margin-bottom: 8px;">
                            ðŸš€ Ready to build something amazing?
                        </p>
                        <p style="font-size: 13px; opacity: 0.9; margin-bottom: 12px;">
                            Start with the AI Wizard for instant guidance, or choose a pattern and dive in!
                        </p>
                        <p style="font-size: 12px; opacity: 0.7;">
                            ðŸ§™ Pro tip: Try "ðŸ§™ AI Wizard" â†’ describe your project â†’ watch the magic happen
                        </p>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
        });

        // =============================================================================
        // EXCEL EXPORT - Professional Multi-Sheet Workbook for Investors
        // =============================================================================

        function exportToExcel() {
            // Create a new workbook
            const wb = XLSX.utils.book_new();

            // Collect all items AND subtasks from the tree (proper phase structure)
            const allItems = [];
            const allTasks = []; // Subtasks for separate PM sheet (recursive)

            // RECURSIVE function to collect nested subtasks from multiple data shapes
            function collectSubtasks(parentItem, parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel = 0) {
                const subtaskCandidates = [];
                const seenIds = new Set();

                if (Array.isArray(parentItem.subItems) && parentItem.subItems.length > 0) {
                    parentItem.subItems.forEach((subtask, index) => {
                        const id = subtask.id || `${parentItem.id || 'item'}-sub-${index}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            subtaskCandidates.push({ ...subtask, id });
                        }
                    });
                }

                if (Array.isArray(parentItem.children) && parentItem.children.length > 0) {
                    parentItem.children
                        .filter(child => child.type === 'subtask')
                        .forEach((child, index) => {
                            const id = child.id || `${parentItem.id || 'item'}-child-${index}`;
                            if (!seenIds.has(id)) {
                                seenIds.add(id);
                                subtaskCandidates.push({ ...child, id });
                            }
                        });
                }

                if (Array.isArray(parentItem.subtasks) && parentItem.subtasks.length > 0) {
                    parentItem.subtasks.forEach((entry, index) => {
                        const normalized = typeof entry === 'string'
                            ? { name: entry }
                            : { ...entry };
                        const id = normalized.id || `${parentItem.id || 'item'}-simple-${index}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            subtaskCandidates.push({
                                type: normalized.type || 'subtask',
                                ...normalized,
                                id
                            });
                        }
                    });
                }

                if (subtaskCandidates.length === 0) {
                    return;
                }

                subtaskCandidates.forEach(subtask => {
                    const indent = '  '.repeat(nestLevel); // Indentation for hierarchy
                    allTasks.push({
                        ...subtask,
                        parentItem: parentName,
                        parentItemId: parentItem.id,
                        phaseName: phaseName,
                        phaseSubtitle: phaseSubtitle,
                        phaseNumber: phaseNumber,
                        nestLevel: nestLevel,
                        taskName: indent + (subtask.name || 'Subtask')
                    });

                    // RECURSIVELY collect nested subtasks
                    collectSubtasks(subtask, subtask.name || parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel + 1);
                });
            }

            function collectItems(node) {
                // Collect items from this phase node
                if (node.items && Array.isArray(node.items)) {
                    node.items.forEach(item => {
                        allItems.push({
                            ...item,
                            phaseName: node.name || 'Unknown Phase',
                            phaseSubtitle: node.subtitle || '',
                            phaseNumber: node.phase || '0'
                        });

                        // Collect subtasks recursively for PM tracking
                        collectSubtasks(item, item.name, node.name || 'Unknown Phase', node.subtitle || '', node.phase || '0', 0);
                    });
                }

                // Recursively collect from child phases
                if (node.children && Array.isArray(node.children)) {
                    node.children.forEach(child => {
                        collectItems(child);
                    });
                }
            }
            collectItems(capexTree);

            // Calculate totals
            const totalCost = allItems.reduce((sum, item) => sum + (item.cost || 0), 0);

            // Group by phase dynamically
            const phaseBreakdown = {};
            allItems.forEach(item => {
                const phaseKey = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;
                if (!phaseBreakdown[phaseKey]) {
                    phaseBreakdown[phaseKey] = { total: 0, count: 0, phaseNumber: item.phaseNumber };
                }
                phaseBreakdown[phaseKey].total += (item.cost || 0);
                phaseBreakdown[phaseKey].count++;
            });

            // =================================================================
            // SHEET 1: EXECUTIVE SUMMARY
            // =================================================================
            const resolvePatternName = () => {
                if (capexTree.pattern) {
                    const patternKey = getPatternKey(capexTree.pattern);
                    if (patternKey) {
                        if (patternKey === 'custom') {
                            const labels = capexTree.pattern.labels || {};
                            return labels.root ? `Custom (${labels.root})` : 'Custom Pattern';
                        }
                        if (PATTERNS[patternKey]) {
                            return PATTERNS[patternKey].name;
                        }
                    }
                }
                if (PATTERNS[currentPattern]) {
                    return PATTERNS[currentPattern].name;
                }
                return 'Generic Project';
            };

            const patternNameForSummary = resolvePatternName();

            const summaryData = [
                ['TREEPLEXITY - PROJECT SUMMARY'],
                ['by geej', '', '', ''],
                [],
                ['Project:', capexTree.name || 'Project Plan'],
                ['Pattern:', patternNameForSummary],
                ['Total Cost:', `$${(totalCost / 1000000).toFixed(2)}M`],
                ['Items Count:', allItems.length],
                ['Report Date:', new Date().toLocaleDateString()],
                [],
                ['INVESTMENT BREAKDOWN BY PHASE'],
                [],
                ['Phase', 'Investment', 'Percentage', 'Items']
            ];

            // Add phase rows dynamically (sorted by phase number)
            Object.entries(phaseBreakdown)
                .sort((a, b) => (a[1].phaseNumber || 0) - (b[1].phaseNumber || 0))
                .forEach(([phaseName, data]) => {
                    const phasePercentage = totalCost > 0 ? `${((data.total / totalCost) * 100).toFixed(1)}%` : '0%';
                    summaryData.push([
                        phaseName,
                        `$${(data.total / 1000000).toFixed(2)}M`,
                        phasePercentage,
                        data.count
                    ]);
                });

            // Add total row
            summaryData.push(['TOTAL', `$${(totalCost / 1000000).toFixed(2)}M`, totalCost > 0 ? '100.0%' : '0%', allItems.length]);

            // Add key metrics
            summaryData.push([]);
            summaryData.push(['KEY METRICS']);
            summaryData.push([]);
            summaryData.push(['Metric', 'Value']);
            summaryData.push(['Average Item Cost', allItems.length > 0 ? `$${(totalCost / allItems.length / 1000).toFixed(0)}K` : '$0']);
            summaryData.push(['Largest Single Item', allItems.length > 0 ? `$${(Math.max(...allItems.map(i => i.cost || 0)) / 1000000).toFixed(2)}M` : '$0']);
            summaryData.push(['Items with Dependencies', allItems.filter(i => i.dependencies && i.dependencies.length > 0).length]);
            summaryData.push(['Items with Alternate Sources', allItems.filter(i => i.alternateSource).length]);

            const ws_summary = XLSX.utils.aoa_to_sheet(summaryData);

            // Set column widths
            ws_summary['!cols'] = [
                { wch: 30 },  // Column A
                { wch: 20 },  // Column B
                { wch: 15 },  // Column C
                { wch: 15 }   // Column D
            ];

            // Add to workbook
            XLSX.utils.book_append_sheet(wb, ws_summary, 'ðŸ“Š Executive Summary');

            // =================================================================
            // SHEET 2: DETAILED ITEMS (PATTERN-AWARE)
            // =================================================================

            // Get current pattern for dynamic columns
            const currentPatternDef = PATTERNS[currentPattern];
            const patternFields = currentPatternDef.fields || {};

            // Build dynamic column headers
            const baseColumns = ['Item Name', 'Phase', 'Type', 'Description'];
            const patternColumns = [];
            const patternFieldKeys = []; // Track field keys for data extraction

            // Add all pattern-specific fields dynamically
            Object.keys(patternFields).forEach(fieldKey => {
                const fieldConfig = patternFields[fieldKey];
                // Skip non-field properties
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }
                if (fieldConfig.label) {
                    patternColumns.push(fieldConfig.label);
                    patternFieldKeys.push(fieldKey);
                }
            });

            const endColumns = ['Dependencies', 'Notes'];
            const allColumns = [...baseColumns, ...patternColumns, ...endColumns];

            // Build column widths dynamically
            const columnWidths = [
                { wch: 30 },  // Item Name
                { wch: 25 },  // Phase
                { wch: 20 },  // Type
                { wch: 40 }   // Description
            ];

            // Add widths for pattern columns
            patternColumns.forEach(col => {
                // Determine width based on field type
                if (col.includes('Date')) {
                    columnWidths.push({ wch: 12 });
                } else if (col.includes('$') || col.includes('Cost') || col.includes('Value')) {
                    columnWidths.push({ wch: 15 });
                } else if (col.includes('%') || col.includes('Points')) {
                    columnWidths.push({ wch: 10 });
                } else if (col.length > 20) {
                    columnWidths.push({ wch: 35 }); // Long labels get more space
                } else {
                    columnWidths.push({ wch: 20 }); // Default width
                }
            });

            columnWidths.push({ wch: 30 }); // Dependencies
            columnWidths.push({ wch: 40 }); // Notes

            const itemsData = [
                [`DETAILED PROJECT ITEMS - ${currentPatternDef.name}`],
                [],
                allColumns
            ];

            // Add item rows with dynamic pattern fields
            allItems.forEach(item => {
                const phaseDisplay = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;

                const rowData = [
                    item.name || '',
                    phaseDisplay,
                    item.itemType || '',
                    item.description || ''
                ];

                // Add pattern-specific field values
                patternFieldKeys.forEach(fieldKey => {
                    const fieldConfig = patternFields[fieldKey];
                    let value = item[fieldKey];

                    if (value === undefined || value === null || value === '') {
                        rowData.push('');
                        return;
                    }

                    // Format based on field type
                    if (fieldConfig.type === 'number') {
                        // Special handling for cost (convert to millions)
                        if (fieldKey === 'cost' && fieldConfig.label.includes('($M)')) {
                            value = (value / 1000000).toFixed(2);
                        } else if (fieldKey === 'dealValue') {
                            value = (value / 1000).toFixed(0); // Thousands
                        } else {
                            value = value.toString();
                        }
                    } else if (fieldConfig.type === 'date') {
                        value = value; // Keep as-is (Excel will format)
                    } else if (fieldConfig.type === 'textarea') {
                        value = value.replace(/\n/g, ' '); // Remove newlines for Excel
                    }

                    rowData.push(value);
                });

                // Add dependencies and notes
                rowData.push((item.dependencies || []).length > 0 ? item.dependencies.join(', ') : 'None');
                rowData.push(item.notes || '');

                itemsData.push(rowData);
            });

            // Add total row (only for patterns with cost field)
            itemsData.push([]);
            if (patternFields.cost || patternFields.dealValue) {
                const totalRow = ['TOTAL', '', '', ''];

                // Find the cost column index
                const costFieldKey = patternFields.cost ? 'cost' : 'dealValue';
                const costIndex = patternFieldKeys.indexOf(costFieldKey);

                // Fill blanks up to cost column
                for (let i = 0; i < patternFieldKeys.length; i++) {
                    if (i === costIndex) {
                        if (costFieldKey === 'cost') {
                            totalRow.push((totalCost / 1000000).toFixed(2));
                        } else {
                            // Sum dealValue for sales pipeline
                            const totalDealValue = allItems.reduce((sum, item) => sum + (item.dealValue || 0), 0);
                            totalRow.push((totalDealValue / 1000).toFixed(0));
                        }
                    } else {
                        totalRow.push('');
                    }
                }

                totalRow.push('', ''); // Dependencies, Notes
                itemsData.push(totalRow);
            }

            const ws_items = XLSX.utils.aoa_to_sheet(itemsData);
            ws_items['!cols'] = columnWidths;

            XLSX.utils.book_append_sheet(wb, ws_items, 'ðŸ“‹ Detailed Items');

            // =================================================================
            // SHEET 3: DEPENDENCIES MATRIX
            // =================================================================
            const depsData = [
                ['DEPENDENCY MATRIX'],
                [],
                ['Item', 'Depends On', 'Count', 'Critical Path?']
            ];

            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    depsData.push([
                        item.name || '',
                        item.dependencies.join(', '),
                        item.dependencies.length,
                        item.dependencies.length > 2 ? 'Yes' : 'No'
                    ]);
                }
            });

            if (depsData.length === 3) {
                depsData.push(['No dependencies defined yet', '', '', '']);
            }

            const ws_deps = XLSX.utils.aoa_to_sheet(depsData);

            ws_deps['!cols'] = [
                { wch: 35 },
                { wch: 50 },
                { wch: 10 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_deps, 'ðŸ”— Dependencies');

            // =================================================================
            // SHEET 4: COST ANALYSIS BY TYPE
            // =================================================================
            const typeBreakdown = {};
            allItems.forEach(item => {
                const type = item.itemType || 'Uncategorized';
                if (!typeBreakdown[type]) {
                    typeBreakdown[type] = { count: 0, total: 0 };
                }
                typeBreakdown[type].count++;
                typeBreakdown[type].total += (item.cost || 0);
            });

            const analysisData = [
                ['COST ANALYSIS BY TYPE'],
                [],
                ['Item Type', 'Count', 'Total Cost ($M)', '% of Total', 'Avg Cost ($K)']
            ];

            Object.entries(typeBreakdown)
                .sort((a, b) => b[1].total - a[1].total)
                .forEach(([type, data]) => {
                    analysisData.push([
                        type,
                        data.count,
                        (data.total / 1000000).toFixed(2),
                        ((data.total / totalCost) * 100).toFixed(1) + '%',
                        (data.total / data.count / 1000).toFixed(0)
                    ]);
                });

            analysisData.push([]);
            analysisData.push(['TOTAL', allItems.length, (totalCost / 1000000).toFixed(2), '100.0%', (totalCost / allItems.length / 1000).toFixed(0)]);

            const ws_analysis = XLSX.utils.aoa_to_sheet(analysisData);

            ws_analysis['!cols'] = [
                { wch: 30 },
                { wch: 10 },
                { wch: 18 },
                { wch: 12 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_analysis, 'ðŸ“ˆ Cost Analysis');

            // =================================================================
            // SHEET 5: PROJECT TASKS (PM TRACKING)
            // =================================================================
            const tasksData = [
                ['PROJECT TASKS - EXECUTION TRACKING (HIERARCHICAL)'],
                ['Professional Project Management Dashboard', '', '', '', '', '', '', '', '', '', '', ''],
                [],
                ['Task Name', 'Level', 'Parent Item', 'Phase', 'Status', 'Assignee', 'Progress %', 'Priority', 'Start Date', 'Due Date', 'Blocking Issue', 'Next Steps', 'Latest Updates']
            ];

            // Add task rows
            if (allTasks.length > 0) {
                allTasks.forEach(task => {
                    const phaseDisplay = `${task.phaseName}${task.phaseSubtitle ? ' (' + task.phaseSubtitle + ')' : ''}`;

                    // Format updates as timestamped entries
                    let updatesText = '';
                    if (task.pmUpdates && Array.isArray(task.pmUpdates) && task.pmUpdates.length > 0) {
                        updatesText = task.pmUpdates
                            .map(u => `[${new Date(u.timestamp).toLocaleDateString()}] ${u.text}`)
                            .join(' | ');
                    }

                    tasksData.push([
                        task.taskName || task.name || '',  // Use indented taskName for hierarchy
                        task.nestLevel || 0,
                        task.parentItem || '',
                        phaseDisplay,
                        task.pmStatus || 'To Do',
                        task.pmAssignee || 'Unassigned',
                        task.pmProgress || 0,
                        task.pmPriority || 'Medium',
                        task.pmStartDate || '',
                        task.pmDueDate || '',
                        task.pmBlockingIssue || '',
                        task.pmNextSteps || '',
                        updatesText
                    ]);
                });
            } else {
                tasksData.push(['No tasks created yet', '', '', '', '', '', '', '', '', '', '', '', '']);
            }

            // Add summary metrics
            tasksData.push([]);
            tasksData.push(['TASK SUMMARY METRICS']);
            tasksData.push([]);

            const completedTasks = allTasks.filter(t => t.pmStatus === 'Done').length;
            const inProgressTasks = allTasks.filter(t => t.pmStatus === 'In Progress').length;
            const blockedTasks = allTasks.filter(t => t.pmStatus === 'Blocked').length;
            const avgProgress = allTasks.length > 0 ? (allTasks.reduce((sum, t) => sum + (t.pmProgress || 0), 0) / allTasks.length).toFixed(1) : 0;

            tasksData.push(['Total Tasks', allTasks.length]);
            tasksData.push(['Completed', completedTasks, `${allTasks.length > 0 ? ((completedTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['In Progress', inProgressTasks, `${allTasks.length > 0 ? ((inProgressTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['Blocked', blockedTasks, blockedTasks > 0 ? 'âš ï¸ ATTENTION REQUIRED' : '']);
            tasksData.push(['Average Progress', `${avgProgress}%`]);
            tasksData.push([]);
            tasksData.push(['Status Distribution']);

            // Status breakdown
            const statusCounts = {};
            allTasks.forEach(t => {
                const status = t.pmStatus || 'To Do';
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });

            Object.entries(statusCounts)
                .sort((a, b) => b[1] - a[1])
                .forEach(([status, count]) => {
                    tasksData.push([status, count, `${((count/allTasks.length)*100).toFixed(1)}%`]);
                });

            const ws_tasks = XLSX.utils.aoa_to_sheet(tasksData);

            // Set column widths for professional presentation
            ws_tasks['!cols'] = [
                { wch: 40 },  // Task Name (with indentation)
                { wch: 8 },   // Level
                { wch: 30 },  // Parent Item
                { wch: 25 },  // Phase
                { wch: 15 },  // Status
                { wch: 20 },  // Assignee
                { wch: 12 },  // Progress %
                { wch: 12 },  // Priority
                { wch: 15 },  // Start Date
                { wch: 15 },  // Due Date
                { wch: 35 },  // Blocking Issue
                { wch: 40 },  // Next Steps
                { wch: 60 }   // Latest Updates
            ];

            XLSX.utils.book_append_sheet(wb, ws_tasks, 'âœ… Project Tasks');

            // =================================================================
            // GENERATE AND DOWNLOAD FILE
            // =================================================================
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `TreeListy-${timestamp}.xlsx`;

            XLSX.writeFile(wb, filename);

            // Show success message
            alert(`âœ… Excel export successful!\n\nFile: ${filename}\n\nIncludes:\nâ€¢ Executive Summary\nâ€¢ Detailed Items (${allItems.length} items)\nâ€¢ Dependencies Matrix\nâ€¢ Cost Analysis by Type\nâ€¢ Project Tasks (${allTasks.length} tasks with PM tracking)\n\nProfessionally formatted and ready for investor presentations! ðŸ“Š`);
        }

        // Excel Export button handler
        document.getElementById('excel-export-btn').addEventListener('click', exportToExcel);

        // =============================================================================
        // EXCEL IMPORT - Import from Excel back to TreeListy
        // =============================================================================

        // =============================================================================
        // FLEXIBLE EXCEL IMPORT - Import ANY Excel file with column mapping
        // =============================================================================

        let excelImportState = {
            workbook: null,
            file: null,
            selectedSheet: null,
            headers: [],
            sampleData: [],
            columnMapping: {},
            hierarchyConfig: {},
            pattern: null
        };

        function importFromExcel(file) {
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });

                    console.log('ðŸ“¥ Excel workbook loaded:', workbook.SheetNames);

                    excelImportState.workbook = workbook;
                    excelImportState.file = file.name;

                    // Check if this is a TreeListy export (fast automatic import)
                    if (workbook.SheetNames.includes('ðŸ“‹ Detailed Items')) {
                        console.log('âœ… TreeListy export detected - importing automatically');
                        importTreeListyExcel(workbook);
                        return;
                    }

                    // Not a TreeListy export - use flexible import wizard
                    console.log('ðŸ“‹ Generic Excel file - launching mapping wizard');
                    startFlexibleImportWizard(workbook);

                } catch (err) {
                    console.error('âŒ Excel import error:', err);
                    alert('âŒ Failed to read Excel file!\n\n' + err.message);
                }
            };

            reader.readAsArrayBuffer(file);
        }

        function showImportModeChoice(workbook) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ“¥ Excel Import Mode';

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 24px;">
                        This appears to be a TreeListy export. Choose how to import:
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="import-mode-fast" style="flex: 1; padding: 20px; border: 2px solid var(--treeplex-primary); border-radius: 12px; cursor: pointer; transition: all 0.2s; background: rgba(0, 166, 125, 0.05);">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">âš¡</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Fast Import
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Automatically import using TreeListy format. Perfect fidelity, instant import.
                            </div>
                        </div>

                        <div id="import-mode-custom" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">ðŸŽ¯</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Custom Mapping
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Map columns manually, customize field mappings, handle custom formats.
                            </div>
                        </div>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Hover effects
            ['import-mode-fast', 'import-mode-custom'].forEach(id => {
                const elem = document.getElementById(id);
                elem.addEventListener('mouseenter', () => {
                    elem.style.transform = 'translateY(-2px)';
                    elem.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
                });
                elem.addEventListener('mouseleave', () => {
                    elem.style.transform = 'translateY(0)';
                    elem.style.boxShadow = 'none';
                });
            });

            // Fast import handler
            document.getElementById('import-mode-fast').addEventListener('click', () => {
                modal.style.display = 'none';
                importTreeListyExcel(workbook);
            });

            // Custom import handler
            document.getElementById('import-mode-custom').addEventListener('click', () => {
                modal.style.display = 'none';
                startFlexibleImportWizard(workbook);
            });
        }

        function importTreeListyExcel(workbook) {
            try {

                    // Parse the "ðŸ“‹ Detailed Items" sheet
                    const itemsSheet = workbook.Sheets['ðŸ“‹ Detailed Items'];
                    const itemsData = XLSX.utils.sheet_to_json(itemsSheet, { header: 1 });

                    console.log('ðŸ“‹ Parsed items data:', itemsData.length, 'rows');

                    // Find the header row (contains "Item Name")
                    let headerRowIndex = -1;
                    for (let i = 0; i < itemsData.length; i++) {
                        if (itemsData[i][0] === 'Item Name') {
                            headerRowIndex = i;
                            break;
                        }
                    }

                    if (headerRowIndex === -1) {
                        alert('âŒ Invalid Excel format!\n\nCould not find the "Item Name" header row.');
                        return;
                    }

                    const headers = itemsData[headerRowIndex];
                    console.log('ðŸ“‹ Headers:', headers);

                    // Parse items (skip header and empty rows)
                    const items = [];
                    for (let i = headerRowIndex + 1; i < itemsData.length; i++) {
                        const row = itemsData[i];

                        // Skip empty rows or total row
                        if (!row[0] || row[0] === 'TOTAL') continue;

                        const item = {};
                        headers.forEach((header, index) => {
                            if (header && row[index] !== undefined && row[index] !== '') {
                                item[header] = row[index];
                            }
                        });

                        items.push(item);
                    }

                    console.log('âœ… Parsed', items.length, 'items from Excel');

                    // Detect pattern from the data structure
                    const detectedPattern = detectPatternFromExcel(items, headers);
                    console.log('ðŸŽ¨ Detected pattern:', detectedPattern);

                    // Convert items to tree structure
                    const newTree = convertExcelToTree(items, detectedPattern);

                    // Auto-import TreeListy exports (simple confirmation only)
                    const confirmMsg = `Import ${items.length} items from Excel?\n\nThis will replace your current tree.`;
                    if (confirm(confirmMsg)) {
                        saveState('Excel Import');
                        capexTree = newTree;
                        currentPattern = detectedPattern;
                        document.getElementById('pattern-select').value = detectedPattern;
                        render();
                        showToast(`âœ… Excel imported! ${items.length} items loaded`);
                        console.log('âœ… TreeListy export auto-imported');
                    }

            } catch (err) {
                console.error('âŒ Excel import error:', err);
                alert('âŒ Failed to import Excel file!\n\n' + err.message + '\n\nPlease ensure this is a valid TreeListy Excel export.');
            }
        }

        function detectPatternFromExcel(items, headers) {
            // Check for pattern-specific columns
            if (headers.includes('Deal Value ($)') || headers.includes('Stage Probability (%)')) {
                return 'sales';
            } else if (headers.includes('Word Count') || headers.includes('Draft Status')) {
                return 'thesis';
            } else if (headers.includes('Story Points') || headers.includes('Engineering Estimate')) {
                return 'roadmap';
            } else if (headers.includes('Use Case') || headers.includes('Target Model')) {
                return 'prompt';
            } else if (headers.includes('Chapter Number') || headers.includes('Section Type')) {
                return 'book';
            } else if (headers.includes('Argument Type') || headers.includes('Philosophical School')) {
                return 'philosophy';
            } else if (headers.includes('KPI') || headers.includes('Strategic Priority')) {
                return 'strategy';
            } else if (headers.includes('Cost ($M)') && headers.includes('Lead Time')) {
                return 'generic';
            }

            // Default to current pattern
            return currentPattern;
        }

        function convertExcelToTree(items, pattern) {
            const patternDef = PATTERNS[pattern];
            const levels = patternDef.levels;

            // Group items by phase
            const phaseMap = {};

            items.forEach(item => {
                const phaseName = item.Phase || item[levels.phase];

                if (!phaseName) return;

                // Extract phase number and subtitle if present
                const phaseMatch = phaseName.match(/^(.+?)\s*\((.*?)\)$/);
                const basePhaseName = phaseMatch ? phaseMatch[1].trim() : phaseName;
                const phaseSubtitle = phaseMatch ? phaseMatch[2].trim() : '';

                if (!phaseMap[basePhaseName]) {
                    phaseMap[basePhaseName] = {
                        name: basePhaseName,
                        subtitle: phaseSubtitle,
                        items: []
                    };
                }

                // Convert item data back to tree format
                const treeItem = {
                    name: item['Item Name'] || item.name || 'Unnamed Item',
                    description: item.Description || item.description || '',
                    type: 'item',
                    icon: 'ðŸ“¦'
                };

                // Map pattern-specific fields dynamically
                const fields = patternDef.fields;
                if (fields) {
                    Object.keys(fields).forEach(fieldKey => {
                        const fieldConfig = fields[fieldKey];

                        // Skip non-field properties
                        if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                            return;
                        }

                        const excelColumnName = fieldConfig.label;

                        if (item[excelColumnName] !== undefined && item[excelColumnName] !== '' && item[excelColumnName] !== null) {
                            let value = item[excelColumnName];

                            // Convert numeric fields
                            if (fieldConfig.type === 'number') {
                                // Handle cost (exported in millions, import back to raw)
                                if (fieldKey === 'cost' && fieldConfig.label.includes('($M)')) {
                                    value = parseFloat(value) * 1000000;
                                } else if (fieldKey === 'dealValue') {
                                    // dealValue exported in thousands, import back to raw
                                    value = parseFloat(value) * 1000;
                                } else {
                                    value = parseFloat(value);
                                }
                            } else if (fieldConfig.type === 'date') {
                                // Keep dates as-is (Excel format)
                                value = value;
                            } else if (fieldConfig.type === 'select') {
                                // Ensure select value is string
                                value = value.toString();
                            } else if (fieldConfig.type === 'textarea') {
                                // Textarea values are already strings
                                value = value.toString();
                            } else {
                                // Text fields
                                value = value.toString();
                            }

                            treeItem[fieldKey] = value;
                        }
                    });
                }

                // Handle dependencies
                if (item.Dependencies && item.Dependencies !== 'None') {
                    treeItem.dependencies = item.Dependencies.split(', ').map(d => d.trim());
                }

                // Handle item type
                if (item.Type) {
                    treeItem.itemType = item.Type;
                }

                phaseMap[basePhaseName].items.push(treeItem);
            });

            // Convert phase map to tree structure
            const phases = Object.values(phaseMap).map((phase, index) => {
                return {
                    id: `phase-${index}`,
                    type: 'phase',
                    phase: index,
                    name: phase.name,
                    subtitle: phase.subtitle,
                    icon: `${index + 1}ï¸âƒ£`,
                    expanded: false,
                    items: phase.items.map((item, itemIndex) => ({
                        ...item,
                        id: `item-${index}-${itemIndex}`
                    }))
                };
            });

            // Create new tree
            const newTree = {
                id: 'root',
                type: 'root',
                name: items[0]?.Project || capexTree.name || 'Imported Project',
                icon: 'ðŸŒ³',
                expanded: true,
                children: phases,
                pattern: {
                    key: pattern,
                    labels: levels
                }
            };

            return newTree;
        }

        function showImportConfirmation(newTree, itemCount, pattern) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ“¥ Import from Excel';

            const patternInfo = PATTERNS[pattern];
            const phaseCount = newTree.children?.length || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 20px; border-radius: 12px; margin-bottom: 24px;">
                        <h3 style="margin: 0 0 12px 0; color: var(--treeplex-primary);">ðŸ“Š Import Summary</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 14px;">
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">Pattern Detected</div>
                                <div style="font-weight: 600;">${patternInfo.icon} ${patternInfo.levels.root}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">${patternInfo.levels.phase}s</div>
                                <div style="font-weight: 600;">${phaseCount}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">${patternInfo.levels.item}s</div>
                                <div style="font-weight: 600;">${itemCount}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">Project Name</div>
                                <div style="font-weight: 600;">${newTree.name}</div>
                            </div>
                        </div>
                    </div>

                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 24px; border-left: 3px solid var(--treeplex-primary);">
                        <p style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600;">Import Mode</p>
                        <p style="margin: 0 0 16px 0; font-size: 13px; color: var(--text-secondary);">
                            How would you like to import this Excel file?
                        </p>

                        <div style="display: flex; gap: 12px;">
                            <button id="import-replace-btn" class="btn" style="flex: 1; background: linear-gradient(135deg, #f59e0b, #d97706); padding: 12px;">
                                ðŸ”„ Replace Current Tree
                            </button>
                            <button id="import-append-btn" class="btn" style="flex: 1; background: linear-gradient(135deg, var(--treeplex-primary), #059669); padding: 12px;">
                                âž• Append to Current Tree
                            </button>
                        </div>
                    </div>

                    <div style="background: rgba(239, 68, 68, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #ef4444;">
                        <p style="margin: 0; font-size: 12px; color: var(--text-secondary);">
                            âš ï¸ <strong>Replace</strong> will overwrite your current project. <strong>Append</strong> will add items to existing phases.
                        </p>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Handle replace
            document.getElementById('import-replace-btn').addEventListener('click', () => {
                saveState('Excel Import: Replace');

                // Replace tree
                capexTree = newTree;
                currentPattern = pattern;
                document.getElementById('pattern-select').value = pattern;

                render();
                modal.style.display = 'none';

                showToast(`âœ… Excel imported! ${itemCount} items loaded`);
                console.log('âœ… Excel import complete (replace mode)');
            });

            // Handle append
            document.getElementById('import-append-btn').addEventListener('click', () => {
                saveState('Excel Import: Append');

                // Append phases and items
                newTree.children.forEach((newPhase, newPhaseIndex) => {
                    const existingPhase = capexTree.children?.[newPhaseIndex];

                    if (existingPhase) {
                        // Phase exists - append items
                        if (newPhase.items && newPhase.items.length > 0) {
                            const currentItemCount = existingPhase.items?.length || 0;

                            // Re-ID items
                            const reIdedItems = newPhase.items.map((item, idx) => ({
                                ...item,
                                id: `item-${newPhaseIndex}-${currentItemCount + idx}`
                            }));

                            existingPhase.items = [...(existingPhase.items || []), ...reIdedItems];
                        }
                    } else {
                        // Phase doesn't exist - add it
                        if (!capexTree.children) capexTree.children = [];
                        newPhase.id = `phase-${capexTree.children.length}`;
                        newPhase.phase = capexTree.children.length;
                        capexTree.children.push(newPhase);
                    }
                });

                render();
                modal.style.display = 'none';

                showToast(`âœ… Excel imported! ${itemCount} items added`);
                console.log('âœ… Excel import complete (append mode)');
            });
        }

        // =============================================================================
        // FLEXIBLE EXCEL IMPORT WIZARD - Import any Excel file with column mapping
        // =============================================================================

        function startFlexibleImportWizard(workbook) {
            console.log('ðŸ§™ Starting flexible import wizard...');

            excelImportState.workbook = workbook;

            // If only one sheet, skip to column mapping
            if (workbook.SheetNames.length === 1) {
                analyzeSheetStructure(workbook.SheetNames[0]);
                return;
            }

            // Multiple sheets - show selection UI
            showSheetSelection(workbook);
        }

        function showSheetSelection(workbook) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ“‘ Select Sheet to Import';

            let sheetsHTML = '';
            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                const rowCount = data.length;
                const colCount = data[0]?.length || 0;

                // Preview first 3 rows
                const preview = data.slice(0, 3)
                    .map(row => row.slice(0, 5).join(', '))
                    .join('<br>');

                sheetsHTML += `
                    <div class="sheet-option" data-sheet="${sheetName}" style="border: 2px solid var(--border); padding: 16px; margin-bottom: 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 8px;">${sheetName}</div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                            ${rowCount} rows Ã— ${colCount} columns
                        </div>
                        <div style="font-size: 11px; font-family: monospace; color: var(--text-secondary); max-height: 60px; overflow: hidden;">
                            ${preview}
                        </div>
                    </div>
                `;
            });

            modalBody.innerHTML = `<div style="padding: 20px;">${sheetsHTML}</div>`;
            modal.style.display = 'flex';

            // Add click handlers
            document.querySelectorAll('.sheet-option').forEach(elem => {
                elem.addEventListener('click', () => {
                    const sheetName = elem.dataset.sheet;
                    analyzeSheetStructure(sheetName);
                });

                // Hover effect
                elem.addEventListener('mouseenter', () => {
                    elem.style.borderColor = 'var(--treeplex-primary)';
                    elem.style.background = 'rgba(0, 166, 125, 0.05)';
                });
                elem.addEventListener('mouseleave', () => {
                    elem.style.borderColor = 'var(--border)';
                    elem.style.background = 'transparent';
                });
            });
        }

        function analyzeSheetStructure(sheetName) {
            const sheet = excelImportState.workbook.Sheets[sheetName];
            const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            console.log('ðŸ“Š Analyzing sheet:', sheetName);

            // Find header row (first non-empty row)
            let headerRowIndex = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] && data[i].some(cell => cell !== '' && cell !== null && cell !== undefined)) {
                    headerRowIndex = i;
                    break;
                }
            }

            const headers = data[headerRowIndex].filter(h => h !== '' && h !== null && h !== undefined);
            const sampleData = data.slice(headerRowIndex + 1, headerRowIndex + 6); // 5 sample rows

            console.log('ðŸ“‹ Found headers:', headers);
            console.log('ðŸ“‹ Sample data rows:', sampleData.length);

            excelImportState.selectedSheet = sheetName;
            excelImportState.headers = headers;
            excelImportState.sampleData = sampleData;

            // Auto-suggest column mappings
            const suggestedMappings = autoSuggestColumnMappings(headers);
            excelImportState.columnMapping = suggestedMappings;

            console.log('ðŸŽ¯ Suggested mappings:', suggestedMappings);

            // Show column mapping UI
            showColumnMappingUI();
        }

        function autoSuggestColumnMappings(headers) {
            const mapping = {
                itemName: null,
                phaseName: null,
                description: null,
                itemType: null,
                dependencies: null
            };

            // Get current pattern for field suggestions
            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};

            // Try to match each header to a TreeListy field
            headers.forEach((header, index) => {
                const headerLower = header.toLowerCase().trim();

                // Match core fields
                if (headerLower.includes('name') || headerLower.includes('title') || headerLower.includes('item')) {
                    if (!mapping.itemName) mapping.itemName = index;
                } else if (headerLower.includes('phase') || headerLower.includes('quarter') || headerLower.includes('stage') || headerLower.includes('chapter') || headerLower.includes('category')) {
                    if (!mapping.phaseName) mapping.phaseName = index;
                } else if (headerLower.includes('description') || headerLower.includes('notes') || headerLower.includes('details')) {
                    if (!mapping.description) mapping.description = index;
                } else if (headerLower.includes('type') || headerLower.includes('status')) {
                    if (!mapping.itemType) mapping.itemType = index;
                } else if (headerLower.includes('depend') || headerLower.includes('prerequisite')) {
                    if (!mapping.dependencies) mapping.dependencies = index;
                }

                // Try to match pattern-specific fields
                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    if (!mapping[fieldKey] && fieldConfig.label) {
                        const fieldLabelLower = fieldConfig.label.toLowerCase().replace(/[^a-z0-9]/g, '');
                        const headerSimplified = headerLower.replace(/[^a-z0-9]/g, '');

                        // Check for similarity
                        if (fieldLabelLower === headerSimplified ||
                            fieldLabelLower.includes(headerSimplified) ||
                            headerSimplified.includes(fieldLabelLower)) {
                            mapping[fieldKey] = index;
                        }
                    }
                });
            });

            console.log('ðŸ” Auto-detected mappings:', mapping);
            return mapping;
        }

        function showColumnMappingUI() {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸŽ¯ Map Excel Columns to TreeListy Fields';

            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};
            const headers = excelImportState.headers;
            const sampleData = excelImportState.sampleData;
            const mapping = excelImportState.columnMapping;

            // Build mapping rows
            let mappingRowsHTML = '';

            // Core fields
            mappingRowsHTML += createMappingRow('Item Name', 'itemName', 'REQUIRED: Name of each item/task', mapping.itemName, true);
            mappingRowsHTML += createMappingRow('Phase/Category', 'phaseName', 'Group items by phase (optional)', mapping.phaseName, false);
            mappingRowsHTML += createMappingRow('Description', 'description', 'Item description', mapping.description, false);
            mappingRowsHTML += createMappingRow('Item Type', 'itemType', 'Type/category of item', mapping.itemType, false);

            // Pattern-specific fields
            Object.keys(fields).forEach(fieldKey => {
                const fieldConfig = fields[fieldKey];
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }

                if (fieldConfig.label) {
                    const helpText = fieldConfig.helpText || `${fieldConfig.label} field`;
                    mappingRowsHTML += createMappingRow(
                        fieldConfig.label,
                        fieldKey,
                        helpText,
                        mapping[fieldKey],
                        false
                    );
                }
            });

            // Dependencies
            mappingRowsHTML += createMappingRow('Dependencies', 'dependencies', 'Comma-separated list of dependencies', mapping.dependencies, false);

            modalBody.innerHTML = `
                <div style="padding: 20px; max-height: 70vh; overflow-y: auto;">
                    <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 16px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.6;">
                            ðŸ“‹ <strong>Sheet:</strong> ${excelImportState.selectedSheet}<br>
                            ðŸŽ¨ <strong>Pattern:</strong> ${patternDef.name}<br>
                            ðŸ“Š <strong>Rows:</strong> ${excelImportState.sampleData.length + ' (preview) / ' + (XLSX.utils.sheet_to_json(excelImportState.workbook.Sheets[excelImportState.selectedSheet], { header: 1 }).length - 1) + ' (total)'}
                        </div>
                    </div>

                    <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                        Map your Excel columns to TreeListy fields. We've pre-selected likely matches.
                    </p>

                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border);">
                                <th style="text-align: left; padding: 8px; font-size: 13px; color: var(--text-secondary);">TreeListy Field</th>
                                <th style="text-align: left; padding: 8px; font-size: 13px; color: var(--text-secondary);">Excel Column</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${mappingRowsHTML}
                        </tbody>
                    </table>

                    <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: flex-end;">
                        <button id="cancel-mapping-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                            Cancel
                        </button>
                        <button id="preview-import-btn" style="padding: 10px 20px; border: none; border-radius: 8px; background: var(--treeplex-primary); color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Preview Import â†’
                        </button>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Update mapping when dropdowns change
            document.querySelectorAll('.column-mapping-select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const fieldKey = e.target.dataset.field;
                    const columnIndex = e.target.value === '' ? null : parseInt(e.target.value);
                    excelImportState.columnMapping[fieldKey] = columnIndex;
                    console.log('ðŸ”„ Updated mapping:', fieldKey, 'â†’', columnIndex);
                });
            });

            // Cancel button
            document.getElementById('cancel-mapping-btn').addEventListener('click', () => {
                modal.style.display = 'none';
            });

            // Preview button
            document.getElementById('preview-import-btn').addEventListener('click', () => {
                // Validate required fields
                if (excelImportState.columnMapping.itemName === null) {
                    alert('âŒ Required Field Missing\n\nYou must map the "Item Name" field to import.');
                    return;
                }

                previewFlexibleImport();
            });
        }

        function createMappingRow(label, fieldKey, helpText, selectedValue, required) {
            const requiredBadge = required ? '<span style="color: var(--error); margin-left: 4px;">*</span>' : '';

            // Build options with proper selected attribute
            const headers = excelImportState.headers;
            const sampleData = excelImportState.sampleData;

            let options = '<option value="">-- Skip this column --</option>';
            headers.forEach((h, i) => {
                const isSelected = (selectedValue !== null && selectedValue !== undefined && selectedValue === i) ? 'selected' : '';
                options += `<option value="${i}" ${isSelected}>${h} (sample: ${sampleData[0]?.[i] || 'N/A'})</option>`;
            });

            return `
                <tr style="border-bottom: 1px solid var(--border);">
                    <td style="padding: 12px 8px;">
                        <div style="font-weight: 500; font-size: 14px;">
                            ${label}${requiredBadge}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">
                            ${helpText}
                        </div>
                    </td>
                    <td style="padding: 12px 8px;">
                        <select class="column-mapping-select" data-field="${fieldKey}" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px;">
                            ${options}
                        </select>
                    </td>
                </tr>
            `;
        }

        function previewFlexibleImport() {
            console.log('ðŸ‘€ Generating preview...');

            const sheet = excelImportState.workbook.Sheets[excelImportState.selectedSheet];
            const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            // Find header row
            let headerRowIndex = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] && data[i].some(cell => cell !== '' && cell !== null && cell !== undefined)) {
                    headerRowIndex = i;
                    break;
                }
            }

            const rows = data.slice(headerRowIndex + 1).filter(row => row && row.length > 0);
            const mapping = excelImportState.columnMapping;
            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};

            // Extract items
            const importedItems = [];
            const phaseMap = {};

            rows.forEach((row, rowIndex) => {
                // Skip empty rows
                if (!row[mapping.itemName] || row[mapping.itemName] === '') {
                    return;
                }

                const item = {
                    name: row[mapping.itemName] || `Item ${rowIndex + 1}`,
                    description: mapping.description !== null ? (row[mapping.description] || '') : '',
                    itemType: mapping.itemType !== null ? (row[mapping.itemType] || '') : '',
                    type: 'item',
                    icon: 'ðŸ“¦'
                };

                // Map pattern-specific fields
                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    const columnIndex = mapping[fieldKey];
                    if (columnIndex !== null && columnIndex !== undefined && row[columnIndex] !== undefined && row[columnIndex] !== '') {
                        let value = row[columnIndex];

                        // Type conversion
                        if (fieldConfig.type === 'number') {
                            value = parseFloat(value) || 0;
                            // Handle special scaling
                            if (fieldKey === 'cost' && fieldConfig.label && fieldConfig.label.includes('($M)')) {
                                value = value * 1000000;
                            } else if (fieldKey === 'dealValue') {
                                value = value * 1000;
                            }
                        }

                        item[fieldKey] = value;
                    }
                });

                // Handle dependencies
                if (mapping.dependencies !== null && row[mapping.dependencies]) {
                    const depString = String(row[mapping.dependencies]);
                    if (depString !== '' && depString.toLowerCase() !== 'none') {
                        item.dependencies = depString.split(/[,;|]/).map(d => d.trim()).filter(d => d);
                    }
                }

                // Determine phase
                const phaseName = mapping.phaseName !== null && row[mapping.phaseName]
                    ? String(row[mapping.phaseName])
                    : 'Default Phase';

                if (!phaseMap[phaseName]) {
                    phaseMap[phaseName] = [];
                }

                phaseMap[phaseName].push(item);
                importedItems.push(item);
            });

            // Generate preview HTML
            let previewHTML = '<div style="padding: 20px; max-height: 70vh; overflow-y: auto;">';

            previewHTML += `
                <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 16px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 12px 0; color: var(--treeplex-primary);">ðŸ“Š Import Preview</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; font-size: 14px;">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Pattern</div>
                            <div style="font-weight: 600;">${patternDef.icon} ${patternDef.name}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Phases</div>
                            <div style="font-weight: 600;">${Object.keys(phaseMap).length}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Items</div>
                            <div style="font-weight: 600;">${importedItems.length}</div>
                        </div>
                    </div>
                </div>
            `;

            // Show preview of first 10 items
            previewHTML += '<div style="font-weight: 600; margin-bottom: 12px;">Preview (first 10 items):</div>';
            previewHTML += '<div style="font-family: monospace; font-size: 12px; background: var(--bg-secondary); padding: 16px; border-radius: 8px; line-height: 1.8;">';

            let itemCount = 0;
            Object.keys(phaseMap).forEach((phaseName, phaseIndex) => {
                if (itemCount >= 10) return;

                previewHTML += `<div style="color: var(--treeplex-primary); font-weight: 600; margin-top: ${phaseIndex > 0 ? '12px' : '0'};">${phaseName}</div>`;

                phaseMap[phaseName].forEach((item, itemIndex) => {
                    if (itemCount >= 10) return;
                    itemCount++;

                    previewHTML += `<div style="margin-left: 20px; color: var(--text-primary);">â”œâ”€ ${item.name}`;
                    if (item.itemType) previewHTML += ` [${item.itemType}]`;
                    if (item.dependencies && item.dependencies.length > 0) {
                        previewHTML += ` <span style="color: var(--text-secondary);">â†’ Depends on: ${item.dependencies.join(', ')}</span>`;
                    }
                    previewHTML += `</div>`;
                });
            });

            if (importedItems.length > 10) {
                previewHTML += `<div style="color: var(--text-secondary); margin-top: 8px;">... and ${importedItems.length - 10} more items</div>`;
            }

            previewHTML += '</div>';

            // Action buttons
            previewHTML += `
                <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between;">
                    <button id="back-to-mapping-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                        â† Back to Mapping
                    </button>
                    <div style="display: flex; gap: 12px;">
                        <button id="execute-import-replace-btn" style="padding: 10px 20px; border: none; border-radius: 8px; background: var(--treeplex-primary); color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Replace Current Tree
                        </button>
                        <button id="execute-import-append-btn" style="padding: 10px 20px; border: 1px solid var(--treeplex-primary); border-radius: 8px; background: transparent; color: var(--treeplex-primary); cursor: pointer; font-size: 14px; font-weight: 600;">
                            Append to Tree
                        </button>
                    </div>
                </div>
            `;

            previewHTML += '</div>';

            // Show modal
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ‘€ Preview Import';
            modalBody.innerHTML = previewHTML;
            modal.style.display = 'flex';

            // Store preview data
            excelImportState.previewData = { phaseMap, importedItems };

            // Button handlers
            document.getElementById('back-to-mapping-btn').addEventListener('click', () => {
                showColumnMappingUI();
            });

            document.getElementById('execute-import-replace-btn').addEventListener('click', () => {
                executeFlexibleImport('replace');
            });

            document.getElementById('execute-import-append-btn').addEventListener('click', () => {
                executeFlexibleImport('append');
            });
        }

        function executeFlexibleImport(mode) {
            console.log('ðŸš€ Executing import in', mode, 'mode...');

            const { phaseMap, importedItems } = excelImportState.previewData;
            const patternDef = PATTERNS[currentPattern];

            saveState(`Excel Import: ${mode === 'replace' ? 'Replace' : 'Append'}`);

            if (mode === 'replace') {
                // Create new tree from scratch
                const phases = Object.keys(phaseMap).map((phaseName, phaseIndex) => {
                    return {
                        id: `phase-${phaseIndex}`,
                        type: 'phase',
                        phase: phaseIndex,
                        name: phaseName,
                        subtitle: '',
                        icon: `${phaseIndex + 1}ï¸âƒ£`,
                        expanded: false,
                        items: phaseMap[phaseName].map((item, itemIndex) => ({
                            ...item,
                            id: `item-${phaseIndex}-${itemIndex}`
                        }))
                    };
                });

                capexTree = {
                    id: 'root',
                    type: 'root',
                    name: `Imported from ${excelImportState.file}`,
                    icon: 'ðŸŒ³',
                    expanded: true,
                    hyperedges: [], // Initialize empty hyperedges array to prevent data loss
                    children: phases,
                    pattern: {
                        key: currentPattern,
                        labels: patternDef.levels
                    }
                };

            } else {
                // Append mode
                if (!capexTree.children) capexTree.children = [];

                Object.keys(phaseMap).forEach((phaseName) => {
                    // Try to find existing phase
                    let existingPhase = capexTree.children.find(p => p.name === phaseName);

                    if (existingPhase) {
                        // Append items to existing phase
                        const currentItemCount = existingPhase.items?.length || 0;
                        const phaseIndex = capexTree.children.indexOf(existingPhase);

                        const newItems = phaseMap[phaseName].map((item, idx) => ({
                            ...item,
                            id: `item-${phaseIndex}-${currentItemCount + idx}`
                        }));

                        existingPhase.items = [...(existingPhase.items || []), ...newItems];
                    } else {
                        // Create new phase
                        const phaseIndex = capexTree.children.length;
                        const newPhase = {
                            id: `phase-${phaseIndex}`,
                            type: 'phase',
                            phase: phaseIndex,
                            name: phaseName,
                            subtitle: '',
                            icon: `${phaseIndex + 1}ï¸âƒ£`,
                            expanded: false,
                            items: phaseMap[phaseName].map((item, itemIndex) => ({
                                ...item,
                                id: `item-${phaseIndex}-${itemIndex}`
                            }))
                        };

                        capexTree.children.push(newPhase);
                    }
                });
            }

            // Update UI
            render();
            document.getElementById('modal').style.display = 'none';

            showToast(`âœ… Excel imported! ${importedItems.length} items ${mode === 'replace' ? 'loaded' : 'added'}`);
            console.log('âœ… Flexible import complete');
        }

        // Excel Import button handler
        document.getElementById('excel-import-btn').addEventListener('click', () => {
            document.getElementById('excel-upload-input').click();
        });

        // Google Drive Refresh button handler
        document.getElementById('refresh-drive-btn').addEventListener('click', async () => {
            const btn = document.getElementById('refresh-drive-btn');
            const originalText = btn.textContent;

            try {
                // Check if current tree has source metadata
                const hasSourceMetadata = capexTree?.source?.type === 'google-drive';

                if (!hasSourceMetadata) {
                    // No source metadata - inform user
                    const proceed = confirm(
                        'âš ï¸ No Google Drive source detected!\n\n' +
                        'This will scan your entire Google Drive.\n\n' +
                        'Tip: Load a Google Drive JSON first, then click Refresh to update only that tree.\n\n' +
                        'Continue with full scan?'
                    );
                    if (!proceed) return;
                }

                // Show loading state
                btn.textContent = 'â³ Refreshing...';
                btn.disabled = true;
                btn.style.opacity = '0.6';

                console.log('â˜ï¸ Refreshing from Google Drive...');
                if (hasSourceMetadata) {
                    console.log('ðŸ“‹ Using source metadata from loaded tree:', capexTree.source);
                }

                // Prepare request body with source metadata (if available)
                const requestBody = hasSourceMetadata ? {
                    source: capexTree.source
                } : {};

                // Call local server to trigger export and get data
                const response = await fetch('http://localhost:5000/refresh-google-drive', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Server request failed');
                }

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'Unknown error');
                }

                console.log('âœ… Received data from server:', result.filename);

                // Auto-import the data
                const treeData = result.data;

                // Detect pattern
                const detectedPattern = treeData.pattern?.key || 'filesystem';
                console.log(`ðŸ“‹ Pattern detected: ${detectedPattern}`);

                // Load directly without preview modal
                if (PATTERNS[detectedPattern]) {
                    currentPattern = detectedPattern;
                    capexTree = treeData;

                    // Update pattern dropdown
                    const patternSelect = document.getElementById('pattern-select');
                    if (patternSelect) {
                        patternSelect.value = detectedPattern;
                    }

                    // Re-render the tree
                    render();

                    // Update sort dropdown options for the loaded pattern
                    updateSortDropdown();

                    // Apply default sort for filesystem pattern (folders first + alphabetical)
                    if (detectedPattern === 'filesystem') {
                        sortTree(null); // This will trigger the default filesystem sort
                    }

                    // Build success message with source info
                    let successMessage = `âœ… Google Drive refreshed successfully!\n\n`;
                    successMessage += `File: ${result.filename}\n`;
                    successMessage += `Size: ${(result.fileSize / 1024).toFixed(1)} KB\n`;
                    successMessage += `Pattern: ${PATTERNS[detectedPattern].name}\n`;

                    if (treeData.source) {
                        successMessage += `\nðŸ“‹ Source Info:\n`;
                        successMessage += `Type: ${treeData.source.type}\n`;
                        successMessage += `Folder: ${treeData.source.folderName}\n`;
                        successMessage += `Depth: ${treeData.source.syncDepth} levels\n`;

                        if (treeData.source.lastSync) {
                            const syncDate = new Date(treeData.source.lastSync);
                            successMessage += `Last Synced: ${syncDate.toLocaleString()}`;
                        }
                    }

                    alert(successMessage);

                    console.log('âœ… Google Drive data loaded successfully');
                } else {
                    throw new Error(`Unknown pattern: ${detectedPattern}`);
                }

            } catch (error) {
                console.error('âŒ Refresh failed:', error);

                // Check if server is running
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    alert('âŒ Cannot connect to local server!\n\nPlease start the server first:\n\n1. Open a terminal\n2. Run: python treelisty_server.py\n3. Keep it running\n4. Try again');
                } else {
                    alert(`âŒ Refresh failed:\n\n${error.message}`);
                }
            } finally {
                // Restore button state
                btn.textContent = originalText;
                btn.disabled = false;
                btn.style.opacity = '1';
            }
        });

        // Excel file upload handler
        document.getElementById('excel-upload-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                console.log('ðŸ“¥ Excel file selected:', file.name);
                importFromExcel(file);
            }
            // Reset input
            e.target.value = '';
        });

        // Redraw lines on scroll or resize
        const treeContainer = document.getElementById('tree-container');
        treeContainer.addEventListener('scroll', drawDependencyLines);
        window.addEventListener('resize', drawDependencyLines);

        // Load from shared URL if present
        (function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);

            // Check for collaboration branch URL first
            if (urlParams.has('branch')) {
                console.log('ðŸ¤ Branch URL detected...');
                // Defer to allow page to fully load
                setTimeout(() => {
                    handleBranchURL();
                }, 100);
                return; // Don't process other URL params
            }

            const compressedData = urlParams.get('p');

            if (compressedData) {
                try {
                    console.log('Loading shared project from URL...');
                    const decompressed = LZString.decompressFromEncodedURIComponent(compressedData);

                    // DEBUG: Log first 500 chars of decompressed JSON
                    console.log('Decompressed JSON (first 500 chars):', decompressed.substring(0, 500));

                    const loadedTree = JSON.parse(decompressed);

                    // DEBUG: Check cost values in loaded tree
                    if (loadedTree.children && loadedTree.children[0] && loadedTree.children[0].items && loadedTree.children[0].items[0]) {
                        console.log('First item cost in loaded JSON:', loadedTree.children[0].items[0].cost);
                    }

                    // Replace capexTree with loaded data
                    capexTree = loadedTree;

                    // Update currentPattern if it's in the loaded data
                    if (capexTree.pattern) {
                        const patternKey = getPatternKey(capexTree.pattern);
                        if (patternKey) {
                            currentPattern = patternKey;
                        }
                    }

                    console.log('âœ… Shared project loaded successfully!');
                    console.log('Project:', capexTree.name || capexTree.title);
                    console.log('Pattern:', currentPattern);

                    // Simple success toast (no modal)
                    setTimeout(() => {
                        const toast = document.createElement('div');
                        toast.textContent = 'âœ… Project loaded!';
                        toast.style.cssText = `
                            position: fixed;
                            top: 80px;
                            right: 20px;
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            padding: 15px 25px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-weight: 600;
                        `;
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 2000);
                    }, 500);

                } catch (error) {
                    console.error('âŒ Failed to load shared project:', error);
                    alert('Failed to load shared project. The URL may be corrupted or invalid.');
                }
            }
        })();

        // =============================================================================
        // PWA & FILE HANDLING SYSTEM
        // =============================================================================

        // PWA install prompt event
        let deferredInstallPrompt = null;

        // Register service worker (only on http:// or https://, not file://)
        if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
            navigator.serviceWorker.register('./service-worker.js')
                .then(registration => {
                    console.log('âœ… Service Worker registered:', registration.scope);
                })
                .catch(error => {
                    console.error('âŒ Service Worker registration failed:', error);
                    console.error('Error details:', error.message, error.stack);
                });
        } else if (window.location.protocol === 'file:') {
            console.log('â„¹ï¸ Service Worker skipped (file:// protocol - not supported)');
        }

        if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {

            // Listen for file launches from service worker
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data.type === 'FILE_OPENED' && event.data.files) {
                    console.log('ðŸ“‚ File opened via file association:', event.data.files);
                    event.data.files.forEach(file => {
                        try {
                            const treeData = JSON.parse(file.content);
                            capexTree = treeData;
                            if (treeData.pattern) {
                                const patternKey = getPatternKey(treeData.pattern);
                                if (patternKey) {
                                    currentPattern = patternKey;
                                }
                            }
                            render();
                            console.log(`âœ… Loaded ${file.name}`);
                        } catch (error) {
                            console.error(`âŒ Failed to load ${file.name}:`, error);
                            alert(`Failed to load ${file.name}: Invalid JSON format`);
                        }
                    });
                }
            });
        }

        // Capture PWA install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('ðŸ’¾ PWA install prompt available - Button will trigger automatic install');
            e.preventDefault();
            deferredInstallPrompt = e;
        });

        // Debug: Check PWA install readiness
        console.log('ðŸ” PWA Debug Info:');
        console.log('- Service Worker supported:', 'serviceWorker' in navigator);
        console.log('- beforeinstallprompt listener added');
        console.log('- Manifest URL:', document.querySelector('link[rel="manifest"]')?.href);
        console.log('- Current URL:', window.location.href);
        console.log('- HTTPS:', window.location.protocol === 'https:');

        // Show PWA onboarding modal
        function showPWAOnboardingModal() {
            const modal = document.getElementById('pwa-onboarding-modal');
            modal.style.display = 'flex';
            // Button is always visible now - no need to check for prompt
        }

        // Install PWA button - Universal handler
        document.getElementById('pwa-install-btn').addEventListener('click', async () => {
            const instructionsDiv = document.getElementById('pwa-manual-instructions');

            if (deferredInstallPrompt) {
                // Automatic install available - trigger it
                try {
                    deferredInstallPrompt.prompt();

                    const { outcome } = await deferredInstallPrompt.userChoice;
                    console.log(`PWA install outcome: ${outcome}`);

                    if (outcome === 'accepted') {
                        console.log('âœ… User accepted PWA installation');

                        // Mark onboarding as completed
                        localStorage.setItem('treelisty-onboarding-seen', 'true');

                        // Close modal
                        document.getElementById('pwa-onboarding-modal').style.display = 'none';

                        // Show success message
                        const toast = document.createElement('div');
                        toast.textContent = 'âœ… TreeListy installed! You can now open .treelisty files by double-clicking them.';
                        toast.style.cssText = `
                            position: fixed;
                            top: 80px;
                            right: 20px;
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            padding: 15px 25px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-weight: 600;
                            max-width: 400px;
                        `;
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 5000);
                    } else {
                        console.log('âŒ User declined PWA installation');
                    }

                    deferredInstallPrompt = null;
                } catch (error) {
                    console.error('Install prompt error:', error);
                    // Fallback to manual instructions if prompt fails
                    instructionsDiv.style.display = 'block';
                }
            } else {
                // No automatic install - show manual instructions
                console.log('ðŸ“ Showing manual install instructions');
                instructionsDiv.style.display = 'block';

                // Change button text to indicate instructions are shown
                const btn = document.getElementById('pwa-install-btn');
                btn.textContent = 'âœ… See Instructions Below';
                btn.style.background = 'var(--card-bg)';
                btn.style.color = 'var(--text-secondary)';
                btn.disabled = true;
            }
        });

        // Skip onboarding button
        document.getElementById('pwa-skip-btn').addEventListener('click', () => {
            localStorage.setItem('treelisty-onboarding-seen', 'true');
            document.getElementById('pwa-onboarding-modal').style.display = 'none';
        });

        // Handle launchQueue for file opens (File Handling API)
        if ('launchQueue' in window) {
            window.launchQueue.setConsumer(async (launchParams) => {
                console.log('ðŸ“‚ File launch detected via File Handling API');

                if (launchParams.files && launchParams.files.length > 0) {
                    for (const fileHandle of launchParams.files) {
                        try {
                            const file = await fileHandle.getFile();
                            const content = await file.text();
                            const treeData = JSON.parse(content);

                            // Load the tree
                            capexTree = treeData;
                            if (treeData.pattern) {
                                const patternKey = getPatternKey(treeData.pattern);
                                if (patternKey) {
                                    currentPattern = patternKey;
                                }
                            }
                            render();

                            console.log(`âœ… Loaded ${file.name} via file association`);

                            // Show success toast
                            const toast = document.createElement('div');
                            toast.textContent = `âœ… Opened ${file.name}`;
                            toast.style.cssText = `
                                position: fixed;
                                top: 80px;
                                right: 20px;
                                background: linear-gradient(135deg, #10b981, #059669);
                                color: white;
                                padding: 15px 25px;
                                border-radius: 8px;
                                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                                z-index: 10000;
                                font-weight: 600;
                            `;
                            document.body.appendChild(toast);
                            setTimeout(() => toast.remove(), 3000);
                        } catch (error) {
                            console.error('âŒ Failed to load file:', error);
                            alert(`Failed to load file: ${error.message}`);
                        }
                    }
                }
            });
        } else {
            console.log('â„¹ï¸ File Handling API not supported in this browser');
        }

        // Initial render
        render();

        // Update AI button label for initial pattern
        updateAIButtonLabel();

        // Initialize pattern selector
        const patternSelect = document.getElementById('pattern-select');
        console.log('Pattern selector found:', patternSelect);
        if (patternSelect) {
            // Load saved pattern from data
            if (capexTree.pattern && getPatternKey(capexTree.pattern)) {
                currentPattern = getPatternKey(capexTree.pattern);
                patternSelect.value = currentPattern;
                console.log('Loaded saved pattern:', currentPattern);
                if (currentPattern === 'custom' && capexTree.pattern.labels) {
                    customPatternNames = capexTree.pattern.labels;
                }
                // Apply pattern labels to existing nodes on load
                const labels = currentPattern === 'custom' && customPatternNames ? customPatternNames : PATTERNS[currentPattern].levels;
                renameNodesForPattern(capexTree, labels);
                console.log('Initial nodes renamed to match saved pattern');
                render(); // Re-render with renamed nodes

                // Update sort dropdown for the loaded pattern
                updateSortDropdown();

                // Update AI button label for the loaded pattern
                updateAIButtonLabel();
            }
            // Handle pattern selection
            patternSelect.addEventListener('change', function() {
                console.log('Pattern selector changed to:', this.value);
                applyPattern(this.value);
            });
            console.log('Pattern selector event listener attached');
        } else {
            console.error('Pattern selector NOT found!');
        }

        // Initialize Theme Switcher
        const themeSelect = document.getElementById('theme-select');
        if (themeSelect) {
            // Load saved theme from localStorage
            const savedTheme = localStorage.getItem('treelisty-theme') || 'default';
            document.documentElement.setAttribute('data-theme', savedTheme);
            themeSelect.value = savedTheme;
            console.log('Theme loaded:', savedTheme);

            // Handle theme selection
            themeSelect.addEventListener('change', function() {
                const selectedTheme = this.value;
                console.log('Theme changed to:', selectedTheme);

                // Apply theme
                document.documentElement.setAttribute('data-theme', selectedTheme);

                // Save to localStorage
                localStorage.setItem('treelisty-theme', selectedTheme);

                // Show toast notification
                const themeNames = {
                    'default': 'ðŸŒ™ Default',
                    'steampunk': 'âš™ï¸ Steampunk',
                    'powerpuff': 'ðŸ’— Powerpuff',
                    'tron': 'ðŸ’  Tron'
                };
                const toast = document.createElement('div');
                toast.textContent = `Theme: ${themeNames[selectedTheme]}`;
                toast.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    right: 20px;
                    padding: 12px 24px;
                    background: var(--card-bg);
                    border: 2px solid var(--border);
                    border-radius: 12px;
                    color: var(--text-primary);
                    font-weight: 600;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: var(--shadow-lg);
                `;
                document.body.appendChild(toast);

                setTimeout(() => toast.remove(), 2000);
            });

            console.log('Theme switcher initialized');
        }

        // ============================================
        // SORTING SYSTEM
        // ============================================

        // Parse lead time string to days for comparison
        function parseLeadTimeToDays(leadTimeStr) {
            if (!leadTimeStr || leadTimeStr === 'N/A' || leadTimeStr === '') return 999999;

            const str = leadTimeStr.toLowerCase();
            let days = 0;

            // Match patterns like "12-18 months", "3-6 weeks", "2 days", etc.
            const monthsMatch = str.match(/(\d+)(?:-(\d+))?\s*months?/);
            const weeksMatch = str.match(/(\d+)(?:-(\d+))?\s*weeks?/);
            const daysMatch = str.match(/(\d+)(?:-(\d+))?\s*days?/);

            if (monthsMatch) {
                // Take average if range, otherwise use single value
                const avg = monthsMatch[2] ? (parseInt(monthsMatch[1]) + parseInt(monthsMatch[2])) / 2 : parseInt(monthsMatch[1]);
                days = avg * 30; // Approximate months to days
            } else if (weeksMatch) {
                const avg = weeksMatch[2] ? (parseInt(weeksMatch[1]) + parseInt(weeksMatch[2])) / 2 : parseInt(weeksMatch[1]);
                days = avg * 7;
            } else if (daysMatch) {
                const avg = daysMatch[2] ? (parseInt(daysMatch[1]) + parseInt(daysMatch[2])) / 2 : parseInt(daysMatch[1]);
                days = avg;
            }

            return days || 999999; // Return large number if unparseable
        }

        // Compare two values based on type
        function compareValues(a, b, type, order) {
            let valA, valB;

            switch(type) {
                case 'number':
                    valA = parseFloat(a) || 0;
                    valB = parseFloat(b) || 0;
                    break;

                case 'leadtime':
                    valA = parseLeadTimeToDays(a);
                    valB = parseLeadTimeToDays(b);
                    break;

                case 'date':
                    valA = a ? new Date(a).getTime() : 0;
                    valB = b ? new Date(b).getTime() : 0;
                    break;

                case 'text':
                default:
                    valA = (a || '').toString().toLowerCase();
                    valB = (b || '').toString().toLowerCase();
                    if (order === 'asc') return valA.localeCompare(valB);
                    return valB.localeCompare(valA);
            }

            if (order === 'asc') return valA - valB;
            return valB - valA;
        }

        // Recursively sort items array and all nested levels
        function sortItemsArray(items, sortConfig) {
            if (!items || !Array.isArray(items) || items.length === 0) return items;
            if (!sortConfig) return items;

            const { field, order, type } = sortConfig;

            // Special handling for "folders first" sorting in filesystem pattern
            if (currentPattern === 'filesystem' && field === 'isFolder') {
                items.sort((a, b) => {
                    // Folders always come before files when sorting by type
                    const aIsFolder = a.isFolder || false;
                    const bIsFolder = b.isFolder || false;

                    if (aIsFolder && !bIsFolder) return order === 'desc' ? -1 : 1;
                    if (!aIsFolder && bIsFolder) return order === 'desc' ? 1 : -1;

                    // If both are folders or both are files, sort by name as secondary
                    return (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase());
                });
            } else {
                // Standard sorting for all other fields
                items.sort((a, b) => {
                    return compareValues(a[field], b[field], type, order);
                });
            }

            // Recursively sort nested arrays (items, subItems, and children for all patterns)
            items.forEach(item => {
                // Sort standard items array (4-level patterns)
                if (item.items && Array.isArray(item.items) && item.items.length > 0) {
                    sortItemsArray(item.items, sortConfig);
                }

                // Sort subItems array (flexible depth patterns like filesystem)
                if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                    sortItemsArray(item.subItems, sortConfig);
                }

                // Sort children array (filesystem pattern uses this for nested folders)
                if (item.children && Array.isArray(item.children) && item.children.length > 0) {
                    sortItemsArray(item.children, sortConfig);
                }
            });

            return items;
        }

        // Sort the entire tree - applies to all nodes at all depths
        function sortTree(sortConfig) {
            if (!sortConfig) {
                // For filesystem pattern, apply default "folders first + alphabetical" sort
                if (currentPattern === 'filesystem') {
                    sortConfig = {
                        value: 'default-filesystem',
                        field: 'isFolder',
                        order: 'desc',
                        type: 'boolean'
                    };
                    currentSortConfig = sortConfig;
                } else {
                    // Reset to original order for other patterns
                    currentSortConfig = null;
                    render();
                    return;
                }
            } else {
                currentSortConfig = sortConfig;
            }

            // Sort phases (drives for filesystem pattern)
            if (capexTree.phases && capexTree.phases.length > 0) {
                sortItemsArray(capexTree.phases, sortConfig);

                // Sort all items within each phase recursively
                capexTree.phases.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        sortItemsArray(phase.items, sortConfig);
                    }
                });
            }

            // Sort children array (for root level if exists)
            if (capexTree.children && capexTree.children.length > 0) {
                sortItemsArray(capexTree.children, sortConfig);
            }

            // Re-render to show sorted tree with new visual order
            if (viewMode === 'canvas') {
                // Clear canvas coordinates to force re-positioning in new sorted order
                capexTree.children.forEach(phase => {
                    const nodeList = phase.items || phase.children || [];
                    nodeList.forEach(node => clearCanvasCoordinates(node));
                });

                // Migrate coordinates based on new sorted order
                migrateToCanvasCoordinates();

                renderCanvas();
                console.log('Canvas sorted by:', sortConfig, '- Canvas layout updated and repositioned');
            } else {
                render();
                console.log('Tree sorted by:', sortConfig, '- Visual layout updated');
            }
        }

        // Initialize Sort System
        const sortSelect = document.getElementById('pattern-sort-select');
        const resetSortBtn = document.getElementById('reset-sort-btn');

        if (sortSelect) {
            // Handle sort selection
            sortSelect.addEventListener('change', function() {
                const selectedOption = this.options[this.selectedIndex];

                if (!this.value || this.value === '') {
                    // Reset to default order
                    currentSortConfig = null;
                    sortTree(null);
                    if (resetSortBtn) resetSortBtn.style.display = 'none';
                    console.log('Sort reset to default order');
                } else {
                    // Apply sort
                    const sortConfig = {
                        value: this.value,
                        field: selectedOption.dataset.field,
                        order: selectedOption.dataset.order,
                        type: selectedOption.dataset.type
                    };

                    sortTree(sortConfig);
                    if (resetSortBtn) resetSortBtn.style.display = 'inline-block';

                    // Show toast notification
                    const toast = document.createElement('div');
                    toast.textContent = `Sorted: ${selectedOption.textContent}`;
                    toast.style.cssText = `
                        position: fixed;
                        bottom: 80px;
                        right: 20px;
                        padding: 12px 24px;
                        background: var(--card-bg);
                        border: 2px solid var(--border);
                        border-radius: 12px;
                        color: var(--text-primary);
                        font-weight: 600;
                        font-size: 14px;
                        z-index: 10000;
                        box-shadow: var(--shadow-lg);
                    `;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 2000);
                }
            });

            console.log('Sort dropdown event listener attached');
        }

        if (resetSortBtn) {
            resetSortBtn.addEventListener('click', function() {
                currentSortConfig = null;
                sortTree(null);
                sortSelect.value = '';
                this.style.display = 'none';

                // Show toast notification
                const toast = document.createElement('div');
                toast.textContent = 'Sort Reset';
                toast.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    right: 20px;
                    padding: 12px 24px;
                    background: var(--card-bg);
                    border: 2px solid var(--border);
                    border-radius: 12px;
                    color: var(--text-primary);
                    font-weight: 600;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: var(--shadow-lg);
                `;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2000);
            });
        }

        // Update sort dropdown on initial load
        updateSortDropdown();

        console.log('Sorting system initialized');

        // ============================================
        // AI TOOLS FLOATING PANEL
        // ============================================

        const aiToolsPanel = document.getElementById('ai-tools-panel');
        const toggleAiToolsBtn = document.getElementById('toggle-ai-tools');
        const closeAiToolsBtn = document.getElementById('close-ai-tools');
        const aiModeSelectHeader = document.getElementById('unified-ai-mode-select');
        const aiModeSelectPanel = document.getElementById('unified-ai-mode-select-panel');

        // Toggle AI Tools Panel
        if (toggleAiToolsBtn && aiToolsPanel) {
            toggleAiToolsBtn.addEventListener('click', function() {
                const isVisible = aiToolsPanel.style.display === 'flex';
                aiToolsPanel.style.display = isVisible ? 'none' : 'flex';
                console.log('AI Tools panel toggled:', !isVisible);
            });
        }

        // Close AI Tools Panel
        if (closeAiToolsBtn && aiToolsPanel) {
            closeAiToolsBtn.addEventListener('click', function() {
                aiToolsPanel.style.display = 'none';
                console.log('AI Tools panel closed');
            });

            // Hover effect for close button
            closeAiToolsBtn.addEventListener('mouseenter', function() {
                this.style.background = 'rgba(255, 255, 255, 0.1)';
            });
            closeAiToolsBtn.addEventListener('mouseleave', function() {
                this.style.background = 'transparent';
            });
        }

        // Sync AI Model selectors (header <-> panel)
        if (aiModeSelectHeader && aiModeSelectPanel) {
            // Sync panel -> header
            aiModeSelectPanel.addEventListener('change', function() {
                aiModeSelectHeader.value = this.value;
                console.log('AI mode synced from panel to header:', this.value);
            });

            // Sync header -> panel
            aiModeSelectHeader.addEventListener('change', function() {
                aiModeSelectPanel.value = this.value;
                console.log('AI mode synced from header to panel:', this.value);
            });

            // Initial sync
            aiModeSelectPanel.value = aiModeSelectHeader.value;
        }

        console.log('AI Tools panel initialized');

        // Initialize pan/zoom controls
        initPanZoom();

        // Splash screen auto-dismiss
        setTimeout(() => {
            const splashScreen = document.getElementById('splash-screen');
            if (splashScreen) {
                splashScreen.classList.add('fade-out');
                // Remove from DOM after fade-out animation completes
                setTimeout(() => {
                    splashScreen.remove();
                }, 500); // Match fade-out animation duration
            }
        }, 2000); // Show splash for 2 seconds (matches loader animation)
    </script>

    <!-- Canvas View Container -->
    <div class="canvas-container" id="canvas-container">
        <!-- Canvas Toolbar -->
        <div class="canvas-toolbar" id="canvas-toolbar" style="position: fixed; top: 120px; left: 50%; transform: translateX(-50%); z-index: 200; display: none; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(20, 20, 30, 0.98); backdrop-filter: blur(10px); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.4);">
            <select id="auto-layout-select" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.15); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 8px; color: #ffffff; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                <option value="" style="background: #1a1a2e; color: #ffffff;">ðŸ“ Auto-Layout</option>
                <option value="hierarchical" style="background: #1a1a2e; color: #ffffff;">ðŸŒ³ Hierarchical</option>
                <option value="timeline" style="background: #1a1a2e; color: #ffffff;">ðŸ“… Timeline</option>
                <option value="force" style="background: #1a1a2e; color: #ffffff;">ðŸŒ€ Force-Directed</option>
                <option value="radial" style="background: #1a1a2e; color: #ffffff;">â­• Radial</option>
                <option value="grid" style="background: #1a1a2e; color: #ffffff;">âŠž Grid</option>
            </select>
            <select id="cluster-by-select" style="padding: 8px 14px; background: rgba(34, 197, 94, 0.15); border: 1px solid rgba(34, 197, 94, 0.4); border-radius: 8px; color: #ffffff; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                <!-- Options populated dynamically by updateClusterByOptions() -->
            </select>
            <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
            <button id="grid-toggle" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                â—« Grid
            </button>
            <button id="reset-view" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                ðŸŽ¯ Reset
            </button>
            <button id="fit-view" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                âŠ¡ Fit
            </button>
            <button id="hyperedge-panel-btn" onclick="toggleHyperedgePanel()" class="btn" style="padding: 8px 14px; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 8px; color: #A78BFA; font-size: 13px; transition: all 0.2s;" title="Manage hyperedge visibility">
                ðŸ”— Edges
            </button>
            <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
            <div style="display: flex; align-items: center; gap: 6px;">
                <button id="zoom-out" class="btn" style="padding: 6px 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: var(--text-primary); font-weight: 600; transition: all 0.2s;">âˆ’</button>
                <span id="zoom-level" style="font-size: 12px; font-weight: 600; color: var(--treeplex-primary); min-width: 50px; text-align: center;">100%</span>
                <button id="zoom-in" class="btn" style="padding: 6px 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: var(--text-primary); font-weight: 600; transition: all 0.2s;">+</button>
            </div>
        </div>

        <!-- Selection Counter -->
        <div id="selection-counter" style="display: none; position: fixed; top: 200px; left: 50%; transform: translateX(-50%); background: rgba(99, 102, 241, 0.95); color: white; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: 600; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px);">
            <span id="selection-count">0</span> nodes selected
        </div>

        <div id="canvas">
            <!-- Grid Pattern -->
            <svg class="canvas-grid" id="canvas-grid" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; opacity: 0;">
                <defs>
                    <pattern id="grid-pattern" width="40" height="40" patternUnits="userSpaceOnUse">
                        <path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(99, 102, 241, 0.15)" stroke-width="1"/>
                    </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid-pattern)" />
            </svg>
            <svg class="canvas-connections" id="canvas-connections"></svg>
        </div>
    </div>

</body>
</html>
<!-- Cache buster: 1732240151 -->
