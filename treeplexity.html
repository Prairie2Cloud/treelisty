<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TreeListy - Universal Project Decomposition by geej</title>
    <!--
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    TreeListy v2.3.0 | Build 133 | 2025-11-20
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    Universal Project Decomposition Tool
    - 15 specialized patterns (Generic, Philosophy, Sales, Gmail, etc.)
    - AI-powered (Claude, Gemini, ChatGPT)
    - Smart JSON save with pattern-based filenames
    - LocalStorage auto-save every 2 minutes
    - 50-state undo system
    - PWA-ready (installable on desktop & mobile)

    Changelog (Build 133):
    - FIX: Quadtree infinite recursion crash in Canvas View (maximum call stack exceeded)
    - ADD: Max depth limit (15 levels) to prevent infinite subdivision
    - ADD: Minimum size check (1px) - stops subdivision when quadrants too small
    - SAFETY: Force return true if no child accepts node (handles floating point edge cases)
    - TECHNICAL: Pass depth parameter through Quadtree constructor chain

    Previous (Build 132):
    - FIX: Deep Mode routing clarification with debug logging
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    -->

    <!-- PWA Configuration -->
    <link rel="manifest" href="./manifest.json" id="pwa-manifest">
    <script>
        // Remove manifest link on file:// protocol to prevent CORS errors
        if (window.location.protocol === 'file:') {
            document.getElementById('pwa-manifest')?.remove();
        }
    </script>
    <meta name="theme-color" content="#6366f1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TreeListy">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%236366f1'/><text x='50' y='70' font-size='70' text-anchor='middle' fill='white'>üå≥</text></svg>">
    <meta name="description" content="Visual project management and hierarchical data organization tool with AI-powered insights">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            /* Default Theme */
            --treeplex-primary: #6366f1;
            --treeplex-primary-dark: #4f46e5;
            --phase-0: #5FA463;
            --phase-0-light: #6FB56E;
            --phase-0-dark: #4A8C4E;
            --phase-1: #3B8FCC;
            --phase-1-light: #4A9DD9;
            --phase-1-dark: #2B7AB8;
            --phase-2: #D68A2E;
            --phase-2-light: #E09940;
            --phase-2-dark: #B8741F;
            --text-primary: #E8EAF0;
            --text-secondary: #9DA3B4;
            --border: #3A3F4D;
            --bg: #1E2128;
            --card-bg: #2A2F3C;
            --card-bg-light: #32374A;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.5);
            --shadow-xl: 0 12px 40px rgba(0,0,0,0.6);
        }

        /* THEME: STEAMPUNK */
        [data-theme="steampunk"] {
            --treeplex-primary: #b8860b;
            --treeplex-primary-dark: #8b6914;
            --phase-0: #cd7f32;
            --phase-0-light: #d4924e;
            --phase-0-dark: #8b5a2b;
            --phase-1: #b87333;
            --phase-1-light: #d4924e;
            --phase-1-dark: #8b4513;
            --phase-2: #daa520;
            --phase-2-light: #ffd700;
            --phase-2-dark: #b8860b;
            --text-primary: #f5deb3;
            --text-secondary: #d2b48c;
            --border: #8b4513;
            --bg: #2b1810;
            --card-bg: #3e2315;
            --card-bg-light: #4a2817;
        }

        /* THEME: POWERPUFF GIRLS */
        [data-theme="powerpuff"] {
            --treeplex-primary: #ff6eb4;
            --treeplex-primary-dark: #ff1493;
            --phase-0: #ff69b4;
            --phase-0-light: #ffb6d9;
            --phase-0-dark: #c71585;
            --phase-1: #87ceeb;
            --phase-1-light: #b0e0e6;
            --phase-1-dark: #4682b4;
            --phase-2: #9acd32;
            --phase-2-light: #c7ea46;
            --phase-2-dark: #6b8e23;
            --text-primary: #2d2d2d;
            --text-secondary: #666666;
            --border: #ffb6d9;
            --bg: #fff0f5;
            --card-bg: #ffffff;
            --card-bg-light: #fffafd;
        }

        /* THEME: TRON */
        [data-theme="tron"] {
            --treeplex-primary: #00ffff;
            --treeplex-primary-dark: #00d4d4;
            --phase-0: #00ffff;
            --phase-0-light: #66ffff;
            --phase-0-dark: #00cccc;
            --phase-1: #00d4ff;
            --phase-1-light: #66e0ff;
            --phase-1-dark: #0099cc;
            --phase-2: #ff6600;
            --phase-2-light: #ff9944;
            --phase-2-dark: #cc5200;
            --text-primary: #e0ffff;
            --text-secondary: #7dd3ff;
            --border: #00ffff;
            --bg: #000000;
            --card-bg: #0a0a0a;
            --card-bg-light: #141414;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            overflow: auto;
        }

        ::selection {
            background: var(--treeplex-primary);
            color: white;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            background: #252931;
            border-bottom: 1px solid var(--border);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .logo {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-right: 40px;
        }

        .logo-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 24px;
            font-weight: 700;
            color: var(--treeplex-primary);
            letter-spacing: -0.5px;
        }

        .logo-subtitle {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-left: 46px;
        }

        /*         .confidential {
        /*             padding: 4px 12px;
        /*             background: #fff5f5;
        /*             border: 1px solid #ffccc7;
        /*             border-radius: 6px;
        /*             font-size: 11px;
        /*             font-weight: 600;
        /*             color: #d32f2f;
        /*             letter-spacing: 0.5px;
        /*         } */

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .control-section {
            display: flex;
            gap: 6px;
            padding: 0 12px;
            border-right: 1px solid var(--border);
        }

        .control-section:last-child {
            border-right: none;
            padding-right: 0;
        }

        .control-section:first-child {
            padding-left: 0;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: var(--card-bg);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn:hover {
            background: var(--card-bg-light);
            border-color: var(--treeplex-primary);
        }

        .btn-primary {
            background: var(--treeplex-primary);
            color: white;
            border-color: var(--treeplex-primary);
        }

        .btn-primary:hover {
            background: var(--treeplex-primary-dark);
        }
/* Pattern Selector */        .pattern-selector {            position: relative;            display: inline-block;        }        .pattern-select {            padding: 8px 12px;            border: 1px solid var(--border);            background: var(--card-bg);            color: var(--text-primary);            border-radius: 6px;            font-size: 13px;            font-weight: 500;            cursor: pointer;            font-family: inherit;            min-width: 180px;        }        .pattern-select:hover {            background-color: var(--card-bg-light);            border-color: var(--treeplex-primary);        }        .pattern-select:focus {            outline: none;            border-color: var(--treeplex-primary);            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);        }

        /* Pan/Zoom Controls */
        .zoom-controls {
            position: fixed;
            top: 90px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: var(--card-bg);
            padding: 12px;
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border);
        }

        .zoom-btn {
            width: 44px;
            height: 44px;
            border: 1px solid var(--border);
            background: var(--card-bg-light);
            color: var(--text-primary);
            border-radius: 8px;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: inherit;
        }

        .zoom-btn:hover {
            background: var(--treeplex-primary);
            border-color: var(--treeplex-primary);
            color: white;
            transform: scale(1.05);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-level {
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            padding: 8px 0;
            border-top: 1px solid var(--border);
            margin-top: 4px;
        }

        /* Tree Container */
        .tree-container {
            padding: 0;
            overflow: hidden;
            min-height: calc(100vh - 70px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background:
                repeating-linear-gradient(45deg, transparent, transparent 40px, rgba(0, 166, 125, 0.03) 40px, rgba(0, 166, 125, 0.03) 80px),
                repeating-linear-gradient(-45deg, transparent, transparent 40px, rgba(59, 143, 204, 0.02) 40px, rgba(59, 143, 204, 0.02) 80px),
                linear-gradient(180deg, #1A1D24 0%, #1E2128 50%, #1A1D24 100%);
            cursor: grab;
        }

        .tree-container.panning {
            cursor: grabbing;
        }

        .tree-transform-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center center;
            transition: transform 0.2s ease-out;
            min-width: 100%;
            min-height: 100%;
        }

        .tree-container::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 166, 125, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(59, 143, 204, 0.06) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(214, 138, 46, 0.04) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }

        .dependency-svg {
            position: absolute;
            top: -5000px;
            left: -5000px;
            width: 20000px;
            height: 20000px;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .dependency-line {
            fill: none;
            stroke: var(--treeplex-primary);
            stroke-width: 3;
            stroke-dasharray: 8, 4;
            opacity: 0.6;
            transition: all 0.3s;
            animation: dash-flow 20s linear infinite;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
        }

        .dependency-line:hover {
            opacity: 1;
            stroke-width: 4;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25));
        }

        .dependency-line.phase-0 {
            stroke: var(--phase-0-dark);
        }

        .dependency-line.phase-1 {
            stroke: var(--phase-1-dark);
        }

        .dependency-line.phase-2 {
            stroke: var(--phase-2-dark);
        }

        .dependency-line.cross-phase {
            stroke: var(--treeplex-primary-dark);
            opacity: 0.7;
            stroke-width: 3.5;
        }

        @keyframes dash-flow {
            to {
                stroke-dashoffset: -100;
            }
        }

        .tree {
            display: flex;
            flex-direction: row;
            gap: 40px;
            align-items: center;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }

        .tree-level {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 12px;
            padding: 20px;
            border-radius: 12px;
            transition: background 0.3s;
        }

        /* Phase-specific backgrounds - subtle gradients */
        .tree-level:has(.phase-0) {
            background: linear-gradient(180deg, rgba(95, 164, 99, 0.03) 0%, rgba(95, 164, 99, 0.08) 100%);
        }

        .tree-level:has(.phase-1) {
            background: linear-gradient(180deg, rgba(59, 143, 204, 0.03) 0%, rgba(59, 143, 204, 0.08) 100%);
        }

        .tree-level:has(.phase-2) {
            background: linear-gradient(180deg, rgba(214, 138, 46, 0.03) 0%, rgba(214, 138, 46, 0.08) 100%);
        }

        .tree-node {
            background: linear-gradient(145deg, var(--card-bg-light), var(--card-bg));
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: var(--shadow-md), 0 0 0 1px rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            min-width: 280px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .tree-node:hover {
            box-shadow: var(--shadow-lg), 0 0 0 1px rgba(255,255,255,0.1);
            transform: translateX(4px) translateY(-2px);
            border-color: var(--treeplex-primary);
            background: linear-gradient(145deg, #3A3F52, var(--card-bg-light));
        }

        .tree-node::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 16px;
            background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
            pointer-events: none;
        }

        .tree-node.root {
            background: linear-gradient(135deg, #4A5568 0%, #2D3748 100%);
            color: white;
            font-size: 20px;
            font-weight: 600;
            min-width: 240px;
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(255, 255, 255, 0.15);
        }

        .tree-node.root:hover {
            box-shadow: var(--shadow-xl);
            background: linear-gradient(135deg, #556577 0%, #3A4556 100%);
        }

        .tree-node.root .node-subtitle {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.85;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 2px;
        }

        /* FILESYSTEM PATTERN: Vertical Tree Layout */
        .tree.filesystem-tree {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 20px;
        }

        .tree.filesystem-tree .tree-level {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 0;
            background: none !important;
        }

        .tree.filesystem-tree .tree-node {
            min-width: auto;
            width: 100%;
            max-width: 800px;
            margin: 4px 0;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.15s;
            cursor: pointer;
        }

        .tree.filesystem-tree .tree-node:hover {
            transform: none;
            background: rgba(99, 102, 241, 0.15);
        }

        .tree.filesystem-tree .tree-node.item,
        .tree.filesystem-tree .tree-node.subtask {
            padding: 6px 10px;
            background: transparent;
            border: none;
            box-shadow: none;
        }

        .tree.filesystem-tree .tree-node.item:hover,
        .tree.filesystem-tree .tree-node.subtask:hover {
            background: rgba(255, 255, 255, 0.05);
            box-shadow: none;
        }

        .tree.filesystem-tree .filesystem-indent-0 { margin-left: 0px; }
        .tree.filesystem-tree .filesystem-indent-1 { margin-left: 40px; }
        .tree.filesystem-tree .filesystem-indent-2 { margin-left: 80px; }
        .tree.filesystem-tree .filesystem-indent-3 { margin-left: 120px; }
        .tree.filesystem-tree .filesystem-indent-4 { margin-left: 160px; }
        .tree.filesystem-tree .filesystem-indent-5 { margin-left: 200px; }
        .tree.filesystem-tree .filesystem-indent-6 { margin-left: 240px; }
        .tree.filesystem-tree .filesystem-indent-7 { margin-left: 280px; }
        .tree.filesystem-tree .filesystem-indent-8 { margin-left: 320px; }
        .tree.filesystem-tree .filesystem-indent-9 { margin-left: 360px; }
        .tree.filesystem-tree .filesystem-indent-10 { margin-left: 400px; }

        .tree.filesystem-tree .node-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tree.filesystem-tree .expand-toggle {
            font-size: 14px;
            margin-right: 6px;
            cursor: pointer;
            padding: 2px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 16px;
            user-select: none;
            transition: all 0.2s;
        }

        .tree.filesystem-tree .expand-toggle:hover {
            color: var(--accent-primary);
            transform: scale(1.2);
        }

        .tree.filesystem-tree .node-icon {
            font-size: 16px;
            margin-right: 4px;
        }

        .tree.filesystem-tree .node-title,
        .tree.filesystem-tree .item-name {
            font-size: 13px;
            font-weight: 500;
        }

        .tree.filesystem-tree .node-subtitle,
        .tree.filesystem-tree .item-description {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .tree-node.phase {
            border-left: 6px solid;
            min-width: 260px;
            position: relative;
            overflow: hidden;
        }

        .tree-node.phase::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: linear-gradient(180deg, var(--phase-color-light), var(--phase-color-dark));
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
        }

        .tree-node.phase-0 {
            border-left-color: var(--phase-0);
            --phase-color-light: var(--phase-0-light);
            --phase-color-dark: var(--phase-0-dark);
        }

        .tree-node.phase-0:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-0);
        }

        .tree-node.phase-1 {
            border-left-color: var(--phase-1);
            --phase-color-light: var(--phase-1-light);
            --phase-color-dark: var(--phase-1-dark);
        }

        .tree-node.phase-1:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-1);
        }

        .tree-node.phase-2 {
            border-left-color: var(--phase-2);
            --phase-color-light: var(--phase-2-light);
            --phase-color-dark: var(--phase-2-dark);
        }

        .tree-node.phase-2:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-2);
        }

        .tree-node.item {
            min-width: 320px;
            max-width: 360px;
            backdrop-filter: blur(4px);
        }

        /* Subtask container - appears below parent item with animation */
        .subtask-container {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            margin-bottom: 8px;
            padding-left: 10px;
            justify-content: flex-start;
            flex-wrap: wrap;
            max-width: 100%;
            animation: slideDownFade 0.4s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            transform-origin: top center;
        }

        @keyframes slideDownFade {
            0% {
                opacity: 0;
                transform: translateY(-40px) scale(0.95);
                max-height: 0;
                filter: blur(6px) brightness(0.5);
            }
            60% {
                filter: blur(1px) brightness(0.9);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                max-height: 500px;
                filter: blur(0) brightness(1);
            }
        }

        /* Subtask styling - compact visual cards */
        .tree-node.item.subtask {
            min-width: 100px;
            max-width: 100px;
            width: 100px;
            min-height: 85px;
            background: rgba(255, 255, 255, 0.06);
            border-left: 3px solid rgba(0, 166, 125, 0.5);
            border-radius: 6px;
            padding: 10px;
            font-size: 10px;
            margin: 0;
            display: inline-flex;
            flex-direction: column;
            vertical-align: top;
            animation: subtaskReveal 0.35s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            opacity: 0;
            transform: translateY(-20px) scale(0.9);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tree-node.item.subtask:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 166, 125, 0.3);
            border-left-color: rgba(0, 166, 125, 0.8);
        }

        /* Staggered animation for subtasks */
        .tree-node.item.subtask:nth-child(1) { animation-delay: 0.05s; }
        .tree-node.item.subtask:nth-child(2) { animation-delay: 0.1s; }
        .tree-node.item.subtask:nth-child(3) { animation-delay: 0.15s; }
        .tree-node.item.subtask:nth-child(4) { animation-delay: 0.2s; }
        .tree-node.item.subtask:nth-child(5) { animation-delay: 0.25s; }
        .tree-node.item.subtask:nth-child(6) { animation-delay: 0.3s; }

        @keyframes subtaskReveal {
            0% {
                opacity: 0;
                transform: translateY(-20px) scale(0.9);
                filter: blur(4px) brightness(0.6);
            }
            70% {
                transform: translateY(2px) scale(1.01);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                filter: blur(0) brightness(1);
            }
        }


        /* Project management fields styling */
        .pm-field {
            font-size: 8px;
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            line-height: 1.1;
        }

        .pm-field-label {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .pm-field-value {
            font-weight: 600;
        }

        .pm-status {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
        }

        .pm-status.todo { background: rgba(156, 163, 175, 0.3); color: #9CA3AF; }
        .pm-status.inprogress { background: rgba(59, 130, 246, 0.3); color: #3B82F6; }
        .pm-status.completed { background: rgba(16, 185, 129, 0.3); color: #10B981; }
        .pm-status.blocked { background: rgba(239, 68, 68, 0.3); color: #EF4444; }

        .pm-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 2px;
        }

        .pm-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            transition: width 0.3s;
        }

        /* Expand/Collapse toggle for items with subtasks */
        .expand-toggle {
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
            display: inline-block;
        }

        .expand-toggle:hover {
            opacity: 1 !important;
            transform: scale(1.3) rotate(90deg);
        }

        /* Items with subtasks have a pointer cursor */
        .tree-node.item:has(.expand-toggle) {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tree-node.item:has(.expand-toggle):hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 166, 125, 0.2);
        }

        .tree-node.item:has(.expand-toggle):active {
            transform: translateY(0);
            transition: all 0.1s ease;
        }

        /* When item has expanded subtasks, add subtle glow and lift effect */
        .tree-node.item.has-expanded-subtasks {
            box-shadow: 0 0 20px rgba(0, 166, 125, 0.4), 0 6px 16px rgba(0, 0, 0, 0.3);
            border-left-color: rgba(0, 166, 125, 0.9);
            border-left-width: 4px;
            transform: translateY(-2px);
            z-index: 10;
            transition: all 0.3s ease;
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .node-icon {
            font-size: 28px;
            flex-shrink: 0;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
            transition: transform 0.3s;
        }

        .tree-node:hover .node-icon {
            transform: scale(1.1);
        }

        .node-content {
            flex: 1;
        }

        .node-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .node-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .node-cost {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-top: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .tree-node.root .node-cost {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.8));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .expand-toggle {
            font-size: 14px;
            opacity: 0.6;
            transition: transform 0.3s;
            margin-left: auto;
        }

        .tree-node.expanded .expand-toggle {
            transform: rotate(90deg);
        }

        .tree-node.collapsed .expand-toggle {
            transform: rotate(0deg);
        }

        /* Item specific */
        .item-name {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .item-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            border: 1px solid;
        }

        .badge-land {
            background: linear-gradient(135deg, rgba(95, 164, 99, 0.3), rgba(74, 140, 78, 0.2));
            color: #81C784;
            border-color: #4A8C4E;
        }
        .badge-engineering {
            background: linear-gradient(135deg, rgba(59, 143, 204, 0.3), rgba(43, 122, 184, 0.2));
            color: #64B5F6;
            border-color: #2B7AB8;
        }
        .badge-professional {
            background: linear-gradient(135deg, rgba(156, 117, 178, 0.3), rgba(128, 90, 150, 0.2));
            color: #BA68C8;
            border-color: #7B4A92;
        }
        .badge-corporate {
            background: linear-gradient(135deg, rgba(130, 130, 130, 0.3), rgba(100, 100, 100, 0.2));
            color: #B0B0B0;
            border-color: #707070;
        }
        .badge-equipment {
            background: linear-gradient(135deg, rgba(214, 138, 46, 0.3), rgba(184, 116, 31, 0.2));
            color: #FFB74D;
            border-color: #B8741F;
        }
        .badge-infrastructure {
            background: linear-gradient(135deg, rgba(233, 98, 158, 0.3), rgba(200, 70, 130, 0.2));
            color: #F48FB1;
            border-color: #C84682;
        }
        .badge-contingency {
            background: linear-gradient(135deg, rgba(229, 115, 115, 0.3), rgba(198, 80, 80, 0.2));
            color: #EF9A9A;
            border-color: #C65050;
        }

        .item-cost {
            font-size: 15px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Connection Lines */
        .tree-node::before {
            content: '';
            position: absolute;
            left: -40px;
            top: 50%;
            width: 40px;
            height: 2px;
            background: var(--border);
        }

        .tree-level:first-child .tree-node::before {
            display: none;
        }

        /* Same-phase dependency indentation indicator */
        .tree-node.item.has-same-phase-dependency::after {
            content: '';
            position: absolute;
            left: -20px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, transparent, var(--treeplex-primary) 20%, var(--treeplex-primary) 80%, transparent);
            opacity: 0.3;
            border-radius: 2px;
        }

        /* Enhanced visual for deeper dependency levels */
        .tree-node.item.has-same-phase-dependency[data-dependency-level="2"]::after {
            opacity: 0.4;
            width: 3px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="3"]::after {
            opacity: 0.5;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="4"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="5"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="6"]::after {
            opacity: 0.6;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency {
            border-left: 2px solid rgba(0, 166, 125, 0.2);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            right: -450px;
            top: 0;
            width: 450px;
            height: 100vh;
            background: var(--card-bg);
            border-left: 1px solid var(--border);
            box-shadow: -4px 0 12px rgba(0,0,0,0.5);
            transition: right 0.3s;
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        .info-panel.open {
            right: 0;
        }

        .info-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-title {
            font-size: 18px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: var(--bg);
        }

        .info-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .info-section {
            margin-bottom: 24px;
        }

        .info-section h4 {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .info-section p {
            font-size: 14px;
            line-height: 1.6;
        }

        .info-section .value {
            font-size: 20px;
            font-weight: 700;
            color: var(--treeplex-primary);
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            font-size: 18px;
            font-weight: 600;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            line-height: 1.7;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
        }

        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--treeplex-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 40px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            display: none;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            padding: 6px;
            min-width: 180px;
            z-index: 1000;
        }

        .context-item {
            padding: 10px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            color: var(--text-primary);
        }

        .context-item:hover {
            background: var(--card-bg-light);
            color: var(--treeplex-primary);
        }

        .context-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
            background: var(--bg);
            color: var(--text-primary);
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--treeplex-primary);
            box-shadow: 0 0 0 3px rgba(0, 166, 125, 0.2);
            background: var(--card-bg-light);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Splash Screen */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1d24 0%, #2a2f3c 50%, #1a1d24 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.5s ease-in;
        }

        #splash-screen.fade-out {
            animation: fadeOut 0.5s ease-out forwards;
        }

        .splash-logo {
            font-size: 72px;
            margin-bottom: 24px;
            animation: logoFloat 2s ease-in-out infinite;
        }

        .splash-title {
            font-size: 48px;
            font-weight: 700;
            color: var(--treeplex-primary);
            margin-bottom: 8px;
            letter-spacing: -1px;
        }

        .splash-subtitle {
            font-size: 20px;
            color: var(--text-secondary);
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 48px;
        }

        .splash-tagline {
            font-size: 16px;
            color: var(--text-primary);
            font-weight: 400;
            margin-bottom: 32px;
            opacity: 0.8;
        }

        .splash-loader {
            width: 200px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .splash-loader-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--phase-1));
            border-radius: 3px;
            animation: loadProgress 2s ease-in-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        @keyframes logoFloat {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes loadProgress {
            0% {
                width: 0%;
            }
            100% {
                width: 100%;
            }
        }

    /* ===================================================== */
    /* CANVAS VIEW STYLES */
    /* ===================================================== */

    .tree-view-container {
        display: block;
    }

    .tree-view-container.hidden {
        display: none !important;
    }

    .canvas-container {
        display: none;
        position: fixed;
        top: 140px;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        overflow: hidden;
        cursor: grab;
    }

    .canvas-container.active {
        display: block;
    }

    .canvas-container.grabbing {
        cursor: grabbing;
    }

    #canvas {
        width: 100%;
        height: 100%;
        position: relative;
        transform-origin: 0 0;
    }

    .canvas-connections {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
    }

    .canvas-nodes-layer {
        position: relative;
        z-index: 2;
    }

    .canvas-node {
        position: absolute;
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        min-width: 280px;
        max-width: 320px;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, filter 0.15s ease;
        z-index: 10;
    }

    .canvas-node:hover {
        transform: translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }

    .canvas-node.dragging {
        cursor: grabbing;
        opacity: 0.9;
        z-index: 1000;
        transform: scale(1.05);
    }

    .canvas-node.selected {
        border-color: var(--treeplex-primary) !important;
        box-shadow:
            0 8px 32px rgba(99, 102, 241, 0.4),
            0 4px 16px rgba(99, 102, 241, 0.3),
            0 0 0 3px rgba(99, 102, 241, 0.2) !important;
        transform: translateY(-2px);
    }

    .phase-zone {
        position: absolute;
        border: 3px dashed;
        border-radius: 20px;
        padding: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .phase-zone-header {
        font-weight: 700;
        font-size: 18px;
        margin-bottom: 12px;
        color: var(--text-primary);
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* Colored phase zones - vibrant colors */
    .phase-0 {
        border-color: #3B82F6;
        background: rgba(59, 130, 246, 0.08);
    }
    .phase-1 {
        border-color: #F59E0B;
        background: rgba(245, 158, 11, 0.08);
    }
    .phase-2 {
        border-color: #10B981;
        background: rgba(16, 185, 129, 0.08);
    }
    .phase-3 {
        border-color: #8B5CF6;
        background: rgba(139, 92, 246, 0.08);
    }
    .phase-4 {
        border-color: #EC4899;
        background: rgba(236, 72, 153, 0.08);
    }
    .phase-5 {
        border-color: #06B6D4;
        background: rgba(6, 182, 212, 0.08);
    }

    /* Grid overlay */
    .canvas-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .canvas-grid.active {
        opacity: 1;
    }

    .canvas-toolbar.active {
        display: flex !important;
    }

    .canvas-toolbar button:hover {
        background: rgba(99, 102, 241, 0.3) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .canvas-toolbar button:active {
        transform: translateY(0);
    }

    .canvas-toolbar select:hover {
        background: rgba(99, 102, 241, 0.25) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
    }

    .canvas-toolbar select option {
        background: #1a1a2e;
        color: #ffffff;
        padding: 10px;
        font-weight: 600;
    }

    .canvas-toolbar select option:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    </style>
    <!-- SheetJS library for Excel export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <!-- LZ-String library for URL compression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <!-- Google API Client Library for OAuth and Drive API -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>
</head>
<body>
    <!-- TreeListy by geej Splash Screen -->
    <div id="splash-screen">
        <div class="splash-logo">üå≥</div>
        <div class="splash-title">TreeListy</div>
        <div class="splash-subtitle">by geej</div>
        <div class="splash-tagline">From Complexity to Clarity</div>
        <div class="splash-loader">
            <div class="splash-loader-bar"></div>
        </div>
    </div>

    <!-- Header -->
    <div class="header">
        <div style="display: flex; align-items: center; gap: 20px;">
            <div class="logo">
                <div class="logo-title">
                    <span>üå≥</span>
                    <span>TreeListy</span>
                </div>
                <div class="logo-subtitle">by geej</div>
            </div>

            <!-- Save Indicator -->
            <div id="save-indicator" style="font-size: 12px; color: #9DA3B4; margin-left: 12px; white-space: nowrap;">
                ‚óè Unsaved changes
            </div>

        </div>
        <div class="controls" style="flex-wrap: wrap; gap: 8px;">
            <!-- Row 1: Main controls -->
            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="toggle-view-mode" title="Switch between Tree and Canvas views" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); padding: 6px 10px; font-size: 13px;">
                    <span id="view-mode-icon">üé®</span>
                    <span id="view-mode-text">Canvas</span>
                </button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="new-project-btn" style="background: linear-gradient(135deg, #059669, #10b981); padding: 6px 10px; font-size: 13px;" title="Start a new project">üÜï</button>
                <button class="btn" id="save-json-btn" title="Save project as JSON" style="padding: 6px 10px; font-size: 13px;">üíæ</button>
                <button class="btn" id="load-json-btn" title="Load project from JSON" style="padding: 6px 10px; font-size: 13px;">üìÇ</button>
                <button class="btn" id="share-btn" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); padding: 6px 10px; font-size: 13px;" title="Generate shareable URL">üì§</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="excel-export-btn" style="background: linear-gradient(135deg, #1D6F42, #00A67D); padding: 6px 10px; font-size: 13px;" title="Export to Excel">üìä</button>
                <button class="btn" id="excel-import-btn" style="background: linear-gradient(135deg, #00A67D, #1D6F42); padding: 6px 10px; font-size: 13px;" title="Import from Excel">üì•</button>
                <button class="btn" id="refresh-drive-btn" style="background: linear-gradient(135deg, #4285f4, #34a853); padding: 6px 10px; font-size: 13px;" title="Refresh from Google Drive">‚òÅÔ∏è</button>
                <input type="file" id="excel-upload-input" accept=".xlsx,.xls" style="display: none;">
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="undo-btn" title="Undo last action" disabled style="opacity: 0.5; padding: 6px 10px; font-size: 13px;">‚Ü©Ô∏è</button>
                <button class="btn" id="expand-btn" title="Expand all" style="padding: 6px 10px; font-size: 13px;">‚¨áÔ∏è</button>
                <button class="btn" id="collapse-btn" title="Collapse all" style="padding: 6px 10px; font-size: 13px;">‚¨ÜÔ∏è</button>
                <button class="btn" id="search-btn" style="background: linear-gradient(135deg, #3b82f6, #2563eb); padding: 6px 10px; font-size: 13px;" title="Search all fields">üîç</button>
            </div>

            <div class="control-section pattern-selector" style="margin-right: 4px;">
                <select class="pattern-select" id="pattern-select" title="Choose naming pattern" style="padding: 6px 10px; font-size: 13px; min-width: 140px;">
                    <option value="generic" data-desc="Universal: Project ‚Üí Phase ‚Üí Item ‚Üí Task">üìã Generic Project</option>
                    <option value="sales" data-desc="Sales: Pipeline ‚Üí Quarter ‚Üí Deal ‚Üí Action">üíº Sales Pipeline</option>
                    <option value="thesis" data-desc="Academic: Thesis ‚Üí Chapter ‚Üí Section ‚Üí Point">üéì Academic Writing</option>
                    <option value="roadmap" data-desc="Product: Product ‚Üí Quarter ‚Üí Feature ‚Üí Story">üöÄ Product Roadmap</option>
                    <option value="book" data-desc="Writing: Book ‚Üí Part ‚Üí Chapter ‚Üí Scene">üìö Book Writing</option>
                    <option value="event" data-desc="Events: Event ‚Üí Stage ‚Üí Activity ‚Üí Task">üéâ Event Planning</option>
                    <option value="fitness" data-desc="Fitness: Program ‚Üí Phase ‚Üí Workout ‚Üí Exercise">üí™ Fitness Program</option>
                    <option value="strategy" data-desc="Business: Strategy ‚Üí Pillar ‚Üí Initiative ‚Üí Action">üìä Strategic Plan</option>
                    <option value="course" data-desc="Education: Course ‚Üí Unit ‚Üí Lesson ‚Üí Exercise">üìñ Course Design</option>
                    <option value="film" data-desc="Production: Film ‚Üí Phase ‚Üí Scene ‚Üí Shot">üé¨ Film Production</option>
                    <option value="philosophy" data-desc="Philosophy: Treatise ‚Üí Book ‚Üí Argument ‚Üí Premise">ü§î Philosophy</option>
                    <option value="prompting" data-desc="AI Prompting: Workbook ‚Üí Stage ‚Üí Module ‚Üí Step">üß† AI Prompt Design</option>
                    <option value="familytree" data-desc="Genealogy: Family ‚Üí Generation ‚Üí Person ‚Üí Event">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Family Tree</option>
                    <option value="dialogue" data-desc="Rhetoric: Conversation ‚Üí Speaker ‚Üí Statement ‚Üí Point">üí¨ Dialogue & Rhetoric</option>
                    <option value="gmail" data-desc="Email: Inbox/Campaign ‚Üí Label/Stage ‚Üí Thread ‚Üí Message">üìß Email Workflow</option>
                    <option value="filesystem" data-desc="File System: Drive ‚Üí Folder ‚Üí File/Folder (Unlimited Depth)">üíæ File System</option>
                    <option value="custom" data-desc="Custom: Define your own level names">‚úèÔ∏è Custom Names</option>
                </select>
            </div>

            <div class="control-section" id="sort-section" style="display: none; margin-right: 4px;">
                <label for="pattern-sort-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>üîÑ</span>
                    <select id="pattern-sort-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 120px; font-size: 12px;" title="Sort tree items by specific metrics">
                        <option value="">Default Order</option>
                    </select>
                </label>
                <button class="btn" id="reset-sort-btn" style="display: none; padding: 4px 8px; font-size: 12px;" title="Reset to default order">‚Ü∫</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="toggle-ai-tools" style="background: linear-gradient(135deg, #a855f7, #ec4899); color: white; font-weight: 600; padding: 6px 10px; font-size: 13px;" title="Toggle AI Tools Panel">ü§ñ</button>
                <button class="btn" id="api-key-btn" title="Configure your Anthropic API key" style="padding: 6px 10px; font-size: 13px;">üîë</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <label for="unified-ai-mode-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>ü§ñ</span>
                    <select id="unified-ai-mode-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 140px; font-size: 12px;" title="Choose AI provider and model">
                        <optgroup label="üÜì Server (Free - 200/hr)">
                            <option value="server-haiku" title="Fast & cheap">‚ö° Haiku</option>
                            <option value="server-sonnet" selected title="Best reasoning">üß† Sonnet</option>
                        </optgroup>
                        <optgroup label="üîë Your Key (Unlimited)">
                            <option value="user-haiku" title="Your Haiku">‚ö° Haiku</option>
                            <option value="user-sonnet" title="Your Sonnet">üß† Sonnet</option>
                            <option value="user-gemini" title="Your Gemini">üî∑ Gemini</option>
                            <option value="user-chatgpt" title="Your ChatGPT">üí¨ ChatGPT</option>
                        </optgroup>
                        <optgroup label="Disable">
                            <option value="off">‚ùå Off</option>
                        </optgroup>
                    </select>
                </label>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <label for="theme-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>üé®</span>
                    <select id="theme-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 100px; font-size: 12px;" title="Choose visual theme">
                        <option value="default">üåô Default</option>
                        <option value="steampunk">‚öôÔ∏è Steampunk</option>
                        <option value="powerpuff">üíó Powerpuff</option>
                        <option value="tron">üí† Tron</option>
                    </select>
                </label>
            </div>

            <div class="control-section" style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                <button class="btn" id="how-to-btn" title="How to use TreeListy" style="padding: 6px 10px; font-size: 13px;">‚ùì</button>
                <div style="font-size: 10px; color: var(--text-secondary); opacity: 0.7; white-space: nowrap;" title="TreeListy v2.3.0 | Build 133 | 2025-11-20">
                    v2.3.0 ‚Ä¢ Build 133
                </div>
            </div>
        </div>
    </div>

    <!-- Pan/Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" id="zoom-in" title="Zoom In">
            <span>+</span>
        </button>
        <button class="zoom-btn" id="zoom-out" title="Zoom Out">
            <span>‚àí</span>
        </button>
        <button class="zoom-btn" id="zoom-reset" title="Reset View">
            <span>‚ü≤</span>
        </button>
        <div class="zoom-level" id="zoom-level">100%</div>
    </div>

    <!-- Tree View Container -->
    <div class="tree-view-container">

    <!-- Tree -->
    <div class="tree-container" id="tree-container">
        <div class="tree-transform-wrapper" id="tree-transform-wrapper">
            <svg class="dependency-svg" id="dependency-svg"></svg>
            <div class="tree" id="tree-root"></div>
        </div>
    </div>

    </div><!-- /tree-view-container -->

    <!-- Info Panel -->
    <div class="info-panel" id="info-panel">
        <div class="info-header">
            <div class="info-title" id="info-title">Details</div>
            <button class="close-btn" id="close-info">‚úï</button>
        </div>
        <div class="info-body" id="info-body"></div>
    </div>

    <!-- Context Menu (populated dynamically) -->
    <div class="context-menu" id="context-menu"></div>

    <!-- Floating AI Tools Panel -->
    <div id="ai-tools-panel" style="position: fixed; bottom: 20px; right: 20px; z-index: 500; display: none; flex-direction: column; gap: 10px; padding: 16px; background: rgba(20, 20, 30, 0.98); backdrop-filter: blur(10px); border: 2px solid rgba(168, 85, 247, 0.4); border-radius: 16px; box-shadow: 0 8px 32px rgba(168, 85, 247, 0.3); min-width: 240px;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <div style="font-weight: 700; font-size: 15px; color: #e4e4e7; display: flex; align-items: center; gap: 8px;">
                ü§ñ AI Tools
            </div>
            <button id="close-ai-tools" style="background: transparent; border: none; color: var(--text-secondary); font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; border-radius: 4px; transition: all 0.2s;" title="Close AI Tools Panel">‚úï</button>
        </div>

        <button class="btn" id="analyze-text-btn" title="Input/paste/load txt to be analyzed" style="width: 100%; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; font-weight: 600; justify-content: flex-start;">üîç Analyze Text</button>
        <button class="btn" id="wizard-btn" title="Grow your tree via chat" style="width: 100%; background: linear-gradient(135deg, #a855f7, #ec4899); color: white; font-weight: 600; justify-content: flex-start;">ü™Ñ AI Wizard</button>
        <button class="btn" id="ai-review-btn" title="Get recommendations for improvement" style="width: 100%; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; font-weight: 600; justify-content: flex-start;">üî¨ AI Review</button>
        <button class="btn" id="auto-enhance-btn" title="Takes text from recommendations and prompts pattern ai to make improvements" style="width: 100%; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; font-weight: 600; justify-content: flex-start;">üîÑ Auto-Enhance</button>
        <button class="btn" id="generate-prompt-btn" title="Generate a complete prompt from your tree structure" style="width: 100%; background: linear-gradient(135deg, #10b981, #059669); color: white; font-weight: 600; justify-content: flex-start;">üìù Generate Prompt</button>
        <button class="btn btn-primary" id="ai-btn" title="Nothing useful yet" style="width: 100%; justify-content: flex-start;">ü§ñ AI Analysis</button>

        <div style="margin-top: 8px; padding-top: 12px; border-top: 1px solid rgba(99, 102, 241, 0.2);">
            <label for="unified-ai-mode-select-panel" style="display: block; font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;">AI Model:</label>
            <select id="unified-ai-mode-select-panel" class="btn" style="width: 100%; padding: 8px 10px; cursor: pointer; font-weight: 600; font-size: 13px;" title="Choose AI provider and model">
                <optgroup label="üÜì Server (Free - Rate Limited: 200/hr)">
                    <option value="server-haiku" title="Server Claude Haiku - Fast & cheap, 200 req/hr limit">‚ö° Fast (Haiku)</option>
                    <option value="server-sonnet" selected title="Server Claude Sonnet 4.5 - Best reasoning, 200 req/hr limit">üß† Best (Sonnet 4.5)</option>
                </optgroup>
                <optgroup label="üîë Your Key (Unlimited - Requires API Key)">
                    <option value="user-haiku" title="Your Claude Haiku - Fast & cheap, unlimited with your key">‚ö° Fast (Haiku)</option>
                    <option value="user-sonnet" title="Your Claude Sonnet 4.5 - Best reasoning with extended thinking, unlimited">üß† Best (Sonnet 4.5)</option>
                    <option value="user-gemini" title="Your Gemini - Fast & cost-effective, requires Google API key">üî∑ Gemini</option>
                    <option value="user-chatgpt" title="Your ChatGPT - Versatile & popular, requires OpenAI API key">üí¨ ChatGPT</option>
                </optgroup>
                <optgroup label="Disable AI Features">
                    <option value="off" title="Turn off all AI features">‚ùå Off</option>
                </optgroup>
            </select>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <div class="modal-header" id="modal-title">AI Analysis</div>
            <div class="modal-body" id="modal-body">
                <div class="spinner"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="modal-close">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="edit-modal">
        <div class="modal-content">
            <div class="modal-header">Edit Item</div>
            <div class="modal-body" id="edit-modal-body"></div>
            <div class="modal-footer">
                <button class="btn" id="edit-cancel">Cancel</button>
                <button class="btn btn-primary" id="edit-save">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Analysis Mode Modal -->
    <div class="modal" id="analysis-modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">üîç Analysis Mode - Convert Text to Tree Structure</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Upload a text file or paste content below. AI will analyze it, detect the best pattern, and convert it into a hierarchical tree structure.
                    </p>
                </div>

                <!-- Analysis Mode Selection (moved to top) -->
                <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                    <div id="current-ai-mode-display" style="padding: 16px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 8px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <div style="font-weight: 600; color: var(--text-primary);">
                                AI Mode: <span id="analyze-mode-label">‚ö° Quick</span>
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                Change mode in header
                            </div>
                        </div>
                        <div id="analyze-mode-description" style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                            Fast pattern detection + basic structure. Recommended for most uses.
                        </div>
                        <div style="margin-top: 12px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                            <strong style="color: var(--text-primary);">üí° Tip:</strong> Change AI mode in the header (ü§ñ AI Mode dropdown) to switch between Quick, Deep, or Off.
                        </div>
                    </div>
                </div>

                <!-- Pattern Selection -->
                <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        üìê Pattern Selection
                    </label>
                    <select id="analysis-pattern-select" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: #1a1a2e; color: #ffffff; font-size: 14px; cursor: pointer;">
                        <option value="auto" style="background: #1a1a2e; color: #ffffff;">ü§ñ Auto-detect (AI chooses best pattern)</option>
                        <option value="generic" style="background: #1a1a2e; color: #ffffff;">üì¶ Generic Project - Universal structure</option>
                        <option value="sales" style="background: #1a1a2e; color: #ffffff;">üíº Sales Pipeline - Deal tracking</option>
                        <option value="thesis" style="background: #1a1a2e; color: #ffffff;">üìö Academic Writing - Research papers</option>
                        <option value="roadmap" style="background: #1a1a2e; color: #ffffff;">üó∫Ô∏è Product Roadmap - Feature timeline</option>
                        <option value="book" style="background: #1a1a2e; color: #ffffff;">üìñ Book Writing - Narrative structure</option>
                        <option value="event" style="background: #1a1a2e; color: #ffffff;">üéâ Event Planning - Event logistics</option>
                        <option value="fitness" style="background: #1a1a2e; color: #ffffff;">üí™ Fitness Program - Workout plans</option>
                        <option value="strategy" style="background: #1a1a2e; color: #ffffff;">üéØ Strategic Plan - Business initiatives</option>
                        <option value="course" style="background: #1a1a2e; color: #ffffff;">üéì Course Design - Curriculum structure</option>
                        <option value="film" style="background: #1a1a2e; color: #ffffff;">üé¨ Film Production - Video workflow</option>
                        <option value="philosophy" style="background: #1a1a2e; color: #ffffff;">ü§î Philosophy - Arguments & treatises</option>
                        <option value="prompting" style="background: #1a1a2e; color: #ffffff;">üß† Prompt Engineering - AI prompts</option>
                        <option value="familytree" style="background: #1a1a2e; color: #ffffff;">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Family Tree - Genealogy</option>
                        <option value="dialogue" style="background: #1a1a2e; color: #ffffff;">üí¨ Dialogue & Rhetoric - Debate analysis</option>
                    </select>
                    <div style="margin-top: 8px; padding: 10px; background: rgba(99, 102, 241, 0.1); border-radius: 4px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                        <strong style="color: var(--text-primary);">üí° Tip:</strong> Auto-detect lets AI analyze your text and recommend the best pattern. Or choose a specific pattern if you know what structure you want.
                    </div>
                </div>

                <!-- File Upload Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        üìÅ Upload File (.txt, .md)
                    </label>
                    <div id="file-drop-zone" style="border: 2px dashed var(--border); border-radius: 8px; padding: 32px; text-align: center; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s;">
                        <div style="font-size: 48px; margin-bottom: 12px;">üìÑ</div>
                        <div style="color: var(--text-primary); font-weight: 500; margin-bottom: 4px;">
                            Drop file here or click to browse
                        </div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            Supports .txt and .md files (max 100KB recommended)
                        </div>
                        <input type="file" id="analysis-file-input" accept=".txt,.md" style="display: none;" />
                    </div>
                    <div id="file-name-display" style="margin-top: 8px; color: var(--text-secondary); font-size: 13px; display: none;">
                        Selected: <span id="selected-file-name" style="color: var(--treeplex-primary); font-weight: 500;"></span>
                        <button id="clear-file-btn" style="margin-left: 8px; color: var(--text-secondary); background: none; border: none; cursor: pointer; font-size: 13px;">[Clear]</button>
                    </div>
                </div>

                <div style="text-align: center; margin: 16px 0; color: var(--text-secondary); font-size: 13px; font-weight: 600;">
                    ‚Äî OR ‚Äî
                </div>

                <!-- Paste Text Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        üìù Paste Text
                    </label>
                    <textarea id="analysis-text-input" placeholder="Paste your text content here...

Example:
- Meeting notes
- Project outline
- Research paper
- Strategic plan
- Event agenda
- Course syllabus

The AI will analyze the structure and convert it to a tree."
                        style="width: 100%; min-height: 200px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: 'Inter', monospace; font-size: 13px; resize: vertical;"></textarea>
                    <div id="char-count" style="margin-top: 6px; text-align: right; color: var(--text-secondary); font-size: 12px;">
                        0 characters
                    </div>
                </div>

                <!-- Warning Display -->
                <div id="analysis-warning" style="display: none; padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px; margin-bottom: 16px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">‚ö†Ô∏è Large File Warning</div>
                    <div id="analysis-warning-text" style="color: var(--text-secondary); font-size: 13px;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="analysis-cancel">Cancel</button>
                <button class="btn btn-primary" id="analysis-start-btn" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">üîç Analyze</button>
            </div>
        </div>
    </div>

    <!-- API Key Configuration Modal -->
    <div class="modal" id="api-key-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">üîë AI Provider Configuration</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Configure your AI provider and API keys. You can use Claude, Gemini, ChatGPT, or all three.
                    </p>
                </div>

                <!-- Provider Selection -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        Primary AI Provider
                    </label>
                    <select id="provider-select" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 14px; cursor: pointer;">
                        <option value="anthropic">ü§ñ Anthropic Claude (Sonnet 4.5) - Best reasoning</option>
                        <option value="gemini">üî∑ Google Gemini (2.0 Flash) - Fast & cost-effective</option>
                        <option value="openai">üí¨ OpenAI ChatGPT (GPT-4o) - Versatile & popular</option>
                    </select>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 6px; line-height: 1.4;">
                        <strong>Cost comparison:</strong> Claude ~$3/1M input, $15/1M output | Gemini Free tier, then ~$0.075/1M | ChatGPT ~$2.50/1M input, $10/1M output
                    </div>
                </div>

                <!-- Claude API Key Section -->
                <div id="claude-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(99, 102, 241, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">ü§ñ Anthropic Claude API Key</div>
                        <div id="claude-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: var(--treeplex-primary); font-size: 13px; font-weight: 500;">üí° How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://console.anthropic.com/" target="_blank" style="color: var(--treeplex-primary);">console.anthropic.com</a></li>
                            <li>Sign up or log in to your account</li>
                            <li>Go to API Keys section</li>
                            <li>Create a new API key</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="claude-api-key-input" placeholder="sk-ant-..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <!-- Gemini API Key Section -->
                <div id="gemini-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(66, 133, 244, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">üî∑ Google Gemini API Key</div>
                        <div id="gemini-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: #4285f4; font-size: 13px; font-weight: 500;">üí° How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: #4285f4;">aistudio.google.com/app/apikey</a></li>
                            <li>Sign in with your Google account</li>
                            <li>Create a new API key</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="gemini-api-key-input" placeholder="AIzaSy..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <!-- OpenAI API Key Section -->
                <div id="openai-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(16, 163, 127, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">üí¨ OpenAI ChatGPT API Key</div>
                        <div id="openai-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: #10a37f; font-size: 13px; font-weight: 500;">üí° How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #10a37f;">platform.openai.com/api-keys</a></li>
                            <li>Sign up or log in to your account</li>
                            <li>Click "Create new secret key"</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="openai-api-key-input" placeholder="sk-proj-..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                    <input type="checkbox" id="api-key-show" style="cursor: pointer;" />
                    <label for="api-key-show" style="font-size: 13px; color: var(--text-secondary); cursor: pointer;">Show API keys</label>
                </div>

                <div style="padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">üîí Security & Storage</div>
                    <div style="color: var(--text-secondary); font-size: 12px; line-height: 1.5;">
                        Your API keys are stored locally in your browser's localStorage and persist across sessions. Keys are never sent to any server except the respective AI provider's API (Anthropic, Google, or OpenAI).
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="api-key-cancel">Cancel</button>
                <button class="btn" id="api-key-clear" style="margin-right: auto; background: rgba(239, 68, 68, 0.1); color: #ef4444;">üóëÔ∏è Clear All Keys</button>
                <button class="btn btn-primary" id="api-key-save" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Save & Continue</button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div class="modal" id="share-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">üì§ Share Your Project</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 15px;">
                        Share this link with anyone! The link contains your entire project data (no server storage).
                    </p>
                    <div style="background: var(--card-bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 15px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="share-url-input" readonly
                                   style="flex: 1; background: var(--card-bg); border: 1px solid var(--border); color: var(--text-primary); padding: 10px; border-radius: 6px; font-family: monospace; font-size: 12px; user-select: all;"
                                   value="">
                            <button class="btn btn-primary" id="copy-share-url" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); white-space: nowrap;">
                                üìã Copy
                            </button>
                        </div>
                    </div>
                    <div id="share-stats" style="display: flex; gap: 20px; font-size: 13px; color: var(--text-secondary);">
                        <div>üìä <span id="share-node-count">0</span> nodes</div>
                        <div>üìè <span id="share-url-length">0</span> characters</div>
                        <div id="share-size-warning" style="display: none; color: #f59e0b;">‚ö†Ô∏è Large project - URL may not work in all apps</div>
                    </div>
                </div>
                <div style="background: var(--card-bg); padding: 15px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                    <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span>‚ÑπÔ∏è</span> How it works
                    </div>
                    <ul style="margin-left: 20px; color: var(--text-secondary); font-size: 14px; line-height: 1.6;">
                        <li>Your data is compressed and embedded in the URL (not stored on any server)</li>
                        <li>Anyone with the link can view and edit their own copy</li>
                        <li>Works best for projects with up to 40-50 nodes</li>
                        <li>For larger projects, use "üíæ Save" to download JSON instead</li>
                    </ul>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="share-close">Close</button>
                <button class="btn btn-primary" id="open-share-url" style="background: linear-gradient(135deg, #3B8FCC, #2B7AB8);">
                    üîó Open in New Tab
                </button>
            </div>
        </div>
    </div>

    <!-- Wizard Modal -->
    <div class="modal" id="wizard-modal" style="display: none; justify-content: flex-end; background: rgba(0, 0, 0, 0.3);">
        <div class="modal-content" style="width: 550px; max-width: 90vw; height: 100vh; max-height: 100vh; margin: 0; border-radius: 0; animation: slideInRight 0.3s ease-out;">
            <style>
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                    }
                    to {
                        transform: translateX(0);
                    }
                }
        
    /* ===================================================== */
    /* CANVAS VIEW STYLES */
    /* ===================================================== */

    .tree-view-container {
        display: block;
    }

    .tree-view-container.hidden {
        display: none !important;
    }

    .canvas-container {
        display: none;
        position: fixed;
        top: 140px;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        overflow: hidden;
        cursor: grab;
    }

    .canvas-container.active {
        display: block;
    }

    .canvas-container.grabbing {
        cursor: grabbing;
    }

    #canvas {
        width: 100%;
        height: 100%;
        position: relative;
        transform-origin: 0 0;
    }

    .canvas-connections {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
    }

    .canvas-nodes-layer {
        position: relative;
        z-index: 2;
    }

    .canvas-node {
        position: absolute;
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        min-width: 280px;
        max-width: 320px;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, filter 0.15s ease;
        z-index: 10;
    }

    .canvas-node:hover {
        transform: translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }

    .canvas-node.dragging {
        cursor: grabbing;
        opacity: 0.9;
        z-index: 1000;
        transform: scale(1.05);
    }

    .canvas-node.selected {
        border-color: var(--treeplex-primary) !important;
        box-shadow:
            0 8px 32px rgba(99, 102, 241, 0.4),
            0 4px 16px rgba(99, 102, 241, 0.3),
            0 0 0 3px rgba(99, 102, 241, 0.2) !important;
        transform: translateY(-2px);
    }

    .phase-zone {
        position: absolute;
        border: 3px dashed;
        border-radius: 20px;
        padding: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .phase-zone-header {
        font-weight: 700;
        font-size: 18px;
        margin-bottom: 12px;
        color: var(--text-primary);
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* Colored phase zones - vibrant colors */
    .phase-0 {
        border-color: #3B82F6;
        background: rgba(59, 130, 246, 0.08);
    }
    .phase-1 {
        border-color: #F59E0B;
        background: rgba(245, 158, 11, 0.08);
    }
    .phase-2 {
        border-color: #10B981;
        background: rgba(16, 185, 129, 0.08);
    }
    .phase-3 {
        border-color: #8B5CF6;
        background: rgba(139, 92, 246, 0.08);
    }
    .phase-4 {
        border-color: #EC4899;
        background: rgba(236, 72, 153, 0.08);
    }
    .phase-5 {
        border-color: #06B6D4;
        background: rgba(6, 182, 212, 0.08);
    }

    /* Grid overlay */
    .canvas-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .canvas-grid.active {
        opacity: 1;
    }

    .canvas-toolbar.active {
        display: flex !important;
    }

    .canvas-toolbar button:hover {
        background: rgba(99, 102, 241, 0.3) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .canvas-toolbar button:active {
        transform: translateY(0);
    }

    .canvas-toolbar select:hover {
        background: rgba(99, 102, 241, 0.25) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
    }

    .canvas-toolbar select option {
        background: #1a1a2e;
        color: #ffffff;
        padding: 10px;
        font-weight: 600;
    }

    .canvas-toolbar select option:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    </style>
            <div class="modal-header">
                <span id="wizard-title">ü™Ñ AI Wizard - Building Your Project</span>
            </div>

            <div style="padding: 15px; background: var(--card-bg-light); border-bottom: 1px solid var(--border);">
                <div style="display: flex; gap: 30px; font-size: 14px; margin-bottom: 10px;">
                    <div>üìä Turn: <span id="wizard-question-count" style="color: var(--treeplex-primary); font-weight: 600;">0</span></div>
                    <div>‚úì Fields: <span id="wizard-fields-complete" style="color: var(--treeplex-primary); font-weight: 600;">0</span>/<span id="wizard-fields-total">10</span> complete</div>
                    <div>üìà <span id="wizard-progress-percent" style="color: var(--treeplex-primary); font-weight: 600;">0%</span> complete</div>
                    <div id="wizard-completion" style="display: none; color: #10b981; font-weight: 600;">‚úÖ Ready to Apply!</div>
                </div>
                <!-- Progress Bar -->
                <div style="width: 100%; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden;">
                    <div id="wizard-progress-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--treeplex-primary), #10b981); transition: width 0.5s ease;"></div>
                </div>
            </div>

            <div class="modal-body" style="display: flex; flex-direction: column; padding: 0; height: calc(100vh - 200px); overflow: hidden;">
                <!-- Tip Banner -->
                <div style="padding: 12px 20px; background: linear-gradient(135deg, rgba(163, 85, 247, 0.1), rgba(236, 72, 153, 0.1)); border-bottom: 1px solid var(--border);">
                    <div style="font-size: 12px; color: var(--text-primary); display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 16px;">üí°</span>
                        <span>Watch your tree update in real-time on the left as we build it together!</span>
                    </div>
                </div>

                <!-- Chat Area -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <div id="wizard-chat-history" style="flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px;">
                        <!-- Chat messages will appear here -->
                    </div>
                    <div style="padding: 15px 20px; border-top: 1px solid var(--border); display: flex; gap: 10px; background: var(--bg-secondary);">
                        <input type="text" id="wizard-user-input" placeholder="Type your answer here..."
                               style="flex: 1; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 6px; font-size: 14px;"
                               onkeypress="if(event.key==='Enter') document.getElementById('wizard-send').click()">
                        <button class="btn btn-primary" id="wizard-send" style="background: linear-gradient(135deg, #a855f7, #ec4899); padding: 12px 24px; white-space: nowrap;">
                            Send
                        </button>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="wizard-cancel">Cancel</button>
                <button class="btn" id="wizard-auto-enhance" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; font-weight: 600;" title="Automatically run AI Review then enhance your tree">
                    üîÑ Auto-Enhance
                </button>
                <button class="btn btn-primary" id="wizard-done" style="background: linear-gradient(135deg, #10b981, #059669);">
                    ‚úÖ Finish & Apply
                </button>
            </div>
        </div>
    </div>

    <!-- Generate Prompt Modal -->
    <div class="modal" id="generate-prompt-modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh;">
            <div class="modal-header">
                <span id="generate-prompt-title">üìù Generated Prompt</span>
            </div>

            <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(85vh - 140px);">
                <div style="margin-bottom: 15px; color: var(--text-secondary); font-size: 13px;">
                    This prompt was generated from your tree structure. Copy and paste it to use with AI systems.
                </div>

                <div style="position: relative;">
                    <textarea id="generated-prompt-text" readonly style="
                        width: 100%;
                        min-height: 400px;
                        padding: 15px;
                        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                        font-size: 13px;
                        line-height: 1.6;
                        border: 1px solid var(--border);
                        border-radius: 8px;
                        background: var(--card-bg);
                        color: var(--text-primary);
                        resize: vertical;
                    "></textarea>

                    <button id="copy-prompt-btn" style="
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        padding: 8px 16px;
                        background: var(--treeplex-primary);
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 600;
                    ">üìã Copy</button>
                </div>

                <div id="copy-success-message" style="
                    margin-top: 10px;
                    padding: 10px;
                    background: #10b981;
                    color: white;
                    border-radius: 6px;
                    text-align: center;
                    display: none;
                ">‚úÖ Copied to clipboard!</div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-prompt-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- AI Review Modal -->
    <div class="modal" id="ai-review-modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh;">
            <div class="modal-header">
                <span>üî¨ AI Review & Enhance</span>
            </div>

            <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 140px);">
                <!-- Status area -->
                <div id="ai-review-status" style="margin-bottom: 20px;">
                    <div style="padding: 15px; background: rgba(99, 102, 241, 0.1); border-left: 3px solid #6366f1; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">ü§ñ AI is analyzing your tree...</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            Checking for completeness, redundancies, logical flow, and pattern alignment.
                        </div>
                    </div>
                </div>

                <!-- Results area (hidden initially) -->
                <div id="ai-review-results" style="display: none;">
                    <!-- Summary section -->
                    <div style="margin-bottom: 24px; padding: 16px; background: var(--card-bg-light); border-radius: 8px;">
                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: var(--text-primary);">üìä Analysis Summary</h3>
                        <div id="ai-review-summary"></div>
                    </div>

                    <!-- Suggestions section -->
                    <div style="margin-bottom: 24px;">
                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: var(--text-primary);">‚ú® Suggested Improvements</h3>
                        <div id="ai-review-suggestions"></div>
                    </div>

                    <!-- Actions section -->
                    <div style="padding: 16px; background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">üéØ Next Steps</div>
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
                            Review the suggestions above. You can manually apply changes to your tree, or let AI enhance specific areas.
                        </div>
                        <button class="btn" id="ai-review-again" style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white;">
                            üîÑ Re-analyze
                        </button>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-ai-review-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- Search Modal -->
    <div class="modal" id="search-modal" style="display: none;">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh;">
            <div class="modal-header">
                <span>üîç Search Tree</span>
            </div>

            <div class="modal-body" style="padding: 20px;">
                <!-- Search input -->
                <div style="margin-bottom: 20px;">
                    <input type="text" id="search-input" placeholder="Search all fields (name, description, notes, etc.)..."
                        style="width: 100%; padding: 12px 16px; font-size: 15px; border: 2px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); outline: none; transition: border-color 0.2s;">
                    <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                        üí° Tip: Search is case-insensitive and searches all fields in all nodes
                    </div>
                </div>

                <!-- Search results -->
                <div id="search-results-container" style="max-height: calc(90vh - 260px); overflow-y: auto;">
                    <div id="search-results-empty" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                        <div style="font-size: 48px; margin-bottom: 12px;">üîç</div>
                        <div style="font-size: 14px;">Enter a search term to find nodes</div>
                    </div>
                    <div id="search-results" style="display: none;"></div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-search-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- PWA Onboarding Modal -->
    <div class="modal" id="pwa-onboarding-modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <span>üå≥ Welcome to TreeListy!</span>
            </div>

            <div class="modal-body" style="padding: 30px;">
                <!-- Success checkmark -->
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 64px;">‚úÖ</div>
                    <h2 style="margin: 16px 0 8px; color: var(--text-primary); font-size: 22px;">Tree Loaded Successfully!</h2>
                    <p style="color: var(--text-secondary); font-size: 14px; margin: 0;">You can now explore this project</p>
                </div>

                <!-- Divider -->
                <div style="height: 1px; background: var(--border); margin: 24px 0;"></div>

                <!-- Install prompt -->
                <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); border: 2px solid var(--treeplex-primary); border-radius: 12px; padding: 24px; margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">
                        <div style="font-size: 40px;">üíæ</div>
                        <div>
                            <h3 style="margin: 0 0 4px; color: var(--text-primary); font-size: 18px;">Want to work with .treelisty files?</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: 13px;">Install TreeListy to open files with a double-click!</p>
                        </div>
                    </div>

                    <div style="background: var(--card-bg); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">‚ú® Benefits:</div>
                        <ul style="margin: 0; padding-left: 20px; color: var(--text-primary); font-size: 14px; line-height: 1.8;">
                            <li>Open <code style="background: var(--bg); padding: 2px 6px; border-radius: 4px; font-family: monospace;">.treelisty</code> files with a double-click</li>
                            <li>Works offline after installation</li>
                            <li>Access from your app menu/desktop</li>
                            <li>Faster loading and better performance</li>
                        </ul>
                    </div>

                    <!-- Universal Install button - ALWAYS shown -->
                    <button class="btn" id="pwa-install-btn" style="width: 100%; background: linear-gradient(135deg, #6366f1, #8b5cf6); padding: 16px; font-size: 16px; font-weight: 600;">
                        üì• Install TreeListy
                    </button>

                    <!-- Instructions (shown after clicking if manual install needed) -->
                    <div id="pwa-manual-instructions" style="display: none; margin-top: 16px; padding: 16px; background: var(--card-bg-light); border-radius: 8px; border: 2px solid var(--treeplex-primary);">
                        <div style="font-size: 15px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">
                            üìç Follow these steps:
                        </div>
                        <ol style="margin: 0; padding-left: 24px; color: var(--text-primary); font-size: 14px; line-height: 2;">
                            <li>Look at the <strong>address bar</strong> (top of browser)</li>
                            <li>Find the <strong>install icon</strong> on the right side:
                                <span style="background: var(--bg); padding: 4px 8px; border-radius: 4px; margin-left: 8px;">üì•</span> or
                                <span style="background: var(--bg); padding: 4px 8px; border-radius: 4px; margin-left: 4px;">‚äï</span>
                            </li>
                            <li>Click the icon and select <strong>"Install"</strong></li>
                        </ol>
                        <div style="margin-top: 16px; padding: 12px; background: rgba(234, 179, 8, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                            üí° Don't see the icon? Close this modal and look for it. Still missing? You might need to use Chrome or Edge browser.
                        </div>
                    </div>
                </div>

                <!-- Skip option -->
                <div style="text-align: center;">
                    <button class="btn" id="pwa-skip-btn" style="background: var(--card-bg); color: var(--text-secondary); padding: 10px 20px; font-size: 13px;">
                        Maybe Later
                    </button>
                    <div style="margin-top: 8px; font-size: 11px; color: var(--text-secondary);">
                        You can always install later from the Help menu
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input for JSON upload -->
    <input type="file" id="json-upload-input" accept=".json,.treelisty" style="display: none;" />

    <script>
        console.log('TreeListy - Universal Project Decomposition - Horizontal Layout with Pan/Zoom');

        // =============================================================================
        // PAN & ZOOM SYSTEM
        // =============================================================================

        // Pan/Zoom state
        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startX = 0;
        let startY = 0;

        const MIN_ZOOM = 0.25;  // 25%
        const MAX_ZOOM = 3.0;   // 300%
        const ZOOM_STEP = 0.15; // 15% per click

        // Apply transform to tree
        function applyTransform() {
            const wrapper = document.getElementById('tree-transform-wrapper');
            if (wrapper) {
                wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
                updateZoomDisplay();
            }
        }

        // Update zoom level display
        function updateZoomDisplay() {
            const display = document.getElementById('zoom-level');
            if (display) {
                display.textContent = Math.round(zoomLevel * 100) + '%';
            }
        }

        // Zoom in
        function zoomIn() {
            if (zoomLevel < MAX_ZOOM) {
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
                applyTransform();
            }
        }

        // Zoom out
        function zoomOut() {
            if (zoomLevel > MIN_ZOOM) {
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
                applyTransform();
            }
        }

        // Reset view
        function resetZoom() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            applyTransform();
        }

        // Mouse wheel zoom
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY;

            if (delta < 0) {
                // Scroll up = zoom in
                zoomIn();
            } else {
                // Scroll down = zoom out
                zoomOut();
            }
        }

        // Mouse down - start panning
        function handleMouseDown(e) {
            // Don't pan if clicking on a node or button
            if (e.target.closest('.tree-node') || e.target.closest('button') || e.target.closest('.zoom-controls')) {
                return;
            }

            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;

            const container = document.getElementById('tree-container');
            container.classList.add('panning');
        }

        // Mouse move - pan
        function handleMouseMove(e) {
            if (!isPanning) return;

            panX = e.clientX - startX;
            panY = e.clientY - startY;
            applyTransform();
        }

        // Mouse up - stop panning
        function handleMouseUp(e) {
            if (isPanning) {
                isPanning = false;
                const container = document.getElementById('tree-container');
                container.classList.remove('panning');
            }
        }

        // Initialize pan/zoom after DOM loads
        function initPanZoom() {
            const container = document.getElementById('tree-container');

            // Zoom controls
            document.getElementById('zoom-in').addEventListener('click', zoomIn);
            document.getElementById('zoom-out').addEventListener('click', zoomOut);
            document.getElementById('zoom-reset').addEventListener('click', resetZoom);

            // Mouse wheel
            container.addEventListener('wheel', handleWheel, { passive: false });

            // Mouse drag
            container.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Prevent context menu on drag
            container.addEventListener('contextmenu', (e) => {
                if (isPanning) e.preventDefault();
            });

            console.log('‚úÖ Pan/Zoom initialized');
        }

        // =============================================================================
        // END PAN & ZOOM SYSTEM
        // =============================================================================

        // =============================================================================
        // REAL AI INTEGRATION - Claude by Anthropic (via Netlify Function)
        // =============================================================================

        // API Configuration - Supports both local API key and Netlify serverless function
        const AI_CONFIG = {
            provider: 'anthropic',
            get model() {
                // Dynamic model selection - user can choose Haiku (fast) or Sonnet (best)
                return getClaudeModelId();
            },
            // Netlify function endpoint (fallback)
            apiEndpoint: 'https://treelisty.netlify.app/.netlify/functions/claude-proxy',
            // Direct Anthropic API endpoint (when using local API key)
            directEndpoint: 'https://api.anthropic.com/v1/messages'
        };

        // Multi-provider API key management
        function getLocalAPIKey(provider = 'anthropic') {
            return localStorage.getItem(`${provider}_api_key`);
        }

        function setLocalAPIKey(key, provider = 'anthropic') {
            localStorage.setItem(`${provider}_api_key`, key);
        }

        function clearLocalAPIKey(provider = 'anthropic') {
            localStorage.removeItem(`${provider}_api_key`);
        }

        // Get AI provider preference
        function getAIProvider() {
            return localStorage.getItem('ai_provider') || 'anthropic';
        }

        function setAIProvider(provider) {
            localStorage.setItem('ai_provider', provider);
        }

        // Get redundancy mode preference
        function getRedundancyMode() {
            return localStorage.getItem('ai_redundancy_mode') === 'true';
        }

        function setRedundancyMode(enabled) {
            localStorage.setItem('ai_redundancy_mode', enabled.toString());
        }

        // Unified AI Mode management (combines provider, model, and processing mode)
        function getUnifiedAIMode() {
            return localStorage.getItem('unified_ai_mode') || 'server-sonnet';
        }

        function setUnifiedAIMode(mode) {
            localStorage.setItem('unified_ai_mode', mode);
            console.log(`‚úÖ Unified AI mode set to: ${mode}`);

            // Update the dropdown
            const select = document.getElementById('unified-ai-mode-select');
            if (select) {
                select.value = mode;
            }
        }

        // Parse unified mode into components
        function parseUnifiedMode(mode = null) {
            const unifiedMode = mode || getUnifiedAIMode();

            if (unifiedMode === 'off') {
                return {
                    enabled: false,
                    provider: null,
                    model: null,
                    mode: 'off',
                    requiresKey: false,
                    description: 'AI features disabled'
                };
            }

            // server-haiku, server-sonnet, user-haiku, user-sonnet, user-gemini, user-chatgpt
            const [source, target] = unifiedMode.split('-');
            const useServerKey = source === 'server';
            const processingMode = useServerKey ? 'quick' : 'deep';

            let provider, model, modelId, description;

            if (target === 'haiku') {
                provider = 'anthropic';
                model = 'haiku';
                modelId = 'claude-3-haiku-20240307';
                description = useServerKey
                    ? 'Fast & cheap (~$0.25/1M in, $1.25/1M out) - 200 req/hr limit'
                    : 'Fast & cheap (~$0.25/1M in, $1.25/1M out) - Unlimited with your key';
            } else if (target === 'sonnet') {
                provider = 'anthropic';
                model = 'sonnet';
                modelId = 'claude-sonnet-4-20250514';
                description = useServerKey
                    ? 'Best reasoning (~$3/1M in, $15/1M out) - 200 req/hr limit'
                    : 'Best reasoning with extended thinking (~$3/1M in, $15/1M out) - Unlimited';
            } else if (target === 'gemini') {
                provider = 'gemini';
                model = 'gemini';
                modelId = 'gemini-2.0-flash-exp';
                description = 'Fast & cost-effective (Free tier, then ~$0.075/1M) - Requires your key';
            } else if (target === 'chatgpt') {
                provider = 'openai';
                model = 'gpt-4o';
                modelId = 'gpt-4o';
                description = 'Versatile & popular (~$2.50/1M in, $10/1M out) - Requires your key';
            }

            return {
                enabled: true,
                provider: provider,
                model: model,
                modelId: modelId,
                mode: processingMode,
                useServerKey: useServerKey,
                requiresKey: !useServerKey,
                description: description
            };
        }

        // Legacy compatibility functions (for existing code)
        function getGlobalAIMode() {
            const parsed = parseUnifiedMode();
            return parsed.enabled ? parsed.mode : 'off';
        }

        function getAIProvider() {
            const parsed = parseUnifiedMode();
            return parsed.provider || 'anthropic';
        }

        function getClaudeModelId() {
            const parsed = parseUnifiedMode();
            return parsed.modelId || 'claude-sonnet-4-20250514';
        }

        function canUseServerlessAI() {
            return Boolean(AI_CONFIG && typeof AI_CONFIG.apiEndpoint === 'string' && AI_CONFIG.apiEndpoint.length > 0);
        }

        function showApiKeyModal(prefillExisting = false) {
            const apiKeyModal = document.getElementById('api-key-modal');
            const claudeInput = document.getElementById('claude-api-key-input');
            const geminiInput = document.getElementById('gemini-api-key-input');
            const openaiInput = document.getElementById('openai-api-key-input');
            const providerSelect = document.getElementById('provider-select');

            // Load existing keys
            const claudeKey = getLocalAPIKey('anthropic');
            const geminiKey = getLocalAPIKey('gemini');
            const openaiKey = getLocalAPIKey('openai');
            const currentProvider = getAIProvider();

            // Prefill keys if requested
            claudeInput.value = prefillExisting && claudeKey ? claudeKey : '';
            geminiInput.value = prefillExisting && geminiKey ? geminiKey : '';
            openaiInput.value = prefillExisting && openaiKey ? openaiKey : '';

            // Set provider dropdown
            providerSelect.value = currentProvider;

            // Update status badges
            updateKeyStatusBadges();

            // Reset show checkbox
            document.getElementById('api-key-show').checked = false;

            apiKeyModal.style.display = 'flex';
        }

        function updateKeyStatusBadges() {
            const claudeStatus = document.getElementById('claude-key-status');
            const geminiStatus = document.getElementById('gemini-key-status');
            const openaiStatus = document.getElementById('openai-key-status');

            const claudeKey = getLocalAPIKey('anthropic');
            const geminiKey = getLocalAPIKey('gemini');
            const openaiKey = getLocalAPIKey('openai');

            if (claudeKey) {
                claudeStatus.textContent = '‚úì Saved';
                claudeStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                claudeStatus.style.color = '#22c55e';
            } else {
                claudeStatus.textContent = 'Not saved';
                claudeStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                claudeStatus.style.color = '#9ca3af';
            }

            if (geminiKey) {
                geminiStatus.textContent = '‚úì Saved';
                geminiStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                geminiStatus.style.color = '#22c55e';
            } else {
                geminiStatus.textContent = 'Not saved';
                geminiStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                geminiStatus.style.color = '#9ca3af';
            }

            if (openaiKey) {
                openaiStatus.textContent = '‚úì Saved';
                openaiStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                openaiStatus.style.color = '#22c55e';
            } else {
                openaiStatus.textContent = 'Not saved';
                openaiStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                openaiStatus.style.color = '#9ca3af';
            }
        }

        // Helper: Direct API call to Anthropic (bypasses Netlify, no timeout limit)
        async function callClaudeDirectAPI(requestData, apiKey) {
            console.log('üöÄ Direct API: Calling Anthropic Claude directly (no Netlify timeout)');

            try {
                const response = await fetch(AI_CONFIG.directEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    throw new Error(error.error?.message || `Claude API error: ${response.status}`);
                }

                return response;
            } catch (error) {
                // CORS errors show as "Failed to fetch" or TypeError
                if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
                    console.error('‚ùå CORS Error: Browser blocked direct API call to api.anthropic.com');
                    throw new Error('Failed to fetch'); // Re-throw for upstream handling
                }
                throw error;
            }
        }

        // Helper: Direct API call to Google Gemini
        async function callGeminiDirectAPI(prompt, systemPrompt, maxTokens, apiKey) {
            console.log('üöÄ Direct API: Calling Google Gemini directly');

            // Gemini API format is different from Claude
            const geminiRequest = {
                contents: [{
                    parts: [{
                        text: (systemPrompt ? systemPrompt + '\n\n' : '') + prompt
                    }]
                }],
                generationConfig: {
                    maxOutputTokens: maxTokens,
                    temperature: 0.7
                }
            };

            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(geminiRequest)
                }
            );

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `Gemini API error: ${response.status}`);
            }

            const data = await response.json();

            // Convert Gemini response format to Claude-like format for consistency
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                throw new Error('Invalid Gemini response structure');
            }

            return {
                json: async () => ({
                    content: [{
                        text: data.candidates[0].content.parts[0].text
                    }]
                }),
                ok: true
            };
        }

        // Helper: Direct API call to OpenAI ChatGPT
        async function callOpenAIDirectAPI(prompt, systemPrompt, maxTokens, apiKey) {
            console.log('üöÄ Direct API: Calling OpenAI ChatGPT directly');

            // OpenAI API format
            const openaiRequest = {
                model: 'gpt-4o', // Using GPT-4o (latest optimized model)
                max_tokens: maxTokens,
                temperature: 0.7,
                messages: [
                    {
                        role: 'system',
                        content: systemPrompt || 'You are an expert project analyst specializing in breaking down complex projects into manageable components.'
                    },
                    {
                        role: 'user',
                        content: prompt
                    }
                ]
            };

            const response = await fetch(
                'https://api.openai.com/v1/chat/completions',
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(openaiRequest)
                }
            );

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `OpenAI API error: ${response.status}`);
            }

            const data = await response.json();

            // Convert OpenAI response format to Claude-like format for consistency
            if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                throw new Error('Invalid OpenAI response structure');
            }

            return {
                json: async () => ({
                    content: [{
                        text: data.choices[0].message.content
                    }]
                }),
                ok: true
            };
        }

        // Unified AI API caller - supports multiple providers (Claude, Gemini, OpenAI)
        async function callClaudeAPI(prompt, systemPrompt = '', maxTokens = 1024, useExtendedThinking = false, retryCount = 0) {
            const MAX_RETRIES = 2;
            const provider = getAIProvider();

            // Debug logging for Deep Mode routing
            if (useExtendedThinking) {
                console.log('üîç Deep Mode requested:', { provider, useExtendedThinking, hasLocalKey: !!getLocalAPIKey('anthropic') });
            }

            // If Gemini is selected and user has Gemini key, use Gemini directly
            if (provider === 'gemini') {
                const geminiKey = getLocalAPIKey('gemini');
                if (geminiKey) {
                    console.log('üî∑ Using Google Gemini');
                    try {
                        const response = await callGeminiDirectAPI(prompt, systemPrompt, maxTokens, geminiKey);
                        const data = await response.json();
                        return data.content[0].text;
                    } catch (error) {
                        console.error('‚ùå Gemini API error:', error);
                        throw new Error(`Gemini error: ${error.message}`);
                    }
                } else {
                    // Gemini selected but no key - show helpful error
                    throw new Error('Gemini API key not found. Please add your Gemini API key (üîë button) or switch to Claude.');
                }
            }

            // If OpenAI is selected and user has OpenAI key, use OpenAI directly
            if (provider === 'openai') {
                const openaiKey = getLocalAPIKey('openai');
                if (openaiKey) {
                    console.log('üí¨ Using OpenAI ChatGPT');
                    try {
                        const response = await callOpenAIDirectAPI(prompt, systemPrompt, maxTokens, openaiKey);
                        const data = await response.json();
                        return data.content[0].text;
                    } catch (error) {
                        console.error('‚ùå OpenAI API error:', error);
                        throw new Error(`OpenAI error: ${error.message}`);
                    }
                } else {
                    // OpenAI selected but no key - show helpful error
                    throw new Error('OpenAI API key not found. Please add your OpenAI API key (üîë button) or switch to Claude.');
                }
            }

            // Otherwise, use Claude (existing logic below)
            const localApiKey = getLocalAPIKey('anthropic'); // Get Claude key for Claude logic

            // ENFORCE: Deep Mode requires user API key (consistent with Gemini/ChatGPT)
            if (useExtendedThinking && !localApiKey) {
                throw new Error(`üß† Deep Mode requires your own API key to avoid Netlify's 10-second timeout.\n\n‚úÖ Solutions:\n1. Add your Anthropic API key (üîë button) - enables Deep Mode with Extended Thinking\n2. Switch to ‚ö° Fast Mode - works with server API key\n\nüí° Deep Mode uses Extended Thinking (5000 token reasoning budget) which can take 15-30 seconds - too slow for Netlify's free tier limit.\n\nGemini and ChatGPT also require user API keys for the same reason.`);
            }

            const requestData = {
                model: AI_CONFIG.model,
                max_tokens: maxTokens,
                system: systemPrompt || 'You are an expert project analyst specializing in breaking down complex projects into manageable components.',
                messages: [{
                    role: 'user',
                    content: prompt
                }]
            };

            // Use extended thinking for JSON generation to avoid syntax errors
            if (useExtendedThinking) {
                requestData.thinking = {
                    type: "enabled",
                    budget_tokens: 5000  // Increased from 2000 for Deep Mode (more reasoning time)
                };
            }

            let response;

            // CRITICAL: Deep Mode with user key MUST use direct API (never Netlify)
            // Gemini and ChatGPT always use direct API, Sonnet must too
            if (useExtendedThinking && localApiKey) {
                console.log('üß† Deep Mode: Using direct API (no timeout limit)');
                console.log('‚ö†Ô∏è Bypassing Netlify completely - extended thinking takes 15-30s');
                try {
                    response = await callClaudeDirectAPI(requestData, localApiKey);
                    console.log('‚úÖ Direct API successful (Deep Mode)');
                } catch (directError) {
                    console.error('‚ùå Direct API failed:', directError);

                    // Check if this is a CORS error (running from file://)
                    if (directError.message === 'Failed to fetch' || directError.name === 'TypeError') {
                        throw new Error(`Deep Mode requires direct API access, but browser blocked the request (CORS policy).\n\nüí° Solutions:\n1. Deploy to a web server (Netlify/Vercel) for full Deep Mode support\n2. Use Fast Mode (‚ö°) which works from local files via Netlify proxy\n3. For now: Export tree to JSON and use Claude.ai directly`);
                    }
                    throw directError;
                }
            } else {
                // FAST MODE or no extended thinking: Use Netlify function (has 10s limit but works everywhere)
                console.log(localApiKey ? 'üîë Using Netlify function with your API key' : 'üåê Using Netlify function with server API key');

                const netlifyRequestBody = {
                    ...requestData,
                    // Include local API key if available (Netlify function will use it)
                    userApiKey: localApiKey || undefined
                };

                // Add timeout to prevent hanging on Netlify's 10s function limit
                // Increased to 25s to give Netlify full time (Sonnet can be slow)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 25000); // 25s timeout (Netlify has 10s limit on free tier)

                try {
                    response = await fetch(AI_CONFIG.apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(netlifyRequestBody),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                } catch (fetchError) {
                    clearTimeout(timeoutId);

                    // AUTOMATIC FALLBACK: If timeout AND user has API key, try direct API
                    if (fetchError.name === 'AbortError' && localApiKey) {
                        console.warn('‚ö†Ô∏è Netlify timeout detected. Falling back to direct API (no timeout limit)...');
                        try {
                            response = await callClaudeDirectAPI(requestData, localApiKey);
                            console.log('‚úÖ Direct API fallback successful!');
                        } catch (directError) {
                            console.error('‚ùå Direct API fallback failed:', directError);

                            // Check if this is a CORS error (common when running from file:// or localhost)
                            if (directError.message === 'Failed to fetch' || directError.name === 'TypeError') {
                                throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nDirect API fallback blocked by browser (CORS - you're running from file://).\n\n‚úÖ Solutions:\n1. Run via local server: python -m http.server 8000\n2. Deploy to https://treelisty.netlify.app (no CORS issues)\n3. Use ‚ö° Fast Mode instead (faster, works everywhere)\n\nüí° Sonnet is powerful but slow - works best on deployed sites or with local server.`);
                            }

                            throw new Error(`Netlify timeout AND direct API failed. Error: ${directError.message}`);
                        }
                    } else if (fetchError.name === 'AbortError') {
                        // Timeout but no user API key - can't fallback
                        throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nAdd your API key (üîë button) to bypass Netlify timeout.\n\nOr use ‚ö° Fast Mode (Haiku) - faster and works everywhere.`);
                    } else {
                        throw fetchError;
                    }
                }

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));

                    // Log detailed error info for debugging
                    console.error('‚ùå AI API Error Details:', {
                        status: response.status,
                        statusText: response.statusText,
                        usingLocalKey: !!localApiKey,
                        error: error
                    });

                    // Check for common errors
                    if (response.status === 0 || !response.status) {
                        throw new Error('Cannot connect to AI service. Please check your internet connection.');
                    }
                    if (response.status === 401) {
                        if (localApiKey) {
                            clearLocalAPIKey();
                            throw new Error('Invalid API key. Please check your Anthropic API key and try again.');
                        }
                        throw new Error('Authentication failed. Please configure your API key.');
                    }
                    if (response.status === 404) {
                        throw new Error('Netlify function not found (404). The serverless function may not be deployed.');
                    }
                    if (response.status === 504) {
                        // Gateway timeout from Netlify
                        if (localApiKey) {
                            // Fallback to direct API if user has key
                            console.warn('‚ö†Ô∏è Netlify 504 timeout. Falling back to direct API...');
                            try {
                                response = await callClaudeDirectAPI(requestData, localApiKey);
                                console.log('‚úÖ Direct API fallback successful after 504!');
                                // Exit error handling - response is now successful
                            } catch (directError) {
                                console.error('‚ùå Direct API fallback failed:', directError);

                                // Check if this is a CORS error
                                if (directError.message === 'Failed to fetch' || directError.name === 'TypeError') {
                                    throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nDirect API fallback blocked by browser (CORS - you're running from file://).\n\n‚úÖ Solutions:\n1. Run via local server: python -m http.server 8000\n2. Use deployed site: https://treelisty.netlify.app\n3. Use ‚ö° Fast Mode (Haiku) - faster and works everywhere\n\nüí° Sonnet is powerful but slow - works best on deployed sites or with local server.`);
                                }

                                throw new Error(`Netlify 504 timeout AND direct API failed. Error: ${directError.message}`);
                            }
                        } else {
                            throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nAdd your API key (üîë button) to bypass Netlify timeout.\n\nOr use ‚ö° Fast Mode (Haiku) - faster and works everywhere.`);
                        }
                    }

                    // If response is now ok (after fallback), skip remaining error checks
                    if (response.ok) {
                        // Continue to response parsing below
                    } else if (response.status === 429) {
                        // Rate limit - retry with exponential backoff
                        if (retryCount < MAX_RETRIES) {
                            const delay = Math.pow(2, retryCount) * 3000; // 3s, 6s
                            console.log(`üîÑ Rate limit hit. Retrying in ${delay/1000} seconds... (attempt ${retryCount + 1}/${MAX_RETRIES})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callClaudeAPI(prompt, systemPrompt, maxTokens, useExtendedThinking, retryCount + 1);
                        }
                        throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                    } else if (response.status === 529) {
                        // API overloaded - retry with exponential backoff
                        if (retryCount < MAX_RETRIES) {
                            const delay = Math.pow(2, retryCount) * 2000; // 2s, 4s
                            console.log(`üîÑ API overloaded. Retrying in ${delay/1000} seconds... (attempt ${retryCount + 1}/${MAX_RETRIES})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callClaudeAPI(prompt, systemPrompt, maxTokens, useExtendedThinking, retryCount + 1);
                        }
                        throw new Error('Anthropic API is temporarily overloaded. Please wait 10-30 seconds and try again.');
                    } else if (response.status === 500 && error.error?.message?.includes('configuration')) {
                        throw new Error('AI service is not configured. Please set up your API key.');
                    } else {
                        // Generic error
                        throw new Error(error.error?.message || `AI Service Error: ${response.status}`);
                    }
                }
            } // End of Fast Mode (Netlify) path

            // Common response handling (works for both Deep Mode direct API and Fast Mode Netlify)
            const data = await response.json();
            console.log('‚úÖ AI analysis successful');
            console.log('API Response data:', data);

            // Handle response - check if content exists
            if (!data.content || !Array.isArray(data.content) || data.content.length === 0) {
                console.error('Invalid API response structure:', data);
                throw new Error('Invalid response from AI service');
            }

            return data.content[0].text;
        }

        // Generate intelligent project analysis
        async function generateAIAnalysis(item, analysisType = 'item') {
            // Determine if this is a subtask or regular item/phase
            const isSubtask = item.type === 'subtask';

            let systemPrompt = '';
            let userPrompt = '';

            if (isSubtask) {
                // SUBTASK AI: Help articulate task details, steps for success, and recommendations
                systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;

            } else if (analysisType === 'subtask') {
                // Same as isSubtask - this is a fallback if analysisType is explicitly set to 'subtask'
                systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;

            } else if (analysisType === 'item') {
                // PROJECT ITEM AI: Pattern-aware analysis
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;

                // Pattern-specific system prompts and analysis
                if (pattern.id === 'philosophy') {
                    systemPrompt = `You are a philosophy professor specializing in classical and contemporary philosophical arguments, dialectical reasoning, and philosophical methodology.`;

                    userPrompt = `Analyze this philosophical ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.speaker ? `**Speaker/Philosopher:** ${item.speaker}\n` : ''}${item.argumentType ? `**Argument Type:** ${item.argumentType}\n` : ''}${item.premise1 ? `**Premise 1:** ${item.premise1}\n` : ''}${item.premise2 ? `**Premise 2:** ${item.premise2}\n` : ''}${item.conclusion ? `**Conclusion:** ${item.conclusion}\n` : ''}${item.keyTerms ? `**Key Terms:** ${item.keyTerms}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a philosophical analysis covering:
1. **Logical Validity** - Is the argument structure sound? Are the premises valid?
2. **Dialectical Strength** - How does this argument engage with opposing views?
3. **Conceptual Clarity** - Are key terms well-defined? Any ambiguities?
4. **Objections to Consider** - What counter-arguments should be addressed?
5. **Historical/Textual Context** - Relevant philosophical traditions or sources
6. **Recommendations** - How to strengthen this argument or explore it further`;

                } else if (pattern.id === 'sales') {
                    systemPrompt = `You are a sales strategist with 20 years of enterprise B2B experience, specializing in deal progression, competitive positioning, and revenue forecasting.`;

                    userPrompt = `Analyze this sales ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.dealValue ? `**Deal Value:** $${(item.dealValue || 0).toLocaleString()}\n` : ''}${item.expectedCloseDate ? `**Expected Close:** ${new Date(item.expectedCloseDate).toLocaleDateString()}\n` : ''}${item.leadSource ? `**Lead Source:** ${item.leadSource}\n` : ''}${item.contactPerson ? `**Contact:** ${item.contactPerson}\n` : ''}${item.stageProbability ? `**Close Probability:** ${item.stageProbability}%\n` : ''}${item.competitorInfo ? `**Competitive Intel:** ${item.competitorInfo}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a sales analysis covering:
1. **Deal Health** - Is this deal progressing appropriately for its stage?
2. **Competitive Positioning** - How to differentiate from competitors?
3. **Next Steps** - Specific actions to advance this deal (meetings, demos, proposals)
4. **Risk Factors** - What could derail this opportunity?
5. **Close Strategy** - Recommended approach to accelerate close
6. **Upsell/Cross-sell** - Opportunities to expand deal value`;

                } else if (pattern.id === 'thesis') {
                    systemPrompt = `You are an academic advisor helping graduate students structure rigorous research, with expertise in thesis development, argumentation, and scholarly writing.`;

                    userPrompt = `Analyze this academic ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.wordCount ? `**Current Words:** ${item.wordCount}\n` : ''}${item.targetWordCount ? `**Target Words:** ${item.targetWordCount}\n` : ''}${item.keyCitations ? `**Key Citations:** ${item.keyCitations}\n` : ''}${item.keyArgument ? `**Main Argument:** ${item.keyArgument}\n` : ''}${item.evidenceType ? `**Evidence Type:** ${item.evidenceType}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide an academic analysis covering:
1. **Argument Strength** - Is the thesis argument clear and defensible?
2. **Evidence Quality** - Is the evidence sufficient and appropriate?
3. **Citation Coverage** - Are key sources adequately referenced?
4. **Structural Coherence** - Does this fit logically within the overall thesis?
5. **Scholarly Rigor** - Areas to strengthen academic quality
6. **Recommendations** - Specific next steps for development`;

                } else if (pattern.id === 'roadmap') {
                    systemPrompt = `You are a product manager experienced in agile development, feature prioritization, and engineering execution strategy.`;

                    userPrompt = `Analyze this product ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.storyPoints ? `**Story Points:** ${item.storyPoints}\n` : ''}${item.userImpact ? `**User Impact:** ${item.userImpact}\n` : ''}${item.technicalRisk ? `**Technical Risk:** ${item.technicalRisk}\n` : ''}${item.engineeringEstimate ? `**Engineering Estimate:** ${item.engineeringEstimate}\n` : ''}${item.featureFlag ? `**Feature Flag:** ${item.featureFlag}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a product analysis covering:
1. **User Value** - Does this feature deliver clear user benefit?
2. **Technical Feasibility** - Are the story points and risk assessment realistic?
3. **Prioritization** - Where should this rank given impact vs effort?
4. **Dependencies** - Are upstream features properly identified?
5. **Implementation Strategy** - Recommended approach (MVP, feature flag, phased rollout)
6. **Success Metrics** - How to measure if this feature succeeds`;

                } else if (pattern.id === 'prompting') {
                    systemPrompt = `You are an AI/ML engineer expert in prompt engineering for Claude and GPT-4, specializing in system design, agent workflows, and prompt optimization.`;

                    userPrompt = `Analyze this prompt ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.systemPrompt ? `**System Prompt:** ${item.systemPrompt.substring(0, 200)}${item.systemPrompt.length > 200 ? '...' : ''}\n` : ''}${item.userPromptTemplate ? `**User Template:** ${item.userPromptTemplate.substring(0, 200)}${item.userPromptTemplate.length > 200 ? '...' : ''}\n` : ''}${item.modelTarget ? `**Model:** ${item.modelTarget}\n` : ''}${item.temperature ? `**Temperature:** ${item.temperature}\n` : ''}${item.maxTokens ? `**Max Tokens:** ${item.maxTokens}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a prompt engineering analysis covering:
1. **Prompt Quality** - Is the system/user prompt clear and well-structured?
2. **Best Practices** - OpenAI/Anthropic recommendations being followed?
3. **Few-Shot Examples** - Are examples sufficient and high-quality?
4. **Chain-of-Thought** - Should CoT be added for better reasoning?
5. **Edge Cases** - What failure modes should be addressed?
6. **Optimization** - How to improve accuracy, cost, or latency`;

                } else if (pattern.id === 'book') {
                    systemPrompt = `You are a professional fiction editor and writing coach, specializing in narrative structure, character development, and storytelling craft.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.wordCount ? `**Current Words:** ${item.wordCount}\n` : ''}${item.targetWordCount ? `**Target Words:** ${item.targetWordCount}\n` : ''}${item.plotPoints ? `**Plot Points:** ${item.plotPoints}\n` : ''}${item.characterArcs ? `**Character Arcs:** ${item.characterArcs}\n` : ''}${item.pacing ? `**Pacing:** ${item.pacing}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a narrative analysis covering:
1. **Story Structure** - Does this chapter serve the overall narrative arc?
2. **Character Development** - Are character arcs progressing appropriately?
3. **Pacing** - Is the rhythm and tension appropriate for this section?
4. **Plot Points** - Are key story beats landing effectively?
5. **Scene Craft** - Suggestions for strengthening individual scenes
6. **Recommendations** - Specific revisions to improve this chapter`;

                } else if (pattern.id === 'film') {
                    systemPrompt = `You are a cinematographer and film director specializing in AI video production (Sora, Veo, Runway Gen-3), with expertise in visual storytelling, camera work, and production planning.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.aiPlatform ? `**AI Platform:** ${item.aiPlatform}\n` : ''}${item.videoPrompt ? `**Video Prompt:** ${item.videoPrompt.substring(0, 200)}${item.videoPrompt.length > 200 ? '...' : ''}\n` : ''}${item.visualStyle ? `**Visual Style:** ${item.visualStyle}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.cameraMovement ? `**Camera Movement:** ${item.cameraMovement}\n` : ''}${item.lightingMood ? `**Lighting:** ${item.lightingMood}\n` : ''}${item.motionIntensity ? `**Motion Intensity:** ${item.motionIntensity}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a production analysis covering:
1. **Prompt Quality** - Is the video prompt detailed enough for Sora/Veo?
2. **Visual Cohesion** - Does this scene match the project's visual style?
3. **Camera & Lighting** - Are technical specs appropriate for the mood?
4. **Production Feasibility** - Can current AI platforms deliver this vision?
5. **Sequence Flow** - How does this scene connect to dependencies?
6. **Optimization** - How to improve prompt for better AI generation`;

                } else if (pattern.id === 'course') {
                    systemPrompt = `You are an instructional designer specializing in curriculum development, learning objectives, and educational best practices.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.learningObjectives ? `**Learning Objectives:** ${item.learningObjectives}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.difficultyLevel ? `**Difficulty:** ${item.difficultyLevel}\n` : ''}${item.prerequisites ? `**Prerequisites:** ${item.prerequisites}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a pedagogical analysis covering:
1. **Learning Objectives** - Are objectives clear, measurable, and achievable?
2. **Content Structure** - Is the lesson logically organized for learning?
3. **Difficulty Progression** - Is this appropriately paced within the course?
4. **Engagement** - Are activities and assessments well-designed?
5. **Prerequisites** - Are dependencies and prior knowledge appropriate?
6. **Recommendations** - How to improve learning outcomes`;

                } else if (pattern.id === 'fitness') {
                    systemPrompt = `You are a certified personal trainer and exercise physiologist with expertise in program design, exercise science, progressive overload, and injury prevention.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.targetMuscleGroups ? `**Target Muscles:** ${item.targetMuscleGroups}\n` : ''}${item.sets ? `**Sets:** ${item.sets}\n` : ''}${item.reps ? `**Reps:** ${item.reps}\n` : ''}${item.restTime ? `**Rest:** ${item.restTime}\n` : ''}${item.intensity ? `**Intensity:** ${item.intensity}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a fitness analysis covering:
1. **Exercise Selection** - Are exercises appropriate for the training goal?
2. **Volume & Intensity** - Are sets, reps, and intensity optimized for progression?
3. **Progressive Overload** - Is the program structured for strength/endurance gains?
4. **Injury Prevention** - Are there any form cues or mobility prerequisites needed?
5. **Recovery** - Is rest time and workout spacing appropriate?
6. **Recommendations** - How to optimize this workout for better results`;

                } else if (pattern.id === 'event') {
                    systemPrompt = `You are a professional event planner with experience in corporate events, weddings, and large-scale conferences, specializing in logistics, vendor coordination, and timeline management.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.venue ? `**Venue:** ${item.venue}\n` : ''}${item.attendeeCount ? `**Attendees:** ${item.attendeeCount}\n` : ''}${item.startTime ? `**Start Time:** ${item.startTime}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.vendor ? `**Vendor:** ${item.vendor}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide an event planning analysis covering:
1. **Timeline Feasibility** - Is the activity appropriately scheduled and paced?
2. **Logistics** - Are venue, equipment, and vendor requirements clear?
3. **Guest Experience** - How does this contribute to attendee satisfaction?
4. **Dependencies** - Are setup/breakdown and sequential activities properly coordinated?
5. **Contingency Planning** - What backup plans are needed for this activity?
6. **Recommendations** - How to improve execution and guest experience`;

                } else if (pattern.id === 'strategy') {
                    systemPrompt = `You are a business strategy consultant specializing in strategic planning, KPI development, organizational transformation, and competitive positioning.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.kpi ? `**KPI:** ${item.kpi}\n` : ''}${item.targetValue ? `**Target:** ${item.targetValue}\n` : ''}${item.currentValue ? `**Current:** ${item.currentValue}\n` : ''}${item.owner ? `**Owner:** ${item.owner}\n` : ''}${item.timeframe ? `**Timeframe:** ${item.timeframe}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a strategic analysis covering:
1. **Strategic Alignment** - Does this initiative support the overall strategic pillar?
2. **KPI Quality** - Are metrics measurable, achievable, and meaningful?
3. **Resource Requirements** - What capabilities or investments are needed?
4. **Dependencies** - Are prerequisite initiatives or decisions identified?
5. **Risk Assessment** - What could prevent success and how to mitigate?
6. **Recommendations** - How to maximize strategic impact`;

                } else if (pattern.id === 'familytree') {
                    systemPrompt = `You are a professional genealogist and family historian specializing in genealogical research, family tree documentation, and historical record analysis.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.birthDate ? `**Birth:** ${item.birthDate}\n` : ''}${item.deathDate ? `**Death:** ${item.deathDate}\n` : ''}${item.birthPlace ? `**Birth Place:** ${item.birthPlace}\n` : ''}${item.occupation ? `**Occupation:** ${item.occupation}\n` : ''}${item.spouse ? `**Spouse:** ${item.spouse}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a genealogical analysis covering:
1. **Record Completeness** - Are key vital records (birth, death, marriage) documented?
2. **Source Quality** - Are sources reliable and properly cited?
3. **Relationship Verification** - Are family connections well-supported by evidence?
4. **Research Gaps** - What additional records or information should be sought?
5. **Conflicting Data** - Are there any inconsistencies to resolve?
6. **Recommendations** - Next steps for strengthening this family branch documentation`;

                } else if (pattern.id === 'dialogue') {
                    systemPrompt = `You are a rhetoric and argumentation expert specializing in debate analysis, logical fallacies, persuasive communication, and interpersonal psychology. Your expertise includes classical rhetoric (Aristotle, Cicero), modern argumentation theory, and political theater analysis.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Speaker:** ${item.speaker || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.verbatimQuote ? `**Verbatim Quote:** "${item.verbatimQuote}"\n` : ''}${item.rhetoricalDevice ? `**Rhetorical Device:** ${item.rhetoricalDevice}\n` : ''}${item.logicalStructure ? `**Logical Structure:** ${item.logicalStructure}\n` : ''}${item.fallaciesPresent ? `**Fallacies Identified:** ${item.fallaciesPresent}\n` : ''}${item.hiddenMotivation ? `**Hidden Motivation:** ${item.hiddenMotivation}\n` : ''}${item.emotionalTone ? `**Emotional Tone:** ${item.emotionalTone}\n` : ''}${item.evidenceQuality ? `**Evidence Quality:** ${item.evidenceQuality}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a rhetorical analysis covering:
1. **Argument Strength** - Evaluate the logical validity and persuasive power of this statement
2. **Rhetorical Techniques** - What persuasive devices are employed? How effective are they?
3. **Logical Fallacies** - Identify any fallacies (ad hominem, straw man, false dichotomy, etc.) and their impact
4. **Hidden Motivations** - What unstated goals or biases might be driving this argument?
5. **Counterargument Strategy** - What would be the most effective rebuttal or opposing position?
6. **Evidence Assessment** - How strong is the supporting evidence? What's missing?
7. **Recommendations** - How could this argument be strengthened or how should an opponent respond?`;

                } else if (pattern.id === 'filesystem') {
                    systemPrompt = `You are "LibrarianAI" for TreeListy.

Your job is to manage and enrich a **single filesystem** (one TreeListy tree) without ever directly deleting or renaming anything. You operate only by updating node metadata and proposing non-destructive actions.

Given a list of nodes (files and folders) with:
- node_id, path, is_folder
- basic metadata (size, timestamps, mime/type hints)
- existing AI fields (if any)

Do the following for **this filesystem only**:

1. **Enrich metadata for each node**
   - Infer and/or update:
     - summary_short: 1‚Äì2 line human-readable description.
     - tags: topical keywords.
     - project_guess: likely project or collection name (string).
     - status: one of draft | working | final | archive_candidate.
     - sensitivity_level: low | medium | high (e.g. legal/financial/personal = high).
     - lifecycle_stage: active | stale | historical | junk_candidate.
     - ai_confidence: 0‚Äì1 float for your overall judgment.
   - Never invent impossible details; base everything on filenames, paths, and any provided content/metadata.

2. **Detect redundancy and clusters**
   - Group near-duplicate or strongly related files into clusters.
   - For each node, set:
     - cluster_id: stable ID shared by similar files, or null.
     - canonical_id: the node_id of the best representative in that cluster, or equal to its own node_id if it is canonical.
   - Prefer canonical files that are more recent, more complete, and more likely to be in the correct folder.

3. **Assess data quality**
   - For each node, compute:
     - data_quality_score: 0‚Äì100, based on naming clarity, location, redundancy, and completeness.
   - Higher scores = clearer, better placed, non-redundant, and likely still useful.

4. **Propose safe actions only**
   - Do **not** delete, rename, or move anything directly.
   - Instead, populate an ai_actions_pending list per node with suggested operations, for example:
     - {"action": "move", "target_folder": "...", "reason": "...", "confidence": 0.82}
     - {"action": "archive", "reason": "...", "confidence": 0.76}
   - Be conservative: when in doubt, lower confidence and prefer suggestion over aggressive cleanup.

Act as a cautious, explainable librarian: improve structure and clarity, reduce redundancy, and surface suggestions, but never take irreversible or destructive actions yourself.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'File'}
**Path:** ${item.filePath || 'N/A'}
${item.isFolder ? `**Is Folder:** Yes\n` : ''}${item.fileSize ? `**Size:** ${(item.fileSize / 1024).toFixed(1)} KB\n` : ''}${item.fileExtension ? `**Extension:** ${item.fileExtension}\n` : ''}${item.dateModified ? `**Modified:** ${new Date(item.dateModified).toLocaleDateString()}\n` : ''}${item.dateCreated ? `**Created:** ${new Date(item.dateCreated).toLocaleDateString()}\n` : ''}${item.fileOwner ? `**Owner:** ${item.fileOwner}\n` : ''}${item.mimeType ? `**MIME Type:** ${item.mimeType}\n` : ''}**Description:** ${item.description || 'None'}
**Notes:** ${item.notes || 'None'}

Provide a LibrarianAI analysis covering:
1. **Metadata Enrichment** - Suggest summary_short, tags, project_guess, status, sensitivity_level, lifecycle_stage, ai_confidence
2. **Redundancy Detection** - Is this part of a cluster? Suggest cluster_id and canonical_id if similar files exist
3. **Data Quality Score** - Rate 0-100 based on naming clarity, location appropriateness, redundancy, and usefulness
4. **Proposed Actions** - Suggest safe, non-destructive actions (move, archive, tag) with confidence scores
5. **Organization Insights** - How does this fit within the overall filesystem structure?
6. **Recommendations** - Conservative suggestions to improve organization without destructive changes`;

                } else {
                    // Generic/default pattern - PM and CFO perspective
                    systemPrompt = `You are an experienced Project Manager and CFO with deep expertise in budget management, resource allocation, risk mitigation, and financial planning for complex projects. Provide strategic insights on cost optimization, timeline management, and delivery excellence.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${pattern.fields?.cost ? `**Cost:** $${(item.cost || 0).toLocaleString()}\n` : ''}${pattern.fields?.leadTime ? `**Lead Time:** ${item.leadTime || 'Not specified'}\n` : ''}${pattern.fields?.alternateSource ? `**Alternate Source:** ${item.alternateSource || 'Not specified'}\n` : ''}${item.pmRAGStatus ? `**RAG Status:** ${item.pmRAGStatus}\n` : ''}${item.pmOwnerEmail ? `**Owner:** ${item.pmOwnerEmail}\n` : ''}${item.pmEstimatedHours ? `**Estimated Hours:** ${item.pmEstimatedHours}h\n` : ''}${item.pmActualHours ? `**Actual Hours:** ${item.pmActualHours}h\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None provided'}

From a PM and CFO perspective, provide analysis covering:
1. **Financial Health** - Budget status, cost drivers, burn rate concerns, ROI considerations
2. **Risk Assessment** - Financial risks, schedule risks, resource constraints, mitigation strategies
3. **Time & Resource Management** - Timeline realism, resource allocation efficiency, critical path impacts
4. **Vendor & Procurement** - Supplier reliability, alternate source evaluation, contract considerations
5. **Stakeholder & Governance** - Approval gates, change management, reporting requirements
6. **Strategic Recommendations** - 2-3 actionable steps to improve delivery, reduce cost, or mitigate risk`;
                }

            } else if (analysisType === 'project') {
                // Project-level analysis (PATTERN-AWARE)
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;
                const allItems = getAllProjectItems();

                // Build phase breakdown
                const phaseBreakdown = capexTree.children?.map((phase, idx) => {
                    const phaseItems = allItems.filter(i => i.id?.startsWith(`p${idx}`));
                    let phaseLine = `- ${phase.name}`;

                    if (phase.subtitle) phaseLine += ` (${phase.subtitle})`;
                    phaseLine += `: ${phaseItems.length} ${levels.item.toLowerCase()}s`;

                    if (pattern.fields?.cost) {
                        const phaseTotal = phaseItems.reduce((sum, i) => sum + (i.cost || 0), 0);
                        phaseLine += `, $${phaseTotal.toLocaleString()}`;
                    }

                    return phaseLine;
                }).join('\n') || 'No phases defined';

                // Pattern-specific prompts
                if (pattern.id === 'book-writing') {
                    systemPrompt = `You are a literary consultant specializing in narrative structure and book development. Provide insights on story structure, pacing, character development, and writing best practices.`;

                    userPrompt = `Analyze this book writing project:

**Title:** ${capexTree.name}
**Pattern:** Book Writing

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Story Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} builds on ${i.dependencies.length} previous element(s)`
).join('\n')}

` : ''}Provide an executive summary for this book project covering:
1. **Narrative Structure Assessment** - Is the part/chapter breakdown balanced and logical?
2. **Story Flow** - Comment on pacing and progression based on dependencies
3. **Development Recommendations** - Suggestions for strengthening the narrative structure
4. **Potential Issues** - Any structural concerns or gaps in the story arc
5. **Next Steps** - Actionable recommendations for the author

Focus on narrative structure and storytelling best practices.`;

                } else if (pattern.id === 'ai-prompt-design') {
                    systemPrompt = `You are a prompt engineering expert specializing in LLM workflows, agent design, and AI system architecture. Provide insights on prompt structure, agent orchestration, and best practices.`;

                    userPrompt = `Analyze this AI prompt design project:

**Prompt Workbook:** ${capexTree.name}
**Pattern:** AI Prompt Design

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Agent Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} requires ${i.dependencies.length} upstream component(s)`
).join('\n')}

` : ''}Provide an executive summary for this prompt engineering project covering:
1. **Architecture Assessment** - Is the stage/module breakdown logical for an AI workflow?
2. **Agent Orchestration** - Comment on dependencies and data flow between modules
3. **Prompt Engineering Best Practices** - Recommendations for improving prompt quality
4. **Potential Issues** - Any architectural concerns or missing components
5. **Next Steps** - Actionable recommendations for the prompt engineer

Focus on prompt engineering and agent design best practices.`;

                } else if (pattern.fields?.cost) {
                    // Financial patterns (generic, sales, roadmap, etc.)
                    systemPrompt = `You are a senior project analyst specializing in project planning, budgeting, and execution strategy. Provide insights on project structure, resource allocation, and execution best practices.`;

                    const totalCost = calculateTotal(capexTree);

                    userPrompt = `Analyze this ${pattern.name.toLowerCase()} project:

**Project:** ${capexTree.name}
**Pattern:** ${pattern.name}
**Total Budget:** $${totalCost.toLocaleString()}

**${levels.phase} Breakdown:**
${phaseBreakdown}

${allItems.filter(i => i.cost > 1000000).length > 0 ? `**Major Line Items (>$1M):**
${allItems.filter(i => i.cost > 1000000).map(i =>
    `- ${i.name}: $${i.cost.toLocaleString()}${i.itemType ? ` (${i.itemType})` : ''}`
).join('\n')}

` : ''}${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Key Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} depends on ${i.dependencies.length} item(s)`
).join('\n')}

` : ''}Provide an executive-level analysis covering:
1. **Budget Assessment** - Is the allocation realistic for this type of project?
2. **Critical Path** - Key dependencies and timeline bottlenecks
3. **Risk Factors** - Top 3 risks to budget or timeline
4. **Optimization Opportunities** - Potential cost savings or efficiency gains
5. **Strategic Recommendations** - High-level guidance for stakeholders

Format for presentation to executives. Be concise but comprehensive.`;

                } else {
                    // Non-financial patterns (philosophy, thesis, etc.)
                    systemPrompt = `You are an expert consultant specializing in structured thinking and project organization. Provide insights on project structure, logical flow, and development best practices.`;

                    userPrompt = `Analyze this ${pattern.name.toLowerCase()} project:

**Project:** ${capexTree.name}
**Pattern:** ${pattern.name}

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Logical Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} builds on ${i.dependencies.length} previous element(s)`
).join('\n')}

` : ''}Provide an executive summary covering:
1. **Structure Assessment** - Is the ${levels.phase.toLowerCase()}/${levels.item.toLowerCase()} breakdown logical and well-organized?
2. **Logical Flow** - Comment on progression and dependencies between elements
3. **Development Recommendations** - Suggestions for strengthening the structure
4. **Potential Issues** - Any structural concerns or gaps in coverage
5. **Next Steps** - Actionable recommendations for the author/creator

Focus on logical structure and content organization best practices.`;
                }
            }

            return await callClaudeAPI(userPrompt, systemPrompt);
        }

        // Helper to get all items from tree
        function getAllProjectItems(node = capexTree, items = []) {
            if (node.items) items.push(...node.items);
            if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
            return items;
        }

        // =============================================================================
        // END AI INTEGRATION
        // =============================================================================

        // Data - Phases flow chronologically left to right
        let capexTree = {
            id: 'root',
            name: 'My Project',
            type: 'root',
            icon: 'üå≥',
            expanded: true,
            children: [
                {
                    id: 'phase-0',
                    name: 'Phase 0',
                    subtitle: 'Pre-Seed',
                    type: 'phase',
                    phase: '0',
                    icon: 'üå±',
                    expanded: true,
                    items: [
                        {
                            id: 'p0-1762125598237',
                            name: 'New Item',
                            description: 'Enter description',
                            cost: 0,
                            icon: 'üì¶',
                            itemType: 'equipment',
                            type: 'item',
                            dependencies: [],
                            subItems: [
                                {
                                    id: 'p0-1762125598237-sub-1762453827798',
                                    name: 'Task 1',
                                    description: 'Task description',
                                    cost: 0,
                                    icon: 'üìã',
                                    itemType: 'subtask',
                                    type: 'subtask',
                                    dependencies: [],
                                    parentId: 'p0-1762125598237',
                                    pmStatus: 'To Do',
                                    pmAssignee: 'Unassigned',
                                    pmStartDate: '2025-11-06',
                                    pmDueDate: '2025-11-06',
                                    pmProgress: 0,
                                    pmPriority: 'Medium',
                                    pmNotes: '',
                                    pmBlockingIssue: '',
                                    pmNextSteps: '',
                                    pmUpdates: [],
                                    subItems: []
                                },
                                {
                                    id: 'p0-1762125598237-sub-1762453836667',
                                    name: 'Task 2',
                                    description: 'Task description',
                                    cost: 0,
                                    icon: 'üìã',
                                    itemType: 'subtask',
                                    type: 'subtask',
                                    dependencies: [],
                                    parentId: 'p0-1762125598237',
                                    pmStatus: 'To Do',
                                    pmAssignee: 'Unassigned',
                                    pmStartDate: '2025-11-06',
                                    pmDueDate: '2025-11-06',
                                    pmProgress: 0,
                                    pmPriority: 'Medium',
                                    pmNotes: '',
                                    pmBlockingIssue: '',
                                    pmNextSteps: '',
                                    pmUpdates: [],
                                    subItems: []
                                }
                            ],
                            expanded: true
                        }
                    ],
                    children: [
                        {
                            id: 'phase-1',
                            name: 'Phase 1',
                            subtitle: 'Seed',
                            type: 'phase',
                            phase: '1',
                            icon: 'üöÄ',
                            expanded: true,
                            items: [
                                {
                                    id: 'p1-1762125603889',
                                    name: 'New Item',
                                    description: 'Enter description',
                                    cost: 0,
                                    icon: 'üì¶',
                                    itemType: 'equipment',
                                    type: 'item',
                                    dependencies: ['p0-1762125598237'],
                                    subItems: [
                                        {
                                            id: 'p1-1762125603889-sub-1762453866145',
                                            name: 'Task 1',
                                            description: 'Task description',
                                            cost: 0,
                                            icon: 'üìã',
                                            itemType: 'subtask',
                                            type: 'subtask',
                                            dependencies: [],
                                            parentId: 'p1-1762125603889',
                                            pmStatus: 'To Do',
                                            pmAssignee: 'Unassigned',
                                            pmStartDate: '2025-11-06',
                                            pmDueDate: '2025-11-06',
                                            pmProgress: 0,
                                            pmPriority: 'Medium',
                                            pmNotes: '',
                                            pmBlockingIssue: '',
                                            pmNextSteps: '',
                                            pmUpdates: [],
                                            subItems: []
                                        }
                                    ],
                                    expanded: true,
                                    alternateSource: '',
                                    leadTime: '',
                                    notes: ''
                                }
                            ],
                            children: [
                                {
                                    id: 'phase-2',
                                    name: 'Phase 2',
                                    subtitle: 'Build',
                                    type: 'phase',
                                    phase: '2',
                                    icon: 'üè≠',
                                    expanded: true,
                                    items: [
                                        {
                                            id: 'p2-1762125606965',
                                            name: 'New Item',
                                            description: 'Enter description',
                                            cost: 0,
                                            icon: 'üì¶',
                                            itemType: 'equipment',
                                            type: 'item',
                                            dependencies: [],
                                            subItems: [
                                                {
                                                    id: 'p2-1762125606965-sub-1762453851549',
                                                    name: 'Task 1',
                                                    description: 'Task description',
                                                    cost: 0,
                                                    icon: 'üìã',
                                                    itemType: 'subtask',
                                                    type: 'subtask',
                                                    dependencies: [],
                                                    parentId: 'p2-1762125606965',
                                                    pmStatus: 'To Do',
                                                    pmAssignee: 'Unassigned',
                                                    pmStartDate: '2025-11-06',
                                                    pmDueDate: '2025-11-06',
                                                    pmProgress: 0,
                                                    pmPriority: 'Medium',
                                                    pmNotes: '',
                                                    pmBlockingIssue: '',
                                                    pmNextSteps: '',
                                                    pmUpdates: [],
                                                    subItems: []
                                                }
                                            ],
                                            expanded: true
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        };

        // =====================================================================
        // CANVAS VIEW INTEGRATION
        // =====================================================================

        let viewMode = 'tree';
        let canvasNodes = [];
        let canvasPan = { x: 0, y: 0 };
        let canvasZoom = 1;
        let isPanningCanvas = false;
        let isDraggingCanvasNode = false;
        let draggedCanvasNode = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let panStartX = 0;
        let panStartY = 0;
        let maxExpandedDepth = Infinity;  // Track how deep we're currently showing
        let gridEnabled = false;
        const gridSize = 40;  // Grid snap size
        let clusterByField = '';  // Track which metadata field to cluster by (itemType, owner, etc.)

        // Multi-selection state
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionEnd = { x: 0, y: 0 };
        let selectedNodes = [];
        let isDraggingSelection = false;
        let selectionDragStart = { x: 0, y: 0 };

        function toggleViewMode() {
            viewMode = viewMode === 'tree' ? 'canvas' : 'tree';

            if (viewMode === 'canvas') {
                console.log('üé® Switching to Canvas View');
                document.getElementById('view-mode-icon').textContent = 'üìä';
                document.getElementById('view-mode-text').textContent = 'Tree View';
                document.querySelector('.tree-view-container').classList.add('hidden');
                document.getElementById('canvas-container').classList.add('active');

                const toolbar = document.getElementById('canvas-toolbar');
                if (toolbar) {
                    toolbar.classList.add('active');
                    console.log('‚úÖ Canvas toolbar activated');
                } else {
                    console.error('‚ùå Canvas toolbar not found!');
                }

                // Migrate coordinates if needed
                const firstPhase = capexTree.children[0];
                const firstItem = firstPhase?.items?.[0] || firstPhase?.children?.[0];
                if (!firstItem?.canvasX) {
                    migrateToCanvasCoordinates();
                } else {
                    // Even if coordinates exist, ensure expanded state is initialized
                    capexTree.children.forEach(phase => {
                        const nodeList = phase.items || phase.children || [];
                        nodeList.forEach(item => {
                            initializeExpandedState(item);
                        });
                    });
                }

                // Initialize arrow markers first time
                initializeArrowMarkers();

                renderCanvas();
                updateZoomDisplay();
                console.log('‚úÖ Canvas View ready');
            } else {
                console.log('üìä Switching to Tree View');
                document.getElementById('view-mode-icon').textContent = 'üé®';
                document.getElementById('view-mode-text').textContent = 'Canvas View';
                document.querySelector('.tree-view-container').classList.remove('hidden');
                document.getElementById('canvas-container').classList.remove('active');

                const toolbar = document.getElementById('canvas-toolbar');
                if (toolbar) {
                    toolbar.classList.remove('active');
                }

                render();
                console.log('‚úÖ Tree View ready');
            }
        }

        function migrateToCanvasCoordinates() {
            let xOffset = 200;
            const ySpacing = 180;

            capexTree.children.forEach((phase, phaseIdx) => {
                let yOffset = 100;
                // Support both 'items' (standard) and 'children' (filesystem pattern)
                const nodeList = phase.items || phase.children || [];
                nodeList.forEach((item) => {
                    item.canvasX = xOffset + 50;
                    item.canvasY = yOffset;
                    yOffset += ySpacing;

                    // Ensure all items with subItems have expanded state initialized
                    initializeExpandedState(item);
                });
                xOffset += 400;
            });
        }

        // Clear all canvas coordinates recursively to force re-positioning
        function clearCanvasCoordinates(node) {
            delete node.canvasX;
            delete node.canvasY;

            // Recursively clear for all child types
            const childList = node.items || node.children || node.subItems || [];
            childList.forEach(child => clearCanvasCoordinates(child));
        }

        // Recursively initialize expanded state for all items with children
        function initializeExpandedState(item) {
            // Support both 'subItems' (standard) and 'children' (filesystem pattern)
            const childList = item.subItems || item.children || [];
            if (childList.length > 0) {
                // Default to expanded if not explicitly set
                if (item.expanded === undefined) {
                    item.expanded = true;
                    console.log('Initializing expanded=true for:', item.name);
                }

                // Recursively initialize for all descendants
                childList.forEach(child => {
                    initializeExpandedState(child);
                });
            }
        }

        function renderCanvas() {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('canvas-connections');

            // Clear existing content
            canvas.querySelectorAll('.canvas-node').forEach(n => n.remove());
            svg.innerHTML = '';
            canvasNodes = [];

            // Render all nodes recursively
            capexTree.children.forEach((phase, phaseIdx) => {
                // Support both 'items' (standard) and 'children' (filesystem pattern)
                const nodeList = phase.items || phase.children || [];
                nodeList.forEach((item, itemIdx) => {
                    // Preserve existing positions for root items to prevent jumping
                    // Only set initial position if not already set
                    if (!item.canvasX || !item.canvasY) {
                        item.canvasX = item.canvasX || 50;
                        item.canvasY = item.canvasY || (50 + itemIdx * 180);
                    }
                    renderNodeAndDescendants(item, phase, null, 0);
                });
            });

            // Draw connection lines after all nodes are positioned
            drawConnections();
            updateCanvasTransform();
        }

        // Recursive function to render a node and all its descendants
        function renderNodeAndDescendants(node, phase, parentNode, nestingLevel) {
            // Check if parent is collapsed - if so, don't render this node
            if (parentNode && parentNode.expanded === false) {
                return;  // Parent is collapsed, skip this node
            }

            // Render this node with hierarchical depth
            renderCanvasNode(node, phase, parentNode, nestingLevel);

            // Recursively render all descendants only if this node is expanded (or has no explicit state)
            // Support both 'subItems' (standard) and 'children' (filesystem pattern)
            const childList = node.subItems || node.children || [];
            if (childList.length > 0) {
                // Default to expanded if not set
                if (node.expanded === undefined) {
                    node.expanded = true;
                }

                childList.forEach((child, childIdx) => {
                    // Auto-position children based on nesting level
                    if (!child.canvasX) {
                        // Each nesting level moves further right
                        child.canvasX = (node.canvasX || 0) + 350;
                        child.canvasY = (node.canvasY || 0) + (childIdx * 120);
                    }

                    // Recursively render this child and its descendants
                    renderNodeAndDescendants(child, phase, node, nestingLevel + 1);
                });
            }
        }

        function drawConnections() {
            // Skip drawing connections for filesystem pattern (uses indent-based hierarchy)
            if (currentPattern === 'filesystem') {
                return;
            }

            const svg = document.getElementById('canvas-connections');
            svg.innerHTML = '';

            // Recursively draw connections for all nodes
            capexTree.children.forEach(phase => {
                phase.items?.forEach(item => {
                    drawNodeConnections(item);
                });
            });
        }

        // Recursive function to draw connections for a node and its descendants
        function drawNodeConnections(node) {
            // Only draw connections if this node is expanded (showing children)
            if (node.expanded !== false && node.subItems && node.subItems.length > 0) {
                node.subItems.forEach(subtask => {
                    // Only draw line if subtask is actually visible
                    if (isNodeVisible(subtask.id)) {
                        drawConnection(
                            node.canvasX + 160, node.canvasY + 60,      // From parent center-right
                            subtask.canvasX, subtask.canvasY + 60,      // To subtask center-left
                            'rgba(99, 102, 241, 0.5)',                  // Purple for parent-child
                            'solid'
                        );
                    }

                    // Recursively draw connections for this subtask's descendants
                    drawNodeConnections(subtask);
                });
            }

            // Draw lines for dependencies only if both nodes are visible
            if (node.dependencies && node.dependencies.length > 0) {
                node.dependencies.forEach(depId => {
                    const depNode = canvasNodes.find(n => n.data.id === depId);
                    if (depNode && depNode.data) {
                        // Only draw if both the dependency and this node are visible
                        if (isNodeVisible(depId) && isNodeVisible(node.id)) {
                            drawConnection(
                                depNode.data.canvasX + 160, depNode.data.canvasY + 60,  // From dependency
                                node.canvasX, node.canvasY + 60,                        // To dependent item
                                'rgba(239, 68, 68, 0.4)',                               // Red for dependencies
                                'dashed'
                            );
                        }
                    }
                });
            }
        }

        function drawConnection(x1, y1, x2, y2, color, style = 'solid') {
            const svg = document.getElementById('canvas-connections');

            // Create curved path (Bezier curve)
            const midX = (x1 + x2) / 2;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

            // Curved line from x1,y1 to x2,y2
            const d = `M ${x1} ${y1} Q ${midX} ${y1}, ${midX} ${(y1 + y2) / 2} T ${x2} ${y2}`;

            path.setAttribute('d', d);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            if (style === 'dashed') {
                path.setAttribute('stroke-dasharray', '5,5');
            }

            // Add arrow marker
            path.setAttribute('marker-end', 'url(#arrowhead-' + style + ')');

            svg.appendChild(path);
        }

        // Initialize arrow markers for SVG
        function initializeArrowMarkers() {
            const svg = document.getElementById('canvas-connections');

            // Define arrow markers
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Solid arrow (for parent-child)
            const solidMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            solidMarker.setAttribute('id', 'arrowhead-solid');
            solidMarker.setAttribute('markerWidth', '10');
            solidMarker.setAttribute('markerHeight', '10');
            solidMarker.setAttribute('refX', '9');
            solidMarker.setAttribute('refY', '3');
            solidMarker.setAttribute('orient', 'auto');
            const solidPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            solidPath.setAttribute('points', '0 0, 10 3, 0 6');
            solidPath.setAttribute('fill', 'rgba(99, 102, 241, 0.5)');
            solidMarker.appendChild(solidPath);

            // Dashed arrow (for dependencies)
            const dashedMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            dashedMarker.setAttribute('id', 'arrowhead-dashed');
            dashedMarker.setAttribute('markerWidth', '10');
            dashedMarker.setAttribute('markerHeight', '10');
            dashedMarker.setAttribute('refX', '9');
            dashedMarker.setAttribute('refY', '3');
            dashedMarker.setAttribute('orient', 'auto');
            const dashedPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            dashedPath.setAttribute('points', '0 0, 10 3, 0 6');
            dashedPath.setAttribute('fill', 'rgba(239, 68, 68, 0.4)');
            dashedMarker.appendChild(dashedPath);

            defs.appendChild(solidMarker);
            defs.appendChild(dashedMarker);
            svg.appendChild(defs);
        }

        function showCanvasContextMenu(x, y, item) {
            console.log('Showing canvas context menu for:', item.name);

            // Remove any existing context menu
            const existing = document.getElementById('canvas-context-menu');
            if (existing) existing.remove();

            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'canvas-context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                background: var(--card-bg);
                border: 2px solid var(--border);
                border-radius: 8px;
                padding: 8px;
                z-index: 10000;
                box-shadow: 0 8px 24px rgba(0,0,0,0.6);
                min-width: 200px;
            `;

            const menuItems = [
                { label: '‚úèÔ∏è Edit Details', action: () => {
                    console.log('Edit Details clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's native handleEdit function
                    if (typeof handleEdit === 'function') {
                        console.log('Calling TreeListy handleEdit function');
                        handleEdit();
                    } else {
                        console.error('handleEdit function not found!');
                    }
                }},
                { label: '‚ûï Add Subtask', action: () => {
                    console.log('Add Subtask clicked for:', item.name);
                    activeNode = item;

                    if (!item.subItems) item.subItems = [];
                    const newSubtask = {
                        id: 'subtask-' + Date.now(),
                        name: 'New Subtask',
                        type: 'subtask',
                        description: '',
                        pmStatus: 'To Do',
                        pmProgress: 0,
                        pmRAGStatus: 'Amber',
                        pmPriority: 'Medium',
                        icon: 'üìã',
                        itemType: 'Feature'  // Add itemType to match pattern
                    };
                    item.subItems.push(newSubtask);

                    // Set the new subtask as active and open edit
                    activeNode = newSubtask;

                    // Save state for undo before opening edit
                    if (typeof saveState === 'function') {
                        saveState('Add subtask');
                    }

                    if (typeof handleEdit === 'function') {
                        console.log('Opening edit for new subtask');
                        handleEdit();

                        // Re-render canvas AFTER modal closes (when user saves)
                        // Listen for modal close event
                        const modal = document.getElementById('edit-modal');
                        const renderOnClose = () => {
                            if (modal.style.display === 'none') {
                                console.log('Edit modal closed, re-rendering canvas');
                                renderCanvas();
                                modal.removeEventListener('DOMSubtreeModified', renderOnClose);
                            }
                        };

                        // Watch for modal close
                        setTimeout(() => {
                            const observer = new MutationObserver((mutations) => {
                                mutations.forEach((mutation) => {
                                    if (mutation.attributeName === 'style') {
                                        if (modal.style.display === 'none') {
                                            console.log('Edit modal closed, re-rendering canvas');
                                            renderCanvas();
                                            observer.disconnect();
                                        }
                                    }
                                });
                            });
                            observer.observe(modal, { attributes: true });
                        }, 100);
                    }
                }},
                { label: 'üí° Smart Suggest', action: () => {
                    activeNode = item;
                    alert('Smart Suggest: Use the Edit dialog to access AI-powered field suggestions');
                }},
                { label: 'ü§ñ AI Analysis', action: () => {
                    activeNode = item;
                    alert('AI Analysis: This feature analyzes the item with AI. Access via Edit dialog AI buttons.');
                }},
                { label: 'üìä Show Info Panel', action: () => {
                    console.log('Show Info Panel clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's showInfo function
                    if (typeof showInfo === 'function') {
                        console.log('Calling TreeListy showInfo function');
                        showInfo(item);
                    } else {
                        console.error('showInfo function not found!');
                    }
                }},
                { label: 'üóëÔ∏è Delete Item', action: () => {
                    console.log('Delete clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's native handleDelete function
                    if (typeof handleDelete === 'function') {
                        console.log('Calling TreeListy handleDelete function');
                        handleDelete();
                        // Re-render canvas after deletion
                        renderCanvas();
                    } else {
                        console.error('handleDelete function not found!');
                    }
                }}
            ];

            menuItems.forEach(menuItem => {
                const btn = document.createElement('button');
                btn.textContent = menuItem.label;
                btn.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 10px 12px;
                    background: transparent;
                    border: none;
                    color: var(--text-primary);
                    text-align: left;
                    cursor: pointer;
                    border-radius: 4px;
                    font-size: 14px;
                    margin-bottom: 4px;
                `;
                btn.onmouseover = () => btn.style.background = 'var(--treeplex-primary)';
                btn.onmouseout = () => btn.style.background = 'transparent';
                btn.onclick = (e) => {
                    console.log('Context menu button clicked:', menuItem.label);
                    e.preventDefault();
                    e.stopPropagation();

                    // Execute action first
                    try {
                        menuItem.action();
                    } catch (error) {
                        console.error('Error executing menu action:', error);
                    }

                    // Remove menu after a tiny delay to ensure action completes
                    setTimeout(() => menu.remove(), 10);
                };
                menu.appendChild(btn);
            });

            document.body.appendChild(menu);

            // Close menu on click outside
            setTimeout(() => {
                const closeMenu = (e) => {
                    // Don't close if clicking inside the menu
                    if (menu.contains(e.target)) {
                        console.log('Click inside menu, not closing');
                        return;
                    }
                    console.log('Click outside menu, closing');
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                };
                document.addEventListener('click', closeMenu);
            }, 100);

            // Also close on Escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    menu.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }

        function renderCanvasNode(item, phase, parentItem = null, nestingLevel = 0) {
            const canvas = document.getElementById('canvas');
            const node = document.createElement('div');
            node.className = 'canvas-node';

            // Calculate hierarchical shadow based on nesting level
            // Level 0 (root items): High elevation (big shadow)
            // Level 1+ (subtasks): Lower elevation (smaller shadow)
            const shadowIntensity = Math.max(0, 5 - nestingLevel);  // 5, 4, 3, 2, 1, 0
            const shadowBlur = 8 + (shadowIntensity * 4);  // 8-28px blur
            const shadowSpread = shadowIntensity * 2;  // 0-10px spread
            const shadowOffset = 2 + (shadowIntensity * 2);  // 2-12px offset

            node.style.boxShadow = `
                0 ${shadowOffset}px ${shadowBlur}px rgba(0, 0, 0, 0.3),
                0 ${shadowOffset / 2}px ${shadowBlur / 2}px rgba(99, 102, 241, ${0.1 + shadowIntensity * 0.05})
            `;

            // Add visual distinction for subtasks
            if (parentItem || item.type === 'subtask') {
                node.style.border = '2px dashed rgba(99, 102, 241, 0.4)';
                node.style.opacity = '0.95';
            } else {
                // Root items get solid border with glow
                node.style.border = '2px solid rgba(99, 102, 241, 0.3)';
            }

            node.style.left = `${item.canvasX}px`;
            node.style.top = `${item.canvasY}px`;
            node.dataset.itemId = item.id;
            node.dataset.nestingLevel = nestingLevel;

            // Check if node has children (support both subItems and children)
            const childList = item.subItems || item.children || [];
            const hasChildren = childList.length > 0;

            // Dynamic tooltip based on whether node has children
            node.title = hasChildren
                ? 'Left-click: Expand/Collapse | Double-click: Edit | Right-click: Menu | Middle-click: Drag'
                : 'Left-click: Info | Double-click: Edit | Right-click: Menu | Middle-click: Drag';

            // Add collapse/expand indicator if node has children
            let expandIndicator = '';
            if (hasChildren) {
                const isExpanded = item.expanded !== false;
                const indicatorIcon = isExpanded ? '‚ñº' : '‚ñ∂';
                expandIndicator = `<div style="position: absolute; top: 8px; right: 8px; font-size: 12px; cursor: pointer; padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; user-select: none;" class="expand-indicator" data-item-id="${item.id}">${indicatorIcon} ${childList.length}</div>`;
            }

            // RAG status indicator
            let ragHtml = '';
            if (item.pmRAGStatus) {
                const ragColors = { Green: '#22C55E', Amber: '#F59E0B', Red: '#EF4444' };
                const ragColor = ragColors[item.pmRAGStatus];
                ragHtml = `<span style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: ${ragColor}; margin-left: 8px; box-shadow: 0 0 6px ${ragColor}80;"></span>`;
            }

            // Cost badge
            let costHtml = '';
            if (item.cost) {
                const costStr = item.cost >= 1000000 ? `$${(item.cost/1000000).toFixed(1)}M` :
                               item.cost >= 1000 ? `$${(item.cost/1000).toFixed(0)}K` :
                               `$${item.cost}`;
                costHtml = `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; background: rgba(34, 197, 94, 0.2); color: #22C55E;">${costStr}</span>`;
            }

            // Type badge
            let typeHtml = '';
            if (item.itemType) {
                typeHtml = `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; background: rgba(99, 102, 241, 0.2); color: var(--treeplex-primary);">${item.itemType}</span>`;
            }

            // Progress indicator
            let progressHtml = '';
            if (item.pmProgress) {
                progressHtml = `<div style="margin-top: 8px; background: rgba(255,255,255,0.1); height: 4px; border-radius: 2px; overflow: hidden;">
                    <div style="background: var(--treeplex-primary); height: 100%; width: ${item.pmProgress}%;"></div>
                </div>`;
            }

            node.innerHTML = `
                ${expandIndicator}
                <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                    <div style="font-size: 24px;">${item.icon || 'üì¶'}</div>
                    <div style="flex: 1;">
                        <div style="font-size: 14px; font-weight: 600; margin-bottom: 4px;">
                            ${item.name}${ragHtml}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                            ${(item.description || 'No description').substring(0, 100)}${item.description?.length > 100 ? '...' : ''}
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    ${typeHtml}
                    ${costHtml}
                    ${item.pmOwnerEmail ? `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; background: rgba(255,255,255,0.1);">üë§ ${item.pmOwnerEmail.split('@')[0]}</span>` : ''}
                </div>
                ${progressHtml}
            `;

            // Add expand/collapse handler
            const expandBtn = node.querySelector('.expand-indicator');
            if (expandBtn) {
                expandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    item.expanded = !item.expanded;
                    console.log('Toggling expand for:', item.name, 'expanded:', item.expanded);
                    renderCanvas();
                });
            }

            // Left-click to expand/collapse if has children, otherwise show info panel
            node.addEventListener('click', (e) => {
                console.log('Left-click detected on:', item.name);
                e.stopPropagation();

                // Set as active node
                activeNode = item;

                // Highlight selected node
                document.querySelectorAll('.canvas-node').forEach(n => n.classList.remove('selected'));
                node.classList.add('selected');

                // Check if node has children (support both subItems and children)
                const hasChildren = (item.subItems && item.subItems.length > 0) ||
                                  (item.children && item.children.length > 0);

                if (hasChildren) {
                    // Toggle expand/collapse
                    item.expanded = !item.expanded;
                    console.log('Toggling expand for:', item.name, 'expanded:', item.expanded);
                    renderCanvas();
                } else {
                    // Leaf node - show info panel
                    if (typeof showInfo === 'function') {
                        console.log('Calling TreeListy showInfo function');
                        showInfo(item);
                    } else {
                        console.error('showInfo function not found!');
                    }
                }
            });

            // Double-click to edit (HIGHEST PRIORITY)
            node.addEventListener('dblclick', (e) => {
                console.log('Double-click detected on:', item.name);
                e.preventDefault();
                e.stopPropagation();

                // Cancel any drag that might have started
                isDraggingCanvasNode = false;
                draggedCanvasNode = null;
                node.classList.remove('dragging');

                // Set active node and call TreeListy's edit function
                activeNode = item;
                console.log('Opening edit dialog for:', item.name);

                if (typeof handleEdit === 'function') {
                    console.log('Calling TreeListy handleEdit function');
                    handleEdit();
                } else {
                    console.error('handleEdit function not found!');
                }
            });

            // Right-click context menu
            node.addEventListener('contextmenu', (e) => {
                console.log('Right-click detected on:', item.name);
                e.preventDefault();
                e.stopPropagation();

                // Cancel any drag
                isDraggingCanvasNode = false;
                draggedCanvasNode = null;
                node.classList.remove('dragging');

                activeNode = item;

                // Show simple inline context menu
                showCanvasContextMenu(e.pageX, e.pageY, item);
            });

            // Drag with MIDDLE MOUSE BUTTON (button 1) only - left button reserved for panning
            node.addEventListener('mousedown', (e) => {
                const containerRect = document.getElementById('canvas-container').getBoundingClientRect();

                // Middle-click - drag group if node is selected, otherwise drag individual
                if (e.button === 1) {
                    e.preventDefault(); // Prevent browser's middle-click scroll
                    e.stopPropagation();

                    // Check if this node is part of a selection
                    if (selectedNodes.includes(item) && selectedNodes.length > 1) {
                        console.log('Middle-click drag group activated (', selectedNodes.length, 'nodes )');
                        isDraggingSelection = true;
                        const clickX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                        const clickY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                        selectionDragStart = { x: clickX, y: clickY };
                    } else {
                        // Individual node drag
                        console.log('Middle-click drag activated for:', item.name);
                        isDraggingCanvasNode = true;
                        draggedCanvasNode = item;
                        dragStartX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x - item.canvasX;
                        dragStartY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y - item.canvasY;
                        node.classList.add('dragging');
                    }
                }
                // Left-click (button 0) is reserved for panning
                // Right-click (button 2) is free for context menu
            });

            canvas.appendChild(node);
            canvasNodes.push({ element: node, data: item, phase: phase });
        }

        function updateCanvasTransform() {
            const canvas = document.getElementById('canvas');
            if (canvas) {
                canvas.style.transform = `translate(${canvasPan.x}px, ${canvasPan.y}px) scale(${canvasZoom})`;
            }
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const zoomLevel = document.getElementById('zoom-level');
            if (zoomLevel) {
                zoomLevel.textContent = Math.round(canvasZoom * 100) + '%';
            }
        }

        function resetView() {
            canvasPan = { x: 0, y: 0 };
            canvasZoom = 1;
            updateCanvasTransform();
        }

        function fitToView() {
            if (canvasNodes.length === 0) return;

            // Find bounding box of all nodes
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            canvasNodes.forEach(({ data }) => {
                minX = Math.min(minX, data.canvasX);
                minY = Math.min(minY, data.canvasY);
                maxX = Math.max(maxX, data.canvasX + 320);  // node width
                maxY = Math.max(maxY, data.canvasY + 120);  // node height
            });

            const container = document.getElementById('canvas-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const contentWidth = maxX - minX + 200;  // padding
            const contentHeight = maxY - minY + 200;

            const scaleX = containerWidth / contentWidth;
            const scaleY = containerHeight / contentHeight;
            canvasZoom = Math.min(scaleX, scaleY, 1);  // Don't zoom in beyond 100%

            // Center the content
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            canvasPan.x = containerWidth / 2 - centerX * canvasZoom;
            canvasPan.y = containerHeight / 2 - centerY * canvasZoom;

            updateCanvasTransform();
        }

        function snapToGrid(value) {
            if (!gridEnabled) return value;
            return Math.round(value / gridSize) * gridSize;
        }

        function clearSelection() {
            // Remove selected class from all nodes
            selectedNodes.forEach(nodeData => {
                const nodeEl = canvasNodes.find(n => n.data.id === nodeData.id)?.element;
                if (nodeEl) {
                    nodeEl.classList.remove('selected');
                }
            });
            selectedNodes = [];
        }

        function toggleGrid() {
            gridEnabled = !gridEnabled;
            const gridBtn = document.getElementById('grid-toggle');
            const gridSvg = document.getElementById('canvas-grid');

            if (gridBtn) {
                if (gridEnabled) {
                    gridBtn.style.background = 'rgba(99, 102, 241, 0.6)';
                    gridBtn.style.borderColor = 'rgba(99, 102, 241, 0.8)';
                    gridBtn.style.color = 'white';
                } else {
                    gridBtn.style.background = 'rgba(99, 102, 241, 0.1)';
                    gridBtn.style.borderColor = 'rgba(99, 102, 241, 0.3)';
                    gridBtn.style.color = 'var(--text-primary)';
                }
            }

            if (gridSvg) {
                gridSvg.style.opacity = gridEnabled ? '1' : '0';
            }

            console.log('Grid:', gridEnabled ? 'ON (visible + snapping)' : 'OFF');
        }

        // Auto-layout algorithms
        function applyAutoLayout(layoutType) {
            console.log('Applying layout:', layoutType);

            if (layoutType === 'hierarchical') {
                applyHierarchicalLayout();
            } else if (layoutType === 'timeline') {
                applyTimelineLayout();
            } else if (layoutType === 'force') {
                applyForceDirectedLayout();
            } else if (layoutType === 'radial') {
                applyRadialLayout();
            } else if (layoutType === 'grid') {
                applyGridLayout();
            }

            renderCanvas();
            fitToView();
        }

        function applyHierarchicalLayout() {
            let currentY = 100;
            const levelGap = 250;
            const nodeGap = 350;

            capexTree.children.forEach((phase, phaseIdx) => {
                let currentX = 200;

                phase.items?.forEach((item) => {
                    item.canvasX = currentX;
                    item.canvasY = currentY;

                    // Layout subtasks to the right and down
                    layoutSubtasksHierarchical(item, currentX + nodeGap, currentY, 1);

                    currentX += nodeGap;
                });

                currentY += levelGap;
            });
        }

        function layoutSubtasksHierarchical(item, startX, startY, level) {
            if (!item.subItems || item.subItems.length === 0) return;

            let currentY = startY;
            const verticalGap = 140;

            item.subItems.forEach((subtask, idx) => {
                subtask.canvasX = startX;
                subtask.canvasY = currentY;

                layoutSubtasksHierarchical(subtask, startX + 350, currentY, level + 1);

                currentY += verticalGap;
            });
        }

        function applyTimelineLayout() {
            let currentX = 200;
            const xGap = 400;
            let currentY = 100;

            capexTree.children.forEach((phase) => {
                phase.items?.forEach((item) => {
                    item.canvasX = currentX;
                    item.canvasY = currentY;

                    // Layout subtasks vertically below
                    if (item.subItems) {
                        let subY = currentY + 150;
                        item.subItems.forEach(subtask => {
                            subtask.canvasX = currentX;
                            subtask.canvasY = subY;
                            subY += 140;
                        });
                    }

                    currentX += xGap;
                });
            });
        }

        function applyGridLayout() {
            const cols = 4;
            const nodeWidth = 350;
            const nodeHeight = 180;
            let index = 0;

            capexTree.children.forEach((phase) => {
                phase.items?.forEach((item) => {
                    const col = index % cols;
                    const row = Math.floor(index / cols);

                    item.canvasX = 100 + col * nodeWidth;
                    item.canvasY = 100 + row * nodeHeight;

                    index++;

                    // Layout subtasks in continuation of grid
                    if (item.subItems) {
                        item.subItems.forEach(subtask => {
                            index++;
                            const col = index % cols;
                            const row = Math.floor(index / cols);
                            subtask.canvasX = 100 + col * nodeWidth;
                            subtask.canvasY = 100 + row * nodeHeight;
                        });
                    }
                });
            });
        }

        function applyRadialLayout() {
            const centerX = 600;
            const centerY = 400;
            const radius = 300;
            let totalItems = 0;

            // Count items
            capexTree.children.forEach(phase => {
                totalItems += phase.items?.length || 0;
            });

            let index = 0;

            capexTree.children.forEach((phase) => {
                phase.items?.forEach((item) => {
                    const angle = (index / totalItems) * Math.PI * 2;
                    item.canvasX = centerX + Math.cos(angle) * radius;
                    item.canvasY = centerY + Math.sin(angle) * radius;

                    // Place subtasks further out
                    if (item.subItems) {
                        item.subItems.forEach((subtask, subIdx) => {
                            const subAngle = angle + (subIdx * 0.2);
                            subtask.canvasX = centerX + Math.cos(subAngle) * (radius + 200);
                            subtask.canvasY = centerY + Math.sin(subAngle) * (radius + 200);
                        });
                    }

                    index++;
                });
            });
        }

        // Barnes-Hut Quadtree for O(n log n) force approximation
        class QuadtreeNode {
            constructor(x, y, width, height, depth = 0) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.depth = depth;  // Track recursion depth
                this.mass = 0;
                this.centerX = 0;
                this.centerY = 0;
                this.children = [];
                this.node = null;  // Actual canvas node if leaf
                this.subdivided = false;
            }

            insert(node) {
                // Check if node is within bounds
                if (node.canvasX < this.x || node.canvasX > this.x + this.width ||
                    node.canvasY < this.y || node.canvasY > this.y + this.height) {
                    return false;
                }

                // If this is empty, place node here
                if (this.mass === 0) {
                    this.node = node;
                    this.mass = 1;
                    this.centerX = node.canvasX;
                    this.centerY = node.canvasY;
                    return true;
                }

                // PREVENT INFINITE RECURSION: Max depth or minimum size check
                const MAX_DEPTH = 15;
                const MIN_SIZE = 1;
                if (this.depth >= MAX_DEPTH || this.width < MIN_SIZE || this.height < MIN_SIZE) {
                    // Can't subdivide further - keep both nodes at this level
                    // Update center of mass to include both
                    const totalMass = this.mass + 1;
                    this.centerX = (this.centerX * this.mass + node.canvasX) / totalMass;
                    this.centerY = (this.centerY * this.mass + node.canvasY) / totalMass;
                    this.mass = totalMass;
                    return true;
                }

                // If this is a leaf, subdivide
                if (!this.subdivided) {
                    this.subdivide();
                }

                // Update center of mass
                const totalMass = this.mass + 1;
                this.centerX = (this.centerX * this.mass + node.canvasX) / totalMass;
                this.centerY = (this.centerY * this.mass + node.canvasY) / totalMass;
                this.mass = totalMass;

                // Insert into appropriate child
                for (let child of this.children) {
                    if (child.insert(node)) {
                        return true;
                    }
                }

                // SAFETY: If no child accepted it, keep it here (prevents infinite recursion)
                // This can happen with floating point precision issues or nodes exactly on boundaries
                return true;
            }

            subdivide() {
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;

                // Create 4 quadrants: NW, NE, SW, SE (pass depth + 1)
                this.children = [
                    new QuadtreeNode(this.x, this.y, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x + halfWidth, this.y, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x, this.y + halfHeight, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x + halfWidth, this.y + halfHeight, halfWidth, halfHeight, this.depth + 1)
                ];

                // Reinsert existing node
                if (this.node) {
                    for (let child of this.children) {
                        if (child.insert(this.node)) {
                            break;
                        }
                    }
                    this.node = null;
                }

                this.subdivided = true;
            }

            calculateForce(node, force, repulsion, theta = 0.5) {
                // Skip if this is the same node
                if (this.node === node) {
                    return;
                }

                const dx = this.centerX - node.canvasX;
                const dy = this.centerY - node.canvasY;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                // If this is a leaf or far enough, treat as single body
                if (!this.subdivided || (this.width / dist < theta)) {
                    const forceMag = repulsion * this.mass / (dist * dist);
                    force.x -= (dx / dist) * forceMag;
                    force.y -= (dy / dist) * forceMag;
                } else {
                    // Recurse into children
                    for (let child of this.children) {
                        if (child.mass > 0) {
                            child.calculateForce(node, force, repulsion, theta);
                        }
                    }
                }
            }
        }

        function buildQuadtree(nodes) {
            // Find bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.canvasX);
                minY = Math.min(minY, node.canvasY);
                maxX = Math.max(maxX, node.canvasX);
                maxY = Math.max(maxY, node.canvasY);
            });

            // Add padding
            const padding = 100;
            minX -= padding;
            minY -= padding;
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;

            // Build tree
            const root = new QuadtreeNode(minX, minY, width, height);
            nodes.forEach(node => root.insert(node));
            return root;
        }

        function applyForceDirectedLayout() {
            // Enhanced force-directed layout with Barnes-Hut, collision detection, and phase-aware forces
            const iterations = 500;  // Increased from 100 for better convergence
            const baseRepulsion = 8000;  // Stronger repulsion
            const baseAttraction = 0.02;  // Stronger attraction
            const nodeRadius = 120;  // Collision detection radius
            const phaseAttractionStrength = 0.008;  // Keep nodes near their phase
            const centerPull = 0.001;  // Weak pull toward center

            // Collect all nodes and track phase membership
            let allNodes = [];
            const phaseMap = new Map();  // Map node ID to phase

            capexTree.children.forEach(phase => {
                phase.items?.forEach(item => {
                    allNodes.push(item);
                    phaseMap.set(item.id, phase);

                    if (item.subItems) {
                        item.subItems.forEach(subtask => {
                            allNodes.push(subtask);
                            phaseMap.set(subtask.id, phase);
                        });
                    }
                });
            });

            // Calculate initial phase centers for phase-aware forces
            const phaseCenters = new Map();
            capexTree.children.forEach(phase => {
                const phaseNodes = allNodes.filter(n => phaseMap.get(n.id) === phase);
                if (phaseNodes.length > 0) {
                    const avgX = phaseNodes.reduce((sum, n) => sum + n.canvasX, 0) / phaseNodes.length;
                    const avgY = phaseNodes.reduce((sum, n) => sum + n.canvasY, 0) / phaseNodes.length;
                    phaseCenters.set(phase.id, { x: avgX, y: avgY });
                }
            });

            // Main simulation loop with progressive damping
            for (let iter = 0; iter < iterations; iter++) {
                const progress = iter / iterations;
                const damping = 0.95 - (progress * 0.45);  // Progressive cooling: 0.95 ‚Üí 0.5
                const tempRepulsion = baseRepulsion * (1 - progress * 0.3);  // Reduce repulsion over time

                // Build quadtree for Barnes-Hut approximation (O(n log n) instead of O(n¬≤))
                const quadtree = buildQuadtree(allNodes);

                // Apply repulsion using Barnes-Hut approximation
                allNodes.forEach(node => {
                    const force = { x: 0, y: 0 };
                    quadtree.calculateForce(node, force, tempRepulsion);
                    node.canvasX += force.x * damping;
                    node.canvasY += force.y * damping;
                });

                // Collision detection: prevent overlaps (still O(n¬≤) but necessary for precision)
                for (let i = 0; i < allNodes.length; i++) {
                    for (let j = i + 1; j < allNodes.length; j++) {
                        const dx = allNodes[j].canvasX - allNodes[i].canvasX;
                        const dy = allNodes[j].canvasY - allNodes[i].canvasY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        const minDist = nodeRadius * 2;
                        if (dist < minDist && dist > 0) {
                            // Push nodes apart to prevent overlap
                            const pushForce = (minDist - dist) / dist * 0.5;
                            const pushX = dx * pushForce;
                            const pushY = dy * pushForce;

                            allNodes[i].canvasX -= pushX;
                            allNodes[i].canvasY -= pushY;
                            allNodes[j].canvasX += pushX;
                            allNodes[j].canvasY += pushY;
                        }
                    }
                }

                // Apply attraction for parent-child relationships
                capexTree.children.forEach(phase => {
                    phase.items?.forEach(item => {
                        if (item.subItems) {
                            item.subItems.forEach(subtask => {
                                const dx = subtask.canvasX - item.canvasX;
                                const dy = subtask.canvasY - item.canvasY;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist > 0) {
                                    // Spring-like attraction
                                    const force = baseAttraction * dist;
                                    const fx = (dx / dist) * force;
                                    const fy = (dy / dist) * force;

                                    item.canvasX += fx * damping;
                                    item.canvasY += fy * damping;
                                    subtask.canvasX -= fx * damping;
                                    subtask.canvasY -= fy * damping;
                                }
                            });
                        }
                    });
                });

                // Apply phase-aware forces (keep nodes grouped by phase)
                allNodes.forEach(node => {
                    const phase = phaseMap.get(node.id);
                    if (phase) {
                        const phaseCenter = phaseCenters.get(phase.id);
                        if (phaseCenter) {
                            const dx = phaseCenter.x - node.canvasX;
                            const dy = phaseCenter.y - node.canvasY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist > 0) {
                                // Gentle pull toward phase center (weaker over time)
                                const force = phaseAttractionStrength * dist * (1 - progress);
                                node.canvasX += (dx / dist) * force;
                                node.canvasY += (dy / dist) * force;
                            }
                        }
                    }
                });

                // Apply metadata-based clustering (if enabled)
                if (clusterByField) {
                    const clusterStrength = 0.015;  // Strength of clustering attraction

                    // Helper function to get comparable value for clustering
                    const getClusterValue = (node, field) => {
                        if (field === 'cost') {
                            // Group by cost ranges (0-10k, 10k-50k, 50k-200k, 200k+)
                            const cost = node.cost || 0;
                            if (cost < 10000) return 'low';
                            if (cost < 50000) return 'medium';
                            if (cost < 200000) return 'high';
                            return 'very-high';
                        } else if (field === 'modifiedDate') {
                            // Group by month
                            if (!node.modifiedDate) return 'unknown';
                            return node.modifiedDate.substring(0, 7); // YYYY-MM
                        } else {
                            // Direct field value (itemType, owner, pmRAGStatus, etc.)
                            return node[field] || 'unknown';
                        }
                    };

                    // Apply clustering forces between nodes with matching metadata
                    for (let i = 0; i < allNodes.length; i++) {
                        for (let j = i + 1; j < allNodes.length; j++) {
                            const valueA = getClusterValue(allNodes[i], clusterByField);
                            const valueB = getClusterValue(allNodes[j], clusterByField);

                            // If nodes share the same metadata value, attract them
                            if (valueA === valueB && valueA !== 'unknown') {
                                const dx = allNodes[j].canvasX - allNodes[i].canvasX;
                                const dy = allNodes[j].canvasY - allNodes[i].canvasY;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist > 0) {
                                    // Gentle attraction between similar nodes
                                    const force = clusterStrength * dist * (1 - progress * 0.5);
                                    const fx = (dx / dist) * force;
                                    const fy = (dy / dist) * force;

                                    allNodes[i].canvasX += fx;
                                    allNodes[i].canvasY += fy;
                                    allNodes[j].canvasX -= fx;
                                    allNodes[j].canvasY -= fy;
                                }
                            }
                        }
                    }
                }

                // Pull towards global center (very weak)
                allNodes.forEach(node => {
                    node.canvasX -= (node.canvasX - 600) * centerPull * damping;
                    node.canvasY -= (node.canvasY - 400) * centerPull * damping;
                });

                // Recalculate phase centers every 50 iterations for better clustering
                if (iter % 50 === 0) {
                    capexTree.children.forEach(phase => {
                        const phaseNodes = allNodes.filter(n => phaseMap.get(n.id) === phase);
                        if (phaseNodes.length > 0) {
                            const avgX = phaseNodes.reduce((sum, n) => sum + n.canvasX, 0) / phaseNodes.length;
                            const avgY = phaseNodes.reduce((sum, n) => sum + n.canvasY, 0) / phaseNodes.length;
                            phaseCenters.set(phase.id, { x: avgX, y: avgY });
                        }
                    });
                }
            }

            const clusterMsg = clusterByField ? ` with clustering by ${clusterByField}` : '';
            console.log(`Force-directed layout complete: ${iterations} iterations, ${allNodes.length} nodes${clusterMsg}`);
        }

        // Canvas container event listeners
        function initializeCanvasEvents() {
            const container = document.getElementById('canvas-container');

            container.addEventListener('mousedown', (e) => {
                const containerRect = container.getBoundingClientRect();

                // Middle mouse button - start selection
                if (e.button === 1 && (e.target === container || e.target.id === 'canvas')) {
                    e.preventDefault();
                    isSelecting = true;
                    const x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                    selectionStart = { x, y };
                    selectionEnd = { x, y };

                    // Clear previous selection
                    clearSelection();

                    // Create selection overlay
                    let selectionBox = document.getElementById('selection-box');
                    if (!selectionBox) {
                        selectionBox = document.createElement('div');
                        selectionBox.id = 'selection-box';
                        selectionBox.style.position = 'absolute';
                        selectionBox.style.border = '2px dashed var(--treeplex-primary)';
                        selectionBox.style.background = 'rgba(0, 166, 125, 0.1)';
                        selectionBox.style.pointerEvents = 'none';
                        selectionBox.style.zIndex = '9999';
                        document.getElementById('canvas').appendChild(selectionBox);
                    }
                    selectionBox.style.display = 'block';
                    return;
                }

                // Left mouse button on canvas background - pan
                if (e.button === 0 && (e.target === container || e.target.id === 'canvas')) {
                    // Clear selection when clicking on empty space
                    if (selectedNodes.length > 0 && !e.ctrlKey) {
                        clearSelection();
                    }

                    // Start panning
                    isPanningCanvas = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    container.classList.add('grabbing');
                }
            });

            container.addEventListener('mousemove', (e) => {
                const containerRect = container.getBoundingClientRect();

                // Drawing selection box with middle mouse
                if (isSelecting) {
                    const x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                    selectionEnd = { x, y };

                    // Update selection box visual
                    const selectionBox = document.getElementById('selection-box');
                    if (selectionBox) {
                        const minX = Math.min(selectionStart.x, selectionEnd.x);
                        const minY = Math.min(selectionStart.y, selectionEnd.y);
                        const maxX = Math.max(selectionStart.x, selectionEnd.x);
                        const maxY = Math.max(selectionStart.y, selectionEnd.y);

                        // Convert canvas coordinates back to screen coordinates (reverse the zoom/pan transformation)
                        const screenMinX = (minX + canvasPan.x) * canvasZoom;
                        const screenMinY = (minY + canvasPan.y) * canvasZoom;
                        const screenMaxX = (maxX + canvasPan.x) * canvasZoom;
                        const screenMaxY = (maxY + canvasPan.y) * canvasZoom;

                        selectionBox.style.left = `${screenMinX}px`;
                        selectionBox.style.top = `${screenMinY}px`;
                        selectionBox.style.width = `${screenMaxX - screenMinX}px`;
                        selectionBox.style.height = `${screenMaxY - screenMinY}px`;
                    }
                    return;
                }

                // Dragging multiple selected nodes
                if (isDraggingSelection && selectedNodes.length > 0) {
                    const currentX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const currentY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;

                    const deltaX = currentX - selectionDragStart.x;
                    const deltaY = currentY - selectionDragStart.y;

                    // Move all selected nodes
                    selectedNodes.forEach(nodeData => {
                        nodeData.canvasX += deltaX;
                        nodeData.canvasY += deltaY;

                        const nodeEl = canvasNodes.find(n => n.data.id === nodeData.id)?.element;
                        if (nodeEl) {
                            nodeEl.style.left = `${nodeData.canvasX}px`;
                            nodeEl.style.top = `${nodeData.canvasY}px`;
                        }

                        // Move children of each selected node
                        function moveChildren(node, dx, dy) {
                            const childList = node.items || node.children || node.subItems || [];
                            childList.forEach(child => {
                                if (child.canvasX !== undefined && child.canvasY !== undefined) {
                                    child.canvasX += dx;
                                    child.canvasY += dy;

                                    const childEl = canvasNodes.find(n => n.data.id === child.id)?.element;
                                    if (childEl) {
                                        childEl.style.left = `${child.canvasX}px`;
                                        childEl.style.top = `${child.canvasY}px`;
                                    }

                                    moveChildren(child, dx, dy);
                                }
                            });
                        }
                        moveChildren(nodeData, deltaX, deltaY);
                    });

                    selectionDragStart = { x: currentX, y: currentY };
                    drawConnections();
                    return;
                }

                if (isPanningCanvas) {
                    const dx = (e.clientX - panStartX) / canvasZoom;
                    const dy = (e.clientY - panStartY) / canvasZoom;
                    canvasPan.x += dx;
                    canvasPan.y += dy;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    updateCanvasTransform();
                } else if (isDraggingCanvasNode && draggedCanvasNode) {
                    const containerRect = container.getBoundingClientRect();
                    let x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x - dragStartX;
                    let y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y - dragStartY;

                    // Apply grid snapping if enabled
                    x = snapToGrid(x);
                    y = snapToGrid(y);

                    // Calculate delta (how much the node moved)
                    const deltaX = x - draggedCanvasNode.canvasX;
                    const deltaY = y - draggedCanvasNode.canvasY;

                    // Update parent position
                    draggedCanvasNode.canvasX = x;
                    draggedCanvasNode.canvasY = y;

                    const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                    if (nodeEl) {
                        nodeEl.style.left = `${x}px`;
                        nodeEl.style.top = `${y}px`;
                    }

                    // Recursively move all children by the same delta
                    function moveChildren(node, dx, dy) {
                        const childList = node.items || node.children || node.subItems || [];
                        childList.forEach(child => {
                            if (child.canvasX !== undefined && child.canvasY !== undefined) {
                                child.canvasX += dx;
                                child.canvasY += dy;

                                // Update child DOM element
                                const childEl = canvasNodes.find(n => n.data.id === child.id)?.element;
                                if (childEl) {
                                    childEl.style.left = `${child.canvasX}px`;
                                    childEl.style.top = `${child.canvasY}px`;
                                }

                                // Recursively move grandchildren
                                moveChildren(child, dx, dy);
                            }
                        });
                    }

                    // Move all descendants
                    if (deltaX !== 0 || deltaY !== 0) {
                        moveChildren(draggedCanvasNode, deltaX, deltaY);
                    }

                    // Redraw connections while dragging
                    drawConnections();
                }
            });

            container.addEventListener('mouseup', (e) => {
                // Finalize selection
                if (isSelecting) {
                    isSelecting = false;

                    // Hide selection box
                    const selectionBox = document.getElementById('selection-box');
                    if (selectionBox) {
                        selectionBox.style.display = 'none';
                    }

                    // Calculate selection bounds
                    const minX = Math.min(selectionStart.x, selectionEnd.x);
                    const minY = Math.min(selectionStart.y, selectionEnd.y);
                    const maxX = Math.max(selectionStart.x, selectionEnd.x);
                    const maxY = Math.max(selectionStart.y, selectionEnd.y);

                    // Find nodes within selection
                    const containerRect = container.getBoundingClientRect();
                    canvasNodes.forEach(nodeObj => {
                        const node = nodeObj.data;
                        const nodeEl = nodeObj.element;

                        if (node.canvasX !== undefined && node.canvasY !== undefined) {
                            const rect = nodeEl.getBoundingClientRect();
                            const nodeX = (rect.left - containerRect.left) / canvasZoom - canvasPan.x;
                            const nodeY = (rect.top - containerRect.top) / canvasZoom - canvasPan.y;
                            const nodeW = rect.width / canvasZoom;
                            const nodeH = rect.height / canvasZoom;

                            // Check if node intersects with selection box
                            if (nodeX < maxX && nodeX + nodeW > minX &&
                                nodeY < maxY && nodeY + nodeH > minY) {
                                selectedNodes.push(node);
                                nodeEl.classList.add('selected');
                            }
                        }
                    });

                    console.log(`Selected ${selectedNodes.length} nodes`);
                    return;
                }

                // End dragging selection
                if (isDraggingSelection) {
                    isDraggingSelection = false;
                    return;
                }

                isPanningCanvas = false;
                container.classList.remove('grabbing');

                // Clean up dragging state
                if (isDraggingCanvasNode || draggedCanvasNode) {
                    if (draggedCanvasNode) {
                        const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                        if (nodeEl) {
                            nodeEl.classList.remove('dragging');
                        }
                    }
                    isDraggingCanvasNode = false;
                    draggedCanvasNode = null;
                }
            });

            // Also handle mouseleave to stop dragging when mouse leaves container
            container.addEventListener('mouseleave', () => {
                isPanningCanvas = false;
                container.classList.remove('grabbing');

                if (isDraggingCanvasNode || draggedCanvasNode) {
                    if (draggedCanvasNode) {
                        const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                        if (nodeEl) {
                            nodeEl.classList.remove('dragging');
                        }
                    }
                    isDraggingCanvasNode = false;
                    draggedCanvasNode = null;
                }
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                canvasZoom = Math.max(0.1, Math.min(5, canvasZoom * delta));
                updateCanvasTransform();
            }, { passive: false });
        }

        // =====================================================================
        // PROGRESSIVE EXPAND/COLLAPSE - Works in both Tree and Canvas Views
        // =====================================================================

        // Calculate the maximum depth of the tree
        function getMaxDepth(node = capexTree, depth = 0) {
            let maxDepth = depth;
            if (node.children) {
                node.children.forEach(child => {
                    maxDepth = Math.max(maxDepth, getMaxDepth(child, depth + 1));
                });
            }
            if (node.items) {
                node.items.forEach(item => {
                    maxDepth = Math.max(maxDepth, getItemMaxDepth(item, depth + 1));
                });
            }
            return maxDepth;
        }

        function getItemMaxDepth(item, depth = 0) {
            let maxDepth = depth;
            if (item.subItems && item.subItems.length > 0) {
                item.subItems.forEach(subItem => {
                    maxDepth = Math.max(maxDepth, getItemMaxDepth(subItem, depth + 1));
                });
            }
            return maxDepth;
        }

        // Collapse one level at a time (deepest first)
        function collapseOneLevel() {
            console.log('üîç collapseOneLevel called');

            // Find all items with subItems that are currently expanded
            let deepestExpandedWithChildren = [];
            let maxDepthFound = 0;

            function findExpandedWithChildren(node, depth = 0, path = []) {
                // For phases (node.children)
                if (node.children) {
                    node.children.forEach(child => {
                        findExpandedWithChildren(child, depth + 1, [...path, node]);
                    });
                }

                // For items
                if (node.items) {
                    node.items.forEach(item => {
                        findExpandedItems(item, depth + 1, [...path, node]);
                    });
                }
            }

            function findExpandedItems(item, depth, path) {
                // If this item has subItems and is expanded, record it
                if (item.subItems && item.subItems.length > 0 && item.expanded !== false) {
                    deepestExpandedWithChildren.push({ item, depth, path });
                    maxDepthFound = Math.max(maxDepthFound, depth);

                    // Recurse into subItems
                    item.subItems.forEach(subItem => {
                        findExpandedItems(subItem, depth + 1, [...path, item]);
                    });
                } else if (item.subItems) {
                    // Has children but collapsed - still check children in case some are expanded
                    item.subItems.forEach(subItem => {
                        findExpandedItems(subItem, depth + 1, [...path, item]);
                    });
                }
            }

            findExpandedWithChildren(capexTree);

            console.log('Found', deepestExpandedWithChildren.length, 'expanded items with children');
            console.log('Max depth:', maxDepthFound);

            if (deepestExpandedWithChildren.length === 0) {
                console.log('‚úÖ Already fully collapsed - no items with children are expanded');
                return;
            }

            // Collapse only the items at the deepest level
            const toCollapse = deepestExpandedWithChildren.filter(x => x.depth === maxDepthFound);
            console.log('Collapsing', toCollapse.length, 'items at depth', maxDepthFound);

            toCollapse.forEach(({ item }) => {
                console.log('  - Collapsing:', item.name);
                item.expanded = false;
            });
        }

        // Expand one level at a time (shallowest first)
        function expandOneLevel() {
            console.log('üîç expandOneLevel called');

            // Find all items with subItems that are currently collapsed
            let collapsedWithChildren = [];
            let minDepthFound = Infinity;

            function findCollapsedWithChildren(node, depth = 0, path = []) {
                // For phases (node.children)
                if (node.children) {
                    node.children.forEach(child => {
                        findCollapsedWithChildren(child, depth + 1, [...path, node]);
                    });
                }

                // For items
                if (node.items) {
                    node.items.forEach(item => {
                        findCollapsedItems(item, depth + 1, [...path, node]);
                    });
                }
            }

            function findCollapsedItems(item, depth, path) {
                // If this item has subItems and is collapsed, record it
                if (item.subItems && item.subItems.length > 0 && item.expanded === false) {
                    collapsedWithChildren.push({ item, depth, path });
                    minDepthFound = Math.min(minDepthFound, depth);
                }

                // Still recurse into subItems even if collapsed (to find deeper collapsed items)
                if (item.subItems) {
                    item.subItems.forEach(subItem => {
                        findCollapsedItems(subItem, depth + 1, [...path, item]);
                    });
                }
            }

            findCollapsedWithChildren(capexTree);

            console.log('Found', collapsedWithChildren.length, 'collapsed items with children');
            console.log('Min depth:', minDepthFound);

            if (collapsedWithChildren.length === 0) {
                console.log('‚úÖ Already fully expanded - no collapsed items with children');
                return;
            }

            // Expand only the items at the shallowest level
            const toExpand = collapsedWithChildren.filter(x => x.depth === minDepthFound);
            console.log('Expanding', toExpand.length, 'items at depth', minDepthFound);

            toExpand.forEach(({ item }) => {
                console.log('  - Expanding:', item.name);
                item.expanded = true;
            });
        }

        // Canvas-aware expand/collapse handlers
        window.canvasExpandOneLevel = function() {
            console.log('üéØ canvasExpandOneLevel called, viewMode:', viewMode);
            expandOneLevel();

            // Always update tree view
            if (typeof render === 'function') {
                console.log('Calling render() for tree view');
                render();
            }

            // Update canvas view if we're in canvas mode
            if (viewMode === 'canvas') {
                console.log('Calling renderCanvas() for canvas view');
                renderCanvas();
            }

            console.log('‚úÖ Expand complete');
        };

        window.canvasCollapseOneLevel = function() {
            console.log('üéØ canvasCollapseOneLevel called, viewMode:', viewMode);
            collapseOneLevel();

            // Always update tree view
            if (typeof render === 'function') {
                console.log('Calling render() for tree view');
                render();
            }

            // Update canvas view if we're in canvas mode
            if (viewMode === 'canvas') {
                console.log('Calling renderCanvas() for canvas view');
                renderCanvas();
            }

            console.log('‚úÖ Collapse complete');
        };

        // Helper to check if a node is visible (not hidden by collapsed parent)
        function isNodeVisible(nodeId) {
            // Find the node and check all its ancestors
            function findAndCheckNode(searchId, node = capexTree, ancestors = []) {
                if (node.id === searchId) {
                    // Check if any ancestor is collapsed
                    return ancestors.every(ancestor => ancestor.expanded !== false);
                }

                if (node.items) {
                    for (const item of node.items) {
                        if (checkItemVisibility(searchId, item, ancestors)) {
                            return true;
                        }
                    }
                }

                if (node.children) {
                    for (const child of node.children) {
                        const result = findAndCheckNode(searchId, child, [...ancestors, node]);
                        if (result !== undefined) return result;
                    }
                }

                return undefined;
            }

            function checkItemVisibility(searchId, item, ancestors = []) {
                if (item.id === searchId) {
                    return ancestors.every(ancestor => ancestor.expanded !== false);
                }

                if (item.subItems) {
                    for (const subItem of item.subItems) {
                        const result = checkItemVisibility(searchId, subItem, [...ancestors, item]);
                        if (result !== undefined) return result;
                    }
                }

                return undefined;
            }

            const result = findAndCheckNode(nodeId);
            return result === undefined ? true : result;  // Default to visible if not found
        }

        window.isNodeVisible = isNodeVisible;


        // =============================================================================
        // UNDO/REDO SYSTEM
        // =============================================================================

        // History stack for undo functionality
        const historyStack = [];
        const MAX_HISTORY = 50; // Keep last 50 states

        // Save current state to history before making changes
        function saveState(actionName = 'Unknown action') {
            const state = {
                tree: JSON.parse(JSON.stringify(capexTree)), // Deep copy
                pattern: currentPattern,
                timestamp: Date.now(),
                action: actionName
            };

            historyStack.push(state);

            // Limit history size
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift(); // Remove oldest
            }

            updateUndoButton();

            // Mark tree as changed (for auto-save)
            if (typeof treeManager !== 'undefined') {
                treeManager.markAsChanged();
            }
            console.log(`üíæ State saved: ${actionName} (${historyStack.length} states in history)`);
        }

        // Undo last action
        function undo() {
            if (historyStack.length === 0) {
                console.warn('‚ö†Ô∏è No history to undo');
                return;
            }

            const previousState = historyStack.pop();

            // Restore previous state
            capexTree = previousState.tree;
            currentPattern = previousState.pattern;
            document.getElementById('pattern-select').value = currentPattern;

            // Re-render
            render();

            updateUndoButton();

            console.log(`‚Ü©Ô∏è Undo: Restored state from "${previousState.action}" (${historyStack.length} states remaining)`);

            // Show toast notification
            showToast(`Undone: ${previousState.action}`);
        }

        // Update undo button state
        function updateUndoButton() {
            const undoBtn = document.getElementById('undo-btn');
            if (undoBtn) {
                if (historyStack.length > 0) {
                    undoBtn.disabled = false;
                    undoBtn.style.opacity = '1';
                    const lastAction = historyStack[historyStack.length - 1].action;
                    undoBtn.title = `Undo: ${lastAction}`;
                } else {
                    undoBtn.disabled = true;
                    undoBtn.style.opacity = '0.5';
                    undoBtn.title = 'Nothing to undo';
                }
            }
        }

        // Toast notification for undo
        function showToast(message) {
            // Remove existing toast if any
            const existingToast = document.getElementById('undo-toast');
            if (existingToast) {
                existingToast.remove();
            }

            // Create toast
            const toast = document.createElement('div');
            toast.id = 'undo-toast';
            toast.style.cssText = `
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.85);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                animation: slideUp 0.3s ease-out;
            `;
            toast.textContent = message;

            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideUp {
                    from {
                        opacity: 0;
                        transform: translateX(-50%) translateY(20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(toast);

            // Auto-remove after 2 seconds
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        // Attach undo button handler
        const undoBtnEl = document.getElementById('undo-btn');
        if (undoBtnEl) {
            undoBtnEl.addEventListener('click', undo);
        }

        // Keyboard shortcut for undo (Ctrl+Z / Cmd+Z)
        document.addEventListener('keydown', (e) => {
            // Check for Ctrl+Z (Windows/Linux) or Cmd+Z (Mac)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                // Don't trigger undo if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle undo in text fields
                }

                e.preventDefault();
                undo();
            }

            // Check for Ctrl+S (Windows/Linux) or Cmd+S (Mac) - Save shortcut
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                // Don't trigger save if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle save in text fields if needed
                }

                e.preventDefault();
                console.log('‚å®Ô∏è Ctrl+S pressed - triggering manual save');
                if (typeof treeManager !== 'undefined') {
                    treeManager.save(capexTree, { forceSaveAs: false });
                } else {
                    console.warn('TreeManager not initialized yet');
                }
            }
        });

        // =============================================================================
        // END UNDO/REDO SYSTEM
        // =============================================================================

// TREEPLEXITY PATTERN SELECTOR
// Insert this code into treelisty.html

// ============================================================================
// PATTERN DEFINITIONS
// ============================================================================

const PATTERNS = {
    generic: {
        name: 'Generic Project',
        icon: 'üìã',
        levels: {
            root: 'Project',
            phase: 'Phase',
            item: 'Item',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Seed', 'Seed', 'Build'],
        types: [
            { value: 'land', label: 'Land' },
            { value: 'engineering', label: 'Engineering' },
            { value: 'equipment', label: 'Equipment' },
            { value: 'infrastructure', label: 'Infrastructure' },
            { value: 'corporate', label: 'Corporate' },
            { value: 'professional', label: 'Professional' },
            { value: 'contingency', label: 'Contingency' }
        ],
        description: 'Universal structure for any project',
        sortOptions: [
            { value: 'cost-high', label: 'üí∞ Cost (Highest First)', field: 'cost', order: 'desc', type: 'number' },
            { value: 'cost-low', label: 'üí∞ Cost (Lowest First)', field: 'cost', order: 'asc', type: 'number' },
            { value: 'leadtime-soonest', label: '‚è±Ô∏è Lead Time (Soonest First)', field: 'leadTime', order: 'asc', type: 'leadtime' },
            { value: 'leadtime-latest', label: '‚è±Ô∏è Lead Time (Latest First)', field: 'leadTime', order: 'desc', type: 'leadtime' },
            { value: 'name-az', label: 'üî§ Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'üî§ Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ],
        fields: {
            cost: { label: 'Cost ($)', type: 'number', step: 1000, helpText: 'üí∞ Budget allocated for this item' },
            alternateSource: { label: 'Alternate Source', type: 'text', placeholder: 'Backup vendor, supplier, or alternative solution...', helpText: 'üì¶ Alternative supplier or backup option for risk mitigation' },
            leadTime: { label: 'Lead Time', type: 'text', placeholder: 'e.g., 12-18 months, 6 weeks, 90 days...', helpText: '‚è±Ô∏è Expected procurement or delivery timeline' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    sales: {
        name: 'Sales Pipeline',
        icon: 'üíº',
        levels: {
            root: 'Pipeline',
            phase: 'Quarter',
            item: 'Deal',
            subtask: 'Action'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'inbound', label: 'Inbound Lead' },
            { value: 'outbound', label: 'Outbound Prospect' },
            { value: 'partnership', label: 'Partnership' },
            { value: 'expansion', label: 'Account Expansion' },
            { value: 'renewal', label: 'Renewal' },
            { value: 'upsell', label: 'Upsell' },
            { value: 'cross-sell', label: 'Cross-sell' },
            { value: 'enterprise', label: 'Enterprise Deal' }
        ],
        description: 'Track sales opportunities through quarters',
        sortOptions: [
            { value: 'dealvalue-high', label: 'üí∞ Deal Value (Largest First)', field: 'dealValue', order: 'desc', type: 'number' },
            { value: 'dealvalue-low', label: 'üí∞ Deal Value (Smallest First)', field: 'dealValue', order: 'asc', type: 'number' },
            { value: 'closedate-soonest', label: 'üìÖ Close Date (Soonest First)', field: 'expectedCloseDate', order: 'asc', type: 'date' },
            { value: 'closedate-latest', label: 'üìÖ Close Date (Latest First)', field: 'expectedCloseDate', order: 'desc', type: 'date' },
            { value: 'probability-high', label: 'üìä Probability (Highest First)', field: 'stageProbability', order: 'desc', type: 'number' },
            { value: 'probability-low', label: 'üìä Probability (Lowest First)', field: 'stageProbability', order: 'asc', type: 'number' },
            { value: 'name-az', label: 'üî§ Deal Name (A-Z)', field: 'name', order: 'asc', type: 'text' }
        ],
        fields: {
            dealValue: { label: 'Deal Value ($)', type: 'number', step: 1000, helpText: 'üí∞ Potential revenue from this deal' },
            expectedCloseDate: { label: 'Expected Close Date', type: 'date', helpText: 'üìÖ Target date to close this deal' },
            leadSource: { label: 'Lead Source', type: 'text', placeholder: 'Inbound, Referral, Cold Outreach...', helpText: 'üìç How did this lead originate?' },
            contactPerson: { label: 'Contact Person', type: 'text', placeholder: 'Primary contact name...', helpText: 'üë§ Main decision maker or champion' },
            stageProbability: { label: 'Stage Probability (%)', type: 'number', min: 0, max: 100, step: 5, helpText: 'üìä Likelihood of closing this deal' },
            competitorInfo: { label: 'Competitor Info', type: 'textarea', placeholder: 'Who else is competing for this deal...', helpText: 'üéØ Other vendors in consideration' },
            includeDependencies: false,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    thesis: {
        name: 'Academic Writing',
        icon: 'üéì',
        levels: {
            root: 'Thesis',
            phase: 'Chapter',
            item: 'Section',
            subtask: 'Point'
        },
        phaseSubtitles: ['Introduction', 'Body', 'Conclusion'],
        types: [
            { value: 'literature-review', label: 'Literature Review' },
            { value: 'methodology', label: 'Methodology' },
            { value: 'analysis', label: 'Analysis' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'theory', label: 'Theoretical Framework' },
            { value: 'evidence', label: 'Evidence' },
            { value: 'argument', label: 'Argument' },
            { value: 'conclusion', label: 'Conclusion' }
        ],
        description: 'Structure academic papers and dissertations',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'üìù Current word count for this section' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'üéØ Goal word count for this section' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: '‚úèÔ∏è Current revision stage' },
            citations: { label: 'Key Citations', type: 'textarea', placeholder: 'List main sources and references...', helpText: 'üìö Important sources for this section' },
            keyArgument: { label: 'Key Argument', type: 'textarea', placeholder: 'Main point of this section...', helpText: 'üí° Central claim or thesis' },
            evidenceType: { label: 'Evidence Type', type: 'select', options: ['Empirical', 'Theoretical', 'Mixed', 'N/A'], helpText: 'üî¨ Nature of supporting evidence' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    roadmap: {
        name: 'Product Roadmap',
        icon: 'üöÄ',
        levels: {
            root: 'Product',
            phase: 'Quarter',
            item: 'Feature',
            subtask: 'Story'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'core-feature', label: 'Core Feature' },
            { value: 'enhancement', label: 'Enhancement' },
            { value: 'bug-fix', label: 'Bug Fix' },
            { value: 'technical-debt', label: 'Technical Debt' },
            { value: 'research', label: 'Research/Spike' },
            { value: 'platform', label: 'Platform' },
            { value: 'integration', label: 'Integration' },
            { value: 'ux', label: 'UX Improvement' }
        ],
        description: 'Plan product features across quarters',
        fields: {
            storyPoints: { label: 'Story Points', type: 'number', min: 0, step: 1, placeholder: '1, 2, 3, 5, 8, 13...', helpText: 'üéØ Effort estimate (Fibonacci scale)' },
            engineeringEstimate: { label: 'Engineering Estimate', type: 'text', placeholder: '2 weeks, 1 sprint, 3 days...', helpText: '‚è±Ô∏è Time estimate from engineering' },
            userImpact: { label: 'User Impact', type: 'select', options: ['High', 'Medium', 'Low'], helpText: 'üë• How many users does this affect?' },
            technicalRisk: { label: 'Technical Risk', type: 'select', options: ['Low', 'Medium', 'High', 'Unknown'], helpText: '‚ö†Ô∏è Complexity and technical uncertainty' },
            featureFlag: { label: 'Feature Flag', type: 'text', placeholder: 'flag_name...', helpText: 'üö© Feature flag for gradual rollout' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    book: {
        name: 'Book Writing',
        icon: 'üìö',
        levels: {
            root: 'Book',
            phase: 'Part',
            item: 'Chapter',
            subtask: 'Scene'
        },
        phaseSubtitles: ['Act I', 'Act II', 'Act III'],
        types: [
            { value: 'narrative', label: 'Narrative' },
            { value: 'dialogue', label: 'Dialogue' },
            { value: 'description', label: 'Description' },
            { value: 'action', label: 'Action' },
            { value: 'reflection', label: 'Reflection' },
            { value: 'transition', label: 'Transition' },
            { value: 'climax', label: 'Climax' },
            { value: 'exposition', label: 'Exposition' }
        ],
        description: 'Organize books into parts, chapters, and scenes',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'üìù Current word count' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'üéØ Goal word count' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: '‚úèÔ∏è Current revision stage' },
            povCharacter: { label: 'POV Character', type: 'text', placeholder: 'Whose perspective...', helpText: 'üë§ Point-of-view character' },
            sceneSetting: { label: 'Scene Setting', type: 'textarea', placeholder: 'Location, time, mood...', helpText: 'üé≠ Where and when this takes place' },
            plotFunction: { label: 'Plot Function', type: 'select', options: ['Setup', 'Conflict', 'Resolution', 'Transition'], helpText: 'üìñ Role in story structure' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    event: {
        name: 'Event Planning',
        icon: 'üéâ',
        levels: {
            root: 'Event',
            phase: 'Stage',
            item: 'Activity',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Event', 'Event Day', 'Post-Event'],
        types: [
            { value: 'logistics', label: 'Logistics' },
            { value: 'catering', label: 'Catering' },
            { value: 'entertainment', label: 'Entertainment' },
            { value: 'venue', label: 'Venue' },
            { value: 'marketing', label: 'Marketing' },
            { value: 'registration', label: 'Registration' },
            { value: 'follow-up', label: 'Follow-up' },
            { value: 'av-tech', label: 'AV/Tech' }
        ],
        description: 'Plan events from prep to execution to follow-up',
        fields: {
            budget: { label: 'Budget ($)', type: 'number', step: 100, helpText: 'üí∞ Budget for this activity' },
            vendor: { label: 'Vendor/Supplier', type: 'text', placeholder: 'Company or person name...', helpText: 'üè¢ External vendor or supplier' },
            bookingDeadline: { label: 'Booking Deadline', type: 'date', helpText: 'üìÖ Last date to book/reserve' },
            guestCount: { label: 'Guest Count', type: 'number', min: 0, placeholder: 'Expected attendees...', helpText: 'üë• Number of expected guests' },
            location: { label: 'Location', type: 'text', placeholder: 'Venue, room, area...', helpText: 'üìç Where this takes place' },
            responsiblePerson: { label: 'Responsible Person', type: 'text', placeholder: 'Team member name...', helpText: 'üë§ Who\'s handling this' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    fitness: {
        name: 'Fitness Program',
        icon: 'üí™',
        levels: {
            root: 'Program',
            phase: 'Phase',
            item: 'Workout',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Foundation', 'Build', 'Peak'],
        types: [
            { value: 'strength', label: 'Strength Training' },
            { value: 'cardio', label: 'Cardio' },
            { value: 'flexibility', label: 'Flexibility' },
            { value: 'recovery', label: 'Recovery' },
            { value: 'nutrition', label: 'Nutrition' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'conditioning', label: 'Conditioning' },
            { value: 'mobility', label: 'Mobility' }
        ],
        description: 'Structure training programs with periodization',
        fields: {
            sets: { label: 'Sets', type: 'number', min: 0, step: 1, placeholder: 'Number of sets...', helpText: 'üî¢ Number of sets' },
            reps: { label: 'Reps', type: 'text', placeholder: '8-12, 10, AMRAP...', helpText: 'üîÅ Repetitions per set' },
            duration: { label: 'Duration', type: 'text', placeholder: '30 minutes, 45 sec...', helpText: '‚è±Ô∏è Time for this exercise/workout' },
            intensity: { label: 'Intensity Level', type: 'select', options: ['Light', 'Moderate', 'High', 'Max'], helpText: 'üî• Effort level' },
            equipment: { label: 'Equipment Needed', type: 'text', placeholder: 'Dumbbells, Barbell, Bodyweight...', helpText: 'üèãÔ∏è Required equipment' },
            formCues: { label: 'Form Cues', type: 'textarea', placeholder: 'Key technique reminders...', helpText: '‚úÖ Important form tips' },
            restPeriod: { label: 'Rest Period', type: 'text', placeholder: '60 sec, 2 min...', helpText: '‚è∏Ô∏è Rest between sets' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    strategy: {
        name: 'Strategic Plan',
        icon: 'üìä',
        levels: {
            root: 'Strategy',
            phase: 'Pillar',
            item: 'Initiative',
            subtask: 'Action'
        },
        phaseSubtitles: ['Planning', 'Execution', 'Review'],
        types: [
            { value: 'market-expansion', label: 'Market Expansion' },
            { value: 'operational', label: 'Operational Excellence' },
            { value: 'financial', label: 'Financial' },
            { value: 'hr', label: 'Human Resources' },
            { value: 'technology', label: 'Technology' },
            { value: 'risk-management', label: 'Risk Management' },
            { value: 'innovation', label: 'Innovation' },
            { value: 'customer', label: 'Customer Experience' }
        ],
        description: 'Organize business strategy into pillars and initiatives',
        fields: {
            investment: { label: 'Investment ($)', type: 'number', step: 10000, helpText: 'üí∞ Capital investment required' },
            keyMetric: { label: 'Key Metric', type: 'text', placeholder: 'What defines success...', helpText: 'üìä Success measurement' },
            targetValue: { label: 'Target Value', type: 'text', placeholder: 'Goal for metric...', helpText: 'üéØ Goal to achieve' },
            responsibleExecutive: { label: 'Responsible Executive', type: 'text', placeholder: 'C-level owner...', helpText: 'üëî Executive sponsor' },
            strategicTheme: { label: 'Strategic Theme', type: 'select', options: ['Growth', 'Efficiency', 'Innovation', 'Transformation', 'Risk Mitigation'], helpText: 'üé≠ Strategic category' },
            riskLevel: { label: 'Risk Level', type: 'select', options: ['Low', 'Medium', 'High'], helpText: '‚ö†Ô∏è Implementation risk' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    course: {
        name: 'Course Design',
        icon: 'üìñ',
        levels: {
            root: 'Course',
            phase: 'Unit',
            item: 'Lesson',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Beginning', 'Middle', 'Advanced'],
        types: [
            { value: 'lecture', label: 'Lecture' },
            { value: 'lab', label: 'Lab/Practical' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'reading', label: 'Reading' },
            { value: 'project', label: 'Project' },
            { value: 'workshop', label: 'Workshop' },
            { value: 'field-work', label: 'Field Work' }
        ],
        description: 'Build educational curricula with units and lessons',
        fields: {
            learningObjectives: { label: 'Learning Objectives', type: 'textarea', placeholder: 'What students will learn...', helpText: 'üéì Expected learning outcomes' },
            duration: { label: 'Duration', type: 'text', placeholder: '50 minutes, 2 hours...', helpText: '‚è±Ô∏è Class time needed' },
            difficultyLevel: { label: 'Difficulty Level', type: 'select', options: ['Beginner', 'Intermediate', 'Advanced'], helpText: 'üìä Complexity level' },
            prerequisites: { label: 'Prerequisites', type: 'textarea', placeholder: 'Prior knowledge needed...', helpText: 'üìã Required background' },
            assessmentType: { label: 'Assessment Type', type: 'select', options: ['Quiz', 'Assignment', 'Project', 'Discussion', 'Exam', 'None'], helpText: '‚úÖ How learning is evaluated' },
            resourcesNeeded: { label: 'Resources Needed', type: 'textarea', placeholder: 'Textbook chapters, videos, materials...', helpText: 'üìö Required materials' },
            homework: { label: 'Homework', type: 'textarea', placeholder: 'Out-of-class work...', helpText: 'üìù Assignments for students' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    film: {
        name: 'AI Video Production',
        icon: 'üé¨',
        levels: {
            root: 'Film',
            phase: 'Act',
            item: 'Scene',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Act I - Setup', 'Act II - Conflict', 'Act III - Resolution'],
        types: [
            { value: 'establishing', label: 'Establishing Shot' },
            { value: 'character-intro', label: 'Character Introduction' },
            { value: 'dialogue', label: 'Dialogue Scene' },
            { value: 'action', label: 'Action Sequence' },
            { value: 'montage', label: 'Montage' },
            { value: 'transition', label: 'Transition' },
            { value: 'climax', label: 'Climax' },
            { value: 'resolution', label: 'Resolution' }
        ],
        description: 'Create films using AI video generation (Sora, Veo, Runway, Pika)',
        fields: {
            aiPlatform: { label: 'AI Platform', type: 'select', options: ['Sora (OpenAI)', 'Veo 3 (Google)', 'Runway Gen-3', 'Pika 2.0', 'Kling AI', 'Luma Dream Machine', 'Haiper', 'Testing Multiple'], helpText: 'ü§ñ Which AI video model to use' },
            videoPrompt: { label: 'Video Prompt', type: 'textarea', placeholder: 'Detailed text-to-video prompt...', helpText: '‚úçÔ∏è Primary prompt describing the scene (be specific: camera movement, lighting, mood, action)' },
            visualStyle: { label: 'Visual Style', type: 'select', options: ['Photorealistic', 'Cinematic', 'Documentary', 'Anime', 'Pixar 3D', 'Stop Motion', 'Vintage Film', 'Noir', 'Sci-Fi', 'Fantasy'], helpText: 'üé® Overall aesthetic and look' },
            duration: { label: 'Duration', type: 'select', options: ['2 seconds', '4 seconds', '6 seconds', '10 seconds', '20 seconds', 'Extended (loop)'], helpText: '‚è±Ô∏è Video clip length' },
            aspectRatio: { label: 'Aspect Ratio', type: 'select', options: ['16:9 (Widescreen)', '9:16 (Vertical/Mobile)', '1:1 (Square)', '2.39:1 (Cinematic)', '4:3 (Classic)'], helpText: 'üìê Video dimensions for target platform' },
            cameraMovement: { label: 'Camera Movement', type: 'select', options: ['Static', 'Slow Pan', 'Dolly In', 'Dolly Out', 'Tracking Shot', 'Crane Up', 'Crane Down', 'Handheld', 'Orbiting'], helpText: 'üé• How camera moves through scene' },
            motionIntensity: { label: 'Motion Intensity', type: 'select', options: ['Minimal', 'Subtle', 'Moderate', 'Dynamic', 'Intense'], helpText: 'üåä Amount of movement and action' },
            lightingMood: { label: 'Lighting Mood', type: 'select', options: ['Golden Hour', 'Overcast', 'Night', 'Neon', 'Dramatic', 'Soft Natural', 'High Contrast', 'Backlit'], helpText: 'üí° Lighting setup and atmosphere' },
            iterationNotes: { label: 'Generation Notes', type: 'textarea', placeholder: 'Prompt refinements, variations tried, best practices learned...', helpText: 'üìù What worked, what didn\'t, prompt engineering insights' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    philosophy: {
        name: 'Philosophy',
        icon: 'ü§î',
        levels: {
            root: 'Dialogue',
            phase: 'Movement',
            item: 'Claim',
            subtask: 'Support'
        },
        phaseSubtitles: ['Opening Question', 'First Definition', 'Refutation', 'Second Attempt', 'Deeper Inquiry', 'Resolution'],
        types: [
            // Dialectical moves
            { value: 'question', label: '‚ùì Question' },
            { value: 'definition', label: 'üìê Definition' },
            { value: 'refutation', label: '‚ùå Refutation/Elenchus' },
            { value: 'premise', label: 'üìç Premise' },
            { value: 'conclusion', label: '‚úì Conclusion' },
            { value: 'objection', label: '‚ö†Ô∏è Objection' },
            { value: 'response', label: 'üí¨ Response' },
            { value: 'example', label: 'üìñ Example' },
            { value: 'analogy', label: 'üîÑ Analogy' },
            { value: 'distinction', label: '‚öñÔ∏è Distinction' },
            { value: 'paradox', label: 'üåÄ Paradox' },
            { value: 'thought-experiment', label: 'üí≠ Thought Experiment' },
            { value: 'aporia', label: 'ü§∑ Aporia (Impasse)' },
            // Philosophical domains
            { value: 'metaphysical', label: 'üåå Metaphysical' },
            { value: 'epistemological', label: 'üß† Epistemological' },
            { value: 'ethical', label: '‚öñÔ∏è Ethical' },
            { value: 'political', label: 'üèõÔ∏è Political' },
            { value: 'logical', label: 'üî¢ Logical' }
        ],
        description: 'Structure philosophical dialogues, treatises, and arguments with dialectical precision',
        fields: {
            speaker: { label: 'Speaker', type: 'text', placeholder: 'Socrates, Meno, etc...', helpText: 'üó£Ô∏è Who makes this claim or argument' },
            argumentType: { label: 'Argument Type', type: 'select', options: ['Deductive', 'Inductive', 'Abductive', 'Dialectical', 'Reductio ad Absurdum', 'Socratic Elenchus'], helpText: 'üéØ Type of reasoning employed' },
            validity: { label: 'Logical Validity', type: 'select', options: ['Valid', 'Invalid', 'Sound', 'Unsound', 'Uncertain'], helpText: '‚úì Logical soundness' },
            keyTerms: { label: 'Key Terms', type: 'text', placeholder: 'virtue, knowledge, piety...', helpText: 'üìù Central concepts defined or discussed' },
            premise1: { label: 'Premise 1', type: 'textarea', placeholder: 'First premise of argument...', helpText: '1Ô∏è‚É£ First assumption or claim' },
            premise2: { label: 'Premise 2', type: 'textarea', placeholder: 'Second premise...', helpText: '2Ô∏è‚É£ Second assumption or claim' },
            conclusion: { label: 'Conclusion', type: 'textarea', placeholder: 'What follows from premises...', helpText: '‚úì Logical conclusion' },
            objection: { label: 'Objection', type: 'textarea', placeholder: 'Main counterargument...', helpText: '‚ùå Key objection raised' },
            response: { label: 'Response to Objection', type: 'textarea', placeholder: 'How objection is addressed...', helpText: 'üí° Defense or reply to objection' },
            textualReference: { label: 'Textual Reference', type: 'text', placeholder: 'e.g., Meno 70a-72c, Republic 347c...', helpText: 'üìñ Stephanus number or page reference' },
            philosophicalSchool: { label: 'School of Thought', type: 'select', options: ['Pre-Socratic', 'Platonic', 'Aristotelian', 'Stoic', 'Epicurean', 'Skeptic', 'Medieval', 'Rationalist', 'Empiricist', 'Kantian', 'Hegelian', 'Phenomenological', 'Analytic', 'Continental', 'Pragmatist', 'Other'], helpText: 'üèõÔ∏è Philosophical tradition or school' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    prompting: {
        name: 'Prompt Engineering',
        icon: 'üß†',
        levels: {
            root: 'Prompt Library',
            phase: 'Category',
            item: 'Prompt',
            subtask: 'Test Case'
        },
        phaseSubtitles: ['Customer Support', 'Content Generation', 'Data Analysis', 'Code Assistance', 'Research', 'Creative Writing'],
        types: [
            { value: 'task-instruction', label: 'üí¨ Task Instruction' },
            { value: 'few-shot', label: 'üìö Few-Shot Examples' },
            { value: 'chain-of-thought', label: 'üß† Chain-of-Thought' },
            { value: 'structured-output', label: 'üìê Structured Output' },
            { value: 'xml-guided', label: 'üèóÔ∏è XML-Guided (Anthropic)' },
            { value: 'prefill-guided', label: 'üéØ Prefill-Guided (Claude)' },
            { value: 'production', label: '‚úÖ Production-Ready' },
            { value: 'experimental', label: 'üß™ Experimental' }
        ],
        description: 'Design and test AI prompts with best practices from OpenAI and Anthropic',
        fields: {
            systemPrompt: {
                label: 'System Prompt (Required)',
                type: 'textarea',
                placeholder: 'You are an expert customer support agent with 10 years of experience. You are helpful, empathetic, and solution-focused. Always maintain a professional yet friendly tone.',
                helpText: 'üë§ Define the AI\'s role, expertise, and behavior. This sets the foundation for all responses.'
            },
            userPromptTemplate: {
                label: 'User Prompt (Required)',
                type: 'textarea',
                placeholder: 'Analyze the following customer support ticket and provide a recommended response:\n\nTicket: {{ticket_text}}\nPriority: {{priority}}\nCustomer Tier: {{tier}}\n\nProvide:\n1. Issue summary\n2. Recommended resolution\n3. Escalation needed (yes/no)',
                helpText: 'üí¨ The main instruction telling the AI what to do. Use {{variables}} for dynamic content.'
            },
            fewShotExamples: {
                label: 'Examples (Recommended)',
                type: 'textarea',
                placeholder: '<example>\nInput: Customer reports login issue on mobile app\nOutput: {\n  "summary": "Authentication failure on iOS app",\n  "resolution": "Clear app cache and reinstall",\n  "escalate": "no"\n}\n</example>\n\n<example>\nInput: Customer requests refund for annual subscription\nOutput: {\n  "summary": "Refund request - annual plan",\n  "resolution": "Process pro-rated refund per policy",\n  "escalate": "yes"\n}\n</example>',
                helpText: 'üìö Show 2-3 examples of input ‚Üí output. This dramatically improves accuracy and consistency.'
            },
            outputFormat: {
                label: 'Output Format (Recommended)',
                type: 'textarea',
                placeholder: 'Return your response as JSON with this exact structure:\n{\n  "summary": "brief issue description",\n  "resolution": "recommended action",\n  "escalate": "yes or no"\n}',
                helpText: 'üìê Specify exactly how you want the output structured (JSON, markdown, bullet points, etc.)'
            },
            chainOfThought: {
                label: 'Chain-of-Thought (Optional)',
                type: 'textarea',
                placeholder: 'Before providing your answer, think through this step-by-step:\n1. What is the core issue?\n2. What are possible solutions?\n3. Which solution is best and why?',
                helpText: 'üß† Ask the AI to "think out loud" before answering. Improves reasoning quality.'
            },
            modelTarget: {
                label: 'Target Model',
                type: 'select',
                options: ['Claude 3.5 Sonnet', 'Claude 3 Opus', 'GPT-4o', 'GPT-4 Turbo', 'o1-preview'],
                helpText: 'ü§ñ Which AI model this prompt is optimized for'
            },
            temperature: {
                label: 'Temperature',
                type: 'number',
                min: 0,
                max: 1,
                step: 0.1,
                placeholder: '0.7',
                helpText: 'üå°Ô∏è 0 = consistent/factual, 1 = creative/varied. Use 0-0.3 for analysis, 0.7-1.0 for creative writing.'
            },
            testResults: {
                label: 'Test Results',
                type: 'textarea',
                placeholder: 'Tested on 50 examples:\n‚úÖ 94% accuracy\n‚ö° Avg response time: 1.3s\nüí∞ Cost per request: $0.015',
                helpText: '‚úÖ Track how well this prompt performs on real test cases'
            },
            testStatus: {
                label: 'Status',
                type: 'select',
                options: ['Draft', 'Testing', 'Validated', 'Production', 'Deprecated'],
                helpText: '‚úÖ Development stage'
            },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    familytree: {
        name: 'Family Tree',
        icon: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
        levels: {
            root: 'Family',
            phase: 'Generation',
            item: 'Person',
            subtask: 'Event'
        },
        phaseSubtitles: ['Self/Siblings', 'Parents', 'Grandparents', 'Great-Grandparents', 'Great-Great-Grandparents', 'Children', 'Grandchildren', 'Great-Grandchildren'],
        types: [
            { value: 'paternal', label: 'Paternal Line' },
            { value: 'maternal', label: 'Maternal Line' },
            { value: 'spouse', label: 'Spouse' },
            { value: 'biological', label: 'Biological' },
            { value: 'adopted', label: 'Adopted' },
            { value: 'step', label: 'Step-Family' },
            { value: 'foster', label: 'Foster' },
            { value: 'half', label: 'Half-Sibling' }
        ],
        description: 'Build and document your family genealogy',
        fields: {
            fullName: { label: 'Full Name', type: 'text', placeholder: 'First Middle Last...', helpText: 'üë§ Complete name including middle names' },
            maidenName: { label: 'Maiden Name', type: 'text', placeholder: 'Birth surname if different...', helpText: 'üíç Birth surname (if changed after marriage)' },
            gender: { label: 'Gender', type: 'select', options: ['Male', 'Female', 'Other', 'Unknown'], helpText: '‚öß Gender identity' },
            birthDate: { label: 'Birth Date', type: 'date', helpText: 'üéÇ Date of birth' },
            birthPlace: { label: 'Birth Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'üìç Place of birth (city, state, country)' },
            livingStatus: { label: 'Living Status', type: 'select', options: ['Living', 'Deceased', 'Unknown'], helpText: 'üíö Current living status' },
            deathDate: { label: 'Death Date', type: 'date', helpText: 'üïäÔ∏è Date of death (if deceased)' },
            deathPlace: { label: 'Death Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'üìç Place of death (if deceased)' },
            marriageDate: { label: 'Marriage Date', type: 'date', helpText: 'üíí Date of marriage' },
            marriagePlace: { label: 'Marriage Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'üìç Place of marriage ceremony' },
            spouseName: { label: 'Spouse Name', type: 'text', placeholder: 'Name of spouse...', helpText: 'üíë Current or former spouse' },
            occupation: { label: 'Occupation', type: 'text', placeholder: 'Profession or career...', helpText: 'üíº Primary occupation or career' },
            photoURL: { label: 'Photo URL', type: 'text', placeholder: 'https://...', helpText: 'üì∑ Link to portrait or photo' },
            dnaInfo: { label: 'DNA/Genetic Info', type: 'textarea', placeholder: 'Haplogroup, DNA matches, test results...', helpText: 'üß¨ DNA test results, haplogroups, genetic markers' },
            sources: { label: 'Sources/Citations', type: 'textarea', placeholder: 'Documents, certificates, records...', helpText: 'üìÑ Birth certificates, census records, documents' },
            relationshipType: { label: 'Relationship Type', type: 'select', options: ['Biological', 'Adopted', 'Step', 'Foster', 'Half-Sibling', 'Unknown'], helpText: 'üîó Type of family relationship' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    dialogue: {
        name: 'Dialogue & Rhetoric',
        icon: 'üí¨',
        levels: {
            root: 'Conversation',
            phase: 'Speaker',
            item: 'Statement',
            subtask: 'Point'
        },
        phaseSubtitles: ['Speaker A', 'Speaker B', 'Speaker C', 'Moderator'],
        types: [
            { value: 'logical', label: 'üß† Logical Argument' },
            { value: 'emotional', label: '‚ù§Ô∏è Emotional Appeal (Pathos)' },
            { value: 'ethical', label: '‚öñÔ∏è Ethical Appeal (Ethos)' },
            { value: 'statistical', label: 'üìä Statistical Evidence' },
            { value: 'anecdotal', label: 'üìñ Anecdotal Evidence' },
            { value: 'rhetorical-question', label: '‚ùì Rhetorical Question' },
            { value: 'counterargument', label: 'üîÑ Counterargument' },
            { value: 'deflection', label: '‚Ü©Ô∏è Deflection/Dodge' },
            { value: 'concession', label: 'ü§ù Concession/Agreement' }
        ],
        description: 'Analyze conversations, debates, and rhetoric to uncover hidden logic, fallacies, and motivations',
        fields: {
            speaker: {
                label: 'Speaker/Character',
                type: 'text',
                placeholder: 'e.g., Senator Jane Smith, John (protagonist), Anonymous commenter...',
                helpText: 'üë§ Who is making this statement? Include role, title, or context if known'
            },
            verbatimQuote: {
                label: 'Verbatim Quote',
                type: 'textarea',
                placeholder: 'Copy/paste the exact words spoken or written...',
                helpText: 'üí¨ The actual statement, word-for-word. Essential for accurate analysis of rhetoric and tone'
            },
            rhetoricalDevice: {
                label: 'Rhetorical Device Used',
                type: 'select',
                options: ['Logos (Logic)', 'Pathos (Emotion)', 'Ethos (Credibility)', 'Kairos (Timing)', 'Metaphor', 'Analogy', 'Repetition', 'Hyperbole', 'Irony', 'Appeal to Authority', 'None'],
                helpText: 'üé≠ Primary rhetorical technique used to persuade or communicate. Identify the dominant device'
            },
            logicalStructure: {
                label: 'Logical Structure',
                type: 'textarea',
                placeholder: 'Premise 1: All experts agree...\nPremise 2: Dr. Chen is an expert...\nConclusion: Therefore, Dr. Chen\'s view is valid',
                helpText: 'üß© Break down the argument into premises and conclusion. How does the speaker construct their logic?'
            },
            fallaciesPresent: {
                label: 'Fallacies Present',
                type: 'textarea',
                placeholder: 'Ad hominem: Attacks opponent\'s character instead of argument\nStraw man: Misrepresents opponent\'s position...',
                helpText: '‚ö†Ô∏è Identify any logical fallacies (ad hominem, straw man, slippery slope, false dichotomy, etc.) and explain how they appear'
            },
            hiddenMotivation: {
                label: 'Hidden Motivation/Subtext',
                type: 'textarea',
                placeholder: 'Surface: Arguing for policy change\nHidden: Positioning for re-election, deflecting from scandal, protecting financial interests...',
                helpText: 'üîç What unstated goals or motivations might underlie this statement? Consider political, financial, or personal incentives'
            },
            emotionalTone: {
                label: 'Emotional Tone',
                type: 'select',
                options: ['Calm/Neutral', 'Passionate', 'Angry', 'Defensive', 'Condescending', 'Empathetic', 'Dismissive', 'Fearful', 'Confident', 'Sarcastic'],
                helpText: 'üé≠ The emotional delivery and affect. How does tone enhance or undermine the message?'
            },
            counterargument: {
                label: 'Strongest Counterargument',
                type: 'textarea',
                placeholder: 'The strongest rebuttal would be: "While the speaker claims X, evidence shows Y because..."',
                helpText: 'üîÑ What is the most effective counter to this statement? Build the opposing case using logic and evidence'
            },
            evidenceQuality: {
                label: 'Evidence Quality',
                type: 'select',
                options: ['Strong (Peer-reviewed, verified)', 'Moderate (Credible sources)', 'Weak (Anecdotal, unverified)', 'None (Opinion only)', 'Misleading (Cherry-picked data)'],
                helpText: 'üìä Assess the strength and credibility of any evidence or data cited. Is it rigorous or rhetorical?'
            },
            effectivenessRating: {
                label: 'Persuasiveness Rating',
                type: 'number',
                min: 1,
                max: 10,
                step: 1,
                placeholder: '7',
                helpText: 'üéØ Rate 1-10: How persuasive is this statement to the target audience? (1=unconvincing, 10=highly compelling)'
            },
            includeDependencies: true,
            includeTracking: false
        }
    },
    filesystem: {
        name: 'File System',
        icon: 'üíæ',
        isFlexibleDepth: true,
        levels: {
            root: 'Drive',
            phase: 'Folder',
            item: 'File/Folder',
            subtask: 'File'
        },
        phaseSubtitles: ['Documents', 'Downloads', 'Desktop', 'Pictures', 'Videos', 'Projects'],
        types: [
            // Folder types
            { value: 'folder', label: 'üìÅ Folder' },
            { value: 'folder-shared', label: 'üìÇ Shared Folder' },
            { value: 'folder-cloud', label: '‚òÅÔ∏è Cloud Folder' },

            // Document types
            { value: 'pdf', label: 'üìï PDF' },
            { value: 'word', label: 'üìò Word Doc' },
            { value: 'excel', label: 'üìó Spreadsheet' },
            { value: 'powerpoint', label: 'üìô Presentation' },
            { value: 'text', label: 'üìù Text File' },
            { value: 'document', label: 'üìÑ Document' },

            // Media types
            { value: 'image', label: 'üñºÔ∏è Image' },
            { value: 'video', label: 'üé¨ Video' },
            { value: 'audio', label: 'üéµ Audio' },

            // Code types
            { value: 'code', label: 'üíª Code' },
            { value: 'html', label: 'üåê HTML' },
            { value: 'css', label: 'üé® CSS' },
            { value: 'javascript', label: '‚ö° JavaScript' },
            { value: 'python', label: 'üêç Python' },

            // Archive types
            { value: 'archive', label: 'üì¶ Archive' },
            { value: 'zip', label: 'üóúÔ∏è ZIP' },

            // Other
            { value: 'executable', label: '‚öôÔ∏è Executable' },
            { value: 'database', label: 'üóÑÔ∏è Database' },
            { value: 'unknown', label: '‚ùì Unknown' }
        ],
        description: 'Organize files and folders from local drives, Google Drive, and OneDrive',
        sortOptions: [
            { value: 'name-az', label: 'üî§ Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'üî§ Name (Z-A)', field: 'name', order: 'desc', type: 'text' },
            { value: 'size-large', label: 'üìä Size (Largest First)', field: 'fileSize', order: 'desc', type: 'number' },
            { value: 'size-small', label: 'üìä Size (Smallest First)', field: 'fileSize', order: 'asc', type: 'number' },
            { value: 'modified-newest', label: 'üïí Modified (Newest First)', field: 'dateModified', order: 'desc', type: 'date' },
            { value: 'modified-oldest', label: 'üïí Modified (Oldest First)', field: 'dateModified', order: 'asc', type: 'date' },
            { value: 'created-newest', label: 'üìÖ Created (Newest First)', field: 'dateCreated', order: 'desc', type: 'date' },
            { value: 'created-oldest', label: 'üìÖ Created (Oldest First)', field: 'dateCreated', order: 'asc', type: 'date' },
            { value: 'type-folders-first', label: 'üìÅ Type (Folders First)', field: 'isFolder', order: 'desc', type: 'boolean' },
            { value: 'type-files-first', label: 'üìÑ Type (Files First)', field: 'isFolder', order: 'asc', type: 'boolean' },
            { value: 'extension-az', label: 'üè∑Ô∏è Extension (A-Z)', field: 'fileExtension', order: 'asc', type: 'text' },
            { value: 'extension-za', label: 'üè∑Ô∏è Extension (Z-A)', field: 'fileExtension', order: 'desc', type: 'text' },
            { value: 'owner-az', label: 'üë§ Owner (A-Z)', field: 'fileOwner', order: 'asc', type: 'text' },
            { value: 'owner-za', label: 'üë§ Owner (Z-A)', field: 'fileOwner', order: 'desc', type: 'text' }
        ],
        fields: {
            fileSize: {
                label: 'File Size (bytes)',
                type: 'number',
                min: 0,
                step: 1,
                placeholder: '2500000',
                helpText: 'üìä Size in bytes (will be formatted as KB/MB/GB)'
            },
            fileExtension: {
                label: 'File Extension',
                type: 'text',
                placeholder: '.pdf, .docx, .jpg...',
                helpText: 'üè∑Ô∏è File type extension (e.g., .pdf, .docx, .mp4)'
            },
            filePath: {
                label: 'Full Path',
                type: 'text',
                placeholder: 'C:\\Users\\Documents\\file.pdf',
                helpText: 'üìÇ Complete file path'
            },
            dateModified: {
                label: 'Date Modified',
                type: 'datetime-local',
                helpText: 'üïí Last modification date and time'
            },
            dateCreated: {
                label: 'Date Created',
                type: 'datetime-local',
                helpText: 'üìÖ Creation date and time'
            },
            fileOwner: {
                label: 'Owner',
                type: 'text',
                placeholder: 'john.doe@company.com',
                helpText: 'üë§ File owner (for cloud files)'
            },
            sharedWith: {
                label: 'Shared With',
                type: 'textarea',
                placeholder: 'user1@email.com, user2@email.com...',
                helpText: 'üë• Users with access (for cloud files)'
            },
            permissions: {
                label: 'Permissions',
                type: 'select',
                options: ['Read Only', 'Read/Write', 'Owner', 'Viewer', 'Editor', 'Commenter'],
                helpText: 'üîí Access permissions'
            },
            driveType: {
                label: 'Drive Type',
                type: 'select',
                options: ['Local Drive', 'Google Drive', 'OneDrive', 'Dropbox', 'Network Drive', 'External Drive'],
                helpText: 'üíæ Storage location type'
            },
            mimeType: {
                label: 'MIME Type',
                type: 'text',
                placeholder: 'application/pdf, image/jpeg...',
                helpText: 'üìã File MIME type (for web/cloud files)'
            },
            tags: {
                label: 'Tags',
                type: 'text',
                placeholder: 'work, important, archive...',
                helpText: 'üè∑Ô∏è Custom tags for organization'
            },
            fileUrl: {
                label: 'Cloud URL',
                type: 'text',
                placeholder: 'https://drive.google.com/...',
                helpText: 'üîó Direct link to cloud file'
            },
            isFolder: {
                label: 'Is Folder',
                type: 'checkbox',
                helpText: 'üìÅ Check if this is a folder (not a file)'
            },
            includeDependencies: false,
            includeTracking: false
        }
    },
    gmail: {
        name: 'Email Workflow',
        icon: 'üìß',
        levels: {
            root: 'Inbox/Campaign',
            phase: 'Label/Stage',
            item: 'Thread',
            subtask: 'Message'
        },
        phaseSubtitles: ['Inbox', 'Sent', 'Important', 'Archive'],
        types: [
            { value: 'cold-outreach', label: '‚ùÑÔ∏è Cold Outreach' },
            { value: 'newsletter', label: 'üì∞ Newsletter' },
            { value: 'response', label: '‚Ü©Ô∏è Response' },
            { value: 'follow-up', label: '‚û°Ô∏è Follow-up' },
            { value: 'internal', label: 'üè¢ Internal Update' },
            { value: 'transactional', label: 'üßæ Transactional' }
        ],
        description: 'Import and analyze Gmail threads with full conversation context',
        sortOptions: [
            { value: 'date-newest', label: 'üìÖ Date (Newest First)', field: 'sendDate', order: 'desc', type: 'date' },
            { value: 'date-oldest', label: 'üìÖ Date (Oldest First)', field: 'sendDate', order: 'asc', type: 'date' },
            { value: 'subject-az', label: 'üî§ Subject (A-Z)', field: 'subjectLine', order: 'asc', type: 'text' },
            { value: 'subject-za', label: 'üî§ Subject (Z-A)', field: 'subjectLine', order: 'desc', type: 'text' },
            { value: 'messages-most', label: 'üí¨ Messages (Most First)', field: 'messageCount', order: 'desc', type: 'number' },
            { value: 'messages-least', label: 'üí¨ Messages (Least First)', field: 'messageCount', order: 'asc', type: 'number' }
        ],
        fields: {
            recipientEmail: {
                label: 'To (Email)',
                type: 'text',
                placeholder: 'client@company.com',
                helpText: 'üë§ Primary recipient address'
            },
            ccEmail: {
                label: 'CC',
                type: 'text',
                placeholder: 'manager@company.com',
                helpText: 'üë• Carbon copy recipients'
            },
            subjectLine: {
                label: 'Subject Line',
                type: 'text',
                placeholder: 'Meeting Request: Q4 Planning',
                helpText: 'üìù The email subject line'
            },
            emailBody: {
                label: 'Email Body',
                type: 'textarea',
                placeholder: 'Hi [Name],\n\nWriting to follow up on...',
                helpText: '‚úçÔ∏è The main content of the email'
            },
            sendDate: {
                label: 'Date Sent',
                type: 'date',
                helpText: 'üìÖ When this email was sent/received'
            },
            status: {
                label: 'Status',
                type: 'select',
                options: ['Draft', 'Ready', 'Sent', 'Replied', 'Archived'],
                helpText: 'üì¨ Email status'
            },
            threadId: {
                label: 'Thread ID',
                type: 'text',
                placeholder: 'Gmail thread ID',
                helpText: 'üîó Gmail thread identifier'
            },
            messageCount: {
                label: 'Message Count',
                type: 'number',
                min: 1,
                helpText: 'üí¨ Number of messages in this thread'
            },
            sender: {
                label: 'Sender',
                type: 'text',
                placeholder: 'john@company.com',
                helpText: 'üë§ Email sender'
            },
            labels: {
                label: 'Gmail Labels',
                type: 'text',
                placeholder: 'INBOX, IMPORTANT, SENT',
                helpText: 'üè∑Ô∏è Gmail labels/categories'
            },
            includeDependencies: true,
            includeTracking: true
        }
    },
    custom: {
        name: 'Custom Names',
        icon: '‚úèÔ∏è',
        levels: {
            root: 'Level 0',
            phase: 'Level 1',
            item: 'Level 2',
            subtask: 'Level 3'
        },
        description: 'Define your own names for all four levels',
        customizable: true
    }
};

// ============================================================================
// FILE SYSTEM ICON MAPPING
// ============================================================================

const FILE_ICON_MAP = {
    // Documents
    '.pdf': { icon: 'üìï', type: 'pdf' },
    '.doc': { icon: 'üìò', type: 'word' },
    '.docx': { icon: 'üìò', type: 'word' },
    '.odt': { icon: 'üìò', type: 'document' },

    // Spreadsheets
    '.xls': { icon: 'üìó', type: 'excel' },
    '.xlsx': { icon: 'üìó', type: 'excel' },
    '.csv': { icon: 'üìä', type: 'excel' },
    '.ods': { icon: 'üìä', type: 'excel' },

    // Presentations
    '.ppt': { icon: 'üìô', type: 'powerpoint' },
    '.pptx': { icon: 'üìô', type: 'powerpoint' },
    '.key': { icon: 'üìô', type: 'powerpoint' },
    '.odp': { icon: 'üìô', type: 'powerpoint' },

    // Text
    '.txt': { icon: 'üìù', type: 'text' },
    '.md': { icon: 'üìù', type: 'text' },
    '.rtf': { icon: 'üìù', type: 'text' },

    // Images
    '.jpg': { icon: 'üñºÔ∏è', type: 'image' },
    '.jpeg': { icon: 'üñºÔ∏è', type: 'image' },
    '.png': { icon: 'üñºÔ∏è', type: 'image' },
    '.gif': { icon: 'üé®', type: 'image' },
    '.bmp': { icon: 'üñºÔ∏è', type: 'image' },
    '.svg': { icon: 'üé®', type: 'image' },
    '.webp': { icon: 'üñºÔ∏è', type: 'image' },

    // Videos
    '.mp4': { icon: 'üé¨', type: 'video' },
    '.avi': { icon: 'üé¨', type: 'video' },
    '.mov': { icon: 'üé¨', type: 'video' },
    '.mkv': { icon: 'üé¨', type: 'video' },
    '.webm': { icon: 'üé¨', type: 'video' },
    '.flv': { icon: 'üé¨', type: 'video' },

    // Audio
    '.mp3': { icon: 'üéµ', type: 'audio' },
    '.wav': { icon: 'üéµ', type: 'audio' },
    '.flac': { icon: 'üéµ', type: 'audio' },
    '.aac': { icon: 'üéµ', type: 'audio' },
    '.ogg': { icon: 'üéµ', type: 'audio' },
    '.m4a': { icon: 'üéµ', type: 'audio' },

    // Code
    '.html': { icon: 'üåê', type: 'html' },
    '.htm': { icon: 'üåê', type: 'html' },
    '.css': { icon: 'üé®', type: 'css' },
    '.js': { icon: '‚ö°', type: 'javascript' },
    '.jsx': { icon: '‚ö°', type: 'javascript' },
    '.ts': { icon: 'üíô', type: 'javascript' },
    '.tsx': { icon: 'üíô', type: 'javascript' },
    '.py': { icon: 'üêç', type: 'python' },
    '.java': { icon: '‚òï', type: 'code' },
    '.cpp': { icon: '‚öôÔ∏è', type: 'code' },
    '.c': { icon: '‚öôÔ∏è', type: 'code' },
    '.php': { icon: 'üêò', type: 'code' },
    '.rb': { icon: 'üíé', type: 'code' },
    '.go': { icon: 'üîµ', type: 'code' },
    '.rs': { icon: 'ü¶Ä', type: 'code' },
    '.json': { icon: 'üìã', type: 'code' },
    '.xml': { icon: 'üìã', type: 'code' },
    '.yaml': { icon: 'üìã', type: 'code' },
    '.yml': { icon: 'üìã', type: 'code' },

    // Archives
    '.zip': { icon: 'üóúÔ∏è', type: 'zip' },
    '.rar': { icon: 'üì¶', type: 'archive' },
    '.7z': { icon: 'üì¶', type: 'archive' },
    '.tar': { icon: 'üì¶', type: 'archive' },
    '.gz': { icon: 'üì¶', type: 'archive' },

    // Executables
    '.exe': { icon: '‚öôÔ∏è', type: 'executable' },
    '.msi': { icon: '‚öôÔ∏è', type: 'executable' },
    '.app': { icon: '‚öôÔ∏è', type: 'executable' },
    '.dmg': { icon: 'üíø', type: 'executable' },
    '.deb': { icon: 'üì¶', type: 'executable' },

    // Database
    '.db': { icon: 'üóÑÔ∏è', type: 'database' },
    '.sqlite': { icon: 'üóÑÔ∏è', type: 'database' },
    '.sql': { icon: 'üóÑÔ∏è', type: 'database' },

    // Default
    'default': { icon: '‚ùì', type: 'unknown' }
};

const FOLDER_ICON_MAP = {
    'default': 'üìÅ',
    'open': 'üìÇ',
    'shared': 'üë•',
    'cloud': '‚òÅÔ∏è',
    'system': '‚öôÔ∏è',
    'user': 'üë§',
    'downloads': 'üì•',
    'documents': 'üìÑ',
    'pictures': 'üñºÔ∏è',
    'videos': 'üé¨',
    'music': 'üéµ',
    'desktop': 'üñ•Ô∏è',
    'trash': 'üóëÔ∏è'
};

function getFileIcon(fileName, isFolder = false) {
    if (isFolder) {
        // Check for special folder names
        const folderNameLower = fileName.toLowerCase();
        if (folderNameLower.includes('download')) return FOLDER_ICON_MAP.downloads;
        if (folderNameLower.includes('document')) return FOLDER_ICON_MAP.documents;
        if (folderNameLower.includes('picture') || folderNameLower.includes('photo')) return FOLDER_ICON_MAP.pictures;
        if (folderNameLower.includes('video') || folderNameLower.includes('movie')) return FOLDER_ICON_MAP.videos;
        if (folderNameLower.includes('music') || folderNameLower.includes('audio')) return FOLDER_ICON_MAP.music;
        if (folderNameLower.includes('desktop')) return FOLDER_ICON_MAP.desktop;
        if (folderNameLower.includes('trash') || folderNameLower.includes('recycle')) return FOLDER_ICON_MAP.trash;
        if (folderNameLower.includes('user')) return FOLDER_ICON_MAP.user;
        return FOLDER_ICON_MAP.default;
    }

    // Extract extension
    const ext = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
    const mapping = FILE_ICON_MAP[ext] || FILE_ICON_MAP.default;
    return mapping.icon;
}

function getFileType(fileName, isFolder = false) {
    if (isFolder) return 'folder';
    const ext = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
    const mapping = FILE_ICON_MAP[ext] || FILE_ICON_MAP.default;
    return mapping.type;
}

// ============================================================================
// PATTERN STATE
// ============================================================================

let currentPattern = 'generic';
let customPatternNames = null;
let currentSortConfig = null; // Stores current sort configuration

// ============================================================================
// PATTERN FUNCTIONS
// ============================================================================

function getPatternLabels() {
    console.log('getPatternLabels called, currentPattern:', currentPattern);
    if (currentPattern === 'custom' && customPatternNames) {
        console.log('Returning custom labels:', customPatternNames);
        return customPatternNames;
    }
    const labels = PATTERNS[currentPattern].levels;
    console.log('Returning pattern labels:', labels);
    return labels;
}

function renameNodesForPattern(node, labels) {
    if (!node) return;

    // Collect all possible terms from all patterns for replacement
    const allRootTerms = ['Project', 'Pipeline', 'Thesis', 'Product', 'Book', 'Event', 'Program', 'Strategy', 'Course', 'Film', 'Treatise', 'Family'];
    const allPhaseTerms = ['Phase', 'Quarter', 'Chapter', 'Part', 'Stage', 'Pillar', 'Unit', 'Generation'];
    const allItemTerms = ['Item', 'Deal', 'Section', 'Feature', 'Chapter', 'Activity', 'Workout', 'Initiative', 'Lesson', 'Scene', 'Argument', 'Person'];
    const allSubtaskTerms = ['Task', 'Sub-task', 'Action', 'Point', 'Story', 'Scene', 'Exercise', 'Shot', 'Premise', 'Event'];

    // Rename based on node type - replace ANY pattern term with the new one
    if (node.type === 'root') {
        // Try to replace any root term from any pattern
        for (const term of allRootTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.root);
        }
    } else if (node.type === 'phase') {
        // Try to replace any phase term from any pattern
        for (const term of allPhaseTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.phase);
        }
        // Update phase subtitle based on pattern
        if (PATTERNS[currentPattern].phaseSubtitles && node.phase !== undefined) {
            const phaseIndex = parseInt(node.phase);
            if (!isNaN(phaseIndex) && phaseIndex < PATTERNS[currentPattern].phaseSubtitles.length) {
                node.subtitle = PATTERNS[currentPattern].phaseSubtitles[phaseIndex];
            }
        }
    } else if (node.type === 'item') {
        // Try to replace any item term from any pattern
        for (const term of allItemTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.item);
        }
    } else if (node.type === 'subtask') {
        // Try to replace any subtask term from any pattern
        for (const term of allSubtaskTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.subtask);
        }
    }

    // Recursively process children
    if (node.children) {
        node.children.forEach(child => renameNodesForPattern(child, labels));
    }

    // Process items in phases
    if (node.items) {
        node.items.forEach(item => {
            renameNodesForPattern(item, labels);
            // Process subtasks
            if (item.subItems) {
                item.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
            }
        });
    }

    // Process nested subtasks
    if (node.subItems) {
        node.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
    }
}

function applyPattern(patternKey) {
    console.log('applyPattern called with:', patternKey);
    currentPattern = patternKey;

    if (patternKey === 'custom') {
        showCustomPatternDialog();
    } else {
        // Store in data
        if (!capexTree.pattern) {
            capexTree.pattern = {};
        }
        capexTree.pattern.key = patternKey;
        capexTree.pattern.labels = PATTERNS[patternKey].levels;
        console.log('Pattern applied:', PATTERNS[patternKey].name);
        console.log('New labels:', PATTERNS[patternKey].levels);

        // Auto-rename existing nodes to match pattern
        renameNodesForPattern(capexTree, PATTERNS[patternKey].levels);
        console.log('Nodes renamed to match pattern');

        // Re-render to apply new labels
        render();

        // Update sort dropdown for new pattern
        updateSortDropdown();
    }
}

// Populate sort dropdown based on current pattern
function updateSortDropdown() {
    console.log('üîÑ updateSortDropdown called, currentPattern:', currentPattern);

    const sortSection = document.getElementById('sort-section');
    const sortSelect = document.getElementById('pattern-sort-select');

    if (!sortSection || !sortSelect) {
        console.log('‚ùå Sort elements not found in DOM');
        return;
    }

    const pattern = PATTERNS[currentPattern];
    console.log('Pattern object:', pattern ? pattern.name : 'undefined');

    // Check if pattern has sortOptions
    if (pattern && pattern.sortOptions && pattern.sortOptions.length > 0) {
        // Show sort section
        sortSection.style.display = 'flex';

        // Clear existing options
        const previousCount = sortSelect.options.length;
        sortSelect.innerHTML = '<option value="">Default Order</option>';

        // Add pattern-specific sort options
        pattern.sortOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.label;
            opt.dataset.field = option.field;
            opt.dataset.order = option.order;
            opt.dataset.type = option.type;
            sortSelect.appendChild(opt);
        });

        console.log(`‚úÖ Sort dropdown updated: ${previousCount} ‚Üí ${sortSelect.options.length} options (${pattern.sortOptions.length} + Default) for "${currentPattern}" pattern`);
    } else {
        // Hide sort section if pattern has no sort options
        sortSection.style.display = 'none';
        console.log(`‚ö†Ô∏è Pattern "${currentPattern}" has no sort options`);
    }
}

function showCustomPatternDialog() {
    const pattern = PATTERNS[currentPattern];
    const currentLabels = customPatternNames || pattern.levels;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = `
        <div style="padding: 20px;">
            <h3 style="color: var(--treeplex-primary); margin-bottom: 20px;">Custom Pattern Names</h3>
            <p style="margin-bottom: 20px; color: var(--text-secondary); font-size: 14px;">
                Define your own names for each level of your project structure.
            </p>

            <div style="display: flex; flex-direction: column; gap: 16px;">
                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 0 (Root):
                    </label>
                    <input type="text" id="custom-root" value="${currentLabels.root}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Project, Campaign, Thesis">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 1 (Phase):
                    </label>
                    <input type="text" id="custom-phase" value="${currentLabels.phase}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Phase, Quarter, Chapter">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 2 (Item):
                    </label>
                    <input type="text" id="custom-item" value="${currentLabels.item}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Item, Feature, Section">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 3 (Subtask):
                    </label>
                    <input type="text" id="custom-subtask" value="${currentLabels.subtask}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Task, Story, Point">
                </div>
            </div>

            <div style="display: flex; gap: 12px; margin-top: 24px;">
                <button class="btn btn-primary" onclick="saveCustomPattern()" style="flex: 1;">
                    ‚úì Apply Custom Names
                </button>
                <button class="btn" onclick="closeModal()" style="flex: 1;">
                    Cancel
                </button>
            </div>
        </div>
    `;

    document.getElementById('modal').style.display = 'flex';
}

function saveCustomPattern() {
    const root = document.getElementById('custom-root').value.trim() || 'Level 0';
    const phase = document.getElementById('custom-phase').value.trim() || 'Level 1';
    const item = document.getElementById('custom-item').value.trim() || 'Level 2';
    const subtask = document.getElementById('custom-subtask').value.trim() || 'Level 3';

    customPatternNames = { root, phase, item, subtask };

    // Store in data
    if (!capexTree.pattern) {
        capexTree.pattern = {};
    }
    capexTree.pattern.key = 'custom';
    capexTree.pattern.labels = customPatternNames;

    closeModal();
    render();
}

// ============================================================================
// INITIALIZATION
// ============================================================================


function showPatternDescription() {
    const select = document.getElementById('pattern-select');
    const selectedOption = select.options[select.selectedIndex];
    const desc = selectedOption.getAttribute('data-desc');

    if (desc) {
        select.setAttribute('title', desc);
    }
}

function hidePatternDescription() {
    // Keep title for basic tooltip
}

        // State
        let activeNode = null;

        // Utilities
        function formatCost(cost) {
            // Handle null, undefined, or non-numeric values
            if (cost === null || cost === undefined || cost === '' || isNaN(cost)) {
                return '$0';
            }

            // Convert to number if it's a string
            const numCost = typeof cost === 'string' ? parseFloat(cost) : cost;

            if (numCost >= 1000000) return '$' + (numCost / 1000000).toFixed(1) + 'M';
            if (numCost >= 1000) return '$' + (numCost / 1000).toFixed(0) + 'k';
            return '$' + numCost.toLocaleString();
        }

        // Calculate total including all children (for root node)
        function calculateTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            if (node.children) {
                node.children.forEach(child => {
                    total += calculateTotal(child);
                });
            }
            return total;
        }

        // Calculate only items in this phase (NOT children phases)
        function calculatePhaseTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            return total;
        }

        function findNode(id, node = capexTree) {
            if (node.id === id) return node;
            if (node.children) {
                for (let child of node.children) {
                    const found = findNode(id, child);
                    if (found) return found;
                }
            }
            return null;
        }

        // Render tree - phases flow left to right
        function render() {
            const container = document.getElementById('tree-root');
            container.innerHTML = '';

            const tableEl = document.createElement('div');
            tableEl.className = 'tree';

            // FILESYSTEM PATTERN: Use vertical tree layout
            if (currentPattern === 'filesystem') {
                tableEl.classList.add('filesystem-tree');

                function buildFilesystemNode(node, depth = 0) {
                    // Initialize expanded property if not set
                    if (node.expanded === undefined) {
                        node.expanded = (depth === 0 || depth === 1); // Auto-expand root and drives
                    }

                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = `tree-node ${node.type} filesystem-indent-${depth}`;
                    if (node.expanded) nodeDiv.classList.add('expanded');
                    else nodeDiv.classList.add('collapsed');
                    nodeDiv.dataset.nodeId = node.id;

                    // Build node content
                    if (node.type === 'root') {
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0) || (node.children && node.children.length > 0);
                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? '‚ñº' : '‚ñ∂') + '</span>' : ''}
                                <span class="node-icon">${node.icon}</span>
                                <div class="node-content">
                                    <div class="node-title">${node.name}</div>
                                </div>
                            </div>
                        `;
                    } else if (node.type === 'phase') {
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0) || (node.children && node.children.length > 0);
                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? '‚ñº' : '‚ñ∂') + '</span>' : ''}
                                <span class="node-icon">${node.icon}</span>
                                <div class="node-content">
                                    <div class="node-title">${node.name}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        // Item/Subtask - file or folder
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0);
                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? '‚ñº' : '‚ñ∂') + '</span>' : ''}
                                <span class="node-icon">${node.icon}</span>
                                <div class="node-content">
                                    <span class="item-name">${node.name}</span>
                                </div>
                            </div>
                        `;
                    }

                    // Event listeners
                    nodeDiv.addEventListener('click', (e) => {
                        e.stopPropagation();

                        const hasChildren = (node.items && node.items.length > 0) ||
                                          (node.subItems && node.subItems.length > 0) ||
                                          (node.children && node.children.length > 0);

                        console.log('Clicked node:', node.name, {
                            type: node.type,
                            hasItems: node.items?.length || 0,
                            hasSubItems: node.subItems?.length || 0,
                            hasChildren: node.children?.length || 0,
                            expanded: node.expanded,
                            hasChildrenTotal: hasChildren
                        });

                        if (hasChildren) {
                            node.expanded = !node.expanded;
                            console.log('‚Üí Toggled', node.name, 'to', node.expanded ? 'EXPANDED' : 'COLLAPSED');

                            // Preserve scroll position during re-render
                            const treeContainer = document.getElementById('tree-container');
                            const scrollPos = treeContainer ? treeContainer.scrollTop : 0;

                            render();

                            // Restore scroll position after render
                            if (treeContainer) {
                                setTimeout(() => {
                                    treeContainer.scrollTop = scrollPos;
                                }, 0);
                            }
                        } else {
                            console.log('‚Üí No children, showing info panel');
                            showInfo(node);
                        }
                    });

                    nodeDiv.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        activeNode = node;
                        showContextMenu(e.pageX, e.pageY);
                    });

                    tableEl.appendChild(nodeDiv);

                    // Recursively render children if expanded
                    if (node.expanded) {
                        if (node.children && node.children.length > 0) {
                            node.children.forEach(child => buildFilesystemNode(child, depth + 1));
                        }
                        if (node.items && node.items.length > 0) {
                            node.items.forEach(item => buildFilesystemNode(item, depth + 1));
                        }
                        if (node.subItems && node.subItems.length > 0) {
                            node.subItems.forEach(subItem => buildFilesystemNode(subItem, depth + 1));
                        }
                    }
                }

                // Start rendering from root
                buildFilesystemNode(capexTree, 0);

                container.appendChild(tableEl);
                return;
            }

            // DEFAULT PATTERN: Use horizontal column layout
            // Traverse and build columns
            function buildColumn(node) {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'tree-level';

                // Render current node
                const nodeDiv = document.createElement('div');
                nodeDiv.className = `tree-node ${node.type}`;
                if (node.type === 'phase') nodeDiv.classList.add(`phase-${node.phase}`);
                if (node.expanded) nodeDiv.classList.add('expanded');
                else nodeDiv.classList.add('collapsed');

                nodeDiv.dataset.nodeId = node.id;

                if (node.type === 'root') {
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon}</span>
                            <div class="node-content">
                                <div class="node-title">${node.name}</div>
                                <div class="node-subtitle">by geej</div>
                            </div>
                            ${node.children ? '<span class="expand-toggle">‚ñ∂</span>' : ''}
                        </div>
                    `;
                } else if (node.type === 'phase') {
                    const total = calculatePhaseTotal(node);
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon}</span>
                            <div class="node-content">
                                <div class="node-title">${node.name}</div>
                                <div class="node-subtitle">${node.subtitle}</div>
                                ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<div class="node-cost">${formatCost(total)}</div>` : ''}
                            </div>
                            ${node.items || node.children ? '<span class="expand-toggle">‚ñ∂</span>' : ''}
                        </div>
                    `;
                } else {
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon}</span>
                            <div class="node-content">
                                <div class="item-name">${node.name}</div>
                                <div class="item-description">${node.description}</div>
                                <div class="item-meta">
                                    ${node.itemType ? `<span class="badge badge-${node.itemType}">${node.itemType}</span>` : ''}
                                    ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<span class="item-cost">${formatCost(node.cost)}</span>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }

                nodeDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if ((node.items && node.items.length > 0) || (node.children && node.children.length > 0)) {
                        node.expanded = !node.expanded;

                        // Preserve scroll position during re-render
                        const treeContainer = document.getElementById('tree-container');
                        const scrollPos = treeContainer ? treeContainer.scrollTop : 0;

                        render();

                        // Restore scroll position after render
                        if (treeContainer) {
                            setTimeout(() => {
                                treeContainer.scrollTop = scrollPos;
                            }, 0);
                        }
                    } else {
                        showInfo(node);
                    }
                });

                nodeDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    activeNode = node;
                    showContextMenu(e.pageX, e.pageY);
                });

                levelDiv.appendChild(nodeDiv);
                tableEl.appendChild(levelDiv);

                // If expanded, show items in next column, then next phase in following column
                if (node.expanded) {
                    // Show items if any
                    if (node.items && node.items.length > 0) {
                        const itemsColumn = document.createElement('div');
                        itemsColumn.className = 'tree-level';

                        // Get all item IDs in this phase to check for same-phase dependencies
                        const phaseItemIds = node.items.map(i => i.id);

                        // Topological sort: order items by dependencies
                        // Items with no same-phase dependencies first, then items that depend on them
                        function topologicalSort(items, phaseIds) {
                            const sorted = [];
                            const visited = new Set();
                            const visiting = new Set();

                            function visit(item) {
                                if (visited.has(item.id)) return;
                                if (visiting.has(item.id)) {
                                    // Circular dependency - just add it
                                    sorted.push(item);
                                    visited.add(item.id);
                                    return;
                                }

                                visiting.add(item.id);

                                // Visit dependencies first (only same-phase dependencies)
                                if (item.dependencies) {
                                    // Handle both array and string formats
                                    const deps = Array.isArray(item.dependencies) ? item.dependencies : [];
                                    deps.forEach(depId => {
                                        if (phaseIds.includes(depId)) {
                                            const depItem = items.find(i => i.id === depId);
                                            if (depItem) {
                                                visit(depItem);
                                            }
                                        }
                                    });
                                }

                                visiting.delete(item.id);
                                visited.add(item.id);
                                sorted.push(item);
                            }

                            items.forEach(item => visit(item));
                            return sorted;
                        }

                        // Calculate dependency depth/level for hierarchical indentation
                        // Returns the depth in the dependency chain (0 = no deps, 1 = direct child, 2 = grandchild, etc.)
                        function calculateDependencyLevel(item, phaseItems, phaseItemIds, visited = new Set()) {
                            // Base case: no same-phase dependencies
                            if (!item.dependencies || item.dependencies.length === 0) {
                                return 0;
                            }

                            const samePhaseDeps = item.dependencies.filter(depId => phaseItemIds.includes(depId));
                            if (samePhaseDeps.length === 0) {
                                return 0;
                            }

                            // Prevent circular dependency infinite loops
                            if (visited.has(item.id)) {
                                return 0;
                            }

                            visited.add(item.id);

                            // Find max depth among all same-phase dependencies
                            let maxLevel = 0;
                            samePhaseDeps.forEach(depId => {
                                const depItem = phaseItems.find(i => i.id === depId);
                                if (depItem) {
                                    const depLevel = calculateDependencyLevel(depItem, phaseItems, phaseItemIds, new Set(visited));
                                    maxLevel = Math.max(maxLevel, depLevel + 1);
                                }
                            });

                            return maxLevel;
                        }

                        // Use topological sort only when no custom sort is active
                        const sortedItems = (typeof currentSortConfig !== 'undefined' && currentSortConfig !== null)
                            ? node.items  // Use existing order when user has sorted
                            : topologicalSort(node.items, phaseItemIds);  // Use dependency-based order otherwise

                        sortedItems.forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = `tree-node item phase-${node.phase}`;
                            itemDiv.dataset.itemId = item.id; // Add item ID for dependency linking

                            // Calculate dependency depth for hierarchical indentation
                            const dependencyLevel = calculateDependencyLevel(item, node.items, phaseItemIds);

                            // Add multi-level indentation based on dependency depth
                            // Level 0 = no indent, Level 1 = 20px, Level 2 = 40px, Level 3 = 60px, etc.
                            if (dependencyLevel > 0) {
                                itemDiv.classList.add('has-same-phase-dependency');
                                itemDiv.style.marginLeft = `${dependencyLevel * 20}px`;
                                itemDiv.style.position = 'relative';
                                itemDiv.dataset.dependencyLevel = dependencyLevel; // Store for potential visual enhancements
                            }

                            // Add expanded class if item has subtasks and is expanded
                            if (item.subItems && item.subItems.length > 0 && item.expanded) {
                                itemDiv.classList.add('has-expanded-subtasks');
                            }

                            // Add dependency indicator
                            const depInfo = item.dependencies && item.dependencies.length > 0
                                ? `<div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">Depends: ${item.dependencies.join(', ')}</div>`
                                : '';

                            // Check if item has subtasks for expand/collapse indicator
                            const hasSubtasks = item.subItems && item.subItems.length > 0;
                            const expandIndicator = hasSubtasks
                                ? `<span class="expand-toggle" onclick="event.stopPropagation(); window.toggleSubtasks('${item.id}');" style="margin-left: 8px; font-size: 12px; opacity: 0.7; cursor: pointer; user-select: none;">${item.expanded ? '‚ñº' : '‚ñ∂'}</span>`
                                : '';

                            // RAG Status indicator
                            const ragStatusColors = {
                                'Green': '#22C55E',
                                'Amber': '#F59E0B',
                                'Red': '#EF4444'
                            };
                            const itemRAGStatus = item.pmRAGStatus;
                            const ragIndicator = itemRAGStatus ?
                                `<span style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: ${ragStatusColors[itemRAGStatus]}; margin-left: 8px; box-shadow: 0 0 6px ${ragStatusColors[itemRAGStatus]}80; vertical-align: middle;" title="RAG Status: ${itemRAGStatus}"></span>` : '';

                            // PM Status badge
                            const pmStatusBadge = item.pmStatus && item.pmStatus !== 'To Do' ?
                                `<span style="font-size: 10px; padding: 2px 6px; border-radius: 4px; background: ${item.pmStatus === 'Completed' ? '#22C55E' : item.pmStatus === 'Blocked' ? '#EF4444' : '#3B82F6'}; color: white; margin-left: 8px; font-weight: 600;">${item.pmStatus}</span>` : '';

                            itemDiv.innerHTML = `
                                <div class="node-header">
                                    <span class="node-icon">${item.icon}</span>
                                    <div class="node-content">
                                        <div class="item-name">
                                            ${item.name}
                                            ${ragIndicator}
                                            ${pmStatusBadge}
                                            ${expandIndicator}
                                            ${hasSubtasks ? `<span style="font-size: 10px; color: var(--text-secondary); margin-left: 8px;">(${item.subItems.length} tasks)</span>` : ''}
                                        </div>
                                        <div class="item-description">${item.description}</div>
                                        <div class="item-meta">
                                            ${item.itemType ? `<span class="badge badge-${item.itemType}">${item.itemType}</span>` : ''}
                                            ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost ? `<span class="item-cost">${formatCost(item.cost)}</span>` : ''}
                                            ${item.pmOwnerEmail ? `<span style="font-size: 10px; color: var(--text-secondary); margin-left: 12px;">üë§ ${item.pmOwnerEmail.split('@')[0]}</span>` : ''}
                                            ${item.pmProgress > 0 ? `<span style="font-size: 10px; color: var(--treeplex-primary); margin-left: 12px; font-weight: 600;">${item.pmProgress}%</span>` : ''}
                                        </div>
                                        ${depInfo}
                                    </div>
                                </div>
                            `;
                            itemDiv.addEventListener('click', (e) => {
                                e.stopPropagation();

                                const panel = document.getElementById('info-panel');
                                const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === item.id;

                                if (isPanelOpen) {
                                    // Second click: Close panel and collapse subtasks
                                    panel.classList.remove('open');
                                    currentOpenItemId = null;
                                    if (hasSubtasks) {
                                        item.expanded = false;

                                        // Preserve scroll position during re-render
                                        const treeContainer = document.getElementById('tree-container');
                                        const scrollPos = treeContainer ? treeContainer.scrollTop : 0;

                                        render();

                                        // Restore scroll position after render
                                        if (treeContainer) {
                                            setTimeout(() => {
                                                treeContainer.scrollTop = scrollPos;
                                            }, 0);
                                        }
                                    }
                                } else {
                                    // First click: Open panel and expand subtasks
                                    showInfo(item);
                                    if (hasSubtasks) {
                                        item.expanded = true;

                                        // Preserve scroll position during re-render
                                        const treeContainer = document.getElementById('tree-container');
                                        const scrollPos = treeContainer ? treeContainer.scrollTop : 0;

                                        render();

                                        // Restore scroll position after render
                                        if (treeContainer) {
                                            setTimeout(() => {
                                                treeContainer.scrollTop = scrollPos;
                                            }, 0);
                                        }
                                    }
                                }
                            });

                            itemDiv.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                activeNode = item;
                                showContextMenu(e.pageX, e.pageY);
                            });

                            itemsColumn.appendChild(itemDiv);

                            // RECURSIVE function to render subtasks - keeps same generation on horizontal plane
                            function renderSubtasks(parentItem, containerEl, phaseNum, nestLevel = 0) {
                                if (!parentItem.expanded || !parentItem.subItems || parentItem.subItems.length === 0) {
                                    return;
                                }

                                const subtaskContainer = document.createElement('div');
                                subtaskContainer.className = 'subtask-container';
                                subtaskContainer.style.marginLeft = `${(dependencyLevel + nestLevel) * 20}px`;

                                // Get sub-item IDs for dependency calculations
                                const subItemIds = parentItem.subItems.map(s => s.id);

                                // Sort sub-items by dependencies (topological sort)
                                const sortedSubItems = topologicalSort(parentItem.subItems, subItemIds);

                                // Collect all expanded children that need rendering in next generation
                                const allExpandedGrandchildren = [];

                                // Render all subtasks horizontally first (same generation on same row)
                                sortedSubItems.forEach((subItem, index) => {
                                    const subItemDiv = document.createElement('div');
                                    subItemDiv.className = `tree-node item phase-${phaseNum} subtask`;
                                    subItemDiv.dataset.itemId = subItem.id;

                                    // Ensure subItem has type set
                                    if (!subItem.type) {
                                        subItem.type = 'subtask';
                                    }

                                    // Status color indicator
                                    const statusColors = {
                                        'To Do': '#9CA3AF',
                                        'In Progress': '#3B82F6',
                                        'Completed': '#10B981',
                                        'Done': '#10B981',
                                        'Blocked': '#EF4444'
                                    };
                                    const statusColor = statusColors[subItem.pmStatus] || '#9CA3AF';

                                    // Get initials from assignee name
                                    const getInitials = (name) => {
                                        if (!name || name === 'Unassigned') return '?';
                                        const parts = name.trim().split(' ');
                                        if (parts.length === 1) return parts[0].substring(0, 2).toUpperCase();
                                        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                                    };

                                    // Check if this task has children
                                    const hasChildren = subItem.subItems && subItem.subItems.length > 0;
                                    const chevronIcon = hasChildren ? (subItem.expanded ? '‚ñº' : '‚ñ∂') : '';

                                    // RAG Status for subtasks
                                    const subRAGColors = {
                                        'Green': '#22C55E',
                                        'Amber': '#F59E0B',
                                        'Red': '#EF4444'
                                    };
                                    const subRAGStatus = subItem.pmRAGStatus;
                                    const ragDot = subRAGStatus ?
                                        `<div style="width: 8px; height: 8px; border-radius: 50%; background: ${subRAGColors[subRAGStatus]}; box-shadow: 0 0 4px ${subRAGColors[subRAGStatus]}; flex-shrink: 0; position: absolute; top: -2px; right: -2px; border: 1.5px solid var(--card-bg-light);" title="RAG: ${subRAGStatus}"></div>` : '';

                                    subItemDiv.innerHTML = `
                                        <div style="display: flex; flex-direction: column; gap: 6px; width: 100%; height: 100%;">
                                            <!-- Task Title with optional chevron -->
                                            <div style="display: flex; align-items: flex-start; gap: 4px;">
                                                ${chevronIcon ? `<span style="font-size: 8px; color: var(--text-secondary); cursor: pointer; margin-top: 2px;" class="task-chevron">${chevronIcon}</span>` : ''}
                                                <div style="font-size: 11px; font-weight: 600; line-height: 1.2; color: var(--text-primary); flex: 1; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                                                    ${subItem.name}
                                                </div>
                                            </div>

                                            <!-- Visual Indicators Row -->
                                            <div style="display: flex; align-items: center; gap: 6px; margin-top: auto;">
                                                <!-- Status Dot with RAG overlay -->
                                                <div style="position: relative; width: 12px; height: 12px; flex-shrink: 0;">
                                                    <div style="width: 12px; height: 12px; border-radius: 50%; background: ${statusColor}; box-shadow: 0 0 6px ${statusColor}; flex-shrink: 0;" title="${subItem.pmStatus || 'To Do'}"></div>
                                                    ${ragDot}
                                                </div>

                                                <!-- Owner Badge -->
                                                <div style="width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; color: white; flex-shrink: 0;" title="${subItem.pmOwnerEmail || subItem.pmAssignee || 'Unassigned'}">
                                                    ${getInitials(subItem.pmOwnerEmail || subItem.pmAssignee)}
                                                </div>

                                                <!-- Progress % -->
                                                <div style="font-size: 11px; font-weight: 700; color: var(--treeplex-primary); margin-left: auto;" title="Progress">
                                                    ${subItem.pmProgress || 0}%
                                                </div>
                                            </div>

                                            <!-- Mini Progress Bar -->
                                            <div style="width: 100%; height: 3px; background: rgba(0, 0, 0, 0.3); border-radius: 2px; overflow: hidden;">
                                                <div style="height: 100%; width: ${subItem.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                                            </div>
                                        </div>
                                    `;

                                    // Click to show info panel AND toggle nested subtasks
                                    subItemDiv.addEventListener('click', (e) => {
                                        e.stopPropagation();

                                        const panel = document.getElementById('info-panel');
                                        const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === subItem.id;

                                        if (isPanelOpen) {
                                            // Second click: Close panel and collapse nested subtasks
                                            panel.classList.remove('open');
                                            currentOpenItemId = null;
                                            if (hasChildren) {
                                                subItem.expanded = false;

                                                // Preserve scroll position during re-render
                                                const treeContainer = document.getElementById('tree-container');
                                                const scrollPos = treeContainer ? treeContainer.scrollTop : 0;

                                                render();

                                                // Restore scroll position after render
                                                if (treeContainer) {
                                                    setTimeout(() => {
                                                        treeContainer.scrollTop = scrollPos;
                                                    }, 0);
                                                }
                                            }
                                        } else {
                                            // First click: Open panel and expand nested subtasks
                                            showInfo(subItem);
                                            if (hasChildren) {
                                                subItem.expanded = true;

                                                // Preserve scroll position during re-render
                                                const treeContainer = document.getElementById('tree-container');
                                                const scrollPos = treeContainer ? treeContainer.scrollTop : 0;

                                                render();

                                                // Restore scroll position after render
                                                if (treeContainer) {
                                                    setTimeout(() => {
                                                        treeContainer.scrollTop = scrollPos;
                                                    }, 0);
                                                }
                                            }
                                        }
                                    });

                                    subItemDiv.addEventListener('contextmenu', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        activeNode = subItem;
                                        showContextMenu(e.pageX, e.pageY);
                                    });

                                    subtaskContainer.appendChild(subItemDiv);

                                    // Collect expanded children for next generation
                                    if (subItem.expanded && subItem.subItems && subItem.subItems.length > 0) {
                                        allExpandedGrandchildren.push(subItem);
                                    }
                                });

                                containerEl.appendChild(subtaskContainer);

                                // Now render ALL children of this generation on the NEXT horizontal row below
                                allExpandedGrandchildren.forEach(expandedChild => {
                                    renderSubtasks(expandedChild, containerEl, phaseNum, nestLevel + 1);
                                });
                            }

                            // Initial call to render subtasks
                            renderSubtasks(item, itemsColumn, node.phase, 0);
                        });

                        tableEl.appendChild(itemsColumn);
                    }

                    // Recursively render next phase
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => buildColumn(child));
                    }
                }
            }

            buildColumn(capexTree);
            container.appendChild(tableEl);

            // Draw dependency lines after rendering
            setTimeout(drawDependencyLines, 100);
        }

        // Draw dependency lines using SVG
        function drawDependencyLines() {
            const svg = document.getElementById('dependency-svg');
            const treeEl = document.getElementById('tree-root');
            const wrapperEl = document.getElementById('tree-transform-wrapper');

            // Clear existing lines
            svg.innerHTML = '';

            // Set SVG dimensions to be large enough for panning/zooming
            // Use a fixed large size that the CSS will position correctly
            svg.setAttribute('width', '20000');
            svg.setAttribute('height', '20000');

            // Add arrow marker definitions
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Create markers for each phase color - using darker vibrant colors
            const colors = {
                'phase-0': '#4CAF50',
                'phase-1': '#2196F3',
                'phase-2': '#FB8C00',
                'cross-phase': '#008F6D'
            };

            Object.entries(colors).forEach(([className, color]) => {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', `arrow-${className}`);
                marker.setAttribute('viewBox', '0 0 10 10');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '5');
                marker.setAttribute('markerWidth', '8');
                marker.setAttribute('markerHeight', '8');
                marker.setAttribute('orient', 'auto');

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                path.setAttribute('fill', color);
                path.setAttribute('opacity', '0.8');
                path.setAttribute('filter', 'drop-shadow(0 2px 2px rgba(0,0,0,0.2))');

                marker.appendChild(path);
                defs.appendChild(marker);
            });

            svg.appendChild(defs);

            // Find all items with dependencies
            function getAllItems(node, items = [], phase = null) {
                if (node.phase !== undefined) phase = node.phase;
                if (node.items) {
                    node.items.forEach(item => items.push({ ...item, currentPhase: phase }));
                }
                if (node.children) {
                    node.children.forEach(child => getAllItems(child, items, phase));
                }
                return items;
            }

            const allItems = getAllItems(capexTree);

            // Helper to find item phase
            function findItemPhase(itemId) {
                const item = allItems.find(i => i.id === itemId);
                return item ? item.currentPhase : null;
            }

            // Draw lines for each dependency
            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    const targetEl = document.querySelector(`[data-item-id="${item.id}"]`);
                    if (!targetEl) return;

                    item.dependencies.forEach(depId => {
                        const sourceEl = document.querySelector(`[data-item-id="${depId}"]`);
                        if (!sourceEl) return;

                        // Get positions in tree's local coordinate space (not viewport)
                        // This accounts for the transform by using offsetLeft/Top instead of getBoundingClientRect
                        function getElementPosition(el) {
                            let x = 0;
                            let y = 0;
                            let current = el;

                            // Walk up to the tree root to get cumulative offset
                            while (current && current !== treeEl.parentElement) {
                                x += current.offsetLeft || 0;
                                y += current.offsetTop || 0;
                                current = current.offsetParent;
                            }

                            return { x, y, width: el.offsetWidth, height: el.offsetHeight };
                        }

                        const sourcePos = getElementPosition(sourceEl);
                        const targetPos = getElementPosition(targetEl);

                        // SVG offset constant (matches CSS top/left offset)
                        const SVG_OFFSET = 5000;

                        const x1 = sourcePos.x + sourcePos.width + SVG_OFFSET;
                        const y1 = sourcePos.y + sourcePos.height / 2 + SVG_OFFSET;
                        const x2 = targetPos.x + SVG_OFFSET;
                        const y2 = targetPos.y + targetPos.height / 2 + SVG_OFFSET;

                        // Determine if cross-phase dependency
                        const sourcePhase = findItemPhase(depId);
                        const targetPhase = item.currentPhase;
                        const isCrossPhase = sourcePhase !== targetPhase;

                        // Skip same-phase dependencies - only draw cross-phase arrows
                        if (!isCrossPhase) return;

                        const lineClass = 'cross-phase';

                        // Create curved path (quadratic bezier)
                        const midX = (x1 + x2) / 2;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const d = `M ${x1} ${y1} Q ${midX} ${y1}, ${midX} ${(y1 + y2) / 2} T ${x2} ${y2}`;

                        path.setAttribute('d', d);
                        path.setAttribute('class', `dependency-line ${lineClass}`);
                        path.setAttribute('marker-end', `url(#arrow-${lineClass})`);

                        // Add tooltip
                        const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                        title.textContent = `${depId} ‚Üí ${item.id}${isCrossPhase ? ' (cross-phase)' : ''}`;
                        path.appendChild(title);

                        svg.appendChild(path);
                    });
                }
            });

            // =================================================================
            // DRAW PARENT-CHILD CONNECTORS FOR TASKS (Symmetrical Grey Lines)
            // =================================================================
            // Find all subtasks and draw symmetrical connectors to their parent items
            function getAllSubtasksWithParent(node, subtasks = []) {
                if (node.items) {
                    node.items.forEach(item => {
                        if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                            // Collect parent with all its children for symmetrical layout
                            subtasks.push({
                                parent: item,
                                children: item.subItems
                            });

                            // Recursively handle nested tasks
                            item.subItems.forEach(subtask => {
                                if (subtask.subItems && Array.isArray(subtask.subItems) && subtask.subItems.length > 0) {
                                    subtasks.push({
                                        parent: subtask,
                                        children: subtask.subItems
                                    });
                                }
                            });
                        }
                    });
                }
                if (node.children) {
                    node.children.forEach(child => getAllSubtasksWithParent(child, subtasks));
                }
                return subtasks;
            }

            const allParentChildPairs = getAllSubtasksWithParent(capexTree);

            // Helper to get element position
            function getElementPosition(el) {
                let x = 0;
                let y = 0;
                let current = el;

                while (current && current !== treeEl.parentElement) {
                    x += current.offsetLeft || 0;
                    y += current.offsetTop || 0;
                    current = current.offsetParent;
                }

                return { x, y, width: el.offsetWidth, height: el.offsetHeight };
            }

            const SVG_OFFSET = 5000;

            allParentChildPairs.forEach(({ parent, children }) => {
                const parentEl = document.querySelector(`[data-item-id="${parent.id}"]`);
                if (!parentEl) return;

                const parentPos = getElementPosition(parentEl);

                // Draw symmetrical lines from parent to each child
                children.forEach(child => {
                    const childEl = document.querySelector(`[data-item-id="${child.id}"]`);
                    if (!childEl) return;

                    const childPos = getElementPosition(childEl);

                    // Start from bottom-center of parent
                    const x1 = parentPos.x + parentPos.width / 2 + SVG_OFFSET;
                    const y1 = parentPos.y + parentPos.height + SVG_OFFSET;

                    // End at top-center of child
                    const x2 = childPos.x + childPos.width / 2 + SVG_OFFSET;
                    const y2 = childPos.y + SVG_OFFSET;

                    // Create symmetrical line (no arrow head)
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', 'rgba(128, 128, 128, 0.4)');  // Grey
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('opacity', '0.6');

                    // Add tooltip
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = `${parent.name} ‚Üí ${child.name}`;
                    line.appendChild(title);

                    svg.appendChild(line);
                });
            });
        }


        // Info Panel
        function showInfo(node) {
            const panel = document.getElementById('info-panel');
            const titleElement = document.getElementById('info-title');

            // Enhanced title for subtasks - just the name, prominent
            if (node.type === 'subtask') {
                titleElement.innerHTML = `
                    <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); line-height: 1.3;">
                        ${node.name}
                    </div>
                `;
            } else {
                titleElement.textContent = `${node.icon} ${node.name}`;
            }

            const body = document.getElementById('info-body');

            // Build dependencies section
            let depsHtml = '';
            if (node.dependencies && node.dependencies.length > 0) {
                const depNames = node.dependencies.map(depId => {
                    // Find the dependency item to get its name
                    function findItemById(id, n = capexTree) {
                        if (n.id === id) return n;
                        if (n.items) {
                            const found = n.items.find(i => i.id === id);
                            if (found) return found;
                        }
                        if (n.children) {
                            for (let child of n.children) {
                                const found = findItemById(id, child);
                                if (found) return found;
                            }
                        }
                        return null;
                    }
                    const depItem = findItemById(depId);
                    return depItem ? `${depItem.icon} ${depItem.name}` : depId;
                }).join('<br>');

                depsHtml = `
                    <div class="info-section">
                        <h4>Dependencies</h4>
                        <p style="line-height: 1.8;">${depNames}</p>
                    </div>
                `;
            }

            // Build dependents section (items that depend on this one)
            let dependentsHtml = '';
            if (node.id) {
                function findDependents(nodeId, n = capexTree, dependents = []) {
                    if (n.items) {
                        n.items.forEach(item => {
                            if (item.dependencies && item.dependencies.includes(nodeId)) {
                                dependents.push(item);
                            }
                        });
                    }
                    if (n.children) {
                        n.children.forEach(child => findDependents(nodeId, child, dependents));
                    }
                    return dependents;
                }

                const dependents = findDependents(node.id);
                if (dependents.length > 0) {
                    const depList = dependents.map(d => `${d.icon} ${d.name}`).join('<br>');
                    dependentsHtml = `
                        <div class="info-section">
                            <h4>Required By</h4>
                            <p style="line-height: 1.8;">${depList}</p>
                        </div>
                    `;
                }
            }

            // Build PM Dashboard section for subtasks (only if pattern has tracking enabled)
            let pmDashboardHtml = '';
            const pattern = PATTERNS[currentPattern];
            const hasTracking = pattern.fields?.includeTracking === true;

            if (node.type === 'subtask' && hasTracking) {
                const statusColors = {
                    'To Do': { bg: 'rgba(156, 163, 175, 0.3)', color: '#9CA3AF' },
                    'In Progress': { bg: 'rgba(59, 130, 246, 0.3)', color: '#3B82F6' },
                    'Completed': { bg: 'rgba(16, 185, 129, 0.3)', color: '#10B981' },
                    'Blocked': { bg: 'rgba(239, 68, 68, 0.3)', color: '#EF4444' }
                };
                const statusStyle = statusColors[node.pmStatus] || statusColors['To Do'];

                const priorityEmojis = { 'Low': 'üü¢', 'Medium': 'üü°', 'High': 'üü†', 'Critical': 'üî¥' };
                const priorityEmoji = priorityEmojis[node.pmPriority] || '‚ö™';

                // Calculate days until/since due date
                let dueDateInfo = '';
                if (node.pmDueDate) {
                    const dueDate = new Date(node.pmDueDate);
                    const today = new Date();
                    const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                    if (diffDays < 0) {
                        dueDateInfo = `<span style="color: #EF4444; font-weight: 600;">‚ö†Ô∏è ${Math.abs(diffDays)} days overdue</span>`;
                    } else if (diffDays === 0) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">üìÖ Due today!</span>`;
                    } else if (diffDays <= 3) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">‚è∞ ${diffDays} days left</span>`;
                    } else {
                        dueDateInfo = `<span style="color: var(--text-secondary);">${diffDays} days left</span>`;
                    }
                }

                pmDashboardHtml = `
                    <!-- Status + Progress Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: ${statusStyle.bg}; border-radius: 10px; border: 2px solid ${statusStyle.color};">
                            <div style="font-size: 28px; font-weight: 700; color: ${statusStyle.color};">
                                ${node.pmStatus || 'To Do'}
                            </div>
                        </div>
                        <div style="flex: 1; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); border-radius: 10px; border: 2px solid rgba(0, 166, 125, 0.4); display: flex; flex-direction: column; justify-content: center;">
                            <div style="font-size: 36px; font-weight: 700; color: var(--treeplex-primary); line-height: 1;">${node.pmProgress || 0}%</div>
                            <div style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden; margin-top: 8px;">
                                <div style="height: 100%; width: ${node.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Owner + Priority Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; align-items: center; gap: 12px;">
                            <div style="width: 48px; height: 48px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: 700; color: white; flex-shrink: 0;">
                                ${node.pmAssignee ? node.pmAssignee.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2) : '?'}
                            </div>
                            <div style="font-size: 18px; font-weight: 600;">${node.pmAssignee || 'Unassigned'}</div>
                        </div>
                        <div style="width: 120px; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <div style="font-size: 40px; margin-bottom: 4px;">${priorityEmoji}</div>
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-secondary);">${node.pmPriority || 'Medium'}</div>
                        </div>
                    </div>

                    <!-- Timeline -->
                    <div style="padding: 16px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-around; margin-bottom: 12px;">
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">üìÖ</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmStartDate ? new Date(node.pmStartDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                            <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
                                <div style="height: 2px; flex: 1; background: linear-gradient(90deg, var(--treeplex-primary), transparent);"></div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">üéØ</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmDueDate ? new Date(node.pmDueDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                        </div>
                        ${dueDateInfo ? `<div style="text-align: center; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; font-size: 13px;">${dueDateInfo}</div>` : ''}
                    </div>

                    <!-- Notes -->
                    ${node.pmNotes ? `
                        <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; border-left: 4px solid var(--treeplex-primary); margin-bottom: 16px;">
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary);">${node.pmNotes}</div>
                        </div>
                    ` : ''}

                    <!-- Blocking Issue -->
                    ${node.pmBlockingIssue ? `
                        <div style="padding: 14px; background: rgba(239, 68, 68, 0.15); border-radius: 10px; border-left: 4px solid #EF4444; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">üöß</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #FCA5A5;">${node.pmBlockingIssue}</div>
                        </div>
                    ` : ''}

                    <!-- Next Steps -->
                    ${node.pmNextSteps ? `
                        <div style="padding: 14px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; border-left: 4px solid #3B82F6; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">‚û°Ô∏è</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #93C5FD;">${node.pmNextSteps}</div>
                        </div>
                    ` : ''}

                    <!-- Latest Updates -->
                    ${node.pmUpdates && node.pmUpdates.length > 0 ? `
                        <div style="max-height: 300px; overflow-y: auto;">
                            ${node.pmUpdates.map(update => `
                                <div style="margin-bottom: 10px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 6px;">
                                        üìÖ ${new Date(update.timestamp).toLocaleString('en-US', {month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'})}
                                    </div>
                                    <div style="font-size: 13px; line-height: 1.5; white-space: pre-wrap;">${update.text}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            }

            // Build pattern-specific infographic (geometric and visual)
            let patternInfoHtml = '';

            // SALES PIPELINE - Funnel with probability
            if (currentPattern === 'sales' && (node.dealValue || node.stageProbability || node.expectedCloseDate || node.competitorInfo)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(16, 185, 129, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #10B981; margin-bottom: 8px;">üíº Sales Deal Pipeline</div>
                        </div>

                        <!-- Deal Value + Probability Row -->
                        <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                            ${node.dealValue ? `
                                <div style="flex: 1; padding: 20px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">üí∞ Deal Value</div>
                                    <div style="font-size: 32px; font-weight: 700; color: #10B981;">$${node.dealValue.toLocaleString()}</div>
                                </div>
                            ` : ''}
                            ${node.stageProbability !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">üìä Close Probability</div>
                                    <div style="font-size: 32px; font-weight: 700; color: #3B82F6;">${node.stageProbability}%</div>
                                    <div style="width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; overflow: hidden; margin-top: 12px;">
                                        <div style="height: 100%; width: ${node.stageProbability}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Expected Revenue (Value √ó Probability) -->
                        ${node.dealValue && node.stageProbability !== undefined ? `
                            <div style="text-align: center; padding: 16px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; margin-bottom: 20px;">
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">Expected Revenue (Value √ó Probability)</div>
                                <div style="font-size: 24px; font-weight: 700; color: #F59E0B;">$${Math.round(node.dealValue * (node.stageProbability / 100)).toLocaleString()}</div>
                            </div>
                        ` : ''}

                        <!-- Timeline & Contact -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.expectedCloseDate ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üìÖ Target Close</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${new Date(node.expectedCloseDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                            ${node.contactPerson ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üë§ Contact</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.contactPerson}</div>
                                </div>
                            ` : ''}
                            ${node.leadSource ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üìç Source</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.leadSource}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Competitor Info -->
                        ${node.competitorInfo ? `
                            <div style="padding: 16px; background: rgba(239, 68, 68, 0.12); border-left: 4px solid #EF4444; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #EF4444; margin-bottom: 8px; text-transform: uppercase;">üéØ Competitive Landscape</div>
                                <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.competitorInfo}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILM/VIDEO - Scene storyboard card
            else if (currentPattern === 'film' && (node.videoPrompt || node.aiPlatform || node.cameraMovement)) {
                const platformColors = {
                    'Sora (OpenAI)': '#74aa9c',
                    'Veo 3 (Google)': '#4285f4',
                    'Runway Gen-3': '#6366f1',
                    'Pika 2.0': '#f59e0b',
                    'Testing Multiple': '#8b5cf6'
                };
                const platformColor = platformColors[node.aiPlatform] || '#9ca3af';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">üé¨ AI Video Scene</div>
                        </div>

                        <!-- Platform & Technical Specs -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.aiPlatform ? `
                                <div style="padding: 12px; background: rgba(${parseInt(platformColor.slice(1, 3), 16)}, ${parseInt(platformColor.slice(3, 5), 16)}, ${parseInt(platformColor.slice(5, 7), 16)}, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Platform</div>
                                    <div style="font-size: 13px; font-weight: 600; color: ${platformColor};">ü§ñ ${node.aiPlatform}</div>
                                </div>
                            ` : ''}
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #3B82F6;">‚è±Ô∏è ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.aspectRatio ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Ratio</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #10B981;">üìê ${node.aspectRatio.split(' ')[0]}</div>
                                </div>
                            ` : ''}
                            ${node.visualStyle ? `
                                <div style="padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Style</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #A78BFA;">üé® ${node.visualStyle}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Cinematography -->
                        ${node.cameraMovement || node.lightingMood || node.motionIntensity ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 12px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 12px; text-transform: uppercase;">üé• Cinematography</div>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                    ${node.cameraMovement && node.cameraMovement !== 'Static' ? `
                                        <div style="padding: 8px 14px; background: rgba(245, 158, 11, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #F59E0B;">
                                            üìπ ${node.cameraMovement}
                                        </div>
                                    ` : ''}
                                    ${node.lightingMood ? `
                                        <div style="padding: 8px 14px; background: rgba(251, 191, 36, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #FCD34D;">
                                            üí° ${node.lightingMood}
                                        </div>
                                    ` : ''}
                                    ${node.motionIntensity ? `
                                        <div style="padding: 8px 14px; background: rgba(59, 130, 246, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #60A5FA;">
                                            üåä ${node.motionIntensity}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}

                        <!-- Video Prompt (Main) -->
                        ${node.videoPrompt ? `
                            <div style="padding: 16px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid var(--treeplex-primary); border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px; text-transform: uppercase;">‚úçÔ∏è Video Prompt</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">${node.videoPrompt}</div>
                            </div>
                        ` : ''}

                        <!-- Iteration Notes -->
                        ${node.iterationNotes ? `
                            <div style="padding: 14px; background: rgba(139, 92, 246, 0.12); border-left: 4px solid #A78BFA; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #A78BFA; margin-bottom: 6px; text-transform: uppercase;">üìù Generation Notes</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.iterationNotes}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // PHILOSOPHY - Logical argument structure (already implemented)
            else if (currentPattern === 'philosophy' && (node.premise1 || node.premise2 || node.conclusion || node.objection || node.response)) {
                // Philosophy Pattern Infographic
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ü§î Philosophical Argument Structure</div>
                            ${node.speaker ? `<div style="font-size: 14px; color: var(--text-secondary);">üó£Ô∏è Speaker: <span style="color: var(--text-primary); font-weight: 600;">${node.speaker}</span></div>` : ''}
                        </div>

                        <!-- Argument Metadata Row -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.argumentType ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Argument Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #60A5FA;">üéØ ${node.argumentType}</div>
                                </div>
                            ` : ''}
                            ${node.validity ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: ${node.validity === 'Valid' || node.validity === 'Sound' ? 'rgba(16, 185, 129, 0.15)' : 'rgba(239, 68, 68, 0.15)'}; border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Validity</div>
                                    <div style="font-size: 14px; font-weight: 600; color: ${node.validity === 'Valid' || node.validity === 'Sound' ? '#10B981' : '#EF4444'};">‚úì ${node.validity}</div>
                                </div>
                            ` : ''}
                            ${node.philosophicalSchool ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">School</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">üèõÔ∏è ${node.philosophicalSchool}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Argument Flow: Premises ‚Üí Conclusion -->
                        ${node.premise1 || node.premise2 || node.conclusion ? `
                            <div style="margin-bottom: 24px;">
                                <div style="text-align: center; font-size: 13px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px;">‚ö° Logical Structure</div>

                                ${node.premise1 ? `
                                    <div style="position: relative; margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">1Ô∏è‚É£ Premise 1</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.premise1}</div>
                                        </div>
                                        <div style="text-align: center; margin: 8px 0; font-size: 20px; color: var(--treeplex-primary);">‚Üì</div>
                                    </div>
                                ` : ''}

                                ${node.premise2 ? `
                                    <div style="position: relative; margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">2Ô∏è‚É£ Premise 2</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.premise2}</div>
                                        </div>
                                        <div style="text-align: center; margin: 8px 0; font-size: 20px; color: var(--treeplex-primary);">‚Üì</div>
                                    </div>
                                ` : ''}

                                ${node.conclusion ? `
                                    <div style="position: relative;">
                                        <div style="text-align: center; margin-bottom: 8px;">
                                            <span style="display: inline-block; padding: 6px 16px; background: var(--treeplex-primary); color: white; border-radius: 20px; font-size: 13px; font-weight: 700;">‚à¥ THEREFORE</span>
                                        </div>
                                        <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1)); border: 2px solid #10B981; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">‚úì Conclusion</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; font-weight: 500;">${node.conclusion}</div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Objection & Response (Dialectic) -->
                        ${node.objection || node.response ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 13px; font-weight: 700; color: #F59E0B; margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px;">‚öîÔ∏è Dialectical Challenge</div>

                                ${node.objection ? `
                                    <div style="margin-bottom: 12px;">
                                        <div style="background: rgba(239, 68, 68, 0.12); border-left: 4px solid #EF4444; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #EF4444; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">‚ùå Objection</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.objection}</div>
                                        </div>
                                    </div>
                                ` : ''}

                                ${node.response ? `
                                    <div style="text-align: center; margin: 12px 0; font-size: 16px; color: var(--treeplex-primary);">‚§∑</div>
                                    <div style="margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">üí° Response to Objection</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.response}</div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Key Concepts & References -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.keyTerms ? `
                                <div style="flex: 1; min-width: 200px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üìù Key Terms</div>
                                    <div style="font-size: 13px; line-height: 1.5; color: var(--text-primary);">${node.keyTerms}</div>
                                </div>
                            ` : ''}
                            ${node.textualReference ? `
                                <div style="flex: 1; min-width: 200px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üìñ Reference</div>
                                    <div style="font-size: 13px; line-height: 1.5; color: var(--text-primary); font-family: monospace;">${node.textualReference}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // THESIS - Academic structure with argument ‚Üí evidence
            else if (currentPattern === 'thesis' && (node.keyArgument || node.citations || node.evidenceType)) {
                const progressPercent = node.targetWordCount ? Math.min(100, Math.round((node.wordCount / node.targetWordCount) * 100)) : 0;

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(16, 185, 129, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #10B981; margin-bottom: 8px;">üéì Academic Section</div>
                        </div>

                        <!-- Word Count Progress -->
                        ${node.wordCount !== undefined || node.targetWordCount ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-radius: 10px; margin-bottom: 20px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="font-size: 13px; color: var(--text-secondary);">üìù Word Count</span>
                                    <span style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.wordCount || 0} / ${node.targetWordCount || '?'} words</span>
                                </div>
                                ${node.targetWordCount ? `
                                    <div style="width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; overflow: hidden;">
                                        <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                    <div style="text-align: center; margin-top: 6px; font-size: 12px; color: var(--text-secondary);">${progressPercent}% complete</div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Draft Status + Evidence Type -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.draftStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Status</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B;">‚úèÔ∏è ${node.draftStatus}</div>
                                </div>
                            ` : ''}
                            ${node.evidenceType ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Evidence</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">üî¨ ${node.evidenceType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Key Argument (Central claim) -->
                        ${node.keyArgument ? `
                            <div style="padding: 16px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase;">üí° Key Argument</div>
                                <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.keyArgument}</div>
                            </div>
                        ` : ''}

                        <!-- Citations -->
                        ${node.citations ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid #9ca3af; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">üìö Key Citations</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.citations}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // ROADMAP - Feature card with user impact & technical risk
            else if (currentPattern === 'roadmap' && (node.storyPoints || node.userImpact || node.technicalRisk)) {
                const impactColors = { 'High': '#10B981', 'Medium': '#F59E0B', 'Low': '#9CA3AF' };
                const riskColors = { 'Low': '#10B981', 'Medium': '#F59E0B', 'High': '#EF4444', 'Unknown': '#9CA3AF' };

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">üöÄ Product Feature</div>
                        </div>

                        <!-- Story Points (Large) -->
                        ${node.storyPoints !== undefined ? `
                            <div style="text-align: center; padding: 24px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.1)); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">Effort Estimate</div>
                                <div style="font-size: 48px; font-weight: 700; color: var(--treeplex-primary); line-height: 1;">${node.storyPoints}</div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">Story Points</div>
                            </div>
                        ` : ''}

                        <!-- Impact & Risk Matrix -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
                            ${node.userImpact ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(impactColors[node.userImpact].slice(1, 3), 16)}, ${parseInt(impactColors[node.userImpact].slice(3, 5), 16)}, ${parseInt(impactColors[node.userImpact].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">User Impact</div>
                                    <div style="font-size: 20px; font-weight: 700; color: ${impactColors[node.userImpact]};">üë• ${node.userImpact}</div>
                                </div>
                            ` : ''}
                            ${node.technicalRisk ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(riskColors[node.technicalRisk].slice(1, 3), 16)}, ${parseInt(riskColors[node.technicalRisk].slice(3, 5), 16)}, ${parseInt(riskColors[node.technicalRisk].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Technical Risk</div>
                                    <div style="font-size: 20px; font-weight: 700; color: ${riskColors[node.technicalRisk]};">‚ö†Ô∏è ${node.technicalRisk}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Engineering Estimate & Feature Flag -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.engineeringEstimate ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">‚è±Ô∏è Estimate</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.engineeringEstimate}</div>
                                </div>
                            ` : ''}
                            ${node.featureFlag ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üö© Feature Flag</div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--treeplex-primary); font-family: monospace;">${node.featureFlag}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // PROMPTING - Layered prompt structure
            else if (currentPattern === 'prompting' && (node.systemPrompt || node.userPromptTemplate || node.fewShotExamples)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(167, 139, 250, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(139, 92, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #8B5CF6; margin-bottom: 8px;">üß† Prompt Structure</div>
                        </div>

                        <!-- Model + Temperature -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.modelTarget ? `
                                <div style="flex: 1; min-width: 180px; padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Target Model</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #60A5FA;">ü§ñ ${node.modelTarget}</div>
                                </div>
                            ` : ''}
                            ${node.temperature !== undefined ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Temperature</div>
                                    <div style="font-size: 18px; font-weight: 700; color: #F59E0B;">üî• ${node.temperature}</div>
                                </div>
                            ` : ''}
                            ${node.maxTokens ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Max Tokens</div>
                                    <div style="font-size: 18px; font-weight: 700; color: #10B981;">üìè ${node.maxTokens}</div>
                                </div>
                            ` : ''}
                            ${node.testStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Status</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #A78BFA;">‚úÖ ${node.testStatus}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Layered Structure -->
                        ${node.systemPrompt ? `
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #8B5CF6; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 1: SYSTEM</span>
                                </div>
                                <div style="padding: 14px; background: rgba(139, 92, 246, 0.12); border-left: 4px solid #8B5CF6; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.systemPrompt}</div>
                                </div>
                            </div>
                        ` : ''}

                        ${node.userPromptTemplate ? `
                            <div style="text-align: center; margin: 12px 0; font-size: 18px; color: var(--treeplex-primary);">‚Üì</div>
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #3B82F6; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 2: USER PROMPT</span>
                                </div>
                                <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.userPromptTemplate}</div>
                                </div>
                            </div>
                        ` : ''}

                        ${node.fewShotExamples ? `
                            <div style="text-align: center; margin: 12px 0; font-size: 18px; color: var(--treeplex-primary);">‚Üì</div>
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #10B981; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 3: FEW-SHOT EXAMPLES</span>
                                </div>
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.fewShotExamples}</div>
                                </div>
                            </div>
                        ` : ''}

                        <!-- Test Results -->
                        ${node.testResults ? `
                            <div style="padding: 14px; background: rgba(245, 158, 11, 0.12); border-left: 4px solid #F59E0B; border-radius: 8px; margin-top: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 6px; text-transform: uppercase;">‚úÖ Test Results</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.testResults}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // BOOK - Narrative arc card
            else if (currentPattern === 'book' && (node.povCharacter || node.sceneSetting || node.plotFunction)) {
                const progressPercent = node.targetWordCount ? Math.min(100, Math.round((node.wordCount / node.targetWordCount) * 100)) : 0;

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.08), rgba(251, 146, 60, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(245, 158, 11, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #F59E0B; margin-bottom: 8px;">üìö Narrative Scene</div>
                        </div>

                        <!-- Word Count -->
                        ${node.wordCount !== undefined || node.targetWordCount ? `
                            <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-radius: 10px; margin-bottom: 16px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 12px; color: var(--text-secondary);">üìù Words</span>
                                    <span style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.wordCount || 0} / ${node.targetWordCount || '?'}</span>
                                </div>
                                ${node.targetWordCount ? `
                                    <div style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden;">
                                        <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- POV + Plot Function -->
                        <div style="display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">
                            ${node.povCharacter ? `
                                <div style="flex: 1; min-width: 180px; padding: 14px; background: rgba(139, 92, 246, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üë§ POV Character</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #A78BFA;">${node.povCharacter}</div>
                                </div>
                            ` : ''}
                            ${node.plotFunction ? `
                                <div style="flex: 1; min-width: 180px; padding: 14px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üìñ Plot Function</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #10B981;">${node.plotFunction}</div>
                                </div>
                            ` : ''}
                            ${node.draftStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 14px; background: rgba(245, 158, 11, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">Status</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #F59E0B;">‚úèÔ∏è ${node.draftStatus}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Scene Setting -->
                        ${node.sceneSetting ? `
                            <div style="padding: 16px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid #F59E0B; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 8px; text-transform: uppercase;">üé≠ Scene Setting</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.sceneSetting}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // COURSE - Learning module
            else if (currentPattern === 'course' && (node.learningObjectives || node.duration || node.assessmentType)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(96, 165, 250, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">üìñ Learning Module</div>
                        </div>

                        <!-- Duration + Difficulty + Assessment -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #10B981;">‚è±Ô∏è ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.difficultyLevel ? `
                                <div style="padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Level</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B;">üìä ${node.difficultyLevel}</div>
                                </div>
                            ` : ''}
                            ${node.assessmentType ? `
                                <div style="padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Assessment</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">‚úÖ ${node.assessmentType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Learning Objectives -->
                        ${node.learningObjectives ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase;">üéì Learning Objectives</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.learningObjectives}</div>
                            </div>
                        ` : ''}

                        <!-- Prerequisites & Resources -->
                        ${node.prerequisites || node.resourcesNeeded ? `
                            <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                                ${node.prerequisites ? `
                                    <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">üìã Prerequisites</div>
                                        <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.prerequisites}</div>
                                    </div>
                                ` : ''}
                                ${node.resourcesNeeded ? `
                                    <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">üìö Resources</div>
                                        <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.resourcesNeeded}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // EVENT PLANNING - Timeline with logistics grid
            else if (currentPattern === 'event' && (node.budget || node.vendor || node.guestCount || node.bookingDeadline)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(236, 72, 153, 0.08), rgba(219, 39, 119, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(236, 72, 153, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #EC4899; margin-bottom: 8px;">üéâ Event Activity</div>
                        </div>

                        <!-- Budget + Guest Count -->
                        <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                            ${node.budget !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">üí∞ Budget</div>
                                    <div style="font-size: 28px; font-weight: 700; color: #10B981;">$${node.budget.toLocaleString()}</div>
                                </div>
                            ` : ''}
                            ${node.guestCount !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">üë• Guests</div>
                                    <div style="font-size: 28px; font-weight: 700; color: #3B82F6;">${node.guestCount}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Vendor + Location + Deadline -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            ${node.vendor ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üè¢ Vendor</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.vendor}</div>
                                </div>
                            ` : ''}
                            ${node.location ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üìç Location</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.location}</div>
                                </div>
                            ` : ''}
                            ${node.responsiblePerson ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üë§ Owner</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.responsiblePerson}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Booking Deadline (Urgent Banner) -->
                        ${node.bookingDeadline ? `
                            <div style="padding: 16px; background: rgba(245, 158, 11, 0.15); border-left: 4px solid #F59E0B; border-radius: 8px; text-align: center;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 6px; text-transform: uppercase;">üìÖ Booking Deadline</div>
                                <div style="font-size: 18px; font-weight: 700; color: var(--text-primary);">${new Date(node.bookingDeadline).toLocaleDateString('en-US', {weekday: 'long', month: 'short', day: 'numeric', year: 'numeric'})}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FITNESS PROGRAM - Exercise card with sets/reps grid
            else if (currentPattern === 'fitness' && (node.sets || node.reps || node.duration || node.intensity)) {
                const intensityColors = { 'Light': '#10B981', 'Moderate': '#F59E0B', 'High': '#EF4444', 'Max': '#DC2626' };
                const intensityColor = intensityColors[node.intensity] || '#9CA3AF';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.08), rgba(220, 38, 38, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(239, 68, 68, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #EF4444; margin-bottom: 8px;">üí™ Exercise Specification</div>
                        </div>

                        <!-- Sets √ó Reps (Large Display) -->
                        ${node.sets || node.reps ? `
                            <div style="text-align: center; padding: 24px; background: rgba(239, 68, 68, 0.15); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 48px; font-weight: 700; color: #EF4444; line-height: 1;">
                                    ${node.sets || '?'} <span style="font-size: 32px; color: var(--text-secondary);">√ó</span> ${node.reps || '?'}
                                </div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-top: 8px;">Sets √ó Reps</div>
                            </div>
                        ` : ''}

                        <!-- Duration + Intensity + Rest -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #3B82F6;">‚è±Ô∏è ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.intensity ? `
                                <div style="padding: 12px; background: rgba(${parseInt(intensityColor.slice(1, 3), 16)}, ${parseInt(intensityColor.slice(3, 5), 16)}, ${parseInt(intensityColor.slice(5, 7), 16)}, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Intensity</div>
                                    <div style="font-size: 16px; font-weight: 600; color: ${intensityColor};">üî• ${node.intensity}</div>
                                </div>
                            ` : ''}
                            ${node.restPeriod ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Rest</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #10B981;">‚è∏Ô∏è ${node.restPeriod}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Equipment -->
                        ${node.equipment ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üèãÔ∏è Equipment</div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.equipment}</div>
                            </div>
                        ` : ''}

                        <!-- Form Cues -->
                        ${node.formCues ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase;">‚úÖ Form Cues</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.formCues}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // STRATEGY - Strategic initiative card with metrics
            else if (currentPattern === 'strategy' && (node.investment || node.keyMetric || node.strategicTheme)) {
                const themeColors = { 'Growth': '#10B981', 'Efficiency': '#3B82F6', 'Innovation': '#8B5CF6', 'Transformation': '#F59E0B', 'Risk Mitigation': '#EF4444' };
                const themeColor = themeColors[node.strategicTheme] || '#9CA3AF';
                const riskColors = { 'Low': '#10B981', 'Medium': '#F59E0B', 'High': '#EF4444' };

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(37, 99, 235, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">üìä Strategic Initiative</div>
                        </div>

                        <!-- Investment (Large) -->
                        ${node.investment !== undefined ? `
                            <div style="text-align: center; padding: 24px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">Capital Investment</div>
                                <div style="font-size: 40px; font-weight: 700; color: #10B981; line-height: 1;">$${node.investment.toLocaleString()}</div>
                            </div>
                        ` : ''}

                        <!-- Strategic Theme + Risk Level -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
                            ${node.strategicTheme ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(themeColor.slice(1, 3), 16)}, ${parseInt(themeColor.slice(3, 5), 16)}, ${parseInt(themeColor.slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Theme</div>
                                    <div style="font-size: 18px; font-weight: 700; color: ${themeColor};">üé≠ ${node.strategicTheme}</div>
                                </div>
                            ` : ''}
                            ${node.riskLevel ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(riskColors[node.riskLevel].slice(1, 3), 16)}, ${parseInt(riskColors[node.riskLevel].slice(3, 5), 16)}, ${parseInt(riskColors[node.riskLevel].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Risk</div>
                                    <div style="font-size: 18px; font-weight: 700; color: ${riskColors[node.riskLevel]};">‚ö†Ô∏è ${node.riskLevel}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Key Metric ‚Üí Target Value -->
                        ${node.keyMetric || node.targetValue ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 12px; font-weight: 700; color: #3B82F6; margin-bottom: 12px; text-transform: uppercase;">üìà Success Metrics</div>
                                ${node.keyMetric ? `
                                    <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 10px;">
                                        <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 4px; text-transform: uppercase;">üìä Key Metric</div>
                                        <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.keyMetric}</div>
                                    </div>
                                ` : ''}
                                ${node.targetValue ? `
                                    <div style="text-align: center; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">üéØ Target</div>
                                        <div style="font-size: 20px; font-weight: 700; color: #10B981;">${node.targetValue}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Executive Owner -->
                        ${node.responsibleExecutive ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üëî Executive Sponsor</div>
                                <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.responsibleExecutive}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FAMILY TREE - Person card with genealogy info
            else if (currentPattern === 'familytree' && (node.fullName || node.birthDate || node.birthPlace)) {
                const isLiving = node.livingStatus === 'Living';
                const statusColor = isLiving ? '#10B981' : '#9CA3AF';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(124, 58, 237, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(139, 92, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #8B5CF6; margin-bottom: 8px;">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Family Member</div>
                        </div>

                        <!-- Full Name + Living Status -->
                        ${node.fullName ? `
                            <div style="text-align: center; padding: 20px; background: rgba(139, 92, 246, 0.15); border-radius: 10px; margin-bottom: 20px;">
                                <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">${node.fullName}</div>
                                ${node.maidenName ? `<div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">(n√©e ${node.maidenName})</div>` : ''}
                                ${node.livingStatus ? `
                                    <div style="display: inline-block; padding: 6px 14px; background: rgba(${parseInt(statusColor.slice(1, 3), 16)}, ${parseInt(statusColor.slice(3, 5), 16)}, ${parseInt(statusColor.slice(5, 7), 16)}, 0.2); border-radius: 20px; font-size: 12px; font-weight: 600; color: ${statusColor};">
                                        ${isLiving ? 'üíö' : 'üïäÔ∏è'} ${node.livingStatus}
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Birth & Death Info -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            ${node.birthDate || node.birthPlace ? `
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase;">üéÇ Birth</div>
                                    ${node.birthDate ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${new Date(node.birthDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                    ${node.birthPlace ? `<div style="font-size: 13px; color: var(--text-secondary);">üìç ${node.birthPlace}</div>` : ''}
                                </div>
                            ` : ''}
                            ${node.deathDate || node.deathPlace ? `
                                <div style="padding: 14px; background: rgba(156, 163, 175, 0.12); border-left: 4px solid #9CA3AF; border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: #9CA3AF; margin-bottom: 8px; text-transform: uppercase;">üïäÔ∏è Death</div>
                                    ${node.deathDate ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${new Date(node.deathDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                    ${node.deathPlace ? `<div style="font-size: 13px; color: var(--text-secondary);">üìç ${node.deathPlace}</div>` : ''}
                                </div>
                            ` : ''}
                        </div>

                        <!-- Marriage & Family -->
                        ${node.spouseName || node.marriageDate ? `
                            <div style="padding: 14px; background: rgba(236, 72, 153, 0.12); border-left: 4px solid #EC4899; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #EC4899; margin-bottom: 8px; text-transform: uppercase;">üíë Marriage</div>
                                ${node.spouseName ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">Spouse: ${node.spouseName}</div>` : ''}
                                ${node.marriageDate ? `<div style="font-size: 13px; color: var(--text-secondary);">${new Date(node.marriageDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                ${node.marriagePlace ? `<div style="font-size: 13px; color: var(--text-secondary);">üìç ${node.marriagePlace}</div>` : ''}
                            </div>
                        ` : ''}

                        <!-- Occupation & Gender & Relationship -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 16px;">
                            ${node.gender ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Gender</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">‚öß ${node.gender}</div>
                                </div>
                            ` : ''}
                            ${node.occupation ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Occupation</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">üíº ${node.occupation}</div>
                                </div>
                            ` : ''}
                            ${node.relationshipType ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Relationship</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">üîó ${node.relationshipType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- DNA Info -->
                        ${node.dnaInfo ? `
                            <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 6px; text-transform: uppercase;">üß¨ DNA / Genetic Info</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.dnaInfo}</div>
                            </div>
                        ` : ''}

                        <!-- Sources -->
                        ${node.sources ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid #9ca3af; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üìÑ Sources</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.sources}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILE SYSTEM - File preview/open button with thumbnail
            else if (currentPattern === 'filesystem' && !node.isFolder && (node.fileUrl || node.filePath)) {
                // Format file size
                const formatFileSize = (bytes) => {
                    if (!bytes) return 'Unknown size';
                    if (bytes < 1024) return bytes + ' B';
                    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                    if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                    return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
                };

                // Get file icon based on extension
                const fileIcon = node.icon || getFileIcon(node.name, false);
                const fileSize = formatFileSize(node.fileSize);

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">üíæ File Details</div>
                        </div>

                        <!-- File Thumbnail/Icon & Open Button -->
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 16px; margin-bottom: 20px;">
                            <!-- Large Icon -->
                            <div style="font-size: 80px; line-height: 1;">${fileIcon}</div>

                            <!-- File Name -->
                            <div style="font-size: 18px; font-weight: 600; color: var(--text-primary); text-align: center; word-break: break-all;">
                                ${node.name}
                            </div>

                            <!-- Open File Button -->
                            ${node.fileUrl ? `
                                <button onclick="window.open('${node.fileUrl}', '_blank')"
                                        style="padding: 14px 32px;
                                               background: linear-gradient(135deg, #6366f1, #8b5cf6);
                                               border: none;
                                               border-radius: 12px;
                                               color: white;
                                               font-size: 16px;
                                               font-weight: 700;
                                               cursor: pointer;
                                               transition: all 0.2s;
                                               box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);"
                                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(99, 102, 241, 0.4)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(99, 102, 241, 0.3)'">
                                    üîó Open File
                                </button>
                            ` : ''}
                        </div>

                        <!-- File Metadata Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.fileSize ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">üìä Size</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${fileSize}</div>
                                </div>
                            ` : ''}
                            ${node.fileExtension ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">üè∑Ô∏è Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.fileExtension}</div>
                                </div>
                            ` : ''}
                            ${node.dateModified ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">üïí Modified</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary);">${new Date(node.dateModified).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                            ${node.dateCreated ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">üìÖ Created</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary);">${new Date(node.dateCreated).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- File Path -->
                        ${node.filePath ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid var(--treeplex-primary); border-radius: 8px; margin-bottom: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üìÇ Path</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); font-family: monospace; word-break: break-all;">${node.filePath}</div>
                            </div>
                        ` : ''}

                        <!-- Permissions & Owner -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.permissions ? `
                                <div style="flex: 1; min-width: 150px; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">üîí Permissions</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #10B981;">${node.permissions}</div>
                                </div>
                            ` : ''}
                            ${node.fileOwner ? `
                                <div style="flex: 1; min-width: 150px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">üë§ Owner</div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${node.fileOwner}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Shared With -->
                        ${node.sharedWith ? `
                            <div style="padding: 14px; background: rgba(168, 85, 247, 0.15); border-left: 4px solid #a855f7; border-radius: 8px; margin-top: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: #a855f7; margin-bottom: 6px; text-transform: uppercase;">üë• Shared With</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary);">${node.sharedWith}</div>
                            </div>
                        ` : ''}

                        <!-- Tags -->
                        ${node.tags ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-top: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üè∑Ô∏è Tags</div>
                                <div style="font-size: 13px; color: var(--text-primary);">${node.tags}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILESYSTEM - File/Folder info card with Open button
            let filesystemInfoHtml = '';
            if (currentPattern === 'filesystem' && node.type === 'item') {
                const formatFileSize = (bytes) => {
                    if (!bytes || bytes === 0) return 'N/A';
                    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
                    let size = bytes;
                    let unitIndex = 0;
                    while (size >= 1024 && unitIndex < units.length - 1) {
                        size /= 1024;
                        unitIndex++;
                    }
                    return `${size.toFixed(2)} ${units[unitIndex]}`;
                };

                const formatDate = (dateStr) => {
                    if (!dateStr) return 'N/A';
                    try {
                        return new Date(dateStr).toLocaleString('en-US', {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                    } catch (e) {
                        return dateStr;
                    }
                };

                // Determine if it's a folder or file
                const isFolder = node.isFolder === true;
                const entityType = isFolder ? 'Folder' : 'File';
                const entityIcon = isFolder ? 'üìÅ' : node.icon || 'üìÑ';

                filesystemInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(99, 102, 241, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">${entityIcon} ${entityType} Details</div>
                        </div>

                        <!-- Open Button (Prominent) -->
                        ${node.fileUrl || node.filePath ? `
                            <div style="text-align: center; margin-bottom: 20px;">
                                <button onclick="window.open('${node.fileUrl || node.filePath}', '_blank')" style="
                                    padding: 16px 32px;
                                    background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
                                    color: white;
                                    border: none;
                                    border-radius: 12px;
                                    font-size: 16px;
                                    font-weight: 700;
                                    cursor: pointer;
                                    display: inline-flex;
                                    align-items: center;
                                    gap: 10px;
                                    transition: all 0.3s;
                                    box-shadow: 0 4px 12px rgba(0, 166, 125, 0.3);
                                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0, 166, 125, 0.4)';" onmouseout="this.style.transform=''; this.style.boxShadow='0 4px 12px rgba(0, 166, 125, 0.3)';">
                                    <span style="font-size: 20px;">üîó</span>
                                    <span>Open ${isFolder ? 'Folder' : 'File'}</span>
                                </button>
                            </div>
                        ` : ''}

                        <!-- File/Folder Metadata Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 16px;">
                            ${!isFolder && node.fileSize !== undefined ? `
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">üíæ Size</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #10B981;">${formatFileSize(node.fileSize)}</div>
                                </div>
                            ` : ''}
                            ${node.fileExtension ? `
                                <div style="padding: 14px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">üìã Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B; font-family: monospace;">${node.fileExtension}</div>
                                </div>
                            ` : ''}
                            ${node.mimeType ? `
                                <div style="padding: 14px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">üîñ MIME</div>
                                    <div style="font-size: 11px; font-weight: 600; color: #A78BFA; font-family: monospace; word-break: break-all;">${node.mimeType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Dates -->
                        ${node.dateModified || node.dateCreated ? `
                            <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                                ${node.dateModified ? `
                                    <div style="flex: 1; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üìÖ Modified</div>
                                        <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${formatDate(node.dateModified)}</div>
                                    </div>
                                ` : ''}
                                ${node.dateCreated ? `
                                    <div style="flex: 1; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üÜï Created</div>
                                        <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${formatDate(node.dateCreated)}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Owner & Path -->
                        ${node.fileOwner ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üë§ Owner</div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.fileOwner}</div>
                            </div>
                        ` : ''}
                        ${node.filePath ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">üìÇ Path</div>
                                <div style="font-size: 12px; color: var(--text-primary); font-family: monospace; word-break: break-all;">${node.filePath}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            body.innerHTML = `
                ${pmDashboardHtml}
                ${patternInfoHtml}
                ${filesystemInfoHtml}
                <div class="info-section">
                    <h4>ID</h4>
                    <p><code style="background: var(--bg); padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 12px;">${node.id || 'N/A'}</code></p>
                </div>
                ${PATTERNS[currentPattern].fields?.cost && node.type !== 'root' ? `
                <div class="info-section">
                    <h4>Cost</h4>
                    <p class="value">${formatCost(node.cost || 0)}</p>
                </div>
                ` : ''}
                ${node.type === 'root' ? `
                <div class="info-section">
                    <h4>Total Cost</h4>
                    <p class="value">${formatCost(calculateTotal(node))}</p>
                </div>
                ` : ''}
                <div class="info-section">
                    <h4>Description</h4>
                    <p>${node.description || node.subtitle || 'N/A'}</p>
                </div>
                <div class="info-section">
                    <h4>Type</h4>
                    <p>${node.itemType || node.type || 'N/A'}</p>
                </div>
                ${node.alternateSource ? `
                    <div class="info-section">
                        <h4>Alternate Source</h4>
                        <p style="font-size: 14px; line-height: 1.6;">üì¶ ${node.alternateSource}</p>
                    </div>
                ` : ''}
                ${node.leadTime ? `
                    <div class="info-section">
                        <h4>Lead Time</h4>
                        <p style="font-size: 14px; line-height: 1.6;">‚è±Ô∏è ${node.leadTime}</p>
                    </div>
                ` : ''}
                ${node.notes ? `
                    <div class="info-section">
                        <h4>Context Notes</h4>
                        <p style="background: var(--bg); padding: 12px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary); font-size: 13px; line-height: 1.6; white-space: pre-wrap;">${node.notes}</p>
                    </div>
                ` : ''}
                ${depsHtml}
                ${dependentsHtml}
                ${node.type === 'phase' ? `
                    <div class="info-section">
                        <h4>Phase Total</h4>
                        <p class="value">${formatCost(calculatePhaseTotal(node))}</p>
                    </div>
                ` : ''}
                ${node.type === 'root' ? `
                    <div class="info-section">
                        <h4>Total Cost</h4>
                        <p class="value">${formatCost(calculateTotal(node))}</p>
                    </div>
                ` : ''}
            `;

            panel.classList.add('open');
            currentOpenItemId = node.id;
        }

        // Track which item's panel is currently open
        let currentOpenItemId = null;

        document.getElementById('close-info').addEventListener('click', () => {
            document.getElementById('info-panel').classList.remove('open');
            currentOpenItemId = null;
        });

        // Context Menu
        function showContextMenu(x, y) {
            const menu = document.getElementById('context-menu');
            const labels = getPatternLabels();

            // Build menu dynamically based on node type
            let menuHtml = '';

            if (activeNode.type === 'item') {
                // Item context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.item}</div>
                    <div class="context-item" id="ctx-add-subtask">‚ûï Add ${labels.subtask}</div>
                    <div class="context-item" id="ctx-delete">üóëÔ∏è Delete ${labels.item}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ AI Analysis</div>
                `;
            } else if (activeNode.type === 'subtask') {
                // Subtask context menu (can now have nested subtasks)
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.subtask}</div>
                    <div class="context-item" id="ctx-add-subtask">‚ûï Add Nested ${labels.subtask}</div>
                    <div class="context-item" id="ctx-delete">üóëÔ∏è Delete ${labels.subtask}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ AI Analysis</div>
                `;
            } else if (activeNode.type === 'phase') {
                // Phase context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.phase}</div>
                    <div class="context-item" id="ctx-create">‚ûï Add ${labels.item} to ${activeNode.name}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ AI Analysis</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">üíæ Download JSON</div>
                    <div class="context-item" id="ctx-upload">üìÇ Upload JSON</div>
                `;
            } else if (activeNode.type === 'root') {
                // Root context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">üìã View Details</div>
                    <div class="context-item" id="ctx-edit">‚úèÔ∏è Edit ${labels.root}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-expand">üìÇ Expand All</div>
                    <div class="context-item" id="ctx-collapse">üìÅ Collapse All</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ü§ñ ${labels.root} AI Analysis</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">üíæ Download JSON</div>
                    <div class="context-item" id="ctx-upload">üìÇ Upload JSON</div>
                `;
            }

            menu.innerHTML = menuHtml;
            menu.style.display = 'block';

            // Position menu first (to measure dimensions)
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Check if menu goes off screen and adjust position
            const menuRect = menu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            let finalX = x;
            let finalY = y;

            // Adjust horizontal position if menu goes off right edge
            if (menuRect.right > viewportWidth) {
                finalX = viewportWidth - menuRect.width - 10;
            }

            // Adjust vertical position if menu goes off bottom edge
            if (menuRect.bottom > viewportHeight) {
                finalY = viewportHeight - menuRect.height - 10;
            }

            // Ensure menu doesn't go off left edge
            if (finalX < 10) finalX = 10;

            // Ensure menu doesn't go off top edge
            if (finalY < 10) finalY = 10;

            menu.style.left = finalX + 'px';
            menu.style.top = finalY + 'px';

            // Re-attach event listeners
            attachContextMenuListeners();
        }

        function attachContextMenuListeners() {
            const viewBtn = document.getElementById('ctx-view');
            const editBtn = document.getElementById('ctx-edit');
            const createBtn = document.getElementById('ctx-create');
            const addSubtaskBtn = document.getElementById('ctx-add-subtask');
            const deleteBtn = document.getElementById('ctx-delete');
            const aiBtn = document.getElementById('ctx-ai');
            const downloadBtn = document.getElementById('ctx-download');
            const uploadBtn = document.getElementById('ctx-upload');
            const expandBtn = document.getElementById('ctx-expand');
            const collapseBtn = document.getElementById('ctx-collapse');

            if (viewBtn) viewBtn.onclick = handleViewDetails;
            if (editBtn) editBtn.onclick = handleEdit;
            if (createBtn) createBtn.onclick = handleCreate;
            if (addSubtaskBtn) addSubtaskBtn.onclick = handleAddSubtask;
            if (deleteBtn) deleteBtn.onclick = handleDelete;
            if (aiBtn) aiBtn.onclick = handleAI;
            if (downloadBtn) downloadBtn.onclick = handleDownload;
            if (uploadBtn) uploadBtn.onclick = handleUpload;
            if (expandBtn) expandBtn.onclick = handleExpandAll;
            if (collapseBtn) collapseBtn.onclick = handleCollapseAll;
        }

        document.addEventListener('click', () => {
            document.getElementById('context-menu').style.display = 'none';
        });

        // Context menu handlers
        function handleViewDetails() {
            if (activeNode) showInfo(activeNode);
        }

        // =============================================================================
        // SMART SUGGESTION ENGINE - AI-Powered with Pattern Expertise
        // =============================================================================

        // Helper: Extract tree context for AI suggestions
        function extractTreeContext(itemContext) {
            const allItems = getAllProjectItems(capexTree);

            // Find current phase
            let currentPhase = null;
            let siblingItems = [];
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    if (phase.items && phase.items.find(item => item.id === itemContext.id)) {
                        currentPhase = phase;
                        siblingItems = phase.items.filter(item => item.id !== itemContext.id);
                        break;
                    }
                }
            }

            // Find items this depends on
            const dependencies = [];
            if (itemContext.dependencies) {
                itemContext.dependencies.forEach(depId => {
                    const depItem = allItems.find(item => item.id === depId);
                    if (depItem) dependencies.push(depItem);
                });
            }

            // Find items that depend on this
            const dependents = allItems.filter(item =>
                item.dependencies && item.dependencies.includes(itemContext.id)
            );

            return {
                projectName: capexTree.name || 'Project',
                projectDescription: capexTree.description || '',
                pattern: currentPattern,
                totalItems: allItems.length,
                currentPhase: currentPhase ? {
                    name: currentPhase.name,
                    subtitle: currentPhase.subtitle,
                    itemCount: currentPhase.items?.length || 0
                } : null,
                siblingItems: siblingItems.slice(0, 5), // Limit to 5 for context
                dependencies: dependencies.slice(0, 3),
                dependents: dependents.slice(0, 3),
                allItems: allItems.slice(0, 10) // Sample for pattern learning
            };
        }

        // Helper: Build pattern-expert AI prompts
        function buildPatternExpertPrompt(fieldType, itemContext, treeContext) {
            const pattern = currentPattern;

            // Base context shared across all patterns
            let prompt = `You are a subject matter expert for ${pattern} pattern projects. `;

            // Pattern-specific expert persona
            const expertPersonas = {
                philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments.',
                sales: 'You are a sales strategist with 20 years of enterprise B2B experience.',
                thesis: 'You are an academic advisor helping graduate students structure rigorous research.',
                roadmap: 'You are a product manager experienced in agile development and feature prioritization.',
                prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude and GPT-4.',
                book: 'You are a professional fiction editor and writing coach.',
                film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway).',
                course: 'You are an instructional designer with expertise in curriculum development.',
                fitness: 'You are a certified personal trainer and exercise physiologist with expertise in program design, exercise science, and progressive overload.',
                event: 'You are a professional event planner with experience in corporate events, weddings, and large-scale conferences.',
                strategy: 'You are a business strategy consultant specializing in strategic planning, KPI development, and organizational transformation.',
                familytree: 'You are a professional genealogist and family historian specializing in genealogical research and family tree documentation.',
                dialogue: 'You are a rhetoric and argumentation expert specializing in debate analysis, persuasive communication, and identifying logical fallacies.',
                gmail: 'You are an expert email analyst and communication strategist. You analyze email threads for tone, intent, rhetoric, and relationship dynamics. You provide context-aware suggestions for responses based on the full conversation history.',
                generic: 'You are an experienced Project Manager and CFO with deep expertise in budget management, resource allocation, risk mitigation, and financial planning for complex projects.'
            };

            prompt += expertPersonas[pattern] || expertPersonas.generic;
            prompt += `\n\n`;

            // Project context (trimmed for speed)
            prompt += `PROJECT: ${treeContext.projectName}`;
            if (treeContext.currentPhase) {
                prompt += ` - ${treeContext.currentPhase.name}`;
            }
            prompt += `\n\n`;

            // Current item context (trimmed)
            prompt += `ITEM: ${itemContext.name || 'New Item'}\n`;
            if (itemContext.description && itemContext.description.length < 200) {
                prompt += `${itemContext.description.substring(0, 200)}\n`;
            }

            // Add existing field values for context
            const relevantFields = ['speaker', 'conclusion', 'premise1', 'premise2',
                                    'dealValue', 'contactPerson', 'leadSource',
                                    'keyArgument', 'evidenceType',
                                    'videoPrompt', 'visualStyle', 'cameraMovement',
                                    'itemType', 'notes'];
            relevantFields.forEach(field => {
                if (itemContext[field] && field !== fieldType) {
                    prompt += `- ${field}: ${itemContext[field]}\n`;
                }
            });

            // Dependencies (minimal, for speed)
            if (treeContext.dependencies.length > 0) {
                prompt += `Builds on: ${treeContext.dependencies.map(d => d.name).join(', ')}\n`;
            }

            // Sibling examples (limit to 2, show only relevant field)
            if (treeContext.siblingItems.length > 0) {
                const examples = treeContext.siblingItems
                    .filter(sib => sib[fieldType])
                    .slice(0, 2)
                    .map(sib => String(sib[fieldType]).substring(0, 60));
                if (examples.length > 0) {
                    prompt += `Examples: ${examples.join('; ')}\n`;
                }
            }

            prompt += `\n`;

            // CONTINUITY INSTRUCTIONS for sequential/narrative patterns
            const sequentialPatterns = ['film', 'book', 'roadmap'];
            if (sequentialPatterns.includes(pattern) && treeContext.siblingItems.length > 0) {
                const lastSibling = treeContext.siblingItems[treeContext.siblingItems.length - 1];
                prompt += `‚ö†Ô∏è CONTINUITY REQUIREMENT:\n`;
                prompt += `This item follows: "${lastSibling.name}"\n`;

                if (pattern === 'film') {
                    prompt += `Ensure visual/narrative continuity from previous scene:\n`;
                    if (lastSibling.description) prompt += `- Previous scene: ${lastSibling.description.substring(0, 100)}\n`;
                    if (lastSibling.lightingMood) prompt += `- Previous lighting: ${lastSibling.lightingMood}\n`;
                    prompt += `- If previous scene ended with location change/fade, this scene must establish new context\n`;
                    prompt += `- Maintain consistent visual style and tone unless intentionally shifting\n`;
                } else if (pattern === 'book') {
                    prompt += `Ensure narrative continuity from previous chapter/section:\n`;
                    if (lastSibling.description) prompt += `- Previous: ${lastSibling.description.substring(0, 100)}\n`;
                    prompt += `- Maintain character consistency, plot coherence, and thematic threads\n`;
                    prompt += `- If starting new section/arc, provide logical handover from previous\n`;
                } else if (pattern === 'roadmap') {
                    prompt += `Ensure feature sequencing makes sense:\n`;
                    if (lastSibling.description) prompt += `- Previous feature: ${lastSibling.description.substring(0, 100)}\n`;
                    prompt += `- Check dependencies: does this feature build on or require the previous one?\n`;
                    prompt += `- If starting new phase, ensure logical progression from previous phase goals\n`;
                }
                prompt += `\n`;
            }

            // Pattern-specific field instructions
            prompt += buildFieldInstructions(pattern, fieldType, itemContext);

            prompt += `\nReturn ONLY the ${fieldType} value (1-3 sentences, no explanation).\n`;

            return prompt;
        }

        // Helper: Pattern-specific field instructions
        function buildFieldInstructions(pattern, fieldType, itemContext) {
            let instructions = `YOUR TASK: Suggest a ${fieldType} for the current item.\n\n`;

            // Philosophy pattern
            if (pattern === 'philosophy') {
                const fieldInstructions = {
                    speaker: 'Suggest the most appropriate philosophical speaker/author for this argument based on the topic and historical context.',
                    premise1: 'Suggest a first premise that would logically support the conclusion. Use clear, precise philosophical language.',
                    premise2: 'Suggest a second premise that bridges premise1 to the conclusion, creating a valid logical inference.',
                    premise3: 'Suggest a third premise if needed to complete the argument structure.',
                    conclusion: 'Suggest a philosophical conclusion that follows from the premises. State it clearly and precisely.',
                    objection: 'Suggest a strong objection to this argument - what would a critic say? Be specific and philosophically rigorous.',
                    response: 'Suggest how the author would respond to the objection. Use careful distinctions and counterarguments.',
                    keyTerms: 'List 3-5 key philosophical terms central to this argument (comma-separated).',
                    textualReference: 'Suggest specific textual references (work and section numbers) where this argument appears or is discussed.',
                    description: 'Write a 2-3 sentence description of this philosophical argument, its method, and its significance.',
                    name: 'Suggest a concise title for this philosophical argument that captures its core claim.',
                    notes: 'Suggest key considerations for evaluating this argument: validity, soundness, implications, objections.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Sales pattern
            else if (pattern === 'sales') {
                const fieldInstructions = {
                    dealValue: 'Suggest a realistic deal value (in thousands $K) based on the deal type and company size.',
                    contactPerson: 'Suggest the most likely decision-maker title for this type of deal.',
                    leadSource: 'Suggest the most probable lead source for this deal type.',
                    competitorInfo: 'Suggest realistic competitive intelligence: who are we competing against and how do we differentiate? (2-3 sentences)',
                    expectedCloseDate: 'Suggest a realistic close date based on deal size and sales cycle.',
                    stageProbability: 'Suggest a close probability (0-100) based on the deal stage and context.',
                    description: 'Write a 2-3 sentence description of this sales opportunity, key stakeholders, and success factors.',
                    name: 'Suggest a descriptive name for this deal that includes company type and solution.',
                    notes: 'Suggest key considerations: budget timing, decision process, procurement, champion identification.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Thesis pattern
            else if (pattern === 'thesis') {
                const fieldInstructions = {
                    keyArgument: 'Suggest the main thesis argument for this chapter/section. What gap does it address? What contribution does it make?',
                    citations: 'Suggest 3-5 realistic academic citations (Author Year format) relevant to this topic.',
                    evidenceType: 'Suggest the most appropriate evidence type (Empirical, Theoretical, Mixed, Case Study, etc.).',
                    wordCount: 'Suggest a realistic current word count for this section.',
                    targetWordCount: 'Suggest an appropriate target word count based on section type.',
                    description: 'Write a 2-3 sentence description of this chapter/section: its argument, evidence, and contribution.',
                    name: 'Suggest a clear chapter/section title that reflects its content and argument.',
                    notes: 'Suggest key considerations: citation completeness, argument coherence, methodological rigor.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Film pattern
            else if (pattern === 'film') {
                const fieldInstructions = {
                    videoPrompt: 'Suggest a detailed Sora/Veo prompt (100-200 chars) for this scene. Include: subject, action, camera movement, lighting, style. Be cinematic and specific.',
                    cameraMovement: 'Suggest the most appropriate camera movement for this scene type and mood.',
                    lightingMood: 'Suggest the best lighting mood based on time of day, genre, and emotional tone.',
                    visualStyle: 'Suggest the visual style that best matches this scene\'s purpose and genre.',
                    duration: 'Suggest appropriate clip duration based on scene complexity and action.',
                    aiPlatform: 'Suggest the best AI platform (Sora, Veo 3, Runway Gen-3) for this scene type.',
                    description: 'Write a 2-3 sentence description of this scene: what happens, mood, visual approach.',
                    name: 'Suggest a concise scene name that captures the key action or emotion.',
                    notes: 'Suggest key considerations: continuity, platform strengths, prompt specificity, motion artifacts.',
                    iterationNotes: 'Suggest prompt engineering tips specific to this scene type.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Roadmap pattern
            else if (pattern === 'roadmap') {
                const fieldInstructions = {
                    storyPoints: 'Suggest story point estimate (Fibonacci: 1,2,3,5,8,13) based on feature complexity.',
                    userImpact: 'Suggest user impact level (Low/Medium/High/Critical) based on affected user percentage and importance.',
                    technicalRisk: 'Suggest technical risk (Low/Medium/High) considering dependencies, unknowns, and complexity.',
                    engineeringEstimate: 'Suggest time estimate in sprints/weeks based on complexity.',
                    featureFlag: 'Suggest a feature flag name following naming conventions (feature_*).',
                    description: 'Write 2-3 sentences: what this feature does, who it affects, and key success metrics.',
                    name: 'Suggest a clear feature name that describes the user-facing capability.',
                    notes: 'Suggest key considerations: testing requirements, rollout strategy, monitoring, documentation.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Prompting pattern
            else if (pattern === 'prompting') {
                const fieldInstructions = {
                    systemPrompt: 'Suggest a clear, specific system prompt defining the AI\'s role, capabilities, and constraints. Use Anthropic best practices.',
                    userPromptTemplate: 'Suggest a user prompt template with {{variables}} and XML tags for structure.',
                    fewShotExamples: 'Suggest 1-2 few-shot examples in <examples><example> format showing input/output patterns.',
                    chainOfThought: 'Suggest CoT instructions: "Think step by step..." tailored to this task.',
                    outputFormat: 'Suggest the expected output structure (markdown, JSON, specific sections).',
                    structuralTags: 'Suggest XML tags for this task (e.g., <thinking>, <answer>, <critique>).',
                    assistantPrefill: 'Suggest an assistant prefill to guide tone and format.',
                    toolDefinitions: 'Suggest tool/function definitions if this task needs tool calling (JSON schema).',
                    modelTarget: 'Suggest the best model (Claude 3.5 Sonnet, GPT-4o, etc.) for this use case.',
                    temperature: 'Suggest temperature (0-1). Use 0-0.3 for deterministic tasks, 0.7-1.0 for creative.',
                    description: 'Write 2-3 sentences: what this prompt does, its approach, and optimization goals.',
                    name: 'Suggest a descriptive name for this prompt use case.',
                    notes: 'Suggest OpenAI/Anthropic best practices applied to this specific prompt.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Generic pattern - PM and CFO perspective
            else if (pattern === 'generic') {
                const fieldInstructions = {
                    cost: 'Suggest a realistic cost estimate based on the item type, scope, and market rates. Consider labor, materials, overhead.',
                    leadTime: 'Suggest a realistic timeline considering procurement cycles, dependencies, and resource availability.',
                    alternateSource: 'Suggest a credible backup vendor or alternative approach to mitigate supply chain/delivery risks.',
                    pmNextSteps: 'Suggest 2-3 specific, actionable next steps a PM would take to advance this task.',
                    pmBlockingIssue: 'Identify likely blockers: budget constraints, resource conflicts, vendor delays, approvals needed.',
                    description: 'Write 2-3 sentences describing this deliverable, its business value, and key execution considerations.',
                    name: 'Suggest a clear deliverable name that communicates scope and business value.',
                    notes: 'Suggest PM considerations: budget burn rate, stakeholder alignment, risk mitigation, change management.',
                    pmOwnerEmail: 'Suggest the most appropriate role/person to own this (e.g., engineering-lead@, procurement@, finance@).'
                };
                instructions += fieldInstructions[fieldType] || `From a PM and CFO perspective, suggest a realistic ${fieldType} value considering budget, timeline, and risk factors.`;
            }

            // Gmail pattern - Email analysis and response generation
            else if (pattern === 'gmail') {
                const fieldInstructions = {
                    subjectLine: 'Suggest 2-3 high-converting subject lines based on the email context. Keep under 50 characters. Avoid spammy words. Focus on value or curiosity.',
                    emailBody: 'Analyze the full conversation thread and suggest a contextually-appropriate response. Reference previous messages. Match the tone and formality level. Include a clear call to action if appropriate.',
                    recipientEmail: 'Suggest the likely recipient based on the conversation context and sender patterns.',
                    status: 'Suggest the appropriate email status (Draft/Sent/Replied/Archived) based on the conversation state.',
                    name: 'Suggest a short internal name for this email thread that captures the main topic or business context.',
                    description: 'Analyze this email thread: summarize the key points, identify the tone/sentiment, note any action items, and assess relationship dynamics.',
                    notes: 'Suggest key observations: communication style, negotiation position, objections raised, next steps needed, relationship temperature (warm/neutral/cold).'
                };
                instructions += fieldInstructions[fieldType] || `Analyze the email context and conversation history to suggest an appropriate ${fieldType} value.`;
            }

            // Other patterns
            else {
                instructions += `Consider the project context, dependencies, and sibling items. Suggest a realistic, specific ${fieldType} value that fits the pattern.`;
            }

            return instructions;
        }

        // MAIN AI SUGGESTION FUNCTION (async with AI integration)
        async function generateAISuggestion(fieldType, itemContext) {
            console.log('ü§ñ generateAISuggestion called:', fieldType);

            // Check global AI mode
            const aiMode = getGlobalAIMode();
            console.log('ü§ñ Global AI Mode:', aiMode);

            if (aiMode === 'off') {
                console.log('‚ùå AI features disabled, using static fallback');
                return generateStaticSuggestion(fieldType, itemContext);
            }

            // Check if API key is available (needed for all modes)
            const apiKey = getLocalAPIKey(getAIProvider());
            console.log('üîë API Key present:', !!apiKey);

            if (!apiKey && aiMode === 'deep') {
                console.log('‚ö†Ô∏è Deep Mode requires API key, falling back to static');
                alert('üî¨ Deep Mode requires your own API key.\n\nPlease configure your API key (üîë button) or switch to Quick Mode in the header.');
                return generateStaticSuggestion(fieldType, itemContext);
            }

            if (!apiKey && aiMode === 'quick') {
                console.log('‚ö° Quick Mode: Will use server API key');
            }

            try {
                // Extract full tree context
                console.log('üìä Extracting tree context...');
                const treeContext = extractTreeContext(itemContext);
                console.log('üìä Tree context extracted:', treeContext);

                // Build pattern-expert prompt
                console.log('üìù Building expert prompt...');
                const expertPrompt = buildPatternExpertPrompt(fieldType, itemContext, treeContext);
                console.log('üìù Expert prompt built, length:', expertPrompt.length);

                // Call Claude API for intelligent suggestion (low token limit for speed)
                console.log('‚òÅÔ∏è Calling Claude API...');
                const suggestion = await callClaudeAPI(expertPrompt, '', 256); // 256 tokens max = faster, stays under 10s Netlify limit
                console.log('‚òÅÔ∏è Claude API response:', suggestion);

                // Clean up the response (remove quotes, trim)
                let cleaned = suggestion.trim();
                if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
                    cleaned = cleaned.slice(1, -1);
                }
                if (cleaned.startsWith("'") && cleaned.endsWith("'")) {
                    cleaned = cleaned.slice(1, -1);
                }

                console.log('‚ú® Returning cleaned suggestion:', cleaned);
                return cleaned || generateStaticSuggestion(fieldType, itemContext);

            } catch (error) {
                console.error('‚ùå AI suggestion failed, falling back to static:', error);
                console.error('Error details:', error.message, error.stack);
                return generateStaticSuggestion(fieldType, itemContext);
            }
        }

        // STATIC SUGGESTION ENGINE (fallback when no API key)
        function generateStaticSuggestion(fieldType, itemContext) {
            const pattern = PATTERNS[currentPattern];
            const itemType = itemContext.itemType || '';
            const phase = itemContext.id ? itemContext.id.split('-')[0] : 'p0';
            const notes = itemContext.notes || '';

            // Get all existing items for contextual analysis
            function getAllProjectItems(node = capexTree, items = []) {
                if (node.items) items.push(...node.items);
                if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
                return items;
            }
            const existingItems = getAllProjectItems();

            // Pattern-aware AI suggestion templates - Subject matter experts for each domain
            const patternSuggestions = {
                philosophy: {
                    name: ['Knowledge is Virtue', 'The Nature of Justice', 'Definition of Piety', 'Forms vs Particulars', 'The Good Life', 'Moral Relativism Critique', 'Socratic Paradox', 'The Cave Allegory', 'Mind-Body Problem', 'Free Will vs Determinism'],
                    description: 'Dialectical examination of fundamental concepts through logical argumentation. Present premises systematically, consider objections, and respond with careful distinctions. Ground claims in textual evidence and philosophical tradition.',
                    speaker: ['Socrates', 'Plato', 'Aristotle', 'Meno', 'Euthyphro', 'Thrasymachus', 'Glaucon', 'Adeimantus'],
                    premise1: 'All humans desire what is genuinely good for them.',
                    premise2: 'If someone pursues what is harmful, they must not recognize it as harmful.',
                    conclusion: 'Therefore, wrongdoing is a form of ignorance, not deliberate evil.',
                    objection: 'Some people knowingly pursue harmful pleasures despite understanding the consequences.',
                    response: 'True knowledge of harm would necessarily prevent pursuit; what appears as knowledge may be mere belief.',
                    keyTerms: 'virtue, knowledge, piety, justice, wisdom, excellence (arete)',
                    textualReference: 'Meno 77b-78b, Protagoras 352-358',
                    notes: 'Consider: logical validity of argument, strength of premises, historical context, counterexamples from lived experience, implications for ethics and epistemology.'
                },
                sales: {
                    name: ['Enterprise Cloud Migration', 'SaaS Platform Expansion', 'Strategic Partnership Deal', 'Fortune 500 Account', 'Multi-Year Service Agreement', 'Technology Integration Project'],
                    description: 'High-value opportunity requiring executive engagement and multi-stakeholder alignment. Key success factors: clear ROI demonstration, competitive differentiation, and relationship-building with economic buyer.',
                    leadSource: 'Inbound marketing, industry conference referral, or strategic partner introduction',
                    contactPerson: 'VP of IT, CFO, or Chief Digital Officer',
                    competitorInfo: 'Competing against 2-3 established vendors. Differentiation: superior support, proven ROI, and industry-specific features.',
                    notes: 'Key considerations: budget approval timing, decision-making process, technical evaluation criteria, procurement requirements, champion identification, stakeholder mapping.'
                },
                thesis: {
                    name: ['Literature Review', 'Theoretical Framework', 'Methodology Design', 'Data Analysis', 'Results Interpretation', 'Discussion of Findings', 'Limitations & Future Research'],
                    description: 'Critical analysis of existing scholarship establishing theoretical foundation for research. Synthesize major debates, identify gaps in literature, and position current study within academic discourse.',
                    keyArgument: 'Previous research has overlooked [specific aspect], creating need for [your contribution]. This study addresses gap through [your approach].',
                    citations: 'Smith (2020), Johnson & Lee (2019), Martinez et al. (2018), Chen (2021)',
                    evidenceType: 'Mixed: quantitative data analysis combined with qualitative case studies',
                    notes: 'Key considerations: citation completeness, argument coherence, gap identification, methodological rigor, contribution to field, clarity of research questions.'
                },
                roadmap: {
                    name: ['User Authentication V2', 'Mobile App Redesign', 'API Performance Optimization', 'Analytics Dashboard', 'Third-Party Integration', 'Search Functionality'],
                    description: 'User-facing feature delivering measurable business value. Requires cross-functional coordination between product, engineering, and design. Success metrics defined upfront.',
                    userImpact: 'High - affects 80% of active users',
                    technicalRisk: 'Medium - depends on third-party API stability',
                    engineeringEstimate: '2 sprints (4 weeks)',
                    featureFlag: 'feature_new_search_v2',
                    notes: 'Key considerations: user testing requirements, performance benchmarks, rollout strategy, rollback plan, monitoring and alerting, documentation needs.'
                },
                prompting: {
                    name: ['Customer Support Agent', 'Code Reviewer with CoT', 'RAG Query Handler', 'Content Generator', 'Multi-Agent Router', 'Safety Classifier', 'Summarizer with Examples', 'Function Calling Orchestrator'],
                    description: 'Production prompt engineered using OpenAI/Anthropic best practices. Clear role definition, task breakdown, few-shot examples, output format specification, and evaluation criteria. Optimized for consistency and reliability.',
                    systemPrompt: 'You are an expert customer support agent for a SaaS platform. Your goal is to resolve customer issues quickly while maintaining a friendly, professional tone. Always prioritize customer satisfaction. If you cannot resolve an issue, escalate appropriately with clear context.',
                    userPromptTemplate: 'A customer has reported the following issue:\n\n<customer_issue>\n{{issue}}\n</customer_issue>\n\n<context>\nAccount: {{account_tier}}\nPrevious tickets: {{ticket_history}}\n</context>\n\nAnalyze the issue and provide: 1) Root cause, 2) Resolution steps, 3) Prevention advice.',
                    fewShotExamples: '<examples>\n<example>\n<user>Login broken after password reset</user>\n<assistant>Root cause: Session cache not cleared. Resolution: Clear browser cache or wait 5 minutes for auto-refresh. Prevention: Use incognito mode during password changes.</assistant>\n</example>\n</examples>',
                    structuralTags: '<thinking>\nAnalyze issue type and severity\n</thinking>\n\n<answer>\nProvide structured response\n</answer>',
                    assistantPrefill: 'Here is my analysis of the customer issue:',
                    chainOfThought: 'Think step by step: First identify the symptom, then trace back to root cause, then propose the minimal effective solution.',
                    outputFormat: 'Use this structure:\n**Root Cause:** [one sentence]\n**Resolution:** [numbered steps]\n**Prevention:** [actionable advice]',
                    modelTarget: 'Claude 3.5 Sonnet',
                    temperature: 0.3,
                    maxTokens: 1500,
                    testResults: 'Golden set: 94% accuracy on 200 support tickets\nAvg latency: 1.8s\nCost: $0.025 per call\nCustomer satisfaction: 4.7/5',
                    toolDefinitions: '{\n  "escalate_ticket": {\n    "description": "Escalate to human agent",\n    "parameters": {"reason": "string", "priority": "high|medium|low"}\n  }\n}',
                    agentWorkflow: 'Single agent (support responder)\n‚Üí Optionally calls escalate_ticket function\n‚Üí Human agent takes over if escalated',
                    contextManagement: 'Sliding window: keep last 6 messages (3 turns)\nCompress older history with summarization\nToken budget: 8K context, 1.5K completion',
                    promptInjectionDefense: 'Use XML tags to separate user input: <customer_issue>{{untrusted}}</customer_issue>\nValidate output doesn\'t leak system prompt\nMonitor for jailbreak patterns',
                    iterationNotes: 'v1: Too verbose, 350 tokens avg\nv2: Added output format, reduced to 180 tokens\nv3: Few-shot examples improved consistency to 94%\nv4: Lowered temp from 0.7‚Üí0.3 for more deterministic responses',
                    notes: 'OpenAI/Anthropic best practices applied:\n- Clear system role (Anthropic: system parameter)\n- XML tags for structure (Anthropic recommendation)\n- Few-shot examples in <examples> tags\n- Assistant prefill to guide tone (Claude-specific)\n- Chain-of-thought instruction for reasoning\n- Explicit output format\n- Prompt injection defense with delimiters\n- Golden test set for validation\n- Iterative refinement based on metrics'
                },
                book: {
                    name: ['Opening Scene', 'Character Introduction', 'Rising Action', 'Climactic Confrontation', 'Resolution', 'Twist Reveal', 'Emotional Payoff', 'Transition Chapter'],
                    description: 'Narrative chapter advancing plot through character development, conflict escalation, or thematic exploration. Balance dialogue, action, and description. Maintain pacing and reader engagement.',
                    wordCount: 3500,
                    targetWordCount: 4000,
                    draftStatus: 'First Draft',
                    povCharacter: 'Sarah Chen (protagonist)',
                    sceneSetting: 'Downtown coffee shop, early morning, rain outside',
                    plotFunction: 'Establishes protagonist motivation and introduces central conflict',
                    notes: 'Key considerations: POV consistency, show vs tell balance, scene vs sequel structure, sensory details, dialogue authenticity, pacing variation, emotional beats, foreshadowing.'
                },
                film: {
                    name: ['Opening Establishing Shot', 'Character Introduction', 'Emotional Dialogue', 'Action Chase Sequence', 'Atmospheric Transition', 'Climactic Confrontation', 'Dream/Memory Sequence', 'Final Resolution'],
                    description: 'AI-generated video scene created through detailed text-to-video prompting. Specify camera movement, lighting, mood, action, and visual style. Iterate on prompt wording for best results. Consider continuity across shots.',
                    aiPlatform: 'Sora (OpenAI)',
                    videoPrompt: 'A cinematic close-up shot slowly pulling back to reveal a woman in her 30s standing at a rain-streaked window overlooking a neon-lit city at night. Soft blue and purple lighting from the city illuminates her contemplative expression. Camera movement: slow dolly back. Mood: melancholic, cyberpunk aesthetic. Shot on 35mm film, shallow depth of field, bokeh lights in background.',
                    visualStyle: 'Cinematic',
                    duration: '10 seconds',
                    aspectRatio: '16:9 (Widescreen)',
                    cameraMovement: 'Dolly Out',
                    motionIntensity: 'Subtle',
                    lightingMood: 'Neon',
                    iterationNotes: 'Best practices: Be extremely specific about camera movement and speed. Mention lighting sources explicitly. Use cinematography terms (bokeh, depth of field, shot types). Reference film stock or camera models for aesthetic cues. Specify exact actions and their duration. Include mood/emotion words. Test multiple aspect ratios - some models handle certain ratios better. Start with shorter durations for complex scenes. Use "slow", "gradual", "subtle" for smoother motion.',
                    notes: 'Key considerations: Prompt engineering (specificity vs brevity), continuity between shots, aspect ratio consistency, motion artifacts detection, prompt variations for A/B testing, platform-specific strengths (Sora: physics/realism, Veo: motion control, Runway: speed), generation cost budgeting, style consistency across scenes, temporal coherence for extended clips, copyright/likeness considerations.'
                },
                course: {
                    name: ['Introduction to Topic', 'Foundational Concepts', 'Hands-On Lab Exercise', 'Case Study Analysis', 'Group Discussion', 'Skill Application Project', 'Assessment', 'Review Session'],
                    description: 'Instructional session designed to build student knowledge and skills through active learning. Combines lecture, practice, and assessment. Aligned with course learning objectives.',
                    learningObjectives: 'Students will be able to: 1) Define key concepts, 2) Apply techniques to novel problems, 3) Analyze real-world examples, 4) Evaluate trade-offs',
                    duration: '90 minutes',
                    difficultyLevel: 'Intermediate',
                    prerequisites: 'Completion of Module 2, basic programming knowledge, familiarity with data structures',
                    assessmentType: 'Quiz',
                    resourcesNeeded: 'Textbook Chapter 5, online simulation tool, practice dataset, reference handout',
                    homework: 'Complete problem set 4 (problems 1-10), read Chapter 6, prepare discussion questions',
                    notes: 'Key considerations: accessibility accommodations, engagement strategies, timing flexibility, technology backup plans, formative assessment checkpoints, inclusive pedagogy, active learning techniques.'
                },
                strategic: {
                    name: ['Digital Transformation Initiative', 'Market Expansion Strategy', 'Operational Excellence Program', 'Customer Experience Overhaul', 'Innovation Portfolio', 'Risk Mitigation Plan', 'Sustainability Initiative'],
                    description: 'Strategic initiative aligned with organizational priorities. Requires executive sponsorship, cross-functional resources, and measurable outcomes. Board-level visibility and quarterly review cadence.',
                    investment: 2500000,
                    keyMetric: 'Revenue growth in target segment',
                    targetValue: '25% year-over-year increase',
                    responsibleExecutive: 'Chief Strategy Officer',
                    strategicTheme: 'Growth',
                    riskLevel: 'Medium',
                    notes: 'Key considerations: stakeholder alignment, resource allocation, change management, governance structure, milestone tracking, competitive response, market timing, regulatory compliance.'
                },
                generic: {
                    name: {
                        land: ['Land Acquisition & Title', 'Site Purchase & Legal', 'Property Option Agreement'],
                        engineering: ['Engineering Design Services', 'Technical Specification Development', 'System Architecture'],
                        equipment: ['Equipment Procurement', 'Hardware Purchase & Installation', 'Capital Equipment'],
                        infrastructure: ['Infrastructure Development', 'Site Preparation', 'Facility Build-Out'],
                        corporate: ['Corporate Administration', 'Business Operations', 'Management Overhead'],
                        professional: ['Professional Services', 'Consulting & Advisory', 'Expert Services'],
                        contingency: ['Contingency Reserve', 'Risk Mitigation Fund', 'Budget Reserve']
                    },
                    description: {
                        equipment: 'Procurement of capital equipment with extended lead times. Requires vendor evaluation, competitive bidding, and early commitment to secure production slots.',
                        default: 'Detailed specification of deliverables, timeline, dependencies, and success criteria. Coordinate with stakeholders and manage risks proactively.'
                    },
                    cost: { p0: [50000, 100000, 250000], p1: [500000, 1000000, 2000000], p2: [25000000, 50000000, 100000000] },
                    alternateSource: 'Secondary vendors, in-house capability, strategic partnerships, or alternative procurement strategies',
                    leadTime: { p0: '2-8 weeks', p1: '3-6 months', p2: '12-24 months' },
                    notes: 'Key considerations: timeline, budget allocation, vendor selection, risk mitigation, quality assurance, regulatory compliance.'
                }
            };

            // PATTERN-AWARE SUGGESTION GENERATION - Each pattern acts as subject expert
            const patternKey = currentPattern;
            const patternData = patternSuggestions[patternKey] || patternSuggestions.generic;

            // Handle pattern-specific fields (philosophy, sales, thesis, etc.)
            if (patternData[fieldType]) {
                const suggestion = patternData[fieldType];

                // If array, pick random option
                if (Array.isArray(suggestion)) {
                    return suggestion[Math.floor(Math.random() * suggestion.length)];
                }

                // If string, return directly
                return suggestion;
            }

            // Common fields handled for all patterns
            if (fieldType === 'name') {
                if (patternKey === 'generic' && patternData.name[itemType]) {
                    const options = patternData.name[itemType];
                    return options[Math.floor(Math.random() * options.length)];
                }
                return `New ${pattern.levels.item || 'Item'}`;
            }

            if (fieldType === 'description') {
                if (patternKey === 'generic' && itemType) {
                    return patternData.description[itemType] || patternData.description.default;
                }
                return patternData.description || 'Enter detailed description here...';
            }

            if (fieldType === 'notes') {
                return patternData.notes || 'Key considerations and implementation notes...';
            }

            if (fieldType === 'icon') {
                const iconMap = {
                    philosophy: ['ü§î', 'üí≠', 'üìú', 'üèõÔ∏è', '‚öñÔ∏è'],
                    sales: ['üíº', 'üí∞', 'üìä', 'ü§ù', 'üìà'],
                    thesis: ['üìö', 'üìù', 'üéì', 'üìñ', '‚úçÔ∏è'],
                    roadmap: ['üöÄ', '‚ö°', 'üîß', 'üí°', 'üéØ'],
                    prompting: ['üß†', 'ü§ñ', '‚öôÔ∏è', 'üîÆ', 'üí¨'],
                    book: ['üìñ', '‚úçÔ∏è', 'üìö', 'üñãÔ∏è', 'üìù'],
                    film: ['üé¨', 'üé•', 'üéûÔ∏è', 'üé≠', 'üìπ'],
                    course: ['üìñ', 'üéì', 'üìö', 'üë®‚Äçüè´', 'üìù'],
                    strategic: ['üéØ', 'üìä', 'üèõÔ∏è', 'üíº', 'üó∫Ô∏è'],
                    generic: ['üì¶', '‚öôÔ∏è', 'üîß', 'üìä', 'üíº']
                };
                const icons = iconMap[patternKey] || iconMap.generic;
                return icons[Math.floor(Math.random() * icons.length)];
            }

            // Generic pattern: cost and leadTime (other patterns don't use these)
            if (fieldType === 'cost' && patternKey === 'generic') {
                const similarItems = existingItems.filter(item => item.itemType === itemType && item.cost > 0);
                if (similarItems.length > 0) {
                    const costs = similarItems.map(i => i.cost).sort((a, b) => a - b);
                    const median = costs[Math.floor(costs.length / 2)];
                    return Math.round(median * (0.9 + Math.random() * 0.2));
                }
                const costRanges = patternData.cost[phase] || patternData.cost.p1;
                return costRanges[Math.floor(Math.random() * costRanges.length)];
            }

            if (fieldType === 'leadTime' && patternKey === 'generic') {
                return patternData.leadTime[phase] || patternData.leadTime.p1;
            }

            if (fieldType === 'alternateSource' && patternKey === 'generic') {
                return patternData.alternateSource;
            }

            return '';
        }

        // Add AI suggestion capability to text fields
        function enableAISuggestionsOnField(fieldElement, fieldType, itemContext) {
            fieldElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Check if API key available for AI mode
                const hasAPIKey = getLocalAPIKey();
                const modeLabel = hasAPIKey ? '‚ú® AI Suggest' : 'üí° Quick Suggest';
                const modeDesc = hasAPIKey ? 'AI-powered contextual suggestion' : 'Template-based suggestion (add API key for AI mode)';

                // Show smart suggestion context menu
                const menu = document.getElementById('context-menu');
                menu.innerHTML = `
                    <div class="context-item" id="ai-suggest-field">${modeLabel}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" style="font-size: 11px; color: var(--text-secondary); cursor: default; padding: 8px 14px;" onmouseover="this.style.background='transparent'">${modeDesc}</div>
                `;
                menu.style.display = 'block';

                // Position menu
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';

                // Smart positioning to avoid going off screen
                const menuRect = menu.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                let finalX = e.pageX;
                let finalY = e.pageY;

                if (menuRect.right > viewportWidth) {
                    finalX = viewportWidth - menuRect.width - 10;
                }
                if (menuRect.bottom > viewportHeight) {
                    finalY = viewportHeight - menuRect.height - 10;
                }
                if (finalX < 10) finalX = 10;
                if (finalY < 10) finalY = 10;

                menu.style.left = finalX + 'px';
                menu.style.top = finalY + 'px';

                // Attach AI suggest handler (ASYNC)
                const aiSuggestBtn = document.getElementById('ai-suggest-field');
                aiSuggestBtn.onclick = async () => {
                    console.log('üîç Smart Suggest clicked:', fieldType, hasAPIKey ? 'AI mode' : 'Quick mode');
                    menu.style.display = 'none';

                    // Get current context including notes field value
                    const currentContext = { ...itemContext };
                    const notesField = document.getElementById('edit-notes');
                    if (notesField) {
                        currentContext.notes = notesField.value;
                    }

                    console.log('üìã Context:', currentContext);

                    // Show loading state
                    const originalValue = fieldElement.value;
                    const originalPlaceholder = fieldElement.placeholder;
                    fieldElement.value = '';
                    fieldElement.placeholder = hasAPIKey ? '‚ú® AI is thinking...' : 'üí° Generating suggestion...';
                    fieldElement.style.transition = 'all 0.3s';
                    fieldElement.style.background = 'rgba(99, 102, 241, 0.1)';
                    fieldElement.disabled = true;

                    try {
                        console.log('‚è≥ Calling generateAISuggestion...');
                        // Call AI suggestion (async)
                        const suggestion = await generateAISuggestion(fieldType, currentContext);
                        console.log('‚úÖ Got suggestion:', suggestion);

                        // Apply suggestion
                        fieldElement.value = suggestion;

                        // Trigger input event for any listeners
                        fieldElement.dispatchEvent(new Event('input', { bubbles: true }));

                        // Success feedback
                        fieldElement.style.background = 'rgba(0, 166, 125, 0.15)';
                        setTimeout(() => {
                            fieldElement.style.background = 'var(--bg)';
                        }, 600);

                    } catch (error) {
                        console.error('‚ùå Smart Suggest error:', error);
                        console.error('Error stack:', error.stack);

                        // Restore original value on error
                        fieldElement.value = originalValue;

                        // Error feedback
                        fieldElement.style.background = 'rgba(239, 68, 68, 0.1)';
                        setTimeout(() => {
                            fieldElement.style.background = 'var(--bg)';
                        }, 600);

                        // Show error to user
                        alert(`Smart Suggest Error: ${error.message}\n\nCheck browser console (F12) for details.`);
                    } finally {
                        console.log('üîÑ Re-enabling field');
                        // Re-enable field
                        fieldElement.disabled = false;
                        fieldElement.placeholder = originalPlaceholder;
                    }
                };
            });
        }

        // Helper function to generate dynamic field HTML based on pattern
        function generateFieldHTML(fieldKey, fieldConfig, node) {
            const value = node[fieldKey] || '';
            const fieldId = `edit-${fieldKey}`;

            let inputHTML = '';

            if (fieldConfig.type === 'select') {
                const options = fieldConfig.options.map(opt =>
                    `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`
                ).join('');
                inputHTML = `<select id="${fieldId}">${options}</select>`;
            } else if (fieldConfig.type === 'textarea') {
                inputHTML = `<textarea id="${fieldId}" placeholder="${fieldConfig.placeholder || ''}" style="min-height: 80px;">${value}</textarea>`;
            } else if (fieldConfig.type === 'number') {
                const min = fieldConfig.min !== undefined ? `min="${fieldConfig.min}"` : '';
                const max = fieldConfig.max !== undefined ? `max="${fieldConfig.max}"` : '';
                const step = fieldConfig.step !== undefined ? `step="${fieldConfig.step}"` : '';
                inputHTML = `<input type="number" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" ${min} ${max} ${step} />`;
            } else if (fieldConfig.type === 'date') {
                inputHTML = `<input type="date" id="${fieldId}" value="${value}" />`;
            } else {
                // default to text
                inputHTML = `<input type="text" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" />`;
            }

            return `
                <div class="form-group">
                    <label>${fieldConfig.label} <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                    ${inputHTML}
                    ${fieldConfig.helpText ? `<p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">${fieldConfig.helpText}</p>` : ''}
                </div>
            `;
        }

        function handleEdit() {
            if (!activeNode) return;

            // Simple name editing for root and phase nodes
            if (activeNode.type === 'root' || activeNode.type === 'phase') {
                const labels = getPatternLabels();
                const nodeType = activeNode.type === 'root' ? labels.root : labels.phase;
                const newName = prompt(`Enter new ${nodeType} name:`, activeNode.name);

                if (newName && newName !== activeNode.name) {
                    activeNode.name = newName;
                    render();
                }
                return;
            }

            // Full edit modal for items and subtasks
            if (activeNode.type === 'item' || activeNode.type === 'subtask') {
                const modal = document.getElementById('edit-modal');
                const body = document.getElementById('edit-modal-body');

                // Get all items from all phases for dependency selection
                function getAllItems(node, items = [], phaseName = '') {
                    if (node.phase !== undefined) phaseName = `Phase ${node.phase}`;
                    if (node.items) {
                        node.items.forEach(item => {
                            items.push({ ...item, phaseName });
                        });
                    }
                    if (node.children) {
                        node.children.forEach(child => getAllItems(child, items, phaseName));
                    }
                    return items;
                }

                const allItems = getAllItems(capexTree).filter(item => item.id !== activeNode.id);

                // Build dependency checkboxes
                const currentDeps = activeNode.dependencies || [];
                const depsHtml = allItems.map(item => {
                    const checked = currentDeps.includes(item.id) ? 'checked' : '';
                    return `
                        <label style="display: flex; align-items: center; gap: 10px; padding: 8px 10px; cursor: pointer; font-weight: normal; text-transform: none; letter-spacing: normal; border-radius: 6px; transition: background 0.2s; margin-bottom: 4px;" onmouseover="this.style.background='var(--card-bg-light)'" onmouseout="this.style.background='transparent'">
                            <input type="checkbox" class="dep-checkbox" value="${item.id}" ${checked} style="flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; accent-color: var(--treeplex-primary);" />
                            <span style="flex: 1; display: flex; align-items: center; gap: 8px; font-size: 14px;">
                                <span style="font-size: 18px; flex-shrink: 0;">${item.icon}</span>
                                <span style="flex: 1; color: var(--text-primary);">${item.name}</span>
                                <span style="color: var(--text-secondary); font-size: 11px; padding: 2px 8px; background: var(--card-bg); border-radius: 4px; border: 1px solid var(--border);">${item.phaseName}</span>
                            </span>
                        </label>
                    `;
                }).join('');

                // Get current pattern and its fields configuration
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                // Check if PM tracking should be shown
                const showTracking = fields.includeTracking &&
                                    fields.trackingFor &&
                                    fields.trackingFor.includes(activeNode.type);

                // Build field HTML
                let fieldsHTML = '';

                // 1. PM Tracking Section (conditional)
                if (showTracking) {
                    // Calculate RAG status color
                    const ragStatus = activeNode.pmRAGStatus || 'Amber';
                    const ragColors = {
                        'Green': '#22C55E',
                        'Amber': '#F59E0B',
                        'Red': '#EF4444'
                    };
                    const ragColor = ragColors[ragStatus] || ragColors.Amber;

                    // Calculate time tracking metrics
                    const estHours = activeNode.pmEstimatedHours || 0;
                    const actHours = activeNode.pmActualHours || 0;
                    const remHours = activeNode.pmRemainingHours || estHours - actHours;
                    const timeProgress = estHours > 0 ? Math.min(100, (actHours / estHours) * 100) : 0;
                    const isOverBudget = actHours > estHours;

                    fieldsHTML += `
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--treeplex-primary);">üéØ Project Management</h3>

                        <!-- PM Infographic Dashboard -->
                        <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(99, 102, 241, 0.05) 100%); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 16px;">
                                <!-- RAG Status Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">RAG Status</div>
                                    <div style="width: 48px; height: 48px; border-radius: 50%; background: ${ragColor}; margin: 0 auto; box-shadow: 0 4px 12px ${ragColor}40, inset 0 2px 4px rgba(255,255,255,0.3);"></div>
                                    <div style="font-size: 13px; font-weight: 600; margin-top: 8px; color: ${ragColor};">${ragStatus}</div>
                                </div>

                                <!-- Progress Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Progress</div>
                                    <div style="position: relative; width: 64px; height: 64px; margin: 0 auto;">
                                        <svg width="64" height="64" style="transform: rotate(-90deg);">
                                            <circle cx="32" cy="32" r="28" stroke="var(--border)" stroke-width="6" fill="none"></circle>
                                            <circle cx="32" cy="32" r="28" stroke="var(--treeplex-primary)" stroke-width="6" fill="none"
                                                stroke-dasharray="${(activeNode.pmProgress || 0) * 1.759} 175.9"
                                                stroke-linecap="round"
                                                style="transition: stroke-dasharray 0.3s ease;"></circle>
                                        </svg>
                                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 16px; font-weight: 700; color: var(--treeplex-primary);">${activeNode.pmProgress || 0}%</div>
                                    </div>
                                </div>

                                <!-- Priority Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Priority</div>
                                    <div style="margin-top: 4px;">
                                        ${(() => {
                                            const priority = activeNode.pmPriority || 'Medium';
                                            const priorityIcons = {
                                                'Low': 'üü¢',
                                                'Medium': 'üü°',
                                                'High': 'üü†',
                                                'Critical': 'üî¥'
                                            };
                                            return `<div style="font-size: 32px; margin: 4px 0;">${priorityIcons[priority] || priorityIcons.Medium}</div>
                                                   <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${priority}</div>`;
                                        })()}
                                    </div>
                                </div>
                            </div>

                            <!-- Time Tracking Visualization -->
                            ${estHours > 0 ? `
                            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
                                <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Time Tracking</div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 12px;">
                                    <span>‚è±Ô∏è Estimated: <strong>${estHours}h</strong></span>
                                    <span>‚úÖ Actual: <strong style="color: ${isOverBudget ? '#EF4444' : '#22C55E'};">${actHours}h</strong></span>
                                    <span>‚è≥ Remaining: <strong>${remHours}h</strong></span>
                                </div>
                                <div style="width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
                                    <div style="width: ${timeProgress}%; height: 100%; background: ${isOverBudget ? '#EF4444' : '#22C55E'}; transition: width 0.3s ease;"></div>
                                </div>
                                ${isOverBudget ? `<div style="font-size: 11px; color: #EF4444; margin-top: 4px; font-weight: 600;">‚ö†Ô∏è Over Budget by ${actHours - estHours}h</div>` : ''}
                            </div>
                            ` : ''}
                        </div>

                        <!-- PM Form Fields -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                            <div class="form-group">
                                <label>Status</label>
                                <select id="edit-pm-status">
                                    <option value="To Do" ${activeNode.pmStatus === 'To Do' ? 'selected' : ''}>To Do</option>
                                    <option value="In Progress" ${activeNode.pmStatus === 'In Progress' ? 'selected' : ''}>In Progress</option>
                                    <option value="Completed" ${activeNode.pmStatus === 'Completed' ? 'selected' : ''}>Completed</option>
                                    <option value="Blocked" ${activeNode.pmStatus === 'Blocked' ? 'selected' : ''}>Blocked</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>RAG Status üö¶</label>
                                <select id="edit-pm-rag-status">
                                    <option value="Green" ${ragStatus === 'Green' ? 'selected' : ''}>üü¢ Green - On Track</option>
                                    <option value="Amber" ${ragStatus === 'Amber' ? 'selected' : ''}>üü° Amber - At Risk</option>
                                    <option value="Red" ${ragStatus === 'Red' ? 'selected' : ''}>üî¥ Red - Critical</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Owner Email üë§</label>
                            <input type="email" id="edit-pm-owner-email" value="${activeNode.pmOwnerEmail || activeNode.pmAssignee || ''}" placeholder="owner@company.com" />
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 4px; font-style: italic;">üìß Email for collaborative pipeline reviews</p>
                        </div>
                        <div class="form-group">
                            <label>Progress (%)</label>
                            <input type="number" id="edit-pm-progress" value="${activeNode.pmProgress || 0}" min="0" max="100" step="5" />
                        </div>
                        <div class="form-group">
                            <label>Priority</label>
                            <select id="edit-pm-priority">
                                <option value="Low" ${activeNode.pmPriority === 'Low' ? 'selected' : ''}>Low</option>
                                <option value="Medium" ${activeNode.pmPriority === 'Medium' ? 'selected' : ''}>Medium</option>
                                <option value="High" ${activeNode.pmPriority === 'High' ? 'selected' : ''}>High</option>
                                <option value="Critical" ${activeNode.pmPriority === 'Critical' ? 'selected' : ''}>Critical</option>
                            </select>
                        </div>

                        <!-- Time Management Fields -->
                        <div style="margin-top: 16px; padding: 16px; background: rgba(99, 102, 241, 0.05); border: 1px dashed var(--border); border-radius: 8px;">
                            <h4 style="font-size: 14px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">‚è±Ô∏è Time Management</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Estimated (hours)</label>
                                    <input type="number" id="edit-pm-estimated-hours" value="${estHours}" min="0" step="0.5" placeholder="0" />
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Actual (hours)</label>
                                    <input type="number" id="edit-pm-actual-hours" value="${actHours}" min="0" step="0.5" placeholder="0" />
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Remaining (hours)</label>
                                    <input type="number" id="edit-pm-remaining-hours" value="${remHours}" min="0" step="0.5" placeholder="Auto" />
                                </div>
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">üí° Remaining auto-calculates if left empty (Estimated - Actual)</p>
                        </div>
                        <div class="form-group">
                            <label>Start Date</label>
                            <input type="date" id="edit-pm-start-date" value="${activeNode.pmStartDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>Due Date</label>
                            <input type="date" id="edit-pm-due-date" value="${activeNode.pmDueDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>üöß Blocking Issue <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                            <textarea id="edit-pm-blocking-issue" style="min-height: 60px;" placeholder="What's preventing progress?">${activeNode.pmBlockingIssue || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>‚û°Ô∏è Next Steps <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                            <textarea id="edit-pm-next-steps" style="min-height: 80px;" placeholder="Specific actions needed...">${activeNode.pmNextSteps || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>PM Notes</label>
                            <textarea id="edit-pm-notes" style="min-height: 80px;" placeholder="Task-specific notes, blockers, action items...">${activeNode.pmNotes || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>üìù Latest Updates</label>
                            <div style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 8px; max-height: 200px; overflow-y: auto;">
                                ${activeNode.pmUpdates && activeNode.pmUpdates.length > 0 ? activeNode.pmUpdates.map((update, idx) => `
                                    <div style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border);">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">${new Date(update.timestamp).toLocaleString()}</div>
                                        <div style="font-size: 13px; line-height: 1.5;">${update.text}</div>
                                        <button onclick="window.deleteUpdate(${idx})" style="margin-top: 6px; padding: 2px 8px; font-size: 10px; background: rgba(239, 68, 68, 0.2); border: 1px solid #EF4444; border-radius: 4px; color: #EF4444; cursor: pointer;">Delete</button>
                                    </div>
                                `).join('') : '<p style="color: var(--text-secondary); font-size: 13px; text-align: center; padding: 20px;">No updates yet</p>'}
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <textarea id="edit-pm-new-update" style="flex: 1; min-height: 60px;" placeholder="Add a new update..."></textarea>
                                <button onclick="window.addUpdate()" style="padding: 8px 16px; background: var(--treeplex-primary); border: none; border-radius: 6px; color: white; font-weight: 600; cursor: pointer; white-space: nowrap;">Add Update</button>
                            </div>
                        </div>
                        <hr style="margin: 24px 0; border: none; border-top: 1px solid var(--border);" />
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--text-secondary);">Details</h3>
                    `;
                }

                // 2. Universal Fields (always shown)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Name <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <input type="text" id="edit-name" value="${activeNode.name || ''}" />
                    </div>
                    <div class="form-group">
                        <label>Description <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <textarea id="edit-description">${activeNode.description || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label>Icon <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <input type="text" id="edit-icon" value="${activeNode.icon || ''}" maxlength="2" />
                    </div>
                    <div class="form-group">
                        <label>Type</label>
                        <select id="edit-type">
                            ${PATTERNS[currentPattern].types.map(type =>
                                `<option value="${type.value}" ${activeNode.itemType === type.value ? 'selected' : ''}>${type.label}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;

                // 3. Pattern-Specific Custom Fields (dynamic)
                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }
                    const fieldConfig = fields[fieldKey];
                    fieldsHTML += generateFieldHTML(fieldKey, fieldConfig, activeNode);
                });

                // 4. Notes (universal)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Notes <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click üí°)</span></label>
                        <textarea id="edit-notes" style="min-height: 100px;" placeholder="Additional notes...">${activeNode.notes || ''}</textarea>
                    </div>
                `;

                // 5. Dependencies (conditional)
                if (fields.includeDependencies) {
                    fieldsHTML += `
                        <div class="form-group">
                            <label>Dependencies</label>
                            <div style="max-height: 240px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 6px; background: var(--bg);">
                                ${depsHtml || '<p style="color: var(--text-secondary); font-size: 13px; margin: 0; padding: 10px; text-align: center;">No other items available</p>'}
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">‚úì Select prerequisite items that must be completed first</p>
                        </div>
                    `;
                }

                body.innerHTML = fieldsHTML;

                modal.style.display = 'flex';

                // Enable AI suggestions on text fields after modal is displayed
                setTimeout(() => {
                    // Universal fields
                    const nameField = document.getElementById('edit-name');
                    const descField = document.getElementById('edit-description');
                    const iconField = document.getElementById('edit-icon');
                    const notesField = document.getElementById('edit-notes');

                    if (nameField) enableAISuggestionsOnField(nameField, 'name', activeNode);
                    if (descField) enableAISuggestionsOnField(descField, 'description', activeNode);
                    if (iconField) enableAISuggestionsOnField(iconField, 'icon', activeNode);
                    if (notesField) enableAISuggestionsOnField(notesField, 'notes', activeNode);

                    // Pattern-specific fields (dynamic)
                    Object.keys(fields).forEach(fieldKey => {
                        if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                            return;
                        }
                        const fieldElement = document.getElementById(`edit-${fieldKey}`);
                        if (fieldElement) {
                            enableAISuggestionsOnField(fieldElement, fieldKey, activeNode);
                        }
                    });

                    // Enable AI suggestions for PM fields (conditional)
                    if (showTracking) {
                        const pmBlockingIssueField = document.getElementById('edit-pm-blocking-issue');
                        const pmNextStepsField = document.getElementById('edit-pm-next-steps');

                        if (pmBlockingIssueField) enableAISuggestionsOnField(pmBlockingIssueField, 'pmBlockingIssue', activeNode);
                        if (pmNextStepsField) enableAISuggestionsOnField(pmNextStepsField, 'pmNextSteps', activeNode);
                    }
                }, 50);
            }
        }

        function handleCreate() {
            if (activeNode && activeNode.type === 'phase') {
                // Save state for undo
                saveState(`Create item in ${activeNode.name}`);

                // Create new item in this phase
                const labels = getPatternLabels();
                const defaultType = PATTERNS[currentPattern].types[0].value;
                const newItem = {
                    id: `p${activeNode.phase}-${Date.now()}`,
                    name: `New ${labels.item}`,
                    description: 'Enter description',
                    cost: 0,
                    icon: 'üì¶',
                    itemType: defaultType,
                    type: 'item',
                    dependencies: []
                };

                if (!activeNode.items) activeNode.items = [];
                activeNode.items.push(newItem);
                activeNode.expanded = true;
                render();
            }
        }

        function handleAddSubtask() {
            // Allow both items AND subtasks to have nested sub-tasks
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask')) {
                const labels = getPatternLabels();
                const isNestedSubtask = activeNode.type === 'subtask';
                const promptLabel = isNestedSubtask ? `nested ${labels.subtask}` : labels.subtask;

                // Prompt for sub-task name
                const subtaskName = prompt(`Enter ${promptLabel} name:`, `New ${isNestedSubtask ? 'Nested ' : ''}${labels.subtask}`);
                if (!subtaskName) return;

                // Save state for undo
                saveState(`Add subtask to ${activeNode.name}`);

                // Get today's date in YYYY-MM-DD format
                const today = new Date().toISOString().split('T')[0];

                // Create new sub-task with PM fields
                const newSubtask = {
                    id: `${activeNode.id}-sub-${Date.now()}`,
                    name: subtaskName,
                    description: 'Task description',
                    cost: 0,
                    icon: 'üìã',
                    itemType: 'subtask',
                    type: 'subtask',
                    dependencies: [],
                    parentId: activeNode.id,
                    // Project Management fields
                    pmStatus: 'To Do',
                    pmAssignee: 'Unassigned',
                    pmStartDate: today,
                    pmDueDate: today,
                    pmProgress: 0,
                    pmPriority: 'Medium',
                    pmNotes: '',
                    pmBlockingIssue: '',
                    pmNextSteps: '',
                    pmUpdates: [],
                    // Initialize subItems for nested support
                    subItems: []
                };

                // Initialize subItems array if it doesn't exist
                if (!activeNode.subItems) activeNode.subItems = [];
                activeNode.subItems.push(newSubtask);

                // Mark parent as expanded to show sub-tasks
                activeNode.expanded = true;

                render();
                document.getElementById('context-menu').style.display = 'none';
            }
        }

        function handleDelete() {
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask')) {
                const itemType = activeNode.type === 'subtask' ? 'sub-task' : 'item';
                if (confirm(`Delete "${activeNode.name}" ${itemType}?`)) {
                    // Save state for undo
                    saveState(`Delete ${itemType}: ${activeNode.name}`);
                    if (activeNode.type === 'subtask') {
                        // Remove subtask from its parent item
                        function removeSubtask(subtaskId, node = capexTree) {
                            if (node.items) {
                                for (let item of node.items) {
                                    if (item.subItems) {
                                        const index = item.subItems.findIndex(s => s.id === subtaskId);
                                        if (index !== -1) {
                                            item.subItems.splice(index, 1);
                                            return true;
                                        }
                                    }
                                }
                            }
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeSubtask(subtaskId, child)) return true;
                                }
                            }
                            return false;
                        }
                        removeSubtask(activeNode.id);
                    } else {
                        // Find and remove the item from its parent phase
                        function removeItem(itemId, node = capexTree) {
                            if (node.items) {
                                const index = node.items.findIndex(i => i.id === itemId);
                                if (index !== -1) {
                                    node.items.splice(index, 1);
                                    return true;
                                }
                            }
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeItem(itemId, child)) return true;
                                }
                            }
                            return false;
                        }
                        removeItem(activeNode.id);
                    }
                    render();
                }
            }
        }

        // =============================================================================
        // TREE MANAGER - Save/Load with Auto-Save & Organized Folders
        // =============================================================================

        class TreeManager {
            constructor() {
                this.currentTreeId = null;
                this.lastSaveTimestamp = null;
                this.hasUnsavedChanges = false;
                this.autoSaveInterval = null;
            }

            initialize() {
                console.log('üå≥ TreeManager: Initializing...');
                console.log('üíæ Save mode: LocalStorage + Download to Downloads folder');
                this.loadTreeFromURLOrStorage();
                this.startAutoSave(120);
                this.startIndicatorUpdates();
                this.watchForChanges();
            }

            getTimestamp() {
                const now = new Date();
                const y = now.getFullYear();
                const m = String(now.getMonth() + 1).padStart(2, '0');
                const d = String(now.getDate()).padStart(2, '0');
                const h = String(now.getHours()).padStart(2, '0');
                const min = String(now.getMinutes()).padStart(2, '0');
                const s = String(now.getSeconds()).padStart(2, '0');
                return `${y}${m}${d}-${h}${min}${s}`;
            }

            slugify(text) {
                return text.toString().toLowerCase().trim()
                    .replace(/\s+/g, '-').replace(/[^\w\-]+/g, '')
                    .replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
            }

            generateFilename(tree) {
                const pattern = tree.pattern?.key || 'generic';
                const treeName = tree.name || 'project';
                const slug = this.slugify(treeName);
                const timestamp = this.getTimestamp();

                // Format: treelisty-<pattern>-<name>-<timestamp>.json
                // Example: treelisty-philosophy-plato-cave-20251118-153045.json
                return `treelisty-${pattern}-${slug}-${timestamp}.json`;
            }

            saveToLocalStorage(tree) {
                try {
                    const treeId = tree.id || 'default';
                    const jsonStr = JSON.stringify(tree, null, 2);
                    localStorage.setItem(`treelisty:tree:${treeId}`, jsonStr);
                    const metadata = this.extractMetadata(tree);
                    localStorage.setItem(`treelisty:meta:${treeId}`, JSON.stringify(metadata));
                    this.lastSaveTimestamp = Date.now();
                    this.hasUnsavedChanges = false;
                    console.log(`üíæ Saved to LocalStorage: ${treeId}`);
                    return true;
                } catch (error) {
                    console.error('‚ùå LocalStorage save failed:', error);
                    return false;
                }
            }

            extractMetadata(tree) {
                return {
                    id: tree.id || 'default',
                    name: tree.name || 'Untitled',
                    pattern: tree.pattern?.key || 'generic',
                    itemCount: this.countItems(tree),
                    lastModified: Date.now(),
                    lastSaved: this.lastSaveTimestamp
                };
            }

            countItems(tree) {
                let count = 0;
                if (tree.children) {
                    tree.children.forEach(phase => {
                        if (phase.items) {
                            count += phase.items.length;
                            phase.items.forEach(item => {
                                if (item.subItems) count += item.subItems.length;
                                if (item.subtasks) count += item.subtasks.length;
                            });
                        }
                    });
                }
                return count;
            }

            downloadJSON(tree) {
                try {
                    const filename = this.generateFilename(tree);
                    const jsonStr = JSON.stringify(tree, null, 2);
                    const blob = new Blob([jsonStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    console.log(`üíæ Downloaded: ${filename}`);
                    if (typeof showToast === 'function') showToast(`‚úÖ Saved: ${filename}`);
                    return true;
                } catch (error) {
                    console.error('‚ùå Download failed:', error);
                    return false;
                }
            }

            save(tree, options = {}) {
                const { silent = false, forceSaveAs = false } = options;

                // Save to LocalStorage for auto-save tracking
                this.saveToLocalStorage(tree);

                // Download JSON file (only on manual save, not auto-save)
                if (!silent) {
                    this.downloadJSON(tree);
                    this.updateSaveIndicator('saved');
                }

                this.addToRecentFiles(tree);
            }

            startAutoSave(intervalSeconds) {
                console.log(`‚è∞ Auto-save enabled: every ${intervalSeconds} seconds`);
                this.autoSaveInterval = setInterval(() => {
                    if (this.hasUnsavedChanges) {
                        console.log('üíæ Auto-saving...');
                        this.save(capexTree, { silent: true });
                    }
                }, intervalSeconds * 1000);
            }

            startIndicatorUpdates() {
                // Update save indicator every 30 seconds to keep "Saved Xm ago" current
                setInterval(() => {
                    if (this.lastSaveTimestamp && !this.hasUnsavedChanges) {
                        this.updateSaveIndicator('saved');
                    }
                }, 30000); // 30 seconds
            }

            watchForChanges() {
                this.hasUnsavedChanges = true;
            }

            markAsChanged() {
                this.hasUnsavedChanges = true;
                this.updateSaveIndicator('unsaved');
            }

            updateSaveIndicator(status) {
                const indicator = document.getElementById('save-indicator');
                if (!indicator) return;
                if (status === 'saving') {
                    indicator.textContent = 'üíæ Saving...';
                    indicator.style.color = '#9DA3B4';
                } else if (status === 'saved') {
                    const timeAgo = this.getTimeAgo(this.lastSaveTimestamp);
                    indicator.textContent = `‚úì Saved ${timeAgo}`;
                    indicator.style.color = '#5FA463';
                } else if (status === 'unsaved') {
                    indicator.textContent = '‚óè Unsaved changes';
                    indicator.style.color = '#D68A2E';
                }
            }

            getTimeAgo(timestamp) {
                if (!timestamp) return 'just now';
                const seconds = Math.floor((Date.now() - timestamp) / 1000);
                if (seconds < 10) return 'just now';
                if (seconds < 60) return `${seconds}s ago`;
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            }

            addToRecentFiles(tree) {
                try {
                    let recent = this.getRecentFiles();
                    const metadata = this.extractMetadata(tree);
                    recent = recent.filter(r => r.id !== metadata.id);
                    recent.unshift(metadata);
                    recent = recent.slice(0, 10);
                    localStorage.setItem('treelisty:recent', JSON.stringify(recent));
                } catch (error) {
                    console.error('‚ùå Failed to update recent files:', error);
                }
            }

            getRecentFiles() {
                try {
                    const data = localStorage.getItem('treelisty:recent');
                    return data ? JSON.parse(data) : [];
                } catch (error) {
                    return [];
                }
            }

            loadTreeFromURLOrStorage() {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('data')) {
                    console.log('üì• Loading tree from shared URL...');
                    return;
                }
                const treeId = 'default';
                const treeData = localStorage.getItem(`treelisty:tree:${treeId}`);
                if (treeData) {
                    try {
                        const tree = JSON.parse(treeData);
                        console.log('üì• Loaded tree from LocalStorage:', treeId);
                        Object.assign(capexTree, tree);
                        this.currentTreeId = treeId;
                    } catch (error) {
                        console.error('‚ùå Failed to load tree from LocalStorage:', error);
                    }
                }
            }
        }

        const treeManager = new TreeManager();
        window.addEventListener('DOMContentLoaded', () => {
            treeManager.initialize();
        });

        // Enhanced save function
        function handleDownload() {
            treeManager.save(capexTree, { forceSaveAs: false });
        }

        function handleUpload() {
            document.getElementById('json-upload-input').click();
        }

        function handleExpandAll() {
            function expandAll(node) {
                if (node.children) {
                    node.expanded = true;
                    node.children.forEach(expandAll);
                }
            }
            expandAll(capexTree);
            render();
        }

        function handleCollapseAll() {
            function collapseAll(node) {
                if (node.children) {
                    node.expanded = false;
                    node.children.forEach(collapseAll);
                }
            }
            capexTree.children.forEach(collapseAll);
            render();
        }

        // Toggle subtasks for a specific item
        window.toggleSubtasks = function(itemId) {
            function findAndToggle(node) {
                if (node.items) {
                    const item = node.items.find(i => i.id === itemId);
                    if (item) {
                        item.expanded = !item.expanded;
                        render();
                        return true;
                    }
                }
                if (node.children) {
                    for (let child of node.children) {
                        if (findAndToggle(child)) return true;
                    }
                }
                return false;
            }
            findAndToggle(capexTree);
        };

        // Add update to current activeNode
        window.addUpdate = function() {
            if (!activeNode) return;
            const updateText = document.getElementById('edit-pm-new-update').value.trim();
            if (!updateText) {
                alert('Please enter an update message');
                return;
            }

            if (!activeNode.pmUpdates) activeNode.pmUpdates = [];
            activeNode.pmUpdates.unshift({
                timestamp: new Date().toISOString(),
                text: updateText
            });

            // Clear the input and re-render the modal
            document.getElementById('edit-pm-new-update').value = '';
            handleEdit(); // Re-render the edit modal to show the new update
        };

        // Delete update from current activeNode
        window.deleteUpdate = function(index) {
            if (!activeNode || !activeNode.pmUpdates) return;
            if (confirm('Delete this update?')) {
                activeNode.pmUpdates.splice(index, 1);
                handleEdit(); // Re-render the edit modal
            }
        };

        async function handleAI() {
            if (activeNode) {
                const modal = document.getElementById('modal');
                const modalBody = document.getElementById('modal-body');

                // Show loading state
                modalBody.innerHTML = `
                    <div style="padding: 40px; text-align: center;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">AI is analyzing ${activeNode.name}...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                `;
                modal.style.display = 'flex';

                try {
                    // Determine analysis type (subtask, item, or project)
                    let analysisType = 'item';
                    if (activeNode.type === 'root') {
                        analysisType = 'project';
                    } else if (activeNode.type === 'subtask') {
                        analysisType = 'subtask';
                    }

                    // Call real AI
                    const aiResponse = await generateAIAnalysis(activeNode, analysisType);

                    // Display AI response with markdown-like formatting
                    modalBody.innerHTML = `
                        <div style="padding: 20px; line-height: 1.8;">
                            <div style="white-space: pre-wrap; font-size: 14px; color: var(--text-primary);">${aiResponse}</div>
                            <div style="margin-top: 24px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ü§ñ Analysis powered by Claude Sonnet ‚Ä¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;

                } catch (error) {
                    // Show error
                    modalBody.innerHTML = `
                        <div style="padding: 30px; text-align: center;">
                            <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                            <h3 style="margin-bottom: 16px; color: var(--text-primary);">AI Analysis Failed</h3>
                            <p style="margin-bottom: 24px; color: var(--text-secondary); line-height: 1.6;">
                                ${error.message}
                            </p>
                            <p style="font-size: 12px; color: var(--text-secondary);">
                                If this problem persists, contact geej support.
                            </p>
                        </div>
                    `;
                }
            }
        }

        // Edit modal save/cancel handlers
        document.getElementById('edit-save').addEventListener('click', () => {
            if (activeNode) {
                // Save state for undo
                saveState(`Edit ${activeNode.type}: ${activeNode.name}`);

                // Save universal fields
                activeNode.name = document.getElementById('edit-name').value;
                activeNode.description = document.getElementById('edit-description').value;
                activeNode.icon = document.getElementById('edit-icon').value;
                activeNode.itemType = document.getElementById('edit-type').value;
                activeNode.notes = document.getElementById('edit-notes').value;

                // Save pattern-specific fields dynamically
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    const fieldElement = document.getElementById(`edit-${fieldKey}`);
                    if (fieldElement) {
                        const fieldConfig = fields[fieldKey];
                        if (fieldConfig.type === 'number') {
                            activeNode[fieldKey] = parseInt(fieldElement.value) || 0;
                        } else {
                            activeNode[fieldKey] = fieldElement.value;
                        }
                    }
                });

                // Collect selected dependencies from checkboxes (conditional)
                if (fields.includeDependencies) {
                    const depCheckboxes = document.querySelectorAll('.dep-checkbox');
                    const selectedDeps = [];
                    depCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedDeps.push(checkbox.value);
                        }
                    });
                    activeNode.dependencies = selectedDeps;
                }

                // Save PM fields for subtasks
                if (activeNode.type === 'subtask') {
                    const pmStatus = document.getElementById('edit-pm-status');
                    const pmRAGStatus = document.getElementById('edit-pm-rag-status');
                    const pmOwnerEmail = document.getElementById('edit-pm-owner-email');
                    const pmStartDate = document.getElementById('edit-pm-start-date');
                    const pmDueDate = document.getElementById('edit-pm-due-date');
                    const pmProgress = document.getElementById('edit-pm-progress');
                    const pmPriority = document.getElementById('edit-pm-priority');
                    const pmEstimatedHours = document.getElementById('edit-pm-estimated-hours');
                    const pmActualHours = document.getElementById('edit-pm-actual-hours');
                    const pmRemainingHours = document.getElementById('edit-pm-remaining-hours');
                    const pmNotes = document.getElementById('edit-pm-notes');
                    const pmBlockingIssue = document.getElementById('edit-pm-blocking-issue');
                    const pmNextSteps = document.getElementById('edit-pm-next-steps');

                    if (pmStatus) activeNode.pmStatus = pmStatus.value;
                    if (pmRAGStatus) activeNode.pmRAGStatus = pmRAGStatus.value;
                    if (pmOwnerEmail) {
                        activeNode.pmOwnerEmail = pmOwnerEmail.value;
                        // Backward compatibility: also save as pmAssignee
                        activeNode.pmAssignee = pmOwnerEmail.value;
                    }
                    if (pmStartDate) activeNode.pmStartDate = pmStartDate.value;
                    if (pmDueDate) activeNode.pmDueDate = pmDueDate.value;
                    if (pmProgress) activeNode.pmProgress = parseInt(pmProgress.value) || 0;
                    if (pmPriority) activeNode.pmPriority = pmPriority.value;
                    if (pmEstimatedHours) activeNode.pmEstimatedHours = parseFloat(pmEstimatedHours.value) || 0;
                    if (pmActualHours) activeNode.pmActualHours = parseFloat(pmActualHours.value) || 0;
                    if (pmRemainingHours) {
                        // If remaining is explicitly set, use it; otherwise auto-calculate
                        const remValue = parseFloat(pmRemainingHours.value);
                        if (remValue > 0) {
                            activeNode.pmRemainingHours = remValue;
                        } else {
                            // Auto-calculate: Estimated - Actual
                            const est = parseFloat(pmEstimatedHours?.value) || 0;
                            const act = parseFloat(pmActualHours?.value) || 0;
                            activeNode.pmRemainingHours = Math.max(0, est - act);
                        }
                    }
                    if (pmNotes) activeNode.pmNotes = pmNotes.value;
                    if (pmBlockingIssue) activeNode.pmBlockingIssue = pmBlockingIssue.value;
                    if (pmNextSteps) activeNode.pmNextSteps = pmNextSteps.value;
                    // pmUpdates are managed separately via window.addUpdate and window.deleteUpdate
                }

                document.getElementById('edit-modal').style.display = 'none';
                render();
            }
        });

        document.getElementById('edit-cancel').addEventListener('click', () => {
            document.getElementById('edit-modal').style.display = 'none';
        });

        // JSON upload handler
        document.getElementById('json-upload-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        // Validate basic structure
                        if (data.id && data.children) {
                            // Replace the tree data
                            Object.assign(capexTree, data);

                            // Restore pattern if saved
                            if (capexTree.pattern && capexTree.pattern.key) {
                                currentPattern = capexTree.pattern.key;
                                const patternSelect = document.getElementById('pattern-select');
                                if (patternSelect) {
                                    patternSelect.value = currentPattern;
                                }
                                if (currentPattern === 'custom' && capexTree.pattern.labels) {
                                    customPatternNames = capexTree.pattern.labels;
                                }

                                console.log('Pattern loaded from file:', currentPattern);

                                // Update sort dropdown immediately after setting pattern
                                updateSortDropdown();
                            } else {
                                // No pattern in file - use current pattern
                                console.log('No pattern in file, using current:', currentPattern);
                                updateSortDropdown();
                            }

                            render();

                            // Apply default sort for filesystem pattern (folders first + alphabetical)
                            if (currentPattern === 'filesystem') {
                                sortTree(null); // This will trigger the default filesystem sort
                            }

                            alert('JSON loaded successfully!');
                        } else {
                            alert('Invalid JSON structure. Must have "id" and "children" properties.');
                        }
                    } catch (err) {
                        alert('Error parsing JSON: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
            // Reset input
            e.target.value = '';
        });

        // Controls - Expand/Collapse All
        const expandBtn = document.getElementById('expand-btn');
        const collapseBtn = document.getElementById('collapse-btn');

        if (expandBtn) {
            console.log('‚úÖ Expand button found, attaching event listener');
            expandBtn.addEventListener('click', () => {
                console.log('‚¨áÔ∏è Expand button clicked!');
                console.log('Current tree state:', capexTree);

                function expandAll(node) {
                    // Set expanded on this node
                    node.expanded = true;

                    // Recursively expand all children (phases/folders in filesystem)
                    if (node.children) {
                        node.children.forEach(expandAll);
                    }

                    // Recursively expand all items (standard patterns)
                    if (node.items) {
                        node.items.forEach(expandAll);
                    }

                    // Recursively expand all subItems (nested tasks)
                    if (node.subItems) {
                        node.subItems.forEach(expandAll);
                    }
                }
                expandAll(capexTree);

                console.log('Tree after expand:', capexTree);
                render();
                console.log('Render complete');
            });
        } else {
            console.error('‚ùå Expand button not found!');
        }

        if (collapseBtn) {
            console.log('‚úÖ Collapse button found, attaching event listener');
            collapseBtn.addEventListener('click', () => {
                console.log('‚¨ÜÔ∏è Collapse button clicked!');
                console.log('Current tree state:', capexTree);

                function collapseAll(node) {
                    // Set collapsed on this node
                    node.expanded = false;

                    // Recursively collapse all children (phases/folders in filesystem)
                    if (node.children) {
                        node.children.forEach(collapseAll);
                    }

                    // Recursively collapse all items (standard patterns)
                    if (node.items) {
                        node.items.forEach(collapseAll);
                    }

                    // Recursively collapse all subItems (nested tasks)
                    if (node.subItems) {
                        node.subItems.forEach(collapseAll);
                    }
                }

                // Start from the root's children
                if (capexTree.children) {
                    capexTree.children.forEach(collapseAll);
                }
                if (capexTree.items) {
                    capexTree.items.forEach(collapseAll);
                }

                console.log('Tree after collapse:', capexTree);
                render();
                console.log('Render complete');
            });
        } else {
            console.error('‚ùå Collapse button not found!');
        }

        // Search functionality
        document.getElementById('search-btn').addEventListener('click', () => {
            const modal = document.getElementById('search-modal');
            modal.style.display = 'flex';
            document.getElementById('search-input').focus();
        });

        document.getElementById('close-search-modal').addEventListener('click', () => {
            document.getElementById('search-modal').style.display = 'none';
        });

        // Recursive search function
        function searchNodes(query, node, path = [], results = []) {
            const queryLower = query.toLowerCase();

            // Helper to check if a value contains the query
            function matchesQuery(value) {
                if (value === null || value === undefined) return false;
                return String(value).toLowerCase().includes(queryLower);
            }

            // Search all fields in this node
            const matches = [];
            Object.keys(node).forEach(key => {
                // Skip non-searchable fields
                if (['children', 'items', 'subItems', 'dependencies', 'expanded', 'type', 'canvasX', 'canvasY'].includes(key)) {
                    return;
                }

                if (matchesQuery(node[key])) {
                    matches.push({ field: key, value: node[key] });
                }
            });

            // If this node has matches, add it to results
            if (matches.length > 0) {
                results.push({
                    node: node,
                    path: path,
                    matches: matches
                });
            }

            // Recursively search children (support both standard and filesystem patterns)
            const childList = node.children || node.items || node.subItems || [];
            childList.forEach((child, idx) => {
                searchNodes(query, child, [...path, { name: node.name || node.id, index: idx }], results);
            });

            return results;
        }

        // Perform search and display results
        function performSearch() {
            const query = document.getElementById('search-input').value.trim();
            const resultsContainer = document.getElementById('search-results');
            const emptyState = document.getElementById('search-results-empty');

            if (!query) {
                resultsContainer.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }

            const results = [];

            // Search through all phases
            if (capexTree.children) {
                capexTree.children.forEach((phase, phaseIdx) => {
                    // Search the phase itself
                    searchNodes(query, phase, [{ name: capexTree.name, index: phaseIdx }], results);
                });
            }

            // Display results
            if (results.length === 0) {
                resultsContainer.style.display = 'none';
                emptyState.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 12px;">ü§∑</div>
                    <div style="font-size: 14px;">No results found for "${query}"</div>
                `;
                emptyState.style.display = 'block';
            } else {
                emptyState.style.display = 'none';
                resultsContainer.style.display = 'block';

                resultsContainer.innerHTML = `
                    <div style="margin-bottom: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px;">
                        <strong style="color: var(--treeplex-primary);">${results.length}</strong> result${results.length !== 1 ? 's' : ''} found
                    </div>
                    ${results.map((result, idx) => {
                        const pathStr = result.path.map(p => p.name).join(' ‚Üí ') + ' ‚Üí ' + result.node.name;
                        const matchesHtml = result.matches.map(m => {
                            const value = String(m.value).substring(0, 200);
                            return `<div style="margin: 4px 0;"><strong>${m.field}:</strong> ${highlightMatch(value, query)}</div>`;
                        }).join('');

                        return `
                            <div class="search-result-item" data-node-id="${result.node.id}" style="padding: 12px 16px; margin-bottom: 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px; display: flex; align-items: center; gap: 8px;">
                                    ${result.node.icon || 'üìÑ'} ${result.node.name}
                                </div>
                                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                                    ${pathStr}
                                </div>
                                <div style="font-size: 13px; color: var(--text-primary); padding: 8px; background: var(--bg-secondary); border-radius: 4px;">
                                    ${matchesHtml}
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;

                // Add click handlers to results
                resultsContainer.querySelectorAll('.search-result-item').forEach((el, idx) => {
                    el.addEventListener('click', () => {
                        const nodeId = el.dataset.nodeId;
                        // Close search modal
                        document.getElementById('search-modal').style.display = 'none';
                        // Highlight and scroll to the node
                        highlightNode(nodeId);
                    });

                    // Hover effect
                    el.addEventListener('mouseenter', () => {
                        el.style.borderColor = 'var(--treeplex-primary)';
                        el.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                    el.addEventListener('mouseleave', () => {
                        el.style.borderColor = 'var(--border)';
                        el.style.background = 'var(--card-bg)';
                    });
                });
            }
        }

        // Highlight matched text
        function highlightMatch(text, query) {
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<mark style="background: rgba(255, 187, 0, 0.3); padding: 2px 4px; border-radius: 3px; font-weight: 600;">$1</mark>');
        }

        // Highlight node in tree view
        function highlightNode(nodeId) {
            // Find and expand ancestors to make node visible
            function findAndExpandNode(node, targetId, ancestors = []) {
                if (node.id === targetId) {
                    // Expand all ancestors
                    ancestors.forEach(ancestor => {
                        ancestor.expanded = true;
                    });
                    render();

                    // Scroll to node after render
                    setTimeout(() => {
                        const nodeEl = document.querySelector(`[data-item-id="${nodeId}"]`);
                        if (nodeEl) {
                            nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            // Flash highlight
                            nodeEl.style.background = 'rgba(99, 102, 241, 0.2)';
                            nodeEl.style.transition = 'background 0.3s';
                            setTimeout(() => {
                                nodeEl.style.background = '';
                            }, 1500);
                        }
                    }, 100);
                    return true;
                }

                // Recursively search children
                const childList = node.children || node.items || node.subItems || [];
                for (const child of childList) {
                    if (findAndExpandNode(child, targetId, [...ancestors, node])) {
                        return true;
                    }
                }
                return false;
            }

            // Search through all phases
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    if (findAndExpandNode(phase, nodeId, [capexTree])) {
                        break;
                    }
                }
            }
        }

        // Search on input
        const searchInput = document.getElementById('search-input');
        searchInput.addEventListener('input', debounce(performSearch, 300));
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });

        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Save and Load JSON buttons in console
        // New Project button - Start fresh
        document.getElementById('new-project-btn').addEventListener('click', () => {
            const confirmNew = confirm(
                'üÜï Start New Project?\n\n' +
                'This will clear your current project.\n\n' +
                'Make sure to save first if you want to keep your work!'
            );

            if (confirmNew) {
                saveState('New Project');

                // Use current pattern from dropdown (pattern-aware)
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;
                const fields = pattern.fields || {};

                // Build starter item with only pattern-specific fields
                const starterItem = {
                    id: 'item-' + Date.now(),
                    name: `New ${levels.item}`,
                    description: 'Enter description',
                    icon: 'üì¶',
                    itemType: '',
                    type: 'item',
                    dependencies: [],
                    subItems: [],
                    expanded: true
                };

                // Add pattern-specific fields
                Object.keys(fields).forEach(fieldKey => {
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return; // Skip meta fields
                    }

                    const fieldConfig = fields[fieldKey];

                    // Set default values based on field type
                    if (fieldConfig.type === 'number') {
                        starterItem[fieldKey] = 0;
                    } else if (fieldConfig.type === 'date') {
                        starterItem[fieldKey] = '';
                    } else if (fieldConfig.type === 'select') {
                        starterItem[fieldKey] = '';
                    } else if (fieldConfig.type === 'textarea') {
                        starterItem[fieldKey] = '';
                    } else {
                        starterItem[fieldKey] = '';
                    }
                });

                // Reset to fresh tree with pattern-specific structure
                capexTree = {
                    id: 'root',
                    name: `My ${levels.root}`,
                    type: 'root',
                    icon: pattern.icon,
                    expanded: true,
                    children: [
                        {
                            id: 'phase-0',
                            name: `${levels.phase} 0`,
                            subtitle: pattern.phaseSubtitles ? pattern.phaseSubtitles[0] : '',
                            type: 'phase',
                            phase: 0,
                            icon: '1Ô∏è‚É£',
                            expanded: true,
                            items: [starterItem],
                            children: []
                        }
                    ],
                    pattern: {
                        key: currentPattern,
                        labels: levels
                    }
                };

                render();
                showToast(`‚úÖ New ${pattern.name} project started!`);
                console.log(`üÜï New ${pattern.name} project created`);
            }
        });

        document.getElementById('save-json-btn').addEventListener('click', handleDownload);
        document.getElementById('load-json-btn').addEventListener('click', handleUpload);

        // Share button - Generate shareable URL
        document.getElementById('share-btn').addEventListener('click', () => {
            const shareableURL = generateShareableURL();

            // Show modal with URL
            const modal = document.getElementById('share-modal');
            const urlInput = document.getElementById('share-url-input');
            urlInput.value = shareableURL;

            // Update stats
            const nodeCount = countAllNodes(capexTree);
            document.getElementById('share-node-count').textContent = nodeCount;
            document.getElementById('share-url-length').textContent = shareableURL.length;

            // Show warning if URL is very long (>2000 chars might have issues in some apps)
            const warning = document.getElementById('share-size-warning');
            if (shareableURL.length > 2000) {
                warning.style.display = 'block';
            } else {
                warning.style.display = 'none';
            }

            modal.style.display = 'flex';

            // Select the URL text for easy copying
            setTimeout(() => urlInput.select(), 100);
        });

        // Share modal - Copy button
        document.getElementById('copy-share-url').addEventListener('click', () => {
            const urlInput = document.getElementById('share-url-input');
            urlInput.select();
            document.execCommand('copy');

            // Change button text temporarily
            const btn = document.getElementById('copy-share-url');
            const originalText = btn.textContent;
            btn.textContent = '‚úÖ Copied!';
            btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';

            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
            }, 2000);
        });

        // Share modal - Open in new tab button
        document.getElementById('open-share-url').addEventListener('click', () => {
            const url = document.getElementById('share-url-input').value;
            window.open(url, '_blank');
        });

        // Share modal - Close button
        document.getElementById('share-close').addEventListener('click', () => {
            document.getElementById('share-modal').style.display = 'none';
        });

        // Generate shareable URL with compressed data
        function generateShareableURL() {
            // DEBUG: Check cost values before serialization
            if (capexTree.children && capexTree.children[0] && capexTree.children[0].items && capexTree.children[0].items[0]) {
                console.log('First item cost before stringify:', capexTree.children[0].items[0].cost);
            }

            const jsonData = JSON.stringify(capexTree);

            // DEBUG: Log first 500 chars of JSON
            console.log('JSON before compress (first 500 chars):', jsonData.substring(0, 500));

            const compressed = LZString.compressToEncodedURIComponent(jsonData);
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?p=${compressed}`;
        }

        // Count all nodes in tree (for stats)
        function countAllNodes(node) {
            let count = 1; // Count this node
            if (node.children) {
                node.children.forEach(child => {
                    if (child.items) {
                        count += child.items.length;
                        child.items.forEach(item => {
                            if (item.subtasks) {
                                count += item.subtasks.length;
                            }
                        });
                    } else {
                        count += countAllNodes(child);
                    }
                });
            }
            return count;
        }

        // =============================================================================
        // AI WIZARD SYSTEM
        // =============================================================================

        // Wizard state
        let wizardState = {
            active: false,
            conversation: [],
            questionsAsked: 0,
            fieldsCompleted: new Set(),
            totalFields: 0,
            awaitingResponse: false,
            workingTree: null,
            patternKey: null
        };

        // Check if tree has meaningful content
        function hasExistingContent() {
            // Check if any phase has items or children (filesystem pattern uses 'children')
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    // Support both 'items' (standard patterns) and 'children' (filesystem pattern)
                    const nodeList = phase.items || phase.children || [];
                    if (nodeList.length > 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Start wizard
        document.getElementById('wizard-btn').addEventListener('click', () => {
            // Check global AI mode
            const aiMode = getGlobalAIMode();
            if (aiMode === 'off') {
                alert('‚ùå AI features are currently disabled.\n\nPlease enable AI mode in the header (ü§ñ AI Mode dropdown) to use the AI Wizard.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            // If tree has content, ask user if they want to enhance or start fresh
            if (hasExistingContent()) {
                showWizardModeChoice();
            } else {
                startWizard(false); // false = start fresh
            }
        });

        // Show modal to choose wizard mode
        function showWizardModeChoice() {
            const pattern = PATTERNS[currentPattern];
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ü™Ñ AI Wizard Mode';

            // Count existing items
            const itemCount = capexTree.children?.reduce((sum, phase) =>
                sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 24px;">
                        Your tree already has <strong style="color: var(--treeplex-primary);">${itemCount} ${pattern.levels.item.toLowerCase()}(s)</strong>.
                        How would you like to proceed?
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="mode-enhance" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">‚ú®</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Enhance Existing
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Keep your current tree and use the wizard to add more detail, fill gaps, or expand sections.
                            </div>
                        </div>

                        <div id="mode-fresh" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">üå±</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Start Fresh
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Clear the current tree and build a completely new structure from scratch.
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 16px; padding: 12px; background: rgba(163, 85, 247, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                        üí° <strong>Tip:</strong> Enhancement mode is great for iterative refinement. The wizard will see your existing structure and help you improve it.
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Add click handlers
            document.getElementById('mode-enhance').onclick = () => {
                modal.style.display = 'none';
                startWizard(true); // true = enhance mode
            };

            document.getElementById('mode-fresh').onclick = () => {
                modal.style.display = 'none';
                startWizard(false); // false = start fresh
            };
        }

        async function startWizard(enhanceMode = false) {
            // Reset wizard state
            wizardState = {
                active: true,
                conversation: [],
                questionsAsked: 0,
                fieldsCompleted: new Set(),
                totalFields: 0,
                awaitingResponse: false,
                workingTree: JSON.parse(JSON.stringify(capexTree)), // Deep copy
                patternKey: currentPattern,
                enhanceMode: enhanceMode,
                retryCount: 0 // Track recovery attempts
            };

            // Get pattern info
            const pattern = PATTERNS[currentPattern];
            const patternFields = pattern.fields || {};
            wizardState.totalFields = Object.keys(patternFields).length;

            // Update modal title
            const modeLabel = enhanceMode ? '‚ú® Enhancing' : 'ü™Ñ Building';
            document.getElementById('wizard-title').textContent = `${modeLabel} Your ${pattern.name}`;
            document.getElementById('wizard-fields-total').textContent = wizardState.totalFields;

            // Clear chat and preview
            document.getElementById('wizard-chat-history').innerHTML = '';
            updateWizardPreview();

            // Show modal
            document.getElementById('wizard-modal').style.display = 'flex';

            // Start conversation
            await wizardAsk();
        }

        // Add message to chat
        function addWizardMessage(role, content) {
            const chatHistory = document.getElementById('wizard-chat-history');
            const messageDiv = document.createElement('div');

            if (role === 'ai') {
                messageDiv.style.cssText = `
                    background: linear-gradient(135deg, #a855f7, #ec4899);
                    color: white;
                    padding: 15px;
                    border-radius: 12px;
                    border-bottom-left-radius: 4px;
                    max-width: 80%;
                    align-self: flex-start;
                    line-height: 1.6;
                `;
                messageDiv.textContent = 'üß† ' + content;
            } else {
                messageDiv.style.cssText = `
                    background: var(--treeplex-primary);
                    color: white;
                    padding: 15px;
                    border-radius: 12px;
                    border-bottom-right-radius: 4px;
                    max-width: 80%;
                    align-self: flex-end;
                    line-height: 1.6;
                `;
                messageDiv.textContent = 'üë§ ' + content;
            }

            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        // Ask AI for next question
        async function wizardAsk() {
            if (wizardState.awaitingResponse) return;
            wizardState.awaitingResponse = true;

            // Disable input while waiting
            document.getElementById('wizard-user-input').disabled = true;
            document.getElementById('wizard-send').disabled = true;

            try {
                const systemPrompt = buildWizardSystemPrompt();
                const conversationContext = wizardState.conversation.map(msg =>
                    `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`
                ).join('\n\n');

                const userPrompt = conversationContext ||
                    (wizardState.enhanceMode ?
                        "The user wants to enhance their existing tree. Acknowledge what they have and ask how you can help improve it." :
                        "Start the wizard conversation. Ask the user what they want to build.");

                console.log('ü™Ñ Wizard asking AI...');
                console.log('ü™Ñ System prompt length:', systemPrompt.length);
                console.log('ü™Ñ User prompt length:', userPrompt.length);

                const response = await callClaudeAPI(userPrompt, systemPrompt, 4000); // Increased to 4000 (Haiku max) to reduce truncation

                console.log('ü™Ñ AI Raw Response:', response);

                // Try to extract JSON if AI added text before/after
                let jsonStr = response.trim();

                // If response has markdown code blocks, extract JSON from them
                if (jsonStr.includes('```json')) {
                    const match = jsonStr.match(/```json\s*\n([\s\S]*?)\n```/);
                    if (match) {
                        jsonStr = match[1];
                        console.log('ü™Ñ Extracted from ```json block');
                    }
                } else if (jsonStr.includes('```')) {
                    const match = jsonStr.match(/```\s*\n([\s\S]*?)\n```/);
                    if (match) {
                        jsonStr = match[1];
                        console.log('ü™Ñ Extracted from ``` block');
                    }
                }

                // Find the FIRST complete JSON object using proper brace matching
                // This handles cases where AI adds text before/after the JSON
                const firstBrace = jsonStr.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response. AI may not be following instructions.');
                }

                if (firstBrace > 0) {
                    console.log('ü™Ñ Skipping text before JSON:', jsonStr.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonStr.length; i++) {
                    const char = jsonStr[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    console.error('ü™Ñ Incomplete JSON - Wizard response was cut off!');
                    console.error('ü™Ñ Full response length:', response.length);
                    console.error('ü™Ñ Response (first 500 chars):', response.substring(0, 500));
                    console.error('ü™Ñ Response (last 500 chars):', response.substring(Math.max(0, response.length - 500)));

                    // Check retry limit
                    wizardState.retryCount = (wizardState.retryCount || 0) + 1;
                    if (wizardState.retryCount > 2) {
                        throw new Error('Response was cut off multiple times. Try asking the wizard to add fewer items at once, or click "Finish & Apply" to save current progress.');
                    }

                    // Try to recover by asking AI to simplify
                    console.log('ü™Ñ Attempting auto-recovery (attempt ' + wizardState.retryCount + '/2)...');

                    // Add a recovery message to conversation
                    wizardState.conversation.push({
                        role: 'system',
                        content: 'Your last response was cut off (too long). Please provide a MUCH SHORTER response with only 2-3 items MAX. Be extremely concise.'
                    });

                    // Show user-friendly message
                    addWizardMessage('ai', "Oops! My response was too long and got cut off. Let me try with a shorter answer...");

                    // Retry with simplified prompt
                    document.getElementById('wizard-user-input').disabled = false;
                    document.getElementById('wizard-send').disabled = false;
                    wizardState.awaitingResponse = false;
                    setTimeout(() => wizardAsk(), 500);
                    return;
                }

                jsonStr = jsonStr.substring(firstBrace, endPos);

                if (endPos < response.length) {
                    console.log('ü™Ñ Skipping text after JSON:', response.substring(endPos, endPos + 50) + '...');
                }

                console.log('ü™Ñ Extracted JSON (first 200 chars):', jsonStr.substring(0, 200) + '...');
                console.log('ü™Ñ JSON length:', jsonStr.length);

                // Sanitize JSON: Fix control characters in string values
                // This handles cases where AI generates unescaped newlines/tabs in strings
                let parsed;
                try {
                    // First, try parsing as-is
                    parsed = JSON.parse(jsonStr);
                } catch (firstError) {
                    console.warn('ü™Ñ JSON parse failed, attempting sanitization...', firstError.message);

                    // Sanitize by escaping control characters within string values
                    // Strategy: Replace literal newlines/tabs/etc with escaped versions
                    // but only within quoted string values (not in JSON structure)

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonStr.length; i++) {
                        const char = jsonStr[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                // Other control characters - escape as unicode
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonStr = sanitized;
                    console.log('ü™Ñ Sanitized JSON:', jsonStr.substring(0, 200) + '...');

                    // Try parsing again after sanitization
                    parsed = JSON.parse(jsonStr);
                }

                // Validate required fields
                if (!parsed.message) {
                    throw new Error('AI response missing "message" field');
                }

                // Success! Reset retry count
                wizardState.retryCount = 0;

                // Add AI message to conversation history
                wizardState.conversation.push({role: 'assistant', content: parsed.message});
                addWizardMessage('ai', parsed.message);

                // Update tree if provided
                if (parsed.treeUpdate) {
                    console.log('ü™Ñ Applying tree update:', parsed.treeUpdate);
                    mergeTreeUpdate(parsed.treeUpdate);
                    updateWizardPreview();
                }

                // Update progress
                if (parsed.fieldsUpdated && Array.isArray(parsed.fieldsUpdated)) {
                    parsed.fieldsUpdated.forEach(field => wizardState.fieldsCompleted.add(field));
                    document.getElementById('wizard-fields-complete').textContent = wizardState.fieldsCompleted.size;
                }

                // Update progress bar (from AI's progress field 0.0 to 1.0)
                if (parsed.progress !== undefined) {
                    const percentComplete = Math.round(parsed.progress * 100);
                    document.getElementById('wizard-progress-percent').textContent = `${percentComplete}%`;
                    document.getElementById('wizard-progress-bar').style.width = `${percentComplete}%`;
                }

                // Check if done
                if (parsed.done) {
                    document.getElementById('wizard-completion').style.display = 'block';
                    document.getElementById('wizard-progress-bar').style.width = '100%';
                    document.getElementById('wizard-progress-percent').textContent = '100%';
                }

            } catch (error) {
                console.error('ü™Ñ Wizard error details:', {
                    error: error.message,
                    stack: error.stack,
                    conversation: wizardState.conversation
                });

                // Show error message in chat
                const errorMsg = error.message || 'Unknown error occurred';
                addWizardMessage('ai', `I'm having trouble: ${errorMsg}\n\nPlease check:\n1. Is your API key configured? (Settings ‚Üí API Key)\n2. Try refreshing the page\n3. Check browser console for details (F12)`);
            }

            // Re-enable input
            document.getElementById('wizard-user-input').disabled = false;
            document.getElementById('wizard-send').disabled = false;
            document.getElementById('wizard-user-input').focus();
            wizardState.awaitingResponse = false;
        }

        // User sends message
        document.getElementById('wizard-send').addEventListener('click', async () => {
            const input = document.getElementById('wizard-user-input');
            const message = input.value.trim();

            if (!message || wizardState.awaitingResponse) return;

            // Add to conversation
            wizardState.conversation.push({role: 'user', content: message});
            addWizardMessage('user', message);
            wizardState.questionsAsked++;
            document.getElementById('wizard-question-count').textContent = wizardState.questionsAsked;

            // Clear input
            input.value = '';

            // Get AI response
            await wizardAsk();
        });

        // Build system prompt for wizard
        function buildWizardSystemPrompt() {
            const pattern = PATTERNS[wizardState.patternKey];
            const levels = pattern.levels;
            const fields = pattern.fields || {};

            // Build a summary of current tree (not full JSON to save tokens)
            const treeSummary = wizardState.workingTree.name || 'Empty';
            const phaseCount = (wizardState.workingTree.children || []).length;
            const itemCount = (wizardState.workingTree.children || []).reduce((acc, phase) =>
                acc + (phase.items || []).length, 0);

            // Build detailed existing structure summary for enhance mode
            let existingStructure = '';
            if (wizardState.enhanceMode && itemCount > 0) {
                existingStructure = '\n\nüå≥ EXISTING TREE STRUCTURE (DO NOT DELETE - ADD TO THIS):\n\n';
                existingStructure += `**${wizardState.workingTree.name}**\n`;
                if (wizardState.workingTree.description) {
                    existingStructure += `Description: ${wizardState.workingTree.description}\n`;
                }
                existingStructure += '\n';

                (wizardState.workingTree.children || []).forEach((phase, idx) => {
                    existingStructure += `${levels.phase} ${idx + 1}: ${phase.name}`;
                    if (phase.subtitle) existingStructure += ` (${phase.subtitle})`;
                    existingStructure += `\n`;

                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach(item => {
                            existingStructure += `  - ${item.name}`;
                            if (item.description) {
                                existingStructure += `: ${item.description.substring(0, 60)}${item.description.length > 60 ? '...' : ''}`;
                            }
                            existingStructure += `\n`;

                            if (item.subtasks && item.subtasks.length > 0) {
                                existingStructure += `    (${item.subtasks.length} subtasks)\n`;
                            }
                        });
                    } else {
                        existingStructure += `  (no items yet)\n`;
                    }
                    existingStructure += '\n';
                });

                existingStructure += `Total: ${phaseCount} ${levels.phase.toLowerCase()}(s), ${itemCount} ${levels.item.toLowerCase()}(s)\n\n`;
                existingStructure += `üéØ YOUR MISSION: Help the user ENHANCE this existing tree by:\n`;
                existingStructure += `- Adding more detail to existing items\n`;
                existingStructure += `- Filling gaps or missing sections\n`;
                existingStructure += `- Expanding phases that seem incomplete\n`;
                existingStructure += `- Adding subtasks to items that need them\n\n`;
                existingStructure += `‚ö†Ô∏è SMART MERGE SYSTEM: After your FIRST response, include ONLY new or modified items in treeUpdate.\n`;
                existingStructure += `   The system automatically preserves all existing items not mentioned. You do NOT need to resend the entire tree every time.\n`;
            }

            const modeInstruction = wizardState.enhanceMode ?
                `You are ENHANCING an existing ${pattern.name} project. The user already has a tree with ${itemCount} items. Help them improve, expand, or fill gaps.` :
                `You are BUILDING a complete ${pattern.name} project from scratch. Extract NECESSARY and SUFFICIENT data in MINIMUM questions.`;

            return `‚ö†Ô∏è CRITICAL OUTPUT FORMAT: You MUST return ONLY a valid JSON object. NO text before the opening {. NO text after the closing }. NO explanations. NO commentary. JUST JSON.

You are an EXPERT INFORMATION EXTRACTION WIZARD. ${modeInstruction}

CURRENT STATE:
- Pattern: ${pattern.name}
- Structure: ${levels.root} ‚Üí ${levels.phase} ‚Üí ${levels.item} ‚Üí ${levels.subtask}
- Fields: ${Object.keys(fields).join(', ') || 'none'}
- Completed Fields: ${Array.from(wizardState.fieldsCompleted).join(', ') || 'none'}
- Tree: ${treeSummary} (${phaseCount} phases, ${itemCount} items)${existingStructure}

üéØ CORE MISSION: Extract 100% of required information in ‚â§5 strategic questions

üìä STRATEGIC QUESTIONING FRAMEWORK:

üéØ QUESTIONING ORDER (CRITICAL - Follow this sequence):

**TURN 1 - UNDERSTAND THE GOAL**
First question MUST clarify: "What is this ${pattern.name.toLowerCase()} trying to ACHIEVE? What's the exact goal?"
- Example: "What specific problem does this ${pattern.name.toLowerCase()} solve?"
- Example: "What output/result should this ${pattern.name.toLowerCase()} produce?"
${pattern.name === 'Prompt Engineering' ? `- ‚ö†Ô∏è META-LEVEL CLARITY: User is DESIGNING a prompt (not using one). Guide them to describe what THE PROMPT will do, not what THEY want to know.
  ‚Üí Good: "A prompt that takes X and returns Y"
  ‚Üí Bad: "I want to know about X"` : ''}
- DO NOT ask about safety, edge cases, or technical details yet
- DO NOT build the tree until you understand the GOAL

**TURN 2 - BUILD MAIN STRUCTURE**
After understanding the goal, propose the main phases/structure:
- "Based on your goal of [X], I'm thinking you need phases: [A, B, C]. Does that cover the main workflow?"
- Build 60-70% of the tree based on the goal
- Ask ONE clarifying question about structure

**TURN 3 - FILL CRITICAL DETAILS**
Add items and subtasks to each phase:
- "I've added [N] items across [M] phases. The biggest gap I see is [X]. Should I add that?"
- Build to 85-90% complete
- Focus on what's MISSING, not refinements

**TURN 4 - VALIDATE & REFINE**
Present near-complete tree and ask about completeness:
- "Does this capture the full workflow for [goal]? Or am I missing critical steps?"
- Now is when you can ask about edge cases, dependencies, special scenarios
- Build to 95%+ complete

**TURN 5 - CLOSE**
Final validation:
- "This looks complete for [goal]. Should I mark it done, or do you want to add/change anything?"
- Set done=true if approved

üö´ PRIORITY ORDER (What to ask when):

1. **THE GOAL** (Turn 1) - "What is this prompt trying to achieve exactly?"
2. **MAIN STRUCTURE** (Turn 2) - "What are the main phases/stages to achieve [goal]?"
3. **KEY ITEMS** (Turn 3) - "What are the critical items in each phase?"
4. **COMPLETENESS** (Turn 4) - "Am I missing any critical steps?"
5. **EDGE CASES/REFINEMENTS** (Turn 4) - "Any special scenarios or dependencies?"
6. **VALIDATION** (Turn 5) - "Does this fully capture everything?"

‚ùå NEVER ask about these BEFORE understanding the goal:
- Safety considerations
- Model parameters (temperature, tokens)
- Edge cases
- Technical implementation details

‚ö° EFFICIENCY TARGETS (UPDATED):
- Turn 1: Ask about GOAL. Build NOTHING until you understand the purpose.
- Turn 2: Build 60-70% of tree based on goal + ask about structure
- Turn 3: Fill to 85-90% + ask about biggest gaps
- Turn 4: Fill to 95%+ + validate completeness
- Turn 5: Set done=true if approved

üîç INFORMATION EXTRACTION TACTICS:
1. **EMBEDDED CONFIRMATION**: "I've added X, Y, Z as defaults. What am I missing?" (validates + extracts gaps)
2. **CONSTRAINT TESTING**: "I see this needs A. Does it also need B or is A sufficient?" (tests boundaries)
3. **DEPENDENCY PROBING**: "X blocks Y. Anything else blocked by X?" (maps critical paths)
4. **COMPLETENESS CHECK**: "I have N items for phase P. Too many/few/just right?" (validates scope)

üìã NECESSARY & SUFFICIENT DATA:
ALWAYS include in treeUpdate:
- Phases (3-6 typical)
- Items per phase (2-5 typical)
- ‚ö†Ô∏è NESTED ITEMS${wizardState.patternKey === 'filesystem' ? ' (use "children" property for File System pattern)' : ' (use "subItems" property, NOT "subtasks")'}: Add 2-4 ${levels.subtask}s to items that need decomposition
  ‚Üí ${levels.subtask}s are PATTERN-SPECIFIC breakdowns:
    ‚Ä¢ ${pattern.name === 'Philosophy' ? 'Philosophy: premises, objections, evidence, citations' : ''}
    ‚Ä¢ ${pattern.name === 'Sales Pipeline' ? 'Sales: follow-up actions, next steps, deliverables' : ''}
    ‚Ä¢ ${pattern.name === 'Thesis' ? 'Thesis: arguments, evidence, citations, counter-arguments' : ''}
    ‚Ä¢ ${pattern.name === 'Product Roadmap' ? 'Roadmap: tasks, specs, acceptance criteria, tests' : ''}
    ‚Ä¢ ${pattern.name === 'Book' ? 'Book: scenes, character moments, plot points' : ''}
    ‚Ä¢ ${pattern.name === 'Course' ? 'Course: lessons, activities, assessments, exercises' : ''}
    ‚Ä¢ ${pattern.name === 'Film Production' ? 'Film: shots, camera movements, lighting, blocking' : ''}
    ‚Ä¢ ${pattern.name === 'Prompt Engineering' ? 'Prompting: test cases, variations, edge cases' : ''}
    ‚Ä¢ Generic: steps, components, or sub-elements
  ‚Üí Focus on ${pattern.name} deliverables, not generic task lists
  ‚Üí ‚ú® UNLIMITED NESTING: ${wizardState.patternKey === 'filesystem' ? 'children can have their own children for N-level depth (e.g., Folder ‚Üí Subfolder ‚Üí File)' : 'subItems can have their own subItems for N-level depth (e.g., Step 1 ‚Üí Step 1.1 ‚Üí Step 1.1.1)'}
- Dependency info in descriptions (e.g., "After Phase 1 completes...")
- Pattern-specific fields (infer from conversation)

NEVER ask about:
- Formatting preferences
- Nice-to-have details that can be added later
- Information already inferrable from context

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ö†Ô∏è RESPONSE FORMAT - MANDATORY: Return ONLY the JSON below ‚ö†Ô∏è
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

DO NOT write ANY text before or after the JSON.
Your ENTIRE response must be ONLY this JSON object:

${wizardState.patternKey === 'filesystem' ? `
‚ö†Ô∏è FILESYSTEM PATTERN - SPECIAL STRUCTURE:
For File System pattern, use "children" arrays at ALL levels (not "items" or "subItems"):

{
  "message": "I've built [X drives, Y folders]. [State what you added]. [Ask ONE follow-up question]",
  "treeUpdate": {
    "name": "My Computer",
    "description": "File system structure",
    "children": [
      {
        "name": "C:\\ Local Drive",
        "type": "phase",
        "icon": "üíæ",
        "children": [
          {
            "name": "Projects",
            "type": "item",
            "icon": "üìÅ",
            "isFolder": true,
            "dateModified": "2025-11-15T14:30:00",
            "children": [
              {
                "name": "report.xlsx",
                "type": "item",
                "icon": "üìó",
                "isFolder": false,
                "fileSize": 15728640,
                "fileExtension": ".xlsx",
                "dateModified": "2025-11-10T16:45:00"
              }
            ]
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["fileSize", "isFolder"],
  "progress": 0.7,
  "done": false
}

‚ö†Ô∏è FILESYSTEM REQUIREMENTS:
- Use "children" for folders AND files (NOT "items" or "subItems")
- Set isFolder: true for folders, false for files
- Include fileSize (bytes), fileExtension, dateModified for files
- Auto-detect icons based on extension (.xlsx‚Üíüìó, .pdf‚Üíüìï, .jpg‚ÜíüñºÔ∏è, etc.)
- Unlimited nesting depth supported via children arrays
` : wizardState.patternKey === 'prompting' ? `
‚ö†Ô∏è AI PROMPT DESIGN PATTERN - SPECIAL FIELDS:
For AI Prompt Design, items MUST include these pattern-specific fields:

{
  "message": "I've designed [X] prompt stages with system instructions, user templates, and examples. [Ask ONE follow-up question]",
  "treeUpdate": {
    "name": "Master Prompt Engineer",
    "description": "Transform weak prompts into highly effective, structured instructions using proven prompt engineering framework",
    "children": [
      {
        "name": "System Configuration",
        "subtitle": "Role, framework, and process",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Core System Prompt",
            "description": "Expert persona and meta-framework for prompt engineering",
            "itemType": "system-prompt",
            "systemPrompt": "You are a Master Prompt Engineer specializing in Large Language Model interactions. Your expertise is transforming vague, simple, or inefficient prompts into highly effective, structured instructions.\n\nYour Framework (apply to every prompt):\n1. PERSONA/ROLE - Assign specific expert identity\n2. TASK - Define objective with active verbs\n3. CONTEXT - Add necessary background\n4. CONSTRAINTS - Define rules (do's and don'ts)\n5. OUTPUT FORMAT - Specify exact structure (Table, JSON, Markdown, etc.)\n\nYour Process:\n1. INPUT ACQUISITION - If no prompt provided, request it\n2. ANALYSIS - Evaluate for Clarity, Context, Constraints (3C Framework)\n3. IMPROVEMENT - Rewrite using the 5-part framework above\n4. DELIVERY - Present as: Critique ‚Üí Optimized Prompt ‚Üí Explanation\n\nBe analytical, precise, and helpful. Every improved prompt must be copy-paste ready.",
            "subItems": [
              {
                "name": "Tone Guidelines",
                "description": "Analytical, precise, helpful. Focus on teaching principles, not just fixing."
              },
              {
                "name": "Quality Standards",
                "description": "Every output must be immediately usable. No placeholders unless explicitly requested."
              }
            ]
          }
        ]
      },
      {
        "name": "User Interaction",
        "subtitle": "How users engage with this prompt",
        "type": "phase",
        "phase": 1,
        "items": [
          {
            "name": "User Prompt Template",
            "description": "Ready-to-use prompt for improving other prompts",
            "itemType": "user-template",
            "userPromptTemplate": "Please provide the prompt you would like me to improve. I'll analyze it for clarity, context, and constraints, then rewrite it using proven prompt engineering principles (Persona ‚Üí Task ‚Üí Context ‚Üí Constraints ‚Üí Output Format). I'll deliver a structured response with: (1) Critique of the original, (2) Optimized version, and (3) Explanation of improvements.",
            "subItems": [
              {
                "name": "Alternative: Batch Mode",
                "description": "For multiple prompts: 'I have three prompts to improve. I'll share them one at a time. For each, provide: Critique ‚Üí Optimized Version ‚Üí Key Improvements. Ready for the first one?'"
              }
            ]
          }
        ]
      },
      {
        "name": "Examples & Training",
        "subtitle": "Before/after prompt transformations",
        "type": "phase",
        "phase": 2,
        "items": [
          {
            "name": "Example Set",
            "description": "Demonstrate weak ‚Üí strong prompt transformations",
            "itemType": "examples",
            "fewShotExamples": "Example 1 - Weak Prompt:\n'Write about climate change.'\n\nOptimized:\n'You are an environmental scientist specializing in climate policy. Write a 500-word article explaining the top 3 impacts of climate change on coastal cities for a general audience. Use concrete examples from Miami, Venice, and Jakarta. Structure: (1) Introduction with thesis, (2) Three impacts with data, (3) Conclusion with actionable steps. Tone: Informative but accessible, avoid jargon.'\n\nKey Improvement: Added persona (environmental scientist), specific task (3 impacts, 500 words, examples), constraints (avoid jargon), and output structure.\n\n---\n\nExample 2 - Weak Prompt:\n'Help me with my resume.'\n\nOptimized:\n'You are a senior tech recruiter with 15 years of experience at FAANG companies. Review my software engineer resume and provide feedback in this format:\n1. STRENGTHS - What stands out positively\n2. GAPS - What's missing or unclear\n3. IMPROVEMENTS - 3 specific changes to increase interview callbacks\n4. REWRITE - Rewrite the Experience section for my top role using STAR format (Situation, Task, Action, Result)\n\nFocus on quantifiable achievements and technical impact. Target: Senior SWE roles at large tech companies.'\n\nKey Improvement: Added expert persona (tech recruiter), clear analysis framework (4-part structure), constraints (quantifiable, STAR format), and target audience (senior roles, big tech).",
            "subItems": [
              {
                "name": "Domain-Specific Example: Gardening Assistant",
                "description": "Full prompt structure for fall/winter gardening in Victoria, BC. System: 'You are an expert Pacific Northwest gardening consultant specializing in fall and winter cultivation in USDA zones 8-9. You provide specific, actionable advice based on local climate patterns, soil conditions, and seasonal timing for Victoria, BC and surrounding regions.' User: 'I need fall/winter gardening advice for Victoria, BC. Start by asking me what plants I want to grow, my experience level, and my garden conditions (soil type, sun exposure). Then provide a tailored planting and maintenance guide based on my answers.' Output Format: '1. Planting Timeline (specific dates/months), 2. Soil Preparation (pH, amendments, prep steps), 3. Planting Instructions (depth, spacing, technique), 4. Maintenance Schedule (weekly tasks through season), 5. Harvest Timing (when and how to harvest).' This shows how the meta-framework applies to a concrete domain."
              }
            ]
          }
        ]
      },
      {
        "name": "Output Specification",
        "subtitle": "Standardized delivery format",
        "type": "phase",
        "phase": 3,
        "items": [
          {
            "name": "Response Structure",
            "description": "Consistent 3-part delivery format",
            "itemType": "output-format",
            "outputFormat": "Deliver every improved prompt in this format:\n\n**1. CRITIQUE OF ORIGINAL PROMPT**\n- Briefly explain weaknesses (e.g., 'Lacked persona,' 'Too vague on formatting,' 'No constraints')\n\n**2. OPTIMIZED PROMPT**\n> [Full rewritten prompt in blockquote or code block for easy copying]\n\n**3. EXPLANATION OF CHANGES**\n- Explain why specific changes improve results (e.g., 'Added expert persona to increase authority,' 'Specified output format to ensure consistency')\n\nOptional: If the original prompt is ambiguous, ask 1-2 clarifying questions before optimizing.",
            "chainOfThought": "Before rewriting, analyze using 3C Framework: (1) CLARITY - Is intent obvious? (2) CONTEXT - Does AI know its role and audience? (3) CONSTRAINTS - Are there guardrails on length, format, style? Then apply 5-part framework: Persona ‚Üí Task ‚Üí Context ‚Üí Constraints ‚Üí Output Format."
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["systemPrompt", "userPromptTemplate", "fewShotExamples", "outputFormat", "chainOfThought"],
  "progress": 0.8,
  "done": false
}

‚ö†Ô∏è CRITICAL for Prompt Engineering pattern:
- ALWAYS populate systemPrompt, userPromptTemplate, fewShotExamples, outputFormat fields
- TEACH THE META-FRAMEWORK: Persona ‚Üí Task ‚Üí Context ‚Üí Constraints ‚Üí Output Format
- SHOW THE PROCESS: Input Acquisition ‚Üí Analysis (3C: Clarity, Context, Constraints) ‚Üí Improvement ‚Üí Delivery
- NO PLACEHOLDER VARIABLES: Use interactive style (AI asks questions) or specific style (list concrete topics)
- READY-TO-USE: Prompts must work immediately when pasted (no {{variable}} substitution needed)
- Use subItems for supplementary details (tone guidelines, quality standards, alternatives)
- Each phase represents a component of the final prompt (System, User, Examples, Output)
- The Generate Prompt feature extracts these fields to create the executable prompt
` : `
{
  "message": "I've built [X phases, Y items]. [State what you added]. The only gap I see is [specific gap]. [Ask ONE strategic follow-up question that maximizes information gain]",
  "treeUpdate": {
    "name": "Project Name",
    "description": "Brief description",
    "children": [
      {
        "name": "Phase 1",
        "subtitle": "Phase subtitle",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Item name",
            "description": "Item description (include dependency notes like 'Requires X to complete first' if order matters)",
            "itemType": "type",
            "subItems": [
              {
                "name": "Step 1",
                "description": "Detail",
                "subItems": [
                  {"name": "Step 1.1", "description": "Nested detail (supports N-level depth)"}
                ]
              },
              {"name": "Step 2", "description": "Detail"}
            ]
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["field1", "field2"],
  "progress": 0.7,
  "done": false
}`}

üéØ CRITICAL RULES:
- Return ONLY JSON, no text before/after
- ‚ö†Ô∏è KEEP RESPONSES CONCISE: Don't add too many items at once (max 5-7 items per turn)
- Turn 1: Build MINIMAL tree (just project name), ask about GOAL
- Turn 2+: Include treeUpdate with 2-4+ new items per turn
- INFER AGGRESSIVELY: Add details based on context, let user correct
- EVERY message must end with ONE strategic follow-up question (unless done=true)
- Follow the QUESTIONING ORDER above (Goal ‚Üí Structure ‚Üí Details ‚Üí Validation)
- Track progress field accurately (0.0 ‚Üí 1.0)
- Set done=true when tree is complete (typically turn 5)
- If tree is getting large (>20 items), add fewer items per turn to avoid truncation

üöÄ FIRST RESPONSE INSTRUCTION:
${wizardState.enhanceMode ? `
ENHANCE MODE - First response:
1. Return the EXISTING tree structure in treeUpdate (include all current phases/items to establish baseline)
2. Set progress based on how complete the tree already is (0.5 to 0.8 typical)
3. Ask: "I can see you have [X]. What would you like me to help you with? Add more ${levels.item.toLowerCase()}s, expand existing ones with more detail, add subtasks, or fill gaps?"

‚ö†Ô∏è FIRST RESPONSE: Include ALL existing phases, items, and subtasks to establish baseline.
‚ö†Ô∏è SUBSEQUENT RESPONSES: Include ONLY new or modified items. The Smart Merge system automatically preserves everything else.
   - If adding new items to an existing phase: Include just that phase with the new items
   - If modifying an existing item: Include just that item with changes
   - If adding a new phase: Include just the new phase
   - Items not mentioned are automatically preserved - you don't need to resend them!
` : `
BUILD MODE - First response:
1. Create minimal tree with just project name and empty description
2. Set progress to 0.1
3. ${pattern.name === 'Prompt Engineering' ? `Ask: "What prompt do you want to design? Describe what it should DO when someone uses it.

Examples:
‚Ä¢ 'A prompt that takes a business idea and returns a 5-year financial projection with key metrics'
‚Ä¢ 'A prompt that analyzes code for security vulnerabilities and suggests fixes with severity ratings'
‚Ä¢ 'A prompt that converts casual emails into formal business communications'

Remember: You're DESIGNING a prompt (meta-level), not using one. Tell me what task the prompt should perform."` : `Ask: "What is the exact GOAL of this ${pattern.name.toLowerCase()}? What specific output/result should it produce?"`}

DO NOT build phases, items, or subtasks in Turn 1. Wait to understand the goal first.
`}`;
        }

        // Merge tree update into working tree (SMART MERGE - preserves existing data)
        function mergeTreeUpdate(update) {
            if (update.name) wizardState.workingTree.name = update.name;
            if (update.description) wizardState.workingTree.description = update.description;

            if (update.children) {
                // Initialize existing children if none
                if (!wizardState.workingTree.children) {
                    wizardState.workingTree.children = [];
                }

                // Helper: Find matching phase by name (case-insensitive, fuzzy)
                function findMatchingPhase(phaseName, existingPhases) {
                    const normalizedName = phaseName.toLowerCase().trim();
                    return existingPhases.find(p =>
                        p.name.toLowerCase().trim() === normalizedName ||
                        p.name.toLowerCase().includes(normalizedName) ||
                        normalizedName.includes(p.name.toLowerCase())
                    );
                }

                // Helper: Find matching item by name (case-insensitive, fuzzy)
                function findMatchingItem(itemName, existingItems) {
                    const normalizedName = itemName.toLowerCase().trim();
                    return existingItems.find(i =>
                        i.name.toLowerCase().trim() === normalizedName ||
                        i.name.toLowerCase().includes(normalizedName) ||
                        normalizedName.includes(i.name.toLowerCase())
                    );
                }

                // Track which existing phases were matched
                const matchedPhaseIds = new Set();

                // Process each phase from update
                update.children.forEach((updatedPhase, phaseIdx) => {
                    const existingPhase = findMatchingPhase(updatedPhase.name, wizardState.workingTree.children);

                    if (existingPhase) {
                        // MERGE with existing phase
                        console.log(`üîÑ Merging phase: ${updatedPhase.name}`);
                        matchedPhaseIds.add(existingPhase.id);

                        // Update phase-level fields (preserve existing if not in update)
                        existingPhase.name = updatedPhase.name || existingPhase.name;
                        existingPhase.subtitle = updatedPhase.subtitle || existingPhase.subtitle;
                        if (updatedPhase.description) existingPhase.description = updatedPhase.description;

                        // Merge items (standard patterns) OR children (filesystem pattern)
                        const itemsArrayName = updatedPhase.items ? 'items' : (updatedPhase.children ? 'children' : null);
                        if (itemsArrayName) {
                            if (!existingPhase[itemsArrayName]) existingPhase[itemsArrayName] = [];

                            const matchedItemIds = new Set();

                            updatedPhase[itemsArrayName].forEach((updatedItem, itemIdx) => {
                                const existingItem = findMatchingItem(updatedItem.name, existingPhase[itemsArrayName]);

                                if (existingItem) {
                                    // MERGE with existing item - preserve ALL existing fields
                                    console.log(`  üîÑ Merging item: ${updatedItem.name}`);
                                    matchedItemIds.add(existingItem.id);

                                    // Merge all fields (keep existing if not in update)
                                    Object.keys(updatedItem).forEach(key => {
                                        if (key !== 'subItems' && key !== 'children' && updatedItem[key] !== undefined && updatedItem[key] !== '') {
                                            existingItem[key] = updatedItem[key];
                                        }
                                    });

                                    // Merge subItems (RECURSIVE for N-level depth support)
                                    // Supports both 'subItems' (standard) and 'children' (filesystem)
                                    function mergeSubItems(existingParent, updatedParent, parentPhase, parentItemIdx) {
                                        const nestedArrayName = updatedParent.subItems ? 'subItems' : (updatedParent.children ? 'children' : null);
                                        if (!nestedArrayName) return;
                                        if (!existingParent[nestedArrayName]) existingParent[nestedArrayName] = [];

                                        updatedParent[nestedArrayName].forEach(newSubItem => {
                                            const existingSubItem = existingParent[nestedArrayName].find(s =>
                                                s.name.toLowerCase().trim() === newSubItem.name.toLowerCase().trim()
                                            );

                                            if (existingSubItem) {
                                                // Update existing subItem
                                                Object.keys(newSubItem).forEach(key => {
                                                    if (key !== 'subItems' && key !== 'children' && newSubItem[key] !== undefined && newSubItem[key] !== '') {
                                                        existingSubItem[key] = newSubItem[key];
                                                    }
                                                });

                                                // RECURSIVE: Merge nested items (supports N-level depth)
                                                mergeSubItems(existingSubItem, newSubItem, parentPhase, parentItemIdx);
                                            } else {
                                                // Add new item with auto-generated ID
                                                const subIdx = existingParent[nestedArrayName].length;
                                                const newSubItemWithId = {
                                                    id: `${nestedArrayName === 'children' ? 'child' : 'subtask'}-${parentPhase}-${parentItemIdx}-${subIdx}`,
                                                    type: nestedArrayName === 'children' ? 'item' : 'subtask',
                                                    ...newSubItem
                                                };
                                                existingParent[nestedArrayName].push(newSubItemWithId);
                                            }
                                        });
                                    }

                                    mergeSubItems(existingItem, updatedItem, existingPhase.phase, existingPhase[itemsArrayName].indexOf(existingItem));
                                } else {
                                    // ADD new item to existing phase
                                    console.log(`  ‚úÖ Adding new item: ${updatedItem.name}`);
                                    const newItemIdx = existingPhase[itemsArrayName].length;

                                    // RECURSIVE function to add IDs to nested items (supports both subItems and children)
                                    function addNestedItemIds(nestedItems, nestedArrayName, phaseIdx, itemIdx, parentPath = '') {
                                        if (!nestedItems) return [];
                                        return nestedItems.map((nestedItem, nestedIdx) => {
                                            const childArrayName = nestedItem.subItems ? 'subItems' : (nestedItem.children ? 'children' : null);
                                            const result = {
                                                id: `${nestedArrayName === 'children' ? 'child' : 'subtask'}-${phaseIdx}-${itemIdx}-${parentPath}${nestedIdx}`,
                                                type: nestedArrayName === 'children' ? 'item' : 'subtask',
                                                ...nestedItem
                                            };
                                            if (childArrayName) {
                                                result[childArrayName] = addNestedItemIds(nestedItem[childArrayName], childArrayName, phaseIdx, itemIdx, `${parentPath}${nestedIdx}-`);
                                            }
                                            return result;
                                        });
                                    }

                                    const nestedArrayName = updatedItem.subItems ? 'subItems' : (updatedItem.children ? 'children' : null);
                                    const newItem = {
                                        id: `item-${existingPhase.phase}-${newItemIdx}`,
                                        type: 'item',
                                        icon: 'üìÑ',
                                        expanded: false,
                                        ...updatedItem
                                    };
                                    if (nestedArrayName) {
                                        newItem[nestedArrayName] = addNestedItemIds(updatedItem[nestedArrayName], nestedArrayName, existingPhase.phase, newItemIdx);
                                    }
                                    existingPhase[itemsArrayName].push(newItem);
                                }
                            });

                            // PRESERVE existing items that weren't in the update
                            console.log(`  ‚ÑπÔ∏è Preserved ${existingPhase[itemsArrayName].filter(i => !matchedItemIds.has(i.id)).length} existing items not in update`);
                        }
                    } else {
                        // ADD new phase
                        console.log(`‚úÖ Adding new phase: ${updatedPhase.name}`);
                        const newPhaseIdx = wizardState.workingTree.children.length;

                        // RECURSIVE function to add IDs to nested subItems (reuse from above)
                        function addSubItemIds(subItems, phaseIdx, itemIdx, parentPath = '') {
                            if (!subItems) return [];
                            return subItems.map((subItem, subIdx) => ({
                                id: `subtask-${phaseIdx}-${itemIdx}-${parentPath}${subIdx}`,
                                type: 'subtask',
                                ...subItem,
                                subItems: addSubItemIds(subItem.subItems, phaseIdx, itemIdx, `${parentPath}${subIdx}-`)
                            }));
                        }

                        wizardState.workingTree.children.push({
                            id: `phase-${newPhaseIdx}`,
                            type: 'phase',
                            phase: newPhaseIdx,
                            icon: 'üìã',
                            expanded: true,
                            ...updatedPhase,
                            items: (updatedPhase.items || []).map((item, itemIdx) => ({
                                id: `item-${newPhaseIdx}-${itemIdx}`,
                                type: 'item',
                                icon: 'üìÑ',
                                expanded: false,
                                ...item,
                                subItems: addSubItemIds(item.subItems, newPhaseIdx, itemIdx)
                            }))
                        });
                    }
                });

                // PRESERVE existing phases that weren't in the update
                const preservedPhases = wizardState.workingTree.children.filter(p => !matchedPhaseIds.has(p.id));
                console.log(`‚ÑπÔ∏è Preserved ${preservedPhases.length} existing phases not in update`);

                // Re-index phase numbers
                wizardState.workingTree.children.forEach((phase, idx) => {
                    phase.phase = idx;
                });

                console.log(`‚úÖ Smart merge complete: ${wizardState.workingTree.children.length} phases, ${wizardState.workingTree.children.reduce((sum, p) => sum + (p.items?.length || 0), 0)} items`);
            }
        }

        // Update tree preview - copy working tree to main tree and render in real-time
        function updateWizardPreview() {
            // Copy working tree to main tree
            capexTree = JSON.parse(JSON.stringify(wizardState.workingTree));

            // Render to show real-time updates on the left
            render();

            console.log('‚úÖ Tree updated in real-time:', {
                name: capexTree.name,
                phases: capexTree.children?.length || 0,
                items: capexTree.children?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0
            });

            return;

            const preview = document.getElementById('wizard-tree-preview');
            const tree = wizardState.workingTree;

            let html = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 10px; color: var(--treeplex-primary); border-bottom: 2px solid var(--treeplex-primary); padding-bottom: 8px;">
                ${tree.icon || 'üå≥'} ${tree.name || 'Untitled Project'}
            </div>`;

            if (tree.description) {
                html += `<div style="color: var(--text-secondary); margin-bottom: 20px; font-size: 13px; font-style: italic;">
                    ${tree.description}
                </div>`;
            }

            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    // Phase header with background
                    html += `<div style="margin-bottom: 20px; border-left: 3px solid var(--treeplex-primary); padding-left: 12px;">
                        <div style="font-weight: 600; font-size: 14px; color: var(--treeplex-primary); margin-bottom: 8px;">
                            ${phase.icon || 'üìã'} ${phase.name}
                            ${phase.subtitle ? `<div style="color: var(--text-secondary); font-weight: 400; font-size: 12px; margin-top: 2px;">${phase.subtitle}</div>` : ''}
                        </div>`;

                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            // Item
                            html += `<div style="margin-left: 15px; margin-bottom: 10px; padding: 8px; background: var(--card-bg-light); border-radius: 6px;">
                                <div style="color: var(--text-primary); font-weight: 500; font-size: 13px;">
                                    ${item.icon || 'üìÑ'} ${item.name}
                                </div>`;

                            // Item description
                            if (item.description) {
                                html += `<div style="color: var(--text-secondary); font-size: 11px; margin-top: 4px; margin-left: 20px;">
                                    ${item.description}
                                </div>`;
                            }

                            // Dependencies (if present - for backward compatibility)
                            if (item.dependencies) {
                                // Handle both array and string formats
                                const depText = Array.isArray(item.dependencies)
                                    ? item.dependencies.join(', ')
                                    : item.dependencies;
                                if (depText && depText.length > 0) {
                                    html += `<div style="color: #f59e0b; font-size: 11px; margin-top: 4px; margin-left: 20px;">
                                        ‚ö†Ô∏è Depends on: ${depText}
                                    </div>`;
                                }
                            }

                            // Subtasks
                            if (item.subtasks && item.subtasks.length > 0) {
                                html += `<div style="margin-left: 20px; margin-top: 6px;">`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    html += `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 3px;">
                                        ‚ñ∏ ${subtask.name}${subtask.description ? ': ' + subtask.description : ''}
                                    </div>`;
                                });
                                html += `</div>`;
                            }

                            html += `</div>`; // End item
                        });
                    }

                    html += `</div>`; // End phase
                });
            } else {
                html += `<div style="color: var(--text-secondary); text-align: center; margin-top: 40px; padding: 40px 20px; border: 2px dashed var(--border); border-radius: 8px;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üå±</div>
                    <div>Waiting for conversation to start building the tree...</div>
                </div>`;
            }

            preview.innerHTML = html;
        }

        // Finish wizard
        document.getElementById('wizard-done').addEventListener('click', () => {
            // Save state for undo
            saveState('AI Wizard: Apply changes');

            // Apply working tree to main tree (deep copy to prevent reference issues)
            capexTree = JSON.parse(JSON.stringify(wizardState.workingTree));
            currentPattern = wizardState.patternKey;

            // Close modal
            document.getElementById('wizard-modal').style.display = 'none';

            // Render updated tree
            render();

            console.log('ü™Ñ Wizard complete! Tree applied.');
        });

        // Cancel wizard
        document.getElementById('wizard-cancel').addEventListener('click', () => {
            if (confirm('Are you sure? Your progress will be lost.')) {
                document.getElementById('wizard-modal').style.display = 'none';
            }
        });

        // Auto-Enhance: Run AI Review then enhance tree automatically
        async function runAutoEnhance() {
            // Check if tree has content
            if (!hasExistingContent()) {
                alert('‚ö†Ô∏è Your tree is empty.\n\nPlease add some content first, then use Auto-Enhance.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            try {
                // Open wizard modal first
                document.getElementById('wizard-modal').style.display = 'flex';

                // Show loading state in wizard
                const chatHistory = document.getElementById('wizard-chat-history');
                chatHistory.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">üîç Step 1/2: Analyzing your tree for improvements...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Using your preferred AI model for review</p>
                    </div>
                `;

                // Step 1: Run AI Review to get suggestions
                const pattern = PATTERNS[currentPattern];
                const tree = capexTree;
                const reviewPrompt = buildReviewPrompt(tree, pattern);

                // Get current AI mode (respect user's choice of Gemini or ChatGPT)
                const currentAIMode = document.getElementById('unified-ai-mode-select').value;

                // Use user's selected model for review
                const reviewExperts = {
                    philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments. Review for logical validity, premise strength, and dialectical completeness.',
                    sales: 'You are a sales strategist with 20 years of enterprise B2B experience. Review for pipeline health, deal qualification, and revenue optimization.',
                    thesis: 'You are an academic advisor helping graduate students structure rigorous research. Review for argument progression, citation quality, and scholarly standards.',
                    roadmap: 'You are a product manager experienced in agile development and feature prioritization. Review for execution readiness, story completeness, and technical feasibility.',
                    prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude, GPT-4, and other LLMs. Review for prompt clarity, few-shot example quality, output format specification, and edge case handling.',
                    book: 'You are a professional fiction editor and writing coach. Review for narrative flow, character development, and pacing.',
                    film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway). Review for visual storytelling, shot composition, and production feasibility.',
                    course: 'You are an instructional designer with expertise in curriculum development. Review for learning progression, assessment alignment, and instructional scaffolding.',
                    dialogue: 'You are a debate coach and rhetoric expert specializing in argumentation theory, logical fallacies, and persuasive communication. Review for argument strength, rhetorical effectiveness, fallacy identification, and evidence quality.',
                    generic: `You are an expert ${pattern.name} analyst. Review the provided tree structure for completeness, redundancies, logical flow, and alignment with ${pattern.name} best practices.`
                };

                const expertPersona = reviewExperts[currentPattern] || reviewExperts.generic;

                console.log(`üîÑ Auto-Enhance: Running AI Review with ${currentAIMode}...`);

                const reviewResponse = await callClaudeAPI(
                    reviewPrompt,
                    expertPersona + ' Provide specific, actionable suggestions.',
                    4096,
                    false // No extended thinking for faster review
                );

                // Extract improvements section
                const improvements = extractSection(reviewResponse, 'IMPROVEMENTS');

                if (!improvements) {
                    alert('‚ùå No improvements were suggested.\n\nYour tree appears complete!');
                    document.getElementById('wizard-modal').style.display = 'none';
                    return;
                }

                console.log('‚úÖ Got improvements:', improvements.substring(0, 200) + '...');

                // Step 2: Start wizard in enhance mode with improvements
                chatHistory.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">‚ú® Step 2/2: Starting enhancement wizard...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Using Sonnet for high-quality enhancements</p>
                    </div>
                `;

                // Force Sonnet for wizard enhancements (better quality)
                const originalAIMode = currentAIMode;
                document.getElementById('unified-ai-mode-select').value = 'server-sonnet';

                // Start wizard in enhance mode
                await startWizard(true); // true = enhance mode

                // Restore original AI mode selection
                document.getElementById('unified-ai-mode-select').value = originalAIMode;

                // Automatically send improvements as first message
                setTimeout(() => {
                    const userInput = document.getElementById('wizard-user-input');
                    const sendBtn = document.getElementById('wizard-send');

                    userInput.value = improvements;
                    sendBtn.click();
                }, 500);

                console.log('üîÑ Auto-Enhance workflow started successfully!');

            } catch (error) {
                console.error('‚ùå Auto-Enhance error:', error);
                alert(`‚ùå Auto-Enhance failed:\n\n${error.message}`);

                // Clear loading state and close modal
                document.getElementById('wizard-chat-history').innerHTML = '';
                document.getElementById('wizard-modal').style.display = 'none';
            }
        }

        // Toolbar button handler
        document.getElementById('auto-enhance-btn').addEventListener('click', runAutoEnhance);

        // Wizard footer button handler
        document.getElementById('wizard-auto-enhance').addEventListener('click', runAutoEnhance);

        // =============================================================================
        // GENERATE PROMPT SYSTEM
        // =============================================================================

        // Generate Prompt button
        document.getElementById('generate-prompt-btn').addEventListener('click', () => {
            const promptText = generatePromptFromTree();
            document.getElementById('generated-prompt-text').value = promptText;
            document.getElementById('generate-prompt-modal').style.display = 'flex';
        });

        // Close prompt modal
        document.getElementById('close-prompt-modal').addEventListener('click', () => {
            document.getElementById('generate-prompt-modal').style.display = 'none';
        });

        // Copy prompt to clipboard
        document.getElementById('copy-prompt-btn').addEventListener('click', async () => {
            const textArea = document.getElementById('generated-prompt-text');
            try {
                await navigator.clipboard.writeText(textArea.value);
                const successMsg = document.getElementById('copy-success-message');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                textArea.select();
                document.execCommand('copy');
                const successMsg = document.getElementById('copy-success-message');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            }
        });

        // Generate prompt from tree structure
        function generatePromptFromTree() {
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;
            const tree = capexTree;

            let prompt = '';

            // Header based on pattern
            if (currentPattern === 'prompting') {
                prompt += generateAIPromptDesignPrompt(tree, pattern);
            } else {
                prompt += generateGenericPrompt(tree, pattern);
            }

            return prompt;
        }

        // Generate EXECUTABLE AI Prompt (not meta-description)
        // Synthesizes tree into ONE complete, copy-paste ready prompt
        function generateAIPromptDesignPrompt(tree, pattern) {
            // Collect all items to synthesize into one unified prompt
            const allItems = [];
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach(item => {
                            allItems.push({ ...item, phaseName: phase.name });
                        });
                    }
                });
            }

            if (allItems.length === 0) {
                return `*No prompts defined yet. Add items to your tree.*\n`;
            }

            // Extract components from first item (primary prompt)
            const firstItem = allItems[0];
            const systemPrompts = allItems.map(item => item.systemPrompt).filter(sp => sp && sp.length > 0);
            const userTemplates = allItems.map(item => item.userPromptTemplate).filter(ut => ut && ut.length > 0);
            const exampleItems = allItems.filter(item => item.fewShotExamples && item.fewShotExamples.length > 0);
            const formatItems = allItems.filter(item => item.outputFormat && item.outputFormat.length > 0);
            const cotItems = allItems.filter(item => item.chainOfThought && item.chainOfThought.length > 0);
            const structuralItems = allItems.filter(item => item.structuralTags && item.structuralTags.length > 0);

            // Build CLEAN EXECUTABLE prompt (no meta-instructions, just the raw prompt)
            let actualPrompt = '';

            // Add system context at the top (like a system message)
            if (systemPrompts.length > 0) {
                actualPrompt += `${systemPrompts[0]}\n\n---\n\n`;
            }

            // Add the main user instruction
            if (userTemplates.length > 0) {
                actualPrompt += userTemplates[0];
            } else {
                actualPrompt += `${tree.description || tree.name}`;
            }

            // Add few-shot examples inline if present
            if (exampleItems.length > 0) {
                actualPrompt += `\n\nHere are examples of the expected behavior:\n\n`;
                actualPrompt += exampleItems[0].fewShotExamples;
            }

            // Add output format specification
            if (formatItems.length > 0) {
                actualPrompt += `\n\n${formatItems[0].outputFormat}`;
            }

            // Add chain-of-thought instructions
            if (cotItems.length > 0) {
                actualPrompt += `\n\n${cotItems[0].chainOfThought}`;
            }

            // Add structural tags if present (Anthropic XML patterns)
            if (structuralItems.length > 0) {
                actualPrompt += `\n\n${structuralItems[0].structuralTags}`;
            }

            // RETURN CLEAN PROMPT - Ready to paste directly into AI chat
            // No markdown, no explanations, no meta-instructions
            return actualPrompt;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BUILD 122: TWO-STYLE VIDEO PROMPT GENERATOR
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Feature: Generate AI video prompts in two styles:
        //   1. Explainer/Documentary - Clean, educational, logical
        //   2. Narrative/Story - Character-driven, emotional, hero's journey
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function generateAIVideoPrompts(tree, pattern, style = null) {
            // If no style specified, show style selector and return
            if (!style) {
                showVideoStyleSelector((selectedStyle) => {
                    const prompt = generateAIVideoPrompts(tree, pattern, selectedStyle);
                    displayGeneratedPrompt(prompt, `${tree.name} - ${selectedStyle === 'narrative' ? 'Story' : 'Explainer'} Video`);
                });
                return null; // Will be called again with style
            }

            // 1. Determine the 'Hero' of the story (for Narrative mode)
            const hero = findProjectHero(tree);

            let output = `# ${tree.icon || 'üé¨'} ${tree.name || 'Video Production'}\n\n`;
            output += `**Style:** ${style === 'narrative' ? 'üé≠ Narrative / Story Mode' : 'üìä Explainer / Documentary Mode'}\n`;
            output += `**Format:** Copy-paste ready for Sora / Veo / Runway\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Hero info for narrative mode
            if (style === 'narrative') {
                output += `**Hero:** ${hero}\n`;
                output += `**Story Arc:** Three-act structure following the project completion journey\n\n`;
            }

            output += `---\n\n`;

            // Process Phases/Acts
            if (tree.children && tree.children.length > 0) {
                let previousScene = null;

                tree.children.forEach((phase, phaseIdx) => {
                    // Map Phase to Story Act (for narrative)
                    const actLabel = getStoryActLabel(phaseIdx, tree.children.length);

                    output += `## ${phase.name}`;
                    if (style === 'narrative') {
                        output += ` (${actLabel})`;
                    } else {
                        output += ` (Phase ${phaseIdx + 1})`;
                    }
                    output += `\n\n`;

                    if (phase.subtitle || phase.description) {
                        output += `*${phase.subtitle || phase.description}*\n\n`;
                    }

                    // Process Items/Scenes
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            const sceneNumber = `${phaseIdx + 1}.${itemIdx + 1}`;

                            // Generate the prompt based on style
                            const promptText = style === 'narrative'
                                ? synthesizeNarrativePrompt(item, hero, actLabel, previousScene)
                                : synthesizeExplainerPrompt(item);

                            output += `### Scene ${sceneNumber}: ${item.name}\n\n`;
                            output += `**Platform:** ${item.aiPlatform || 'Sora (OpenAI)'}\n\n`;
                            output += `**Prompt:**\n\`\`\`\n${promptText}\n\`\`\`\n\n`;

                            // Technical specs
                            const specs = [];
                            if (item.duration) specs.push(`Duration: ${item.duration}`);
                            if (item.aspectRatio) specs.push(`Aspect: ${item.aspectRatio}`);
                            if (item.visualStyle) specs.push(`Style: ${item.visualStyle}`);
                            if (specs.length > 0) {
                                output += `**Tech:** ${specs.join(' ‚Ä¢ ')}\n\n`;
                            }

                            output += `---\n\n`;

                            // Store for continuity
                            previousScene = item;
                        });
                    }
                });
            }

            // Usage instructions
            output += `\n## üìã Usage Instructions\n\n`;
            output += `1. Copy the prompt text (inside the code block)\n`;
            output += `2. Paste into your AI video platform:\n`;
            output += `   - **Sora** (OpenAI): Best for photorealistic, cinematic shots\n`;
            output += `   - **Veo 3** (Google): Great for consistent styles, longer clips\n`;
            output += `   - **Runway Gen-3**: Fast iteration, good for prototyping\n`;
            output += `   - **Pika 2.0**: Stylized, artistic effects\n`;
            output += `3. Adjust technical settings (duration, aspect ratio) as specified\n`;
            output += `4. Generate and review results\n`;
            output += `5. Iterate: Use the Notes section to refine prompts\n\n`;

            output += `---\n\n`;
            output += `**üí° Pro Tip:** ${style === 'narrative'
                ? 'Narrative videos work best for marketing, storytelling, and emotional connection. Consider adding background music and voiceover narration!'
                : 'Explainer videos work best for investor presentations, team onboarding, and educational content. Keep pacing consistent and visuals clean!'
            }\n`;

            return output;
        }

        // Helper: Find the Hero (Main Character)
        function findProjectHero(tree) {
            // Strategy 1: Find most frequently assigned person
            const assignees = {};

            function traverseTree(node) {
                if (node.pmAssignee && node.pmAssignee !== 'Unassigned') {
                    assignees[node.pmAssignee] = (assignees[node.pmAssignee] || 0) + 1;
                }
                if (node.children) {
                    node.children.forEach(child => traverseTree(child));
                }
                if (node.items) {
                    node.items.forEach(item => traverseTree(item));
                }
                if (node.subItems || node.subtasks) {
                    (node.subItems || node.subtasks).forEach(sub => traverseTree(sub));
                }
            }

            traverseTree(tree);

            // Return most frequent assignee
            const sorted = Object.entries(assignees).sort((a, b) => b[1] - a[1]);
            if (sorted.length > 0) return sorted[0][0];

            // Strategy 2: Extract name from descriptions
            function getAllText(node) {
                let text = (node.name || '') + ' ' + (node.description || '');
                if (node.children) {
                    node.children.forEach(child => text += ' ' + getAllText(child));
                }
                if (node.items) {
                    node.items.forEach(item => text += ' ' + getAllText(item));
                }
                return text;
            }

            const allText = getAllText(tree);
            const nameMatch = allText.match(/\b([A-Z][a-z]+ [A-Z][a-z]+)\b/);
            if (nameMatch) return nameMatch[1];

            // Strategy 3: Use tree owner or default
            return tree.owner || tree.createdBy || "The Project Lead";
        }

        // Helper: Map Phases to Story Acts
        function getStoryActLabel(index, total) {
            if (total <= 1) return "The Journey";
            const position = index / (total - 1);
            if (position < 0.4) return "Act I: The Challenge";
            if (position < 0.75) return "Act II: The Struggle";
            return "Act III: The Triumph";
        }

        // Style 1: Explainer / Documentary
        function synthesizeExplainerPrompt(item) {
            const visualSubject = item.name;
            const details = item.description || "Project details";

            // Financial context
            let financialGraphic = "";
            if (item.cost) {
                const costM = (item.cost / 1000000).toFixed(1);
                financialGraphic = `Budget graphic showing $${costM}M overlaid on screen.`;
            } else if (item.dealValue) {
                const valueM = (item.dealValue / 1000000).toFixed(1);
                financialGraphic = `Deal value of $${valueM}M displayed as infographic.`;
            } else if (item.investment) {
                const investM = (item.investment / 1000000).toFixed(1);
                financialGraphic = `Investment: $${investM}M shown in clean typography.`;
            }

            // Timeline context
            let timelineGraphic = "";
            if (item.leadTime) {
                timelineGraphic = `Timeline graphic animating: ${item.leadTime}.`;
            } else if (item.engineeringEstimate) {
                timelineGraphic = `Duration overlay: ${item.engineeringEstimate}.`;
            } else if (item.duration) {
                timelineGraphic = `Timeline: ${item.duration}.`;
            }

            // Location/Setting
            let setting = "Modern office environment or construction site";
            if (item.location) {
                setting = item.location;
            } else if (details.toLowerCase().includes('office')) {
                setting = "Modern glass office with city view";
            } else if (details.toLowerCase().includes('site') || details.toLowerCase().includes('land')) {
                setting = "Construction site or development location";
            } else if (details.toLowerCase().includes('lab') || details.toLowerCase().includes('research')) {
                setting = "Clean research laboratory";
            }

            return `Style: High-end Corporate Documentary. Photorealistic. 8k resolution.
Shot: Slow tracking shot or aerial drone view establishing the scope.
Subject: ${visualSubject}.
Action: ${details}. The visualization builds itself on screen with clean architectural lines.
Overlay Graphics: ${financialGraphic} ${timelineGraphic}
Setting: ${setting}.
Lighting: Bright, clean, clinical, "Apple store" aesthetic with soft shadows.
Mood: Competent, organized, futuristic, inspiring confidence.
Camera: Steady, professional gimbal movement. Wide to medium shots.`;
        }

        // Style 2: Narrative / Story
        function synthesizeNarrativePrompt(item, hero, act, previousScene) {
            const action = item.description || "working on the task";

            // Get dynamic mood based on context
            const moodData = getNarrativeMood(item, act);
            const mood = moodData.mood;
            const lighting = moodData.lighting;

            // Get appropriate setting
            const setting = getNarrativeSetting(item, act);

            // Emotional stakes
            const stakes = getEmotionalStakes(item);

            // Continuity from previous scene
            let continuity = "";
            if (previousScene) {
                continuity = `\nContinuity: Previous scene: "${previousScene.name}". This scene shows the consequence/progress of that action.`;
            }

            // Character details
            const characterDesc = `${hero} (30s-40s, professional, determined expression)`;

            return `Style: Cinematic Movie Scene. Anamorphic lens. Film grain.
Character: ${characterDesc}
Setting: ${setting}
Action: ${hero} is ${action}. ${mood}. ${stakes}${continuity}
Detail: Close-up on ${hero}'s face showing ${getEmotionalExpression(mood)}. Show determination and professionalism.
Lighting: ${lighting}. Cinematic contrast with dramatic shadows.
Mood: ${mood}. High stakes atmosphere.
Camera: Dynamic - Start wide, dolly in to close-up, or handheld for intensity.`;
        }

        // Helper: Dynamic Mood Detection
        function getNarrativeMood(item, act) {
            let mood = "Determined and focused";
            let lighting = "Natural daylight through windows";

            // Act-based default
            if (act.includes("Challenge")) {
                mood = "Optimistic but focused, ready to take on the world";
                lighting = "Morning sun streaming through windows, golden and hopeful";
            } else if (act.includes("Struggle")) {
                mood = "Stressed, high stakes, late night problem-solving";
                lighting = "Dark office, blue screen glow, single desk lamp, shadows";
            } else if (act.includes("Triumph")) {
                mood = "Relieved, celebratory, breakthrough moment";
                lighting = "Golden hour, warm sunset, victorious warm tones";
            }

            // Override with cost/value signals (high stakes)
            const monetaryValue = item.cost || item.dealValue || item.investment || 0;
            if (monetaryValue > 10000000) {
                mood = "Extreme pressure, multi-million dollar stakes, intense focus";
                lighting = "Dramatic boardroom lighting, spotlight effect, high contrast";
            } else if (monetaryValue > 5000000) {
                mood = "High pressure, massive responsibility, calculated decisions";
                lighting = "Serious office lighting, professional intensity";
            }

            // Override with status signals (crisis)
            if (item.pmStatus === 'Blocked' || item.pmBlockingIssue) {
                mood = "Crisis mode, urgent problem-solving, racing against time";
                lighting = "Harsh fluorescent, emergency meeting, red alert tones";
            }

            // Override with risk signals
            if (item.technicalRisk === 'High' || item.riskLevel === 'high') {
                mood = "Cautious, careful analysis, aware of dangers";
                lighting = "Moody, dramatic shadows, tension in the frame";
            }

            // Dependencies = coordination stress
            if (item.dependencies && item.dependencies.length > 3) {
                mood = "Coordination stress, juggling multiple priorities, multitasking energy";
            }

            return { mood, lighting };
        }

        // Helper: Setting Detection
        function getNarrativeSetting(item, act) {
            // Check if explicit setting exists
            if (item.location) return item.location;
            if (item.sceneSetting) return item.sceneSetting;

            // Infer from description
            const desc = (item.name + ' ' + (item.description || '')).toLowerCase();

            if (desc.includes('site') || desc.includes('construction') || desc.includes('land')) {
                return "Active construction site, equipment in background, dirt and machinery";
            }
            if (desc.includes('office') || desc.includes('meeting')) {
                return "Modern glass office, city skyline visible, professional environment";
            }
            if (desc.includes('lab') || desc.includes('research')) {
                return "Clean research laboratory, high-tech equipment, sterile environment";
            }
            if (desc.includes('field') || desc.includes('outdoor')) {
                return "Outdoor location, natural environment, sky visible";
            }

            // Default based on act
            if (act.includes("Challenge")) {
                return "Modern office conference room, early morning, project plans visible";
            } else if (act.includes("Struggle")) {
                return "Office late at night, desks cluttered with documents, pressure visible";
            } else if (act.includes("Triumph")) {
                return "Office or construction site, celebrating success, relieved atmosphere";
            }

            return "Professional office or work environment";
        }

        // Helper: Emotional Stakes
        function getEmotionalStakes(item) {
            const monetaryValue = item.cost || item.dealValue || item.investment || 0;
            const timeline = item.leadTime || item.engineeringEstimate || item.duration || "";

            if (monetaryValue > 5000000) {
                return `Career-defining moment. Millions on the line.`;
            }
            if (monetaryValue > 1000000) {
                return `Major project milestone. Success matters.`;
            }
            if (timeline.includes('month') && parseInt(timeline) < 6) {
                return `Tight deadline. Time pressure evident.`;
            }
            if (item.dependencies && item.dependencies.length > 2) {
                return `Complex dependencies. Everything must align.`;
            }

            return `Professional commitment. Doing this right matters.`;
        }

        // Helper: Emotional Expression
        function getEmotionalExpression(mood) {
            if (mood.includes("Optimistic")) return "hope mixed with determination";
            if (mood.includes("Stressed") || mood.includes("Crisis")) return "stress and urgent focus";
            if (mood.includes("Relieved") || mood.includes("celebratory")) return "relief and satisfaction";
            if (mood.includes("pressure")) return "intense concentration under pressure";
            if (mood.includes("Cautious")) return "careful calculation and wariness";
            return "professional determination and focus";
        }

        // UI: Style Selector Modal
        function showVideoStyleSelector(callback) {
            // Remove any existing modal
            const existingModal = document.querySelector('.video-style-modal');
            if (existingModal) existingModal.remove();

            const modalHTML = `
                <div class="modal-overlay video-style-modal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.85);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                ">
                    <div class="modal-content" style="
                        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                        border-radius: 16px;
                        padding: 32px;
                        max-width: 800px;
                        width: 90%;
                        color: #e4e4e7;
                        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
                    ">
                        <h2 style="
                            font-size: 28px;
                            margin-bottom: 8px;
                            background: linear-gradient(135deg, #60a5fa, #a78bfa);
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                            background-clip: text;
                        ">üé¨ Choose Video Style</h2>

                        <p style="color: #9ca3af; margin-bottom: 24px; font-size: 14px;">
                            Generate AI video prompts in two different styles. Same project data, different storytelling approaches.
                        </p>

                        <div class="style-options" style="
                            display: grid;
                            grid-template-columns: 1fr 1fr;
                            gap: 20px;
                            margin-bottom: 24px;
                        ">
                            <div class="style-card" data-style="explainer" style="
                                background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                                border-radius: 12px;
                                padding: 24px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                border: 2px solid transparent;
                            ">
                                <div class="style-icon" style="font-size: 48px; margin-bottom: 12px;">üìä</div>
                                <h3 style="font-size: 18px; margin-bottom: 12px; color: #fff;">Explainer / Documentary</h3>
                                <p style="font-size: 13px; margin-bottom: 16px; color: #dbeafe; line-height: 1.5;">
                                    Clean, professional, educational. Shows the project plan logically step-by-step.
                                </p>
                                <ul style="font-size: 12px; color: #dbeafe; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 6px;">‚úÖ Investor presentations</li>
                                    <li style="margin-bottom: 6px;">‚úÖ Team onboarding</li>
                                    <li style="margin-bottom: 6px;">‚úÖ Status updates</li>
                                    <li>‚úÖ Educational content</li>
                                </ul>
                            </div>

                            <div class="style-card" data-style="narrative" style="
                                background: linear-gradient(135deg, #8b5cf6, #6d28d9);
                                border-radius: 12px;
                                padding: 24px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                border: 2px solid transparent;
                            ">
                                <div class="style-icon" style="font-size: 48px; margin-bottom: 12px;">üé≠</div>
                                <h3 style="font-size: 18px; margin-bottom: 12px; color: #fff;">Narrative / Story</h3>
                                <p style="font-size: 13px; margin-bottom: 16px; color: #ede9fe; line-height: 1.5;">
                                    Character-driven drama. Shows someone completing the project successfully with emotional stakes.
                                </p>
                                <ul style="font-size: 12px; color: #ede9fe; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 6px;">‚úÖ Marketing videos</li>
                                    <li style="margin-bottom: 6px;">‚úÖ Hero's journey arc</li>
                                    <li style="margin-bottom: 6px;">‚úÖ Emotional storytelling</li>
                                    <li>‚úÖ Brand building</li>
                                </ul>
                            </div>
                        </div>

                        <p style="
                            text-align: center;
                            color: #60a5fa;
                            font-size: 13px;
                            margin-bottom: 16px;
                        ">üí° Tip: Both styles use the same project data</p>

                        <button class="modal-cancel" style="
                            width: 100%;
                            padding: 12px;
                            background: #374151;
                            color: #e4e4e7;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            transition: all 0.2s;
                        ">Cancel</button>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // Add hover effects
            const styleCards = document.querySelectorAll('.style-card');
            styleCards.forEach(card => {
                card.addEventListener('mouseenter', () => {
                    card.style.transform = 'scale(1.05)';
                    card.style.borderColor = '#60a5fa';
                    card.style.boxShadow = '0 10px 30px rgba(96, 165, 250, 0.3)';
                });
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'scale(1)';
                    card.style.borderColor = 'transparent';
                    card.style.boxShadow = 'none';
                });

                // Click handler
                card.addEventListener('click', () => {
                    const style = card.dataset.style;
                    document.querySelector('.video-style-modal').remove();
                    callback(style);
                });
            });

            // Cancel button
            document.querySelector('.modal-cancel').addEventListener('click', () => {
                document.querySelector('.video-style-modal').remove();
            });

            // Click outside to close
            document.querySelector('.video-style-modal').addEventListener('click', (e) => {
                if (e.target.classList.contains('video-style-modal')) {
                    document.querySelector('.video-style-modal').remove();
                }
            });
        }

        // UI: Display Generated Prompt
        function displayGeneratedPrompt(prompt, title) {
            // Copy to clipboard
            navigator.clipboard.writeText(prompt).then(() => {
                showNotification(`‚úÖ ${title} - Prompt copied to clipboard!`);
            }).catch(() => {
                // Fallback: show in console if clipboard fails
                console.log('=== GENERATED PROMPT ===');
                console.log(prompt);
                showNotification(`‚úÖ ${title} - See console for prompt`);
            });
        }

        // Synthesize all video fields into one cohesive professional prompt
        // Based on Sora/Veo3 best practices: comprehensive, detailed, cinematographic
        function synthesizeVideoPrompt(item) {
            let sections = [];

            // SECTION 1: CORE SCENE DESCRIPTION
            let sceneDesc = '';
            if (item.videoPrompt) {
                sceneDesc = item.videoPrompt;
            } else if (item.description) {
                sceneDesc = item.description;
            } else {
                sceneDesc = item.name;
            }
            sections.push(sceneDesc);

            // SECTION 2: CAMERA SPECIFICATIONS
            const cameraSpecs = [];

            // Camera movement (critical for Sora/Veo3)
            if (item.cameraMovement && item.cameraMovement !== 'Static') {
                const movement = item.cameraMovement.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(movement)) {
                    cameraSpecs.push(`${movement} camera`);
                }
            } else if (!sceneDesc.toLowerCase().includes('camera')) {
                cameraSpecs.push('static camera');
            }

            // Motion intensity affects pacing
            if (item.motionIntensity) {
                const intensity = item.motionIntensity.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(intensity) && !sceneDesc.toLowerCase().includes('motion')) {
                    cameraSpecs.push(`${intensity} motion`);
                }
            }

            if (cameraSpecs.length > 0) {
                sections.push(cameraSpecs.join(', '));
            }

            // SECTION 3: LIGHTING & ATMOSPHERE
            const lightingDetails = [];

            if (item.lightingMood) {
                const mood = item.lightingMood.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(mood) && !sceneDesc.toLowerCase().includes('light')) {
                    lightingDetails.push(`${mood} lighting`);
                }
            }

            // Visual style affects overall aesthetic
            if (item.visualStyle && item.visualStyle !== 'Photorealistic') {
                const style = item.visualStyle.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(style)) {
                    lightingDetails.push(`${style} aesthetic`);
                }
            }

            if (lightingDetails.length > 0) {
                sections.push(lightingDetails.join(', '));
            }

            // SECTION 4: TECHNICAL FORMAT (professional cinematography language)
            const technicalDetails = [];

            // Aspect ratio implies framing
            if (item.aspectRatio) {
                const ratio = item.aspectRatio;
                if (ratio.includes('16:9')) {
                    if (!sceneDesc.toLowerCase().includes('widescreen') && !sceneDesc.toLowerCase().includes('cinematic')) {
                        technicalDetails.push('widescreen composition');
                    }
                } else if (ratio.includes('9:16')) {
                    if (!sceneDesc.toLowerCase().includes('vertical')) {
                        technicalDetails.push('vertical framing');
                    }
                } else if (ratio.includes('2.39')) {
                    if (!sceneDesc.toLowerCase().includes('cinematic')) {
                        technicalDetails.push('anamorphic widescreen');
                    }
                }
            }

            if (technicalDetails.length > 0) {
                sections.push(technicalDetails.join(', '));
            }

            // SYNTHESIZE: Build comprehensive prompt
            let finalPrompt = sections.filter(s => s && s.length > 0).join('. ');

            // Ensure professional formatting
            if (!finalPrompt.endsWith('.') && !finalPrompt.endsWith('!') && !finalPrompt.endsWith('?')) {
                finalPrompt += '.';
            }

            // QUALITY CHECK: Professional prompts should be detailed (100+ chars minimum)
            // If still too short, add generic cinematography guidance
            if (finalPrompt.length < 100) {
                const defaultEnhancements = [];

                if (!finalPrompt.toLowerCase().includes('focus')) {
                    defaultEnhancements.push('sharp focus on subject');
                }

                if (!finalPrompt.toLowerCase().includes('detail')) {
                    defaultEnhancements.push('high attention to detail');
                }

                if (item.duration && item.duration.includes('seconds')) {
                    const seconds = item.duration.match(/\d+/)?.[0];
                    if (seconds) {
                        defaultEnhancements.push(`${seconds}-second clip`);
                    }
                }

                if (defaultEnhancements.length > 0) {
                    finalPrompt += ` ${defaultEnhancements.join(', ')}.`;
                }
            }

            return finalPrompt;
        }

        // Generate Product Roadmap prompt (sprint-ready, execution-focused)
        function generateRoadmapPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'üöÄ'} ${tree.name || 'Product Roadmap'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate roadmap metrics
            let totalStoryPoints = 0;
            let highImpactFeatures = 0;
            let highRiskFeatures = 0;
            let totalFeatures = 0;
            const quarterMetrics = [];

            if (tree.children) {
                tree.children.forEach(quarter => {
                    if (quarter.type === 'phase' && quarter.items) {
                        let quarterPoints = 0;
                        let quarterHighImpact = 0;
                        let quarterHighRisk = 0;

                        quarter.items.forEach(feature => {
                            quarterPoints += feature.storyPoints || 0;
                            if (feature.userImpact === 'High' || feature.userImpact === 'Critical') {
                                quarterHighImpact++;
                            }
                            if (feature.technicalRisk === 'High') {
                                quarterHighRisk++;
                            }
                        });

                        quarterMetrics.push({
                            name: quarter.name || `Quarter ${quarter.phase + 1}`,
                            subtitle: quarter.subtitle,
                            features: quarter.items.length,
                            points: quarterPoints,
                            highImpact: quarterHighImpact,
                            highRisk: quarterHighRisk
                        });

                        totalStoryPoints += quarterPoints;
                        totalFeatures += quarter.items.length;
                        highImpactFeatures += quarterHighImpact;
                        highRiskFeatures += quarterHighRisk;
                    }
                });
            }

            // Roadmap Summary
            output += `## üìä Roadmap Summary\n\n`;
            output += `**Delivery Capacity:**\n`;
            output += `- Total Features: ${totalFeatures}\n`;
            output += `- Total Story Points: ${totalStoryPoints}\n`;
            output += `- Average Feature Size: ${Math.round(totalStoryPoints / totalFeatures)} points\n`;
            output += `- High-Impact Features: ${highImpactFeatures} (${Math.round(highImpactFeatures / totalFeatures * 100)}%)\n`;
            output += `- High-Risk Features: ${highRiskFeatures} (${Math.round(highRiskFeatures / totalFeatures * 100)}%)\n\n`;

            // Quarterly Planning
            output += `## üìÖ Quarterly Planning\n\n`;
            quarterMetrics.forEach((q, idx) => {
                output += `### ${q.name}${q.subtitle ? ` ‚Äî ${q.subtitle}` : ''}\n`;
                output += `- Features: ${q.features} (${q.points} story points)\n`;
                output += `- Velocity Target: ${Math.round(q.points / 6)} points/sprint (6 sprints)\n`;
                output += `- High Impact: ${q.highImpact} features\n`;
                output += `- High Risk: ${q.highRisk} features (${q.highRisk > 0 ? 'requires spike work' : 'low risk quarter'})\n\n`;
            });

            // Feature Details
            output += `---\n\n## üöÄ Feature Specifications\n\n`;

            if (tree.children) {
                tree.children.forEach((quarter, qIdx) => {
                    if (quarter.type === 'phase' && quarter.items && quarter.items.length > 0) {
                        output += `### ${quarter.name || `Quarter ${qIdx + 1}`}\n\n`;

                        quarter.items.forEach((feature, fIdx) => {
                            const storyPoints = feature.storyPoints || 0;
                            const userImpact = feature.userImpact || 'Medium';
                            const techRisk = feature.technicalRisk || 'Medium';

                            // Impact/Risk emoji indicators
                            const impactEmoji = userImpact === 'Critical' ? 'üî•' : userImpact === 'High' ? '‚ö°' : userImpact === 'Medium' ? 'üìä' : 'üìâ';
                            const riskEmoji = techRisk === 'High' ? '‚ö†Ô∏è' : techRisk === 'Medium' ? '‚ö°' : '‚úÖ';

                            output += `#### ${fIdx + 1}. ${feature.name}\n\n`;

                            // Feature card
                            output += `**Feature Overview:**\n`;
                            output += `- ${impactEmoji} User Impact: ${userImpact}\n`;
                            output += `- ${riskEmoji} Technical Risk: ${techRisk}\n`;
                            output += `- üìè Story Points: ${storyPoints} (${Math.ceil(storyPoints / 3)} sprints)\n`;
                            if (feature.engineeringEstimate) {
                                output += `- ‚è±Ô∏è Engineering Estimate: ${feature.engineeringEstimate}\n`;
                            }
                            if (feature.featureFlag) {
                                output += `- üö© Feature Flag: \`${feature.featureFlag}\`\n`;
                            }
                            output += `\n`;

                            if (feature.description) {
                                output += `**What it does:**\n${feature.description}\n\n`;
                            }

                            // Implementation tasks
                            if (feature.children && feature.children.length > 0) {
                                output += `**Implementation Tasks:**\n`;
                                feature.children.forEach((task, tIdx) => {
                                    output += `${tIdx + 1}. ${task.name}`;
                                    if (task.storyPoints) {
                                        output += ` (${task.storyPoints} pts)`;
                                    }
                                    output += `\n`;
                                    if (task.description) {
                                        output += `   ${task.description}\n`;
                                    }
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (feature.dependencies && feature.dependencies.length > 0) {
                                output += `**‚ö†Ô∏è Blocking Dependencies:** ${feature.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Execution Recommendations
            output += `## ‚ö° Execution Recommendations\n\n`;
            output += `**Sprint Planning:**\n`;
            const avgVelocity = Math.round(totalStoryPoints / (quarterMetrics.length * 6)); // Assume 6 sprints per quarter
            output += `- Target Velocity: ${avgVelocity} story points per sprint\n`;
            output += `- High-risk features: Start with spike/POC stories (1-2 sprints)\n`;
            output += `- Critical user impact: Prioritize for early quarters\n`;
            output += `- Feature flags: Use for all features >5 story points\n\n`;

            output += `**Risk Mitigation:**\n`;
            output += `1. Technical Spikes: Create 2-point spike stories for high-risk features\n`;
            output += `2. Dependency Management: Resolve blocking dependencies 1 sprint ahead\n`;
            output += `3. Incremental Delivery: Break large features (>8 points) into smaller releases\n`;
            output += `4. User Validation: Beta test high-impact features before GA\n`;
            output += `5. Monitoring: Set up dashboards and alerts for each feature flag\n\n`;

            output += `**Release Strategy:**\n`;
            output += `- Feature Flags: All features behind flags for safe rollout\n`;
            output += `- Phased Rollout: 10% ‚Üí 50% ‚Üí 100% over 2 weeks\n`;
            output += `- Rollback Plan: Document rollback procedures in each PR\n`;
            output += `- Success Metrics: Define KPIs before development starts\n\n`;

            output += `---\n\n`;
            output += `**üí° AI Prompt Usage - Actionable Deliverables:**\n`;
            output += `\n`;
            output += `**For Product Managers:**\n`;
            output += `- "Generate PRD (Product Requirements Document) for [feature name]"\n`;
            output += `- "Create user stories with acceptance criteria for [feature]"\n`;
            output += `- "Write launch email announcing [feature] to customers"\n`;
            output += `- "Design A/B test plan to validate [feature] impact"\n\n`;
            output += `**For Engineering:**\n`;
            output += `- "Create technical design doc for [feature] with architecture diagrams"\n`;
            output += `- "Write API specification (OpenAPI/Swagger) for [feature] endpoints"\n`;
            output += `- "Generate test plan covering happy path, edge cases, and error scenarios"\n`;
            output += `- "Draft database migration script for [feature] schema changes"\n\n`;
            output += `**For Research:**\n`;
            output += `- "Find 3 competitor implementations of [feature] with screenshots"\n`;
            output += `- "Research best practices for [feature type] in SaaS applications"\n`;
            output += `- "Identify potential technical challenges for [feature] implementation"\n\n`;

            return output;
        }

        // Generate Book/Novel prompt (manuscript-ready, narrative-focused)
        function generateBookPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'üìö'} ${tree.name || 'Book Manuscript'}\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Calculate manuscript metrics
            let totalWordCount = 0;
            let targetWordCount = 0;
            let totalChapters = 0;
            const chapterMetrics = [];

            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.type === 'phase' && chapter.items) {
                        let chapterWords = 0;
                        let chapterTarget = 0;
                        let sceneCount = chapter.items.length;

                        chapter.items.forEach(scene => {
                            chapterWords += scene.wordCount || 0;
                            chapterTarget += scene.targetWordCount || 0;
                        });

                        chapterMetrics.push({
                            name: chapter.name || `Chapter ${chapter.phase + 1}`,
                            subtitle: chapter.subtitle,
                            current: chapterWords,
                            target: chapterTarget,
                            scenes: sceneCount,
                            progress: chapterTarget > 0 ? Math.round((chapterWords / chapterTarget) * 100) : 0
                        });

                        totalWordCount += chapterWords;
                        targetWordCount += chapterTarget;
                        totalChapters++;
                    }
                });
            }

            const overallProgress = targetWordCount > 0 ? Math.round((totalWordCount / targetWordCount) * 100) : 0;

            // Manuscript Overview
            output += `## üìñ Manuscript Overview\n\n`;
            output += `**Writing Progress:**\n`;
            output += `- Current Length: ${totalWordCount.toLocaleString()} words\n`;
            output += `- Target Length: ${targetWordCount.toLocaleString()} words\n`;
            output += `- Completion: ${overallProgress}% ${overallProgress < 50 ? '(First Draft)' : overallProgress < 80 ? '(Revision Stage)' : '(Near Final)'}\n`;
            output += `- Structure: ${totalChapters} chapters\n`;
            output += `- Average Chapter: ${Math.round(totalWordCount / totalChapters).toLocaleString()} words\n\n`;

            // Story Arc Analysis
            output += `## üé≠ Story Arc Structure\n\n`;
            chapterMetrics.forEach((ch, idx) => {
                const position = idx / (totalChapters - 1);
                let arcStage = '';
                if (position < 0.25) arcStage = 'üìç Setup/Exposition';
                else if (position < 0.5) arcStage = '‚¨ÜÔ∏è Rising Action';
                else if (position < 0.75) arcStage = 'üî• Climax/Conflict';
                else arcStage = '‚¨áÔ∏è Falling Action/Resolution';

                const progressBar = '‚ñà'.repeat(Math.floor(ch.progress / 10)) + '‚ñë'.repeat(10 - Math.floor(ch.progress / 10));
                output += `### ${ch.name} ${arcStage}\n`;
                output += `- Progress: [${progressBar}] ${ch.progress}%\n`;
                output += `- Word Count: ${ch.current.toLocaleString()} / ${ch.target.toLocaleString()} words\n`;
                output += `- Scenes: ${ch.scenes}\n\n`;
            });

            // Scene Breakdown
            output += `---\n\n## üìù Scene-by-Scene Breakdown\n\n`;

            if (tree.children) {
                tree.children.forEach((chapter, chIdx) => {
                    if (chapter.type === 'phase' && chapter.items && chapter.items.length > 0) {
                        output += `### ${chapter.name || `Chapter ${chIdx + 1}`}${chapter.subtitle ? ` ‚Äî ${chapter.subtitle}` : ''}\n\n`;

                        chapter.items.forEach((scene, sIdx) => {
                            output += `#### Scene ${sIdx + 1}: ${scene.name}\n\n`;

                            // Scene metadata
                            const sceneMetadata = [];
                            if (scene.povCharacter) sceneMetadata.push(`**POV:** ${scene.povCharacter}`);
                            if (scene.sceneSetting) sceneMetadata.push(`**Setting:** ${scene.sceneSetting}`);
                            if (scene.plotFunction) sceneMetadata.push(`**Plot Function:** ${scene.plotFunction}`);

                            if (sceneMetadata.length > 0) {
                                output += sceneMetadata.join(' ‚Ä¢ ') + '\n\n';
                            }

                            // Scene description
                            if (scene.description) {
                                output += `**What Happens:**\n${scene.description}\n\n`;
                            }

                            // Writing progress
                            if (scene.wordCount !== undefined || scene.targetWordCount) {
                                const sceneProgress = scene.targetWordCount > 0 ? Math.round((scene.wordCount || 0) / scene.targetWordCount * 100) : 0;
                                output += `**Writing Status:** ${scene.wordCount || 0} words (${sceneProgress}% of ${scene.targetWordCount || '?'} target)`;
                                if (scene.draftStatus) {
                                    output += ` ‚Äî ${scene.draftStatus}`;
                                }
                                output += `\n\n`;
                            }

                            // Beats/moments within scene
                            if (scene.children && scene.children.length > 0) {
                                output += `**Story Beats:**\n`;
                                scene.children.forEach((beat, bIdx) => {
                                    output += `${bIdx + 1}. ${beat.name}`;
                                    if (beat.description) {
                                        output += ` ‚Äî ${beat.description}`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Writing Recommendations
            output += `## ‚úçÔ∏è Writing Strategy & Next Steps\n\n`;
            output += `**Manuscript Status:**\n`;
            if (overallProgress < 50) {
                output += `- Stage: First Draft ‚Äî focus on completing story structure\n`;
                output += `- Priority: Write forward, don't revise yet\n`;
                output += `- Goal: Reach "The End" before editing\n\n`;
            } else if (overallProgress < 80) {
                output += `- Stage: Revision ‚Äî deepen character arcs and pacing\n`;
                output += `- Priority: Address plot holes and character motivation\n`;
                output += `- Goal: Complete second draft with all scenes polished\n\n`;
            } else {
                output += `- Stage: Final Polish ‚Äî line edits and beta feedback\n`;
                output += `- Priority: Professional editing and proofreading\n`;
                output += `- Goal: Query-ready or publish-ready manuscript\n\n`;
            }

            output += `**Story Development Checklist:**\n`;
            output += `1. Character Arcs: Do all major characters change/grow?\n`;
            output += `2. Plot Coherence: Are there any unresolved threads?\n`;
            output += `3. Pacing: Does each scene advance plot or deepen character?\n`;
            output += `4. Setting: Is the world vivid and consistent?\n`;
            output += `5. Theme: Are thematic elements woven throughout?\n\n`;

            output += `**Scene-Level Quality:**\n`;
            output += `- Each scene should have: Goal, Conflict, Disaster (or Resolution)\n`;
            output += `- POV consistency within chapters\n`;
            output += `- Vary scene length for pacing (long for tension, short for action)\n`;
            output += `- End chapters with hooks to keep readers engaged\n\n`;

            output += `---\n\n`;
            output += `**üí° AI Prompt Usage - Manuscript Deliverables:**\n`;
            output += `\n`;
            output += `**For Drafting:**\n`;
            output += `- "Write a 1000-word opening scene for [chapter] from [POV character]'s perspective"\n`;
            output += `- "Expand [scene name] with more sensory details and emotional depth"\n`;
            output += `- "Draft dialogue between [character A] and [character B] about [conflict]"\n`;
            output += `- "Write the climax scene where [key plot event] happens"\n\n`;
            output += `**For Revision:**\n`;
            output += `- "Analyze character arc for [protagonist] - identify weak character development"\n`;
            output += `- "Find pacing issues in Act 2 - which scenes drag or feel rushed?"\n`;
            output += `- "Suggest ways to increase tension in [chapter name]"\n`;
            output += `- "Identify plot holes or inconsistencies in the manuscript"\n\n`;
            output += `**For Publishing:**\n`;
            output += `- "Write a compelling 300-word book blurb for marketing"\n`;
            output += `- "Generate 20 comp titles (comparable books) with explanation"\n`;
            output += `- "Draft query letter to literary agents highlighting unique elements"\n`;
            output += `- "Create chapter summaries for submission synopsis (1-2 sentences each)"\n\n`;

            return output;
        }

        // Generate Course/Training prompt (curriculum-ready, learning-focused)
        function generateCoursePrompt(tree, pattern) {
            let output = `# ${tree.icon || 'üìñ'} ${tree.name || 'Course Curriculum'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate course metrics
            let totalDuration = 0;
            let totalLessons = 0;
            let assessmentCount = 0;
            const moduleMetrics = [];

            if (tree.children) {
                tree.children.forEach(module => {
                    if (module.type === 'phase' && module.items) {
                        let moduleDuration = 0;
                        let lessonCount = module.items.length;

                        module.items.forEach(lesson => {
                            // Parse duration (e.g., "2 hours", "45 minutes")
                            if (lesson.duration) {
                                const match = lesson.duration.match(/(\d+)\s*(hour|minute|min)/i);
                                if (match) {
                                    const value = parseInt(match[1]);
                                    const unit = match[2].toLowerCase();
                                    moduleDuration += unit.startsWith('hour') ? value * 60 : value;
                                }
                            }
                            if (lesson.assessmentType && lesson.assessmentType !== 'None') {
                                assessmentCount++;
                            }
                        });

                        moduleMetrics.push({
                            name: module.name || `Module ${module.phase + 1}`,
                            subtitle: module.subtitle,
                            duration: moduleDuration,
                            lessons: lessonCount
                        });

                        totalDuration += moduleDuration;
                        totalLessons += lessonCount;
                    }
                });
            }

            const totalHours = Math.floor(totalDuration / 60);
            const totalMinutes = totalDuration % 60;

            // Course Overview
            output += `## üéì Course Overview\n\n`;
            output += `**Course Specifications:**\n`;
            output += `- Total Duration: ${totalHours}h ${totalMinutes}m\n`;
            output += `- Total Modules: ${moduleMetrics.length}\n`;
            output += `- Total Lessons: ${totalLessons}\n`;
            output += `- Assessments: ${assessmentCount}\n`;
            output += `- Average Lesson: ${Math.round(totalDuration / totalLessons)} minutes\n\n`;

            // Learning Path
            output += `## üõ§Ô∏è Learning Path Structure\n\n`;
            moduleMetrics.forEach((mod, idx) => {
                const modHours = Math.floor(mod.duration / 60);
                const modMinutes = mod.duration % 60;
                output += `### Module ${idx + 1}: ${mod.name}${mod.subtitle ? ` ‚Äî ${mod.subtitle}` : ''}\n`;
                output += `- Duration: ${modHours}h ${modMinutes}m\n`;
                output += `- Lessons: ${mod.lessons}\n`;
                output += `- Average Lesson: ${Math.round(mod.duration / mod.lessons)} minutes\n\n`;
            });

            // Detailed Curriculum
            output += `---\n\n## üìö Detailed Curriculum\n\n`;

            if (tree.children) {
                tree.children.forEach((module, modIdx) => {
                    if (module.type === 'phase' && module.items && module.items.length > 0) {
                        output += `### Module ${modIdx + 1}: ${module.name || `Module ${modIdx + 1}`}\n\n`;
                        if (module.subtitle) {
                            output += `*${module.subtitle}*\n\n`;
                        }

                        module.items.forEach((lesson, lesIdx) => {
                            output += `#### Lesson ${modIdx + 1}.${lesIdx + 1}: ${lesson.name}\n\n`;

                            // Lesson metadata
                            const metadata = [];
                            if (lesson.duration) metadata.push(`‚è±Ô∏è ${lesson.duration}`);
                            if (lesson.difficultyLevel) metadata.push(`üìä ${lesson.difficultyLevel}`);
                            if (lesson.assessmentType && lesson.assessmentType !== 'None') metadata.push(`‚úÖ ${lesson.assessmentType}`);

                            if (metadata.length > 0) {
                                output += metadata.join(' ‚Ä¢ ') + '\n\n';
                            }

                            // Learning objectives
                            if (lesson.learningObjectives) {
                                output += `**Learning Objectives:**\n${lesson.learningObjectives}\n\n`;
                            }

                            // Lesson description
                            if (lesson.description) {
                                output += `**Lesson Content:**\n${lesson.description}\n\n`;
                            }

                            // Prerequisites
                            if (lesson.prerequisites) {
                                output += `**Prerequisites:** ${lesson.prerequisites}\n\n`;
                            }

                            // Resources
                            if (lesson.resourcesNeeded) {
                                output += `**Resources Needed:** ${lesson.resourcesNeeded}\n\n`;
                            }

                            // Activities/exercises
                            if (lesson.children && lesson.children.length > 0) {
                                output += `**Activities & Exercises:**\n`;
                                lesson.children.forEach((activity, aIdx) => {
                                    output += `${aIdx + 1}. ${activity.name}`;
                                    if (activity.duration) {
                                        output += ` (${activity.duration})`;
                                    }
                                    if (activity.description) {
                                        output += `\n   ${activity.description}`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (lesson.dependencies && lesson.dependencies.length > 0) {
                                output += `**‚ö†Ô∏è Requires Completion Of:** ${lesson.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Course Development Recommendations
            output += `## üéØ Course Development Strategy\n\n`;
            output += `**Instructional Design Checklist:**\n`;
            output += `1. Learning Objectives: Each lesson has clear, measurable outcomes\n`;
            output += `2. Scaffolding: Concepts build progressively from simple to complex\n`;
            output += `3. Active Learning: Mix of theory, practice, and assessment\n`;
            output += `4. Engagement: Vary content types (video, text, interactive, projects)\n`;
            output += `5. Assessment: Regular checkpoints to verify understanding\n\n`;

            output += `**Course Quality Standards:**\n`;
            output += `- Lesson Length: Keep videos 10-20 minutes for optimal retention\n`;
            output += `- Practice Ratio: 70% practice, 30% theory for skill-based courses\n`;
            output += `- Assessment Frequency: Quiz or exercise every 3-4 lessons\n`;
            output += `- Resource Quality: Provide downloadable templates, cheat sheets, references\n`;
            output += `- Community: Discussion forums or peer review for social learning\n\n`;

            output += `**Production Planning:**\n`;
            const avgLessonTime = Math.round(totalDuration / totalLessons);
            const videoHours = Math.ceil(totalHours * 2); // 2:1 production ratio
            output += `- Video Production Time: ~${videoHours} hours (2:1 ratio for recording/editing)\n`;
            output += `- Script Writing: ~2 hours per lesson (${totalLessons * 2} hours total)\n`;
            output += `- Assessment Creation: ~1 hour per quiz/exercise\n`;
            output += `- Platform Setup: LMS configuration, student enrollment, progress tracking\n\n`;

            output += `---\n\n`;
            output += `**üí° AI Prompt Usage - Course Deliverables:**\n`;
            output += `\n`;
            output += `**For Content Creation:**\n`;
            output += `- "Write a detailed lesson script for [lesson name] covering [learning objectives]"\n`;
            output += `- "Create 10 multiple-choice quiz questions for [module] with explanations"\n`;
            output += `- "Design a hands-on project assignment for [topic] with rubric"\n`;
            output += `- "Generate practice exercises with solutions for [concept]"\n\n`;
            output += `**For Course Materials:**\n`;
            output += `- "Create a 1-page cheat sheet summarizing [module] key concepts"\n`;
            output += `- "Write downloadable PDF guide for [technical skill] with examples"\n`;
            output += `- "Design flashcards for memorizing [terminology/concepts]"\n`;
            output += `- "Generate code templates/starter files for [programming lesson]"\n\n`;
            output += `**For Marketing & Launch:**\n`;
            output += `- "Write compelling course description highlighting unique value (300 words)"\n`;
            output += `- "Create course landing page copy with benefits, outcomes, testimonials"\n`;
            output += `- "Generate lesson previews and free samples to attract students"\n`;
            output += `- "Draft email sequence for course launch (5 emails over 2 weeks)"\n\n`;
            output += `**For Student Support:**\n`;
            output += `- "Create FAQ document answering common student questions"\n`;
            output += `- "Write discussion prompts for community engagement in forums"\n`;
            output += `- "Generate personalized feedback templates for assignment reviews"\n\n`;

            return output;
        }

        // Generate Academic Thesis prompt (manuscript-ready, scholarly)
        function generateThesisPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'üéì'} ${tree.name || 'Thesis'}\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Calculate manuscript metrics
            let totalWordCount = 0;
            let targetWordCount = 0;
            let totalChapters = 0;
            const chapterMetrics = [];

            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.type === 'phase' && chapter.items) {
                        let chapterWords = 0;
                        let chapterTarget = 0;
                        let sectionCount = chapter.items.length;

                        chapter.items.forEach(section => {
                            chapterWords += section.wordCount || 0;
                            chapterTarget += section.targetWordCount || 0;
                        });

                        chapterMetrics.push({
                            name: chapter.name || `Chapter ${chapter.phase + 1}`,
                            subtitle: chapter.subtitle,
                            current: chapterWords,
                            target: chapterTarget,
                            sections: sectionCount,
                            progress: chapterTarget > 0 ? Math.round((chapterWords / chapterTarget) * 100) : 0
                        });

                        totalWordCount += chapterWords;
                        targetWordCount += chapterTarget;
                        totalChapters++;
                    }
                });
            }

            const overallProgress = targetWordCount > 0 ? Math.round((totalWordCount / targetWordCount) * 100) : 0;

            // Document Metadata
            output += `## üìÑ Document Metadata\n\n`;
            output += `**Manuscript Status:**\n`;
            output += `- Current Length: ${totalWordCount.toLocaleString()} words\n`;
            output += `- Target Length: ${targetWordCount.toLocaleString()} words\n`;
            output += `- Completion: ${overallProgress}% (${totalWordCount}/${targetWordCount})\n`;
            output += `- Structure: ${totalChapters} chapters across ${pattern.levels.phase}\n`;
            output += `- Average Chapter: ${Math.round(totalWordCount / totalChapters).toLocaleString()} words\n\n`;

            // Chapter Breakdown with Progress
            output += `## üìö Chapter Structure\n\n`;
            chapterMetrics.forEach((ch, idx) => {
                const progressBar = '‚ñà'.repeat(Math.floor(ch.progress / 10)) + '‚ñë'.repeat(10 - Math.floor(ch.progress / 10));
                output += `### ${ch.name}${ch.subtitle ? ` ‚Äî ${ch.subtitle}` : ''}\n`;
                output += `- Progress: [${progressBar}] ${ch.progress}%\n`;
                output += `- Word Count: ${ch.current.toLocaleString()} / ${ch.target.toLocaleString()} words\n`;
                output += `- Sections: ${ch.sections}\n\n`;
            });

            // Chapter Details
            output += `---\n\n## üìñ Detailed Chapter Content\n\n`;

            if (tree.children) {
                tree.children.forEach((chapter, chIdx) => {
                    if (chapter.type === 'phase' && chapter.items && chapter.items.length > 0) {
                        output += `### ${chapter.name || `Chapter ${chIdx + 1}`}${chapter.subtitle ? ` ‚Äî ${chapter.subtitle}` : ''}\n\n`;

                        chapter.items.forEach((section, sIdx) => {
                            output += `#### ${sIdx + 1}. ${section.name}\n\n`;

                            // Section metadata
                            if (section.keyArgument) {
                                output += `**Central Argument:**\n`;
                                output += `${section.keyArgument}\n\n`;
                            }

                            if (section.description) {
                                output += `**Section Overview:**\n`;
                                output += `${section.description}\n\n`;
                            }

                            // Evidence & Methodology
                            const hasMethodology = section.evidenceType || section.citations;
                            if (hasMethodology) {
                                output += `**Evidence & Methods:**\n`;
                                if (section.evidenceType) {
                                    output += `- Evidence Type: ${section.evidenceType}\n`;
                                }
                                if (section.citations) {
                                    output += `- Key Citations: ${section.citations}\n`;
                                }
                                output += `\n`;
                            }

                            // Writing Progress
                            if (section.wordCount !== undefined || section.targetWordCount) {
                                const sectionProgress = section.targetWordCount > 0 ? Math.round((section.wordCount || 0) / section.targetWordCount * 100) : 0;
                                output += `**Writing Progress:**\n`;
                                output += `- Current: ${section.wordCount || 0} words\n`;
                                output += `- Target: ${section.targetWordCount || 'TBD'} words\n`;
                                output += `- Status: ${sectionProgress}% complete`;
                                if (section.draftStatus) {
                                    output += ` (${section.draftStatus})`;
                                }
                                output += `\n\n`;
                            }

                            // Subsections/Arguments
                            if (section.children && section.children.length > 0) {
                                output += `**Sub-arguments:**\n`;
                                section.children.forEach((sub, subIdx) => {
                                    output += `${subIdx + 1}. ${sub.name}`;
                                    if (sub.keyArgument) {
                                        output += ` ‚Äî ${sub.keyArgument}`;
                                    }
                                    if (sub.citations) {
                                        output += ` [${sub.citations}]`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (section.dependencies && section.dependencies.length > 0) {
                                output += `**‚ö†Ô∏è Dependencies:** This section builds on: ${section.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Writing Recommendations
            output += `## ‚úçÔ∏è Writing Recommendations\n\n`;
            output += `**Manuscript Completeness:**\n`;
            output += `- Overall Progress: ${overallProgress}% complete\n`;
            if (overallProgress < 50) {
                output += `- Status: Early draft stage ‚Äî focus on completing first drafts of all chapters\n`;
            } else if (overallProgress < 80) {
                output += `- Status: Mid-stage ‚Äî focus on deepening arguments and adding evidence\n`;
            } else {
                output += `- Status: Late stage ‚Äî focus on revision, citations, and cohesion\n`;
            }
            output += `- Remaining: ${(targetWordCount - totalWordCount).toLocaleString()} words to target length\n\n`;

            output += `**Chapter Balance:**\n`;
            const chapterLengths = chapterMetrics.map(ch => ch.current);
            const avgChapter = chapterLengths.reduce((a, b) => a + b, 0) / chapterLengths.length;
            const imbalanced = chapterLengths.filter(len => len < avgChapter * 0.5 || len > avgChapter * 1.5);
            if (imbalanced.length > 0) {
                output += `- ‚ö†Ô∏è ${imbalanced.length} chapter(s) significantly differ from average length\n`;
                output += `- Consider redistributing content or adjusting targets\n`;
            } else {
                output += `- ‚úì Chapters are relatively balanced in length\n`;
            }
            output += `\n`;

            output += `**Academic Quality Checks:**\n`;
            output += `1. Citation Coverage: Ensure each major claim has 2-3 supporting citations\n`;
            output += `2. Argument Coherence: Check logical flow within and between chapters\n`;
            output += `3. Evidence Types: Balance theoretical, empirical, and case study evidence\n`;
            output += `4. Literature Gaps: Identify missing perspectives or counter-arguments\n`;
            output += `5. Methodological Rigor: Document methods, limitations, and validity\n\n`;

            output += `**Next Steps:**\n`;
            const incompleteSections = [];
            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.items) {
                        chapter.items.forEach(section => {
                            if (!section.wordCount || section.wordCount < (section.targetWordCount || 0) * 0.5) {
                                incompleteSections.push(section.name);
                            }
                        });
                    }
                });
            }
            if (incompleteSections.length > 0) {
                output += `- Priority: Complete ${incompleteSections.length} under-developed section(s)\n`;
                output += `- Focus areas: ${incompleteSections.slice(0, 3).join(', ')}${incompleteSections.length > 3 ? '...' : ''}\n`;
            }
            output += `- Review: Get feedback from advisors on completed chapters\n`;
            output += `- Citations: Update and complete bibliography\n`;
            output += `- Editing: Professional copyediting for polished sections\n\n`;

            output += `---\n\n`;
            output += `**üí° AI Prompt Usage:** This academic manuscript can be used to:\n`;
            output += `- Ask AI to critique arguments and suggest counter-arguments\n`;
            output += `- Generate literature review summaries for each chapter\n`;
            output += `- Draft section transitions and chapter conclusions\n`;
            output += `- Suggest additional citations based on argument types\n`;
            output += `- Create visual abstracts and conference presentations\n`;
            output += `- Identify methodological weaknesses and suggest improvements\n`;
            output += `- Generate research questions for future studies\n\n`;

            return output;
        }

        // Generate Sales Pipeline prompt (executive-ready, action-oriented)
        function generateSalesPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'üíº'} ${tree.name || 'Sales Pipeline'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate pipeline metrics
            let totalPipelineValue = 0;
            let weightedPipelineValue = 0;
            let totalDeals = 0;
            const quarterMetrics = [];

            if (tree.children) {
                tree.children.forEach(quarter => {
                    if (quarter.type === 'phase' && quarter.items) {
                        let quarterTotal = 0;
                        let quarterWeighted = 0;
                        let quarterDeals = quarter.items.length;

                        quarter.items.forEach(deal => {
                            const dealValue = deal.dealValue || 0;
                            const probability = deal.stageProbability || deal.probability || 0;

                            quarterTotal += dealValue;
                            quarterWeighted += (dealValue * probability / 100);
                        });

                        quarterMetrics.push({
                            name: quarter.name || `Quarter ${quarter.phase + 1}`,
                            subtitle: quarter.subtitle,
                            total: quarterTotal,
                            weighted: quarterWeighted,
                            deals: quarterDeals
                        });

                        totalPipelineValue += quarterTotal;
                        weightedPipelineValue += quarterWeighted;
                        totalDeals += quarterDeals;
                    }
                });
            }

            // Executive Summary
            output += `## üìä Executive Summary\n\n`;
            output += `**Pipeline Health:**\n`;
            output += `- Total Pipeline Value: $${totalPipelineValue.toLocaleString()}\n`;
            output += `- Weighted Pipeline (Probability Adjusted): $${Math.round(weightedPipelineValue).toLocaleString()}\n`;
            output += `- Total Active Deals: ${totalDeals}\n`;
            output += `- Average Deal Size: $${Math.round(totalPipelineValue / totalDeals).toLocaleString()}\n`;
            output += `- Weighted Close Rate: ${Math.round(weightedPipelineValue / totalPipelineValue * 100)}%\n\n`;

            // Quarterly Breakdown
            output += `## üìÖ Quarterly Breakdown\n\n`;
            quarterMetrics.forEach((q, idx) => {
                output += `### ${q.name}${q.subtitle ? ` - ${q.subtitle}` : ''}\n`;
                output += `- Pipeline: $${q.total.toLocaleString()} (${q.deals} deals)\n`;
                output += `- Expected Revenue: $${Math.round(q.weighted).toLocaleString()}\n`;
                output += `- Conversion Confidence: ${Math.round(q.weighted / q.total * 100)}%\n\n`;
            });

            // Deal Details by Quarter
            output += `---\n\n## üíº Deal Pipeline\n\n`;

            if (tree.children) {
                tree.children.forEach((quarter, qIdx) => {
                    if (quarter.type === 'phase' && quarter.items && quarter.items.length > 0) {
                        output += `### ${quarter.name || `Quarter ${qIdx + 1}`}\n\n`;

                        quarter.items.forEach((deal, dIdx) => {
                            const dealValue = deal.dealValue || 0;
                            const probability = deal.stageProbability || deal.probability || 0;
                            const expectedRevenue = Math.round(dealValue * probability / 100);

                            output += `#### ${dIdx + 1}. ${deal.name}\n\n`;

                            // Deal metrics bar
                            output += `**Deal Snapshot:**\n`;
                            output += `- üí∞ Value: $${dealValue.toLocaleString()}\n`;
                            output += `- üìä Probability: ${probability}%\n`;
                            output += `- üíµ Expected Revenue: $${expectedRevenue.toLocaleString()}\n`;
                            if (deal.expectedCloseDate || deal.expectedClose) {
                                output += `- üìÖ Target Close: ${deal.expectedCloseDate || deal.expectedClose}\n`;
                            }
                            if (deal.accountExecutive) {
                                output += `- üë§ Account Executive: ${deal.accountExecutive}\n`;
                            }
                            if (deal.itemType) {
                                const typeLabel = pattern.types.find(t => t.value === deal.itemType)?.label || deal.itemType;
                                output += `- üè∑Ô∏è Deal Type: ${typeLabel}\n`;
                            }
                            if (deal.status) {
                                output += `- üìç Status: ${deal.status}\n`;
                            }
                            if (deal.leadTime) {
                                output += `- ‚è±Ô∏è Sales Cycle: ${deal.leadTime}\n`;
                            }
                            output += `\n`;

                            if (deal.description) {
                                output += `**Overview:**\n${deal.description}\n\n`;
                            }

                            // Action items / Next steps
                            if (deal.children && deal.children.length > 0) {
                                output += `**Action Items:**\n`;
                                deal.children.forEach((action, aIdx) => {
                                    output += `${aIdx + 1}. **${action.name}**\n`;
                                    if (action.description) {
                                        output += `   ${action.description}\n`;
                                    }
                                    if (action.expectedClose || action.expectedCloseDate) {
                                        output += `   _Due: ${action.expectedClose || action.expectedCloseDate}_\n`;
                                    }
                                    if (action.dependencies && action.dependencies.length > 0) {
                                        output += `   _Depends on: ${action.dependencies.join(', ')}_\n`;
                                    }
                                    output += `\n`;
                                });
                            }

                            // Competitive intelligence
                            if (deal.competitorInfo) {
                                output += `**üéØ Competitive Landscape:**\n${deal.competitorInfo}\n\n`;
                            }

                            // Dependencies/blockers
                            if (deal.dependencies && deal.dependencies.length > 0) {
                                output += `**‚ö†Ô∏è Dependencies:** This deal depends on: ${deal.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Risk Analysis & Recommendations
            output += `## ‚ö†Ô∏è Risk Analysis & Recommendations\n\n`;
            output += `**Pipeline Coverage:**\n`;
            const averageCloseRate = Math.round(weightedPipelineValue / totalPipelineValue * 100);
            output += `- Current weighted close rate: ${averageCloseRate}%\n`;
            output += `- To hit 100% of targets, maintain ${Math.round(100 / averageCloseRate)}x pipeline coverage\n`;
            output += `- Low-probability deals (<50%): Focus on advancing or disqualifying quickly\n`;
            output += `- High-value deals (>$500K): Ensure executive sponsorship and multi-threading\n\n`;

            output += `**Key Actions:**\n`;
            output += `1. Accelerate deals in late stages (>70% probability) to close within quarter\n`;
            output += `2. Qualify out deals stuck in discovery for >2 months\n`;
            output += `3. Build relationships with economic buyers, not just champions\n`;
            output += `4. Document competitive wins and losses for pattern analysis\n`;
            output += `5. Request customer references from recent wins for social proof\n\n`;

            output += `---\n\n`;
            output += `**üí° AI Prompt Usage:** This sales pipeline can be used to:\n`;
            output += `- Ask AI to analyze deal health and suggest next best actions\n`;
            output += `- Generate sales enablement materials (case studies, proposals, ROI calculators)\n`;
            output += `- Forecast quarterly revenue with Monte Carlo simulations\n`;
            output += `- Identify at-risk deals based on activity patterns\n`;
            output += `- Draft personalized executive emails for each stakeholder\n`;
            output += `- Create competitive battlecards from competitorInfo fields\n\n`;

            return output;
        }

        // Generate Philosophy prompts (executable, professional)
        function generatePhilosophyPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ü§î'} ${tree.name || 'Philosophical Argument'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            output += `**Professional Philosophy Prompt** - Copy-paste ready for Claude/GPT-4\n\n`;
            output += `---\n\n`;

            // Collect all arguments
            const allArguments = [];
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach(item => {
                            allArguments.push({
                                ...item,
                                phaseName: phase.name,
                                phaseSubtitle: phase.subtitle
                            });
                        });
                    }
                });
            }

            if (allArguments.length === 0) {
                output += `*No arguments defined yet. Add items to your tree.*\n`;
                return output;
            }

            // Detect speakers and dialogue partners
            const speakers = [...new Set(allArguments.map(a => a.speaker).filter(s => s))];
            const primarySpeaker = speakers[0] || 'The Philosopher';
            const isDialogue = speakers.length > 1;

            // SYNTHESIZE: Create professional philosophical prompt

            // 1. CONTEXT & ROLE
            output += `## üìö Context\n\n`;
            output += `This is a ${isDialogue ? 'philosophical dialogue' : 'structured argument'} `;
            if (speakers.length > 0) {
                output += `featuring ${speakers.join(', ')}. `;
            }
            output += `The argument progresses through ${tree.children.length} major movements with ${allArguments.length} distinct claims.\n\n`;

            // 2. MAIN PROMPT
            output += `## üí≠ Your Task\n\n`;
            output += `You are a philosophy professor preparing a comprehensive critical analysis. Write a 2500-word essay that:\n\n`;

            output += `**1. Reconstructs the Argument**\n`;
            output += `- Present each major claim in logical order\n`;
            output += `- Identify premises, inferences, and conclusions\n`;
            output += `- Map the dependency structure (which claims build on others)\n\n`;

            output += `**2. Evaluates Logical Validity**\n`;
            output += `- Are the inferences sound?\n`;
            output += `- Do the conclusions follow from the premises?\n`;
            output += `- What hidden assumptions are made?\n`;
            output += `- Are there logical fallacies?\n\n`;

            output += `**3. Engages Philosophically**\n`;
            output += `- What are the strongest objections to this view?\n`;
            output += `- How might the author respond?\n`;
            output += `- What implications does this have for ethics, epistemology, or metaphysics?\n`;
            output += `- How does this compare to contemporary philosophical positions?\n\n`;

            output += `**4. Applies to Modern Context**\n`;
            output += `- What modern issues does this illuminate?\n`;
            output += `- How would this argument address current debates?\n`;
            output += `- Is this view still defensible today? Why or why not?\n\n`;

            // 3. THE ARGUMENT STRUCTURE (as reference)
            output += `---\n\n`;
            output += `## üìñ The Argument Structure\n\n`;
            output += `Use this as your reference material for the analysis above:\n\n`;

            tree.children.forEach((phase, phaseIdx) => {
                output += `### ${phase.name}\n`;
                if (phase.subtitle) {
                    output += `*${phase.subtitle}*\n`;
                }
                output += `\n`;

                if (phase.items && phase.items.length > 0) {
                    phase.items.forEach((item, itemIdx) => {
                        output += `**Argument ${phaseIdx + 1}.${itemIdx + 1}: ${item.name}**\n\n`;

                        if (item.description) {
                            output += `${item.description}\n\n`;
                        }

                        // Build structured argument info
                        const argDetails = [];

                        if (item.speaker) argDetails.push(`*Speaker*: ${item.speaker}`);
                        if (item.argumentType) argDetails.push(`*Type*: ${item.argumentType}`);
                        if (item.keyTerms) argDetails.push(`*Key Terms*: ${item.keyTerms}`);

                        if (argDetails.length > 0) {
                            output += argDetails.join(' ‚Ä¢ ') + '\n\n';
                        }

                        // Premises and conclusion in structured format
                        if (item.premise1 || item.premise2 || item.conclusion) {
                            output += `<argument>\n`;
                            if (item.premise1) output += `**P1**: ${item.premise1}\n\n`;
                            if (item.premise2) output += `**P2**: ${item.premise2}\n\n`;
                            if (item.premise3) output += `**P3**: ${item.premise3}\n\n`;
                            if (item.conclusion) output += `**‚à¥**: ${item.conclusion}\n`;
                            output += `</argument>\n\n`;
                        }

                        // Dependencies
                        if (item.dependencies && item.dependencies.length > 0) {
                            output += `*Builds on*: ${item.dependencies.join(', ')}\n\n`;
                        }

                        // Subtasks as supporting points
                        if (item.subtasks && item.subtasks.length > 0) {
                            output += `*Supporting points*:\n`;
                            item.subtasks.forEach(sub => {
                                output += `- ${sub.name}`;
                                if (sub.description) output += `: ${sub.description}`;
                                output += `\n`;
                            });
                            output += `\n`;
                        }
                    });
                }
            });

            // 4. OUTPUT STRUCTURE
            output += `---\n\n`;
            output += `## ‚úçÔ∏è Essay Structure\n\n`;
            output += `Your 2500-word analysis should follow this structure:\n\n`;
            output += `**Introduction (300 words)**\n`;
            output += `- Introduce the philosophical problem\n`;
            output += `- State the main thesis being examined\n`;
            output += `- Preview your analytical approach\n\n`;

            output += `**Part I: Argument Reconstruction (600 words)**\n`;
            output += `- Present the argument structure clearly\n`;
            output += `- Identify all major premises and conclusions\n`;
            output += `- Map the logical flow and dependencies\n\n`;

            output += `**Part II: Logical Analysis (500 words)**\n`;
            output += `- Evaluate validity and soundness\n`;
            output += `- Identify hidden assumptions\n`;
            output += `- Note any fallacies or weak inferences\n\n`;

            output += `**Part III: Philosophical Engagement (600 words)**\n`;
            output += `- Present strongest objections\n`;
            output += `- Consider author's possible responses\n`;
            output += `- Discuss broader philosophical implications\n\n`;

            output += `**Part IV: Modern Application (400 words)**\n`;
            output += `- Connect to contemporary issues\n`;
            output += `- Assess relevance and defensibility today\n`;
            output += `- Suggest modifications or extensions\n\n`;

            output += `**Conclusion (100 words)**\n`;
            output += `- Summarize your analysis\n`;
            output += `- State your final evaluation of the argument\n\n`;

            // 5. EVALUATION CRITERIA
            output += `---\n\n`;
            output += `## ‚úì Success Criteria\n\n`;
            output += `Your essay should demonstrate:\n`;
            output += `- ‚úÖ Accurate reconstruction of all ${allArguments.length} arguments\n`;
            output += `- ‚úÖ Rigorous logical analysis using formal/informal logic\n`;
            output += `- ‚úÖ Engagement with key philosophical concepts: ${getKeyTerms(allArguments)}\n`;
            output += `- ‚úÖ Awareness of relevant philosophical traditions and debates\n`;
            output += `- ‚úÖ Clear, precise philosophical writing (avoid vagueness)\n`;
            output += `- ‚úÖ Fair-minded treatment (steel man, not straw man objections)\n`;
            output += `- ‚úÖ Creative application to modern contexts\n`;
            output += `- ‚úÖ Original insights, not mere summary\n\n`;

            // 6. ALTERNATIVE PROMPT MODES
            output += `---\n\n`;
            output += `## üîÑ Alternative Prompt Modes\n\n`;

            if (isDialogue) {
                output += `**Mode 1: Continue the Dialogue**\n`;
                output += `\`\`\`\n`;
                output += `You are responding to ${primarySpeaker}'s arguments. Write a philosophical `;
                output += `dialogue where you (as an interlocutor) raise 3 sophisticated objections, `;
                output += `then have ${primarySpeaker} respond to each. Use the Socratic method `;
                output += `of questioning to probe deeper.\n`;
                output += `\`\`\`\n\n`;
            }

            output += `**Mode 2: Compare to Another Philosopher**\n`;
            output += `\`\`\`\n`;
            output += `Compare this argument to [Kant/Nietzsche/Rawls/Singer]. How would [philosopher] `;
            output += `respond to these claims? Where would they agree/disagree and why? What synthesis `;
            output += `might be possible between the two views?\n`;
            output += `\`\`\`\n\n`;

            output += `**Mode 3: Logical Formalization**\n`;
            output += `\`\`\`\n`;
            output += `Formalize this argument using predicate logic. Translate each premise and `;
            output += `conclusion into logical notation (‚àÄ, ‚àÉ, ‚Üí, ‚Üî, ¬¨, ‚àß, ‚à®). Prove validity using `;
            output += `natural deduction or truth tables. Identify which premises, if any, are dubious.\n`;
            output += `\`\`\`\n\n`;

            output += `**Mode 4: Teaching Guide**\n`;
            output += `\`\`\`\n`;
            output += `Create a teaching guide for undergraduate philosophy students. Include: `;
            output += `(1) Pre-reading questions, (2) Key concepts glossary, (3) Discussion prompts, `;
            output += `(4) Thought experiments to test understanding, (5) Essay topics.\n`;
            output += `\`\`\`\n\n`;

            // 7. PHILOSOPHICAL CONTEXT
            if (allArguments.some(a => a.argumentType)) {
                output += `---\n\n`;
                output += `## üéì Philosophical Methods Used\n\n`;
                const argTypes = [...new Set(allArguments.map(a => a.argumentType).filter(t => t))];
                argTypes.forEach(type => {
                    const count = allArguments.filter(a => a.argumentType === type).length;
                    output += `- **${type}** (${count} argument${count > 1 ? 's' : ''})\n`;
                });
                output += `\n`;
            }

            return output;
        }

        // Helper: Extract key terms for Philosophy prompt
        function getKeyTerms(arguments) {
            const allTerms = arguments
                .map(a => a.keyTerms)
                .filter(t => t)
                .join(', ')
                .split(',')
                .map(t => t.trim())
                .filter(t => t.length > 0);

            // Get unique terms, limit to top 8
            const uniqueTerms = [...new Set(allTerms)].slice(0, 8);
            return uniqueTerms.join(', ');
        }

        // Generate generic prompt format
        function generateGenericPrompt(tree, pattern) {
            // SPECIAL CASE: AI Video Production uses different format
            if (currentPattern === 'film') {
                return generateAIVideoPrompts(tree, pattern);
            }

            // SPECIAL CASE: Philosophy uses different format
            if (currentPattern === 'philosophy') {
                return generatePhilosophyPrompt(tree, pattern);
            }

            // SPECIAL CASE: Sales Pipeline uses different format
            if (currentPattern === 'sales') {
                return generateSalesPrompt(tree, pattern);
            }

            // SPECIAL CASE: Thesis/Academic uses different format
            if (currentPattern === 'thesis') {
                return generateThesisPrompt(tree, pattern);
            }

            // SPECIAL CASE: Product Roadmap uses different format
            if (currentPattern === 'roadmap') {
                return generateRoadmapPrompt(tree, pattern);
            }

            // SPECIAL CASE: Book/Novel uses different format
            if (currentPattern === 'book') {
                return generateBookPrompt(tree, pattern);
            }

            // SPECIAL CASE: Course/Training uses different format
            if (currentPattern === 'course') {
                return generateCoursePrompt(tree, pattern);
            }

            let prompt = `# ${tree.icon || 'üìã'} ${tree.name || 'Project'}\n\n`;

            if (tree.description) {
                prompt += `${tree.description}\n\n`;
            }

            prompt += `---\n\n`;

            // Introduction based on pattern
            const patternIntros = {
                'sales': `You are a sales analyst. Follow this structured sales pipeline analysis:`,
                'thesis': `You are an academic advisor. Follow this thesis structure:`,
                'roadmap': `You are a product manager. Follow this product roadmap:`,
                'book': `You are a writing coach. Follow this book structure:`,
                'event': `You are an event planner. Follow this event plan:`,
                'fitness': `You are a fitness coach. Follow this training program:`,
                'strategy': `You are a business strategist. Follow this strategic plan:`,
                'course': `You are an educator. Follow this course structure:`,
                'philosophy': `You are a philosophy scholar. Follow this philosophical argument:`,
                'familytree': `You are a genealogist. Follow this family tree structure:`,
                'generic': `Follow this structured workflow:`
            };

            prompt += `${patternIntros[currentPattern] || patternIntros['generic']}\n\n`;

            // Process each phase
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    prompt += `## ${pattern.levels.phase} ${phaseIdx + 1}: ${phase.name}\n`;
                    if (phase.subtitle) {
                        prompt += `*${phase.subtitle}*\n`;
                    }
                    prompt += `\n`;

                    // Add items
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            prompt += `### ${itemIdx + 1}. ${item.name}\n`;

                            if (item.description) {
                                prompt += `${item.description}\n`;
                            }

                            // Add ALL pattern-specific fields dynamically
                            prompt += `\n`;
                            if (pattern.fields) {
                                Object.keys(pattern.fields).forEach(fieldKey => {
                                    const fieldConfig = pattern.fields[fieldKey];

                                    // Skip non-field properties
                                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                                        return;
                                    }

                                    const value = item[fieldKey];
                                    if (value !== undefined && value !== null && value !== '') {
                                        let displayValue = value;

                                        // Format based on field type
                                        if (fieldConfig.type === 'number') {
                                            if (fieldKey === 'cost' || fieldKey === 'dealValue') {
                                                displayValue = formatCost(value);
                                            } else {
                                                displayValue = value;
                                            }
                                        } else if (fieldConfig.type === 'date') {
                                            displayValue = new Date(value).toLocaleDateString();
                                        }

                                        prompt += `- **${fieldConfig.label}**: ${displayValue}\n`;
                                    }
                                });
                            }

                            // Add dependencies
                            if (item.dependencies && item.dependencies.length > 0) {
                                const deps = Array.isArray(item.dependencies) ? item.dependencies.join(', ') : item.dependencies;
                                prompt += `- **Dependencies**: ${deps}\n`;
                            }

                            // Add PM tracking fields if present
                            if (item.pmStatus) prompt += `- **Status**: ${item.pmStatus}\n`;
                            if (item.pmAssignee) prompt += `- **Assignee**: ${item.pmAssignee}\n`;
                            if (item.pmProgress !== undefined) prompt += `- **Progress**: ${item.pmProgress}%\n`;
                            if (item.pmPriority) prompt += `- **Priority**: ${item.pmPriority}\n`;
                            if (item.pmDueDate) prompt += `- **Due Date**: ${new Date(item.pmDueDate).toLocaleDateString()}\n`;

                            // Add subtasks
                            if (item.subtasks && item.subtasks.length > 0) {
                                prompt += `\nAction steps:\n`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    prompt += `${subIdx + 1}. ${subtask.name}`;
                                    if (subtask.description) {
                                        prompt += `: ${subtask.description}`;
                                    }
                                    // Add subtask PM tracking if present
                                    const pmInfo = [];
                                    if (subtask.pmStatus) pmInfo.push(`Status: ${subtask.pmStatus}`);
                                    if (subtask.pmAssignee) pmInfo.push(`Assignee: ${subtask.pmAssignee}`);
                                    if (subtask.pmProgress !== undefined) pmInfo.push(`${subtask.pmProgress}%`);
                                    if (pmInfo.length > 0) {
                                        prompt += ` [${pmInfo.join(', ')}]`;
                                    }
                                    prompt += `\n`;
                                });
                            }

                            prompt += `\n`;
                        });
                    }

                    prompt += `\n`;
                });
            }

            // Footer
            prompt += `---\n\n`;
            prompt += `Provide a comprehensive response following this structure, addressing each ${pattern.levels.phase.toLowerCase()} and ${pattern.levels.item.toLowerCase()} systematically.\n`;

            return prompt;
        }

        // AI Modal - Overall Project Analysis (Dynamic AI-Generated)
        document.getElementById('ai-btn').addEventListener('click', async () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;

            document.getElementById('modal-title').textContent = `‚ú® ${pattern.name} Analysis`;

            // Count items by phase
            function countItems(node, counts = {p0: 0, p1: 0, p2: 0}) {
                if (node.items && node.phase !== undefined) {
                    counts[`p${node.phase}`] += node.items.length;
                }
                if (node.children) {
                    node.children.forEach(child => countItems(child, counts));
                }
                return counts;
            }

            const itemCounts = countItems(capexTree);

            // Pattern-aware summary cards
            let summaryHTML = '';

            // For financial patterns (generic, sales, roadmap, strategy)
            if (pattern.fields && pattern.fields.cost) {
                const totalCost = calculateTotal(capexTree);
                const getPhaseCost = (phaseId) => {
                    const phase = findNode(phaseId);
                    return phase ? calculatePhaseTotal(phase) : 0;
                };

                const phase0Cost = getPhaseCost('phase-0');
                const phase1Cost = getPhaseCost('phase-1');
                const phase2Cost = getPhaseCost('phase-2');

                summaryHTML = `
                    <div style="background: linear-gradient(135deg, var(--treeplex-primary), #009977); color: white; padding: 24px; border-radius: 12px; margin-bottom: 24px;">
                        <h2 style="margin-bottom: 8px; font-size: 32px;">${formatCost(totalCost)}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Total Project Investment</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-0);">
                            <div style="font-size: 11px; font-weight: 600; color: #2e7d32; margin-bottom: 4px;">${levels.phase.toUpperCase()} 1</div>
                            <div style="font-size: 20px; font-weight: 700; color: #1b5e20; margin-bottom: 4px;">${formatCost(phase0Cost)}</div>
                            <div style="font-size: 12px; color: #2e7d32;">${itemCounts.p0} ${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-1);">
                            <div style="font-size: 11px; font-weight: 600; color: #1565c0; margin-bottom: 4px;">${levels.phase.toUpperCase()} 2</div>
                            <div style="font-size: 20px; font-weight: 700; color: #0d47a1; margin-bottom: 4px;">${formatCost(phase1Cost)}</div>
                            <div style="font-size: 12px; color: #1565c0;">${itemCounts.p1} ${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #fff3e0; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-2);">
                            <div style="font-size: 11px; font-weight: 600; color: #e65100; margin-bottom: 4px;">${levels.phase.toUpperCase()} 3</div>
                            <div style="font-size: 20px; font-weight: 700; color: #bf360c; margin-bottom: 4px;">${formatCost(phase2Cost)}</div>
                            <div style="font-size: 12px; color: #e65100;">${itemCounts.p2} ${levels.item.toLowerCase()}s</div>
                        </div>
                    </div>`;
            } else {
                // For non-financial patterns (AI Prompt Design, Philosophy, etc.)
                const totalItems = itemCounts.p0 + itemCounts.p1 + itemCounts.p2;
                const totalSubtasks = capexTree.children?.reduce((acc, phase) => {
                    return acc + (phase.items?.reduce((itemAcc, item) => {
                        return itemAcc + (item.subtasks?.length || 0);
                    }, 0) || 0);
                }, 0) || 0;

                summaryHTML = `
                    <div style="background: linear-gradient(135deg, var(--treeplex-primary), #8b5cf6); color: white; padding: 24px; border-radius: 12px; margin-bottom: 24px;">
                        <h2 style="margin-bottom: 8px; font-size: 32px;">${pattern.icon} ${capexTree.name || pattern.levels.root}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">${capexTree.children?.length || 0} ${levels.phase}s ‚Ä¢ ${totalItems} ${levels.item}s ‚Ä¢ ${totalSubtasks} ${levels.subtask}s</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-0);">
                            <div style="font-size: 11px; font-weight: 600; color: #2e7d32; margin-bottom: 4px;">${levels.phase.toUpperCase()} 1</div>
                            <div style="font-size: 20px; font-weight: 700; color: #1b5e20; margin-bottom: 4px;">${itemCounts.p0}</div>
                            <div style="font-size: 12px; color: #2e7d32;">${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-1);">
                            <div style="font-size: 11px; font-weight: 600; color: #1565c0; margin-bottom: 4px;">${levels.phase.toUpperCase()} 2</div>
                            <div style="font-size: 20px; font-weight: 700; color: #0d47a1; margin-bottom: 4px;">${itemCounts.p1}</div>
                            <div style="font-size: 12px; color: #1565c0;">${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #fff3e0; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-2);">
                            <div style="font-size: 11px; font-weight: 600; color: #e65100; margin-bottom: 4px;">${levels.phase.toUpperCase()} 3</div>
                            <div style="font-size: 20px; font-weight: 700; color: #bf360c; margin-bottom: 4px;">${itemCounts.p2}</div>
                            <div style="font-size: 12px; color: #e65100;">${levels.item.toLowerCase()}s</div>
                        </div>
                    </div>`;
            }

            // Show summary + loading state for AI analysis
            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    ${summaryHTML}

                    <div id="ai-analysis-loading" style="padding: 40px; text-align: center; background: var(--card-bg); border-radius: 12px; margin-top: 20px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary); font-size: 14px;">AI is analyzing your ${pattern.name.toLowerCase()}...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Generating insights and recommendations</p>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Call AI to generate the analysis sections dynamically
            console.log('ü§ñ Calling AI analysis at:', AI_CONFIG.apiEndpoint);
            try {
                const aiResponse = await generateAIAnalysis(capexTree, 'project');

                // Replace loading with AI-generated content
                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                        <div style="margin-bottom: 20px;">
                            <div id="ai-generated-content" style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                                <div style="white-space: pre-wrap; font-size: 14px; line-height: 1.8; color: var(--text-primary);">${aiResponse}</div>
                            </div>
                            <div style="margin-top: 16px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ü§ñ Analysis powered by Claude Sonnet ‚Ä¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;
                }

            } catch (error) {
                // Fallback to static analysis when AI is unavailable
                console.warn('AI Analysis unavailable, using static fallback:', error.message);

                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">CRITICAL PATH ANALYSIS</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    ‚Ä¢ <strong>Land acquisition</strong> is the primary gating factor for Phase 1 execution<br>
                                    ‚Ä¢ <strong>Turbine PO deposit</strong> (${formatCost(2000000)}) secures manufacturing capacity for Phase 2<br>
                                    ‚Ä¢ <strong>Pipeline FEED</strong> and permitting run in parallel to optimize timeline<br>
                                    ‚Ä¢ Phase 2 equipment procurement has 12-18 month lead times requiring early commitment
                                </p>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">RISK ASSESSMENT</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    <strong style="color: #d32f2f;">High Risk:</strong> Phase 2 represents ${((phase2Cost/totalCost)*100).toFixed(0)}% of total budget concentrated in equipment and infrastructure.<br>
                                    <strong style="color: #f57c00;">Medium Risk:</strong> Regulatory approvals for land, pipeline, and permitting on critical path.<br>
                                    <strong style="color: #388e3c;">Low Risk:</strong> Phase 0 has manageable capital exposure with assignable land options.
                                </p>
                            </div>

                            <div style="background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); padding: 20px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--treeplex-primary); text-transform: uppercase; letter-spacing: 0.5px;">STRATEGIC RECOMMENDATIONS</h4>
                                <ul style="font-size: 14px; line-height: 2; margin: 0; padding-left: 20px; color: var(--text-primary);">
                                    <li>Secure Phase 0 land option immediately to unlock downstream activities</li>
                                    <li>Negotiate payment milestones tied to regulatory approvals</li>
                                    <li>Consider project financing for Phase 2 to preserve equity</li>
                                    <li>Establish vendor relationships early for long-lead equipment items</li>
                                    <li>Build 10-15% contingency buffer beyond stated ${formatCost(310000)} reserves</li>
                                </ul>
                            </div>
                        </div>
                        <div style="margin-top: 16px; padding: 12px; background: rgba(255, 152, 0, 0.1); border-radius: 6px; text-align: center; border: 1px solid rgba(255, 152, 0, 0.3);">
                            <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                ‚ÑπÔ∏è AI Analysis unavailable ‚Ä¢ Showing static analysis ‚Ä¢ Deploy to Netlify for dynamic AI insights
                            </p>
                        </div>
                    </div>
                `;
                }
            }
        });

        document.getElementById('modal-close').addEventListener('click', () => {
            document.getElementById('modal').style.display = 'none';
        });

        // =============================================================================
        // API KEY CONFIGURATION
        // =============================================================================

        // Show/hide API keys toggle
        document.getElementById('api-key-show').addEventListener('change', (e) => {
            const claudeInput = document.getElementById('claude-api-key-input');
            const geminiInput = document.getElementById('gemini-api-key-input');
            const openaiInput = document.getElementById('openai-api-key-input');
            const inputType = e.target.checked ? 'text' : 'password';
            claudeInput.type = inputType;
            geminiInput.type = inputType;
            openaiInput.type = inputType;
        });

        // Clear all API keys
        document.getElementById('api-key-clear').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all saved API keys? This action cannot be undone.')) {
                clearLocalAPIKey('anthropic');
                clearLocalAPIKey('gemini');
                clearLocalAPIKey('openai');
                document.getElementById('claude-api-key-input').value = '';
                document.getElementById('gemini-api-key-input').value = '';
                document.getElementById('openai-api-key-input').value = '';
                updateKeyStatusBadges();
                console.log('üóëÔ∏è All API keys cleared');
                alert('All API keys have been cleared.');
            }
        });

        // Cancel API key modal
        document.getElementById('api-key-cancel').addEventListener('click', () => {
            document.getElementById('api-key-modal').style.display = 'none';
        });

        document.getElementById('api-key-btn').addEventListener('click', () => {
            showApiKeyModal(true);
        });

        // Unified AI Mode selector
        document.getElementById('unified-ai-mode-select').addEventListener('change', (e) => {
            const newMode = e.target.value;
            const parsed = parseUnifiedMode(newMode);

            // Check if this mode requires an API key
            if (parsed.requiresKey) {
                const provider = parsed.provider;
                const hasKey = getLocalAPIKey(provider);

                if (!hasKey) {
                    // Show helpful message about needing API key
                    const providerName = provider === 'anthropic' ? 'Claude' :
                                       provider === 'gemini' ? 'Gemini' : 'OpenAI';

                    alert(`üîë This mode requires your ${providerName} API key.\n\nPlease click the üîë API Key button to configure your key, then try again.`);

                    // Revert to previous mode
                    const currentMode = getUnifiedAIMode();
                    e.target.value = currentMode;
                    return;
                }
            }

            // Save the new mode
            setUnifiedAIMode(newMode);

            // Show informational message
            console.log(`‚úÖ AI Mode: ${parsed.description}`);

            // Show user-friendly toast
            if (parsed.enabled) {
                const modeLabel = e.target.options[e.target.selectedIndex].text;
                showToast(`‚úÖ AI Mode: ${modeLabel}`);
            } else {
                showToast('‚ùå AI features disabled');
            }
        });

        // Initialize unified AI mode selector on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Attach Canvas view toggle
            const toggleBtn = document.getElementById('toggle-view-mode');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleViewMode);
            }

            // Initialize canvas event listeners
            initializeCanvasEvents();

            // Rebind expand/collapse buttons to use progressive collapse/expand
            // Wait a bit for TreeListy to finish its initialization
            setTimeout(() => {
                const expandBtn = document.getElementById('expand-btn');
                const collapseBtn = document.getElementById('collapse-btn');

                if (expandBtn) {
                    // Remove all existing listeners by cloning the button
                    const newExpandBtn = expandBtn.cloneNode(true);
                    expandBtn.parentNode.replaceChild(newExpandBtn, expandBtn);

                    // Add new listener with progressive expand
                    newExpandBtn.addEventListener('click', () => {
                        console.log('‚¨áÔ∏è Progressive Expand clicked');
                        if (typeof canvasExpandOneLevel === 'function') {
                            canvasExpandOneLevel();
                        }
                    });
                }

                if (collapseBtn) {
                    // Remove all existing listeners by cloning the button
                    const newCollapseBtn = collapseBtn.cloneNode(true);
                    collapseBtn.parentNode.replaceChild(newCollapseBtn, collapseBtn);

                    // Add new listener with progressive collapse
                    newCollapseBtn.addEventListener('click', () => {
                        console.log('‚¨ÜÔ∏è Progressive Collapse clicked');
                        if (typeof canvasCollapseOneLevel === 'function') {
                            canvasCollapseOneLevel();
                        }
                    });
                }
            }, 500);

            // Bind Canvas toolbar buttons
            const autoLayoutSelect = document.getElementById('auto-layout-select');
            const gridToggleBtn = document.getElementById('grid-toggle');
            const resetViewBtn = document.getElementById('reset-view');
            const fitViewBtn = document.getElementById('fit-view');
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');

            if (autoLayoutSelect) {
                autoLayoutSelect.addEventListener('change', (e) => {
                    if (e.target.value) {
                        applyAutoLayout(e.target.value);
                        e.target.value = '';  // Reset to default
                    }
                });
            }

            // Cluster-by selector event listener
            const clusterBySelect = document.getElementById('cluster-by-select');
            if (clusterBySelect) {
                clusterBySelect.addEventListener('change', (e) => {
                    clusterByField = e.target.value;
                    if (clusterByField) {
                        console.log(`Clustering enabled by: ${clusterByField}`);
                        // Re-apply force-directed layout if currently in canvas mode
                        if (viewMode === 'canvas') {
                            applyForceDirectedLayout();
                            renderCanvas();
                        }
                    } else {
                        console.log('Clustering disabled');
                    }
                });
            }

            if (gridToggleBtn) {
                gridToggleBtn.addEventListener('click', toggleGrid);
            }

            if (resetViewBtn) {
                resetViewBtn.addEventListener('click', resetView);
            }

            if (fitViewBtn) {
                fitViewBtn.addEventListener('click', fitToView);
            }

            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    canvasZoom = Math.min(5, canvasZoom * 1.2);
                    updateCanvasTransform();
                });
            }

            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    canvasZoom = Math.max(0.1, canvasZoom / 1.2);
                    updateCanvasTransform();
                });
            }

            const savedMode = getUnifiedAIMode();
            const select = document.getElementById('unified-ai-mode-select');
            if (select) {
                select.value = savedMode;
            }
        });

        // Save API key(s)
        document.getElementById('api-key-save').addEventListener('click', () => {
            const claudeKey = document.getElementById('claude-api-key-input').value.trim();
            const geminiKey = document.getElementById('gemini-api-key-input').value.trim();
            const openaiKey = document.getElementById('openai-api-key-input').value.trim();
            const selectedProvider = document.getElementById('provider-select').value;

            // Validate keys if provided
            if (claudeKey && !claudeKey.startsWith('sk-ant-')) {
                alert('Invalid Claude API key format. Anthropic API keys start with "sk-ant-"');
                return;
            }

            if (geminiKey && !geminiKey.startsWith('AIza')) {
                alert('Invalid Gemini API key format. Google API keys typically start with "AIza"');
                return;
            }

            if (openaiKey && !openaiKey.startsWith('sk-')) {
                alert('Invalid OpenAI API key format. OpenAI API keys start with "sk-"');
                return;
            }

            // Check if selected provider has a key
            if (selectedProvider === 'anthropic' && !claudeKey && !getLocalAPIKey('anthropic')) {
                alert('Please enter a Claude API key, or switch to another provider.');
                return;
            }

            if (selectedProvider === 'gemini' && !geminiKey && !getLocalAPIKey('gemini')) {
                alert('Please enter a Gemini API key, or switch to another provider.');
                return;
            }

            if (selectedProvider === 'openai' && !openaiKey && !getLocalAPIKey('openai')) {
                alert('Please enter an OpenAI API key, or switch to another provider.');
                return;
            }

            // Save keys if provided (preserves existing keys if not changed)
            if (claudeKey) {
                setLocalAPIKey(claudeKey, 'anthropic');
                console.log('‚úÖ Claude API key saved');
            }

            if (geminiKey) {
                setLocalAPIKey(geminiKey, 'gemini');
                console.log('‚úÖ Gemini API key saved');
            }

            if (openaiKey) {
                setLocalAPIKey(openaiKey, 'openai');
                console.log('‚úÖ OpenAI API key saved');
            }

            // Save provider preference
            setAIProvider(selectedProvider);
            console.log(`‚úÖ Primary AI provider set to: ${selectedProvider}`);

            // Close modal
            document.getElementById('api-key-modal').style.display = 'none';

            // If we came from Analysis Mode, reopen it
            if (window.pendingAnalysisMode) {
                window.pendingAnalysisMode = false;
                document.getElementById('analyze-text-btn').click();
            }
        });

        // Function to check if API key is configured
        function checkAPIKeyConfigured(options = {}) {
            const { forcePrompt = false } = options;
            const localKey = getLocalAPIKey();
            if (localKey) {
                return true;
            }

            if (!forcePrompt && canUseServerlessAI()) {
                console.log('üåê No local API key found. Using Netlify serverless function for AI calls.');
                return true;
            }

            // No local key and serverless unavailable (or prompt requested) - show modal
            showApiKeyModal(false);
            return false;
        }

        // =============================================================================
        // AI REVIEW & ENHANCE SYSTEM
        // =============================================================================

        // Open AI Review modal and analyze tree
        document.getElementById('ai-review-btn').addEventListener('click', async () => {
            // Check if AI is enabled
            const aiMode = getGlobalAIMode();
            if (aiMode === 'off') {
                alert('‚ùå AI features are currently disabled.\n\nPlease enable AI mode in the header (ü§ñ AI dropdown) to use AI Review.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            // Check if tree has content
            if (!hasExistingContent()) {
                alert('‚ö†Ô∏è Your tree is empty.\n\nPlease add some content first, then use AI Review to get suggestions for improvements.');
                return;
            }

            // Open modal and start analysis
            document.getElementById('ai-review-modal').style.display = 'flex';
            document.getElementById('ai-review-status').style.display = 'block';
            document.getElementById('ai-review-results').style.display = 'none';

            await performAIReview();
        });

        // Close AI Review modal
        document.getElementById('close-ai-review-modal').addEventListener('click', () => {
            document.getElementById('ai-review-modal').style.display = 'none';
        });

        // Re-analyze button
        document.getElementById('ai-review-again').addEventListener('click', async () => {
            document.getElementById('ai-review-status').style.display = 'block';
            document.getElementById('ai-review-results').style.display = 'none';
            await performAIReview();
        });

        // Perform AI Review of the tree
        async function performAIReview() {
            const pattern = PATTERNS[currentPattern];
            const tree = capexTree;

            try {
                // Build pattern-specific review prompt
                const reviewPrompt = buildReviewPrompt(tree, pattern);

                console.log('üî¨ Starting AI Review...');
                console.log('Pattern:', currentPattern);
                console.log('Tree:', tree.name);

                // Call AI with extended thinking for deep analysis
                const aiMode = getGlobalAIMode();
                const useExtendedThinking = aiMode === 'deep';

                // Extended thinking has budget_tokens = 5000, so maxTokens must be > 5000
                // Using 8000 to give 3000 tokens for actual response content
                const maxTokensForReview = useExtendedThinking ? 8000 : 4096;

                // Pattern-specific expert personas for AI Review
                const reviewExperts = {
                    philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments. Review for logical validity, premise strength, and dialectical completeness.',
                    sales: 'You are a sales strategist with 20 years of enterprise B2B experience. Review for pipeline health, deal qualification, and revenue optimization.',
                    thesis: 'You are an academic advisor helping graduate students structure rigorous research. Review for argument progression, citation quality, and scholarly standards.',
                    roadmap: 'You are a product manager experienced in agile development and feature prioritization. Review for execution readiness, story completeness, and technical feasibility.',
                    prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude, GPT-4, and other LLMs. Review for prompt clarity, few-shot example quality, output format specification, and edge case handling.',
                    book: 'You are a professional fiction editor and writing coach. Review for narrative flow, character development, and pacing.',
                    film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway). Review for visual storytelling, shot composition, and production feasibility.',
                    course: 'You are an instructional designer with expertise in curriculum development. Review for learning progression, assessment alignment, and instructional scaffolding.',
                    dialogue: 'You are a debate coach and rhetoric expert specializing in argumentation theory, logical fallacies, and persuasive communication. Review for argument strength, rhetorical effectiveness, fallacy identification, and evidence quality.',
                    filesystem: 'You are LibrarianAI, a filesystem organization expert. Review for folder structure clarity, file naming consistency, redundancy reduction, data quality, and organizational best practices. Focus on metadata enrichment opportunities and safe, non-destructive improvements.',
                    generic: `You are an expert ${pattern.name} analyst. Review the provided tree structure for completeness, redundancies, logical flow, and alignment with ${pattern.name} best practices.`
                };

                const expertPersona = reviewExperts[currentPattern] || reviewExperts.generic;

                const content = await callClaudeAPI(
                    reviewPrompt,
                    expertPersona + ' Provide specific, actionable suggestions.',
                    maxTokensForReview,
                    useExtendedThinking
                );

                // Parse the AI response and display results
                displayReviewResults(content);

            } catch (error) {
                console.error('‚ùå AI Review error:', error);
                document.getElementById('ai-review-status').innerHTML = `
                    <div style="padding: 15px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">‚ùå Error during analysis</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            ${error.message}
                        </div>
                    </div>
                `;
            }
        }

        // Build pattern-specific review prompt
        function buildReviewPrompt(tree, pattern) {
            const levels = pattern.levels;
            let prompt = `# ${pattern.name} Tree Review\n\n`;
            prompt += `**Project:** ${tree.name}\n`;
            prompt += `**Pattern:** ${pattern.name}\n\n`;

            // Count items
            const itemCounts = {
                phases: tree.children ? tree.children.length : 0,
                items: 0,
                subtasks: 0
            };

            if (tree.children) {
                tree.children.forEach(phase => {
                    // Support both 'items' (standard) and 'children' (filesystem pattern)
                    const nodeList = phase.items || phase.children || [];
                    if (nodeList.length > 0) {
                        itemCounts.items += nodeList.length;
                        nodeList.forEach(item => {
                            if (item.subtasks || item.children) {
                                itemCounts.subtasks += (item.subtasks || item.children || []).length;
                            }
                        });
                    }
                });
            }

            prompt += `**Current Structure:**\n`;
            prompt += `- ${itemCounts.phases} ${levels.phase}(s)\n`;
            prompt += `- ${itemCounts.items} ${levels.item}(s)\n`;
            prompt += `- ${itemCounts.subtasks} ${levels.subtask}(s)\n\n`;

            // Add tree content
            prompt += `## Tree Structure\n\n`;
            if (tree.children) {
                tree.children.forEach((phase, pIdx) => {
                    prompt += `### ${pIdx + 1}. ${phase.name}\n\n`;
                    if (phase.description) {
                        prompt += `${phase.description}\n\n`;
                    }

                    // Support both 'items' (standard) and 'children' (filesystem pattern)
                    const nodeList = phase.items || phase.children || [];
                    if (nodeList.length > 0) {
                        nodeList.forEach((item, iIdx) => {
                            prompt += `  **${iIdx + 1}. ${item.name}**\n`;
                            if (item.description) {
                                prompt += `  ${item.description}\n`;
                            }

                            // Add pattern-specific fields
                            const fields = Object.keys(item).filter(k =>
                                !['id', 'name', 'icon', 'type', 'description', 'subtasks', 'children', 'dependencies'].includes(k)
                            );

                            if (fields.length > 0) {
                                prompt += `  Fields: ${fields.join(', ')}\n`;
                            }
                            prompt += `\n`;
                        });
                    }
                    prompt += `\n`;
                });
            }

            // Pattern-specific review criteria
            prompt += `\n## Review Criteria\n\n`;
            prompt += `Please analyze this ${pattern.name} tree and provide:\n\n`;

            prompt += `1. **Completeness Check:**\n`;
            prompt += `   - Are all necessary ${levels.item.toLowerCase()}s present?\n`;
            prompt += `   - Are there obvious gaps in the ${levels.phase.toLowerCase()} coverage?\n`;
            prompt += `   - Are critical fields missing values?\n\n`;

            prompt += `2. **Redundancy Analysis:**\n`;
            prompt += `   - Are there duplicate or overlapping ${levels.item.toLowerCase()}s?\n`;
            prompt += `   - Can any ${levels.item.toLowerCase()}s be merged or consolidated?\n\n`;

            prompt += `3. **Logical Flow:**\n`;
            prompt += `   - Do the ${levels.phase.toLowerCase()}s follow a logical sequence?\n`;
            prompt += `   - Are dependencies properly structured?\n`;
            prompt += `   - Does the tree structure make sense for this ${pattern.name}?\n\n`;

            prompt += `4. **Pattern Alignment:**\n`;
            prompt += `   - Does this follow ${pattern.name} best practices?\n`;
            prompt += `   - Are pattern-specific fields used appropriately?\n`;
            prompt += `   - What could improve alignment with ${pattern.name} standards?\n\n`;

            // Pattern-specific additions
            if (currentPattern === 'philosophy') {
                prompt += `5. **Philosophical Rigor:**\n`;
                prompt += `   - Are premises logically valid?\n`;
                prompt += `   - Are objections comprehensive?\n`;
                prompt += `   - Are textual references adequate?\n\n`;
            } else if (currentPattern === 'sales') {
                prompt += `5. **Pipeline Health:**\n`;
                prompt += `   - Are all pipeline stages represented?\n`;
                prompt += `   - Are deal values and probabilities realistic?\n`;
                prompt += `   - Are key competitors identified?\n\n`;
            } else if (currentPattern === 'thesis') {
                prompt += `5. **Academic Standards:**\n`;
                prompt += `   - Is the argument progression clear?\n`;
                prompt += `   - Are citations sufficient?\n`;
                prompt += `   - Is chapter balance appropriate?\n\n`;
            } else if (currentPattern === 'roadmap') {
                prompt += `5. **Execution Readiness:**\n`;
                prompt += `   - Are user stories well-defined?\n`;
                prompt += `   - Are story points assigned?\n`;
                prompt += `   - Are technical risks identified?\n\n`;
            } else if (currentPattern === 'book') {
                prompt += `5. **Narrative Structure:**\n`;
                prompt += `   - Does the story arc flow naturally?\n`;
                prompt += `   - Are character arcs developed?\n`;
                prompt += `   - Is pacing appropriate?\n\n`;
            } else if (currentPattern === 'course') {
                prompt += `5. **Instructional Design:**\n`;
                prompt += `   - Is learning progression scaffolded?\n`;
                prompt += `   - Are assessments aligned with objectives?\n`;
                prompt += `   - Is content appropriately chunked?\n\n`;
            } else if (currentPattern === 'prompting') {
                prompt += `5. **Prompt Engineering Quality:**\n`;
                prompt += `   - Are system prompts clear and specific?\n`;
                prompt += `   - Do few-shot examples cover edge cases?\n`;
                prompt += `   - Are output formats well-defined?\n`;
                prompt += `   - Are chain-of-thought instructions effective?\n`;
                prompt += `   - Are test cases comprehensive?\n\n`;
            }

            prompt += `## Output Format\n\n`;
            prompt += `Provide your analysis in the following format:\n\n`;
            prompt += `**SUMMARY:** (2-3 sentences overview of tree quality)\n\n`;
            prompt += `**STRENGTHS:** (Bullet list of what's working well)\n\n`;
            prompt += `**GAPS:** (Specific missing items or fields)\n\n`;
            prompt += `**REDUNDANCIES:** (Items that could be merged)\n\n`;
            prompt += `**IMPROVEMENTS:** (Actionable suggestions to enhance the tree)\n\n`;

            return prompt;
        }

        // Display AI review results
        function displayReviewResults(response) {
            // Hide status, show results
            document.getElementById('ai-review-status').style.display = 'none';
            document.getElementById('ai-review-results').style.display = 'block';

            // Parse response sections
            const sections = {
                summary: extractSection(response, 'SUMMARY'),
                strengths: extractSection(response, 'STRENGTHS'),
                gaps: extractSection(response, 'GAPS'),
                redundancies: extractSection(response, 'REDUNDANCIES'),
                improvements: extractSection(response, 'IMPROVEMENTS')
            };

            // Build summary HTML
            const summaryHTML = `
                <div style="padding: 16px; background: var(--card-bg); border-radius: 8px; margin-bottom: 16px;">
                    ${sections.summary || 'Analysis complete.'}
                </div>

                ${sections.strengths ? `
                <div style="padding: 16px; background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #10b981; font-size: 14px;">‚úÖ Strengths</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.strengths)}</div>
                </div>
                ` : ''}

                ${sections.gaps ? `
                <div style="padding: 16px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #ef4444; font-size: 14px;">‚ö†Ô∏è Gaps</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.gaps)}</div>
                </div>
                ` : ''}

                ${sections.redundancies ? `
                <div style="padding: 16px; background: rgba(245, 158, 11, 0.1); border-left: 3px solid #f59e0b; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #f59e0b; font-size: 14px;">üîÑ Redundancies</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.redundancies)}</div>
                </div>
                ` : ''}
            `;

            document.getElementById('ai-review-summary').innerHTML = summaryHTML;

            // Build suggestions HTML
            const suggestionsHTML = sections.improvements ? `
                <div style="padding: 16px; background: rgba(99, 102, 241, 0.1); border-left: 3px solid #6366f1; border-radius: 6px;">
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.improvements)}</div>
                </div>
            ` : '<div style="color: var(--text-secondary);">No specific improvements suggested.</div>';

            document.getElementById('ai-review-suggestions').innerHTML = suggestionsHTML;

            console.log('‚úÖ AI Review complete');
        }

        // Extract section from AI response
        function extractSection(text, sectionName) {
            const regex = new RegExp(`\\*\\*${sectionName}:\\*\\*\\s*([\\s\\S]*?)(?=\\n\\*\\*[A-Z]+:|$)`, 'i');
            const match = text.match(regex);
            return match ? match[1].trim() : '';
        }

        // Format markdown to HTML (simple version)
        function formatMarkdown(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
                .replace(/^- (.+)$/gm, '<li>$1</li>') // List items
                .replace(/(<li>.*<\/li>)/s, '<ul style="margin: 8px 0; padding-left: 20px;">$1</ul>') // Wrap in ul
                .replace(/\n\n/g, '<br><br>'); // Paragraphs
        }

        // =============================================================================
        // ANALYSIS MODE - TEXT TO TREE CONVERSION
        // =============================================================================

        let analysisText = '';
        let analysisFileName = '';

        // Open Analysis Modal
        // Track analysis mode (fresh or append)
        let analysisAppendMode = false;

        document.getElementById('analyze-text-btn').addEventListener('click', () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                window.pendingAnalysisMode = true;
                return;
            }

            // If tree has content, ask user if they want to append or start fresh
            if (hasExistingContent()) {
                showAnalysisModeChoice();
            } else {
                openAnalysisModal(false); // false = start fresh
            }
        });

        // Show modal to choose analysis mode
        function showAnalysisModeChoice() {
            const pattern = PATTERNS[currentPattern];
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'üîç Analyze Text Mode';

            // Count existing items
            const itemCount = capexTree.children?.reduce((sum, phase) =>
                sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 24px;">
                        Your tree already has <strong style="color: var(--treeplex-primary);">${itemCount} ${pattern.levels.item.toLowerCase()}(s)</strong>.
                        How would you like to proceed?
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="analysis-mode-append" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">‚ûï</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Append to Existing
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Analyze the text and add the results to your current tree. Great for combining multiple documents.
                            </div>
                        </div>

                        <div id="analysis-mode-fresh" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">üîÑ</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Replace Tree
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Clear the current tree and replace it with the analysis results. Starts from scratch.
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                        üí° <strong>Tip:</strong> Append mode lets you analyze multiple documents and combine them into one comprehensive tree.
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Add click handlers
            document.getElementById('analysis-mode-append').onclick = () => {
                modal.style.display = 'none';
                openAnalysisModal(true); // true = append mode
            };

            document.getElementById('analysis-mode-fresh').onclick = () => {
                modal.style.display = 'none';
                openAnalysisModal(false); // false = start fresh
            };
        }

        // Open the analysis modal
        function openAnalysisModal(appendMode) {
            analysisAppendMode = appendMode;

            const modal = document.getElementById('analysis-modal');
            modal.style.display = 'flex';

            // Reset form
            document.getElementById('analysis-text-input').value = '';
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            document.getElementById('char-count').textContent = '0 characters';
            document.getElementById('analysis-warning').style.display = 'none';
            analysisText = '';
            analysisFileName = '';

            // Update the AI mode display to show current global mode
            updateAnalysisModeDisplay();
        }

        // Update the AI mode display in Analyze Text modal
        function updateAnalysisModeDisplay() {
            const mode = getGlobalAIMode();
            const label = document.getElementById('analyze-mode-label');
            const description = document.getElementById('analyze-mode-description');

            if (mode === 'off') {
                label.textContent = '‚ùå Off';
                description.textContent = 'AI features are disabled. Enable AI mode in the header to use this feature.';
                description.style.color = '#EF4444';
            } else if (mode === 'quick') {
                label.textContent = '‚ö° Quick';
                description.textContent = 'Fast pattern detection + basic structure. Recommended for most uses. Uses server API key (rate limited).';
                description.style.color = 'var(--text-secondary)';
            } else if (mode === 'deep') {
                label.textContent = 'üî¨ Deep';
                description.textContent = 'Comprehensive parsing with extended thinking (8192 tokens). Handles 3x more text. Requires your API key. No timeouts.';
                description.style.color = 'var(--text-secondary)';
            }
        }

        // Close Analysis Modal
        document.getElementById('analysis-cancel').addEventListener('click', () => {
            document.getElementById('analysis-modal').style.display = 'none';
        });

        // File Drop Zone - Click to browse
        const fileDropZone = document.getElementById('file-drop-zone');
        const fileInput = document.getElementById('analysis-file-input');

        fileDropZone.addEventListener('click', () => {
            fileInput.click();
        });

        // File selected via browse
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Drag and Drop handlers
        fileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--treeplex-primary)';
            fileDropZone.style.background = 'rgba(99, 102, 241, 0.05)';
        });

        fileDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';
        });

        fileDropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';

            const file = e.dataTransfer.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Handle file upload
        async function handleAnalysisFile(file) {
            // Check file type
            const validTypes = ['.txt', '.md'];
            const fileName = file.name.toLowerCase();
            const isValid = validTypes.some(type => fileName.endsWith(type));

            if (!isValid) {
                alert('Please upload a .txt or .md file only.');
                return;
            }

            // Show file name
            document.getElementById('selected-file-name').textContent = file.name;
            document.getElementById('file-name-display').style.display = 'block';
            analysisFileName = file.name;

            // Read file content
            const reader = new FileReader();
            reader.onload = (e) => {
                analysisText = e.target.result;

                // Clear text area since we're using file
                document.getElementById('analysis-text-input').value = '';

                // Update character count
                updateCharCount(analysisText.length);

                // Check file size and show warning if needed
                checkFileSize(analysisText.length);
            };
            reader.readAsText(file);
        }

        // Clear file button
        document.getElementById('clear-file-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            analysisText = '';
            analysisFileName = '';
            updateCharCount(0);
            document.getElementById('analysis-warning').style.display = 'none';
        });

        // Text area character count
        const textInput = document.getElementById('analysis-text-input');
        textInput.addEventListener('input', (e) => {
            analysisText = e.target.value;
            updateCharCount(analysisText.length);
            checkFileSize(analysisText.length);

            // Clear file if typing in text area
            if (analysisText.length > 0 && analysisFileName) {
                document.getElementById('analysis-file-input').value = '';
                document.getElementById('file-name-display').style.display = 'none';
                analysisFileName = '';
            }
        });

        function updateCharCount(count) {
            const charCountEl = document.getElementById('char-count');
            const words = count > 0 ? analysisText.trim().split(/\s+/).length : 0;
            charCountEl.textContent = `${count.toLocaleString()} characters (~${words} words)`;

            if (count > 50000) {
                charCountEl.style.color = '#ff9f43';
            } else {
                charCountEl.style.color = 'var(--text-secondary)';
            }
        }

        function checkFileSize(charCount) {
            const warningEl = document.getElementById('analysis-warning');
            const warningText = document.getElementById('analysis-warning-text');

            // Rough token estimate: 1 token ‚âà 4 characters
            const estimatedTokens = Math.ceil(charCount / 4);
            const estimatedWords = Math.ceil(charCount / 5);

            if (charCount > 100000) { // Will be truncated
                warningEl.style.display = 'block';
                warningText.textContent = `‚ö†Ô∏è Text is ${charCount.toLocaleString()} characters (~${estimatedWords.toLocaleString()} words). Will be automatically truncated to 100,000 characters (~25,000 words) to prevent timeouts. Consider pasting a shorter excerpt for best results.`;
            } else if (charCount > 75000) { // Large but ok
                warningEl.style.display = 'block';
                warningText.textContent = `Very large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis may take 15-25 seconds. Quick Mode strongly recommended.`;
            } else if (charCount > 50000) { // Large
                warningEl.style.display = 'block';
                warningText.textContent = `Large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Deep Mode will provide richer analysis but may take 20-30 seconds.`;
            } else if (charCount > 5000) {
                warningEl.style.display = 'block';
                warningText.textContent = `Medium text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis should take 15-30 seconds.`;
            } else {
                warningEl.style.display = 'none';
            }
        }

        // =============================================================================
        // AI PATTERN DETECTION & TEXT-TO-TREE CONVERSION
        // =============================================================================

        // Pattern detection function
        async function detectPattern(text) {
            const prompt = `Analyze the following text and determine the 3 most appropriate TreeListy patterns for organizing it.

AVAILABLE PATTERNS:
1. Generic Project - Universal structure for any project (Project ‚Üí Phase ‚Üí Item ‚Üí Task)
2. Sales Pipeline - Deal tracking across quarters (Pipeline ‚Üí Quarter ‚Üí Deal ‚Üí Action)
3. Academic Writing - Thesis/research paper structure (Thesis ‚Üí Chapter ‚Üí Section ‚Üí Point)
4. Product Roadmap - Feature development timeline (Product ‚Üí Quarter ‚Üí Feature ‚Üí Story)
5. Book Writing - Narrative structure (Book ‚Üí Part ‚Üí Chapter ‚Üí Scene)
6. Event Planning - Event organization and logistics (Event ‚Üí Stage ‚Üí Activity ‚Üí Task)
7. Fitness Program - Workout programs and exercises (Program ‚Üí Phase ‚Üí Workout ‚Üí Exercise)
8. Strategic Plan - Business initiatives and metrics (Strategy ‚Üí Pillar ‚Üí Initiative ‚Üí Action)
9. Course Design - Educational curriculum structure (Course ‚Üí Unit ‚Üí Lesson ‚Üí Exercise)
10. Film Production - Film/video production workflow (Film ‚Üí Phase ‚Üí Scene ‚Üí Shot)
11. Philosophy - Philosophical arguments and treatises (Treatise ‚Üí Book ‚Üí Argument ‚Üí Premise)
12. Prompt Engineering - AI prompts and testing (Library ‚Üí Category ‚Üí Prompt ‚Üí Test Case)
13. Family Tree - Genealogical documentation (Family ‚Üí Generation ‚Üí Person ‚Üí Event)
14. Dialogue & Rhetoric - Analyze debates, conversations, and arguments (Conversation ‚Üí Speaker ‚Üí Statement ‚Üí Point)

TEXT TO ANALYZE:
${text.substring(0, 5000)}${text.length > 5000 ? '\n\n[... truncated for analysis ...]' : ''}

DETECTION HINTS:
- If text contains prompt-related terms like "system prompt", "user prompt", "few-shot examples", "chain-of-thought", "temperature", "max tokens" ‚Üí Prompt Engineering
- If text looks like AI instructions or discusses prompt design ‚Üí Prompt Engineering
- If text mentions AI models (Claude, GPT, Anthropic, OpenAI) in context of prompting ‚Üí Prompt Engineering
- If text contains debate/dialogue terms like "speaker", "argument", "rhetoric", "fallacy", "premise", "counterargument", "rebuttal", "debate", "conversation" ‚Üí Dialogue & Rhetoric
- If text is a transcript of a conversation, political debate, or online discussion ‚Üí Dialogue & Rhetoric
- If text analyzes persuasion, argumentation, or rhetorical techniques ‚Üí Dialogue & Rhetoric

Respond with ONLY a valid JSON object in this exact format:
{
  "recommendations": [
    {
      "pattern": "pattern-key",
      "patternName": "Pattern Display Name",
      "confidence": 9,
      "reasoning": "Brief explanation of why this pattern fits"
    }
  ]
}

Provide exactly 3 recommendations, ranked by confidence (1-10). Use these pattern keys: generic, sales, thesis, roadmap, book, event, fitness, strategy, course, film, philosophy, prompting, familytree, dialogue`;

            const response = await callClaudeAPI(prompt);

            try {
                // Extract JSON from response
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    return result.recommendations;
                }
            } catch (e) {
                console.error('Failed to parse pattern detection response:', e);
            }

            // Fallback to generic
            return [{
                pattern: 'generic',
                patternName: 'Generic Project',
                confidence: 5,
                reasoning: 'Default fallback pattern'
            }];
        }

        // Helper function to fix common JSON issues
        function repairJSON(jsonText) {
            // SIMPLE APPROACH: Replace all problematic characters with spaces or escaped versions
            // This is more reliable than complex regex matching

            // Replace literal newlines, carriage returns, and tabs with spaces
            // These shouldn't be in JSON strings - Claude should use \n instead
            jsonText = jsonText.replace(/\r\n/g, ' ');
            jsonText = jsonText.replace(/\r/g, ' ');
            jsonText = jsonText.replace(/\n/g, ' ');
            jsonText = jsonText.replace(/\t/g, ' ');

            // Remove other control characters (ASCII 0-31 except space)
            jsonText = jsonText.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');

            // Remove trailing commas before closing brackets/braces (run multiple times to catch nested cases)
            let previousText;
            do {
                previousText = jsonText;
                jsonText = jsonText.replace(/,(\s*[}\]])/g, '$1');
            } while (jsonText !== previousText);

            // Remove comments (// and /* */)
            jsonText = jsonText.replace(/\/\/.*$/gm, '');
            jsonText = jsonText.replace(/\/\*[\s\S]*?\*\//g, '');

            return jsonText;
        }

        // PROMPT IMPROVEMENT: Special handler for Prompt Engineering pattern
        // Takes a basic prompt and generates comprehensive improved version with best practices
        async function improvePromptWithAI(basicPrompt, mode = 'quick') {
            console.log(`üß† Improving prompt using ${mode} mode...`);

            const systemPrompt = `You are an expert prompt engineer who specializes in improving prompts using OpenAI and Anthropic best practices.

üö® CRITICAL UNDERSTANDING: You are NOT answering questions. You are NOT providing information. You are CREATING PROMPTS.

Your ONLY task: Take a basic topic/idea/draft and CREATE a comprehensive prompt that another AI would use to help with that topic.

Example workflow:
- Input: "early signs of parkinsons" ‚Üí CREATE a prompt for an AI to help identify early Parkinson's signs
- Input: "analyze sentiment" ‚Üí CREATE a sentiment analysis prompt
- Input: "plan a vacation" ‚Üí CREATE a vacation planning prompt

You are a PROMPT BUILDER, not a question answerer.

BEST PRACTICES TO APPLY:
1. **System Prompt**: Clear role definition, context, constraints, tone
2. **User Prompt Template**: Structured with {{variables}}, clear instructions, step-by-step guidance
3. **Few-Shot Examples**: 2-3 high-quality input‚Üíoutput examples showing desired behavior
4. **Chain-of-Thought**: Instructions for showing reasoning process (if applicable)
5. **Output Format**: Exact structure specification (JSON schema, markdown template, etc.)
6. **Edge Cases**: Handle ambiguity, missing data, errors
7. **Variables**: Identify dynamic parts as {{variable_name}}
8. **Prefill** (Claude): Suggested response starter for tone/format control

CRITICAL: Return ONLY valid JSON. No explanations, no markdown, no text before or after.`;

            const userPrompt = `Your task: CREATE a production-ready prompt about the following topic/concept/use-case:

TOPIC: "${basicPrompt}"

Your job is to DESIGN A PROMPT that another AI could use to help with this topic. You are NOT answering this as a question. You are CREATING a ready-to-use prompt.

üéØ What you MUST do:
- Take the topic "${basicPrompt}" and design a comprehensive prompt FOR an AI to handle this topic
- Example: If topic is "early signs of parkinsons" ‚Üí CREATE a prompt FOR an AI to help identify/discuss Parkinson's signs
- Example: If topic is "skin care" ‚Üí CREATE a prompt FOR an AI to provide skin care guidance
- Example: If topic is a draft prompt ‚Üí IMPROVE it into a production version

üö´ What you must NOT do:
- DO NOT answer "${basicPrompt}" as if it's a question posed to you
- DO NOT try to provide information about the topic
- DO NOT give medical advice, recommendations, or analysis
- You are a PROMPT ARCHITECT building a tool, not a subject matter expert answering queries

üé® CRITICAL: Create COMPREHENSIVE, INSTRUCTION-RICH prompts that guide AI behavior:
- Generate prompts that INSTRUCT and CONFIGURE the AI, not simple questions that get answered
- Combine system prompt + user prompt into one comprehensive instruction block
- Include: role definition, process steps, output format, examples, constraints
- The user will paste this entire block into ChatGPT/Claude to configure it

BAD (gets answered immediately): "Help me create a skin care routine"
GOOD (instructs the AI): "You are an expert dermatologist. When helping with skin care: 1) Ask about skin type and concerns 2) Provide structured routine with product recommendations 3) Return as JSON with ingredients, frequency, and reasoning for each step. Now help me create a comprehensive skin care routine."

Now create a SINGLE comprehensive prompt that combines:
1. Role definition and expertise (system-level instructions)
2. Process steps and methodology (how the AI should think)
3. Output format specification (structured data format)
4. Few-shot examples (if helpful)
5. Constraints and edge cases (what to avoid)
6. The actual user request (at the end)

This single prompt will be in the userPromptTemplate field.

Return ONLY this JSON structure:
{
  "projectName": "Descriptive name for this prompt (e.g., 'Skin Care Routine Assistant')",
  "description": "Brief 1-sentence description of what this prompt does",
  "phases": [
    {
      "name": "Production Prompt",
      "subtitle": "Ready to use with Claude/GPT-4",
      "items": [
        {
          "name": "Improved: [Brief name based on use case]",
          "description": "Production-ready prompt that works immediately",
          "itemType": "task-instruction",
          "systemPrompt": "You are an expert [domain]. [Context]. [Constraints]. [Tone].",
          "userPromptTemplate": "Comprehensive instruction-rich prompt combining: role definition + process steps + output format + constraints + user request. This entire text is what the user pastes into the AI.",
          "fewShotExamples": "<example>\\nUser: [example input 1]\\nAssistant: [example output 1]\\n</example>\\n\\n<example>\\nUser: [example input 2]\\nAssistant: [example output 2]\\n</example>",
          "chainOfThought": "Think step by step: 1) [step], 2) [step], 3) [step]. Show your reasoning.",
          "outputFormat": "Return JSON: {\\"field1\\": \\"description\\", \\"field2\\": \\"description\\"}",
          "structuralTags": "<thinking>\\nReasoning process\\n</thinking>\\n<answer>\\nFinal response\\n</answer>",
          "assistantPrefill": "Here is my analysis:",
          "modelTarget": "Claude 3.5 Sonnet",
          "temperature": 0.7,
          "maxTokens": 2000
        }
      ]
    }
  ]
}

RULES:
- Infer use case from basic prompt (chatbot? search? analysis? recommendation?)
- Create realistic, helpful few-shot examples
- userPromptTemplate must be COMPREHENSIVE and INSTRUCTION-RICH (not a simple question)
- Combine role + process + format + request into single prompt that configures AI behavior
- NO {{variables}} or placeholders - make it work immediately when pasted
- Chain-of-thought only if task requires reasoning
- Output format should match the use case (JSON for APIs, markdown for reports, etc.)
- System prompt should be professional and comprehensive
- NO trailing commas in JSON

EXAMPLE of a GOOD userPromptTemplate:
"You are an expert skin care advisor with dermatology knowledge. When providing skin care guidance: 1) First, ask clarifying questions about skin type, concerns, and sensitivities 2) Then provide a comprehensive routine with specific product recommendations 3) Include ingredients, application frequency, and scientific reasoning 4) Return your recommendation as JSON with 'routine' array and 'additional_tips' array. Now, help me create a personalized skin care routine."
- Escape quotes inside strings with backslash`;

            // Deep mode uses extended thinking (budget_tokens = 5000)
            // So maxTokens must be > 5000. Using 8000 to give 3000 tokens for actual response.
            const maxTokens = mode === 'deep' ? 8000 : 2048;
            const useThinking = mode === 'deep';

            const response = await callClaudeAPI(userPrompt, systemPrompt, maxTokens, useThinking);

            try {
                // Extract JSON from response
                let jsonText = response.trim();
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                const firstBrace = jsonText.indexOf('{');
                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('üß† Skipping text before JSON:', jsonText.substring(0, firstBrace));
                    jsonText = jsonText.substring(firstBrace);
                }

                // Find matching closing brace
                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = 0; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Could not find matching closing brace in JSON');
                }

                jsonText = jsonText.substring(0, endPos + 1);

                const parsed = JSON.parse(jsonText);
                console.log('‚úÖ Prompt improved successfully:', parsed.projectName);
                return parsed;

            } catch (e) {
                console.error('‚ùå JSON parsing error:', e);
                console.error('Response:', response);
                throw new Error(`Failed to improve prompt. AI response was not valid JSON: ${e.message}`);
            }
        }

        // Quick Mode: Basic structure conversion
        async function convertTextToTreeQuick(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            // SPECIAL CASE: Prompt Engineering pattern - improve the prompt instead of extracting
            if (pattern === 'prompting') {
                return await improvePromptWithAI(text, 'quick');
            }

            // Generate quick field hints (top 5 most important fields)
            let quickFieldHints = '';
            const importantFields = [];

            Object.keys(fields).forEach(fieldKey => {
                const fieldConfig = fields[fieldKey];
                // Skip non-field properties
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }
                if (fieldConfig.label) {
                    let hint = `- ${fieldKey}: ${fieldConfig.label}`;
                    if (fieldConfig.type === 'number') {
                        hint += ` (number)`;
                    } else if (fieldConfig.type === 'date') {
                        hint += ` (YYYY-MM-DD)`;
                    } else if (fieldConfig.type === 'select' && fieldConfig.options) {
                        hint += ` (${fieldConfig.options.slice(0, 3).join('/')})`;
                    }
                    importantFields.push(hint);
                }
            });

            if (importantFields.length > 0) {
                quickFieldHints = `\n\nKEY FIELDS TO EXTRACT (if mentioned in text):\n${importantFields.slice(0, 6).join('\n')}\n`;
            }

            // Add item types if available
            let itemTypeHints = '';
            if (patternConfig.types && patternConfig.types.length > 0) {
                const typesList = patternConfig.types.slice(0, 8).map(t => t.value).join(', ');
                itemTypeHints = `\n\nITEM TYPES: Use these specific types: ${typesList}\n`;
            }

            // Pattern-specific subtask guidance
            function getPatternSubtaskGuidance(pattern) {
                const guidance = {
                    philosophy: `For ${levels.item}s, add ${levels.subtask}s like: premises, objections, supporting evidence, textual references`,
                    sales: `For ${levels.item}s (deals), add ${levels.subtask}s like: follow-up actions, next steps, activities to close`,
                    thesis: `For ${levels.item}s (arguments), add ${levels.subtask}s like: supporting evidence, citations, counter-arguments`,
                    roadmap: `For ${levels.item}s (features), add ${levels.subtask}s like: implementation steps, technical tasks, acceptance criteria`,
                    book: `For ${levels.item}s (chapters), add ${levels.subtask}s like: scenes, key moments, character developments`,
                    course: `For ${levels.item}s (modules), add ${levels.subtask}s like: lessons, activities, assessments, practice exercises`,
                    film: `For ${levels.item}s (scenes), add ${levels.subtask}s like: specific shots, camera movements, lighting changes`,
                    prompting: `For ${levels.item}s (prompts), add ${levels.subtask}s like: test cases, variations, edge cases to handle`,
                    generic: `For ${levels.item}s, add ${levels.subtask}s like: steps, components, or sub-elements needed`
                };
                return guidance[pattern] || guidance.generic;
            }

            // Pattern-specific instructions for Quick Mode
            let patternSpecialInstructions = '';
            if (pattern === 'film') {
                patternSpecialInstructions = `\n\n‚ö†Ô∏è AI VIDEO: Create ACTUAL SCENES (not workflows about making videos). Each item = one shot. Include videoPrompt, cameraMovement, visualStyle, duration.\n`;
            }

            const prompt = `Convert this text into a hierarchical project structure using the "${patternConfig.name}" pattern.

PATTERN HIERARCHY:
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}
${itemTypeHints}${quickFieldHints}${patternSpecialInstructions}

TEXT:
${text}

INSTRUCTIONS (BE CONCISE TO AVOID TIMEOUT):
1. Identify natural hierarchical structure in the text
2. Create 2-4 phases (${levels.phase}s) - MAXIMUM 4
3. For each phase, create 2-5 items (${levels.item}s) - MAXIMUM 5 per phase
4. ‚ö†Ô∏è IMPORTANT: Add 2-3 ${levels.subtask}s to items that need them
   ‚Üí ${levels.subtask}s break down each ${levels.item} into its constituent parts
   ‚Üí ${getPatternSubtaskGuidance(pattern)}
5. Keep descriptions SHORT (under 100 characters)
6. Extract the key fields listed above if values are mentioned in the text
7. Focus on capturing the hierarchical structure in the text

JSON FORMATTING RULES (CRITICAL - FOLLOW EXACTLY):
- NO trailing commas after the last element in arrays or objects
- NO line breaks or tabs inside string values - use spaces instead
- NO unescaped quotes inside strings
- ONLY plain JSON - no markdown code blocks, no backticks, no explanations
- Start response with { and end with }

CORRECT EXAMPLE (note: NO trailing comma after last item):
{"phases": [{"name": "Test", "items": [{"name": "Item"}]}]}

WRONG (trailing comma):
{"phases": [{"name": "Test", "items": [{"name": "Item"},]}]}

Respond with ONLY valid, parseable JSON:
{
  "projectName": "Extracted or inferred project name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle or description",
      "icon": "üìã",
      "items": [
        {
          "name": "Item name",
          "description": "Brief description",
          "itemType": "type-from-list-above",
          "... include any key fields from list above if mentioned ...": "value",
          "subItems": [
            {
              "name": "${levels.subtask} 1",
              "description": "Pattern-specific detail",
              "subItems": [
                { "name": "${levels.subtask} 1.1", "description": "Supports N-level nesting" }
              ]
            },
            { "name": "${levels.subtask} 2", "description": "Pattern-specific detail" }
          ]
        }
      ]
    }
  ]
}`;

            const response = await callClaudeAPI(prompt, '', 1500, false); // Reduced to avoid Netlify timeout

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the FIRST complete JSON object using proper brace matching
                const firstBrace = jsonText.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ü™Ñ [Quick] Skipping text before JSON:', jsonText.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Incomplete JSON object in AI response (no closing brace found).');
                }

                if (endPos < jsonText.length) {
                    console.log('ü™Ñ [Quick] Skipping text after JSON:', jsonText.substring(endPos, Math.min(endPos + 100, jsonText.length)));
                }

                jsonText = jsonText.substring(firstBrace, endPos);

                console.log('ü™Ñ [Quick] Extracted JSON length:', jsonText.length);

                // Sanitize JSON: Fix control characters in string values (same as wizard)
                let parsed;
                try {
                    parsed = JSON.parse(jsonText);
                } catch (firstError) {
                    console.warn('ü™Ñ [Quick] JSON parse failed, attempting sanitization...', firstError.message);

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonText = sanitized;
                    console.log('‚úÖ [Quick] JSON sanitized successfully');
                    parsed = JSON.parse(jsonText);
                }

                return parsed;
            } catch (e) {
                console.error('Failed to parse quick conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('üîß Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('‚úÖ JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('‚ùå Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Deep Mode: Detailed parsing with field extraction
        async function convertTextToTreeDeep(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            // SPECIAL CASE: Prompt Engineering pattern - improve the prompt instead of extracting
            if (pattern === 'prompting') {
                return await improvePromptWithAI(text, 'deep');
            }

            // Generate dynamic field extraction guide from pattern.fields
            function generateFieldExtractionGuide(pattern) {
                const patternDef = PATTERNS[pattern];
                const fields = patternDef.fields || {};

                let guide = `\n${patternDef.name.toUpperCase()} PATTERN - EXTRACT THESE FIELDS FOR EVERY ITEM:\n`;

                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];

                    // Skip non-field properties
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    if (fieldConfig.label) {
                        guide += `- ${fieldKey}: ${fieldConfig.label}`;

                        // Add extraction hints based on field type
                        if (fieldConfig.type === 'number') {
                            guide += ` (extract numeric value`;
                            if (fieldConfig.min !== undefined || fieldConfig.max !== undefined) {
                                guide += `, valid range ${fieldConfig.min || 0}-${fieldConfig.max || '‚àû'}`;
                            }
                            if (fieldConfig.step !== undefined) {
                                guide += `, use increments of ${fieldConfig.step}`;
                            }
                            guide += `)`;
                        } else if (fieldConfig.type === 'date') {
                            guide += ` (extract date, format as YYYY-MM-DD)`;
                        } else if (fieldConfig.type === 'select' && fieldConfig.options) {
                            guide += ` (choose from: ${fieldConfig.options.join(', ')})`;
                        } else if (fieldConfig.type === 'textarea') {
                            guide += ` (detailed text, 100-300 characters)`;
                        } else if (fieldConfig.type === 'text' && fieldConfig.placeholder) {
                            guide += ` (e.g., "${fieldConfig.placeholder}")`;
                        }

                        if (fieldConfig.helpText) {
                            guide += ` - ${fieldConfig.helpText}`;
                        }

                        guide += `\n`;
                    }
                });

                // Add item types
                if (patternDef.types && patternDef.types.length > 0) {
                    guide += `\nITEM TYPES FOR ${patternDef.name.toUpperCase()}: Use specific types from this list:\n`;
                    const typesList = patternDef.types.map(t => t.value).join(', ');
                    guide += typesList + '\n';
                    guide += `(NOT generic types - use the specific types above to categorize each item)\n`;
                }

                // Add PM tracking fields if pattern supports it
                if (fields.includeTracking && patternDef.fields.trackingFor) {
                    guide += `\nPM TRACKING FIELDS (for ${patternDef.fields.trackingFor.join('/')}s):\n`;
                    guide += `- pmStatus: Task status (choose from: To Do, In Progress, Blocked, Done)\n`;
                    guide += `- pmAssignee: Person responsible (if mentioned in text)\n`;
                    guide += `- pmProgress: Completion percentage (0-100)\n`;
                    guide += `- pmPriority: Priority level (Low, Medium, High, Critical)\n`;
                    guide += `- pmDueDate: Deadline (format YYYY-MM-DD if mentioned)\n`;
                    guide += `- pmStartDate: Start date (format YYYY-MM-DD if mentioned)\n`;
                }

                // Add dependencies hint
                if (fields.includeDependencies) {
                    guide += `\nDEPENDENCIES:\n`;
                    guide += `- Identify which ${levels.item}s depend on others\n`;
                    guide += `- Look for: "depends on", "requires", "after", "builds on", "assumes"\n`;
                    guide += `- Format as array of item IDs: ["item-0-1", "item-0-2"]\n`;
                }

                return guide;
            }

            const patternFieldGuide = generateFieldExtractionGuide(pattern);

            // Pattern-specific subtask guidance for Deep Mode
            function getDeepModeSubtaskGuidance(pattern) {
                const guidance = {
                    philosophy: `Philosophy: ${levels.subtask}s = premises, objections, supporting evidence, citations from source texts`,
                    sales: `Sales: ${levels.subtask}s = follow-up actions, meeting notes, deliverables, next steps to advance the deal`,
                    thesis: `Academic: ${levels.subtask}s = supporting arguments, citations, evidence, counter-arguments to address`,
                    roadmap: `Engineering: ${levels.subtask}s = implementation tasks, technical specs, acceptance criteria, testing steps`,
                    book: `Narrative: ${levels.subtask}s = individual scenes, character moments, plot developments, transitions`,
                    course: `Education: ${levels.subtask}s = lessons, activities, assessments, practice exercises, readings`,
                    film: `Film: ${levels.subtask}s = specific shots, camera angles, lighting changes, actor blocking, technical details`,
                    prompting: `Prompting: ${levels.subtask}s = test cases, edge cases, variations to handle, example inputs/outputs`,
                    generic: `${levels.subtask}s = steps, components, or sub-elements needed to complete the ${levels.item}`
                };
                return guidance[pattern] || guidance.generic;
            }

            // Pattern-specific extraction instructions
            function getPatternSpecificInstructions(pattern) {
                const instructions = {
                    film: `
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ö†Ô∏è AI VIDEO PRODUCTION - CRITICAL INSTRUCTIONS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

YOU ARE CREATING ACTUAL VIDEO SCENES, NOT META-WORKFLOWS!

üé¨ WHAT TO CREATE:
- Each item = ONE SPECIFIC SHOT/SCENE
- Describe WHAT APPEARS IN THE FRAME
- Include: subject, action, camera movement, lighting, mood

‚ùå DO NOT CREATE:
- Workflows about "creating prompts"
- Meta-tasks like "Generate a prompt for..."
- Process steps like "Use Sora to..."
- Planning tasks like "Write description of..."

‚úÖ CORRECT EXAMPLE (user says "drone flight over data center"):
{
  "phases": [{
    "name": "Establishing Sequence",
    "items": [
      {
        "name": "Wide aerial establishing shot",
        "description": "Camera starts at 500 feet showing vast data center campus in Saskatchewan plains",
        "videoPrompt": "Aerial drone shot ascending from ground level, revealing massive data center facility surrounded by snow-covered farmland. Wide establishing shot showing geometric rows of server buildings with steam rising from cooling towers. Camera rises smoothly from 50 feet to 200 feet over 10 seconds. Golden hour lighting with long shadows across white landscape. Cinematic widescreen aesthetic.",
        "aiPlatform": "Veo 3 (Google)",
        "visualStyle": "Cinematic",
        "duration": "10 seconds",
        "aspectRatio": "16:9 (Widescreen)",
        "cameraMovement": "Crane Up",
        "motionIntensity": "Moderate",
        "lightingMood": "Golden Hour"
      },
      {
        "name": "Dolly shot of server building exterior",
        "description": "Close-up tracking shot along reflective glass facade",
        "videoPrompt": "Slow dolly right along mirrored glass exterior of data center building. Reflections of winter sky and clouds move across glass surface. Camera tracks steadily at 6 feet height, revealing geometric patterns of windows and air vents. Overcast lighting with soft shadows. Modern architectural aesthetic. 6-second clip.",
        "cameraMovement": "Tracking Shot",
        "duration": "6 seconds"
      }
    ]
  }]
}

‚ùå WRONG EXAMPLE (meta-workflow - DO NOT DO THIS):
{
  "phases": [{
    "name": "Content Creation",
    "items": [
      {
        "name": "Introduction Prompt",
        "description": "Create a natural language prompt for an introductory segment"  ‚ùå NO!
      },
      {
        "name": "Generate Drone Tour",
        "description": "Use Sora to produce drone footage"  ‚ùå NO!
      }
    ]
  }]
}

üé• FOR EACH SCENE ITEM:
1. **name**: Short description of the shot (e.g., "Aerial reveal of campus")
2. **description**: What happens in the scene (action, subjects, context)
3. **videoPrompt**: DETAILED 100-300 character prompt describing:
   - What appears in frame
   - Camera movement and framing
   - Lighting and mood
   - Visual style
   - Duration
4. **aiPlatform**: Which AI to use (Sora, Veo 3, Runway, Pika)
5. **cameraMovement**: How camera moves (Dolly In, Crane Up, Tracking Shot, etc.)
6. **visualStyle**: Cinematic, Documentary, Photorealistic, etc.
7. **lightingMood**: Golden Hour, Dramatic, Soft Natural, etc.
8. **duration**: How long (2s, 4s, 6s, 10s, 20s)
9. **aspectRatio**: 16:9, 9:16, 2.39:1, etc.

REMEMBER: You are a cinematographer, not a project planner!
Describe the ACTUAL SHOTS, not the process of creating them.
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
`
                };

                return instructions[pattern] || '';
            }

            const patternSpecificInstructions = getPatternSpecificInstructions(pattern);

            const prompt = `Convert this text into a detailed hierarchical project structure using the "${patternConfig.name}" pattern.

PATTERN HIERARCHY (4 LEVELS):
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}
${patternFieldGuide}
${patternSpecificInstructions}

TEXT TO ANALYZE:
${text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
DEEP MODE INSTRUCTIONS - COMPREHENSIVE EXTRACTION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ö†Ô∏è CRITICAL REQUIREMENTS - YOU MUST MEET THESE MINIMUMS:

1. PHASES: Create 3-6 phases (${levels.phase}s)
   ‚Üí Do NOT summarize into fewer phases
   ‚Üí Each major section/movement/chapter = separate phase

2. ITEMS PER PHASE: REQUIRED MINIMUM 3-8 items (${levels.item}s) per phase
   ‚Üí Do NOT create just 1 item per phase
   ‚Üí Extract ALL significant claims/arguments/features/sections
   ‚Üí Each distinct idea/component/argument = separate item

3. SUBTASKS: Add 2-5 ${levels.subtask}s to items that need decomposition
   ‚Üí ${levels.subtask}s are pattern-specific breakdowns of each ${levels.item}
   ‚Üí ${getDeepModeSubtaskGuidance(pattern)}
   ‚Üí Only skip ${levels.subtask}s for truly atomic items that cannot be decomposed

4. DEPTH: Go 3-4 levels deep in the hierarchy
   ‚Üí Phase ‚Üí Item ‚Üí Subtask ‚Üí (nested subtask if needed)
   ‚Üí Do NOT stop at 2 levels

5. FIELD POPULATION: Extract ALL pattern-specific field values listed above
   ‚Üí Populate EVERY field mentioned in the "${patternConfig.name.toUpperCase()}" pattern section
   ‚Üí Do NOT leave fields empty if information is available in the text
   ‚Üí If exact value not in text, make intelligent estimates (for word counts, story points, etc.)
   ‚Üí For dates, use YYYY-MM-DD format

6. DEPENDENCIES: Identify ALL logical prerequisites
   ‚Üí Look for: "depends on", "requires", "builds on", "follows from", "assumes", "after"
   ‚Üí Format: ["item-X-Y", "item-Z-W"]
   ‚Üí Map both intra-phase and inter-phase dependencies

7. NODE TYPES: Use specific types from the "${patternConfig.name.toUpperCase()}" item type list above
   ‚Üí Use the EXACT type values provided (not generic categories)
   ‚Üí Different items should have different types based on their function
   ‚Üí Do NOT use the same type for every item

8. DESCRIPTIONS: Write detailed descriptions (100-250 characters)
   ‚Üí Capture nuance, context, and significance
   ‚Üí NOT just repetition of title

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
EXAMPLE OF PROPER DEPTH (Philosophy Pattern)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

If text contains: "Socrates asks: What is justice? Callias replies it is giving each what they are owed. Socrates refutes this with the mad debtor example."

WRONG (too shallow):
{
  "phases": [{
    "name": "Movement 1",
    "items": [{"name": "Discussion of justice"}]
  }]
}

CORRECT (proper depth):
{
  "phases": [{
    "name": "Movement 1",
    "subtitle": "The Initial Inquiry",
    "items": [
      {
        "name": "Opening Question: What is Justice?",
        "itemType": "question",
        "speaker": "Socrates",
        "description": "Socrates initiates inquiry by asking Callias to define justice",
        "keyTerms": "justice, definition",
        "dependencies": []
      },
      {
        "name": "First Definition: Justice as Giving What is Owed",
        "itemType": "definition",
        "speaker": "Callias",
        "description": "Callias proposes justice means giving each person what they are owed",
        "keyTerms": "justice, debt, obligation",
        "dependencies": []
      },
      {
        "name": "Refutation via Mad Debtor Counterexample",
        "itemType": "refutation",
        "speaker": "Socrates",
        "argumentType": "Socratic Elenchus",
        "description": "Socrates refutes Callias's definition using case of returning sword to madman",
        "dependencies": ["item-0-1"],
        "subItems": [
          {
            "name": "Premise: Returning sword to madman is dangerous",
            "itemType": "premise",
            "premise1": "The madman is owed the sword (per Callias's definition)",
            "conclusion": "But returning it would be unjust (harmful)",
            "description": "Creates contradiction in Callias's definition"
          },
          {
            "name": "Conclusion: Definition is insufficient",
            "itemType": "conclusion",
            "description": "Justice cannot be merely giving what is owed, circumstances matter",
            "dependencies": ["subtask-0-2-0"]
          }
        ]
      }
    ]
  }]
}

See the difference? The CORRECT version:
‚úì Has 3 items (not 1)
‚úì Uses specific item types (question, definition, refutation)
‚úì Populates fields (speaker, argumentType, keyTerms, premises)
‚úì Has subtasks with proper nesting
‚úì Maps dependencies between nodes

THIS IS THE LEVEL OF DETAIL REQUIRED IN DEEP MODE.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FINAL REMINDER
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Deep Mode = COMPREHENSIVE EXTRACTION, not summarization
Extract EVERYTHING with maximum granularity and detail
Aim for 25-40 total nodes for complex texts (Haiku's 4096 token limit)

JSON FORMATTING RULES (CRITICAL - FOLLOW EXACTLY):
- NO trailing commas after the last element in arrays or objects
- NO line breaks or tabs inside string values - use spaces instead
- NO unescaped quotes inside strings
- ONLY plain JSON - no markdown code blocks, no backticks, no explanations
- Start response with { and end with }

CORRECT EXAMPLE (note: NO trailing comma after last item):
{"phases": [{"name": "Test", "items": [{"name": "Item"}]}]}

WRONG (trailing comma):
{"phases": [{"name": "Test", "items": [{"name": "Item"},]}]}

Respond with ONLY valid, parseable JSON:
{
  "projectName": "Extracted or inferred project name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle",
      "icon": "üìã",
      "items": [
        {
          "name": "Item name",
          "description": "Detailed description",
          "itemType": "category",
          "cost": 1000,
          "dependencies": ["item-0-1", "item-1-2"],
          "subtasks": [
            {
              "name": "Subtask name",
              "description": "What needs to be done",
              "dependencies": []
            }
          ],
          "... other pattern-specific fields ...": "values"
        }
      ]
    }
  ]
}`;

            // Deep Mode: Higher limits with extended thinking (uses direct API fallback if needed)
            const response = await callClaudeAPI(prompt, '', 8192, true); // 8192 tokens + extended thinking for comprehensive analysis

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the FIRST complete JSON object using proper brace matching
                const firstBrace = jsonText.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ü™Ñ [Deep] Skipping text before JSON:', jsonText.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Incomplete JSON object in AI response (no closing brace found).');
                }

                if (endPos < jsonText.length) {
                    console.log('ü™Ñ [Deep] Skipping text after JSON:', jsonText.substring(endPos, Math.min(endPos + 100, jsonText.length)));
                }

                jsonText = jsonText.substring(firstBrace, endPos);

                console.log('ü™Ñ [Deep] Extracted JSON length:', jsonText.length);

                // Sanitize JSON: Fix control characters in string values (same as wizard)
                let parsed;
                try {
                    parsed = JSON.parse(jsonText);
                } catch (firstError) {
                    console.warn('ü™Ñ [Deep] JSON parse failed, attempting sanitization...', firstError.message);

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonText = sanitized;
                    console.log('‚úÖ [Deep] JSON sanitized successfully');
                    parsed = JSON.parse(jsonText);
                }

                return parsed;
            } catch (e) {
                console.error('Failed to parse deep conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('üîß Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('‚úÖ JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('‚ùå Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Main Analyze button handler
        document.getElementById('analysis-start-btn').addEventListener('click', async () => {
            // Get text from file or textarea
            const textFromTextarea = document.getElementById('analysis-text-input').value.trim();
            let finalText = analysisText || textFromTextarea;

            if (!finalText) {
                alert('Please upload a file or paste text to analyze.');
                return;
            }

            // Get global AI mode
            const mode = getGlobalAIMode();

            // Check if AI is disabled
            if (mode === 'off') {
                alert('‚ùå AI features are currently disabled.\n\nPlease enable AI mode in the header (ü§ñ AI Mode dropdown) to use text analysis.');
                return;
            }

            // Auto-truncate very long texts to prevent timeouts
            // Different limits for Quick vs Deep Mode
            const MAX_CHARS_QUICK = 100000; // ~25,000 words for Quick Mode
            const MAX_CHARS_DEEP = 300000;  // ~75,000 words for Deep Mode (with user API key, no timeout)
            const MAX_CHARS = mode === 'deep' ? MAX_CHARS_DEEP : MAX_CHARS_QUICK;

            let wasTruncated = false;
            if (finalText.length > MAX_CHARS) {
                wasTruncated = true;
                finalText = finalText.substring(0, MAX_CHARS);
                console.warn(`‚ö†Ô∏è Text truncated from ${analysisText.length} to ${MAX_CHARS} characters for ${mode} mode`);
            }

            // Check if Deep Mode requires user's own API key
            if (mode === 'deep') {
                const userApiKey = getLocalAPIKey();
                if (!userApiKey) {
                    alert('üî¨ Deep Mode requires your own Anthropic API key.\n\nWhy?\n‚Ä¢ Deep Mode uses more tokens and takes longer\n‚Ä¢ Prevents timeout on Netlify free tier (10s limit)\n‚Ä¢ You only pay for what you use\n\nPlease:\n1. Click the üîë API Key button\n2. Enter your Anthropic API key\n3. Try Deep Mode again\n\nQuick Mode is available without an API key.');
                    return;
                }
                console.log('‚úÖ Deep Mode: Using your API key (bypasses rate limits and timeouts)');
            }

            // Warn if text was truncated
            if (wasTruncated) {
                const proceed = confirm(`‚ö†Ô∏è Your text is very long and has been automatically truncated to ${MAX_CHARS} characters (~${Math.floor(MAX_CHARS/4)} words) to prevent timeouts.\n\nOnly the first portion will be analyzed.\n\nDo you want to continue?`);
                if (!proceed) {
                    return;
                }
            }

            // Close analysis modal and show loading modal
            document.getElementById('analysis-modal').style.display = 'none';
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'üîç Analyzing Text...';
            modal.style.display = 'flex';

            // Check if user pre-selected a specific pattern
            const preSelectedPattern = document.getElementById('analysis-pattern-select').value;

            try {
                let selectedPattern;

                // If user chose a specific pattern, skip detection and use that pattern directly
                if (preSelectedPattern && preSelectedPattern !== 'auto') {
                    selectedPattern = preSelectedPattern;
                    console.log(`‚úÖ Using pre-selected pattern: ${selectedPattern}`);

                    // Step 2: Convert text to tree (skip pattern detection)
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 1/2: Converting text to tree structure...</p>';

                    let treeData;
                    if (mode === 'quick') {
                        treeData = await convertTextToTreeQuick(finalText, selectedPattern);
                    } else {
                        treeData = await convertTextToTreeDeep(finalText, selectedPattern);
                    }

                    // Step 3: Preview and import
                    showAnalysisPreview(treeData, selectedPattern, analysisAppendMode);
                    return; // Exit early - we're done!
                }

                // Otherwise, proceed with auto-detection
                modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 1/3: Detecting optimal pattern...</p>';

                // Step 1: Detect pattern
                const recommendations = await detectPattern(finalText);

                // Show pattern selection
                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <h3 style="margin-bottom: 16px; color: var(--text-primary);">üìä Recommended Patterns</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px; font-size: 14px;">
                            AI analyzed your text and recommends these patterns. Select one to continue:
                        </p>
                        <div id="pattern-recommendations" style="display: flex; flex-direction: column; gap: 12px;">
                            ${recommendations.map((rec, index) => `
                                <label style="display: flex; align-items: flex-start; padding: 16px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s; background: var(--card-bg);" class="pattern-rec-option" data-pattern="${rec.pattern}">
                                    <input type="radio" name="selected-pattern" value="${rec.pattern}" ${index === 0 ? 'checked' : ''} style="margin-top: 4px; margin-right: 12px;" />
                                    <div style="flex: 1;">
                                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                            <span style="font-weight: 600; color: var(--text-primary); font-size: 15px;">${rec.patternName}</span>
                                            <span style="background: ${rec.confidence >= 8 ? '#4caf50' : rec.confidence >= 6 ? '#ff9f43' : '#666'}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">
                                                ${rec.confidence}/10 confidence
                                            </span>
                                        </div>
                                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                            ${rec.reasoning}
                                        </div>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                        <div style="margin-top: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">
                                Analysis Mode: ${mode === 'quick' ? '‚ö° Quick Mode' : 'üî¨ Deep Mode'}
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary);">
                                ${mode === 'quick' ? 'Fast analysis with basic structure extraction.' : 'Detailed analysis with field extraction and dependencies.'}
                            </div>
                        </div>
                    </div>
                `;

                // Add hover effects to pattern options
                document.querySelectorAll('.pattern-rec-option').forEach(option => {
                    option.addEventListener('mouseenter', () => {
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                    option.addEventListener('mouseleave', () => {
                        const radio = option.querySelector('input[type="radio"]');
                        if (!radio.checked) {
                            option.style.borderColor = 'var(--border)';
                            option.style.background = 'var(--card-bg)';
                        }
                    });
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.pattern-rec-option').forEach(opt => {
                            opt.style.borderColor = 'var(--border)';
                            opt.style.background = 'var(--card-bg)';
                        });
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                });

                // Update modal footer with continue button
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="pattern-select-cancel">Cancel</button>
                    <button class="btn btn-primary" id="pattern-select-continue" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Continue ‚Üí</button>
                `;

                document.getElementById('pattern-select-cancel').addEventListener('click', () => {
                    modal.style.display = 'none';
                });

                document.getElementById('pattern-select-continue').addEventListener('click', async () => {
                    const selectedPattern = document.querySelector('input[name="selected-pattern"]:checked').value;

                    // Step 2: Convert text to tree
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 2/3: Converting text to tree structure...</p>';
                    document.querySelector('#modal .modal-footer').innerHTML = '';

                    try {
                        let treeData;
                        if (mode === 'quick') {
                            treeData = await convertTextToTreeQuick(finalText, selectedPattern);
                        } else {
                            treeData = await convertTextToTreeDeep(finalText, selectedPattern);
                        }

                        // Step 3: Preview and import
                        showAnalysisPreview(treeData, selectedPattern, analysisAppendMode);

                    } catch (error) {
                        modalBody.innerHTML = `
                            <div style="padding: 20px; text-align: center;">
                                <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                                <h3 style="color: #f44336; margin-bottom: 12px;">Analysis Failed</h3>
                                <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                            </div>
                        `;
                        document.querySelector('#modal .modal-footer').innerHTML = `
                            <button class="btn" id="error-close">Close</button>
                            <button class="btn btn-primary" id="error-retry">Try Again</button>
                        `;

                        document.getElementById('error-close').addEventListener('click', () => {
                            modal.style.display = 'none';
                        });

                        document.getElementById('error-retry').addEventListener('click', () => {
                            modal.style.display = 'none';
                            document.getElementById('analyze-text-btn').click();
                        });
                    }
                });

            } catch (error) {
                modalBody.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                        <h3 style="color: #f44336; margin-bottom: 12px;">Pattern Detection Failed</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                    </div>
                `;
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="error-close">Close</button>
                `;

                document.getElementById('error-close').addEventListener('click', () => {
                    modal.style.display = 'none';
                });
            }
        });

        // Show preview before importing
        function showAnalysisPreview(treeData, selectedPattern, appendMode = false) {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            document.getElementById('modal-title').textContent = '‚úÖ Analysis Complete - Preview';

            // Count phases and items
            const phaseCount = treeData.phases?.length || 0;
            const itemCount = treeData.phases?.reduce((sum, phase) => sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, #4caf50, #00a67d); color: white; padding: 20px; border-radius: 12px; margin-bottom: 24px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 8px;">‚ú®</div>
                        <h2 style="margin-bottom: 8px; font-size: 24px;">${treeData.projectName || 'Analyzed Project'}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Pattern: ${PATTERNS[selectedPattern].name}</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${phaseCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Phases Detected</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${itemCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Items Created</div>
                        </div>
                    </div>

                    <div style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 16px; background: var(--bg-secondary);">
                        <h4 style="margin-bottom: 12px; color: var(--text-primary);">Structure Preview:</h4>
                        ${treeData.phases?.map((phase, i) => `
                            <div style="margin-bottom: 16px;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px;">
                                    ${phase.icon || 'üìã'} ${phase.name}
                                </div>
                                <div style="margin-left: 20px; font-size: 13px; color: var(--text-secondary);">
                                    ${phase.items?.slice(0, 3).map(item => `‚Ä¢ ${item.name}`).join('<br>')}
                                    ${phase.items?.length > 3 ? `<br>... and ${phase.items.length - 3} more items` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-top: 20px; padding: 12px 16px; background: rgba(${appendMode ? '76, 175, 80' : '255, 159, 67'}, 0.1); border: 1px solid rgba(${appendMode ? '76, 175, 80' : '255, 159, 67'}, 0.3); border-radius: 6px;">
                        <div style="color: ${appendMode ? '#4caf50' : '#ff9f43'}; font-weight: 600; margin-bottom: 4px;">${appendMode ? '‚ûï Append Mode' : '‚ö†Ô∏è Replace Mode'}</div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            ${appendMode ?
                                'This will add the analyzed content to your existing tree. Phases will be merged or added.' :
                                'Importing will replace your current project. Your current project will be saved as a backup first.'}
                        </div>
                    </div>
                </div>
            `;

            // Create buttons directly with event listeners attached
            const modalFooter = document.querySelector('#modal .modal-footer');
            if (!modalFooter) {
                console.error('‚ùå Modal footer not found!');
                alert('Error: Modal footer not found. Please refresh the page.');
                return;
            }

            // Clear existing content
            modalFooter.innerHTML = '';

            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => {
                console.log('üö´ Import cancelled');
                modal.style.display = 'none';
            };

            // Create import button
            const importBtn = document.createElement('button');
            importBtn.className = 'btn btn-primary';
            importBtn.style.cssText = 'background: linear-gradient(135deg, #4caf50, #00a67d);';
            importBtn.textContent = appendMode ? '‚ûï Append to Tree' : 'üì• Import to TreeListy';
            importBtn.onclick = () => {
                console.log('üîÑ Import button clicked!', { hasTreeData: !!treeData, hasPattern: !!selectedPattern, appendMode });
                try {
                    importAnalyzedTree(treeData, selectedPattern, appendMode);
                    modal.style.display = 'none';
                } catch (error) {
                    console.error('‚ùå Import failed:', error);
                    alert('Import failed: ' + error.message);
                }
            };

            // Add buttons to footer
            modalFooter.appendChild(cancelBtn);
            modalFooter.appendChild(importBtn);

            console.log('‚úÖ Preview modal ready with import button');
        }

        // Import analyzed tree into TreeListy
        function importAnalyzedTree(treeData, selectedPattern, appendMode = false) {
            console.log('üì• Starting import...', { treeData, selectedPattern, appendMode });

            // Save state for undo
            saveState(appendMode ? 'Analyze Text: Append' : 'Analyze Text: Import');

            // Backup current project first
            const backup = JSON.stringify(capexTree, null, 2);
            const backupName = `treelisty_backup_${Date.now()}.json`;
            console.log('üíæ Current project backed up as:', backupName);

            // Switch to selected pattern (only if not appending)
            if (!appendMode) {
                currentPattern = selectedPattern;
                document.getElementById('pattern-select').value = selectedPattern;
            }

            // Convert analyzed data to TreeListy format
            const newTree = {
                type: 'root',
                id: 'root',
                name: treeData.projectName || 'Analyzed Project',
                icon: 'üå≤',
                expanded: true,
                children: treeData.phases?.map((phase, phaseIndex) => ({
                    type: 'phase',
                    id: `phase-${phaseIndex}`,
                    phase: phaseIndex,
                    name: phase.name,
                    subtitle: phase.subtitle || PATTERNS[selectedPattern].phaseSubtitles?.[phaseIndex] || '',
                    icon: phase.icon || 'üìã',
                    expanded: true,
                    cost: 0,
                    items: phase.items?.map((item, itemIndex) => {
                        const itemId = `item-${phaseIndex}-${itemIndex}`;

                        // Build item object with all required fields
                        const itemObj = {
                            type: 'item',
                            id: itemId,
                            name: item.name,
                            description: item.description || '',
                            itemType: item.itemType || '',
                            icon: item.icon || 'üìÑ',
                            cost: item.cost || 0,
                            dependencies: item.dependencies || [],
                            notes: item.notes || '',
                            leadTime: item.leadTime || '',
                            alternateSource: item.alternateSource || '',
                            expanded: false,
                            // Pattern-specific fields
                            dealValue: item.dealValue || 0,
                            wordCount: item.wordCount || 0,
                            storyPoints: item.storyPoints || 0,
                            // Add any other fields from AI
                            ...item
                        };

                        // Add subtasks if they exist (3rd level hierarchy)
                        if (item.subtasks && item.subtasks.length > 0) {
                            itemObj.children = item.subtasks.map((subtask, subtaskIndex) => ({
                                type: 'subtask',
                                id: `subtask-${phaseIndex}-${itemIndex}-${subtaskIndex}`,
                                name: subtask.name || subtask,
                                description: subtask.description || '',
                                icon: subtask.icon || 'üìå',
                                notes: subtask.notes || '',
                                dependencies: subtask.dependencies || [],
                                // Pattern-specific fields
                                ...subtask
                            }));
                        }

                        return itemObj;
                    }) || []
                })) || []
            };

            if (appendMode) {
                // Append mode: merge phases and items
                console.log('‚ûï Append mode: merging trees...');

                // Keep existing project name if different
                if (capexTree.name !== newTree.name && capexTree.name !== 'My Project') {
                    // User has a custom name, keep it
                } else {
                    capexTree.name = newTree.name;
                }

                // Merge phases
                newTree.children.forEach((newPhase, newPhaseIndex) => {
                    // Find matching phase in existing tree by index or name
                    const existingPhase = capexTree.children?.[newPhaseIndex];

                    if (existingPhase) {
                        // Phase exists - append items to it
                        console.log(`Appending ${newPhase.items?.length || 0} items to existing phase: ${existingPhase.name}`);

                        // Update phase name if it was generic
                        if (existingPhase.name === `Phase ${newPhaseIndex}` && newPhase.name !== `Phase ${newPhaseIndex}`) {
                            existingPhase.name = newPhase.name;
                        }

                        // Append new items
                        if (newPhase.items && newPhase.items.length > 0) {
                            const currentItemCount = existingPhase.items?.length || 0;

                            // Re-ID the new items to avoid conflicts
                            const reIdedItems = newPhase.items.map((item, idx) => ({
                                ...item,
                                id: `item-${newPhaseIndex}-${currentItemCount + idx}`
                            }));

                            existingPhase.items = [...(existingPhase.items || []), ...reIdedItems];
                        }
                    } else {
                        // Phase doesn't exist - add it as new
                        console.log(`Adding new phase: ${newPhase.name}`);
                        if (!capexTree.children) capexTree.children = [];

                        // Re-ID the phase
                        newPhase.id = `phase-${capexTree.children.length}`;
                        newPhase.phase = capexTree.children.length;

                        capexTree.children.push(newPhase);
                    }
                });

                // Show success message for append
                const addedItems = treeData.phases?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0;
                const addedSubtasks = treeData.phases?.reduce((sum, p) =>
                    sum + (p.items?.reduce((subSum, item) => subSum + (item.subtasks?.length || 0), 0) || 0), 0) || 0;

                let message = `‚úÖ Successfully appended!\n\n${addedItems} items`;
                if (addedSubtasks > 0) {
                    message += ` and ${addedSubtasks} subtasks`;
                }
                message += ` have been added to your existing tree.`;
                alert(message);

            } else {
                // Replace mode: completely replace tree
                console.log('üîÑ Replace mode: replacing tree...');
                capexTree = newTree;

                // Show success message for replace
                const totalItems = treeData.phases?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0;
                const totalSubtasks = treeData.phases?.reduce((sum, p) =>
                    sum + (p.items?.reduce((subSum, item) => subSum + (item.subtasks?.length || 0), 0) || 0), 0) || 0;

                let message = `‚úÖ Successfully imported!\n\n${treeData.phases?.length || 0} phases and ${totalItems} items`;
                if (totalSubtasks > 0) {
                    message += ` and ${totalSubtasks} subtasks`;
                }
                message += ` have been created.\n\nPattern: ${PATTERNS[selectedPattern].name}`;
                alert(message);
            }

            // Render
            render();

            // Auto-select first item to show detail panel
            // Find the first item in the tree
            let firstItem = null;
            if (capexTree.children && capexTree.children.length > 0) {
                for (const phase of capexTree.children) {
                    if (phase.items && phase.items.length > 0) {
                        firstItem = phase.items[0];
                        break;
                    }
                }
            }

            // Show detail panel for first item if found
            if (firstItem) {
                console.log('üìã Auto-selecting first item for detail panel:', firstItem.name);
                showInfo(firstItem);
            }
        }

        // How to Use button
        document.getElementById('how-to-btn').addEventListener('click', () => {
            const modal = document.getElementById('modal');
            document.getElementById('modal-title').textContent = 'üìñ How to Use TreeListy';
            document.getElementById('modal-body').innerHTML = `
                <div style="padding: 20px; line-height: 1.8;">
                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">üí° What is TreeListy?</h3>
                    <p style="margin-bottom: 20px; font-size: 14px;">
                        <strong>TreeListy</strong> is a universal tool for breaking down any complex project, problem, or process into manageable parts.
                        Structure your work into phases, track dependencies between components, and analyze your entire plan at a glance.
                        Use it for software projects, sales pipelines, academic writing, product roadmaps, AI prompt design, or anything else that benefits from structured thinking! üå≥‚ú®üéØ
                    </p>

                    <h3 style="color: var(--phase-1); margin-bottom: 16px; font-size: 20px;">üöÄ Quick Start</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-1);">
                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>1. Choose Your Pattern</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ Use the Pattern dropdown (top) to select your project type:</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">üìã Generic Project, üíº Sales Pipeline, üéì Academic Writing, üöÄ Product Roadmap</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">üìö Book Writing, üß† AI Prompt Design, üèõÔ∏è Philosophy, üí° Strategic Planning</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">üé¨ Film Production, üìß Email Workflow <em>(NEW!)</em>, üíæ File System</p>
                        <p style="font-size: 12px; margin-bottom: 12px; padding-left: 16px;">...and more! (15 specialized patterns total)</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>2. Build Your Tree (3 Ways)</strong></p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">üßô AI Wizard (Easiest!)</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">‚Ä¢ Click "üßô AI Wizard" button in toolbar</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">‚Ä¢ Describe your project in plain language</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">‚Ä¢ AI asks strategic questions and builds your tree</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">‚Ä¢ Works for new trees or enhancing existing ones!</p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">üìÑ Analyze Text</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">‚Ä¢ Click "üìÑ Analyze Text" button</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">‚Ä¢ Paste any document (plans, specs, articles)</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">‚Ä¢ Choose Quick Mode (fast) or Deep Mode (thorough)</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">‚Ä¢ Can append to existing trees or replace completely</p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">‚úã Manual Creation</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">‚Ä¢ Right-click on any Phase ‚Üí "Add Item"</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">‚Ä¢ Fill in fields manually with full control</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>3. Use Smart Features</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>AI Review üî¨</strong> - Click "üî¨ AI Review" for comprehensive tree analysis</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Smart Suggest üí°</strong> - Right-click any field ‚Üí Choose "‚ú® AI Suggest" or "üí° Quick Suggest"</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Dependencies</strong> - Edit an item ‚Üí Check boxes in Dependencies section</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>AI Analysis ü§ñ</strong> - Click any item ‚Üí "AI Analysis" for insights</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ <strong>Undo</strong> - Click "‚Ü©Ô∏è Undo" or press Ctrl+Z (Cmd+Z on Mac)</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>4. Navigate & View</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Expand/Collapse</strong> - Click "‚¨áÔ∏è Expand" or "‚¨ÜÔ∏è Collapse" buttons</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Click nodes</strong> to expand/collapse individually or view details</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ <strong>Pan/Zoom</strong> - Use mouse wheel or pan controls</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>5. Export & Share</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>üìù Generate Prompt</strong> - Export as AI-ready prompt (for Claude, GPT, etc.)</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>üìä Export Excel</strong> - Professional multi-sheet workbook</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>üì• Import Excel</strong> - Import Excel files back into TreeListy</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>üíæ Save/Load</strong> - Save as JSON and reload anytime</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ <strong>üîó Share</strong> - Generate shareable URL</p>
                    </div>

                    <h3 style="color: var(--phase-2); margin-bottom: 16px; font-size: 20px;">ü§ñ AI-Powered Features</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-2);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üßô AI Wizard</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ <strong>Interactive project building</strong> - AI asks strategic questions<br>
                            ‚Ä¢ <strong>Conversational interface</strong> - Just describe what you need<br>
                            ‚Ä¢ <strong>Enhance mode</strong> - Add to existing trees without starting over<br>
                            ‚Ä¢ <strong>Real-time preview</strong> - Watch your tree build in the side panel<br>
                            ‚Ä¢ <strong>Smart Merge protection</strong> - Never loses your existing data<br>
                            ‚Ä¢ <strong>Auto-recovery</strong> - Handles errors gracefully
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üìÑ Analyze Text</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ <strong>Quick Mode</strong> - Fast analysis (2-4K tokens) for straightforward documents<br>
                            ‚Ä¢ <strong>Deep Mode</strong> - Extended thinking (5000 token budget) for complex analysis<br>
                            ‚Ä¢ <strong>Append Mode</strong> - Combine multiple document analyses<br>
                            ‚Ä¢ <strong>Pattern-specific extraction</strong> - Philosophy extracts premises, Sales extracts deals, etc.<br>
                            ‚Ä¢ <strong>Prompt improvement</strong> - AI Prompt pattern turns basic prompts into comprehensive ones
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üî¨ AI Review & Enhance</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ <strong>Comprehensive tree analysis</strong> - Reviews entire tree for completeness, logic, and flow<br>
                            ‚Ä¢ <strong>Pattern-aware review</strong> - Checks alignment with pattern best practices<br>
                            ‚Ä¢ <strong>Actionable suggestions</strong> - Get specific recommendations for improvements<br>
                            ‚Ä¢ <strong>Gap identification</strong> - Finds missing phases, items, or subtasks<br>
                            ‚Ä¢ <strong>Quality assessment</strong> - Identifies redundancies and structural issues
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üí° Smart Suggest (Dual Modes)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ <strong>‚ú® AI Suggest</strong> - Context-aware suggestions with pattern expertise (Philosophy prof, Sales strategist, etc.)<br>
                            ‚Ä¢ <strong>üí° Quick Suggest</strong> - Instant static templates for common fields<br>
                            ‚Ä¢ <strong>Pattern intelligence</strong> - Philosophy gets premises/objections, Sales gets follow-ups, Film gets Sora/Veo prompts<br>
                            ‚Ä¢ <strong>Right-click any field</strong> - Choose your mode and watch AI fill in intelligent suggestions<br>
                            ‚Ä¢ <strong>Fallback protection</strong> - Auto-switches to Quick mode if AI fails
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üìù Generate Prompt</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ <strong>Export as AI prompt</strong> - Use with Claude, GPT-4, or any LLM<br>
                            ‚Ä¢ <strong>Pattern-aware formatting</strong> - Adapts to your project type<br>
                            ‚Ä¢ <strong>Executable prompts</strong> - AI Prompt pattern creates paste-ready prompts (not meta-docs)<br>
                            ‚Ä¢ <strong>Copy to clipboard</strong> - One-click copy for easy sharing<br>
                            ‚Ä¢ <strong>Complete context</strong> - Includes all phases, items, and subtasks
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ü§ñ AI Analysis (Per Item)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ <strong>Risk assessments</strong> - Identify potential issues<br>
                            ‚Ä¢ <strong>Cost optimization</strong> - Compare with similar items<br>
                            ‚Ä¢ <strong>Strategic insights</strong> - Powered by your chosen AI model<br>
                            ‚Ä¢ <strong>Pattern-specific analysis</strong> - Tailored to your project type
                        </p>
                    </div>

                    <h3 style="color: var(--phase-1); margin-bottom: 16px; font-size: 20px;">üîë AI Providers & API Keys</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-1);">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy supports multiple AI providers!</strong> Choose the model that fits your needs.
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ü§ñ Available Providers</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Anthropic Claude</strong> - Haiku 4.0 (fast, cheap) & Sonnet 4.5 (powerful, extended thinking)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Google Gemini</strong> - 1.5 Flash (fast) & 1.5 Pro (thorough)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ <strong>OpenAI ChatGPT</strong> - GPT-4o mini (fast) & GPT-4o (powerful)</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üîê API Key Setup</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ Click <strong>üîë Set API Key</strong> button in header</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ Enter your API key from Anthropic, Google, or OpenAI</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ Keys are stored in <strong>localStorage</strong> (persist across sessions)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ Get keys at: console.anthropic.com, aistudio.google.com, or platform.openai.com</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">‚ö° Rate Limits & Costs</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Server API key (default)</strong> - 200 requests/hour, 8192 max tokens per request</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Your API key</strong> - Unlimited requests (you pay for usage)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Extended Thinking</strong> - Deep Mode uses 5000 token thinking budget + response (Sonnet 4.5 only)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ <strong>Tip</strong> - Use your own key to bypass rate limits and get faster responses</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üß† Extended Thinking Mode</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Available when using <strong>Sonnet 4.5</strong> in <strong>Deep Mode</strong><br>
                            ‚Ä¢ AI thinks for up to 5000 tokens before responding<br>
                            ‚Ä¢ Better reasoning, fewer errors, more comprehensive analysis<br>
                            ‚Ä¢ Ideal for complex trees, AI Review, and prompt improvement<br>
                            ‚Ä¢ Costs more but delivers significantly higher quality
                        </p>
                    </div>

                    <h3 style="color: var(--phase-3); margin-bottom: 16px; font-size: 20px;">üìä Presentations & Sharing</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-3);">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy is perfect for investor meetings and stakeholder presentations!</strong>
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üéØ Visual Impact</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ Use "‚¨áÔ∏è Expand" button to show complete roadmap<br>
                            ‚Ä¢ Dependency arrows show critical path in real-time<br>
                            ‚Ä¢ Phase colors guide audience through timeline<br>
                            ‚Ä¢ Click individual nodes to drill down into details
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üìä Excel Import & Export</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ <strong>Export:</strong> Professional 4-sheet workbook (Executive Summary, Details, Dependencies, PM Tracking)<br>
                            ‚Ä¢ <strong>Import:</strong> Load Excel files back into TreeListy - edit in Excel, import changes<br>
                            ‚Ä¢ <strong>Append Mode:</strong> Import multiple Excel files into one tree<br>
                            ‚Ä¢ <strong>Pattern Detection:</strong> Automatically detects project type from Excel structure<br>
                            ‚Ä¢ Perfect for board meetings, investor due diligence, and team collaboration
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üíº Pattern-Based Presentations</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ <strong>Sales Pipeline</strong> - Show deal flow and revenue forecast<br>
                            ‚Ä¢ <strong>Product Roadmap</strong> - Display feature timeline and engineering estimates<br>
                            ‚Ä¢ <strong>AI Prompt Design</strong> - Present prompt engineering workflows<br>
                            ‚Ä¢ <strong>Strategic Planning</strong> - Show KPIs and strategic initiatives
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üé§ Pro Tips</p>
                        <p style="font-size: 13px; margin-bottom: 8px; font-style: italic; color: var(--treeplex-primary);">
                            ‚Ä¢ <strong>Excel Workflow:</strong> Export ‚Üí Edit in Excel with team ‚Üí Import back to TreeListy<br>
                            ‚Ä¢ Use AI Wizard before meetings to quickly build comprehensive plans<br>
                            ‚Ä¢ Generate Prompt to share project structure with AI assistants<br>
                            ‚Ä¢ Import multiple Excel files using Append Mode to combine analyses<br>
                            ‚Ä¢ Use Undo (Ctrl+Z) to safely experiment during live demos
                        </p>
                    </div>

                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">‚å®Ô∏è Keyboard Shortcuts & Tips</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--treeplex-primary);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Keyboard Shortcuts</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ <strong>Ctrl+Z / Cmd+Z</strong> - Undo last action (keeps 50 states in history)<br>
                            ‚Ä¢ Works everywhere except when typing in text fields
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Navigation</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            ‚Ä¢ <strong>Click nodes</strong> to expand/collapse or view details<br>
                            ‚Ä¢ <strong>Right-click anywhere</strong> for context menus<br>
                            ‚Ä¢ <strong>‚¨áÔ∏è Expand / ‚¨ÜÔ∏è Collapse buttons</strong> - Control all phases at once<br>
                            ‚Ä¢ <strong>Mouse wheel</strong> - Zoom in/out<br>
                            ‚Ä¢ <strong>Pan controls</strong> - Navigate large trees
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Visual Cues</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">
                            ‚Ä¢ <strong>Indented items</strong> - Depend on items above them<br>
                            ‚Ä¢ <strong>Dependency arrows</strong> - Show cross-phase relationships<br>
                            ‚Ä¢ <strong>Phase colors</strong> - Guide through timeline (green ‚Üí blue ‚Üí orange ‚Üí purple)<br>
                            ‚Ä¢ <strong>Hover effects</strong> - 3D pop effects on items
                        </p>
                    </div>

                    <h3 style="color: var(--phase-4); margin-bottom: 16px; font-size: 20px;">üîß Advanced Features</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; border-left: 3px solid var(--phase-4);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üé≠ Pattern System (9 Built-in + Custom)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Generic Project</strong> - Universal template for any project</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Sales Pipeline</strong> - Deals, contacts, follow-ups, close dates</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Academic Writing</strong> - Thesis, arguments, citations, evidence</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Product Roadmap</strong> - Features, story points, user impact, technical specs</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Book Writing</strong> - Chapters, scenes, character arcs, plot points</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Course Design</strong> - Modules, lessons, activities, assessments</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>AI Prompt Engineering</strong> - System prompts, few-shot examples, chain-of-thought</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Film Production</strong> - Scenes, Sora/Veo video prompts, camera angles, lighting</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ <strong>Philosophy</strong> - Arguments, premises, objections, textual references</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üõ°Ô∏è Smart Merge Data Protection</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Never loses your data</strong> - AI updates preserve all existing content</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Fuzzy name matching</strong> - Finds related items even if names differ slightly</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Additive updates only</strong> - AI can add or update, but never deletes</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Transparent logging</strong> - Console shows exactly what was merged, added, or preserved</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ <strong>Safe experimentation</strong> - Try AI features without fear of data loss</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">üéØ Pattern-Specific AI Behavior</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">Each pattern has specialized AI intelligence:</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Philosophy</strong> - AI suggests premises, objections, supporting evidence, textual citations</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Sales</strong> - AI suggests follow-up actions, next steps, competitive positioning, deal strategies</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Film</strong> - AI generates production-ready Sora/Veo prompts with camera angles, lighting, blocking</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>AI Prompt</strong> - AI transforms basic prompts into comprehensive prompts with system/user/examples</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">‚Ä¢ <strong>Roadmap</strong> - AI suggests implementation tasks, technical specs, acceptance criteria, story points</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">‚Ä¢ <strong>Book</strong> - AI suggests scenes, character moments, plot developments, narrative arcs</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">‚öôÔ∏è Other Advanced Features</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Dependencies</strong> - Track relationships between items across phases with visual arrows</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>PM Tracking</strong> - Status, assignees, dates, progress, priorities, blocking issues</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Context Notes</strong> - Add project background for better AI suggestions and team alignment</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Shareable URLs</strong> - Compress and share entire projects via URL (base64 encoding)</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">‚Ä¢ <strong>Auto-save</strong> - Your work is preserved in browser localStorage automatically</p>
                        <p style="font-size: 13px;">‚Ä¢ <strong>Custom Patterns</strong> - Create your own pattern with custom fields, labels, and hierarchies</p>
                    </div>

                    <div style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.1), rgba(59, 143, 204, 0.1)); border-radius: 8px; text-align: center;">
                        <p style="font-size: 14px; font-weight: 600; color: var(--treeplex-primary); margin-bottom: 8px;">
                            üöÄ Ready to build something amazing?
                        </p>
                        <p style="font-size: 13px; opacity: 0.9; margin-bottom: 12px;">
                            Start with the AI Wizard for instant guidance, or choose a pattern and dive in!
                        </p>
                        <p style="font-size: 12px; opacity: 0.7;">
                            üßô Pro tip: Try "üßô AI Wizard" ‚Üí describe your project ‚Üí watch the magic happen
                        </p>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
        });

        // =============================================================================
        // EXCEL EXPORT - Professional Multi-Sheet Workbook for Investors
        // =============================================================================

        function exportToExcel() {
            // Create a new workbook
            const wb = XLSX.utils.book_new();

            // Collect all items AND subtasks from the tree (proper phase structure)
            const allItems = [];
            const allTasks = []; // Subtasks for separate PM sheet (recursive)

            // RECURSIVE function to collect nested subtasks from multiple data shapes
            function collectSubtasks(parentItem, parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel = 0) {
                const subtaskCandidates = [];
                const seenIds = new Set();

                if (Array.isArray(parentItem.subItems) && parentItem.subItems.length > 0) {
                    parentItem.subItems.forEach((subtask, index) => {
                        const id = subtask.id || `${parentItem.id || 'item'}-sub-${index}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            subtaskCandidates.push({ ...subtask, id });
                        }
                    });
                }

                if (Array.isArray(parentItem.children) && parentItem.children.length > 0) {
                    parentItem.children
                        .filter(child => child.type === 'subtask')
                        .forEach((child, index) => {
                            const id = child.id || `${parentItem.id || 'item'}-child-${index}`;
                            if (!seenIds.has(id)) {
                                seenIds.add(id);
                                subtaskCandidates.push({ ...child, id });
                            }
                        });
                }

                if (Array.isArray(parentItem.subtasks) && parentItem.subtasks.length > 0) {
                    parentItem.subtasks.forEach((entry, index) => {
                        const normalized = typeof entry === 'string'
                            ? { name: entry }
                            : { ...entry };
                        const id = normalized.id || `${parentItem.id || 'item'}-simple-${index}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            subtaskCandidates.push({
                                type: normalized.type || 'subtask',
                                ...normalized,
                                id
                            });
                        }
                    });
                }

                if (subtaskCandidates.length === 0) {
                    return;
                }

                subtaskCandidates.forEach(subtask => {
                    const indent = '  '.repeat(nestLevel); // Indentation for hierarchy
                    allTasks.push({
                        ...subtask,
                        parentItem: parentName,
                        parentItemId: parentItem.id,
                        phaseName: phaseName,
                        phaseSubtitle: phaseSubtitle,
                        phaseNumber: phaseNumber,
                        nestLevel: nestLevel,
                        taskName: indent + (subtask.name || 'Subtask')
                    });

                    // RECURSIVELY collect nested subtasks
                    collectSubtasks(subtask, subtask.name || parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel + 1);
                });
            }

            function collectItems(node) {
                // Collect items from this phase node
                if (node.items && Array.isArray(node.items)) {
                    node.items.forEach(item => {
                        allItems.push({
                            ...item,
                            phaseName: node.name || 'Unknown Phase',
                            phaseSubtitle: node.subtitle || '',
                            phaseNumber: node.phase || '0'
                        });

                        // Collect subtasks recursively for PM tracking
                        collectSubtasks(item, item.name, node.name || 'Unknown Phase', node.subtitle || '', node.phase || '0', 0);
                    });
                }

                // Recursively collect from child phases
                if (node.children && Array.isArray(node.children)) {
                    node.children.forEach(child => {
                        collectItems(child);
                    });
                }
            }
            collectItems(capexTree);

            // Calculate totals
            const totalCost = allItems.reduce((sum, item) => sum + (item.cost || 0), 0);

            // Group by phase dynamically
            const phaseBreakdown = {};
            allItems.forEach(item => {
                const phaseKey = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;
                if (!phaseBreakdown[phaseKey]) {
                    phaseBreakdown[phaseKey] = { total: 0, count: 0, phaseNumber: item.phaseNumber };
                }
                phaseBreakdown[phaseKey].total += (item.cost || 0);
                phaseBreakdown[phaseKey].count++;
            });

            // =================================================================
            // SHEET 1: EXECUTIVE SUMMARY
            // =================================================================
            const resolvePatternName = () => {
                if (capexTree.pattern && capexTree.pattern.key) {
                    if (capexTree.pattern.key === 'custom') {
                        const labels = capexTree.pattern.labels || {};
                        return labels.root ? `Custom (${labels.root})` : 'Custom Pattern';
                    }
                    if (PATTERNS[capexTree.pattern.key]) {
                        return PATTERNS[capexTree.pattern.key].name;
                    }
                }
                if (PATTERNS[currentPattern]) {
                    return PATTERNS[currentPattern].name;
                }
                return 'Generic Project';
            };

            const patternNameForSummary = resolvePatternName();

            const summaryData = [
                ['TREEPLEXITY - PROJECT SUMMARY'],
                ['by geej', '', '', ''],
                [],
                ['Project:', capexTree.name || 'Project Plan'],
                ['Pattern:', patternNameForSummary],
                ['Total Cost:', `$${(totalCost / 1000000).toFixed(2)}M`],
                ['Items Count:', allItems.length],
                ['Report Date:', new Date().toLocaleDateString()],
                [],
                ['INVESTMENT BREAKDOWN BY PHASE'],
                [],
                ['Phase', 'Investment', 'Percentage', 'Items']
            ];

            // Add phase rows dynamically (sorted by phase number)
            Object.entries(phaseBreakdown)
                .sort((a, b) => (a[1].phaseNumber || 0) - (b[1].phaseNumber || 0))
                .forEach(([phaseName, data]) => {
                    const phasePercentage = totalCost > 0 ? `${((data.total / totalCost) * 100).toFixed(1)}%` : '0%';
                    summaryData.push([
                        phaseName,
                        `$${(data.total / 1000000).toFixed(2)}M`,
                        phasePercentage,
                        data.count
                    ]);
                });

            // Add total row
            summaryData.push(['TOTAL', `$${(totalCost / 1000000).toFixed(2)}M`, totalCost > 0 ? '100.0%' : '0%', allItems.length]);

            // Add key metrics
            summaryData.push([]);
            summaryData.push(['KEY METRICS']);
            summaryData.push([]);
            summaryData.push(['Metric', 'Value']);
            summaryData.push(['Average Item Cost', allItems.length > 0 ? `$${(totalCost / allItems.length / 1000).toFixed(0)}K` : '$0']);
            summaryData.push(['Largest Single Item', allItems.length > 0 ? `$${(Math.max(...allItems.map(i => i.cost || 0)) / 1000000).toFixed(2)}M` : '$0']);
            summaryData.push(['Items with Dependencies', allItems.filter(i => i.dependencies && i.dependencies.length > 0).length]);
            summaryData.push(['Items with Alternate Sources', allItems.filter(i => i.alternateSource).length]);

            const ws_summary = XLSX.utils.aoa_to_sheet(summaryData);

            // Set column widths
            ws_summary['!cols'] = [
                { wch: 30 },  // Column A
                { wch: 20 },  // Column B
                { wch: 15 },  // Column C
                { wch: 15 }   // Column D
            ];

            // Add to workbook
            XLSX.utils.book_append_sheet(wb, ws_summary, 'üìä Executive Summary');

            // =================================================================
            // SHEET 2: DETAILED ITEMS (PATTERN-AWARE)
            // =================================================================

            // Get current pattern for dynamic columns
            const currentPatternDef = PATTERNS[currentPattern];
            const patternFields = currentPatternDef.fields || {};

            // Build dynamic column headers
            const baseColumns = ['Item Name', 'Phase', 'Type', 'Description'];
            const patternColumns = [];
            const patternFieldKeys = []; // Track field keys for data extraction

            // Add all pattern-specific fields dynamically
            Object.keys(patternFields).forEach(fieldKey => {
                const fieldConfig = patternFields[fieldKey];
                // Skip non-field properties
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }
                if (fieldConfig.label) {
                    patternColumns.push(fieldConfig.label);
                    patternFieldKeys.push(fieldKey);
                }
            });

            const endColumns = ['Dependencies', 'Notes'];
            const allColumns = [...baseColumns, ...patternColumns, ...endColumns];

            // Build column widths dynamically
            const columnWidths = [
                { wch: 30 },  // Item Name
                { wch: 25 },  // Phase
                { wch: 20 },  // Type
                { wch: 40 }   // Description
            ];

            // Add widths for pattern columns
            patternColumns.forEach(col => {
                // Determine width based on field type
                if (col.includes('Date')) {
                    columnWidths.push({ wch: 12 });
                } else if (col.includes('$') || col.includes('Cost') || col.includes('Value')) {
                    columnWidths.push({ wch: 15 });
                } else if (col.includes('%') || col.includes('Points')) {
                    columnWidths.push({ wch: 10 });
                } else if (col.length > 20) {
                    columnWidths.push({ wch: 35 }); // Long labels get more space
                } else {
                    columnWidths.push({ wch: 20 }); // Default width
                }
            });

            columnWidths.push({ wch: 30 }); // Dependencies
            columnWidths.push({ wch: 40 }); // Notes

            const itemsData = [
                [`DETAILED PROJECT ITEMS - ${currentPatternDef.name}`],
                [],
                allColumns
            ];

            // Add item rows with dynamic pattern fields
            allItems.forEach(item => {
                const phaseDisplay = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;

                const rowData = [
                    item.name || '',
                    phaseDisplay,
                    item.itemType || '',
                    item.description || ''
                ];

                // Add pattern-specific field values
                patternFieldKeys.forEach(fieldKey => {
                    const fieldConfig = patternFields[fieldKey];
                    let value = item[fieldKey];

                    if (value === undefined || value === null || value === '') {
                        rowData.push('');
                        return;
                    }

                    // Format based on field type
                    if (fieldConfig.type === 'number') {
                        // Special handling for cost (convert to millions)
                        if (fieldKey === 'cost' && fieldConfig.label.includes('($M)')) {
                            value = (value / 1000000).toFixed(2);
                        } else if (fieldKey === 'dealValue') {
                            value = (value / 1000).toFixed(0); // Thousands
                        } else {
                            value = value.toString();
                        }
                    } else if (fieldConfig.type === 'date') {
                        value = value; // Keep as-is (Excel will format)
                    } else if (fieldConfig.type === 'textarea') {
                        value = value.replace(/\n/g, ' '); // Remove newlines for Excel
                    }

                    rowData.push(value);
                });

                // Add dependencies and notes
                rowData.push((item.dependencies || []).length > 0 ? item.dependencies.join(', ') : 'None');
                rowData.push(item.notes || '');

                itemsData.push(rowData);
            });

            // Add total row (only for patterns with cost field)
            itemsData.push([]);
            if (patternFields.cost || patternFields.dealValue) {
                const totalRow = ['TOTAL', '', '', ''];

                // Find the cost column index
                const costFieldKey = patternFields.cost ? 'cost' : 'dealValue';
                const costIndex = patternFieldKeys.indexOf(costFieldKey);

                // Fill blanks up to cost column
                for (let i = 0; i < patternFieldKeys.length; i++) {
                    if (i === costIndex) {
                        if (costFieldKey === 'cost') {
                            totalRow.push((totalCost / 1000000).toFixed(2));
                        } else {
                            // Sum dealValue for sales pipeline
                            const totalDealValue = allItems.reduce((sum, item) => sum + (item.dealValue || 0), 0);
                            totalRow.push((totalDealValue / 1000).toFixed(0));
                        }
                    } else {
                        totalRow.push('');
                    }
                }

                totalRow.push('', ''); // Dependencies, Notes
                itemsData.push(totalRow);
            }

            const ws_items = XLSX.utils.aoa_to_sheet(itemsData);
            ws_items['!cols'] = columnWidths;

            XLSX.utils.book_append_sheet(wb, ws_items, 'üìã Detailed Items');

            // =================================================================
            // SHEET 3: DEPENDENCIES MATRIX
            // =================================================================
            const depsData = [
                ['DEPENDENCY MATRIX'],
                [],
                ['Item', 'Depends On', 'Count', 'Critical Path?']
            ];

            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    depsData.push([
                        item.name || '',
                        item.dependencies.join(', '),
                        item.dependencies.length,
                        item.dependencies.length > 2 ? 'Yes' : 'No'
                    ]);
                }
            });

            if (depsData.length === 3) {
                depsData.push(['No dependencies defined yet', '', '', '']);
            }

            const ws_deps = XLSX.utils.aoa_to_sheet(depsData);

            ws_deps['!cols'] = [
                { wch: 35 },
                { wch: 50 },
                { wch: 10 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_deps, 'üîó Dependencies');

            // =================================================================
            // SHEET 4: COST ANALYSIS BY TYPE
            // =================================================================
            const typeBreakdown = {};
            allItems.forEach(item => {
                const type = item.itemType || 'Uncategorized';
                if (!typeBreakdown[type]) {
                    typeBreakdown[type] = { count: 0, total: 0 };
                }
                typeBreakdown[type].count++;
                typeBreakdown[type].total += (item.cost || 0);
            });

            const analysisData = [
                ['COST ANALYSIS BY TYPE'],
                [],
                ['Item Type', 'Count', 'Total Cost ($M)', '% of Total', 'Avg Cost ($K)']
            ];

            Object.entries(typeBreakdown)
                .sort((a, b) => b[1].total - a[1].total)
                .forEach(([type, data]) => {
                    analysisData.push([
                        type,
                        data.count,
                        (data.total / 1000000).toFixed(2),
                        ((data.total / totalCost) * 100).toFixed(1) + '%',
                        (data.total / data.count / 1000).toFixed(0)
                    ]);
                });

            analysisData.push([]);
            analysisData.push(['TOTAL', allItems.length, (totalCost / 1000000).toFixed(2), '100.0%', (totalCost / allItems.length / 1000).toFixed(0)]);

            const ws_analysis = XLSX.utils.aoa_to_sheet(analysisData);

            ws_analysis['!cols'] = [
                { wch: 30 },
                { wch: 10 },
                { wch: 18 },
                { wch: 12 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_analysis, 'üìà Cost Analysis');

            // =================================================================
            // SHEET 5: PROJECT TASKS (PM TRACKING)
            // =================================================================
            const tasksData = [
                ['PROJECT TASKS - EXECUTION TRACKING (HIERARCHICAL)'],
                ['Professional Project Management Dashboard', '', '', '', '', '', '', '', '', '', '', ''],
                [],
                ['Task Name', 'Level', 'Parent Item', 'Phase', 'Status', 'Assignee', 'Progress %', 'Priority', 'Start Date', 'Due Date', 'Blocking Issue', 'Next Steps', 'Latest Updates']
            ];

            // Add task rows
            if (allTasks.length > 0) {
                allTasks.forEach(task => {
                    const phaseDisplay = `${task.phaseName}${task.phaseSubtitle ? ' (' + task.phaseSubtitle + ')' : ''}`;

                    // Format updates as timestamped entries
                    let updatesText = '';
                    if (task.pmUpdates && Array.isArray(task.pmUpdates) && task.pmUpdates.length > 0) {
                        updatesText = task.pmUpdates
                            .map(u => `[${new Date(u.timestamp).toLocaleDateString()}] ${u.text}`)
                            .join(' | ');
                    }

                    tasksData.push([
                        task.taskName || task.name || '',  // Use indented taskName for hierarchy
                        task.nestLevel || 0,
                        task.parentItem || '',
                        phaseDisplay,
                        task.pmStatus || 'To Do',
                        task.pmAssignee || 'Unassigned',
                        task.pmProgress || 0,
                        task.pmPriority || 'Medium',
                        task.pmStartDate || '',
                        task.pmDueDate || '',
                        task.pmBlockingIssue || '',
                        task.pmNextSteps || '',
                        updatesText
                    ]);
                });
            } else {
                tasksData.push(['No tasks created yet', '', '', '', '', '', '', '', '', '', '', '', '']);
            }

            // Add summary metrics
            tasksData.push([]);
            tasksData.push(['TASK SUMMARY METRICS']);
            tasksData.push([]);

            const completedTasks = allTasks.filter(t => t.pmStatus === 'Done').length;
            const inProgressTasks = allTasks.filter(t => t.pmStatus === 'In Progress').length;
            const blockedTasks = allTasks.filter(t => t.pmStatus === 'Blocked').length;
            const avgProgress = allTasks.length > 0 ? (allTasks.reduce((sum, t) => sum + (t.pmProgress || 0), 0) / allTasks.length).toFixed(1) : 0;

            tasksData.push(['Total Tasks', allTasks.length]);
            tasksData.push(['Completed', completedTasks, `${allTasks.length > 0 ? ((completedTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['In Progress', inProgressTasks, `${allTasks.length > 0 ? ((inProgressTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['Blocked', blockedTasks, blockedTasks > 0 ? '‚ö†Ô∏è ATTENTION REQUIRED' : '']);
            tasksData.push(['Average Progress', `${avgProgress}%`]);
            tasksData.push([]);
            tasksData.push(['Status Distribution']);

            // Status breakdown
            const statusCounts = {};
            allTasks.forEach(t => {
                const status = t.pmStatus || 'To Do';
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });

            Object.entries(statusCounts)
                .sort((a, b) => b[1] - a[1])
                .forEach(([status, count]) => {
                    tasksData.push([status, count, `${((count/allTasks.length)*100).toFixed(1)}%`]);
                });

            const ws_tasks = XLSX.utils.aoa_to_sheet(tasksData);

            // Set column widths for professional presentation
            ws_tasks['!cols'] = [
                { wch: 40 },  // Task Name (with indentation)
                { wch: 8 },   // Level
                { wch: 30 },  // Parent Item
                { wch: 25 },  // Phase
                { wch: 15 },  // Status
                { wch: 20 },  // Assignee
                { wch: 12 },  // Progress %
                { wch: 12 },  // Priority
                { wch: 15 },  // Start Date
                { wch: 15 },  // Due Date
                { wch: 35 },  // Blocking Issue
                { wch: 40 },  // Next Steps
                { wch: 60 }   // Latest Updates
            ];

            XLSX.utils.book_append_sheet(wb, ws_tasks, '‚úÖ Project Tasks');

            // =================================================================
            // GENERATE AND DOWNLOAD FILE
            // =================================================================
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `TreeListy-${timestamp}.xlsx`;

            XLSX.writeFile(wb, filename);

            // Show success message
            alert(`‚úÖ Excel export successful!\n\nFile: ${filename}\n\nIncludes:\n‚Ä¢ Executive Summary\n‚Ä¢ Detailed Items (${allItems.length} items)\n‚Ä¢ Dependencies Matrix\n‚Ä¢ Cost Analysis by Type\n‚Ä¢ Project Tasks (${allTasks.length} tasks with PM tracking)\n\nProfessionally formatted and ready for investor presentations! üìä`);
        }

        // Excel Export button handler
        document.getElementById('excel-export-btn').addEventListener('click', exportToExcel);

        // =============================================================================
        // EXCEL IMPORT - Import from Excel back to TreeListy
        // =============================================================================

        // =============================================================================
        // FLEXIBLE EXCEL IMPORT - Import ANY Excel file with column mapping
        // =============================================================================

        let excelImportState = {
            workbook: null,
            file: null,
            selectedSheet: null,
            headers: [],
            sampleData: [],
            columnMapping: {},
            hierarchyConfig: {},
            pattern: null
        };

        function importFromExcel(file) {
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });

                    console.log('üì• Excel workbook loaded:', workbook.SheetNames);

                    excelImportState.workbook = workbook;
                    excelImportState.file = file.name;

                    // Check if this is a TreeListy export (fast automatic import)
                    if (workbook.SheetNames.includes('üìã Detailed Items')) {
                        console.log('‚úÖ TreeListy export detected - importing automatically');
                        importTreeListyExcel(workbook);
                        return;
                    }

                    // Not a TreeListy export - use flexible import wizard
                    console.log('üìã Generic Excel file - launching mapping wizard');
                    startFlexibleImportWizard(workbook);

                } catch (err) {
                    console.error('‚ùå Excel import error:', err);
                    alert('‚ùå Failed to read Excel file!\n\n' + err.message);
                }
            };

            reader.readAsArrayBuffer(file);
        }

        function showImportModeChoice(workbook) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'üì• Excel Import Mode';

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 24px;">
                        This appears to be a TreeListy export. Choose how to import:
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="import-mode-fast" style="flex: 1; padding: 20px; border: 2px solid var(--treeplex-primary); border-radius: 12px; cursor: pointer; transition: all 0.2s; background: rgba(0, 166, 125, 0.05);">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">‚ö°</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Fast Import
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Automatically import using TreeListy format. Perfect fidelity, instant import.
                            </div>
                        </div>

                        <div id="import-mode-custom" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">üéØ</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Custom Mapping
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Map columns manually, customize field mappings, handle custom formats.
                            </div>
                        </div>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Hover effects
            ['import-mode-fast', 'import-mode-custom'].forEach(id => {
                const elem = document.getElementById(id);
                elem.addEventListener('mouseenter', () => {
                    elem.style.transform = 'translateY(-2px)';
                    elem.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
                });
                elem.addEventListener('mouseleave', () => {
                    elem.style.transform = 'translateY(0)';
                    elem.style.boxShadow = 'none';
                });
            });

            // Fast import handler
            document.getElementById('import-mode-fast').addEventListener('click', () => {
                modal.style.display = 'none';
                importTreeListyExcel(workbook);
            });

            // Custom import handler
            document.getElementById('import-mode-custom').addEventListener('click', () => {
                modal.style.display = 'none';
                startFlexibleImportWizard(workbook);
            });
        }

        function importTreeListyExcel(workbook) {
            try {

                    // Parse the "üìã Detailed Items" sheet
                    const itemsSheet = workbook.Sheets['üìã Detailed Items'];
                    const itemsData = XLSX.utils.sheet_to_json(itemsSheet, { header: 1 });

                    console.log('üìã Parsed items data:', itemsData.length, 'rows');

                    // Find the header row (contains "Item Name")
                    let headerRowIndex = -1;
                    for (let i = 0; i < itemsData.length; i++) {
                        if (itemsData[i][0] === 'Item Name') {
                            headerRowIndex = i;
                            break;
                        }
                    }

                    if (headerRowIndex === -1) {
                        alert('‚ùå Invalid Excel format!\n\nCould not find the "Item Name" header row.');
                        return;
                    }

                    const headers = itemsData[headerRowIndex];
                    console.log('üìã Headers:', headers);

                    // Parse items (skip header and empty rows)
                    const items = [];
                    for (let i = headerRowIndex + 1; i < itemsData.length; i++) {
                        const row = itemsData[i];

                        // Skip empty rows or total row
                        if (!row[0] || row[0] === 'TOTAL') continue;

                        const item = {};
                        headers.forEach((header, index) => {
                            if (header && row[index] !== undefined && row[index] !== '') {
                                item[header] = row[index];
                            }
                        });

                        items.push(item);
                    }

                    console.log('‚úÖ Parsed', items.length, 'items from Excel');

                    // Detect pattern from the data structure
                    const detectedPattern = detectPatternFromExcel(items, headers);
                    console.log('üé® Detected pattern:', detectedPattern);

                    // Convert items to tree structure
                    const newTree = convertExcelToTree(items, detectedPattern);

                    // Auto-import TreeListy exports (simple confirmation only)
                    const confirmMsg = `Import ${items.length} items from Excel?\n\nThis will replace your current tree.`;
                    if (confirm(confirmMsg)) {
                        saveState('Excel Import');
                        capexTree = newTree;
                        currentPattern = detectedPattern;
                        document.getElementById('pattern-select').value = detectedPattern;
                        render();
                        showToast(`‚úÖ Excel imported! ${items.length} items loaded`);
                        console.log('‚úÖ TreeListy export auto-imported');
                    }

            } catch (err) {
                console.error('‚ùå Excel import error:', err);
                alert('‚ùå Failed to import Excel file!\n\n' + err.message + '\n\nPlease ensure this is a valid TreeListy Excel export.');
            }
        }

        function detectPatternFromExcel(items, headers) {
            // Check for pattern-specific columns
            if (headers.includes('Deal Value ($)') || headers.includes('Stage Probability (%)')) {
                return 'sales';
            } else if (headers.includes('Word Count') || headers.includes('Draft Status')) {
                return 'thesis';
            } else if (headers.includes('Story Points') || headers.includes('Engineering Estimate')) {
                return 'roadmap';
            } else if (headers.includes('Use Case') || headers.includes('Target Model')) {
                return 'prompt';
            } else if (headers.includes('Chapter Number') || headers.includes('Section Type')) {
                return 'book';
            } else if (headers.includes('Argument Type') || headers.includes('Philosophical School')) {
                return 'philosophy';
            } else if (headers.includes('KPI') || headers.includes('Strategic Priority')) {
                return 'strategy';
            } else if (headers.includes('Cost ($M)') && headers.includes('Lead Time')) {
                return 'generic';
            }

            // Default to current pattern
            return currentPattern;
        }

        function convertExcelToTree(items, pattern) {
            const patternDef = PATTERNS[pattern];
            const levels = patternDef.levels;

            // Group items by phase
            const phaseMap = {};

            items.forEach(item => {
                const phaseName = item.Phase || item[levels.phase];

                if (!phaseName) return;

                // Extract phase number and subtitle if present
                const phaseMatch = phaseName.match(/^(.+?)\s*\((.*?)\)$/);
                const basePhaseName = phaseMatch ? phaseMatch[1].trim() : phaseName;
                const phaseSubtitle = phaseMatch ? phaseMatch[2].trim() : '';

                if (!phaseMap[basePhaseName]) {
                    phaseMap[basePhaseName] = {
                        name: basePhaseName,
                        subtitle: phaseSubtitle,
                        items: []
                    };
                }

                // Convert item data back to tree format
                const treeItem = {
                    name: item['Item Name'] || item.name || 'Unnamed Item',
                    description: item.Description || item.description || '',
                    type: 'item',
                    icon: 'üì¶'
                };

                // Map pattern-specific fields dynamically
                const fields = patternDef.fields;
                if (fields) {
                    Object.keys(fields).forEach(fieldKey => {
                        const fieldConfig = fields[fieldKey];

                        // Skip non-field properties
                        if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                            return;
                        }

                        const excelColumnName = fieldConfig.label;

                        if (item[excelColumnName] !== undefined && item[excelColumnName] !== '' && item[excelColumnName] !== null) {
                            let value = item[excelColumnName];

                            // Convert numeric fields
                            if (fieldConfig.type === 'number') {
                                // Handle cost (exported in millions, import back to raw)
                                if (fieldKey === 'cost' && fieldConfig.label.includes('($M)')) {
                                    value = parseFloat(value) * 1000000;
                                } else if (fieldKey === 'dealValue') {
                                    // dealValue exported in thousands, import back to raw
                                    value = parseFloat(value) * 1000;
                                } else {
                                    value = parseFloat(value);
                                }
                            } else if (fieldConfig.type === 'date') {
                                // Keep dates as-is (Excel format)
                                value = value;
                            } else if (fieldConfig.type === 'select') {
                                // Ensure select value is string
                                value = value.toString();
                            } else if (fieldConfig.type === 'textarea') {
                                // Textarea values are already strings
                                value = value.toString();
                            } else {
                                // Text fields
                                value = value.toString();
                            }

                            treeItem[fieldKey] = value;
                        }
                    });
                }

                // Handle dependencies
                if (item.Dependencies && item.Dependencies !== 'None') {
                    treeItem.dependencies = item.Dependencies.split(', ').map(d => d.trim());
                }

                // Handle item type
                if (item.Type) {
                    treeItem.itemType = item.Type;
                }

                phaseMap[basePhaseName].items.push(treeItem);
            });

            // Convert phase map to tree structure
            const phases = Object.values(phaseMap).map((phase, index) => {
                return {
                    id: `phase-${index}`,
                    type: 'phase',
                    phase: index,
                    name: phase.name,
                    subtitle: phase.subtitle,
                    icon: `${index + 1}Ô∏è‚É£`,
                    expanded: false,
                    items: phase.items.map((item, itemIndex) => ({
                        ...item,
                        id: `item-${index}-${itemIndex}`
                    }))
                };
            });

            // Create new tree
            const newTree = {
                id: 'root',
                type: 'root',
                name: items[0]?.Project || capexTree.name || 'Imported Project',
                icon: 'üå≥',
                expanded: true,
                children: phases,
                pattern: {
                    key: pattern,
                    labels: levels
                }
            };

            return newTree;
        }

        function showImportConfirmation(newTree, itemCount, pattern) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'üì• Import from Excel';

            const patternInfo = PATTERNS[pattern];
            const phaseCount = newTree.children?.length || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 20px; border-radius: 12px; margin-bottom: 24px;">
                        <h3 style="margin: 0 0 12px 0; color: var(--treeplex-primary);">üìä Import Summary</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 14px;">
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">Pattern Detected</div>
                                <div style="font-weight: 600;">${patternInfo.icon} ${patternInfo.levels.root}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">${patternInfo.levels.phase}s</div>
                                <div style="font-weight: 600;">${phaseCount}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">${patternInfo.levels.item}s</div>
                                <div style="font-weight: 600;">${itemCount}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">Project Name</div>
                                <div style="font-weight: 600;">${newTree.name}</div>
                            </div>
                        </div>
                    </div>

                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 24px; border-left: 3px solid var(--treeplex-primary);">
                        <p style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600;">Import Mode</p>
                        <p style="margin: 0 0 16px 0; font-size: 13px; color: var(--text-secondary);">
                            How would you like to import this Excel file?
                        </p>

                        <div style="display: flex; gap: 12px;">
                            <button id="import-replace-btn" class="btn" style="flex: 1; background: linear-gradient(135deg, #f59e0b, #d97706); padding: 12px;">
                                üîÑ Replace Current Tree
                            </button>
                            <button id="import-append-btn" class="btn" style="flex: 1; background: linear-gradient(135deg, var(--treeplex-primary), #059669); padding: 12px;">
                                ‚ûï Append to Current Tree
                            </button>
                        </div>
                    </div>

                    <div style="background: rgba(239, 68, 68, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #ef4444;">
                        <p style="margin: 0; font-size: 12px; color: var(--text-secondary);">
                            ‚ö†Ô∏è <strong>Replace</strong> will overwrite your current project. <strong>Append</strong> will add items to existing phases.
                        </p>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Handle replace
            document.getElementById('import-replace-btn').addEventListener('click', () => {
                saveState('Excel Import: Replace');

                // Replace tree
                capexTree = newTree;
                currentPattern = pattern;
                document.getElementById('pattern-select').value = pattern;

                render();
                modal.style.display = 'none';

                showToast(`‚úÖ Excel imported! ${itemCount} items loaded`);
                console.log('‚úÖ Excel import complete (replace mode)');
            });

            // Handle append
            document.getElementById('import-append-btn').addEventListener('click', () => {
                saveState('Excel Import: Append');

                // Append phases and items
                newTree.children.forEach((newPhase, newPhaseIndex) => {
                    const existingPhase = capexTree.children?.[newPhaseIndex];

                    if (existingPhase) {
                        // Phase exists - append items
                        if (newPhase.items && newPhase.items.length > 0) {
                            const currentItemCount = existingPhase.items?.length || 0;

                            // Re-ID items
                            const reIdedItems = newPhase.items.map((item, idx) => ({
                                ...item,
                                id: `item-${newPhaseIndex}-${currentItemCount + idx}`
                            }));

                            existingPhase.items = [...(existingPhase.items || []), ...reIdedItems];
                        }
                    } else {
                        // Phase doesn't exist - add it
                        if (!capexTree.children) capexTree.children = [];
                        newPhase.id = `phase-${capexTree.children.length}`;
                        newPhase.phase = capexTree.children.length;
                        capexTree.children.push(newPhase);
                    }
                });

                render();
                modal.style.display = 'none';

                showToast(`‚úÖ Excel imported! ${itemCount} items added`);
                console.log('‚úÖ Excel import complete (append mode)');
            });
        }

        // =============================================================================
        // FLEXIBLE EXCEL IMPORT WIZARD - Import any Excel file with column mapping
        // =============================================================================

        function startFlexibleImportWizard(workbook) {
            console.log('üßô Starting flexible import wizard...');

            excelImportState.workbook = workbook;

            // If only one sheet, skip to column mapping
            if (workbook.SheetNames.length === 1) {
                analyzeSheetStructure(workbook.SheetNames[0]);
                return;
            }

            // Multiple sheets - show selection UI
            showSheetSelection(workbook);
        }

        function showSheetSelection(workbook) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'üìë Select Sheet to Import';

            let sheetsHTML = '';
            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                const rowCount = data.length;
                const colCount = data[0]?.length || 0;

                // Preview first 3 rows
                const preview = data.slice(0, 3)
                    .map(row => row.slice(0, 5).join(', '))
                    .join('<br>');

                sheetsHTML += `
                    <div class="sheet-option" data-sheet="${sheetName}" style="border: 2px solid var(--border); padding: 16px; margin-bottom: 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 8px;">${sheetName}</div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                            ${rowCount} rows √ó ${colCount} columns
                        </div>
                        <div style="font-size: 11px; font-family: monospace; color: var(--text-secondary); max-height: 60px; overflow: hidden;">
                            ${preview}
                        </div>
                    </div>
                `;
            });

            modalBody.innerHTML = `<div style="padding: 20px;">${sheetsHTML}</div>`;
            modal.style.display = 'flex';

            // Add click handlers
            document.querySelectorAll('.sheet-option').forEach(elem => {
                elem.addEventListener('click', () => {
                    const sheetName = elem.dataset.sheet;
                    analyzeSheetStructure(sheetName);
                });

                // Hover effect
                elem.addEventListener('mouseenter', () => {
                    elem.style.borderColor = 'var(--treeplex-primary)';
                    elem.style.background = 'rgba(0, 166, 125, 0.05)';
                });
                elem.addEventListener('mouseleave', () => {
                    elem.style.borderColor = 'var(--border)';
                    elem.style.background = 'transparent';
                });
            });
        }

        function analyzeSheetStructure(sheetName) {
            const sheet = excelImportState.workbook.Sheets[sheetName];
            const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            console.log('üìä Analyzing sheet:', sheetName);

            // Find header row (first non-empty row)
            let headerRowIndex = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] && data[i].some(cell => cell !== '' && cell !== null && cell !== undefined)) {
                    headerRowIndex = i;
                    break;
                }
            }

            const headers = data[headerRowIndex].filter(h => h !== '' && h !== null && h !== undefined);
            const sampleData = data.slice(headerRowIndex + 1, headerRowIndex + 6); // 5 sample rows

            console.log('üìã Found headers:', headers);
            console.log('üìã Sample data rows:', sampleData.length);

            excelImportState.selectedSheet = sheetName;
            excelImportState.headers = headers;
            excelImportState.sampleData = sampleData;

            // Auto-suggest column mappings
            const suggestedMappings = autoSuggestColumnMappings(headers);
            excelImportState.columnMapping = suggestedMappings;

            console.log('üéØ Suggested mappings:', suggestedMappings);

            // Show column mapping UI
            showColumnMappingUI();
        }

        function autoSuggestColumnMappings(headers) {
            const mapping = {
                itemName: null,
                phaseName: null,
                description: null,
                itemType: null,
                dependencies: null
            };

            // Get current pattern for field suggestions
            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};

            // Try to match each header to a TreeListy field
            headers.forEach((header, index) => {
                const headerLower = header.toLowerCase().trim();

                // Match core fields
                if (headerLower.includes('name') || headerLower.includes('title') || headerLower.includes('item')) {
                    if (!mapping.itemName) mapping.itemName = index;
                } else if (headerLower.includes('phase') || headerLower.includes('quarter') || headerLower.includes('stage') || headerLower.includes('chapter') || headerLower.includes('category')) {
                    if (!mapping.phaseName) mapping.phaseName = index;
                } else if (headerLower.includes('description') || headerLower.includes('notes') || headerLower.includes('details')) {
                    if (!mapping.description) mapping.description = index;
                } else if (headerLower.includes('type') || headerLower.includes('status')) {
                    if (!mapping.itemType) mapping.itemType = index;
                } else if (headerLower.includes('depend') || headerLower.includes('prerequisite')) {
                    if (!mapping.dependencies) mapping.dependencies = index;
                }

                // Try to match pattern-specific fields
                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    if (!mapping[fieldKey] && fieldConfig.label) {
                        const fieldLabelLower = fieldConfig.label.toLowerCase().replace(/[^a-z0-9]/g, '');
                        const headerSimplified = headerLower.replace(/[^a-z0-9]/g, '');

                        // Check for similarity
                        if (fieldLabelLower === headerSimplified ||
                            fieldLabelLower.includes(headerSimplified) ||
                            headerSimplified.includes(fieldLabelLower)) {
                            mapping[fieldKey] = index;
                        }
                    }
                });
            });

            console.log('üîç Auto-detected mappings:', mapping);
            return mapping;
        }

        function showColumnMappingUI() {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'üéØ Map Excel Columns to TreeListy Fields';

            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};
            const headers = excelImportState.headers;
            const sampleData = excelImportState.sampleData;
            const mapping = excelImportState.columnMapping;

            // Build mapping rows
            let mappingRowsHTML = '';

            // Core fields
            mappingRowsHTML += createMappingRow('Item Name', 'itemName', 'REQUIRED: Name of each item/task', mapping.itemName, true);
            mappingRowsHTML += createMappingRow('Phase/Category', 'phaseName', 'Group items by phase (optional)', mapping.phaseName, false);
            mappingRowsHTML += createMappingRow('Description', 'description', 'Item description', mapping.description, false);
            mappingRowsHTML += createMappingRow('Item Type', 'itemType', 'Type/category of item', mapping.itemType, false);

            // Pattern-specific fields
            Object.keys(fields).forEach(fieldKey => {
                const fieldConfig = fields[fieldKey];
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }

                if (fieldConfig.label) {
                    const helpText = fieldConfig.helpText || `${fieldConfig.label} field`;
                    mappingRowsHTML += createMappingRow(
                        fieldConfig.label,
                        fieldKey,
                        helpText,
                        mapping[fieldKey],
                        false
                    );
                }
            });

            // Dependencies
            mappingRowsHTML += createMappingRow('Dependencies', 'dependencies', 'Comma-separated list of dependencies', mapping.dependencies, false);

            modalBody.innerHTML = `
                <div style="padding: 20px; max-height: 70vh; overflow-y: auto;">
                    <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 16px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.6;">
                            üìã <strong>Sheet:</strong> ${excelImportState.selectedSheet}<br>
                            üé® <strong>Pattern:</strong> ${patternDef.name}<br>
                            üìä <strong>Rows:</strong> ${excelImportState.sampleData.length + ' (preview) / ' + (XLSX.utils.sheet_to_json(excelImportState.workbook.Sheets[excelImportState.selectedSheet], { header: 1 }).length - 1) + ' (total)'}
                        </div>
                    </div>

                    <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                        Map your Excel columns to TreeListy fields. We've pre-selected likely matches.
                    </p>

                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border);">
                                <th style="text-align: left; padding: 8px; font-size: 13px; color: var(--text-secondary);">TreeListy Field</th>
                                <th style="text-align: left; padding: 8px; font-size: 13px; color: var(--text-secondary);">Excel Column</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${mappingRowsHTML}
                        </tbody>
                    </table>

                    <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: flex-end;">
                        <button id="cancel-mapping-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                            Cancel
                        </button>
                        <button id="preview-import-btn" style="padding: 10px 20px; border: none; border-radius: 8px; background: var(--treeplex-primary); color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Preview Import ‚Üí
                        </button>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Update mapping when dropdowns change
            document.querySelectorAll('.column-mapping-select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const fieldKey = e.target.dataset.field;
                    const columnIndex = e.target.value === '' ? null : parseInt(e.target.value);
                    excelImportState.columnMapping[fieldKey] = columnIndex;
                    console.log('üîÑ Updated mapping:', fieldKey, '‚Üí', columnIndex);
                });
            });

            // Cancel button
            document.getElementById('cancel-mapping-btn').addEventListener('click', () => {
                modal.style.display = 'none';
            });

            // Preview button
            document.getElementById('preview-import-btn').addEventListener('click', () => {
                // Validate required fields
                if (excelImportState.columnMapping.itemName === null) {
                    alert('‚ùå Required Field Missing\n\nYou must map the "Item Name" field to import.');
                    return;
                }

                previewFlexibleImport();
            });
        }

        function createMappingRow(label, fieldKey, helpText, selectedValue, required) {
            const requiredBadge = required ? '<span style="color: var(--error); margin-left: 4px;">*</span>' : '';

            // Build options with proper selected attribute
            const headers = excelImportState.headers;
            const sampleData = excelImportState.sampleData;

            let options = '<option value="">-- Skip this column --</option>';
            headers.forEach((h, i) => {
                const isSelected = (selectedValue !== null && selectedValue !== undefined && selectedValue === i) ? 'selected' : '';
                options += `<option value="${i}" ${isSelected}>${h} (sample: ${sampleData[0]?.[i] || 'N/A'})</option>`;
            });

            return `
                <tr style="border-bottom: 1px solid var(--border);">
                    <td style="padding: 12px 8px;">
                        <div style="font-weight: 500; font-size: 14px;">
                            ${label}${requiredBadge}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">
                            ${helpText}
                        </div>
                    </td>
                    <td style="padding: 12px 8px;">
                        <select class="column-mapping-select" data-field="${fieldKey}" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px;">
                            ${options}
                        </select>
                    </td>
                </tr>
            `;
        }

        function previewFlexibleImport() {
            console.log('üëÄ Generating preview...');

            const sheet = excelImportState.workbook.Sheets[excelImportState.selectedSheet];
            const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            // Find header row
            let headerRowIndex = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] && data[i].some(cell => cell !== '' && cell !== null && cell !== undefined)) {
                    headerRowIndex = i;
                    break;
                }
            }

            const rows = data.slice(headerRowIndex + 1).filter(row => row && row.length > 0);
            const mapping = excelImportState.columnMapping;
            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};

            // Extract items
            const importedItems = [];
            const phaseMap = {};

            rows.forEach((row, rowIndex) => {
                // Skip empty rows
                if (!row[mapping.itemName] || row[mapping.itemName] === '') {
                    return;
                }

                const item = {
                    name: row[mapping.itemName] || `Item ${rowIndex + 1}`,
                    description: mapping.description !== null ? (row[mapping.description] || '') : '',
                    itemType: mapping.itemType !== null ? (row[mapping.itemType] || '') : '',
                    type: 'item',
                    icon: 'üì¶'
                };

                // Map pattern-specific fields
                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    const columnIndex = mapping[fieldKey];
                    if (columnIndex !== null && columnIndex !== undefined && row[columnIndex] !== undefined && row[columnIndex] !== '') {
                        let value = row[columnIndex];

                        // Type conversion
                        if (fieldConfig.type === 'number') {
                            value = parseFloat(value) || 0;
                            // Handle special scaling
                            if (fieldKey === 'cost' && fieldConfig.label && fieldConfig.label.includes('($M)')) {
                                value = value * 1000000;
                            } else if (fieldKey === 'dealValue') {
                                value = value * 1000;
                            }
                        }

                        item[fieldKey] = value;
                    }
                });

                // Handle dependencies
                if (mapping.dependencies !== null && row[mapping.dependencies]) {
                    const depString = String(row[mapping.dependencies]);
                    if (depString !== '' && depString.toLowerCase() !== 'none') {
                        item.dependencies = depString.split(/[,;|]/).map(d => d.trim()).filter(d => d);
                    }
                }

                // Determine phase
                const phaseName = mapping.phaseName !== null && row[mapping.phaseName]
                    ? String(row[mapping.phaseName])
                    : 'Default Phase';

                if (!phaseMap[phaseName]) {
                    phaseMap[phaseName] = [];
                }

                phaseMap[phaseName].push(item);
                importedItems.push(item);
            });

            // Generate preview HTML
            let previewHTML = '<div style="padding: 20px; max-height: 70vh; overflow-y: auto;">';

            previewHTML += `
                <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 16px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 12px 0; color: var(--treeplex-primary);">üìä Import Preview</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; font-size: 14px;">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Pattern</div>
                            <div style="font-weight: 600;">${patternDef.icon} ${patternDef.name}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Phases</div>
                            <div style="font-weight: 600;">${Object.keys(phaseMap).length}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Items</div>
                            <div style="font-weight: 600;">${importedItems.length}</div>
                        </div>
                    </div>
                </div>
            `;

            // Show preview of first 10 items
            previewHTML += '<div style="font-weight: 600; margin-bottom: 12px;">Preview (first 10 items):</div>';
            previewHTML += '<div style="font-family: monospace; font-size: 12px; background: var(--bg-secondary); padding: 16px; border-radius: 8px; line-height: 1.8;">';

            let itemCount = 0;
            Object.keys(phaseMap).forEach((phaseName, phaseIndex) => {
                if (itemCount >= 10) return;

                previewHTML += `<div style="color: var(--treeplex-primary); font-weight: 600; margin-top: ${phaseIndex > 0 ? '12px' : '0'};">${phaseName}</div>`;

                phaseMap[phaseName].forEach((item, itemIndex) => {
                    if (itemCount >= 10) return;
                    itemCount++;

                    previewHTML += `<div style="margin-left: 20px; color: var(--text-primary);">‚îú‚îÄ ${item.name}`;
                    if (item.itemType) previewHTML += ` [${item.itemType}]`;
                    if (item.dependencies && item.dependencies.length > 0) {
                        previewHTML += ` <span style="color: var(--text-secondary);">‚Üí Depends on: ${item.dependencies.join(', ')}</span>`;
                    }
                    previewHTML += `</div>`;
                });
            });

            if (importedItems.length > 10) {
                previewHTML += `<div style="color: var(--text-secondary); margin-top: 8px;">... and ${importedItems.length - 10} more items</div>`;
            }

            previewHTML += '</div>';

            // Action buttons
            previewHTML += `
                <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between;">
                    <button id="back-to-mapping-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                        ‚Üê Back to Mapping
                    </button>
                    <div style="display: flex; gap: 12px;">
                        <button id="execute-import-replace-btn" style="padding: 10px 20px; border: none; border-radius: 8px; background: var(--treeplex-primary); color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Replace Current Tree
                        </button>
                        <button id="execute-import-append-btn" style="padding: 10px 20px; border: 1px solid var(--treeplex-primary); border-radius: 8px; background: transparent; color: var(--treeplex-primary); cursor: pointer; font-size: 14px; font-weight: 600;">
                            Append to Tree
                        </button>
                    </div>
                </div>
            `;

            previewHTML += '</div>';

            // Show modal
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'üëÄ Preview Import';
            modalBody.innerHTML = previewHTML;
            modal.style.display = 'flex';

            // Store preview data
            excelImportState.previewData = { phaseMap, importedItems };

            // Button handlers
            document.getElementById('back-to-mapping-btn').addEventListener('click', () => {
                showColumnMappingUI();
            });

            document.getElementById('execute-import-replace-btn').addEventListener('click', () => {
                executeFlexibleImport('replace');
            });

            document.getElementById('execute-import-append-btn').addEventListener('click', () => {
                executeFlexibleImport('append');
            });
        }

        function executeFlexibleImport(mode) {
            console.log('üöÄ Executing import in', mode, 'mode...');

            const { phaseMap, importedItems } = excelImportState.previewData;
            const patternDef = PATTERNS[currentPattern];

            saveState(`Excel Import: ${mode === 'replace' ? 'Replace' : 'Append'}`);

            if (mode === 'replace') {
                // Create new tree from scratch
                const phases = Object.keys(phaseMap).map((phaseName, phaseIndex) => {
                    return {
                        id: `phase-${phaseIndex}`,
                        type: 'phase',
                        phase: phaseIndex,
                        name: phaseName,
                        subtitle: '',
                        icon: `${phaseIndex + 1}Ô∏è‚É£`,
                        expanded: false,
                        items: phaseMap[phaseName].map((item, itemIndex) => ({
                            ...item,
                            id: `item-${phaseIndex}-${itemIndex}`
                        }))
                    };
                });

                capexTree = {
                    id: 'root',
                    type: 'root',
                    name: `Imported from ${excelImportState.file}`,
                    icon: 'üå≥',
                    expanded: true,
                    children: phases,
                    pattern: {
                        key: currentPattern,
                        labels: patternDef.levels
                    }
                };

            } else {
                // Append mode
                if (!capexTree.children) capexTree.children = [];

                Object.keys(phaseMap).forEach((phaseName) => {
                    // Try to find existing phase
                    let existingPhase = capexTree.children.find(p => p.name === phaseName);

                    if (existingPhase) {
                        // Append items to existing phase
                        const currentItemCount = existingPhase.items?.length || 0;
                        const phaseIndex = capexTree.children.indexOf(existingPhase);

                        const newItems = phaseMap[phaseName].map((item, idx) => ({
                            ...item,
                            id: `item-${phaseIndex}-${currentItemCount + idx}`
                        }));

                        existingPhase.items = [...(existingPhase.items || []), ...newItems];
                    } else {
                        // Create new phase
                        const phaseIndex = capexTree.children.length;
                        const newPhase = {
                            id: `phase-${phaseIndex}`,
                            type: 'phase',
                            phase: phaseIndex,
                            name: phaseName,
                            subtitle: '',
                            icon: `${phaseIndex + 1}Ô∏è‚É£`,
                            expanded: false,
                            items: phaseMap[phaseName].map((item, itemIndex) => ({
                                ...item,
                                id: `item-${phaseIndex}-${itemIndex}`
                            }))
                        };

                        capexTree.children.push(newPhase);
                    }
                });
            }

            // Update UI
            render();
            document.getElementById('modal').style.display = 'none';

            showToast(`‚úÖ Excel imported! ${importedItems.length} items ${mode === 'replace' ? 'loaded' : 'added'}`);
            console.log('‚úÖ Flexible import complete');
        }

        // Excel Import button handler
        document.getElementById('excel-import-btn').addEventListener('click', () => {
            document.getElementById('excel-upload-input').click();
        });

        // Google Drive Refresh button handler
        document.getElementById('refresh-drive-btn').addEventListener('click', async () => {
            const btn = document.getElementById('refresh-drive-btn');
            const originalText = btn.textContent;

            try {
                // Check if current tree has source metadata
                const hasSourceMetadata = capexTree?.source?.type === 'google-drive';

                if (!hasSourceMetadata) {
                    // No source metadata - inform user
                    const proceed = confirm(
                        '‚ö†Ô∏è No Google Drive source detected!\n\n' +
                        'This will scan your entire Google Drive.\n\n' +
                        'Tip: Load a Google Drive JSON first, then click Refresh to update only that tree.\n\n' +
                        'Continue with full scan?'
                    );
                    if (!proceed) return;
                }

                // Show loading state
                btn.textContent = '‚è≥ Refreshing...';
                btn.disabled = true;
                btn.style.opacity = '0.6';

                console.log('‚òÅÔ∏è Refreshing from Google Drive...');
                if (hasSourceMetadata) {
                    console.log('üìã Using source metadata from loaded tree:', capexTree.source);
                }

                // Prepare request body with source metadata (if available)
                const requestBody = hasSourceMetadata ? {
                    source: capexTree.source
                } : {};

                // Call local server to trigger export and get data
                const response = await fetch('http://localhost:5000/refresh-google-drive', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Server request failed');
                }

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'Unknown error');
                }

                console.log('‚úÖ Received data from server:', result.filename);

                // Auto-import the data
                const treeData = result.data;

                // Detect pattern
                const detectedPattern = treeData.pattern?.key || 'filesystem';
                console.log(`üìã Pattern detected: ${detectedPattern}`);

                // Load directly without preview modal
                if (PATTERNS[detectedPattern]) {
                    currentPattern = detectedPattern;
                    capexTree = treeData;

                    // Update pattern dropdown
                    const patternSelect = document.getElementById('pattern-select');
                    if (patternSelect) {
                        patternSelect.value = detectedPattern;
                    }

                    // Re-render the tree
                    render();

                    // Update sort dropdown options for the loaded pattern
                    updateSortDropdown();

                    // Apply default sort for filesystem pattern (folders first + alphabetical)
                    if (detectedPattern === 'filesystem') {
                        sortTree(null); // This will trigger the default filesystem sort
                    }

                    // Build success message with source info
                    let successMessage = `‚úÖ Google Drive refreshed successfully!\n\n`;
                    successMessage += `File: ${result.filename}\n`;
                    successMessage += `Size: ${(result.fileSize / 1024).toFixed(1)} KB\n`;
                    successMessage += `Pattern: ${PATTERNS[detectedPattern].name}\n`;

                    if (treeData.source) {
                        successMessage += `\nüìã Source Info:\n`;
                        successMessage += `Type: ${treeData.source.type}\n`;
                        successMessage += `Folder: ${treeData.source.folderName}\n`;
                        successMessage += `Depth: ${treeData.source.syncDepth} levels\n`;

                        if (treeData.source.lastSync) {
                            const syncDate = new Date(treeData.source.lastSync);
                            successMessage += `Last Synced: ${syncDate.toLocaleString()}`;
                        }
                    }

                    alert(successMessage);

                    console.log('‚úÖ Google Drive data loaded successfully');
                } else {
                    throw new Error(`Unknown pattern: ${detectedPattern}`);
                }

            } catch (error) {
                console.error('‚ùå Refresh failed:', error);

                // Check if server is running
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    alert('‚ùå Cannot connect to local server!\n\nPlease start the server first:\n\n1. Open a terminal\n2. Run: python treelisty_server.py\n3. Keep it running\n4. Try again');
                } else {
                    alert(`‚ùå Refresh failed:\n\n${error.message}`);
                }
            } finally {
                // Restore button state
                btn.textContent = originalText;
                btn.disabled = false;
                btn.style.opacity = '1';
            }
        });

        // Excel file upload handler
        document.getElementById('excel-upload-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                console.log('üì• Excel file selected:', file.name);
                importFromExcel(file);
            }
            // Reset input
            e.target.value = '';
        });

        // Redraw lines on scroll or resize
        const treeContainer = document.getElementById('tree-container');
        treeContainer.addEventListener('scroll', drawDependencyLines);
        window.addEventListener('resize', drawDependencyLines);

        // Load from shared URL if present
        (function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const compressedData = urlParams.get('p');

            if (compressedData) {
                try {
                    console.log('Loading shared project from URL...');
                    const decompressed = LZString.decompressFromEncodedURIComponent(compressedData);

                    // DEBUG: Log first 500 chars of decompressed JSON
                    console.log('Decompressed JSON (first 500 chars):', decompressed.substring(0, 500));

                    const loadedTree = JSON.parse(decompressed);

                    // DEBUG: Check cost values in loaded tree
                    if (loadedTree.children && loadedTree.children[0] && loadedTree.children[0].items && loadedTree.children[0].items[0]) {
                        console.log('First item cost in loaded JSON:', loadedTree.children[0].items[0].cost);
                    }

                    // Replace capexTree with loaded data
                    capexTree = loadedTree;

                    // Update currentPattern if it's in the loaded data
                    if (capexTree.pattern && capexTree.pattern.key) {
                        currentPattern = capexTree.pattern.key;
                    }

                    console.log('‚úÖ Shared project loaded successfully!');
                    console.log('Project:', capexTree.name || capexTree.title);
                    console.log('Pattern:', currentPattern);

                    // Simple success toast (no modal)
                    setTimeout(() => {
                        const toast = document.createElement('div');
                        toast.textContent = '‚úÖ Project loaded!';
                        toast.style.cssText = `
                            position: fixed;
                            top: 80px;
                            right: 20px;
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            padding: 15px 25px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-weight: 600;
                        `;
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 2000);
                    }, 500);

                } catch (error) {
                    console.error('‚ùå Failed to load shared project:', error);
                    alert('Failed to load shared project. The URL may be corrupted or invalid.');
                }
            }
        })();

        // =============================================================================
        // PWA & FILE HANDLING SYSTEM
        // =============================================================================

        // PWA install prompt event
        let deferredInstallPrompt = null;

        // Register service worker (only on http:// or https://, not file://)
        if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
            navigator.serviceWorker.register('./service-worker.js')
                .then(registration => {
                    console.log('‚úÖ Service Worker registered:', registration.scope);
                })
                .catch(error => {
                    console.error('‚ùå Service Worker registration failed:', error);
                    console.error('Error details:', error.message, error.stack);
                });
        } else if (window.location.protocol === 'file:') {
            console.log('‚ÑπÔ∏è Service Worker skipped (file:// protocol - not supported)');
        }

        if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {

            // Listen for file launches from service worker
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data.type === 'FILE_OPENED' && event.data.files) {
                    console.log('üìÇ File opened via file association:', event.data.files);
                    event.data.files.forEach(file => {
                        try {
                            const treeData = JSON.parse(file.content);
                            capexTree = treeData;
                            if (treeData.pattern && treeData.pattern.key) {
                                currentPattern = treeData.pattern.key;
                            }
                            render();
                            console.log(`‚úÖ Loaded ${file.name}`);
                        } catch (error) {
                            console.error(`‚ùå Failed to load ${file.name}:`, error);
                            alert(`Failed to load ${file.name}: Invalid JSON format`);
                        }
                    });
                }
            });
        }

        // Capture PWA install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('üíæ PWA install prompt available - Button will trigger automatic install');
            e.preventDefault();
            deferredInstallPrompt = e;
        });

        // Debug: Check PWA install readiness
        console.log('üîç PWA Debug Info:');
        console.log('- Service Worker supported:', 'serviceWorker' in navigator);
        console.log('- beforeinstallprompt listener added');
        console.log('- Manifest URL:', document.querySelector('link[rel="manifest"]')?.href);
        console.log('- Current URL:', window.location.href);
        console.log('- HTTPS:', window.location.protocol === 'https:');

        // Show PWA onboarding modal
        function showPWAOnboardingModal() {
            const modal = document.getElementById('pwa-onboarding-modal');
            modal.style.display = 'flex';
            // Button is always visible now - no need to check for prompt
        }

        // Install PWA button - Universal handler
        document.getElementById('pwa-install-btn').addEventListener('click', async () => {
            const instructionsDiv = document.getElementById('pwa-manual-instructions');

            if (deferredInstallPrompt) {
                // Automatic install available - trigger it
                try {
                    deferredInstallPrompt.prompt();

                    const { outcome } = await deferredInstallPrompt.userChoice;
                    console.log(`PWA install outcome: ${outcome}`);

                    if (outcome === 'accepted') {
                        console.log('‚úÖ User accepted PWA installation');

                        // Mark onboarding as completed
                        localStorage.setItem('treelisty-onboarding-seen', 'true');

                        // Close modal
                        document.getElementById('pwa-onboarding-modal').style.display = 'none';

                        // Show success message
                        const toast = document.createElement('div');
                        toast.textContent = '‚úÖ TreeListy installed! You can now open .treelisty files by double-clicking them.';
                        toast.style.cssText = `
                            position: fixed;
                            top: 80px;
                            right: 20px;
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            padding: 15px 25px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-weight: 600;
                            max-width: 400px;
                        `;
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 5000);
                    } else {
                        console.log('‚ùå User declined PWA installation');
                    }

                    deferredInstallPrompt = null;
                } catch (error) {
                    console.error('Install prompt error:', error);
                    // Fallback to manual instructions if prompt fails
                    instructionsDiv.style.display = 'block';
                }
            } else {
                // No automatic install - show manual instructions
                console.log('üìç Showing manual install instructions');
                instructionsDiv.style.display = 'block';

                // Change button text to indicate instructions are shown
                const btn = document.getElementById('pwa-install-btn');
                btn.textContent = '‚úÖ See Instructions Below';
                btn.style.background = 'var(--card-bg)';
                btn.style.color = 'var(--text-secondary)';
                btn.disabled = true;
            }
        });

        // Skip onboarding button
        document.getElementById('pwa-skip-btn').addEventListener('click', () => {
            localStorage.setItem('treelisty-onboarding-seen', 'true');
            document.getElementById('pwa-onboarding-modal').style.display = 'none';
        });

        // Handle launchQueue for file opens (File Handling API)
        if ('launchQueue' in window) {
            window.launchQueue.setConsumer(async (launchParams) => {
                console.log('üìÇ File launch detected via File Handling API');

                if (launchParams.files && launchParams.files.length > 0) {
                    for (const fileHandle of launchParams.files) {
                        try {
                            const file = await fileHandle.getFile();
                            const content = await file.text();
                            const treeData = JSON.parse(content);

                            // Load the tree
                            capexTree = treeData;
                            if (treeData.pattern && treeData.pattern.key) {
                                currentPattern = treeData.pattern.key;
                            }
                            render();

                            console.log(`‚úÖ Loaded ${file.name} via file association`);

                            // Show success toast
                            const toast = document.createElement('div');
                            toast.textContent = `‚úÖ Opened ${file.name}`;
                            toast.style.cssText = `
                                position: fixed;
                                top: 80px;
                                right: 20px;
                                background: linear-gradient(135deg, #10b981, #059669);
                                color: white;
                                padding: 15px 25px;
                                border-radius: 8px;
                                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                                z-index: 10000;
                                font-weight: 600;
                            `;
                            document.body.appendChild(toast);
                            setTimeout(() => toast.remove(), 3000);
                        } catch (error) {
                            console.error('‚ùå Failed to load file:', error);
                            alert(`Failed to load file: ${error.message}`);
                        }
                    }
                }
            });
        } else {
            console.log('‚ÑπÔ∏è File Handling API not supported in this browser');
        }

        // Initial render
        render();

        // Initialize pattern selector
        const patternSelect = document.getElementById('pattern-select');
        console.log('Pattern selector found:', patternSelect);
        if (patternSelect) {
            // Load saved pattern from data
            if (capexTree.pattern && capexTree.pattern.key) {
                currentPattern = capexTree.pattern.key;
                patternSelect.value = currentPattern;
                console.log('Loaded saved pattern:', currentPattern);
                if (currentPattern === 'custom' && capexTree.pattern.labels) {
                    customPatternNames = capexTree.pattern.labels;
                }
                // Apply pattern labels to existing nodes on load
                const labels = currentPattern === 'custom' && customPatternNames ? customPatternNames : PATTERNS[currentPattern].levels;
                renameNodesForPattern(capexTree, labels);
                console.log('Initial nodes renamed to match saved pattern');
                render(); // Re-render with renamed nodes

                // Update sort dropdown for the loaded pattern
                updateSortDropdown();
            }
            // Handle pattern selection
            patternSelect.addEventListener('change', function() {
                console.log('Pattern selector changed to:', this.value);
                applyPattern(this.value);
            });
            console.log('Pattern selector event listener attached');
        } else {
            console.error('Pattern selector NOT found!');
        }

        // Initialize Theme Switcher
        const themeSelect = document.getElementById('theme-select');
        if (themeSelect) {
            // Load saved theme from localStorage
            const savedTheme = localStorage.getItem('treelisty-theme') || 'default';
            document.documentElement.setAttribute('data-theme', savedTheme);
            themeSelect.value = savedTheme;
            console.log('Theme loaded:', savedTheme);

            // Handle theme selection
            themeSelect.addEventListener('change', function() {
                const selectedTheme = this.value;
                console.log('Theme changed to:', selectedTheme);

                // Apply theme
                document.documentElement.setAttribute('data-theme', selectedTheme);

                // Save to localStorage
                localStorage.setItem('treelisty-theme', selectedTheme);

                // Show toast notification
                const themeNames = {
                    'default': 'üåô Default',
                    'steampunk': '‚öôÔ∏è Steampunk',
                    'powerpuff': 'üíó Powerpuff',
                    'tron': 'üí† Tron'
                };
                const toast = document.createElement('div');
                toast.textContent = `Theme: ${themeNames[selectedTheme]}`;
                toast.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    right: 20px;
                    padding: 12px 24px;
                    background: var(--card-bg);
                    border: 2px solid var(--border);
                    border-radius: 12px;
                    color: var(--text-primary);
                    font-weight: 600;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: var(--shadow-lg);
                `;
                document.body.appendChild(toast);

                setTimeout(() => toast.remove(), 2000);
            });

            console.log('Theme switcher initialized');
        }

        // ============================================
        // SORTING SYSTEM
        // ============================================

        // Parse lead time string to days for comparison
        function parseLeadTimeToDays(leadTimeStr) {
            if (!leadTimeStr || leadTimeStr === 'N/A' || leadTimeStr === '') return 999999;

            const str = leadTimeStr.toLowerCase();
            let days = 0;

            // Match patterns like "12-18 months", "3-6 weeks", "2 days", etc.
            const monthsMatch = str.match(/(\d+)(?:-(\d+))?\s*months?/);
            const weeksMatch = str.match(/(\d+)(?:-(\d+))?\s*weeks?/);
            const daysMatch = str.match(/(\d+)(?:-(\d+))?\s*days?/);

            if (monthsMatch) {
                // Take average if range, otherwise use single value
                const avg = monthsMatch[2] ? (parseInt(monthsMatch[1]) + parseInt(monthsMatch[2])) / 2 : parseInt(monthsMatch[1]);
                days = avg * 30; // Approximate months to days
            } else if (weeksMatch) {
                const avg = weeksMatch[2] ? (parseInt(weeksMatch[1]) + parseInt(weeksMatch[2])) / 2 : parseInt(weeksMatch[1]);
                days = avg * 7;
            } else if (daysMatch) {
                const avg = daysMatch[2] ? (parseInt(daysMatch[1]) + parseInt(daysMatch[2])) / 2 : parseInt(daysMatch[1]);
                days = avg;
            }

            return days || 999999; // Return large number if unparseable
        }

        // Compare two values based on type
        function compareValues(a, b, type, order) {
            let valA, valB;

            switch(type) {
                case 'number':
                    valA = parseFloat(a) || 0;
                    valB = parseFloat(b) || 0;
                    break;

                case 'leadtime':
                    valA = parseLeadTimeToDays(a);
                    valB = parseLeadTimeToDays(b);
                    break;

                case 'date':
                    valA = a ? new Date(a).getTime() : 0;
                    valB = b ? new Date(b).getTime() : 0;
                    break;

                case 'text':
                default:
                    valA = (a || '').toString().toLowerCase();
                    valB = (b || '').toString().toLowerCase();
                    if (order === 'asc') return valA.localeCompare(valB);
                    return valB.localeCompare(valA);
            }

            if (order === 'asc') return valA - valB;
            return valB - valA;
        }

        // Recursively sort items array and all nested levels
        function sortItemsArray(items, sortConfig) {
            if (!items || !Array.isArray(items) || items.length === 0) return items;
            if (!sortConfig) return items;

            const { field, order, type } = sortConfig;

            // Special handling for "folders first" sorting in filesystem pattern
            if (currentPattern === 'filesystem' && field === 'isFolder') {
                items.sort((a, b) => {
                    // Folders always come before files when sorting by type
                    const aIsFolder = a.isFolder || false;
                    const bIsFolder = b.isFolder || false;

                    if (aIsFolder && !bIsFolder) return order === 'desc' ? -1 : 1;
                    if (!aIsFolder && bIsFolder) return order === 'desc' ? 1 : -1;

                    // If both are folders or both are files, sort by name as secondary
                    return (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase());
                });
            } else {
                // Standard sorting for all other fields
                items.sort((a, b) => {
                    return compareValues(a[field], b[field], type, order);
                });
            }

            // Recursively sort nested arrays (items, subItems, and children for all patterns)
            items.forEach(item => {
                // Sort standard items array (4-level patterns)
                if (item.items && Array.isArray(item.items) && item.items.length > 0) {
                    sortItemsArray(item.items, sortConfig);
                }

                // Sort subItems array (flexible depth patterns like filesystem)
                if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                    sortItemsArray(item.subItems, sortConfig);
                }

                // Sort children array (filesystem pattern uses this for nested folders)
                if (item.children && Array.isArray(item.children) && item.children.length > 0) {
                    sortItemsArray(item.children, sortConfig);
                }
            });

            return items;
        }

        // Sort the entire tree - applies to all nodes at all depths
        function sortTree(sortConfig) {
            if (!sortConfig) {
                // For filesystem pattern, apply default "folders first + alphabetical" sort
                if (currentPattern === 'filesystem') {
                    sortConfig = {
                        value: 'default-filesystem',
                        field: 'isFolder',
                        order: 'desc',
                        type: 'boolean'
                    };
                    currentSortConfig = sortConfig;
                } else {
                    // Reset to original order for other patterns
                    currentSortConfig = null;
                    render();
                    return;
                }
            } else {
                currentSortConfig = sortConfig;
            }

            // Sort phases (drives for filesystem pattern)
            if (capexTree.phases && capexTree.phases.length > 0) {
                sortItemsArray(capexTree.phases, sortConfig);

                // Sort all items within each phase recursively
                capexTree.phases.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        sortItemsArray(phase.items, sortConfig);
                    }
                });
            }

            // Sort children array (for root level if exists)
            if (capexTree.children && capexTree.children.length > 0) {
                sortItemsArray(capexTree.children, sortConfig);
            }

            // Re-render to show sorted tree with new visual order
            if (viewMode === 'canvas') {
                // Clear canvas coordinates to force re-positioning in new sorted order
                capexTree.children.forEach(phase => {
                    const nodeList = phase.items || phase.children || [];
                    nodeList.forEach(node => clearCanvasCoordinates(node));
                });

                // Migrate coordinates based on new sorted order
                migrateToCanvasCoordinates();

                renderCanvas();
                console.log('Canvas sorted by:', sortConfig, '- Canvas layout updated and repositioned');
            } else {
                render();
                console.log('Tree sorted by:', sortConfig, '- Visual layout updated');
            }
        }

        // Initialize Sort System
        const sortSelect = document.getElementById('pattern-sort-select');
        const resetSortBtn = document.getElementById('reset-sort-btn');

        if (sortSelect) {
            // Handle sort selection
            sortSelect.addEventListener('change', function() {
                const selectedOption = this.options[this.selectedIndex];

                if (!this.value || this.value === '') {
                    // Reset to default order
                    currentSortConfig = null;
                    sortTree(null);
                    if (resetSortBtn) resetSortBtn.style.display = 'none';
                    console.log('Sort reset to default order');
                } else {
                    // Apply sort
                    const sortConfig = {
                        value: this.value,
                        field: selectedOption.dataset.field,
                        order: selectedOption.dataset.order,
                        type: selectedOption.dataset.type
                    };

                    sortTree(sortConfig);
                    if (resetSortBtn) resetSortBtn.style.display = 'inline-block';

                    // Show toast notification
                    const toast = document.createElement('div');
                    toast.textContent = `Sorted: ${selectedOption.textContent}`;
                    toast.style.cssText = `
                        position: fixed;
                        bottom: 80px;
                        right: 20px;
                        padding: 12px 24px;
                        background: var(--card-bg);
                        border: 2px solid var(--border);
                        border-radius: 12px;
                        color: var(--text-primary);
                        font-weight: 600;
                        font-size: 14px;
                        z-index: 10000;
                        box-shadow: var(--shadow-lg);
                    `;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 2000);
                }
            });

            console.log('Sort dropdown event listener attached');
        }

        if (resetSortBtn) {
            resetSortBtn.addEventListener('click', function() {
                currentSortConfig = null;
                sortTree(null);
                sortSelect.value = '';
                this.style.display = 'none';

                // Show toast notification
                const toast = document.createElement('div');
                toast.textContent = 'Sort Reset';
                toast.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    right: 20px;
                    padding: 12px 24px;
                    background: var(--card-bg);
                    border: 2px solid var(--border);
                    border-radius: 12px;
                    color: var(--text-primary);
                    font-weight: 600;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: var(--shadow-lg);
                `;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2000);
            });
        }

        // Update sort dropdown on initial load
        updateSortDropdown();

        console.log('Sorting system initialized');

        // ============================================
        // AI TOOLS FLOATING PANEL
        // ============================================

        const aiToolsPanel = document.getElementById('ai-tools-panel');
        const toggleAiToolsBtn = document.getElementById('toggle-ai-tools');
        const closeAiToolsBtn = document.getElementById('close-ai-tools');
        const aiModeSelectHeader = document.getElementById('unified-ai-mode-select');
        const aiModeSelectPanel = document.getElementById('unified-ai-mode-select-panel');

        // Toggle AI Tools Panel
        if (toggleAiToolsBtn && aiToolsPanel) {
            toggleAiToolsBtn.addEventListener('click', function() {
                const isVisible = aiToolsPanel.style.display === 'flex';
                aiToolsPanel.style.display = isVisible ? 'none' : 'flex';
                console.log('AI Tools panel toggled:', !isVisible);
            });
        }

        // Close AI Tools Panel
        if (closeAiToolsBtn && aiToolsPanel) {
            closeAiToolsBtn.addEventListener('click', function() {
                aiToolsPanel.style.display = 'none';
                console.log('AI Tools panel closed');
            });

            // Hover effect for close button
            closeAiToolsBtn.addEventListener('mouseenter', function() {
                this.style.background = 'rgba(255, 255, 255, 0.1)';
            });
            closeAiToolsBtn.addEventListener('mouseleave', function() {
                this.style.background = 'transparent';
            });
        }

        // Sync AI Model selectors (header <-> panel)
        if (aiModeSelectHeader && aiModeSelectPanel) {
            // Sync panel -> header
            aiModeSelectPanel.addEventListener('change', function() {
                aiModeSelectHeader.value = this.value;
                console.log('AI mode synced from panel to header:', this.value);
            });

            // Sync header -> panel
            aiModeSelectHeader.addEventListener('change', function() {
                aiModeSelectPanel.value = this.value;
                console.log('AI mode synced from header to panel:', this.value);
            });

            // Initial sync
            aiModeSelectPanel.value = aiModeSelectHeader.value;
        }

        console.log('AI Tools panel initialized');

        // Initialize pan/zoom controls
        initPanZoom();

        // Splash screen auto-dismiss
        setTimeout(() => {
            const splashScreen = document.getElementById('splash-screen');
            if (splashScreen) {
                splashScreen.classList.add('fade-out');
                // Remove from DOM after fade-out animation completes
                setTimeout(() => {
                    splashScreen.remove();
                }, 500); // Match fade-out animation duration
            }
        }, 2000); // Show splash for 2 seconds (matches loader animation)
    </script>

    <!-- Canvas View Container -->
    <div class="canvas-container" id="canvas-container">
        <!-- Canvas Toolbar -->
        <div class="canvas-toolbar" id="canvas-toolbar" style="position: fixed; top: 120px; left: 50%; transform: translateX(-50%); z-index: 200; display: none; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(20, 20, 30, 0.98); backdrop-filter: blur(10px); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.4);">
            <select id="auto-layout-select" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.15); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 8px; color: #ffffff; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                <option value="" style="background: #1a1a2e; color: #ffffff;">üìê Auto-Layout</option>
                <option value="hierarchical" style="background: #1a1a2e; color: #ffffff;">üå≥ Hierarchical</option>
                <option value="timeline" style="background: #1a1a2e; color: #ffffff;">üìÖ Timeline</option>
                <option value="force" style="background: #1a1a2e; color: #ffffff;">üåÄ Force-Directed</option>
                <option value="radial" style="background: #1a1a2e; color: #ffffff;">‚≠ï Radial</option>
                <option value="grid" style="background: #1a1a2e; color: #ffffff;">‚äû Grid</option>
            </select>
            <select id="cluster-by-select" style="padding: 8px 14px; background: rgba(34, 197, 94, 0.15); border: 1px solid rgba(34, 197, 94, 0.4); border-radius: 8px; color: #ffffff; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                <option value="" style="background: #1a1a2e; color: #ffffff;">üîó Cluster By</option>
                <option value="itemType" style="background: #1a1a2e; color: #ffffff;">üì¶ Type</option>
                <option value="owner" style="background: #1a1a2e; color: #ffffff;">üë§ Owner</option>
                <option value="pmRAGStatus" style="background: #1a1a2e; color: #ffffff;">üö¶ Status</option>
                <option value="cost" style="background: #1a1a2e; color: #ffffff;">üí∞ Cost Range</option>
                <option value="modifiedDate" style="background: #1a1a2e; color: #ffffff;">üìÖ Date</option>
            </select>
            <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
            <button id="grid-toggle" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                ‚ó´ Grid
            </button>
            <button id="reset-view" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                üéØ Reset
            </button>
            <button id="fit-view" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                ‚ä° Fit
            </button>
            <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
            <div style="display: flex; align-items: center; gap: 6px;">
                <button id="zoom-out" class="btn" style="padding: 6px 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: var(--text-primary); font-weight: 600; transition: all 0.2s;">‚àí</button>
                <span id="zoom-level" style="font-size: 12px; font-weight: 600; color: var(--treeplex-primary); min-width: 50px; text-align: center;">100%</span>
                <button id="zoom-in" class="btn" style="padding: 6px 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: var(--text-primary); font-weight: 600; transition: all 0.2s;">+</button>
            </div>
        </div>

        <div id="canvas">
            <!-- Grid Pattern -->
            <svg class="canvas-grid" id="canvas-grid" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; opacity: 0;">
                <defs>
                    <pattern id="grid-pattern" width="40" height="40" patternUnits="userSpaceOnUse">
                        <path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(99, 102, 241, 0.15)" stroke-width="1"/>
                    </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid-pattern)" />
            </svg>
            <svg class="canvas-connections" id="canvas-connections"></svg>
        </div>
    </div>

</body>
</html>
<!-- Cache buster: 1762487974 -->
