<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TreeListy - Universal Project Decomposition by geej</title>
    <!--
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    TreeListy v2.17.0 | Build 411 | 2025-12-13
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Universal Project Decomposition Tool
    - 21 specialized patterns (Generic, CAPEX, Philosophy, LifeTree, Sales, Veo3, Sora2, etc.)
    - AI-powered (Claude, Gemini, ChatGPT) with tunable personas
    - Pattern Translation Engine with shadow data preservation
    - Modern collapsible sidebar UI (icon-based navigation)
    - Smart JSON save with pattern-based filenames
    - LocalStorage auto-save every 2 minutes
    - 50-state undo system
    - PWA-ready (installable on desktop & mobile)

    Changelog (Build 411): ðŸ“– Reader Navigation
    - Sequential prev/next navigation through all nodes in info panel
    - Arrow keys (â† â†’) navigate when panel is open
    - Read mode toggle hides edit controls for distraction-free reading
    - Tree view highlights and scrolls to current node
    - Position indicator shows "3 of 24" style progress

    Previous (Build 410): ðŸ” Zoom to Cursor
    Previous (Build 409): ðŸ–±ï¸ Fix Right-Click Context Menu
    Previous (Build 408): ðŸ”— Tree Agent Full Integration
    Previous (Build 407): ðŸ–±ï¸ Draggable Agent Frame
    Previous (Build 406): âœ¨ Visual Node Highlighting
    Previous (Build 405): ðŸ¤– Live Tree Agent Frame (Phase 1)
    Previous (Build 404): ðŸ’¡ Quick/Deep Mode Tooltips
    Previous (Build 403): âš¡ TreeBeard LifeTree Utility Mode
    Previous (Build 402): ðŸŽ™ï¸ Larry King Biographer Mode in Chat Builder
    Previous (Build 401): ðŸ”˜ Fix Chat Builder multi-choice buttons
    - Settings toggle: "Use Classic Chat Panel" in AI Settings modal
    - Keyboard shortcut: Ctrl+/ (Cmd+/ on Mac) toggles chat
    - Settings persist to localStorage across sessions
    - Smooth transition when switching UI modes
    - Polish: Improved integration with existing keyboard shortcuts

    Previous (Build 395): ðŸŒˆ Visual Feedback System
    Previous (Build 394): ðŸŽ¯ Context-Aware Action Buttons
    Previous (Build 393): ðŸŽ¯ Floating Command Frame (New Chat UI)
    Previous (Build 392): ðŸ©º LifeTree Health Check + ðŸ’¬ GPT-5.2 Support
    Previous (Build 391): ðŸ—‘ï¸ Phase Delete Support
    Previous (Build 390): ðŸŽ¨ Visual Type Distinction for Canvas Nodes
    Previous (Build 389): â™Ÿï¸ Semantic Type Indicators (Chess-like Variations)
    Previous (Build 388): ðŸ”§ Edit Any Depth Node
    - Validates node names before creation - rejects undefined/empty names
    - Extracts name from description if name field missing in JSON
    - New repair_tree command: finds and lets you fix malformed nodes
    - TreeBeard can now say "repair tree" to scan for issues

    Previous (Build 383): ðŸ§  TreeBeard Memory Mining + Real-Time Saves
    Previous (Build 380): ðŸŽ™ï¸ Larry King Mode Indicator
    Previous (Build 379): ðŸ”§ Fix: Pattern Restored on Page Reload
    Previous (Build 378): ðŸŽ™ï¸ TreeBeard Tiered Skills + Larry King Biographer
    Previous (Build 377): ðŸ§  TreeBeard Conversation Mode - Natural Language Actions
    Previous (Build 376): ðŸ” Smart Decade Search in find_node
    Previous (Build 375): ðŸŒ³ LifeTree Biographer - Structured Data Gathering
    Previous (Build 374): ðŸŒ³ LifeTree Quick Insight Context
    Previous (Build 373): ðŸ“ Simplified Save/Open Labels
    Previous (Build 372): ðŸ“¦ .treelisty Bundle Export/Import
    Previous (Build 371): ðŸ“Ž Artifact Side Panel
    Previous (Build 370): ðŸŽ¤ Voice Capture System
    Previous (Build 369): ðŸ”§ Fix TreeBeard Button - Syntax Error Fix
    Previous (Build 368): ðŸ§  Conversation Mode - Full AI Intelligence
    Previous (Build 367): ðŸŽ‚ TreeBeard Birthday Method - Proactive Biographer
    Previous (Build 366): ðŸŽ™ï¸ TreeBeard Biographer Mode (LifeTree)
    Previous (Build 365): ðŸŒ³ LifeTree Pattern - Biographical Timeline
    Previous (Build 364): ðŸ”— Enhanced Hyperedge Info Modal
    Previous (Build 360): ðŸ”§ Fix Syntax Error - Splash Screen Freeze
    Previous (Build 359): ðŸ”§ Fix CORS for Local Version Check
    Previous (Build 358): ðŸ”„ Check for Updates Button
    Previous (Build 357): ðŸ”” Version Check Fix for Local Files
    Previous (Build 355): ðŸŒ³ TreeBeard Phase 1 - Smarter & More Personal
    Previous (Build 354): ðŸŒ³ Multi-Tree Import Option
    Previous (Build 353): ðŸ” Smart Import Wizard

    Previous (Build 352): ðŸ§Š Fix 3D View Mode Switching
    Previous (Build 351): Hero Session Code Display for easier sharing
    Previous (Build 350): Fix mobile menu tap interactions
    Previous (Build 349): ðŸ“± Mobile Menu - Absolute Top Layer
    Previous (Build 348): ðŸ“± Mobile Menu - Force Pointer Events
    Previous (Build 347): ðŸ“± Mobile Menu - Fix Button Taps
    Previous (Build 346): ðŸ“± Mobile Menu - Complete Rewrite
    Previous (Build 339): ðŸ“± Mobile Menu High Contrast
    Previous (Build 338): ðŸ“± Mobile Hamburger Fix
    Previous (Build 337): ðŸ”· Gemini 3 Pro Preview Support
    Previous (Build 336): ðŸ“± File System Mobile UI

    Previous (Build 325): ðŸ“… Meeting Link Collaboration System
    Previous (Build 324): ðŸŽ™ï¸ Voice Chat UX Improvement
    Previous (Build 323): ðŸ› Bug fixes - version notification, welcome tree
    Previous (Build 318): â±ï¸ Fix Edge Function Timeout - Use Streaming
    Previous (Build 317): ðŸŒ Nano Banana Image Generation
    Previous (Build 316): ðŸ§  Wiser AI Prompts - Context Injection
    Previous (Build 315): ðŸ§  Wiser TreeBeard - Deep Knowledge Injection
    Previous (Build 314): ðŸ“ Fix Tree View Zoom Reset Position
    Previous (Build 307): ðŸ› TreeBeard Context Fix (children vs phases)
    Previous (Build 306): ðŸŽ¨ UI Z-Index Fix - Chat Bubble Overlap
    Previous (Build 305): ðŸ› TreeBeard Empty Project Bug Fix (wizard)
    Previous (Build 304): ðŸ” Search Result Navigation Fix
    Previous (Build 302): ðŸ› Fix False Update Toast
    Previous (Build 301): ðŸ› Fix 3D Sort Refresh
    Previous (Build 300): ðŸŽ¯ Sort-Aware 3D Layouts
    Previous (Build 299): ðŸ–±ï¸ 3D Usability - Hover & Interaction
    Previous (Build 298): âœ¨ 3D Title Polish
    Previous (Build 297): ðŸŽ¯ 3D Quick Wins - Dependencies & View State
    Previous (Build 289): ðŸ–±ï¸ Mouse-Based 3D Fly Mode
    Previous (Build 288): ðŸ› Canvas View Info Panel Fix
    Previous (Build 287): ðŸš€ 3D Fly Mode + Enhanced Navigation
    Previous (Build 285): ðŸ“ Save & Restore View State
    Previous (Build 284): ðŸ’¾ Version Conflict Detection + Unsaved Warning
    Previous (Build 283): ðŸ”— Smart Hyperedge Labels + Fix Deep Dive

    Previous (Build 275): ðŸ”§ Debug Host Chat Box + Improved Logging
    - Auto-close Live Sync modal when first guest connects
    - Floating chat box with API key sharing
    - Session keys for guests that clear on leave

    Previous (Build 267): ðŸ”§ Fix Double Room Creation + Deploy Functions
    - Migrated API key sharing from Watch Mode to Firebase Live Sync modal
    - Removed deprecated Watch Mode

    Previous (Build 263): ðŸ”¥ Fix Firebase Live Sync Room Creation
    - FIX: Changed Firestore collection from 'rooms' to 'syncRooms' to match security rules

    Previous (Build 262): ðŸ‘¥ Dynamic Team Management System
    - NEW: Project Team section in Project Settings - add Host, Collaborators, Contributors
    - NEW: Unique initials system - first letter, adds 2nd if collision, 3rd if needed
    - NEW: Email association for accountability - hover to see email
    - NEW: Color-coded badges: Host (gold), Collaborator (blue), Contributor (green)
    - FIX: Replaced hardcoded Dad/Owen buttons with dynamic team member buttons
    - UX: Team members appear in Edit modal and Watch mode for quick selection

    Previous (Build 261): ðŸŽ¨ Fix Imagen 4 Image Generation
    - FIX: Updated model IDs to correct Imagen 4 API names
    - Models: imagen-4.0-fast-generate-001, imagen-4.0-generate-001, imagen-4.0-ultra-generate-001

    Previous (Build 260): ðŸŽ¯ AI Specialist Context
    - NEW: specialistContext field on tree root - domain expertise prompt
    - Edit via Project Settings modal (right-click root â†’ Project Settings)

    Previous (Build 259): ðŸ’¬ TreeBeard Chat Redesign
    - Increased default panel size (440x520 for more chat space)
    - Removed quirky "Hoom, hm..." sayings - cleaner welcome

    Previous (Build 258): ðŸŽ¤ Voice Input Fix
    - Fixed: Voice button now works (added touch support for mobile)
    - Added interim results - see transcription as you speak

    Previous (Build 257): ðŸ’¾ Local JSON Save During Collaboration
    - "Save JSON" button in Live Sync modal - download current tree anytime
    - "Auto-save on sync" checkbox - automatically download JSON after each remote sync
    - Each collaborator maintains their own local JSON backup
    - Filename includes pattern, project name, and timestamp

    Previous (Build 256): â†©ï¸ Undo Support for Remote Sync + Editor Attribution
    - Remote sync undo-able, "Last edit by" display, setMyDisplayName/setCollaboratorName

    Previous (Build 255): ðŸŽ® TreeBeard Playground Mode - Test Improved Prompts
    - "improve prompt: X" pattern, action buttons, Playground Mode with model selector

    Previous (Build 254): ðŸ“ Info Panel Redesign + TreeBeard Visual Polish
    - Renamed "TreeListy Assistant" to "TreeBeard" (wise tree guardian)
    - Made the TreeBeard panel draggable by its header
    - Panel is resizable (drag bottom-right corner)
    - Panel position and size saved to localStorage

    Previous (Build 252): ðŸ› Fix splash screen not loading (syntax error in Build 251)
    - Edge Function streaming proxy (netlify/edge-functions/claude-stream.ts)
    - callClaudeStreamingAPI() - SSE streaming with no timeout limit
    - callClaudeEdgeBuffered() - buffered Edge response for compatibility
    - Automatic fallback chain: Edge â†’ Regular Function â†’ Direct API

    Previous (Build 250): ðŸ§­ Conversational Tree Navigation & Editing
    - find_node, Tree traversal, expand/collapse, field editing, ai_enhance_field
    - add_child, delete_node, zoom controls, list_children, node_info
    - Natural language patterns for navigation

    Previous (Build 249): ðŸŽ¤ Expanded Chat Assistant Commands (35 total)
    - File operations - import_text, load_json, import_excel, share_url, live_sync
    - Search, AI operations, Canvas layouts, Selection commands

    Previous (Build 248): ðŸ’¬ Chat Assistant with Voice Control
    - Floating chat bubble (bottom-right) - click or press Ctrl+/
    - Conversational AI assistant that understands TreeListy context
    - Execute commands via natural language ("switch to canvas", "export excel")
    - Voice input - hold microphone button to speak (Web Speech API)
    - Quick action chips for common operations
    - Context-aware responses (knows current project, pattern, selection)

    Previous (Build 247): ðŸ§  AI-Enhanced System Prompts (+2.6 avg sophistication)
    - IMPROVED: Generic Deep Dive now uses McKinsey RAID methodology
      - SubItem types: risk-factor, dependency, assumption, subtask, constraint, success-metric
      - Critical Path Method and stakeholder impact analysis
    - IMPROVED: Generic persona now Senior Financial Planning Manager (15yr Fortune 500)
      - Monte Carlo risk modeling, EVM, Stage-Gate governance, PMI/COSO frameworks
    - IMPROVED: Strategy Consultant now references named frameworks
      - Porter's Five Forces, McKinsey 7-S, BCG Matrix, Blue Ocean Strategy
      - Thought leaders: Michael Porter, Clayton Christensen, Rita McGrath
    - IMPROVED: Course Designer now uses pedagogical frameworks
      - Bloom's Taxonomy, ADDIE, Gagne's Nine Events, Kirkpatrick evaluation
      - Adult learning theory (Knowles' andragogy), backward design (Wiggins & McTighe)

    Previous (Build 246): ðŸŽ¨ AI-Optimized Image Style Prompts

    Previous (Build 245): ðŸ“ Enhanced Whiteboard Sketch Style for Image Generation

    Previous (Build 244): ðŸ“· Professional Canvas Export as PNG
    - NEW: Export Canvas view as high-quality PNG image (ðŸ“· button)

    Previous (Build 243): ðŸŽ¯ Improved CAPEX Pattern Detection in Excel Import
    - FIX: AI prompt now explicitly lists CAPEX pattern detection hints
    - FIX: Budget/Actual/Variance, ROI, Risk/Mitigation columns now trigger CAPEX pattern

    Previous (Build 242): ðŸ“Š AI Multi-Sheet Excel Import
    - NEW: AI analyzes ALL sheets in workbook and suggests import strategy
    - NEW: Strategy options: combine similar, separate phases, skip reference sheets
    - NEW: AI recommends which sheets to import as phases
    - NEW: Automatic column mapping for each sheet during multi-import
    - NEW: Progress indicator during multi-sheet processing
    - NEW: "Pick Sheets Manually" fallback option
    - IMPROVED: Each sheet becomes a phase with AI-suggested names

    Previous (Build 241): ðŸ¤– AI-Powered Excel Import
    - NEW: AI analyzes Excel structure and auto-detects column mappings
    - NEW: AI recommends best pattern based on data content
    - NEW: Simplified import UI with confidence scores
    - NEW: Click-to-adjust mapping cards (no more dropdown walls)

    Previous (Build 239): ðŸŽ™ï¸ Free Speech - Stream of Consciousness Voice Capture
    - NEW: Free Speech pattern for psychological pattern analysis
    - NEW: Web Speech API integration for voice recording
    - NEW: Nudge system with gentle prompts during silence
    - NEW: Gamification metrics (flow score, authenticity, word count)
    - NEW: Privacy-first architecture (transcript deleted after analysis)
    - NEW: AI analysis finds repetition, contradictions, implicit beliefs
    - NEW: ðŸŽ™ï¸ Free Speech button in AI Tools sidebar

    Previous (Build 238): ðŸ“¥ Import Text UX Elevation
    - NEW: ðŸ“¥ Import button in header toolbar (prominent placement)
    - NEW: Empty state CTA with "Import Text" and "Chat Builder" buttons
    - IMPROVED: Import Text now discoverable as primary workflow entry point
    - IMPROVED: Empty state guides new users to main input methods

    Previous (Build 237): ðŸ§  Super Hybrid Prompt Engineering Meta-Prompt
    - ENHANCED: Prompt AI uses "Super Hybrid" meta-prompt (A/B tested, 80.2%+ score)
    - NEW: 3-phase approach: Draft â†’ Self-Critique â†’ Refined Output
    - NEW: Expert panel synthesis (Anthropic/OpenAI/Production perspectives)
    - NEW: Specific persona requirement ("senior engineer at Stripe with 8 years" not "expert")
    - NEW: Agent orchestration contracts for multi-agent workflows
    - NEW: Concrete examples required (not placeholders)
    - IMPROVED: Prompt outputs now directly usable (no meta-commentary)

    Previous (Build 236): ðŸ—‘ï¸ Fix delete sync + nested subtask deletion
    - FIX: Delete operations now immediately sync to Firebase collaborators
    - FIX: Nested subtasks (subtasks within subtasks) can now be deleted
    - FIX: Delete triggers auto-save to localStorage
    - FIX: No longer requires 2-second poll interval to detect deletions

    Previous (Build 235): ðŸ”¥ Firebase sync triggers auto-save to localStorage
    - NEW: ðŸ”¥ Firebase integration for real-time collaboration
    - NEW: Anonymous auth (no sign-in required)
    - NEW: "ðŸ”„ Live Sync" button in toolbar
    - NEW: Start/Join live sync session with shareable room ID

    Previous (Build 230): â˜ï¸ Load from Google Drive Button + Recent Files
    - NEW: â˜ï¸ button in toolbar opens "Load from Google Drive" modal
    - NEW: Paste any Google Drive share link or file ID
    - NEW: Recent Shared Trees list (last 8 files, stored locally)
    - NEW: Click any recent file to instantly reload it
    - NEW: Pattern-specific icons in recent files list
    - NEW: Clear button to remove recent files history
    - FIX: Files loaded via ?gdrive= URL also saved to recent list

    Previous (Build 229): ðŸ”— Auto-Sync Sort & Cluster Controls
    - NEW: Sort and Cluster dropdowns now auto-sync by default
    - NEW: Changing Sort automatically updates Canvas Cluster to match
    - NEW: Changing Cluster automatically updates Tree Sort to match
    - NEW: ðŸ”—/ðŸ”“ toggle button to link/unlink the controls
    - UX: Renamed "Default Order" to "Sort By" for clarity
    - UX: Toast notifications show sync status

    Previous (Build 228): ðŸ–±ï¸ View Controls Guide in Help
    - NEW: Comprehensive "View Controls (Tree vs Canvas)" section in Help modal
    - NEW: Clear mouse control differences between Tree and Canvas views
    - NEW: Middle mouse panning highlighted for Canvas users
    - NEW: Tips for users without middle mouse button
    - NEW: Canvas navigation tips (Fit button, hyperedges, box select)

    Previous (Build 227): ðŸ”§ Fix Pattern Detection from Google Drive Links
    - FIX: Pattern selector now properly updates when loading from ?gdrive= URLs
    - FIX: Philosophy, CAPEX, and other patterns correctly detected and displayed
    - FIX: Custom pattern labels preserved from shared files
    - FIX: Sort dropdown and AI button update to match loaded pattern

    Previous (Build 226): â˜ï¸ Google Drive Proxy for CORS-Free Loading
    - NEW: Netlify function gdrive-proxy fetches Google Drive files server-side
    - FIX: ?gdrive=FILE_ID URLs now load reliably (no CORS errors)
    - FIX: Host import from Google Drive uses proxy
    - FIX: Handles Google's virus scan confirmation page automatically
    - Works for both hosts and collaborators clicking email links

    Previous (Build 225): ðŸ–±ï¸ Mouse-Driven Chat Builder with Clickable Choices
    - AI questions now include clickable choice buttons
    - [CHOICE:label] markers auto-convert to purple pill buttons
    - Click to answer - no typing required for most questions

    Previous (Build 224): ðŸ“§ Separate Async vs Live Collaboration
    - "Async Share (Chess by Mail)" - share Google Drive link, collaborators use own keys
    - "Live Session (Share API Keys)" - share your keys for 4 hours

    Previous (Build 223): ðŸ“§ Collab Wizard - Host Import & Email Invitations
    - Hosts can import trees from Google Drive, Dropbox, or direct JSON URLs
    - Email invitation workflow with Send, Copy Text, and Mail App buttons

    Previous (Build 222): ðŸ”‘ Live Collab Sessions - Share API Keys with Collaborators
    - Host shares encrypted API keys with collaborators during live sessions
    - Guests use host's keys automatically - never see the actual keys
    - 4-hour session limit with auto-cleanup
    - Session status tracking (guest count, expiration)
    - Uses Netlify Blobs for secure server-side storage

    Previous (Build 221): ðŸŒ Nano Banana Pro - Google's Best Image Model
    - Uses Gemini's reasoning for smarter image composition
    - Falls back to Imagen 4 if preferred
    Previous (Build 220): âœ¨ AI-Powered Imagen Prompt Crafting
    - 8 visual style presets: Whiteboard, Infographic, Cartoon, Tech, Nature, Minimal, Isometric, Academic
    - "AI Craft Prompt" button uses Gemini to write optimized Imagen 4 prompts
    - Pattern-aware: Uses your tree's context (Philosophy, Sales, etc.) for better prompts
    - Word count indicator (15-25 words = green = ideal length)
    - Follows Imagen 4 best practices: subject first, style keywords, lighting
    - Fun, educational, whiteboard-style default for approachable visuals
    Previous (Build 219): ðŸ” Image Preview Lightbox for Imagen 4
    - Click any generated image to view full-size in lightbox
    - Examine details before choosing which image to attach
    - Download button to save images locally
    - Attach to Node button from preview view
    - Escape key or click outside to close
    - Shows prompt used for each image
    Previous (Build 218): ðŸŽ¨ Imagen 4 Image Generation + Model Updates
    - NEW: Generate images from selected nodes using Google Imagen 4
    - NEW: Right-click â†’ "Generate Image" in Canvas view
    - NEW: Choose aspect ratio (1:1, 16:9, 9:16, 4:3, 3:4)
    - NEW: Imagen 4 Standard, Fast, and Ultra models
    - NEW: Attach generated images to nodes
    - UPDATED: Gemini models to 2.5-pro and 2.5-flash (stable)
    - UPDATED: OpenAI models: GPT-5, GPT-5-mini, o3, o4-mini
    - UPDATED: Claude Opus 4.5 (claude-opus-4-5-20251101)
    Previous (Build 217): ðŸŒŸ Added Claude Opus 4.5 Model Option
    Previous (Build 216): ðŸ‘¥ Collaboration Section Moved to Prominent Position
    - MOVED: Collaboration section now appears right after Name/Description/Icon
    - UI: New highlighted card design with purple gradient background
    - UI: More compact layout - Contributor field with team member buttons inline
    - UI: Comments textarea in same card for quick access
    - UX: No more scrolling to find collaboration features

    Previous (Build 215): ðŸŽ¯ User-Refined Canvas Layout for Welcome Tree
    - Applied user's hand-positioned node coordinates
    - More spread-out layout with better visual balance
    - Items positioned to showcase hyperedge connections

    Previous (Build 214): ðŸŽ¨ Visually Striking Canvas Layout for Welcome Tree
    - NEW: Symmetrical 6-phase radial layout - root at center (700, 450)
    - NEW: 5 colorful hyperedges demonstrating visual groupings:
      â€¢ Dual View System (indigo) - Tree/Canvas connection
      â€¢ AI Creation Pipeline (emerald) - Build â†’ Import â†’ Enhance â†’ Analyze
      â€¢ Collaboration Workflow (amber) - Share â†’ Tag â†’ Comment â†’ Sync
      â€¢ Canvas-Specific Features (pink) - Canvas/Hyperedges/Dependencies
      â€¢ Start Here (violet) - Three paths to begin
    - NEW: Power Features phase expanded by default at top center
    - NEW: Hyperedges item shows "Done" status as proof they work
    - UI: Canvas-first design - visually striking layout showcases hyperedge feature

    Previous (Build 213): ðŸŒ³ Updated Welcome Tree for New Users

    Previous (Build 211): ðŸ‘ï¸ Watch Mode + Google Drive Links ("Chess by Mail")
    - NEW: Watch Mode - poll shared files for real-time sync
    - NEW: ?gdrive=FILE_ID URL parameter - email links that load trees!
    - NEW: ?watch=URL parameter - auto-opens Watch Mode for live sync
    - NEW: File System Access API support for local shared files
    - NEW: Configurable poll intervals (5s/10s/30s/1min)
    - NEW: Auto-detect contributor changes, skip self-saves
    - NEW: Visual sync indicator with pulse animation
    - UI: Watch Mode modal with status panel
    - WORKFLOW: Email Google Drive links to collaborators for async editing

    Previous (Build 210): ðŸ‘¥ Collaboration Comments & Contributor Tags

    Previous (Build 209): ðŸ› Fix Canvas Node Selection Persistence

    Previous (Build 207): ðŸ’° New CAPEX / Angel Pitch Pattern

    Previous (Build 206): ðŸš€ Investor-Ready CFO Persona

    Previous (Build 205): ðŸ’° Fix $0 Display on Non-Cost Nodes

    Previous (Build 199): Fix Merge Deep Copy

    Previous (Build 198): Fix view variable name

    Previous (Build 197): Fix undo function name

    Previous (Build 196): Wrong function name (saveToHistory)

    Previous (Build 193): ðŸ”§ IIFE with DOM Ready Check

    Previous (Build 192): ðŸ’° Hide $0 Cost in Canvas View
    - FIX: Cost badge only shows in canvas if pattern supports cost AND cost > 0

    Previous (Build 191): âœ¨ New "Explore TreeListy" Starter Tree
    - NEW: Self-describing starter tree teaches TreeListy by example
    - NEW: 4 phases: Discover, Create, Enhance, Share

    Previous (Build 190): ðŸŽ¨ Layout Fix - Edges Panel vs Info Panel

    Previous (Build 189): ðŸ“§ Improved Collaboration Email & Merge UI
    - NEW: "Merge Branch" button in sidebar to paste collaboration URLs
    - NEW: "Copy Email" button copies rich HTML with clickable button

    Previous (Build 188): ðŸ”€ Smart Merge with Project Validation
    - NEW: Detects if wrong project is loaded when merging
    - NEW: Shows expected vs current project name comparison

    Previous (Build 187): ðŸ¤ Complete Collaboration System (Branch & Merge)
    - NEW: ðŸ“¥ ?branch= URL detection and parsing on page load
    - NEW: ðŸ¤ Branch editing mode with purple banner for collaborators
    - NEW: ðŸ“¤ "Share Back" button to send edits to original author
    - NEW: ðŸ”€ Merge modal for accepting incoming collaboration changes

    Previous (Build 186): ðŸ¤ Share for Collaboration UI
    - NEW: ðŸ”‘ getDeviceFingerprint() - Canvas-based device ID for contributor tracking
    - NEW: ðŸ—ºï¸ getAncestryPath(nodeId) - Get breadcrumb path to any node
    - NEW: ðŸ“¦ extractSubtree(nodeIds, hyperedgeId) - Extract nodes for sharing
    - NEW: ðŸ”— generateBranchURL(branch) - Create shareable ?branch= URL
    - NEW: ðŸ“ Size validation - Blocks sharing if subtree > 8KB URL limit
    - FOUNDATION: isBranchMode() check, currentBranch state variable

    Previous (Build 184): ðŸ› Fix New Project Not Updating Canvas
    - FIX: ðŸ› "New Project" now calls renderCanvas() to update canvas view immediately
    - Previously only tree view was updated, canvas stayed on old project

    Previous (Build 183): ðŸ‘ï¸ Hyperedge Hover Dims Unrelated Nodes
    - NEW: ðŸ” Hovering a hyperedge now dims all nodes NOT in that hyperedge (0.25 opacity)
    - NEW: âœ¨ Member nodes get highlighted with purple glow on hover
    - ENHANCED: Smooth 0.3s transition for opacity and glow effects
    - FIX: ðŸ› Fixed dataset.itemId lookup (was using wrong attribute name)

    Previous (Build 181): ðŸ”§ Fix Hyperedge/Connection Clipping on Zoom Out
    - FIX: ðŸ› Hyperedges and connections were clipped to small rectangle on zoom out
    - FIX: canvas-connections SVG now uses 20000x20000px area (like dependency-svg)
    - FIX: Added SVG_OFFSET (5000px) to all drawing coordinates
    - IMPROVED: Hyperedges now render correctly at any zoom level (10%-500%)

    Previous (Build 180): ðŸ”— Hyperedge Visibility Management
    - NEW: ðŸ‘ï¸ Hover dimming - other hyperedges fade when you hover one
    - NEW: ðŸŽ¯ Focus View button in hyperedge info modal to isolate view
    - NEW: ðŸ”— "Edges" button in canvas toolbar to manage hyperedge visibility
    - NEW: Visibility panel with checkboxes, Show All/Hide All, focus shortcuts
    - ENHANCED: Each hyperedge wrapped in SVG group for better interaction

    Previous (Build 179): ðŸ’Š Capsule Geometry for 2-Node Hyperedges
    - NEW: ðŸŽ¯ Deep Dive auto-focuses on hyperedge members
    - NEW: Auto-arranges analyzed nodes in clean layout
    - FIX: ðŸ› Hyperedge now clickable

    Previous (Build 176): ðŸ§  AI-Powered Relationship Analysis
    - NEW: ðŸ§  AI analyzes selected nodes and DISCERNS the philosophical relationship
    - NEW: AI generates: relationshipType, dialecticalRelation, argumentativeFlow, conceptualBridge
    - NEW: AI identifies: philosophical tension and potential synthesis

    Previous (Build 175): ðŸ›ï¸ Descriptive Hyperedge Labels
    - NEW: ðŸ›ï¸ Hyperedge labels show dialectical relation type
    - NEW: ðŸ‘† "click to explore relationship" hint below hyperedge label

    Previous (Build 174): ðŸŽ¨ Hyperedge Visual Enhancement
    - NEW: ðŸŽ¨ Hyperedge color permeates member nodes (tinted border + glow)
    - NEW: ðŸ“¦ Hyperedge hull includes both selected nodes AND generated subitems (Venn diagram)
    - NEW: ðŸ–±ï¸ Clickable hyperedges - shows philosophy relationship info panel

    Previous (Build 173): ðŸ”— Fix Hyperedge Visualization
    - FIX: ðŸ› Hyperedges not visible after Deep Dive Analysis
    - FIX: Division by zero in padding calculation when nodes overlap
    - FIX: NaN coordinates causing polygon to not render

    Previous (Build 169): ðŸŽ“ Deep Dive Analysis (Structured Scholar)
    - NEW: Right-click â†’ "Deep Dive Analysis" on any node(s)
    - NEW: Generates 2-4 subItems per node (objections, implications, hidden premises)
    - NEW: Auto-fills missing fields (speaker, keyTerms, textualReference)
    - NEW: Multi-select support - Ctrl+click nodes, then Deep Dive all at once
    - NEW: Auto-creates purple hyperedge linking analyzed nodes
    - NEW: Philosophy-specific prompts using Structured Scholar technique
    - NEW: Generic pattern support for non-philosophy deep dives

    Previous (Build 168): Fix Undefined Text in Tree/Canvas Views
    - FIX: ðŸ› Phase subtitle undefined - Now conditionally rendered
    - FIX: ðŸ› Item/Node icons undefined - Added fallbacks (ðŸ“‹, ðŸ“„, ðŸŒ³)

    Previous (Build 167): Philosophy Structured Scholar Prompt (+4.7% depth)
    - ENHANCED: ðŸŽ“ Philosophy prompts use "Structured Scholar" technique (93% vs 88% baseline)
    - NEW: Mandatory NAMED secondary sources requirement (e.g., "Vlastos", "Williams")
    - NEW: Standard objections must cite specific philosophers
    - NEW: Expanded itemTypes: implicit-premise, distinction, thought-experiment, objection
    - NEW: Required metadata: tradition, method, keyTerms, interlocutors, secondarySources
    - RESEARCH: Tested 10 meta-prompting techniques; Structured Scholar won

    Changelog (Build 166): Philosophy Pattern Prompt Optimization
    - ENHANCED: ðŸ§  Philosophy pattern prompts optimized based on A/B testing (+10% structural fidelity)
    - NEW: Explicit itemType examples with common error warnings
    - FIX: "Bee analogy = question" misclassification now explicitly corrected
    - IMPROVED: Deep Mode philosophy instructions with full JSON examples

    Previous (Build 165): Cognitive Citadel Foundation
    - NEW: ðŸ›¡ï¸ Migration System - Schema versioning for backward compatibility
    - NEW: ðŸ›¡ï¸ Provenance Stamping - All nodes track origin (user/ai-import/legacy)
    - NEW: ðŸ›¡ï¸ Dialectic Mode - Forces AI to identify assumptions & counter-arguments
    - NEW: Phenomenology array on nodes (future: capture "residue" that doesn't fit structure)
    - NEW: Metrics stub on nodes (future: attention economics tracking)
    - FIX: AI-imported content now properly tagged with provenance

    Previous (Build 164): Model Selector + Latest Model IDs
    - NEW: ðŸŽ¯ Model Selector Dropdown - Choose specific AI models per call
    - NEW: Claude: Haiku 3 (server), Haiku 3.5, Sonnet 4, Opus 4
    - NEW: Gemini: Flash 2.0, Pro 2.5 Preview
    - NEW: ChatGPT: 4o-mini, GPT-4o, o1 reasoning
    - FIX: Updated Gemini models to latest (2.0-flash stable, 2.5-pro-preview)

    Previous (Build 163): Fix undefined response error + null guard
    - FIX: Added null guard for AI response to prevent "Cannot read properties of undefined"
    - FIX: Better error message when AI returns empty/undefined response
    - INFO: Anthropic intentionally blocks direct browser API calls (no CORS headers)
    - INFO: This is NOT a bug - it's their security architecture requiring server proxy

    Previous (Build 162): AGGRESSIVE Large Tree Handling
    - FIX: ðŸ›‘ Large trees (30+ items) now FORCE treeUpdate: null in enhance mode
    - FIX: Removed instruction to "echo baseline" that was causing 32K responses

    Previous (Build 161): Smart Fallback for Large Trees
    - NEW: ðŸš€ Auto-fallback to fast mode on timeout or response cutoff
    - NEW: Large tree detection (50+ items) - warns about potential timeout
    - NEW: Timeout auto-retry - switches to fast mode and retries automatically

    Previous (Build 160): Wizard Token Optimization + Claude CORS Fix
    - FIX: ðŸª„ Wizard "response cut off" bug - Added STRONG instruction to NOT echo entire tree
    - FIX: ðŸ”„ Claude API routing - Anthropic blocks ALL direct browser calls (CORS policy)
    - INFO: Deep Mode for Claude MUST use Netlify proxy (10s timeout applies)
    - INFO: For unlimited Deep Mode, use Gemini (allows direct browser API calls)

    Previous (Build 158): Based on Gemini code review recommendations
    - FIX: ðŸ› Hyperedges Data Loss Bug - importAnalyzedTree and executeFlexibleImport now initialize hyperedges: []
    - FIX: âš¡ Performance - drawHyperedges now uses O(1) Map lookup instead of O(N) recursive getNodeById
    - NEW: ðŸ“Š Deep Mode Progress UI - Real-time chunk-by-chunk progress bar during semantic analysis
    - NEW: ðŸ”— Hyperedge Management UI - Delete hyperedges from root node info panel (no more JSON editing!)
    - Added window.deleteHyperedge() global handler with undo support

    Previous (Build 157):
    - FIX: ðŸ”‘ API Key Storage Bug - EmbeddingManager now uses correct localStorage key format
    - Fixed: Changed 'openai-api-key' â†’ 'openai_api_key' (underscore format)
    - Fixed: Changed 'gemini-api-key' â†’ 'gemini_api_key' (underscore format)
    - Your saved API keys from Build 155 and earlier are now accessible again!

    Previous (Build 156):
    - NEW: ðŸ§  Semantic Chunking Engine - NLP-powered text segmentation for large documents
    - NEW: SemanticChunker class with cosine similarity and 90th percentile adaptive thresholding
    - NEW: EmbeddingManager service supporting OpenAI text-embedding-3-small & Gemini text-embedding-004
    - NEW: Chunk-by-chunk processing in Quick Mode and Deep Mode (prevents hallucinations on large files)
    - NEW: Visual chunk distribution UI showing detected semantic sections
    - ENHANCED: Automatic structural fallback (Markdown headers â†’ paragraphs â†’ lines) when no embedding provider
    - TECH: Sliding window context buffering, batch API processing (max 20 per batch)
    - TECH: Silent error handling with graceful degradation

    Previous (Build 155):
    - FIX: Cluster-by dropdown scope issue - Moved function to global scope
    - Pattern-specific options now properly populate for Philosophy, Film, Veo3, Sora2, Sales, Roadmap
    - Function now accessible from all pattern switch and file load handlers

    Previous (Build 154):
    - FIX: Cluster-by dropdown now properly dynamic (removed hardcoded HTML)
    - NEW: Philosophy sort options - speaker, argument type, validity, school, claim name
    - NEW: Film sort options - visual style, lighting mood, camera movement, AI platform, duration
    - ENHANCED: Cluster-by and sort dropdowns now fully pattern-aware

    Previous (Build 153):
    - FIX: Pattern-specific clustering - Dropdown now shows relevant fields per pattern
    - Philosophy: argumentType, validity, speaker, philosophicalSchool
    - Film: visualStyle, lightingMood, cameraMovement, aiPlatform
    - Veo3/Sora2: Flow mode, beat type, cameo, physics complexity
    - Sales: leadStage, leadSource, dealSize
    - ENHANCED: Dynamic cluster-by options update on pattern switch and file load

    Previous (Build 152):
    - NEW: Wolfram-style Hyperedges - N-ary relationships (montage, argument, theme, etc.)
    - NEW: Convex Hull Visualization - Hyperedges render as semi-transparent blobs in Canvas View
    - NEW: Multi-select Hyperedge Creation - Ctrl+Click nodes, right-click "Create Hyperedge"
    - NEW: Provenance Stamping - All nodes track creation source (ai-sonnet, ai-gemini, user, etc.)
    - NEW: Root-level Hyperedge Storage - Cross-phase relationships (Film flashbacks, Philosophy refutations)
    - ENHANCED: Graham Scan Algorithm - O(n log n) convex hull computation for hyperedge visualization

    Previous (Build 151):
    - FIX: Smart Suggest for videoPrompt - No more "Okay, buckle up!" conversational fluff
    - NEW: Veo3/Sora2 Smart Suggest - Full field suggestions for new AI video patterns

    Previous (Build 150):
    - NEW: Veo3 (Google) & Sora2 (OpenAI) AI Video Patterns - Platform-specific workflows
    - NEW: Metadata Clustering in Canvas - Group nodes by type, owner, status, cost, or date
    - ENHANCED: Force-Directed Layout - Barnes-Hut O(n log n), collision detection, 500 iterations
    - FIX: Extended Thinking temperature must be 1 (Claude API requirement)

    Previous (Build 148):
    - NEW: Collapsible AI Tools Sidebar - Icon-based left-docked navigation (60px â†’ 260px on hover)
    - NEW: Modern Chat UI - Neutral slate grey for AI, vibrant primary for user (ChatGPT aesthetic)
    - NEW: Typography Improvements - Larger titles (17px), better hierarchy, improved scannability
    - NEW: Zoom controls integrated into sidebar above Settings (fixes layout conflict)
    - ENHANCEMENT: Reclaimed ~200px canvas width when sidebar collapsed
    - FIX: Removed standalone zoom panel that was obstructing AI sidebar

    Previous (Build 147):
    - NEW: Pattern Translation Engine - Convert Generic â†’ Sales (and reverse) with field mapping
    - NEW: Shadow Data Preservation - Original data backed up during translation
    - FIX: Temperature parameter now correctly applied from Creativity slider

    Previous (Build 146):
    - NEW: AI Tuner - Customize AI tone, verbosity, creativity, and custom instructions
    - NEW: Persistent AI personas - Settings saved in tree JSON and travel with file
    - NEW: Live preview in AI Settings modal shows before/after prompt transformation

    Previous (Build 145):
    - NEW: Filesystem pattern "Digital Librarian" AI - Smart Suggest for all file metadata fields
    - COMPLETE: All 15 patterns now have pattern-specific Smart Suggest coverage

    Previous (Build 144):
    - FIX: Canvas View dependency arrows for hidden phases (no more random purple lines)
    - FIX: Philosophy Pattern AI Analysis using correct persona (not generic PM)
    - FIX: Pattern loading from JSON handles both string and object formats

    Previous (Build 143):
    - FIX: CORS protection for ALL AI providers (Gemini, ChatGPT, Claude)
    - FIX: Clear error messages when using Gemini/ChatGPT from local files
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -->

    <!-- PWA Configuration -->
    <link rel="manifest" href="./manifest.json" id="pwa-manifest">
    <script>
        // Remove manifest link on file:// protocol to prevent CORS errors
        if (window.location.protocol === 'file:') {
            document.getElementById('pwa-manifest')?.remove();
        }
    </script>
    <!-- BUILD 328: Single source of truth for version info -->
    <script>
        window.TREELISTY_VERSION = {
            major: '2.17.0',
            build: 411,
            date: '2025-12-13',
            get full() { return `v${this.major} â€¢ Build ${this.build}`; },
            get title() { return `TreeListy v${this.major} | Build ${this.build} | ${this.date}`; }
        };
    </script>
    <meta name="theme-color" content="#6366f1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TreeListy">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%236366f1'/><text x='50' y='70' font-size='70' text-anchor='middle' fill='white'>ðŸŒ³</text></svg>">
    <meta name="description" content="Visual project management and hierarchical data organization tool with AI-powered insights">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            /* Default Theme */
            --treeplex-primary: #6366f1;
            --treeplex-primary-dark: #4f46e5;
            --phase-0: #5FA463;
            --phase-0-light: #6FB56E;
            --phase-0-dark: #4A8C4E;
            --phase-1: #3B8FCC;
            --phase-1-light: #4A9DD9;
            --phase-1-dark: #2B7AB8;
            --phase-2: #D68A2E;
            --phase-2-light: #E09940;
            --phase-2-dark: #B8741F;
            --text-primary: #E8EAF0;
            --text-secondary: #9DA3B4;
            --border: #3A3F4D;
            --bg: #1E2128;
            --card-bg: #2A2F3C;
            --card-bg-light: #32374A;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.5);
            --shadow-xl: 0 12px 40px rgba(0,0,0,0.6);
        }

        /* THEME: STEAMPUNK */
        [data-theme="steampunk"] {
            --treeplex-primary: #b8860b;
            --treeplex-primary-dark: #8b6914;
            --phase-0: #cd7f32;
            --phase-0-light: #d4924e;
            --phase-0-dark: #8b5a2b;
            --phase-1: #b87333;
            --phase-1-light: #d4924e;
            --phase-1-dark: #8b4513;
            --phase-2: #daa520;
            --phase-2-light: #ffd700;
            --phase-2-dark: #b8860b;
            --text-primary: #f5deb3;
            --text-secondary: #d2b48c;
            --border: #8b4513;
            --bg: #2b1810;
            --card-bg: #3e2315;
            --card-bg-light: #4a2817;
        }

        /* THEME: POWERPUFF GIRLS */
        [data-theme="powerpuff"] {
            --treeplex-primary: #ff6eb4;
            --treeplex-primary-dark: #ff1493;
            --phase-0: #ff69b4;
            --phase-0-light: #ffb6d9;
            --phase-0-dark: #c71585;
            --phase-1: #87ceeb;
            --phase-1-light: #b0e0e6;
            --phase-1-dark: #4682b4;
            --phase-2: #9acd32;
            --phase-2-light: #c7ea46;
            --phase-2-dark: #6b8e23;
            --text-primary: #2d2d2d;
            --text-secondary: #666666;
            --border: #ffb6d9;
            --bg: #fff0f5;
            --card-bg: #ffffff;
            --card-bg-light: #fffafd;
        }

        /* THEME: TRON */
        [data-theme="tron"] {
            --treeplex-primary: #00ffff;
            --treeplex-primary-dark: #00d4d4;
            --phase-0: #00ffff;
            --phase-0-light: #66ffff;
            --phase-0-dark: #00cccc;
            --phase-1: #00d4ff;
            --phase-1-light: #66e0ff;
            --phase-1-dark: #0099cc;
            --phase-2: #ff6600;
            --phase-2-light: #ff9944;
            --phase-2-dark: #cc5200;
            --text-primary: #e0ffff;
            --text-secondary: #7dd3ff;
            --border: #00ffff;
            --bg: #000000;
            --card-bg: #0a0a0a;
            --card-bg-light: #141414;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            overflow: auto;
        }

        ::selection {
            background: var(--treeplex-primary);
            color: white;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            background: #252931;
            border-bottom: 1px solid var(--border);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .logo {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-right: 40px;
        }

        .logo-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 24px;
            font-weight: 700;
            color: var(--treeplex-primary);
            letter-spacing: -0.5px;
        }

        .logo-subtitle {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-left: 46px;
        }

        /*         .confidential {
        /*             padding: 4px 12px;
        /*             background: #fff5f5;
        /*             border: 1px solid #ffccc7;
        /*             border-radius: 6px;
        /*             font-size: 11px;
        /*             font-weight: 600;
        /*             color: #d32f2f;
        /*             letter-spacing: 0.5px;
        /*         } */

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .control-section {
            display: flex;
            gap: 6px;
            padding: 0 12px;
            border-right: 1px solid var(--border);
        }

        .control-section:last-child {
            border-right: none;
            padding-right: 0;
        }

        .control-section:first-child {
            padding-left: 0;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: var(--card-bg);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn:hover {
            background: var(--card-bg-light);
            border-color: var(--treeplex-primary);
        }

        .btn-primary {
            background: var(--treeplex-primary);
            color: white;
            border-color: var(--treeplex-primary);
        }

        .btn-primary:hover {
            background: var(--treeplex-primary-dark);
        }
/* Pattern Selector */        .pattern-selector {            position: relative;            display: inline-block;        }        .pattern-select {            padding: 8px 12px;            border: 1px solid var(--border);            background: var(--card-bg);            color: var(--text-primary);            border-radius: 6px;            font-size: 13px;            font-weight: 500;            cursor: pointer;            font-family: inherit;            min-width: 180px;        }        .pattern-select:hover {            background-color: var(--card-bg-light);            border-color: var(--treeplex-primary);        }        .pattern-select:focus {            outline: none;            border-color: var(--treeplex-primary);            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);        }

        /* Pan/Zoom Controls */
        .zoom-controls {
            position: fixed;
            top: 90px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: var(--card-bg);
            padding: 12px;
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border);
        }

        .zoom-btn {
            width: 44px;
            height: 44px;
            border: 1px solid var(--border);
            background: var(--card-bg-light);
            color: var(--text-primary);
            border-radius: 8px;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: inherit;
        }

        .zoom-btn:hover {
            background: var(--treeplex-primary);
            border-color: var(--treeplex-primary);
            color: white;
            transform: scale(1.05);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-level {
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            padding: 8px 0;
            border-top: 1px solid var(--border);
            margin-top: 4px;
        }

        /* Tree Container */
        .tree-container {
            padding: 0;
            overflow: hidden;
            min-height: calc(100vh - 70px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background:
                repeating-linear-gradient(45deg, transparent, transparent 40px, rgba(0, 166, 125, 0.03) 40px, rgba(0, 166, 125, 0.03) 80px),
                repeating-linear-gradient(-45deg, transparent, transparent 40px, rgba(59, 143, 204, 0.02) 40px, rgba(59, 143, 204, 0.02) 80px),
                linear-gradient(180deg, #1A1D24 0%, #1E2128 50%, #1A1D24 100%);
            cursor: grab;
        }

        .tree-container.panning {
            cursor: grabbing;
        }

        .tree-transform-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: flex-start;  /* BUILD 332: Anchor to top for proper zoom behavior */
            justify-content: flex-start;
            transform-origin: top left;  /* Scale from top-left so zoomed content stays visible */
            transition: transform 0.15s ease-out;  /* BUILD 410: Smooth zoom animation */
            min-width: 100%;
            min-height: 100%;
        }

        .tree-transform-wrapper.panning {
            transition: none;  /* Disable transition during drag for immediate response */
        }

        .tree-container::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 166, 125, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(59, 143, 204, 0.06) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(214, 138, 46, 0.04) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }

        .dependency-svg {
            position: absolute;
            top: -5000px;
            left: -5000px;
            width: 20000px;
            height: 20000px;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .dependency-line {
            fill: none;
            stroke: var(--treeplex-primary);
            stroke-width: 3;
            stroke-dasharray: 8, 4;
            opacity: 0.6;
            transition: all 0.3s;
            animation: dash-flow 20s linear infinite;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
        }

        .dependency-line:hover {
            opacity: 1;
            stroke-width: 4;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25));
        }

        .dependency-line.phase-0 {
            stroke: var(--phase-0-dark);
        }

        .dependency-line.phase-1 {
            stroke: var(--phase-1-dark);
        }

        .dependency-line.phase-2 {
            stroke: var(--phase-2-dark);
        }

        .dependency-line.cross-phase {
            stroke: var(--treeplex-primary-dark);
            opacity: 0.7;
            stroke-width: 3.5;
        }

        @keyframes dash-flow {
            to {
                stroke-dashoffset: -100;
            }
        }

        .tree {
            display: flex;
            flex-direction: row;
            gap: 40px;
            align-items: center;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }

        .tree-level {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 12px;
            padding: 20px;
            border-radius: 12px;
            transition: background 0.3s;
        }

        /* Phase-specific backgrounds - subtle gradients */
        .tree-level:has(.phase-0) {
            background: linear-gradient(180deg, rgba(95, 164, 99, 0.03) 0%, rgba(95, 164, 99, 0.08) 100%);
        }

        .tree-level:has(.phase-1) {
            background: linear-gradient(180deg, rgba(59, 143, 204, 0.03) 0%, rgba(59, 143, 204, 0.08) 100%);
        }

        .tree-level:has(.phase-2) {
            background: linear-gradient(180deg, rgba(214, 138, 46, 0.03) 0%, rgba(214, 138, 46, 0.08) 100%);
        }

        .tree-node {
            background: linear-gradient(145deg, var(--card-bg-light), var(--card-bg));
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: var(--shadow-md), 0 0 0 1px rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            min-width: 280px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .tree-node:hover {
            box-shadow: var(--shadow-lg), 0 0 0 1px rgba(255,255,255,0.1);
            transform: translateX(4px) translateY(-2px);
            border-color: var(--treeplex-primary);
            background: linear-gradient(145deg, #3A3F52, var(--card-bg-light));
        }

        .tree-node::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 16px;
            background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
            pointer-events: none;
        }

        .tree-node.root {
            background: linear-gradient(135deg, #4A5568 0%, #2D3748 100%);
            color: white;
            font-size: 20px;
            font-weight: 600;
            min-width: 240px;
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(255, 255, 255, 0.15);
        }

        .tree-node.root:hover {
            box-shadow: var(--shadow-xl);
            background: linear-gradient(135deg, #556577 0%, #3A4556 100%);
        }

        .tree-node.root .node-subtitle {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.85;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 2px;
        }

        /* FILESYSTEM PATTERN: Vertical Tree Layout */
        .tree.filesystem-tree {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 20px;
        }

        .tree.filesystem-tree .tree-level {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 0;
            background: none !important;
        }

        .tree.filesystem-tree .tree-node {
            min-width: auto;
            width: 100%;
            max-width: 800px;
            margin: 4px 0;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.15s;
            cursor: pointer;
        }

        .tree.filesystem-tree .tree-node:hover {
            transform: none;
            background: rgba(99, 102, 241, 0.15);
        }

        .tree.filesystem-tree .tree-node.item,
        .tree.filesystem-tree .tree-node.subtask {
            padding: 6px 10px;
            background: transparent;
            border: none;
            box-shadow: none;
        }

        .tree.filesystem-tree .tree-node.item:hover,
        .tree.filesystem-tree .tree-node.subtask:hover {
            background: rgba(255, 255, 255, 0.05);
            box-shadow: none;
        }

        .tree.filesystem-tree .filesystem-indent-0 { margin-left: 0px; }
        .tree.filesystem-tree .filesystem-indent-1 { margin-left: 40px; }
        .tree.filesystem-tree .filesystem-indent-2 { margin-left: 80px; }
        .tree.filesystem-tree .filesystem-indent-3 { margin-left: 120px; }
        .tree.filesystem-tree .filesystem-indent-4 { margin-left: 160px; }
        .tree.filesystem-tree .filesystem-indent-5 { margin-left: 200px; }
        .tree.filesystem-tree .filesystem-indent-6 { margin-left: 240px; }
        .tree.filesystem-tree .filesystem-indent-7 { margin-left: 280px; }
        .tree.filesystem-tree .filesystem-indent-8 { margin-left: 320px; }
        .tree.filesystem-tree .filesystem-indent-9 { margin-left: 360px; }
        .tree.filesystem-tree .filesystem-indent-10 { margin-left: 400px; }

        .tree.filesystem-tree .node-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tree.filesystem-tree .expand-toggle {
            font-size: 14px;
            margin-right: 6px;
            cursor: pointer;
            padding: 2px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 16px;
            user-select: none;
            transition: all 0.2s;
        }

        .tree.filesystem-tree .expand-toggle:hover {
            color: var(--accent-primary);
            transform: scale(1.2);
        }

        .tree.filesystem-tree .node-icon {
            font-size: 16px;
            margin-right: 4px;
        }

        .tree.filesystem-tree .node-title,
        .tree.filesystem-tree .item-name {
            font-size: 13px;
            font-weight: 500;
        }

        .tree.filesystem-tree .node-subtitle,
        .tree.filesystem-tree .item-description {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* ============================================================================
           BUILD 335: HAMBURGER MENU BUTTON
           Hidden on desktop, visible on mobile
           ============================================================================ */
        .mobile-hamburger {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 44px;
            height: 44px;
            padding: 10px;
            background: transparent;
            border: none;
            cursor: pointer;
            gap: 5px;
            margin-left: auto;
        }

        .hamburger-line {
            display: block;
            width: 24px;
            height: 2px;
            background: var(--text);
            border-radius: 2px;
            transition: all 0.3s ease;
        }

        /* Hamburger â†’ X animation when open */
        .mobile-hamburger.open .hamburger-line:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        .mobile-hamburger.open .hamburger-line:nth-child(2) {
            opacity: 0;
        }
        .mobile-hamburger.open .hamburger-line:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* Mobile menu overlay - catches taps outside menu to close */
        /* z-index MUST be lower than .controls (100000) so menu is clickable */
        .mobile-menu-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            /* BUILD 350: Only cover left side, leave menu area clear */
            right: 300px;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 99990;
        }
        .mobile-menu-overlay.visible {
            display: block;
        }


        /* ============================================================================
           MOBILE OPTIMIZED VIEW - BUILD 336
           File-system style reading mode with hamburger menu
           ============================================================================ */
        @media screen and (max-width: 768px), (max-device-width: 768px), (pointer: coarse) and (max-width: 1024px) {
            /* CRITICAL: Hide EVERYTHING that's not the tree content */
            html, body {
                overflow-x: hidden !important;
                max-width: 100vw !important;
            }

            /* Show hamburger button on mobile - HIGH CONTRAST */
            .mobile-hamburger {
                display: flex !important;
                background: #6366f1 !important;
                border-radius: 8px !important;
                border: 2px solid #818cf8 !important;
            }

            .mobile-hamburger .hamburger-line {
                background: #ffffff !important;
                width: 20px !important;
                height: 3px !important;
            }

            /* Show overlay when menu is open */
            .mobile-menu-overlay.visible {
                display: block !important;
            }

            /* Logo container: full width on mobile so hamburger pushes to right */
            .header > div:first-child {
                flex: 1 !important;
                width: 100% !important;
            }

            /* Header: Minimal - just logo + hamburger */
            .header {
                padding: 8px 12px !important;
                gap: 8px !important;
                min-height: 48px !important;
                max-height: 48px !important;
                position: sticky !important;
                top: 0 !important;
                z-index: 100 !important;
            }

            /* Hide logo subtitle on mobile */
            .header .logo-subtitle,
            #save-indicator {
                display: none !important;
            }

            .header .logo-title {
                font-size: 15px !important;
            }

            /* ===== BUILD 349: MOBILE SLIDE-OUT MENU - TOP LAYER ===== */

            /* Controls panel: ABSOLUTE TOP LAYER for touch/tap */
            .header .controls {
                display: flex !important;
                flex-direction: column !important;
                position: fixed !important;
                top: 0 !important;
                right: -320px !important;
                width: 300px !important;
                height: 100% !important;
                background: #ffffff !important;
                padding: 60px 12px 20px 12px !important;
                gap: 12px !important;
                overflow-y: auto !important;
                overflow-x: hidden !important;
                z-index: 2147483647 !important;
                box-shadow: -2px 0 10px rgba(0,0,0,0.2) !important;
                transition: right 0.25s ease-out !important;
                pointer-events: auto !important;
                touch-action: pan-y !important;
                -webkit-overflow-scrolling: touch !important;
                isolation: isolate !important;
            }

            /* When menu is open, slide in */
            .header .controls.mobile-menu-open {
                right: 0 !important;
            }

            /* All child elements must be visible AND clickable */
            .header .controls > * {
                display: flex !important;
                flex-shrink: 0 !important;
                pointer-events: auto !important;
            }

            /* Control sections - vertical stack */
            .header .controls .control-section {
                display: flex !important;
                flex-direction: row !important;
                flex-wrap: wrap !important;
                gap: 8px !important;
                padding: 8px !important;
                background: #f1f5f9 !important;
                border-radius: 8px !important;
                width: 100% !important;
                box-sizing: border-box !important;
                pointer-events: auto !important;
            }

            /* Buttons - clear styling + MUST BE CLICKABLE */
            .header .controls .btn,
            .header .controls button {
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                background: #3b82f6 !important;
                color: #ffffff !important;
                border: none !important;
                padding: 10px 14px !important;
                font-size: 13px !important;
                font-weight: 600 !important;
                border-radius: 6px !important;
                min-height: 40px !important;
                cursor: pointer !important;
                pointer-events: auto !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: rgba(0,0,0,0.1) !important;
            }

            /* Dropdown triggers */
            .header .controls .dropdown-menu-trigger {
                background: #1e293b !important;
                color: #ffffff !important;
                pointer-events: auto !important;
            }

            /* Selects/dropdowns */
            .header .controls select {
                display: block !important;
                width: 100% !important;
                background: #ffffff !important;
                color: #1e293b !important;
                border: 2px solid #cbd5e1 !important;
                padding: 10px 12px !important;
                font-size: 13px !important;
                font-weight: 500 !important;
                border-radius: 6px !important;
                min-height: 40px !important;
                pointer-events: auto !important;
                touch-action: manipulation !important;
            }

            /* Dropdown menu */
            .header .controls .dropdown-menu {
                pointer-events: auto !important;
            }

            /* Dropdown menu content */
            .header .controls .dropdown-menu-content {
                position: relative !important;
                display: none;
                width: 100% !important;
                background: #ffffff !important;
                border: 1px solid #e2e8f0 !important;
                border-radius: 6px !important;
                margin-top: 4px !important;
                box-shadow: none !important;
                pointer-events: auto !important;
            }

            /* BUILD 350: Match actual JS class structure */
            .header .controls .dropdown-menu-content.open {
                display: block !important;
                opacity: 1 !important;
                visibility: visible !important;
            }

            .header .controls .dropdown-menu-item {
                display: flex !important;
                padding: 10px 12px !important;
                color: #1e293b !important;
                font-size: 13px !important;
                background: #ffffff !important;
                pointer-events: auto !important;
                cursor: pointer !important;
            }

            .header .controls .dropdown-menu-item:active {
                background: #e2e8f0 !important;
            }

            /* Labels */
            .header .controls label {
                display: flex !important;
                flex-direction: column !important;
                gap: 4px !important;
                color: #475569 !important;
                font-size: 12px !important;
                font-weight: 600 !important;
                width: 100% !important;
            }

            /* Hide sort section unless active */
            .header .controls #sort-section {
                display: none !important;
            }

            /* ===== AI TOOLS SIDEBAR: COMPLETELY HIDDEN ===== */
            #ai-tools-panel,
            .ai-tools-panel,
            [id="ai-tools-panel"] {
                display: none !important;
                visibility: hidden !important;
                width: 0 !important;
                height: 0 !important;
                overflow: hidden !important;
                position: absolute !important;
                left: -9999px !important;
            }

            /* ===== MAIN CONTENT: FULL WIDTH ===== */
            .main-content,
            .tree-view-container,
            .canvas-container,
            main,
            [class*="main"] {
                margin-left: 0 !important;
                padding-left: 0 !important;
                width: 100% !important;
                max-width: 100vw !important;
            }

            /* Dropdowns in mobile menu */
            .header .controls .dropdown-menu {
                width: 100% !important;
            }

            /* Hide version on mobile */
            #version-display {
                display: none !important;
            }

            /* ===== FILE SYSTEM STYLE TREE ===== */
            .tree-view-container {
                padding: 0 !important;
                margin: 0 !important;
                overflow-x: hidden !important;
                overflow-y: auto !important;
                width: 100% !important;
                max-width: 100vw !important;
            }

            .tree-container {
                padding: 0 !important;
                margin: 0 !important;
                width: 100% !important;
            }

            .tree {
                display: flex !important;
                flex-direction: column !important;
                gap: 0 !important;
                padding: 4px 8px !important;
                width: 100% !important;
                max-width: 100% !important;
            }

            .tree-level {
                display: flex !important;
                flex-direction: column !important;
                gap: 0 !important;
                padding: 0 !important;
                margin: 0 !important;
                background: transparent !important;
                flex-wrap: nowrap !important;
                width: 100% !important;
            }

            /* ===== FILE SYSTEM NODE STYLING ===== */
            .tree-node {
                min-width: 0 !important;
                width: calc(100% - 4px) !important;
                max-width: none !important;
                margin: 1px 2px !important;
                padding: 10px 12px !important;
                border-radius: 4px !important;
                font-size: 14px !important;
                background: transparent !important;
                border: none !important;
                box-shadow: none !important;
                display: flex !important;
                flex-direction: row !important;
                align-items: center !important;
                gap: 8px !important;
            }

            .tree-node:hover {
                transform: none !important;
                background: rgba(255,255,255,0.05) !important;
            }

            .tree-node.selected {
                background: rgba(99, 102, 241, 0.15) !important;
                border-left: 3px solid var(--primary) !important;
            }

            /* File-system indentation */
            .tree-node.root { margin-left: 0 !important; padding-left: 8px !important; }
            .tree-node.phase { margin-left: 0 !important; padding-left: 8px !important; }
            .tree-node.item { margin-left: 20px !important; padding-left: 8px !important; }
            .tree-node.subtask { margin-left: 40px !important; padding-left: 8px !important; }

            /* Phase: Folder style */
            .tree-node.phase {
                font-weight: 600 !important;
                color: var(--text) !important;
                border-left: 3px solid var(--primary) !important;
                border-left-color: inherit !important;
                margin-top: 8px !important;
                margin-bottom: 2px !important;
            }

            .tree-node.phase::before {
                content: 'ðŸ“' !important;
                display: inline-block !important;
                margin-right: 6px !important;
                font-size: 14px !important;
            }

            /* Item: File style */
            .tree-node.item {
                color: var(--text-secondary) !important;
            }

            .tree-node.item::before {
                content: 'ðŸ“„' !important;
                display: inline-block !important;
                margin-right: 6px !important;
                font-size: 13px !important;
            }

            /* Subtask: Nested file */
            .tree-node.subtask {
                font-size: 13px !important;
                color: var(--text-secondary) !important;
                opacity: 0.85 !important;
            }

            .tree-node.subtask::before {
                content: 'â””â”€' !important;
                display: inline-block !important;
                margin-right: 4px !important;
                font-family: monospace !important;
                color: var(--border) !important;
            }

            /* Node content - single line, truncate */
            .node-title,
            .item-name,
            .tree-node > span:first-of-type {
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                flex: 1 !important;
            }

            /* Hide descriptions on mobile */
            .node-subtitle,
            .item-description,
            .node-description {
                display: none !important;
            }

            /* Hide action buttons - use long-press instead */
            .tree-node .node-actions,
            .tree-node .item-actions,
            .node-buttons,
            .tree-node button:not(.collapse-btn) {
                display: none !important;
            }

            /* Keep collapse button visible */
            .tree-node .collapse-btn {
                padding: 4px !important;
                margin-left: auto !important;
                opacity: 0.6 !important;
            }

            /* Hide complex elements */
            .dependency-svg,
            .empty-state-cta,
            #canvas-container,
            #view-3d,
            .hyperedge-indicator {
                display: none !important;
            }

            /* Info panel: Bottom sheet */
            .info-panel {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                top: auto !important;
                width: 100% !important;
                max-height: 60vh !important;
                border-radius: 16px 16px 0 0 !important;
                transform: translateY(100%) !important;
                transition: transform 0.3s ease !important;
                z-index: 1000 !important;
            }

            .info-panel.open {
                transform: translateY(0) !important;
            }

            /* Touch-friendly tap targets */
            .tree-node,
            .btn,
            .dropdown-menu-item {
                min-height: 44px !important;
            }

            /* Context menu: Bottom sheet */
            .context-menu {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                top: auto !important;
                max-width: none !important;
                border-radius: 16px 16px 0 0 !important;
                padding: 12px !important;
                max-height: 50vh !important;
                overflow-y: auto !important;
                z-index: 10000 !important;
            }

            .context-item {
                padding: 14px 16px !important;
                font-size: 15px !important;
            }

            /* Modals: Full screen */
            .modal-content {
                max-width: 100% !important;
                max-height: 100% !important;
                width: 100% !important;
                height: 100% !important;
                border-radius: 0 !important;
                margin: 0 !important;
            }

            /* TreeBeard chat: Full width bottom sheet */
            #treebeard-chat-panel {
                width: 100% !important;
                right: 0 !important;
                left: 0 !important;
                bottom: 0 !important;
                max-height: 70vh !important;
                border-radius: 16px 16px 0 0 !important;
            }

            /* TreeBeard FAB button */
            #treebeard-fab {
                bottom: 16px !important;
                right: 16px !important;
                width: 52px !important;
                height: 52px !important;
            }
        }

        /* Long-press visual feedback for touch */
        @media (pointer: coarse) {
            .tree-node {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
            }

            .tree-node.long-press-active {
                background: rgba(99, 102, 241, 0.2) !important;
                transform: scale(0.98);
            }
        }

        .tree-node.phase {
            border-left: 6px solid;
            min-width: 260px;
            position: relative;
            overflow: hidden;
        }

        .tree-node.phase::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: linear-gradient(180deg, var(--phase-color-light), var(--phase-color-dark));
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
        }

        .tree-node.phase-0 {
            border-left-color: var(--phase-0);
            --phase-color-light: var(--phase-0-light);
            --phase-color-dark: var(--phase-0-dark);
        }

        .tree-node.phase-0:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-0);
        }

        .tree-node.phase-1 {
            border-left-color: var(--phase-1);
            --phase-color-light: var(--phase-1-light);
            --phase-color-dark: var(--phase-1-dark);
        }

        .tree-node.phase-1:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-1);
        }

        .tree-node.phase-2 {
            border-left-color: var(--phase-2);
            --phase-color-light: var(--phase-2-light);
            --phase-color-dark: var(--phase-2-dark);
        }

        .tree-node.phase-2:hover {
            box-shadow: var(--shadow-lg), -6px 0 0 0 var(--phase-2);
        }

        .tree-node.item {
            min-width: 320px;
            max-width: 360px;
            backdrop-filter: blur(4px);
        }

        /* Subtask container - appears below parent item with animation */
        .subtask-container {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            margin-bottom: 8px;
            padding-left: 10px;
            justify-content: flex-start;
            flex-wrap: wrap;
            max-width: 100%;
            animation: slideDownFade 0.4s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            transform-origin: top center;
        }

        @keyframes slideDownFade {
            0% {
                opacity: 0;
                transform: translateY(-40px) scale(0.95);
                max-height: 0;
                filter: blur(6px) brightness(0.5);
            }
            60% {
                filter: blur(1px) brightness(0.9);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                max-height: 500px;
                filter: blur(0) brightness(1);
            }
        }

        /* Subtask styling - compact visual cards */
        .tree-node.item.subtask {
            min-width: 100px;
            max-width: 100px;
            width: 100px;
            min-height: 85px;
            background: rgba(255, 255, 255, 0.06);
            border-left: 3px solid rgba(0, 166, 125, 0.5);
            border-radius: 6px;
            padding: 10px;
            font-size: 10px;
            margin: 0;
            display: inline-flex;
            flex-direction: column;
            vertical-align: top;
            animation: subtaskReveal 0.35s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            opacity: 0;
            transform: translateY(-20px) scale(0.9);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tree-node.item.subtask:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 166, 125, 0.3);
            border-left-color: rgba(0, 166, 125, 0.8);
        }

        /* Staggered animation for subtasks */
        .tree-node.item.subtask:nth-child(1) { animation-delay: 0.05s; }
        .tree-node.item.subtask:nth-child(2) { animation-delay: 0.1s; }
        .tree-node.item.subtask:nth-child(3) { animation-delay: 0.15s; }
        .tree-node.item.subtask:nth-child(4) { animation-delay: 0.2s; }
        .tree-node.item.subtask:nth-child(5) { animation-delay: 0.25s; }
        .tree-node.item.subtask:nth-child(6) { animation-delay: 0.3s; }

        @keyframes subtaskReveal {
            0% {
                opacity: 0;
                transform: translateY(-20px) scale(0.9);
                filter: blur(4px) brightness(0.6);
            }
            70% {
                transform: translateY(2px) scale(1.01);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                filter: blur(0) brightness(1);
            }
        }


        /* Project management fields styling */
        .pm-field {
            font-size: 8px;
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            line-height: 1.1;
        }

        .pm-field-label {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .pm-field-value {
            font-weight: 600;
        }

        .pm-status {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
        }

        .pm-status.todo { background: rgba(156, 163, 175, 0.3); color: #9CA3AF; }
        .pm-status.inprogress { background: rgba(59, 130, 246, 0.3); color: #3B82F6; }
        .pm-status.completed { background: rgba(16, 185, 129, 0.3); color: #10B981; }
        .pm-status.blocked { background: rgba(239, 68, 68, 0.3); color: #EF4444; }

        .pm-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 2px;
        }

        .pm-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            transition: width 0.3s;
        }

        /* Expand/Collapse toggle for items with subtasks */
        .expand-toggle {
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
            display: inline-block;
        }

        .expand-toggle:hover {
            opacity: 1 !important;
            transform: scale(1.3) rotate(90deg);
        }

        /* Items with subtasks have a pointer cursor */
        .tree-node.item:has(.expand-toggle) {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tree-node.item:has(.expand-toggle):hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 166, 125, 0.2);
        }

        .tree-node.item:has(.expand-toggle):active {
            transform: translateY(0);
            transition: all 0.1s ease;
        }

        /* When item has expanded subtasks, add subtle glow and lift effect */
        .tree-node.item.has-expanded-subtasks {
            box-shadow: 0 0 20px rgba(0, 166, 125, 0.4), 0 6px 16px rgba(0, 0, 0, 0.3);
            border-left-color: rgba(0, 166, 125, 0.9);
            border-left-width: 4px;
            transform: translateY(-2px);
            z-index: 10;
            transition: all 0.3s ease;
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .node-icon {
            font-size: 28px;
            flex-shrink: 0;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
            transition: transform 0.3s;
        }

        .tree-node:hover .node-icon {
            transform: scale(1.1);
        }

        .node-content {
            flex: 1;
        }

        .node-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .node-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .node-cost {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-top: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .tree-node.root .node-cost {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.8));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .expand-toggle {
            font-size: 14px;
            opacity: 0.6;
            transition: transform 0.3s;
            margin-left: auto;
        }

        .tree-node.expanded .expand-toggle {
            transform: rotate(90deg);
        }

        .tree-node.collapsed .expand-toggle {
            transform: rotate(0deg);
        }

        /* Item specific */
        .item-name {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .item-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            border: 1px solid;
        }

        .badge-land {
            background: linear-gradient(135deg, rgba(95, 164, 99, 0.3), rgba(74, 140, 78, 0.2));
            color: #81C784;
            border-color: #4A8C4E;
        }
        .badge-engineering {
            background: linear-gradient(135deg, rgba(59, 143, 204, 0.3), rgba(43, 122, 184, 0.2));
            color: #64B5F6;
            border-color: #2B7AB8;
        }
        .badge-professional {
            background: linear-gradient(135deg, rgba(156, 117, 178, 0.3), rgba(128, 90, 150, 0.2));
            color: #BA68C8;
            border-color: #7B4A92;
        }
        .badge-corporate {
            background: linear-gradient(135deg, rgba(130, 130, 130, 0.3), rgba(100, 100, 100, 0.2));
            color: #B0B0B0;
            border-color: #707070;
        }
        .badge-equipment {
            background: linear-gradient(135deg, rgba(214, 138, 46, 0.3), rgba(184, 116, 31, 0.2));
            color: #FFB74D;
            border-color: #B8741F;
        }
        .badge-infrastructure {
            background: linear-gradient(135deg, rgba(233, 98, 158, 0.3), rgba(200, 70, 130, 0.2));
            color: #F48FB1;
            border-color: #C84682;
        }
        .badge-contingency {
            background: linear-gradient(135deg, rgba(229, 115, 115, 0.3), rgba(198, 80, 80, 0.2));
            color: #EF9A9A;
            border-color: #C65050;
        }

        /* Contributor badge for collaboration */
        .contributor-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 600;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(99, 102, 241, 0.15));
            color: #a5b4fc;
            border: 1px solid rgba(99, 102, 241, 0.4);
            border-radius: 12px;
            margin-left: 6px;
            cursor: help;
        }

        /* Collab comment indicator */
        .collab-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            font-size: 12px;
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.3), rgba(251, 191, 36, 0.15));
            border: 1px solid rgba(251, 191, 36, 0.4);
            border-radius: 50%;
            margin-left: 4px;
            cursor: help;
            animation: collab-pulse 2s ease-in-out infinite;
        }

        @keyframes collab-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.4); }
            50% { box-shadow: 0 0 0 4px rgba(251, 191, 36, 0); }
        }

        .item-cost {
            font-size: 15px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Connection Lines */
        .tree-node::before {
            content: '';
            position: absolute;
            left: -40px;
            top: 50%;
            width: 40px;
            height: 2px;
            background: var(--border);
        }

        .tree-level:first-child .tree-node::before {
            display: none;
        }

        /* Same-phase dependency indentation indicator */
        .tree-node.item.has-same-phase-dependency::after {
            content: '';
            position: absolute;
            left: -20px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, transparent, var(--treeplex-primary) 20%, var(--treeplex-primary) 80%, transparent);
            opacity: 0.3;
            border-radius: 2px;
        }

        /* Enhanced visual for deeper dependency levels */
        .tree-node.item.has-same-phase-dependency[data-dependency-level="2"]::after {
            opacity: 0.4;
            width: 3px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="3"]::after {
            opacity: 0.5;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency[data-dependency-level="4"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="5"]::after,
        .tree-node.item.has-same-phase-dependency[data-dependency-level="6"]::after {
            opacity: 0.6;
            width: 4px;
        }

        .tree-node.item.has-same-phase-dependency {
            border-left: 2px solid rgba(0, 166, 125, 0.2);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            right: -450px;
            top: 0;
            width: 450px;
            height: 100vh;
            background: var(--card-bg);
            border-left: 1px solid var(--border);
            box-shadow: -4px 0 12px rgba(0,0,0,0.5);
            transition: right 0.3s;
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        .info-panel.open {
            right: 0;
        }

        .info-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-title {
            font-size: 18px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: var(--bg);
        }

        /* BUILD 411: Reader Navigation */
        .reader-nav {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 12px;
            padding-right: 12px;
            border-right: 1px solid var(--border);
        }

        .reader-nav-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.15s;
        }

        .reader-nav-btn:hover:not(:disabled) {
            background: var(--treeplex-primary);
            border-color: var(--treeplex-primary);
            color: white;
        }

        .reader-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .reader-position {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 50px;
            text-align: center;
        }

        .reader-mode-btn {
            background: none;
            border: 1px solid transparent;
            font-size: 16px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.15s;
            opacity: 0.6;
        }

        .reader-mode-btn:hover {
            opacity: 1;
            background: var(--bg);
        }

        .reader-mode-btn.active {
            opacity: 1;
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--treeplex-primary);
        }

        /* Read mode: hide edit controls */
        .info-panel.read-mode .info-field input,
        .info-panel.read-mode .info-field textarea,
        .info-panel.read-mode .info-field select,
        .info-panel.read-mode .edit-btn,
        .info-panel.read-mode .delete-btn,
        .info-panel.read-mode .pm-field-group input,
        .info-panel.read-mode .pm-field-group select {
            display: none !important;
        }

        .info-panel.read-mode .info-field-value {
            display: block !important;
        }

        /* Current node highlight in tree */
        .tree-node.reader-current {
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.5), var(--shadow-md) !important;
            animation: readerPulse 2s ease-in-out infinite;
        }

        @keyframes readerPulse {
            0%, 100% { box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.5), var(--shadow-md); }
            50% { box-shadow: 0 0 0 5px rgba(99, 102, 241, 0.3), var(--shadow-md); }
        }

        .info-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .info-section {
            margin-bottom: 24px;
        }

        .info-section h4 {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .info-section p {
            font-size: 14px;
            line-height: 1.6;
        }

        .info-section .value {
            font-size: 20px;
            font-weight: 700;
            color: var(--treeplex-primary);
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .modal-content {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            font-size: 18px;
            font-weight: 600;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            line-height: 1.7;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
        }

        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--treeplex-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 40px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            display: none;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            padding: 6px;
            min-width: 180px;
            z-index: 1000;
        }

        .context-item {
            padding: 10px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            color: var(--text-primary);
        }

        .context-item:hover {
            background: var(--card-bg-light);
            color: var(--treeplex-primary);
        }

        .context-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
            background: var(--bg);
            color: var(--text-primary);
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--treeplex-primary);
            box-shadow: 0 0 0 3px rgba(0, 166, 125, 0.2);
            background: var(--card-bg-light);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Splash Screen */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1d24 0%, #2a2f3c 50%, #1a1d24 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.5s ease-in;
        }

        #splash-screen.fade-out {
            animation: fadeOut 0.5s ease-out forwards;
        }

        .splash-logo {
            font-size: 72px;
            margin-bottom: 24px;
            animation: logoFloat 2s ease-in-out infinite;
        }

        .splash-title {
            font-size: 48px;
            font-weight: 700;
            color: var(--treeplex-primary);
            margin-bottom: 8px;
            letter-spacing: -1px;
        }

        .splash-subtitle {
            font-size: 20px;
            color: var(--text-secondary);
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 48px;
        }

        .splash-tagline {
            font-size: 16px;
            color: var(--text-primary);
            font-weight: 400;
            margin-bottom: 32px;
            opacity: 0.8;
        }

        .splash-loader {
            width: 200px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .splash-loader-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--treeplex-primary), var(--phase-1));
            border-radius: 3px;
            animation: loadProgress 2s ease-in-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        @keyframes logoFloat {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes loadProgress {
            0% {
                width: 0%;
            }
            100% {
                width: 100%;
            }
        }

    /* ===================================================== */
    /* CANVAS VIEW STYLES */
    /* ===================================================== */

    .tree-view-container {
        display: block;
    }

    .tree-view-container.hidden {
        display: none !important;
    }

    .canvas-container {
        display: none;
        position: fixed;
        top: 140px;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        overflow: hidden;
        cursor: grab;
    }

    .canvas-container.active {
        display: block;
    }

    .canvas-container.grabbing {
        cursor: grabbing;
    }

    #canvas {
        width: 100%;
        height: 100%;
        position: relative;
        transform-origin: 0 0;
    }

    .canvas-connections {
        position: absolute;
        top: -5000px;
        left: -5000px;
        width: 20000px;
        height: 20000px;
        pointer-events: none;
        z-index: 1;
        overflow: visible;
    }

    /* Allow pointer events on hyperedge groups and their elements */
    .canvas-connections .hyperedge-group {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections polygon,
    .canvas-connections rect,
    .canvas-connections path.hyperedge-capsule {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections text {
        pointer-events: all;
        cursor: pointer;
    }

    /* Disable on connection lines (but not capsule paths) */
    .canvas-connections path:not(.hyperedge-capsule),
    .canvas-connections line {
        pointer-events: none;
    }

    .canvas-nodes-layer {
        position: relative;
        z-index: 2;
    }

    .canvas-node {
        position: absolute;
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        min-width: 280px;
        max-width: 320px;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, filter 0.15s ease;
        z-index: 10;
    }

    .canvas-node:hover {
        transform: translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }

    .canvas-node.dragging {
        cursor: grabbing;
        opacity: 0.9;
        z-index: 1000;
        transform: scale(1.05);
    }

    .canvas-node.selected {
        border-color: var(--treeplex-primary) !important;
        box-shadow:
            0 8px 32px rgba(99, 102, 241, 0.4),
            0 4px 16px rgba(99, 102, 241, 0.3),
            0 0 0 3px rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-2px);
    }

    .canvas-node.selected::before {
        content: 'âœ“';
        position: absolute;
        top: -10px;
        right: -10px;
        background: #6366f1;
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .canvas-node.dragging-group {
        opacity: 0.7;
        box-shadow: 0 0 20px rgba(99, 102, 241, 0.8);
    }

    .phase-zone {
        position: absolute;
        border: 3px dashed;
        border-radius: 20px;
        padding: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .phase-zone-header {
        font-weight: 700;
        font-size: 18px;
        margin-bottom: 12px;
        color: var(--text-primary);
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* Colored phase zones - vibrant colors */
    .phase-0 {
        border-color: #3B82F6;
        background: rgba(59, 130, 246, 0.08);
    }
    .phase-1 {
        border-color: #F59E0B;
        background: rgba(245, 158, 11, 0.08);
    }
    .phase-2 {
        border-color: #10B981;
        background: rgba(16, 185, 129, 0.08);
    }
    .phase-3 {
        border-color: #8B5CF6;
        background: rgba(139, 92, 246, 0.08);
    }
    .phase-4 {
        border-color: #EC4899;
        background: rgba(236, 72, 153, 0.08);
    }
    .phase-5 {
        border-color: #06B6D4;
        background: rgba(6, 182, 212, 0.08);
    }

    /* Grid overlay */
    .canvas-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .canvas-grid.active {
        opacity: 1;
    }

    .canvas-toolbar.active {
        display: flex !important;
    }

    .canvas-toolbar button:hover {
        background: rgba(99, 102, 241, 0.3) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .canvas-toolbar button:active {
        transform: translateY(0);
    }

    .canvas-toolbar select:hover {
        background: rgba(99, 102, 241, 0.25) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
    }

    .canvas-toolbar select option {
        background: #1a1a2e;
        color: #ffffff;
        padding: 10px;
        font-weight: 600;
    }

    .canvas-toolbar select option:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    /* ============================================================================
       AI SETTINGS MODAL - STYLING
       ============================================================================ */

    /* AI Settings Modal - Radio Button Styling */
    .ai-radio-option {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        padding: 12px;
        background: rgba(255,255,255,0.03);
        border: 2px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .ai-radio-option:hover {
        background: rgba(255,255,255,0.06);
        border-color: rgba(99, 102, 241, 0.4);
    }

    .ai-radio-option input[type="radio"] {
        margin-top: 2px;
        cursor: pointer;
    }

    .ai-radio-option input[type="radio"]:checked + .radio-label {
        color: #6366f1;
    }

    .ai-radio-option:has(input[type="radio"]:checked) {
        background: rgba(99, 102, 241, 0.1);
        border-color: #6366f1;
    }

    .radio-label {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .radio-label strong {
        font-size: 13px;
        color: rgba(255,255,255,0.9);
    }

    .radio-label small {
        font-size: 11px;
        color: rgba(255,255,255,0.5);
    }

    /* Creativity Slider */
    #creativity-slider {
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        background: rgba(255,255,255,0.1);
        border-radius: 3px;
        outline: none;
    }

    #creativity-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        background: #6366f1;
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(99, 102, 241, 0.4);
    }

    #creativity-slider::-moz-range-thumb {
        width: 18px;
        height: 18px;
        background: #6366f1;
        border-radius: 50%;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 6px rgba(99, 102, 241, 0.4);
    }

    /* ============================================================================
       UI MODERNIZATION - BUILD 148
       ============================================================================ */

    /* ============================================================================
       DROPDOWN MENU COMPONENT - BUILD 331
       Accessible dropdown menus for toolbar consolidation
       ============================================================================ */
    .dropdown-menu {
        position: relative;
        display: inline-block;
    }

    .dropdown-menu-trigger {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 6px 12px;
        font-size: 13px;
        font-weight: 600;
        color: white;
        background: linear-gradient(135deg, #6366f1, #8b5cf6);
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .dropdown-menu-trigger:hover {
        filter: brightness(1.1);
        transform: translateY(-1px);
    }

    .dropdown-menu-trigger::after {
        content: 'â–¾';
        font-size: 10px;
        margin-left: 2px;
        transition: transform 0.2s ease;
    }

    .dropdown-menu-trigger[aria-expanded="true"]::after {
        transform: rotate(180deg);
    }

    .dropdown-menu-content {
        position: absolute;
        top: calc(100% + 4px);
        left: 0;
        min-width: 200px;
        background: var(--card-bg);
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-8px);
        transition: all 0.2s ease;
    }

    .dropdown-menu-content.open {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
    }

    .dropdown-menu-item {
        display: flex;
        align-items: center;
        gap: 10px;
        width: 100%;
        padding: 10px 14px;
        font-size: 13px;
        color: var(--text-primary);
        background: none;
        border: none;
        cursor: pointer;
        transition: background 0.15s ease;
        text-align: left;
    }

    .dropdown-menu-item:first-child {
        border-radius: 7px 7px 0 0;
    }

    .dropdown-menu-item:last-child {
        border-radius: 0 0 7px 7px;
    }

    .dropdown-menu-item:only-child {
        border-radius: 7px;
    }

    .dropdown-menu-item:hover {
        background: rgba(99, 102, 241, 0.15);
        color: var(--treeplex-primary);
    }

    .dropdown-menu-item:focus {
        outline: none;
        background: rgba(99, 102, 241, 0.2);
        color: var(--treeplex-primary);
    }

    .dropdown-menu-item .item-icon {
        font-size: 16px;
        width: 20px;
        text-align: center;
    }

    .dropdown-menu-item .item-label {
        flex: 1;
    }

    .dropdown-menu-item .item-shortcut {
        font-size: 11px;
        color: var(--text-secondary);
        opacity: 0.7;
    }

    .dropdown-menu-divider {
        height: 1px;
        background: var(--border);
        margin: 4px 0;
    }

    .dropdown-menu-header {
        padding: 8px 14px 4px;
        font-size: 11px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    /* Dropdown variants */
    .dropdown-menu-trigger.btn-green {
        background: linear-gradient(135deg, #059669, #10b981);
    }

    .dropdown-menu-trigger.btn-blue {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
    }

    /* AI TOOLS SIDEBAR - Collapsible Left-Docked */
    #ai-tools-panel {
        position: fixed !important;
        top: 70px !important;
        left: 0 !important;
        bottom: 0 !important;
        width: 60px !important;
        min-width: 60px !important;
        background: #1E2128 !important;
        border-right: 1px solid var(--border) !important;
        border-top: none !important;
        border-bottom: none !important;
        border-left: none !important;
        border-radius: 0 !important;
        padding: 16px 8px !important;
        transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
        overflow: hidden !important;
        z-index: 900 !important;
        display: flex !important;
        flex-direction: column !important;
        gap: 12px !important;
        box-shadow: 4px 0 24px rgba(0,0,0,0.2) !important;
    }

    /* Expand on Hover */
    #ai-tools-panel:hover {
        width: 260px !important;
        background: var(--card-bg) !important;
    }

    /* BUILD 340: HIDE SIDEBAR ON MOBILE - Must come AFTER desktop rules */
    @media screen and (max-width: 768px), (max-device-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #ai-tools-panel {
            display: none !important;
            visibility: hidden !important;
            width: 0 !important;
            height: 0 !important;
            position: absolute !important;
            left: -9999px !important;
            pointer-events: none !important;
        }
    }

    /* Sidebar Buttons */
    #ai-tools-panel .btn {
        justify-content: flex-start !important;
        padding: 10px 12px !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        width: 100% !important;
        background: transparent !important;
        border: 1px solid transparent !important;
        color: var(--text-secondary) !important;
        transition: all 0.2s !important;
    }

    /* Button Icons (Always Visible) */
    #ai-tools-panel .btn::before {
        content: attr(data-icon);
        font-size: 20px;
        min-width: 24px;
        margin-right: 16px;
        text-align: center;
    }

    /* Button Hover State */
    #ai-tools-panel .btn:hover {
        background: rgba(255, 255, 255, 0.05) !important;
        color: var(--text-primary) !important;
        border-color: rgba(255, 255, 255, 0.1) !important;
    }

    /* Active/Primary Button Override */
    #ai-tools-panel .btn.btn-primary {
        background: linear-gradient(135deg, #6366f1, #8b5cf6) !important;
        color: white !important;
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    /* Hide text when collapsed */
    #ai-tools-panel:not(:hover) .btn span {
        opacity: 0;
    }

    #ai-tools-panel .btn span {
        transition: opacity 0.2s;
        opacity: 1;
    }

    /* TYPOGRAPHY IMPROVEMENTS - Better Hierarchy */
    /* Primary Title - Bigger & Bolder */
    .node-title, .item-name {
        font-size: 17px !important;
        font-weight: 700 !important;
        color: #F3F4F6 !important;
        letter-spacing: -0.01em;
        margin-bottom: 6px !important;
        line-height: 1.3;
    }

    /* Subtitle/Description - Receded */
    .node-subtitle, .item-description {
        font-size: 13px !important;
        color: #9CA3AF !important;
        font-weight: 400;
        line-height: 1.5;
    }

    /* Tags/Badges - More refined */
    .badge {
        font-size: 10px !important;
        padding: 3px 8px !important;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-radius: 4px !important;
        font-weight: 700 !important;
    }

    /* Node Cards - Better Depth */
    .tree-node {
        box-shadow:
            0 1px 0 rgba(255,255,255,0.1) inset,
            0 4px 12px rgba(0,0,0,0.4);
    }

    /* ZOOM CONTROLS IN SIDEBAR */
    /* Hide old standalone zoom controls if they exist */
    .zoom-controls {
        display: none !important;
    }

    /* Sidebar zoom controls container */
    .sidebar-zoom-controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 100%;
        padding: 8px 0;
        border-top: 1px solid rgba(255,255,255,0.1);
    }

    /* Zoom level display in sidebar */
    .zoom-level-sidebar {
        text-align: center;
        font-size: 11px;
        color: var(--text-secondary);
        padding: 4px;
        background: rgba(255,255,255,0.03);
        border-radius: 4px;
        font-weight: 600;
    }

    /* Ensure zoom buttons follow sidebar button styling */
    .sidebar-zoom-controls .btn {
        padding: 8px 12px !important;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CHAT ASSISTANT BUBBLE STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Floating bubble button */
    #chat-assistant-bubble {
        position: fixed;
        bottom: 24px;
        right: 24px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #8b5cf6, #6366f1);
        border: none;
        cursor: pointer;
        box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #chat-assistant-bubble:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 28px rgba(99, 102, 241, 0.5);
    }

    #chat-assistant-bubble.active {
        transform: rotate(45deg);
    }

    /* Chat panel - Draggable Floating Frame (TreeBeard) */
    #chat-assistant-panel {
        position: fixed;
        bottom: 96px;
        right: 24px;
        width: 440px;
        min-width: 340px;
        max-width: calc(100vw - 48px);
        height: 520px;
        min-height: 320px;
        max-height: calc(100vh - 100px);
        background: linear-gradient(180deg, rgba(30, 30, 46, 0.98), rgba(24, 24, 38, 0.99));
        border: 2px solid rgba(139, 92, 246, 0.3);
        border-radius: 16px;
        /* Multi-layer shadow for strong floating effect */
        box-shadow:
            0 0 0 1px rgba(139, 92, 246, 0.15),
            0 4px 8px rgba(0, 0, 0, 0.3),
            0 12px 24px rgba(0, 0, 0, 0.4),
            0 24px 48px rgba(0, 0, 0, 0.5),
            0 0 60px rgba(139, 92, 246, 0.08);
        z-index: 9999;
        display: none;
        flex-direction: column;
        overflow: hidden;
        resize: both;
        overflow: auto;
        backdrop-filter: blur(8px);
    }

    #chat-assistant-panel.open {
        display: flex;
        animation: chatSlideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #chat-assistant-panel.dragging {
        opacity: 0.95;
        border-color: rgba(139, 92, 246, 0.5);
        box-shadow:
            0 0 0 2px rgba(139, 92, 246, 0.3),
            0 8px 16px rgba(0, 0, 0, 0.4),
            0 24px 48px rgba(0, 0, 0, 0.5),
            0 32px 64px rgba(0, 0, 0, 0.6),
            0 0 80px rgba(139, 92, 246, 0.15);
        transition: none;
    }

    @keyframes chatSlideUp {
        from {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    /* Chat header - Drag Handle */
    #chat-assistant-header {
        padding: 8px 12px;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.12), rgba(99, 102, 241, 0.12));
        border-bottom: 1px solid var(--border, #3f3f5a);
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: grab;
        user-select: none;
        flex-shrink: 0;
    }

    #chat-assistant-header:active {
        cursor: grabbing;
    }

    #chat-assistant-header h3 {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary, #fff);
        display: flex;
        align-items: center;
        gap: 8px;
        pointer-events: none;
    }

    #chat-assistant-header .header-actions {
        display: flex;
        gap: 4px;
    }

    #chat-assistant-header button {
        background: transparent;
        border: none;
        color: var(--text-secondary, #a0a0a0);
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 14px;
        transition: all 0.2s;
    }

    #chat-assistant-header button:hover {
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-primary, #fff);
    }

    /* Resize handle styling */
    #chat-assistant-panel::-webkit-resizer {
        background: linear-gradient(135deg, transparent 50%, rgba(139, 92, 246, 0.3) 50%);
        border-radius: 0 0 12px 0;
    }

    /* Chat messages area */
    #chat-assistant-messages {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .chat-message {
        max-width: 88%;
        padding: 8px 12px;
        border-radius: 10px;
        font-size: 13px;
        line-height: 1.45;
        word-wrap: break-word;
    }

    .chat-message.user {
        align-self: flex-end;
        background: linear-gradient(135deg, #8b5cf6, #6366f1);
        color: white;
        border-bottom-right-radius: 4px;
    }

    .chat-message.assistant {
        align-self: flex-start;
        background: var(--item-bg, #2a2a3e);
        color: var(--text-primary, #fff);
        border-bottom-left-radius: 4px;
    }

    .chat-message.assistant .action-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 10px;
    }

    .chat-message.assistant .action-btn {
        padding: 6px 12px;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.4);
        border-radius: 6px;
        color: var(--text-primary, #fff);
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .chat-message.assistant .action-btn:hover {
        background: rgba(99, 102, 241, 0.4);
        border-color: rgba(99, 102, 241, 0.6);
    }

    .chat-message.system {
        align-self: center;
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
        font-size: 12px;
        padding: 6px 12px;
        border-radius: 20px;
    }

    .chat-message.error {
        align-self: center;
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
        font-size: 12px;
        padding: 6px 12px;
        border-radius: 20px;
    }

    .chat-typing {
        display: flex;
        gap: 4px;
        padding: 12px 16px;
        align-self: flex-start;
    }

    .chat-typing span {
        width: 8px;
        height: 8px;
        background: var(--text-secondary, #a0a0a0);
        border-radius: 50%;
        animation: typingBounce 1.4s ease-in-out infinite;
    }

    .chat-typing span:nth-child(2) { animation-delay: 0.2s; }
    .chat-typing span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typingBounce {
        0%, 60%, 100% { transform: translateY(0); }
        30% { transform: translateY(-6px); }
    }

    /* Chat input area */
    #chat-assistant-input-area {
        padding: 12px 16px;
        border-top: 1px solid var(--border, #3f3f5a);
        display: flex;
        gap: 8px;
        align-items: flex-end;
    }

    #chat-assistant-input {
        flex: 1;
        background: var(--item-bg, #2a2a3e);
        border: 1px solid var(--border, #3f3f5a);
        border-radius: 12px;
        padding: 10px 14px;
        color: var(--text-primary, #fff);
        font-size: 14px;
        resize: none;
        min-height: 20px;
        max-height: 100px;
        font-family: inherit;
    }

    #chat-assistant-input:focus {
        outline: none;
        border-color: #8b5cf6;
    }

    #chat-assistant-input::placeholder {
        color: var(--text-secondary, #a0a0a0);
    }

    #chat-voice-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: var(--item-bg, #2a2a3e);
        border: 1px solid var(--border, #3f3f5a);
        color: var(--text-secondary, #a0a0a0);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        transition: all 0.2s;
    }

    #chat-voice-btn:hover {
        border-color: #8b5cf6;
        color: #8b5cf6;
    }

    #chat-voice-btn.recording {
        background: rgba(239, 68, 68, 0.2);
        border-color: #ef4444;
        color: #ef4444;
        animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }

    #chat-send-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(135deg, #8b5cf6, #6366f1);
        border: none;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        transition: all 0.2s;
    }

    #chat-send-btn:hover {
        transform: scale(1.05);
    }

    #chat-send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }

    /* Quick actions bar */
    #chat-quick-actions {
        padding: 8px 16px;
        border-top: 1px solid var(--border, #3f3f5a);
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
    }

    .quick-action-chip {
        padding: 4px 10px;
        background: rgba(99, 102, 241, 0.15);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 12px;
        color: var(--text-secondary, #a0a0a0);
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .quick-action-chip:hover {
        background: rgba(99, 102, 241, 0.3);
        color: var(--text-primary, #fff);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUILD 393: FLOATING COMMAND FRAME (New Chat UI)
       - Spotlight-style floating frame at top-center
       - Always-visible action buttons
       - Collapsible history
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    #command-frame {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        width: 560px;
        max-width: calc(100vw - 48px);
        background: linear-gradient(180deg, rgba(30, 30, 46, 0.98), rgba(24, 24, 38, 0.99));
        border: 2px solid rgba(139, 92, 246, 0.35);
        border-radius: 16px;
        box-shadow:
            0 0 0 1px rgba(139, 92, 246, 0.15),
            0 8px 32px rgba(0, 0, 0, 0.5),
            0 0 60px rgba(139, 92, 246, 0.1);
        z-index: 9999;
        display: none;
        flex-direction: column;
        overflow: hidden;
        backdrop-filter: blur(12px);
    }

    #command-frame.open {
        display: flex;
        animation: frameSlideDown 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #command-frame.minimized {
        width: 220px;
        top: 16px;
    }

    #command-frame.minimized .command-context-bar,
    #command-frame.minimized .command-actions,
    #command-frame.minimized .command-input-area,
    #command-frame.minimized .command-history {
        display: none;
    }

    @keyframes frameSlideDown {
        from {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    }

    /* BUILD 395: Visual Feedback Animations */
    @keyframes vfPulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }

    @keyframes vfBadgeFloat {
        from {
            opacity: 0;
            transform: translateX(-50%) translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    }

    @keyframes vfLineDash {
        to { stroke-dashoffset: -12; }
    }

    .vf-pulse {
        animation: vfPulse 1s ease-in-out infinite;
    }

    .vf-overlay {
        transition: opacity 0.3s ease-out;
    }

    .vf-badge, .vf-canvas-badge {
        animation: vfBadgeFloat 0.3s ease-out;
    }

    /* Command Frame Header */
    .command-frame-header {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 14px;
        background: rgba(139, 92, 246, 0.08);
        border-bottom: 1px solid rgba(139, 92, 246, 0.2);
        cursor: grab;
        user-select: none;
    }

    .command-frame-header:active { cursor: grabbing; }

    .frame-icon { font-size: 16px; }
    .frame-title {
        font-size: 14px;
        font-weight: 600;
        color: #a5b4fc;
        flex: 1;
    }

    /* Mode Pills */
    .mode-pills {
        display: flex;
        gap: 4px;
        background: rgba(0, 0, 0, 0.25);
        padding: 3px;
        border-radius: 10px;
    }

    .mode-pill {
        padding: 5px 10px;
        border: none;
        border-radius: 8px;
        background: transparent;
        color: #9ca3af;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .mode-pill:hover { color: #e5e7eb; }

    .mode-pill.active {
        background: rgba(139, 92, 246, 0.4);
        color: white;
    }

    .frame-minimize, .frame-close {
        width: 28px;
        height: 28px;
        border: none;
        border-radius: 6px;
        background: transparent;
        color: #9ca3af;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .frame-minimize:hover, .frame-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: white;
    }

    /* Context Bar */
    .command-context-bar {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 14px;
        background: rgba(16, 185, 129, 0.1);
        border-bottom: 1px solid rgba(16, 185, 129, 0.2);
        font-size: 12px;
        color: #10b981;
    }

    .command-context-bar.no-focus {
        background: rgba(107, 114, 128, 0.1);
        border-color: rgba(107, 114, 128, 0.2);
        color: #9ca3af;
    }

    .context-icon { font-size: 14px; }

    .context-text {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .context-action {
        padding: 4px 8px;
        border: none;
        border-radius: 4px;
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
    }

    .context-action:hover { background: rgba(16, 185, 129, 0.3); }

    /* Action Buttons Grid */
    .command-actions {
        padding: 10px 14px;
        border-bottom: 1px solid rgba(139, 92, 246, 0.15);
    }

    .action-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .action-row.secondary-actions {
        margin-top: 8px;
    }

    .action-row.secondary-actions.collapsed {
        display: none;
    }

    .cmd-btn {
        padding: 8px 14px;
        background: rgba(99, 102, 241, 0.15);
        border: 1px solid rgba(99, 102, 241, 0.25);
        border-radius: 10px;
        color: #e5e7eb;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .cmd-btn:hover {
        background: rgba(99, 102, 241, 0.3);
        border-color: rgba(99, 102, 241, 0.4);
        transform: translateY(-1px);
    }

    .cmd-btn:active { transform: translateY(0); }

    .cmd-btn .btn-icon { font-size: 14px; }
    .cmd-btn .btn-label { font-weight: 500; }

    .cmd-btn.highlight {
        background: rgba(16, 185, 129, 0.2);
        border-color: rgba(16, 185, 129, 0.3);
        color: #34d399;
    }

    /* Input Area */
    .command-input-area {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 14px;
    }

    #command-input {
        flex: 1;
        padding: 11px 16px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(139, 92, 246, 0.25);
        border-radius: 12px;
        color: white;
        font-size: 14px;
        outline: none;
        transition: all 0.2s;
    }

    #command-input:focus {
        border-color: rgba(139, 92, 246, 0.5);
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    #command-input::placeholder { color: #6b7280; }

    .command-btn {
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 10px;
        background: rgba(139, 92, 246, 0.2);
        color: #a5b4fc;
        cursor: pointer;
        font-size: 18px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .command-btn:hover {
        background: rgba(139, 92, 246, 0.35);
        color: white;
    }

    .command-btn.primary {
        background: linear-gradient(135deg, #8b5cf6, #6366f1);
        color: white;
    }

    .command-btn.primary:hover {
        transform: scale(1.05);
    }

    /* Collapsible History */
    .command-history {
        border-top: 1px solid rgba(139, 92, 246, 0.15);
    }

    .history-toggle {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 14px;
        cursor: pointer;
        font-size: 12px;
        color: #9ca3af;
        transition: background 0.2s;
    }

    .history-toggle:hover { background: rgba(139, 92, 246, 0.05); }

    .command-history.collapsed .history-messages { display: none; }
    .command-history.collapsed .toggle-icon { transform: rotate(0deg); }
    .command-history:not(.collapsed) .toggle-icon { transform: rotate(180deg); }

    .toggle-icon { transition: transform 0.2s; }

    .history-messages {
        max-height: 180px;
        overflow-y: auto;
        padding: 0 14px 14px;
    }

    .history-msg {
        padding: 8px 12px;
        margin-bottom: 8px;
        border-radius: 10px;
        font-size: 13px;
        line-height: 1.45;
    }

    .history-msg.user {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.4), rgba(99, 102, 241, 0.4));
        color: white;
        margin-left: 25%;
        border-bottom-right-radius: 4px;
    }

    .history-msg.assistant {
        background: rgba(45, 45, 65, 0.8);
        color: #e5e7eb;
        margin-right: 25%;
        border-bottom-left-radius: 4px;
    }

    /* Visual Feedback Overlay */
    .feedback-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9998;
    }

    /* Mobile: Full-screen command frame */
    @media screen and (max-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #command-frame.open {
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            max-width: 100vw;
            height: 100vh;
            transform: none;
            border-radius: 0;
            animation: none;
        }

        .command-frame-header {
            padding-top: max(12px, env(safe-area-inset-top));
        }

        .command-input-area {
            padding-bottom: max(12px, env(safe-area-inset-bottom));
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUILD 405: LIVE TREE AGENT (Chat Builder Redesign)
       - Floating frame for watching tree build in real-time
       - Top-left position, draggable
       - Full chat history with choices
       - Visual node highlighting integration
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    #tree-agent-frame {
        position: fixed;
        top: 80px;
        left: 20px;
        width: 380px;
        max-height: 600px;
        background: linear-gradient(180deg, rgba(30, 30, 46, 0.97), rgba(24, 24, 38, 0.98));
        border: 2px solid rgba(16, 185, 129, 0.35);
        border-radius: 16px;
        box-shadow:
            0 0 0 1px rgba(16, 185, 129, 0.15),
            0 8px 32px rgba(0, 0, 0, 0.5),
            0 0 60px rgba(16, 185, 129, 0.08);
        z-index: 9999;
        display: none;
        flex-direction: column;
        overflow: hidden;
        backdrop-filter: blur(12px);
    }

    #tree-agent-frame.open {
        display: flex;
        animation: agentSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #tree-agent-frame.minimized .agent-body {
        display: none;
    }

    #tree-agent-frame.minimized {
        max-height: 56px;
    }

    @keyframes agentSlideIn {
        from {
            opacity: 0;
            transform: translateX(-20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
    }

    /* Agent Header */
    .agent-header {
        display: flex;
        flex-direction: column;
        padding: 12px 14px;
        background: rgba(16, 185, 129, 0.1);
        border-bottom: 1px solid rgba(16, 185, 129, 0.2);
        cursor: grab;
        user-select: none;
    }

    .agent-header:active { cursor: grabbing; }

    .agent-title-row {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .agent-icon {
        font-size: 18px;
        animation: agentPulse 2s ease-in-out infinite;
    }

    @keyframes agentPulse {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.8; transform: scale(1.05); }
    }

    .agent-title {
        flex: 1;
        font-size: 14px;
        font-weight: 600;
        color: #34d399;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .agent-progress-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 8px;
    }

    .agent-progress-bar {
        flex: 1;
        height: 6px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 3px;
        overflow: hidden;
    }

    .agent-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #10b981, #34d399);
        border-radius: 3px;
        transition: width 0.4s ease-out;
    }

    .agent-progress-text {
        font-size: 12px;
        color: #9ca3af;
        min-width: 36px;
        text-align: right;
    }

    .agent-header-actions {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 4px;
    }

    .agent-btn {
        width: 28px;
        height: 28px;
        border: none;
        border-radius: 6px;
        background: transparent;
        color: #9ca3af;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .agent-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: white;
    }

    /* Agent Body */
    .agent-body {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
    }

    /* Messages Area */
    .agent-messages {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        max-height: 350px;
        min-height: 150px;
    }

    .agent-message {
        padding: 10px 12px;
        margin-bottom: 10px;
        border-radius: 12px;
        font-size: 13px;
        line-height: 1.5;
        animation: msgFadeIn 0.3s ease-out;
    }

    @keyframes msgFadeIn {
        from { opacity: 0; transform: translateY(8px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .agent-message.user {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.4), rgba(139, 92, 246, 0.4));
        color: white;
        margin-left: 20%;
        border-bottom-right-radius: 4px;
    }

    .agent-message.assistant {
        background: rgba(45, 45, 65, 0.8);
        color: #e5e7eb;
        margin-right: 10%;
        border-bottom-left-radius: 4px;
    }

    .agent-message.system {
        background: rgba(16, 185, 129, 0.15);
        border: 1px solid rgba(16, 185, 129, 0.25);
        color: #34d399;
        font-size: 12px;
        text-align: center;
    }

    /* Choices Container */
    .agent-choices {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 0 12px 12px;
    }

    .agent-choice-btn {
        padding: 8px 14px;
        background: rgba(16, 185, 129, 0.15);
        border: 1px solid rgba(16, 185, 129, 0.3);
        border-radius: 20px;
        color: #34d399;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .agent-choice-btn:hover {
        background: rgba(16, 185, 129, 0.3);
        border-color: rgba(16, 185, 129, 0.5);
        transform: translateY(-1px);
    }

    .agent-choice-btn:active {
        transform: translateY(0);
    }

    /* Input Row */
    .agent-input-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        border-top: 1px solid rgba(16, 185, 129, 0.15);
        background: rgba(0, 0, 0, 0.15);
    }

    #agent-input {
        flex: 1;
        padding: 10px 14px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(16, 185, 129, 0.25);
        border-radius: 10px;
        color: white;
        font-size: 13px;
        outline: none;
        transition: all 0.2s;
    }

    #agent-input:focus {
        border-color: rgba(16, 185, 129, 0.5);
        box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
    }

    #agent-input::placeholder { color: #6b7280; }

    .agent-input-btn {
        width: 36px;
        height: 36px;
        border: none;
        border-radius: 8px;
        background: rgba(16, 185, 129, 0.2);
        color: #34d399;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .agent-input-btn:hover {
        background: rgba(16, 185, 129, 0.35);
        color: white;
    }

    .agent-input-btn.primary {
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
    }

    .agent-input-btn.primary:hover {
        transform: scale(1.05);
    }

    /* Footer Actions */
    .agent-footer {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 12px;
        border-top: 1px solid rgba(16, 185, 129, 0.15);
        background: rgba(16, 185, 129, 0.05);
    }

    .agent-action-btn {
        flex: 1;
        padding: 10px 16px;
        border: 1px solid rgba(107, 114, 128, 0.3);
        border-radius: 8px;
        background: transparent;
        color: #9ca3af;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
    }

    .agent-action-btn:hover {
        background: rgba(107, 114, 128, 0.15);
        color: #e5e7eb;
    }

    .agent-action-btn.primary {
        background: linear-gradient(135deg, #10b981, #059669);
        border-color: transparent;
        color: white;
    }

    .agent-action-btn.primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    /* Node Highlight Animations (for tree view integration) */
    .node-new-highlight {
        animation: nodeNewPulse 2s ease-out;
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.6);
    }

    .node-modified-highlight {
        animation: nodeModifiedPulse 2s ease-out;
        box-shadow: 0 0 20px rgba(234, 179, 8, 0.6);
    }

    @keyframes nodeNewPulse {
        0% {
            box-shadow: 0 0 0 rgba(16, 185, 129, 0.8);
            background-color: rgba(16, 185, 129, 0.3);
        }
        50% {
            box-shadow: 0 0 25px rgba(16, 185, 129, 0.6);
        }
        100% {
            box-shadow: 0 0 0 rgba(16, 185, 129, 0);
            background-color: transparent;
        }
    }

    @keyframes nodeModifiedPulse {
        0% {
            box-shadow: 0 0 0 rgba(234, 179, 8, 0.8);
            background-color: rgba(234, 179, 8, 0.2);
        }
        50% {
            box-shadow: 0 0 25px rgba(234, 179, 8, 0.6);
        }
        100% {
            box-shadow: 0 0 0 rgba(234, 179, 8, 0);
            background-color: transparent;
        }
    }

    /* Mobile Responsive */
    @media screen and (max-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #tree-agent-frame.open {
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            max-width: 100vw;
            height: 100vh;
            max-height: 100vh;
            border-radius: 0;
            animation: none;
        }

        .agent-header {
            padding-top: max(12px, env(safe-area-inset-top));
        }

        .agent-footer {
            padding-bottom: max(10px, env(safe-area-inset-bottom));
        }

        .agent-messages {
            max-height: none;
            flex: 1;
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUILD 370: VOICE CAPTURE SYSTEM
       - Mobile full-screen TreeBeard
       - FAB (Floating Action Button) for voice capture
       - Voice capture UI with live transcript
       - Captures section in TreeBeard
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Mobile Full-Screen TreeBeard */
    @media screen and (max-width: 768px), (max-device-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #chat-assistant-panel.open {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            min-width: 100vw !important;
            min-height: 100vh !important;
            border-radius: 0 !important;
            z-index: 10001 !important;
            resize: none !important;
            animation: none !important;
        }

        #chat-assistant-panel.open #chat-assistant-header {
            padding: 16px !important;
            padding-top: max(16px, env(safe-area-inset-top)) !important;
        }

        #chat-assistant-panel.open #chat-assistant-input-area {
            padding: 16px !important;
            padding-bottom: max(16px, env(safe-area-inset-bottom)) !important;
        }

        /* Hide original bubble on mobile when panel is open */
        #chat-assistant-bubble.panel-open {
            display: none !important;
        }
    }

    /* Voice Capture FAB (Floating Action Button) */
    #voice-capture-fab {
        position: fixed;
        bottom: 100px;
        right: 24px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(135deg, #10b981, #059669);
        border: none;
        cursor: pointer;
        box-shadow: 0 4px 20px rgba(16, 185, 129, 0.4);
        z-index: 9998;
        display: none; /* Hidden by default, shown on mobile */
        align-items: center;
        justify-content: center;
        font-size: 28px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #voice-capture-fab:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 28px rgba(16, 185, 129, 0.5);
    }

    #voice-capture-fab:active {
        transform: scale(0.95);
    }

    #voice-capture-fab.recording {
        background: linear-gradient(135deg, #ef4444, #dc2626);
        box-shadow: 0 4px 20px rgba(239, 68, 68, 0.5);
        animation: fabPulse 1.5s ease-in-out infinite;
    }

    #voice-capture-fab .fab-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        min-width: 22px;
        height: 22px;
        background: #ef4444;
        border-radius: 11px;
        color: white;
        font-size: 12px;
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 6px;
        border: 2px solid var(--bg-primary, #0f172a);
    }

    @keyframes fabPulse {
        0%, 100% { box-shadow: 0 4px 20px rgba(239, 68, 68, 0.5); }
        50% { box-shadow: 0 4px 30px rgba(239, 68, 68, 0.8); }
    }

    /* Show FAB on mobile */
    @media screen and (max-width: 768px), (max-device-width: 768px), (pointer: coarse) and (max-width: 1024px) {
        #voice-capture-fab {
            display: flex;
        }

        /* Hide FAB when TreeBeard is open, during modals, or 3D view */
        body.treebeard-open #voice-capture-fab,
        body.modal-open #voice-capture-fab,
        body.view-3d-active #voice-capture-fab {
            display: none !important;
        }
    }

    /* Voice Capture Section in TreeBeard */
    #voice-captures-section {
        border-bottom: 1px solid var(--border, #3f3f5a);
        max-height: 200px;
        overflow-y: auto;
    }

    #voice-captures-section.collapsed {
        max-height: 44px;
        overflow: hidden;
    }

    .captures-header {
        padding: 10px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        background: rgba(16, 185, 129, 0.1);
        transition: background 0.2s;
    }

    .captures-header:hover {
        background: rgba(16, 185, 129, 0.15);
    }

    .captures-header h4 {
        margin: 0;
        font-size: 12px;
        font-weight: 600;
        color: #10b981;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .captures-header .capture-count {
        background: #10b981;
        color: white;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 10px;
        font-weight: 700;
    }

    .captures-header .toggle-icon {
        color: var(--text-secondary);
        font-size: 12px;
        transition: transform 0.2s;
    }

    #voice-captures-section.collapsed .toggle-icon {
        transform: rotate(-90deg);
    }

    .captures-list {
        padding: 8px;
    }

    .capture-item {
        background: var(--item-bg, #2a2a3e);
        border: 1px solid var(--border, #3f3f5a);
        border-radius: 8px;
        padding: 10px 12px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .capture-item:hover {
        border-color: #10b981;
        background: rgba(16, 185, 129, 0.1);
    }

    .capture-item:last-child {
        margin-bottom: 0;
    }

    .capture-item .capture-preview {
        font-size: 13px;
        color: var(--text-primary);
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }

    .capture-item.expanded .capture-preview {
        -webkit-line-clamp: unset;
        display: block;
    }

    .capture-item .capture-meta {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 6px;
        font-size: 11px;
        color: var(--text-secondary);
    }

    .capture-item .capture-meta .word-count {
        background: rgba(99, 102, 241, 0.2);
        padding: 2px 6px;
        border-radius: 4px;
        color: #a5b4fc;
    }

    .capture-actions {
        display: none;
        gap: 6px;
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid var(--border, #3f3f5a);
    }

    .capture-item.expanded .capture-actions {
        display: flex;
        flex-wrap: wrap;
    }

    .capture-action-btn {
        padding: 6px 10px;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--text-primary);
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .capture-action-btn:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    .capture-action-btn.delete {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.3);
    }

    .capture-action-btn.delete:hover {
        background: rgba(239, 68, 68, 0.4);
    }

    /* Voice Recording UI in TreeBeard */
    #voice-recording-ui {
        display: none;
        flex-direction: column;
        align-items: center;
        padding: 24px;
        background: linear-gradient(180deg, rgba(16, 185, 129, 0.1), transparent);
        border-bottom: 1px solid var(--border, #3f3f5a);
    }

    #voice-recording-ui.active {
        display: flex;
    }

    .recording-status {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 16px;
    }

    .recording-dot {
        width: 12px;
        height: 12px;
        background: #ef4444;
        border-radius: 50%;
        animation: blink 1s infinite;
    }

    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.4; }
    }

    .recording-duration {
        font-size: 24px;
        font-weight: 700;
        color: #10b981;
        font-family: 'SF Mono', 'Monaco', monospace;
    }

    .live-transcript-area {
        width: 100%;
        min-height: 100px;
        max-height: 200px;
        overflow-y: auto;
        background: var(--item-bg, #2a2a3e);
        border: 1px solid var(--border, #3f3f5a);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 16px;
        font-size: 14px;
        line-height: 1.6;
        color: var(--text-primary);
    }

    .live-transcript-area .interim {
        color: var(--text-secondary);
        font-style: italic;
    }

    .live-transcript-area .final {
        color: var(--text-primary);
    }

    .live-transcript-placeholder {
        color: var(--text-secondary);
        font-style: italic;
        text-align: center;
    }

    .recording-controls {
        display: flex;
        gap: 12px;
    }

    .recording-stop-btn {
        padding: 12px 24px;
        background: linear-gradient(135deg, #10b981, #059669);
        border: none;
        border-radius: 8px;
        color: white;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
    }

    .recording-stop-btn:hover {
        transform: scale(1.02);
    }

    .recording-cancel-btn {
        padding: 12px 24px;
        background: var(--item-bg, #2a2a3e);
        border: 1px solid var(--border, #3f3f5a);
        border-radius: 8px;
        color: var(--text-secondary);
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .recording-cancel-btn:hover {
        border-color: #ef4444;
        color: #ef4444;
    }

    .recording-warning {
        margin-top: 12px;
        padding: 8px 12px;
        background: rgba(245, 158, 11, 0.2);
        border-radius: 6px;
        color: #f59e0b;
        font-size: 12px;
        display: none;
    }

    .recording-warning.show {
        display: block;
    }

    /* Capture Processing Modal in TreeBeard */
    .capture-processing-prompt {
        padding: 16px;
        background: rgba(16, 185, 129, 0.1);
        border-bottom: 1px solid var(--border, #3f3f5a);
    }

    .capture-processing-prompt .prompt-header {
        font-size: 12px;
        color: #10b981;
        font-weight: 600;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .capture-processing-prompt .transcript-preview {
        background: var(--item-bg, #2a2a3e);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 12px;
        font-size: 13px;
        line-height: 1.5;
        max-height: 120px;
        overflow-y: auto;
    }

    .capture-processing-prompt .quick-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 8px;
    }

    .capture-processing-prompt .quick-action {
        padding: 8px 14px;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 8px;
        color: var(--text-primary);
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .capture-processing-prompt .quick-action:hover {
        background: rgba(99, 102, 241, 0.4);
        border-color: rgba(99, 102, 241, 0.5);
    }

    .capture-processing-prompt .instruction-hint {
        font-size: 11px;
        color: var(--text-secondary);
        font-style: italic;
    }

    /* Artifact Badge Indicators */
    .artifact-badge {
        display: inline-flex;
        align-items: center;
        gap: 2px;
        padding: 2px 6px;
        background: rgba(99, 102, 241, 0.2);
        border-radius: 4px;
        font-size: 11px;
        color: #a5b4fc;
        margin-left: 6px;
    }

    /* BUILD 371: Artifact Side Panel */
    #artifact-panel {
        position: fixed;
        top: 60px;
        right: -400px;
        width: 380px;
        height: calc(100vh - 60px);
        background: var(--surface, #1e1e2e);
        border-left: 1px solid var(--border, #3f3f5a);
        z-index: 200;
        display: flex;
        flex-direction: column;
        transition: right 0.3s ease;
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
    }

    #artifact-panel.open {
        right: 0;
    }

    #artifact-panel .panel-header {
        padding: 16px 20px;
        background: var(--header-bg, #16161e);
        border-bottom: 1px solid var(--border, #3f3f5a);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    #artifact-panel .panel-header h3 {
        margin: 0;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    #artifact-panel .panel-header .item-name {
        font-size: 12px;
        color: var(--text-secondary);
        margin-top: 4px;
    }

    #artifact-panel .panel-close {
        background: none;
        border: none;
        color: var(--text-secondary);
        font-size: 20px;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
    }

    #artifact-panel .panel-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
    }

    #artifact-panel .panel-content {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }

    /* Drop zone for artifacts */
    .artifact-drop-zone {
        border: 2px dashed rgba(99, 102, 241, 0.4);
        border-radius: 12px;
        padding: 32px;
        text-align: center;
        margin-bottom: 16px;
        background: rgba(99, 102, 241, 0.05);
        transition: all 0.2s;
        cursor: pointer;
    }

    .artifact-drop-zone:hover,
    .artifact-drop-zone.drag-over {
        border-color: #6366f1;
        background: rgba(99, 102, 241, 0.15);
    }

    .artifact-drop-zone .drop-icon {
        font-size: 32px;
        margin-bottom: 12px;
    }

    .artifact-drop-zone .drop-text {
        font-size: 14px;
        color: var(--text-secondary);
    }

    .artifact-drop-zone .drop-hint {
        font-size: 11px;
        color: var(--text-tertiary);
        margin-top: 8px;
    }

    /* Artifact list */
    .artifact-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .artifact-list-item {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 12px;
        background: var(--item-bg, #2a2a3e);
        border-radius: 8px;
        border: 1px solid var(--border, #3f3f5a);
        transition: all 0.2s;
    }

    .artifact-list-item:hover {
        background: var(--item-hover, #32324a);
    }

    .artifact-list-item .artifact-preview {
        width: 60px;
        height: 60px;
        border-radius: 6px;
        overflow: hidden;
        background: rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }

    .artifact-list-item .artifact-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .artifact-list-item .artifact-preview .placeholder-icon {
        font-size: 24px;
        opacity: 0.5;
    }

    .artifact-list-item .artifact-info {
        flex: 1;
        min-width: 0;
    }

    .artifact-list-item .artifact-name {
        font-size: 13px;
        font-weight: 500;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .artifact-list-item .artifact-meta {
        font-size: 11px;
        color: var(--text-secondary);
        margin-top: 4px;
    }

    .artifact-list-item .artifact-actions {
        display: flex;
        gap: 4px;
        margin-top: 8px;
    }

    .artifact-list-item .artifact-action {
        padding: 4px 8px;
        font-size: 11px;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 4px;
        color: #a5b4fc;
        cursor: pointer;
    }

    .artifact-list-item .artifact-action:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    .artifact-list-item .artifact-action.delete {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.3);
        color: #fca5a5;
    }

    .artifact-list-item .artifact-action.delete:hover {
        background: rgba(239, 68, 68, 0.4);
    }

    /* Empty state */
    .artifact-empty {
        text-align: center;
        padding: 32px;
        color: var(--text-secondary);
    }

    .artifact-empty .empty-icon {
        font-size: 48px;
        opacity: 0.3;
        margin-bottom: 12px;
    }

    /* Item row artifact indicator */
    .item-row .item-artifacts-indicator {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 6px;
        background: rgba(99, 102, 241, 0.15);
        border-radius: 4px;
        font-size: 10px;
        color: #a5b4fc;
        cursor: pointer;
        margin-left: 4px;
    }

    .item-row .item-artifacts-indicator:hover {
        background: rgba(99, 102, 241, 0.3);
    }

    /* Mobile adjustments for artifact panel */
    @media screen and (max-width: 768px) {
        #artifact-panel {
            width: 100vw;
            right: -100vw;
        }

        #artifact-panel.open {
            right: 0;
        }
    }

    </style>
    <!-- SheetJS library for Excel export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <!-- LZ-String library for URL compression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <!-- html2canvas for Canvas export as image -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <!-- JSZip for .treelisty bundle export/import -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- Google API Client Library for OAuth and Drive API -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <!-- Firebase SDK (modular CDN) -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, updateDoc, onSnapshot, serverTimestamp, getDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBU_n37rTiae2oM95ZS3Ojkg7UvhZmkCRo",
            authDomain: "treelisty.firebaseapp.com",
            projectId: "treelisty",
            storageBucket: "treelisty.firebasestorage.app",
            messagingSenderId: "281763482612",
            appId: "1:281763482612:web:72de0c4f347fe48fc147a1"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Expose to global scope for use in main script
        window.firebaseApp = app;
        window.firebaseAuth = auth;
        window.firebaseDb = db;
        window.firebaseSignInAnonymously = signInAnonymously;
        window.firebaseOnAuthStateChanged = onAuthStateChanged;
        window.firebaseDoc = doc;
        window.firebaseSetDoc = setDoc;
        window.firebaseOnSnapshot = onSnapshot;
        window.firebaseServerTimestamp = serverTimestamp;
        window.firebaseGetDoc = getDoc;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseReady = true;

        console.log('ðŸ”¥ Firebase initialized');
    </script>
</head>
<body>
    <!-- TreeListy by geej Splash Screen -->
    <div id="splash-screen">
        <div class="splash-logo">ðŸŒ³</div>
        <div class="splash-title">TreeListy</div>
        <div class="splash-subtitle">by geej</div>
        <div class="splash-tagline">From Complexity to Clarity</div>
        <div class="splash-loader">
            <div class="splash-loader-bar"></div>
        </div>
    </div>

    <!-- BUILD 335: Mobile Menu Overlay (click to close) -->
    <div id="mobile-menu-overlay" class="mobile-menu-overlay"></div>


    <!-- Header -->
    <div class="header">
        <div style="display: flex; align-items: center; gap: 20px;">
            <div class="logo">
                <div class="logo-title">
                    <span>ðŸŒ³</span>
                    <span>TreeListy</span>
                </div>
                <div class="logo-subtitle">by geej</div>
            </div>

            <!-- Save Indicator -->
            <div id="save-indicator" style="font-size: 12px; color: #9DA3B4; margin-left: 12px; white-space: nowrap;">
                â— Unsaved changes
            </div>

            <!-- BUILD 335: Mobile Hamburger Menu Button -->
            <button id="mobile-menu-btn" class="mobile-hamburger" aria-label="Open menu" aria-expanded="false">
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
            </button>

        </div>
        <div class="controls" style="flex-wrap: wrap; gap: 8px;">
            <!-- BUILD 333: View Selector Dropdown - Shows current state -->
            <div class="control-section" style="margin-right: 4px;">
                <div class="dropdown-menu" id="view-dropdown">
                    <button class="dropdown-menu-trigger" id="view-dropdown-btn" aria-expanded="false" aria-haspopup="true" title="Switch view mode">
                        <span id="current-view-icon">ðŸŒ²</span>
                        <span id="current-view-text">Tree</span>
                    </button>
                    <div class="dropdown-menu-content" role="menu" aria-label="View options">
                        <button class="dropdown-menu-item" role="menuitem" id="view-tree-btn" data-view="tree">
                            <span class="item-icon">ðŸŒ²</span>
                            <span class="item-label">Tree View</span>
                            <span class="item-shortcut" id="tree-check">âœ“</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="view-canvas-btn" data-view="canvas">
                            <span class="item-icon">ðŸŽ¨</span>
                            <span class="item-label">Canvas View</span>
                            <span class="item-shortcut" id="canvas-check" style="opacity: 0;">âœ“</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="view-3d-btn" data-view="3d">
                            <span class="item-icon">ðŸ§Š</span>
                            <span class="item-label">3D Navigator</span>
                            <span class="item-shortcut" id="3d-check" style="opacity: 0;">âœ“</span>
                        </button>
                        <div class="dropdown-menu-divider"></div>
                        <button class="dropdown-menu-item" role="menuitem" id="export-canvas-btn" style="display: none;">
                            <span class="item-icon">ðŸ“·</span>
                            <span class="item-label">Export as PNG</span>
                        </button>
                    </div>
                </div>
                <!-- Hidden buttons for backwards compatibility with existing JS -->
                <button class="btn" id="toggle-view-mode" style="display: none;">
                    <span id="view-mode-icon">ðŸŽ¨</span>
                    <span id="view-mode-text">Canvas</span>
                </button>
                <button class="btn" id="toggle-3d-mode" style="display: none;">ðŸ§Š 3D</button>
            </div>

            <!-- BUILD 331: Consolidated Open/Save Dropdowns -->
            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="new-project-btn" style="background: linear-gradient(135deg, #059669, #10b981); padding: 6px 10px; font-size: 13px;" title="Start a new project">ðŸ†•</button>

                <!-- Open Dropdown -->
                <div class="dropdown-menu" id="open-dropdown">
                    <button class="dropdown-menu-trigger" id="open-dropdown-btn" aria-expanded="false" aria-haspopup="true" title="Open project from various sources">
                        <span>ðŸ“‚ Open</span>
                    </button>
                    <div class="dropdown-menu-content" role="menu" aria-label="Open options">
                        <button class="dropdown-menu-item" role="menuitem" id="load-json-btn">
                            <span class="item-icon">ðŸ“„</span>
                            <span class="item-label">Open Saved Tree</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="load-gdrive-btn">
                            <span class="item-icon">â˜ï¸</span>
                            <span class="item-label">From Google Drive</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="excel-import-btn">
                            <span class="item-icon">ðŸ“Š</span>
                            <span class="item-label">From Excel (.xlsx)</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="msproject-import-btn">
                            <span class="item-icon">ðŸ“…</span>
                            <span class="item-label">From MS Project (.xml)</span>
                        </button>
                        <div class="dropdown-menu-divider"></div>
                        <button class="dropdown-menu-item" role="menuitem" id="import-text-header-btn">
                            <span class="item-icon">ðŸ“</span>
                            <span class="item-label">Import Text (AI)</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="refresh-drive-btn" style="display: none;">
                            <span class="item-icon">ðŸ”„</span>
                            <span class="item-label">Refresh from Drive</span>
                        </button>
                    </div>
                </div>
                <input type="file" id="excel-upload-input" accept=".xlsx,.xls" style="display: none;">
                <input type="file" id="msproject-upload-input" accept=".xml" style="display: none;">

                <!-- Save Dropdown -->
                <div class="dropdown-menu" id="save-dropdown">
                    <button class="dropdown-menu-trigger btn-green" id="save-dropdown-btn" aria-expanded="false" aria-haspopup="true" title="Save or export project">
                        <span>ðŸ’¾ Save</span>
                    </button>
                    <div class="dropdown-menu-content" role="menu" aria-label="Save options">
                        <button class="dropdown-menu-item" role="menuitem" id="save-json-btn">
                            <span class="item-icon">ðŸ“„</span>
                            <span class="item-label">Save Tree</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="save-bundle-btn" onclick="window.exportTreelistyBundle()">
                            <span class="item-icon">ðŸ“¦</span>
                            <span class="item-label">Save Tree + Attachments</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="excel-export-btn">
                            <span class="item-icon">ðŸ“Š</span>
                            <span class="item-label">Export to Excel</span>
                        </button>
                        <button class="dropdown-menu-item" role="menuitem" id="msproject-export-btn">
                            <span class="item-icon">ðŸ“…</span>
                            <span class="item-label">Export to MS Project (.xml)</span>
                        </button>
                        <div class="dropdown-menu-divider"></div>
                        <button class="dropdown-menu-item" role="menuitem" id="share-btn">
                            <span class="item-icon">ðŸ”—</span>
                            <span class="item-label">Share as URL</span>
                        </button>
                    </div>
                </div>

                <button class="btn" id="live-sync-btn" onclick="document.getElementById('live-sync-modal').style.display='flex'; window.initFirebaseAuthIfNeeded && window.initFirebaseAuthIfNeeded();" style="background: linear-gradient(135deg, #f97316, #ea580c); padding: 6px 10px; font-size: 13px;" title="ðŸ”¥ Firebase Live Sync">ðŸ”„ Live</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="undo-btn" title="Undo last action" disabled style="opacity: 0.5; padding: 6px 10px; font-size: 13px;">â†©ï¸</button>
                <button class="btn" id="expand-btn" title="Expand all" style="padding: 6px 10px; font-size: 13px;">â¬‡ï¸</button>
                <button class="btn" id="collapse-btn" title="Collapse all" style="padding: 6px 10px; font-size: 13px;">â¬†ï¸</button>
                <button class="btn" id="search-btn" style="background: linear-gradient(135deg, #3b82f6, #2563eb); padding: 6px 10px; font-size: 13px;" title="Search all fields">ðŸ”</button>
            </div>

            <div class="control-section pattern-selector" style="margin-right: 4px;">
                <select class="pattern-select" id="pattern-select" title="Choose naming pattern" style="padding: 6px 10px; font-size: 13px; min-width: 140px;">
                    <option value="generic" data-desc="Universal: Project â†’ Phase â†’ Item â†’ Task">ðŸ“‹ Generic Project</option>
                    <option value="sales" data-desc="Sales: Pipeline â†’ Quarter â†’ Deal â†’ Action">ðŸ’¼ Sales Pipeline</option>
                    <option value="thesis" data-desc="Academic: Thesis â†’ Chapter â†’ Section â†’ Point">ðŸŽ“ Academic Writing</option>
                    <option value="roadmap" data-desc="Product: Product â†’ Quarter â†’ Feature â†’ Story">ðŸš€ Product Roadmap</option>
                    <option value="book" data-desc="Writing: Book â†’ Part â†’ Chapter â†’ Scene">ðŸ“š Book Writing</option>
                    <option value="event" data-desc="Events: Event â†’ Stage â†’ Activity â†’ Task">ðŸŽ‰ Event Planning</option>
                    <option value="fitness" data-desc="Fitness: Program â†’ Phase â†’ Workout â†’ Exercise">ðŸ’ª Fitness Program</option>
                    <option value="strategy" data-desc="Business: Strategy â†’ Pillar â†’ Initiative â†’ Action">ðŸ“Š Strategic Plan</option>
                    <option value="course" data-desc="Education: Course â†’ Unit â†’ Lesson â†’ Exercise">ðŸ“– Course Design</option>
                    <option value="film" data-desc="Production: Film â†’ Phase â†’ Scene â†’ Shot">ðŸŽ¬ Film Production</option>
                    <option value="veo3" data-desc="Veo3: Project â†’ Sequence â†’ Scene â†’ Shot/Frame">ðŸŽ¥ Veo3 (Google)</option>
                    <option value="sora2" data-desc="Sora2: Project â†’ Sequence â†’ Beat â†’ Shot/Remix">ðŸŽ¬ Sora2 (OpenAI)</option>
                    <option value="philosophy" data-desc="Philosophy: Treatise â†’ Book â†’ Argument â†’ Premise">ðŸ¤” Philosophy</option>
                    <option value="prompting" data-desc="AI Prompting: Workbook â†’ Stage â†’ Module â†’ Step">ðŸ§  AI Prompt Design</option>
                    <option value="familytree" data-desc="Genealogy: Family â†’ Generation â†’ Person â†’ Event">ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family Tree</option>
                    <option value="lifetree" data-desc="Biography: Life â†’ Decade â†’ Event â†’ Detail">ðŸŒ³ LifeTree (Biography)</option>
                    <option value="dialogue" data-desc="Rhetoric: Conversation â†’ Speaker â†’ Statement â†’ Point">ðŸ’¬ Dialogue & Rhetoric</option>
                    <option value="gmail" data-desc="Email: Inbox/Campaign â†’ Label/Stage â†’ Thread â†’ Message">ðŸ“§ Email Workflow</option>
                    <option value="filesystem" data-desc="File System: Drive â†’ Folder â†’ File/Folder (Unlimited Depth)">ðŸ’¾ File System</option>
                    <option value="capex" data-desc="Investor: Project â†’ Funding Phase â†’ Investment â†’ Deliverable">ðŸ’° CAPEX / Angel Pitch</option>
                    <option value="custom" data-desc="Custom: Define your own level names">âœï¸ Custom Names</option>
                </select>
            </div>

            <div class="control-section" id="sort-section" style="display: none; margin-right: 4px;">
                <label for="pattern-sort-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>ðŸ“‹</span>
                    <select id="pattern-sort-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 120px; font-size: 12px;" title="Sort tree items by specific metrics. When linked (ðŸ”—), also clusters Canvas view.">
                        <option value="">Sort By</option>
                    </select>
                </label>
                <button class="btn" id="sort-cluster-link-btn" style="padding: 4px 8px; font-size: 12px; opacity: 0.8;" title="Click to unlink Sort from Canvas Cluster. When linked, changing Sort also changes Canvas clustering.">ðŸ”—</button>
                <button class="btn" id="reset-sort-btn" style="display: none; padding: 4px 8px; font-size: 12px;" title="Reset to default order">â†º</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <button class="btn" id="api-key-btn" title="Configure your Anthropic API key" style="padding: 6px 10px; font-size: 13px;">ðŸ”‘</button>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <label for="unified-ai-mode-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>ðŸ¤–</span>
                    <select id="unified-ai-mode-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 160px; font-size: 12px;" title="Choose AI provider and model">
                        <optgroup label="ðŸ†“ Server (Free - 200/hr)">
                            <option value="server-haiku" title="Fast & cheap - Claude 3 Haiku">âš¡ Haiku 3</option>
                            <option value="server-sonnet" selected title="Best reasoning - Claude Sonnet 4">ðŸ§  Sonnet 4</option>
                        </optgroup>
                        <optgroup label="ðŸ”‘ Claude (Your Key)">
                            <option value="user-haiku" title="Fast - Claude 3.5 Haiku">âš¡ Haiku 3.5</option>
                            <option value="user-sonnet" title="Best reasoning - Claude Sonnet 4">ðŸ§  Sonnet 4</option>
                            <option value="user-opus" title="Most capable - Claude Opus 4">ðŸ‘‘ Opus 4</option>
                            <option value="user-opus45" title="Frontier - Claude Opus 4.5">ðŸŒŸ Opus 4.5</option>
                        </optgroup>
                        <optgroup label="ðŸ”· Gemini (Your Key)">
                            <option value="user-gemini-flash" title="Fast - Gemini 2.5 Flash (Stable)">âš¡ Flash 2.5</option>
                            <option value="user-gemini-pro" title="Best reasoning - Gemini 2.5 Pro (Stable)">ðŸ§  Pro 2.5</option>
                            <option value="user-gemini-3-pro" title="Frontier - Gemini 3 Pro Preview (Nov 2025)">ðŸŒŸ Pro 3 Preview</option>
                        </optgroup>
                        <optgroup label="ðŸ’¬ OpenAI (Your Key)">
                            <option value="user-gpt52-pro" title="Most Accurate - GPT-5.2 Pro (Dec 2025)">ðŸ‘‘ GPT-5.2 Pro</option>
                            <option value="user-gpt52" title="Flagship - GPT-5.2 (Dec 2025)">ðŸŒŸ GPT-5.2</option>
                            <option value="user-gpt52-chat" title="ChatGPT Model - GPT-5.2 Chat">ðŸ’¬ GPT-5.2 Chat</option>
                            <option value="user-gpt5-mini" title="Fast - GPT-5 Mini">âš¡ GPT-5 mini</option>
                            <option value="user-o4-mini" title="Fast reasoning - o4-mini">ðŸ”® o4-mini</option>
                            <option value="user-o3" title="Best reasoning - o3">ðŸ”® o3</option>
                            <option value="user-gpt5" title="Previous Gen - GPT-5">ðŸ§  GPT-5</option>
                            <option value="user-gpt4o" title="Legacy - GPT-4o">ðŸ“¦ GPT-4o</option>
                        </optgroup>
                        <optgroup label="Disable">
                            <option value="off">âŒ Off</option>
                        </optgroup>
                    </select>
                </label>
            </div>

            <div class="control-section" style="margin-right: 4px;">
                <label for="theme-select" style="display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--text-secondary);">
                    <span>ðŸŽ¨</span>
                    <select id="theme-select" class="btn" style="padding: 6px 8px; cursor: pointer; font-weight: 600; min-width: 100px; font-size: 12px;" title="Choose visual theme">
                        <option value="default">ðŸŒ™ Default</option>
                        <option value="steampunk">âš™ï¸ Steampunk</option>
                        <option value="powerpuff">ðŸ’— Powerpuff</option>
                        <option value="tron">ðŸ’  Tron</option>
                    </select>
                </label>
            </div>

            <div class="control-section" style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                <button class="btn" id="how-to-btn" title="How to use TreeListy" style="padding: 6px 10px; font-size: 13px;">â“</button>
                <div id="version-display" style="font-size: 10px; color: var(--text-secondary); opacity: 0.7; white-space: nowrap;">
                    <!-- Populated by TREELISTY_VERSION -->
                </div>
            </div>
        </div>
    </div>

    <!-- Tree View Container -->
    <div class="tree-view-container">

    <!-- Empty State CTA (shown when tree is default/empty) -->
    <div id="empty-state-cta" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 10; padding: 40px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 16px; max-width: 500px;">
        <div style="font-size: 48px; margin-bottom: 16px;">ðŸš€</div>
        <h2 style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">Get Started</h2>
        <p style="font-size: 14px; color: var(--text-secondary); margin-bottom: 24px; line-height: 1.6;">
            Paste any text, document, or prompt and AI will structure it into a tree for you.
        </p>
        <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
            <button class="btn" id="empty-state-import-btn" style="background: linear-gradient(135deg, #8b5cf6, #6366f1); padding: 12px 24px; font-size: 15px; font-weight: 600; color: white; border-radius: 8px;">
                ðŸ“¥ Import Text
            </button>
            <button class="btn" id="empty-state-chat-btn" style="background: linear-gradient(135deg, #10b981, #059669); padding: 12px 24px; font-size: 15px; font-weight: 600; color: white; border-radius: 8px;">
                ðŸ’¬ Chat Builder
            </button>
        </div>
        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 16px; opacity: 0.7;">
            Or use the sidebar tools on the left â†’
        </p>
    </div>

    <!-- Tree -->
    <div class="tree-container" id="tree-container">
        <div class="tree-transform-wrapper" id="tree-transform-wrapper">
            <svg class="dependency-svg" id="dependency-svg"></svg>
            <div class="tree" id="tree-root"></div>
        </div>
    </div>

    </div><!-- /tree-view-container -->

    <!-- Info Panel -->
    <div class="info-panel" id="info-panel">
        <div class="info-header">
            <!-- BUILD 411: Reader Navigation bar -->
            <div class="reader-nav" id="reader-nav" style="display: none;">
                <button class="reader-nav-btn" id="reader-prev" title="Previous node (â†)">â—€</button>
                <button class="reader-nav-btn" id="reader-next" title="Next node (â†’)">â–¶</button>
                <span class="reader-position" id="reader-position">1 of 1</span>
                <button class="reader-mode-btn" id="reader-mode-toggle" title="Toggle read mode">ðŸ“–</button>
            </div>
            <div class="info-title" id="info-title">Details</div>
            <button class="close-btn" id="close-info">âœ•</button>
        </div>
        <div class="info-body" id="info-body"></div>
    </div>

    <!-- Context Menu (populated dynamically) -->
    <div class="context-menu" id="context-menu"></div>

    <!-- AI Tools Sidebar (Collapsible) -->
    <div id="ai-tools-panel">
        <button class="btn" data-icon="ðŸ“¥" id="analyze-text-btn" title="Convert text/files into tree structure"><span>Import Text</span></button>
        <button class="btn" data-icon="ðŸ”€" id="merge-branch-btn" title="Paste a collaboration URL to merge changes"><span>Merge Branch</span></button>
        <button class="btn" data-icon="ðŸŽ™ï¸" id="freespeech-btn" onclick="openFreeSpeechModal()" title="Voice capture with psychological pattern analysis"><span>Free Speech</span></button>
        <button class="btn" data-icon="ðŸ’¬" id="wizard-btn" title="Build and edit tree via chat"><span>Chat Builder</span></button>
        <button class="btn" data-icon="ðŸ©º" id="ai-review-btn" title="Check for logic gaps and missing fields"><span>Check Quality</span></button>
        <button class="btn" data-icon="âœ¨" id="auto-enhance-btn" title="Auto-fill details and add subtasks"><span>Smart Expand</span></button>
        <button class="btn" data-icon="ðŸ“¤" id="generate-prompt-btn" title="Export tree as text for other LLMs"><span>Export Prompt</span></button>
        <button class="btn btn-primary" data-icon="ðŸ¤–" id="ai-btn" title="Run pattern-specific analysis"><span>AI Analysis</span></button>

        <div style="flex: 1;"></div>

        <!-- Zoom Controls in Sidebar -->
        <div class="sidebar-zoom-controls">
            <button class="btn" data-icon="+" id="zoom-in" title="Zoom In"><span>Zoom In</span></button>
            <button class="btn" data-icon="âˆ’" id="zoom-out" title="Zoom Out"><span>Zoom Out</span></button>
            <button class="btn" data-icon="âŸ²" id="zoom-reset" title="Reset Zoom"><span>Reset Zoom</span></button>
            <div class="zoom-level-sidebar" id="zoom-level">100%</div>
        </div>

        <button class="btn" data-icon="âš™ï¸" id="ai-settings-btn" title="AI Settings"><span>AI Settings</span></button>
    </div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <div class="modal-header" id="modal-title">Quick Insight</div>
            <div class="modal-body" id="modal-body">
                <div class="spinner"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="modal-close">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="edit-modal">
        <div class="modal-content">
            <div class="modal-header">Edit Item</div>
            <div class="modal-body" id="edit-modal-body"></div>
            <div class="modal-footer">
                <button class="btn" id="edit-cancel">Cancel</button>
                <button class="btn btn-primary" id="edit-save">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Project Settings Modal (Build 260) -->
    <div class="modal" id="project-settings-modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">âš™ï¸ Project Settings</div>
            <div class="modal-body">
                <div class="form-group">
                    <label style="font-weight: 600; margin-bottom: 8px; display: block;">Project Name</label>
                    <input type="text" id="project-name-input" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--item-bg); color: var(--text-primary); font-size: 16px;" />
                </div>

                <div class="form-group" style="margin-top: 20px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: block;">Project Description</label>
                    <textarea id="project-description-input" rows="2" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--item-bg); color: var(--text-primary); font-size: 14px; resize: vertical;" placeholder="Brief description of the project..."></textarea>
                </div>

                <div class="form-group" style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(99, 102, 241, 0.05)); border: 2px solid rgba(139, 92, 246, 0.3); border-radius: 12px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 20px;">ðŸŽ¯</span>
                        AI Specialist Context
                    </label>
                    <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; line-height: 1.5;">
                        Make the AI an expert in your tree's specific domain. This context is injected into all AI prompts for this project.
                    </p>
                    <textarea id="project-specialist-context" rows="4" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--item-bg); color: var(--text-primary); font-size: 14px; resize: vertical; line-height: 1.5;" placeholder="e.g., Expert in French existentialism, particularly Sartre's 'Being and Nothingness', Camus' absurdism, and de Beauvoir's feminist existentialism. Deep knowledge of 20th century continental philosophy."></textarea>
                    <div style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">
                        <strong>Examples:</strong>
                        <ul style="margin: 6px 0 0 16px; padding: 0; line-height: 1.6;">
                            <li>Philosophy: "Specialist in Hegelian dialectics and phenomenology"</li>
                            <li>Sales: "Expert in enterprise SaaS sales to Fortune 500 CFOs"</li>
                            <li>Film: "Cinematographer specializing in noir lighting and Hitchcock techniques"</li>
                        </ul>
                    </div>
                </div>

                <!-- Build 262: Team Management -->
                <div class="form-group" style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(99, 102, 241, 0.05)); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 12px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 20px;">ðŸ‘¥</span>
                        Project Team
                    </label>
                    <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; line-height: 1.5;">
                        Add team members to track contributions. Each person gets a unique badge (initials) for accountability.
                    </p>

                    <!-- Host Section -->
                    <div style="margin-bottom: 16px;">
                        <div style="font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">ðŸ‘‘ Host (Owner)</div>
                        <div id="project-host-display" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 8px;">
                            <span id="host-badge" style="width: 28px; height: 28px; background: linear-gradient(135deg, #ffc107, #ff9800); color: #000; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 11px;"></span>
                            <span id="host-name" style="flex: 1;"></span>
                            <span id="host-email" style="font-size: 11px; color: var(--text-secondary);"></span>
                        </div>
                    </div>

                    <!-- Add New Member -->
                    <div style="margin-bottom: 16px; padding: 12px; background: var(--bg); border-radius: 8px; border: 1px dashed var(--border);">
                        <div style="font-size: 12px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">âž• Add Team Member</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <input type="text" id="new-member-name" placeholder="Name" style="flex: 1; min-width: 120px; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--item-bg); color: var(--text-primary); font-size: 13px;" />
                            <input type="email" id="new-member-email" placeholder="Email" style="flex: 2; min-width: 180px; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--item-bg); color: var(--text-primary); font-size: 13px;" />
                            <select id="new-member-role" style="padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--item-bg); color: var(--text-primary); font-size: 13px;">
                                <option value="contributor">Contributor</option>
                                <option value="collaborator">Collaborator</option>
                            </select>
                            <button type="button" onclick="addTeamMember()" style="padding: 8px 16px; background: var(--treeplex-primary); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500;">Add</button>
                        </div>
                        <div style="margin-top: 8px; font-size: 11px; color: var(--text-secondary);">
                            <strong>Contributor:</strong> Can edit assigned items â€¢ <strong>Collaborator:</strong> Full edit access
                        </div>
                    </div>

                    <!-- Team List -->
                    <div id="project-team-list" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- Dynamically populated -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="project-settings-cancel">Cancel</button>
                <button class="btn btn-primary" id="project-settings-save">ðŸ’¾ Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Analysis Mode Modal -->
    <div class="modal" id="analysis-modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">ðŸ” Analysis Mode - Convert Text to Tree Structure</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Upload a text file or paste content below. AI will analyze it, detect the best pattern, and convert it into a hierarchical tree structure.
                    </p>
                </div>

                <!-- Analysis Mode Selection (moved to top) -->
                <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                    <div id="current-ai-mode-display" style="padding: 16px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 8px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <div style="font-weight: 600; color: var(--text-primary);">
                                AI Mode: <span id="analyze-mode-label">âš¡ Quick</span>
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                Change mode in header
                            </div>
                        </div>
                        <div id="analyze-mode-description" style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                            Fast pattern detection + basic structure. Recommended for most uses.
                        </div>
                        <div style="margin-top: 12px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                            <strong style="color: var(--text-primary);">ðŸ’¡ Tip:</strong> Change AI mode in the header (ðŸ¤– AI Mode dropdown) to switch between Quick, Deep, or Off.
                        </div>
                    </div>
                </div>

                <!-- Pattern Selection -->
                <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        ðŸ“ Pattern Selection
                    </label>
                    <select id="analysis-pattern-select" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: #1a1a2e; color: #ffffff; font-size: 14px; cursor: pointer;">
                        <option value="auto" style="background: #1a1a2e; color: #ffffff;">ðŸ¤– Auto-detect (AI chooses best pattern)</option>
                        <option value="generic" style="background: #1a1a2e; color: #ffffff;">ðŸ“¦ Generic Project - Universal structure</option>
                        <option value="sales" style="background: #1a1a2e; color: #ffffff;">ðŸ’¼ Sales Pipeline - Deal tracking</option>
                        <option value="thesis" style="background: #1a1a2e; color: #ffffff;">ðŸ“š Academic Writing - Research papers</option>
                        <option value="roadmap" style="background: #1a1a2e; color: #ffffff;">ðŸ—ºï¸ Product Roadmap - Feature timeline</option>
                        <option value="book" style="background: #1a1a2e; color: #ffffff;">ðŸ“– Book Writing - Narrative structure</option>
                        <option value="event" style="background: #1a1a2e; color: #ffffff;">ðŸŽ‰ Event Planning - Event logistics</option>
                        <option value="fitness" style="background: #1a1a2e; color: #ffffff;">ðŸ’ª Fitness Program - Workout plans</option>
                        <option value="strategy" style="background: #1a1a2e; color: #ffffff;">ðŸŽ¯ Strategic Plan - Business initiatives</option>
                        <option value="course" style="background: #1a1a2e; color: #ffffff;">ðŸŽ“ Course Design - Curriculum structure</option>
                        <option value="film" style="background: #1a1a2e; color: #ffffff;">ðŸŽ¬ Film Production - Video workflow</option>
                        <option value="veo3" style="background: #1a1a2e; color: #ffffff;">ðŸŽ¥ Veo3 (Google) - Ingredient/Frame-based video</option>
                        <option value="sora2" style="background: #1a1a2e; color: #ffffff;">ðŸŽ¬ Sora2 (OpenAI) - Cameo/Beat-based video</option>
                        <option value="philosophy" style="background: #1a1a2e; color: #ffffff;">ðŸ¤” Philosophy - Arguments & treatises</option>
                        <option value="prompting" style="background: #1a1a2e; color: #ffffff;">ðŸ§  Prompt Engineering - AI prompts</option>
                        <option value="familytree" style="background: #1a1a2e; color: #ffffff;">ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family Tree - Genealogy</option>
                        <option value="lifetree" style="background: #1a1a2e; color: #ffffff;">ðŸŒ³ LifeTree - Biographical timeline</option>
                        <option value="dialogue" style="background: #1a1a2e; color: #ffffff;">ðŸ’¬ Dialogue & Rhetoric - Debate analysis</option>
                        <option value="capex" style="background: #1a1a2e; color: #ffffff;">ðŸ’° CAPEX / Angel Pitch - Investor-ready</option>
                        <option value="filesystem" style="background: #1a1a2e; color: #ffffff;">ðŸ’¾ File System - File organization</option>
                    </select>
                    <div style="margin-top: 8px; padding: 10px; background: rgba(99, 102, 241, 0.1); border-radius: 4px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                        <strong style="color: var(--text-primary);">ðŸ’¡ Tip:</strong> Auto-detect lets AI analyze your text and recommend the best pattern. Or choose a specific pattern if you know what structure you want.
                    </div>
                </div>

                <!-- File Upload Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        ðŸ“ Upload File (.txt, .md)
                    </label>
                    <div id="file-drop-zone" style="border: 2px dashed var(--border); border-radius: 8px; padding: 32px; text-align: center; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s;">
                        <div style="font-size: 48px; margin-bottom: 12px;">ðŸ“„</div>
                        <div style="color: var(--text-primary); font-weight: 500; margin-bottom: 4px;">
                            Drop file here or click to browse
                        </div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            Supports .txt and .md files (max 100KB recommended)
                        </div>
                        <input type="file" id="analysis-file-input" accept=".txt,.md" style="display: none;" />
                    </div>
                    <div id="file-name-display" style="margin-top: 8px; color: var(--text-secondary); font-size: 13px; display: none;">
                        Selected: <span id="selected-file-name" style="color: var(--treeplex-primary); font-weight: 500;"></span>
                        <button id="clear-file-btn" style="margin-left: 8px; color: var(--text-secondary); background: none; border: none; cursor: pointer; font-size: 13px;">[Clear]</button>
                    </div>
                </div>

                <div style="text-align: center; margin: 16px 0; color: var(--text-secondary); font-size: 13px; font-weight: 600;">
                    â€” OR â€”
                </div>

                <!-- Paste Text Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        ðŸ“ Paste Text
                    </label>
                    <textarea id="analysis-text-input" placeholder="Paste your text content here...

Example:
- Meeting notes
- Project outline
- Research paper
- Strategic plan
- Event agenda
- Course syllabus

The AI will analyze the structure and convert it to a tree."
                        style="width: 100%; min-height: 200px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: 'Inter', monospace; font-size: 13px; resize: vertical;"></textarea>
                    <div id="char-count" style="margin-top: 6px; text-align: right; color: var(--text-secondary); font-size: 12px;">
                        0 characters
                    </div>
                </div>

                <!-- Warning Display -->
                <div id="analysis-warning" style="display: none; padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px; margin-bottom: 16px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">âš ï¸ Large File Warning</div>
                    <div id="analysis-warning-text" style="color: var(--text-secondary); font-size: 13px;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="analysis-cancel">Cancel</button>
                <button class="btn btn-primary" id="analysis-start-btn" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">ðŸ” Analyze</button>
            </div>
        </div>
    </div>

    <!-- API Key Configuration Modal -->
    <div class="modal" id="api-key-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">ðŸ”‘ AI Provider Configuration</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 16px;">
                        Configure your AI provider and API keys. You can use Claude, Gemini, ChatGPT, or all three.
                    </p>
                </div>

                <!-- Provider Selection -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        Primary AI Provider
                    </label>
                    <select id="provider-select" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 14px; cursor: pointer;">
                        <option value="anthropic">ðŸ¤– Anthropic Claude (Sonnet 4) - Best reasoning</option>
                        <option value="gemini">ðŸ”· Google Gemini (2.0 Flash) - Fast & cost-effective</option>
                        <option value="openai">ðŸ’¬ OpenAI ChatGPT (GPT-4o) - Versatile & popular</option>
                    </select>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 6px; line-height: 1.4;">
                        <strong>Cost comparison:</strong> Claude ~$3/1M input, $15/1M output | Gemini Free tier, then ~$0.075/1M | ChatGPT ~$2.50/1M input, $10/1M output
                    </div>
                </div>

                <!-- Claude API Key Section -->
                <div id="claude-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(99, 102, 241, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">ðŸ¤– Anthropic Claude API Key</div>
                        <div id="claude-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: var(--treeplex-primary); font-size: 13px; font-weight: 500;">ðŸ’¡ How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://console.anthropic.com/" target="_blank" style="color: var(--treeplex-primary);">console.anthropic.com</a></li>
                            <li>Sign up or log in to your account</li>
                            <li>Go to API Keys section</li>
                            <li>Create a new API key</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="claude-api-key-input" placeholder="sk-ant-..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <!-- Gemini API Key Section -->
                <div id="gemini-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(66, 133, 244, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">ðŸ”· Google Gemini API Key</div>
                        <div id="gemini-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: #4285f4; font-size: 13px; font-weight: 500;">ðŸ’¡ How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: #4285f4;">aistudio.google.com/app/apikey</a></li>
                            <li>Sign in with your Google account</li>
                            <li>Create a new API key</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="gemini-api-key-input" placeholder="AIzaSy..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <!-- OpenAI API Key Section -->
                <div id="openai-key-section" style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: rgba(16, 163, 127, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text-primary);">ðŸ’¬ OpenAI ChatGPT API Key</div>
                        <div id="openai-key-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></div>
                    </div>

                    <details style="margin-bottom: 12px;">
                        <summary style="cursor: pointer; color: #10a37f; font-size: 13px; font-weight: 500;">ðŸ’¡ How to get an API key</summary>
                        <ol style="color: var(--text-secondary); font-size: 12px; margin: 8px 0; padding-left: 20px; line-height: 1.6;">
                            <li>Visit <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #10a37f;">platform.openai.com/api-keys</a></li>
                            <li>Sign up or log in to your account</li>
                            <li>Click "Create new secret key"</li>
                            <li>Copy and paste it below</li>
                        </ol>
                    </details>

                    <input type="password" id="openai-api-key-input" placeholder="sk-proj-..."
                        style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 13px;" />
                </div>

                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                    <input type="checkbox" id="api-key-show" style="cursor: pointer;" />
                    <label for="api-key-show" style="font-size: 13px; color: var(--text-secondary); cursor: pointer;">Show API keys</label>
                </div>

                <div style="padding: 12px 16px; background: rgba(255, 159, 67, 0.1); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px;">
                    <div style="color: #ff9f43; font-weight: 600; margin-bottom: 4px;">ðŸ”’ Security & Storage</div>
                    <div style="color: var(--text-secondary); font-size: 12px; line-height: 1.5;">
                        Your API keys are stored locally in your browser's localStorage and persist across sessions. Keys are never sent to any server except the respective AI provider's API (Anthropic, Google, or OpenAI).
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="api-key-cancel">Cancel</button>
                <button class="btn" id="api-key-clear" style="margin-right: auto; background: rgba(239, 68, 68, 0.1); color: #ef4444;">ðŸ—‘ï¸ Clear All Keys</button>
                <button class="btn btn-primary" id="api-key-save" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Save & Continue</button>
            </div>
        </div>
    </div>

    <!-- AI Settings Modal -->
    <div id="ai-settings-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid rgba(255,255,255,0.1);">
                <h2 style="margin: 0; font-size: 22px; display: flex; align-items: center; gap: 10px;">
                    <span>âš™ï¸</span> AI Settings
                    <span style="font-size: 13px; font-weight: 400; color: rgba(255,255,255,0.5); margin-left: 10px;">Tune Your AI Persona</span>
                </h2>
                <button onclick="closeAISettingsModal()" style="background: none; border: none; color: rgba(255,255,255,0.6); font-size: 28px; cursor: pointer; padding: 0; line-height: 1;">&times;</button>
            </div>

            <!-- Tone Section -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ðŸŽ­ Tone & Persona
                </label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="neutral" checked>
                        <span class="radio-label">
                            <strong>âš–ï¸ Neutral</strong>
                            <small>Professional, balanced, objective</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="critical">
                        <span class="radio-label">
                            <strong>ðŸ” Critical</strong>
                            <small>Red team, skeptical, finds flaws</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="enthusiastic">
                        <span class="radio-label">
                            <strong>ðŸš€ Enthusiastic</strong>
                            <small>Encouraging, optimistic, opportunity-focused</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-tone" value="socratic">
                        <span class="radio-label">
                            <strong>â“ Socratic</strong>
                            <small>Asks questions, guides discovery</small>
                        </span>
                    </label>
                </div>
            </div>

            <!-- Verbosity Section -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ðŸ“ Output Style
                </label>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-verbosity" value="concise" checked>
                        <span class="radio-label">
                            <strong>âš¡ Concise</strong>
                            <small>Brief, bullet points</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-verbosity" value="balanced">
                        <span class="radio-label">
                            <strong>ðŸ“Š Balanced</strong>
                            <small>Clear paragraphs</small>
                        </span>
                    </label>
                    <label class="ai-radio-option">
                        <input type="radio" name="ai-verbosity" value="verbose">
                        <span class="radio-label">
                            <strong>ðŸ“š Verbose</strong>
                            <small>Detailed, thorough</small>
                        </span>
                    </label>
                </div>
            </div>

            <!-- Creativity Slider -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ðŸŒ¡ï¸ Creativity Level
                    <span id="creativity-value" style="color: #6366f1; margin-left: 8px;">0.5</span>
                </label>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <span style="font-size: 12px; color: rgba(255,255,255,0.5);">Consistent</span>
                    <input type="range" id="creativity-slider" min="0" max="100" value="50" style="flex: 1;">
                    <span style="font-size: 12px; color: rgba(255,255,255,0.5);">Creative</span>
                </div>
                <p style="font-size: 12px; color: rgba(255,255,255,0.4); margin-top: 8px; margin-bottom: 0;">
                    Lower values (0.0-0.3): Deterministic, factual tasks. Higher values (0.7-1.0): Creative writing, brainstorming.
                </p>
            </div>

            <!-- Custom Instructions -->
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    âœï¸ Custom Instructions <span style="font-weight: 400; color: rgba(255,255,255,0.5);">(Optional Override)</span>
                </label>
                <textarea id="custom-instructions" rows="4" style="width: 100%; padding: 12px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-family: 'SF Mono', Monaco, monospace; font-size: 13px; resize: vertical;" placeholder="Examples:
â€¢ 'Always include code examples in TypeScript'
â€¢ 'Assume I'm a beginner - explain concepts simply'
â€¢ 'Be extremely detailed about security implications'
â€¢ 'Focus on cost optimization strategies'"></textarea>
                <p style="font-size: 12px; color: rgba(255,255,255,0.4); margin-top: 8px; margin-bottom: 0;">
                    ðŸ’¡ These instructions override all other settings. The AI will prioritize this guidance above all else.
                </p>
            </div>

            <!-- Dialectic Mode Toggle (Cognitive Citadel) -->
            <div style="margin-bottom: 25px; padding: 15px; background: rgba(220, 38, 38, 0.1); border: 1px solid rgba(220, 38, 38, 0.3); border-radius: 8px;">
                <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
                    <input type="checkbox" id="ai-dialectic-mode" style="width: 18px; height: 18px; accent-color: #EF4444; margin-top: 2px;">
                    <div>
                        <strong style="color: #EF4444;">ðŸ›¡ï¸ Dialectic Mode</strong>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-top: 4px;">
                            Forces AI to identify assumptions and counter-arguments <em>before</em> helping.
                            Breaks the agreement echo chamber.
                        </div>
                    </div>
                </label>
            </div>

            <!-- BUILD 396: Chat UI Style Toggle -->
            <div style="margin-bottom: 25px; padding: 15px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px;">
                <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
                    <input type="checkbox" id="use-classic-chat" style="width: 18px; height: 18px; accent-color: #6366f1; margin-top: 2px;">
                    <div>
                        <strong style="color: #a5b4fc;">ðŸ’¬ Use Classic Chat Panel</strong>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-top: 4px;">
                            Switch to the traditional slide-out panel instead of the new floating command frame.
                            <br><span style="color: rgba(255,255,255,0.5);">Keyboard shortcut: Ctrl+/ or Cmd+/</span>
                        </div>
                    </div>
                </label>
            </div>

            <!-- Live Preview -->
            <div style="margin-bottom: 25px; padding: 15px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 600; font-size: 14px; color: rgba(255,255,255,0.9);">
                    ðŸ‘ï¸ Live Preview
                </label>
                <div style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
                    <strong>Before (Base Prompt):</strong>
                </div>
                <div style="padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: rgba(255,255,255,0.5); margin-bottom: 12px;">
                    You are an expert project manager specializing in breaking down complex tasks...
                </div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
                    <strong>After (With Your Settings):</strong>
                </div>
                <div id="preview-after" style="padding: 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: rgba(255,255,255,0.8); white-space: pre-wrap;">You are an expert project manager specializing in breaking down complex tasks...</div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; gap: 10px; justify-content: flex-end; padding-top: 15px; border-top: 2px solid rgba(255,255,255,0.1);">
                <button onclick="resetAISettings()" class="btn" style="padding: 10px 20px; background: rgba(255,255,255,0.05);">
                    ðŸ”„ Reset to Defaults
                </button>
                <button onclick="closeAISettingsModal()" class="btn" style="padding: 10px 20px;">
                    Cancel
                </button>
                <button onclick="saveAISettings()" class="btn btn-primary" style="padding: 10px 20px; background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);">
                    ðŸ’¾ Save Settings
                </button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div class="modal" id="share-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">ðŸ“¤ Share Your Project</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 15px;">
                        Share this link with anyone! The link contains your entire project data (no server storage).
                    </p>
                    <div style="background: var(--card-bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 15px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="share-url-input" readonly
                                   style="flex: 1; background: var(--card-bg); border: 1px solid var(--border); color: var(--text-primary); padding: 10px; border-radius: 6px; font-family: monospace; font-size: 12px; user-select: all;"
                                   value="">
                            <button class="btn btn-primary" id="copy-share-url" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); white-space: nowrap;">
                                ðŸ“‹ Copy
                            </button>
                        </div>
                    </div>
                    <div id="share-stats" style="display: flex; gap: 20px; font-size: 13px; color: var(--text-secondary);">
                        <div>ðŸ“Š <span id="share-node-count">0</span> nodes</div>
                        <div>ðŸ“ <span id="share-url-length">0</span> characters</div>
                        <div id="share-size-warning" style="display: none; color: #f59e0b;">âš ï¸ Large project - URL may not work in all apps</div>
                    </div>
                </div>
                <div style="background: var(--card-bg); padding: 15px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                    <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span>â„¹ï¸</span> How it works
                    </div>
                    <ul style="margin-left: 20px; color: var(--text-secondary); font-size: 14px; line-height: 1.6;">
                        <li>Your data is compressed and embedded in the URL (not stored on any server)</li>
                        <li>Anyone with the link can view and edit their own copy</li>
                        <li>Works best for projects with up to 40-50 nodes</li>
                        <li>For larger projects, use "ðŸ’¾ Save" to download JSON instead</li>
                    </ul>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="share-close">Close</button>
                <button class="btn btn-primary" id="open-share-url" style="background: linear-gradient(135deg, #3B8FCC, #2B7AB8);">
                    ðŸ”— Open in New Tab
                </button>
            </div>
        </div>
    </div>

    <!-- Share Branch Modal (Collaboration) -->
    <div class="modal" id="share-branch-modal" style="display: none;">
        <div class="modal-content" style="max-width: 750px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #10b981, #059669); color: white;">
                ðŸ¤ Share for Collaboration
            </div>
            <div class="modal-body" id="share-branch-body">
                <!-- Populated dynamically by showShareBranchModal() -->
            </div>
            <div class="modal-footer">
                <button class="btn" id="share-branch-close">Close</button>
                <button class="btn" id="share-branch-copy" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">
                    ðŸ“‹ Copy URL
                </button>
                <button class="btn" id="share-branch-copy-email" style="background: linear-gradient(135deg, #f59e0b, #d97706);">
                    ðŸ“§ Copy Email
                </button>
                <button class="btn btn-primary" id="share-branch-email" style="background: linear-gradient(135deg, #10b981, #059669);">
                    âœ‰ï¸ Open Email App
                </button>
            </div>
        </div>
    </div>

    <!-- Merge Branch Modal (Collaboration - receiving edited branches) -->
    <div class="modal" id="merge-branch-modal" style="display: none;">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white;">
                ðŸ”€ Merge Collaboration Changes
            </div>
            <div class="modal-body" id="merge-branch-body">
                <!-- Populated dynamically by showMergeBranchModal() -->
            </div>
            <div class="modal-footer">
                <button class="btn" id="merge-branch-cancel">Cancel</button>
                <button class="btn btn-primary" id="merge-branch-accept" style="background: linear-gradient(135deg, #10b981, #059669);">
                    âœ… Accept & Merge Changes
                </button>
            </div>
        </div>
    </div>

    <!-- Branch Editing Banner (shown when editing a shared branch) -->
    <div id="branch-edit-banner" style="display: none; position: fixed; top: 60px; left: 0; right: 0; z-index: 1000; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; padding: 12px 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);">
        <div style="display: flex; align-items: center; justify-content: space-between; max-width: 1400px; margin: 0 auto;">
            <div style="display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px;">ðŸ¤</span>
                <div>
                    <div style="font-weight: 600; font-size: 14px;">Editing Shared Branch</div>
                    <div id="branch-edit-info" style="font-size: 12px; opacity: 0.9;">From: Project Name</div>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="branch-share-back-btn" class="btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);">
                    ðŸ“¤ Share Back
                </button>
                <button id="branch-exit-btn" class="btn" style="background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);">
                    âœ– Exit
                </button>
            </div>
        </div>
    </div>

    <!-- Paste Branch URL Modal -->
    <div class="modal" id="paste-branch-modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white;">
                ðŸ”€ Merge Collaboration Branch
            </div>
            <div class="modal-body">
                <p style="color: var(--text-secondary); margin-bottom: 16px;">
                    Paste a collaboration URL you received from a collaborator to merge their changes into your project.
                </p>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Branch URL:</label>
                    <textarea id="paste-branch-url-input"
                              placeholder="Paste the full URL here (starts with https://treelisty.netlify.app?branch=...)"
                              style="width: 100%; height: 120px; background: var(--card-bg); border: 2px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 6px; font-family: monospace; font-size: 11px; resize: vertical;"></textarea>
                </div>
                <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 12px; border-radius: 6px; border-left: 3px solid #6366f1;">
                    <p style="color: var(--text-secondary); font-size: 12px; margin: 0;">
                        <strong>Tip:</strong> Make sure your original project is loaded before merging. The system will check if the projects match.
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="paste-branch-cancel">Cancel</button>
                <button class="btn btn-primary" id="paste-branch-merge" style="background: linear-gradient(135deg, #10b981, #059669);">
                    ðŸ”€ Parse & Merge
                </button>
            </div>
        </div>
    </div>

    <!-- Free Speech Recording Modal -->
    <div class="modal" id="freespeech-modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%); border: 1px solid rgba(99, 102, 241, 0.3);">
            <div class="modal-header" style="border-bottom: 1px solid rgba(99, 102, 241, 0.2);">
                <h3 style="color: #e2e8f0;">ðŸŽ™ï¸ Free Speech Session</h3>
                <button class="modal-close" onclick="closeFreeSpeechModal()">&times;</button>
            </div>
            <div class="modal-body" id="freespeech-modal-body" style="padding: 24px; text-align: center;">
                <!-- IDLE State -->
                <div id="freespeech-idle" style="display: block;">
                    <div style="font-size: 64px; margin-bottom: 16px;">ðŸŽ™ï¸</div>
                    <h4 style="color: #e2e8f0; margin-bottom: 12px;">Speak Without Thinking</h4>
                    <p style="color: #94a3b8; font-size: 14px; line-height: 1.6; margin-bottom: 24px;">
                        Let your thoughts flow freely. No judgment, no editing.<br>
                        AI will find surprising patterns in your words.
                    </p>
                    <div style="background: rgba(99, 102, 241, 0.1); padding: 16px; border-radius: 12px; margin-bottom: 24px; border: 1px solid rgba(99, 102, 241, 0.2);">
                        <div style="font-size: 12px; color: #94a3b8; text-align: left;">
                            <div style="margin-bottom: 8px;">âœ¨ <strong>Tips for best results:</strong></div>
                            <div style="margin-left: 16px;">â€¢ Speak as if thinking out loud</div>
                            <div style="margin-left: 16px;">â€¢ Don't censor yourself</div>
                            <div style="margin-left: 16px;">â€¢ Silences are okay - take your time</div>
                            <div style="margin-left: 16px;">â€¢ Your words are private until analyzed</div>
                        </div>
                    </div>
                    <button onclick="startFreeSpeechWarmup()" style="width: 100%; padding: 16px 24px; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; border: none; border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                        ðŸŽ¤ Begin Recording
                    </button>
                </div>

                <!-- WARMUP State (3-second countdown) -->
                <div id="freespeech-warmup" style="display: none;">
                    <div id="freespeech-countdown" style="font-size: 120px; color: #6366f1; font-weight: bold; animation: pulse 1s infinite;">3</div>
                    <p style="color: #94a3b8; font-size: 16px;">Take a breath...</p>
                </div>

                <!-- RECORDING State -->
                <div id="freespeech-recording" style="display: none;">
                    <!-- Breathing Circle Visualization -->
                    <div id="freespeech-visualizer" style="width: 200px; height: 200px; margin: 0 auto 24px; position: relative;">
                        <div id="freespeech-circle" style="width: 100%; height: 100%; border-radius: 50%; background: radial-gradient(circle, rgba(99, 102, 241, 0.4) 0%, rgba(99, 102, 241, 0.1) 70%, transparent 100%); animation: breathe 4s ease-in-out infinite;"></div>
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 48px;">ðŸŽ™ï¸</div>
                    </div>

                    <!-- Nudge Display (shows gentle prompts) -->
                    <div id="freespeech-nudge" style="min-height: 32px; font-size: 18px; color: #94a3b8; font-style: italic; margin-bottom: 24px;"></div>

                    <!-- Recording Status -->
                    <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 24px;">
                        <div style="width: 12px; height: 12px; background: #ef4444; border-radius: 50%; animation: blink 1s infinite;"></div>
                        <span style="color: #ef4444; font-weight: 600;">Recording...</span>
                    </div>

                    <button onclick="stopFreeSpeechRecording()" style="width: 100%; padding: 16px 24px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer;">
                        âœ“ I'm Done
                    </button>
                </div>

                <!-- PROCESSING State -->
                <div id="freespeech-processing" style="display: none;">
                    <div style="font-size: 64px; margin-bottom: 16px; animation: spin 2s linear infinite;">ðŸ”®</div>
                    <h4 style="color: #e2e8f0; margin-bottom: 12px;">Finding Hidden Patterns...</h4>
                    <p style="color: #94a3b8; font-size: 14px;">AI is analyzing your stream of consciousness</p>
                    <div style="margin-top: 24px;">
                        <div style="height: 4px; background: rgba(99, 102, 241, 0.2); border-radius: 2px; overflow: hidden;">
                            <div id="freespeech-progress" style="height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6); width: 0%; transition: width 0.5s ease;"></div>
                        </div>
                    </div>
                </div>

                <!-- ERROR State -->
                <div id="freespeech-error" style="display: none;">
                    <div style="font-size: 64px; margin-bottom: 16px;">âš ï¸</div>
                    <h4 style="color: #ef4444; margin-bottom: 12px;">Recording Issue</h4>
                    <p id="freespeech-error-message" style="color: #94a3b8; font-size: 14px; margin-bottom: 24px;">Speech recognition is not supported in this browser.</p>
                    <button onclick="resetFreeSpeechModal()" style="padding: 12px 24px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); cursor: pointer;">
                        Try Again
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Free Speech CSS Animations -->
    <style>
        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.15); opacity: 1; }
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        #freespeech-modal .modal-content {
            animation: fadeInScale 0.3s ease-out;
        }
        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>

    <!-- Wizard Modal -->
    <div class="modal" id="wizard-modal" style="display: none; justify-content: flex-end; background: transparent; pointer-events: none;">
        <div class="modal-content" style="width: 550px; max-width: 90vw; height: 100vh; max-height: 100vh; margin: 0; border-radius: 0; animation: slideInRight 0.3s ease-out; pointer-events: auto; box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);">
            <style>
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                    }
                    to {
                        transform: translateX(0);
                    }
                }
        
    /* ===================================================== */
    /* CANVAS VIEW STYLES */
    /* ===================================================== */

    .tree-view-container {
        display: block;
    }

    .tree-view-container.hidden {
        display: none !important;
    }

    .canvas-container {
        display: none;
        position: fixed;
        top: 140px;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        overflow: hidden;
        cursor: grab;
    }

    .canvas-container.active {
        display: block;
    }

    .canvas-container.grabbing {
        cursor: grabbing;
    }

    #canvas {
        width: 100%;
        height: 100%;
        position: relative;
        transform-origin: 0 0;
    }

    .canvas-connections {
        position: absolute;
        top: -5000px;
        left: -5000px;
        width: 20000px;
        height: 20000px;
        pointer-events: none;
        z-index: 1;
        overflow: visible;
    }

    /* Allow pointer events on hyperedge groups and their elements */
    .canvas-connections .hyperedge-group {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections polygon,
    .canvas-connections rect,
    .canvas-connections path.hyperedge-capsule {
        pointer-events: all;
        cursor: pointer;
    }

    .canvas-connections text {
        pointer-events: all;
        cursor: pointer;
    }

    /* Disable on connection lines (but not capsule paths) */
    .canvas-connections path:not(.hyperedge-capsule),
    .canvas-connections line {
        pointer-events: none;
    }

    .canvas-nodes-layer {
        position: relative;
        z-index: 2;
    }

    .canvas-node {
        position: absolute;
        background: var(--card-bg);
        border-radius: 12px;
        padding: 16px;
        min-width: 280px;
        max-width: 320px;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, filter 0.15s ease;
        z-index: 10;
    }

    .canvas-node:hover {
        transform: translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }

    .canvas-node.dragging {
        cursor: grabbing;
        opacity: 0.9;
        z-index: 1000;
        transform: scale(1.05);
    }

    .canvas-node.selected {
        border-color: var(--treeplex-primary) !important;
        box-shadow:
            0 8px 32px rgba(99, 102, 241, 0.4),
            0 4px 16px rgba(99, 102, 241, 0.3),
            0 0 0 3px rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-2px);
    }

    .canvas-node.selected::before {
        content: 'âœ“';
        position: absolute;
        top: -10px;
        right: -10px;
        background: #6366f1;
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .canvas-node.dragging-group {
        opacity: 0.7;
        box-shadow: 0 0 20px rgba(99, 102, 241, 0.8);
    }

    .phase-zone {
        position: absolute;
        border: 3px dashed;
        border-radius: 20px;
        padding: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .phase-zone-header {
        font-weight: 700;
        font-size: 18px;
        margin-bottom: 12px;
        color: var(--text-primary);
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* Colored phase zones - vibrant colors */
    .phase-0 {
        border-color: #3B82F6;
        background: rgba(59, 130, 246, 0.08);
    }
    .phase-1 {
        border-color: #F59E0B;
        background: rgba(245, 158, 11, 0.08);
    }
    .phase-2 {
        border-color: #10B981;
        background: rgba(16, 185, 129, 0.08);
    }
    .phase-3 {
        border-color: #8B5CF6;
        background: rgba(139, 92, 246, 0.08);
    }
    .phase-4 {
        border-color: #EC4899;
        background: rgba(236, 72, 153, 0.08);
    }
    .phase-5 {
        border-color: #06B6D4;
        background: rgba(6, 182, 212, 0.08);
    }

    /* Grid overlay */
    .canvas-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .canvas-grid.active {
        opacity: 1;
    }

    .canvas-toolbar.active {
        display: flex !important;
    }

    .canvas-toolbar button:hover {
        background: rgba(99, 102, 241, 0.3) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .canvas-toolbar button:active {
        transform: translateY(0);
    }

    .canvas-toolbar select:hover {
        background: rgba(99, 102, 241, 0.25) !important;
        border-color: rgba(99, 102, 241, 0.6) !important;
    }

    .canvas-toolbar select option {
        background: #1a1a2e;
        color: #ffffff;
        padding: 10px;
        font-weight: 600;
    }

    .canvas-toolbar select option:hover {
        background: rgba(99, 102, 241, 0.4);
    }

    </style>
            <div class="modal-header">
                <span id="wizard-title">ðŸª„ AI Wizard - Building Your Project</span>
            </div>

            <div style="padding: 15px; background: var(--card-bg-light); border-bottom: 1px solid var(--border);">
                <div style="display: flex; gap: 30px; font-size: 14px; margin-bottom: 10px;">
                    <div>ðŸ“Š Turn: <span id="wizard-question-count" style="color: var(--treeplex-primary); font-weight: 600;">0</span></div>
                    <div>âœ“ Fields: <span id="wizard-fields-complete" style="color: var(--treeplex-primary); font-weight: 600;">0</span>/<span id="wizard-fields-total">10</span> complete</div>
                    <div>ðŸ“ˆ <span id="wizard-progress-percent" style="color: var(--treeplex-primary); font-weight: 600;">0%</span> complete</div>
                    <div id="wizard-completion" style="display: none; color: #10b981; font-weight: 600;">âœ… Ready to Apply!</div>
                </div>
                <!-- Progress Bar -->
                <div style="width: 100%; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden;">
                    <div id="wizard-progress-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--treeplex-primary), #10b981); transition: width 0.5s ease;"></div>
                </div>
            </div>

            <div class="modal-body" style="display: flex; flex-direction: column; padding: 0; height: calc(100vh - 200px); overflow: hidden;">
                <!-- Tip Banner -->
                <div style="padding: 12px 20px; background: linear-gradient(135deg, rgba(163, 85, 247, 0.1), rgba(236, 72, 153, 0.1)); border-bottom: 1px solid var(--border);">
                    <div style="font-size: 12px; color: var(--text-primary); display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 16px;">ðŸ’¡</span>
                        <span>Watch your tree update in real-time on the left as we build it together!</span>
                    </div>
                </div>

                <!-- Chat Area -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <div id="wizard-chat-history" style="flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px;">
                        <!-- Chat messages will appear here -->
                    </div>
                    <div style="padding: 15px 20px; border-top: 1px solid var(--border); display: flex; gap: 10px; background: var(--bg-secondary);">
                        <input type="text" id="wizard-user-input" placeholder="Type your answer here..."
                               style="flex: 1; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 6px; font-size: 14px;"
                               onkeypress="if(event.key==='Enter') document.getElementById('wizard-send').click()">
                        <button class="btn btn-primary" id="wizard-send" style="background: linear-gradient(135deg, #a855f7, #ec4899); padding: 12px 24px; white-space: nowrap;">
                            Send
                        </button>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="wizard-cancel">Cancel</button>
                <button class="btn" id="wizard-auto-enhance" style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; font-weight: 600;" title="Automatically run AI Review then enhance your tree">
                    ðŸ”„ Auto-Enhance
                </button>
                <button class="btn btn-primary" id="wizard-done" style="background: linear-gradient(135deg, #10b981, #059669);">
                    âœ… Finish & Apply
                </button>
            </div>
        </div>
    </div>

    <!-- Generate Prompt Modal -->
    <div class="modal" id="generate-prompt-modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh;">
            <div class="modal-header">
                <span id="generate-prompt-title">ðŸ“ Generated Prompt</span>
            </div>

            <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(85vh - 140px);">
                <div style="margin-bottom: 15px; color: var(--text-secondary); font-size: 13px;">
                    This prompt was generated from your tree structure. Copy and paste it to use with AI systems.
                </div>

                <div style="position: relative;">
                    <textarea id="generated-prompt-text" readonly style="
                        width: 100%;
                        min-height: 400px;
                        padding: 15px;
                        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                        font-size: 13px;
                        line-height: 1.6;
                        border: 1px solid var(--border);
                        border-radius: 8px;
                        background: var(--card-bg);
                        color: var(--text-primary);
                        resize: vertical;
                    "></textarea>

                    <button id="copy-prompt-btn" style="
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        padding: 8px 16px;
                        background: var(--treeplex-primary);
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 600;
                    ">ðŸ“‹ Copy</button>
                </div>

                <div id="copy-success-message" style="
                    margin-top: 10px;
                    padding: 10px;
                    background: #10b981;
                    color: white;
                    border-radius: 6px;
                    text-align: center;
                    display: none;
                ">âœ… Copied to clipboard!</div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-prompt-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- AI Review Modal -->
    <div class="modal" id="ai-review-modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh;">
            <div class="modal-header">
                <span>ðŸ”¬ AI Review & Enhance</span>
            </div>

            <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 140px);">
                <!-- Status area -->
                <div id="ai-review-status" style="margin-bottom: 20px;">
                    <div style="padding: 15px; background: rgba(99, 102, 241, 0.1); border-left: 3px solid #6366f1; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">ðŸ¤– AI is analyzing your tree...</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            Checking for completeness, redundancies, logical flow, and pattern alignment.
                        </div>
                    </div>
                </div>

                <!-- Results area (hidden initially) -->
                <div id="ai-review-results" style="display: none;">
                    <!-- Summary section -->
                    <div style="margin-bottom: 24px; padding: 16px; background: var(--card-bg-light); border-radius: 8px;">
                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: var(--text-primary);">ðŸ“Š Analysis Summary</h3>
                        <div id="ai-review-summary"></div>
                    </div>

                    <!-- Suggestions section -->
                    <div style="margin-bottom: 24px;">
                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: var(--text-primary);">âœ¨ Suggested Improvements</h3>
                        <div id="ai-review-suggestions"></div>
                    </div>

                    <!-- Actions section -->
                    <div style="padding: 16px; background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">ðŸŽ¯ Next Steps</div>
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
                            Review the suggestions above. You can manually apply changes to your tree, or let AI enhance specific areas.
                        </div>
                        <button class="btn" id="ai-review-again" style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white;">
                            ðŸ”„ Re-analyze
                        </button>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-ai-review-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- Search Modal -->
    <div class="modal" id="search-modal" style="display: none;">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh;">
            <div class="modal-header">
                <span>ðŸ” Search Tree</span>
            </div>

            <div class="modal-body" style="padding: 20px;">
                <!-- Search input -->
                <div style="margin-bottom: 20px;">
                    <input type="text" id="search-input" placeholder="Search all fields (name, description, notes, etc.)..."
                        style="width: 100%; padding: 12px 16px; font-size: 15px; border: 2px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); outline: none; transition: border-color 0.2s;">
                    <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                        ðŸ’¡ Tip: Search is case-insensitive and searches all fields in all nodes
                    </div>
                </div>

                <!-- Search results -->
                <div id="search-results-container" style="max-height: calc(90vh - 260px); overflow-y: auto;">
                    <div id="search-results-empty" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                        <div style="font-size: 48px; margin-bottom: 12px;">ðŸ”</div>
                        <div style="font-size: 14px;">Enter a search term to find nodes</div>
                    </div>
                    <div id="search-results" style="display: none;"></div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn" id="close-search-modal">Close</button>
            </div>
        </div>
    </div>

    <!-- PWA Onboarding Modal -->
    <div class="modal" id="pwa-onboarding-modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <span>ðŸŒ³ Welcome to TreeListy!</span>
            </div>

            <div class="modal-body" style="padding: 30px;">
                <!-- Success checkmark -->
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 64px;">âœ…</div>
                    <h2 style="margin: 16px 0 8px; color: var(--text-primary); font-size: 22px;">Tree Loaded Successfully!</h2>
                    <p style="color: var(--text-secondary); font-size: 14px; margin: 0;">You can now explore this project</p>
                </div>

                <!-- Divider -->
                <div style="height: 1px; background: var(--border); margin: 24px 0;"></div>

                <!-- Install prompt -->
                <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); border: 2px solid var(--treeplex-primary); border-radius: 12px; padding: 24px; margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">
                        <div style="font-size: 40px;">ðŸ’¾</div>
                        <div>
                            <h3 style="margin: 0 0 4px; color: var(--text-primary); font-size: 18px;">Want to work with .treelisty files?</h3>
                            <p style="margin: 0; color: var(--text-secondary); font-size: 13px;">Install TreeListy to open files with a double-click!</p>
                        </div>
                    </div>

                    <div style="background: var(--card-bg); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                        <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">âœ¨ Benefits:</div>
                        <ul style="margin: 0; padding-left: 20px; color: var(--text-primary); font-size: 14px; line-height: 1.8;">
                            <li>Open <code style="background: var(--bg); padding: 2px 6px; border-radius: 4px; font-family: monospace;">.treelisty</code> files with a double-click</li>
                            <li>Works offline after installation</li>
                            <li>Access from your app menu/desktop</li>
                            <li>Faster loading and better performance</li>
                        </ul>
                    </div>

                    <!-- Universal Install button - ALWAYS shown -->
                    <button class="btn" id="pwa-install-btn" style="width: 100%; background: linear-gradient(135deg, #6366f1, #8b5cf6); padding: 16px; font-size: 16px; font-weight: 600;">
                        ðŸ“¥ Install TreeListy
                    </button>

                    <!-- Instructions (shown after clicking if manual install needed) -->
                    <div id="pwa-manual-instructions" style="display: none; margin-top: 16px; padding: 16px; background: var(--card-bg-light); border-radius: 8px; border: 2px solid var(--treeplex-primary);">
                        <div style="font-size: 15px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">
                            ðŸ“ Follow these steps:
                        </div>
                        <ol style="margin: 0; padding-left: 24px; color: var(--text-primary); font-size: 14px; line-height: 2;">
                            <li>Look at the <strong>address bar</strong> (top of browser)</li>
                            <li>Find the <strong>install icon</strong> on the right side:
                                <span style="background: var(--bg); padding: 4px 8px; border-radius: 4px; margin-left: 8px;">ðŸ“¥</span> or
                                <span style="background: var(--bg); padding: 4px 8px; border-radius: 4px; margin-left: 4px;">âŠ•</span>
                            </li>
                            <li>Click the icon and select <strong>"Install"</strong></li>
                        </ol>
                        <div style="margin-top: 16px; padding: 12px; background: rgba(234, 179, 8, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                            ðŸ’¡ Don't see the icon? Close this modal and look for it. Still missing? You might need to use Chrome or Edge browser.
                        </div>
                    </div>
                </div>

                <!-- Skip option -->
                <div style="text-align: center;">
                    <button class="btn" id="pwa-skip-btn" style="background: var(--card-bg); color: var(--text-secondary); padding: 10px 20px; font-size: 13px;">
                        Maybe Later
                    </button>
                    <div style="margin-top: 8px; font-size: 11px; color: var(--text-secondary);">
                        You can always install later from the Help menu
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load from Google Drive Modal -->
    <div class="modal" id="load-gdrive-modal" style="display: none;">
        <div class="modal-content" style="max-width: 550px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #4285f4, #34a853);">
                <span>â˜ï¸ Load from Google Drive</span>
                <button class="modal-close" id="load-gdrive-close">&times;</button>
            </div>
            <div class="modal-body" style="padding: 24px;">
                <!-- URL Input Section -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                        Paste Google Drive Share Link
                    </label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="gdrive-url-input" placeholder="https://drive.google.com/file/d/..."
                            style="flex: 1; padding: 12px 16px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
                        <button class="btn" id="gdrive-load-btn" style="background: linear-gradient(135deg, #4285f4, #34a853); padding: 12px 20px; font-weight: 600;">
                            Load
                        </button>
                    </div>
                    <p style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                        Supports: drive.google.com share links or file IDs
                    </p>
                </div>

                <!-- Recent Files Section -->
                <div id="recent-gdrive-section" style="display: none;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <label style="font-size: 14px; font-weight: 600; color: var(--text-primary);">
                            ðŸ“‹ Recent Shared Trees
                        </label>
                        <button class="btn" id="clear-recent-gdrive" style="padding: 4px 10px; font-size: 11px; background: var(--card-bg);">
                            Clear
                        </button>
                    </div>
                    <div id="recent-gdrive-list" style="max-height: 200px; overflow-y: auto;">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Help text -->
                <div style="margin-top: 20px; padding: 16px; background: rgba(66, 133, 244, 0.1); border-radius: 8px; border-left: 3px solid #4285f4;">
                    <p style="margin: 0 0 8px; font-size: 13px; font-weight: 600; color: var(--text-primary);">ðŸ’¡ How to share a TreeListy file:</p>
                    <ol style="margin: 0; padding-left: 20px; font-size: 12px; color: var(--text-secondary); line-height: 1.8;">
                        <li>Save your project as JSON (ðŸ’¾ button)</li>
                        <li>Upload to Google Drive</li>
                        <li>Right-click â†’ Share â†’ "Anyone with the link"</li>
                        <li>Copy link and paste here!</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase Live Sync Modal -->
    <div class="modal" id="live-sync-modal" style="display: none;">
        <div class="modal-content" style="max-width: 520px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #f97316, #ea580c);">
                <span>ðŸ”„ Live Collaboration</span>
                <button class="modal-close" id="live-sync-close" onclick="document.getElementById('live-sync-modal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <!-- NOT CONNECTED STATE -->
                <div id="sync-start-section">
                    <div style="text-align: center; padding: 20px 0;">
                        <div style="font-size: 48px; margin-bottom: 12px;">ðŸ¤</div>
                        <h3 style="margin: 0 0 8px; color: var(--text-primary);">Start Collaborating</h3>
                        <p style="margin: 0 0 20px; font-size: 13px; color: var(--text-secondary);">
                            Work together in real-time with instant sync
                        </p>

                        <button class="btn" id="create-sync-room-btn" onclick="window.createFirebaseSyncRoom()" style="width: 100%; padding: 16px; background: linear-gradient(135deg, #10b981, #059669); font-weight: 600; font-size: 15px; margin-bottom: 12px;">
                            ðŸš€ Start Live Session
                        </button>

                        <!-- BUILD 325: Schedule Meeting Button -->
                        <button class="btn" onclick="window.closeMeetingModal(); window.showMeetingModal(); document.getElementById('live-sync-modal').style.display='none';" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #6366f1, #8b5cf6); font-weight: 600; font-size: 14px; margin-bottom: 16px;">
                            ðŸ“… Schedule Meeting Link
                        </button>

                        <div style="display: flex; align-items: center; gap: 12px; margin: 16px 0;">
                            <div style="flex: 1; height: 1px; background: var(--border);"></div>
                            <span style="font-size: 11px; color: var(--text-secondary);">or join existing</span>
                            <div style="flex: 1; height: 1px; background: var(--border);"></div>
                        </div>

                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="join-room-id" placeholder="Room code (e.g. ABC123)"
                                style="flex: 1; padding: 12px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; font-family: monospace; text-transform: uppercase;">
                            <button class="btn" id="join-sync-room-btn" onclick="window.joinFirebaseSyncRoom(document.getElementById('join-room-id').value)" style="padding: 12px 20px; background: linear-gradient(135deg, #6366f1, #8b5cf6); font-weight: 600;">
                                Join
                            </button>
                        </div>
                    </div>
                </div>

                <!-- CONNECTED STATE -->
                <div id="sync-active-section" style="display: none;">
                    <!-- BUILD 351: Hero Code Display - Easy to read and share -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.15)); padding: 20px; border-radius: 12px; border: 2px solid rgba(16, 185, 129, 0.4); margin-bottom: 16px;">
                        <!-- Status indicator -->
                        <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">
                            <div style="width: 10px; height: 10px; background: #10b981; border-radius: 50%; animation: watchPulse 2s ease-in-out infinite;"></div>
                            <span style="font-weight: 600; color: #10b981; font-size: 14px;">Live Session Active</span>
                        </div>

                        <!-- HERO CODE - Large, centered, easy to read aloud -->
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-secondary); margin-bottom: 8px;">Share this code</div>
                            <div id="active-room-id-display" style="font-family: 'SF Mono', 'Consolas', monospace; font-size: 36px; font-weight: 800; letter-spacing: 8px; color: var(--text-primary); background: var(--bg); padding: 16px 24px; border-radius: 12px; border: 2px dashed var(--border); display: inline-block; min-width: 200px; cursor: pointer;" onclick="window.copySessionCode()" title="Click to copy code">--</div>
                            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">Click code to copy</div>
                        </div>

                        <!-- Quick share buttons -->
                        <div style="display: flex; gap: 8px; justify-content: center; margin-bottom: 16px;">
                            <button class="btn" onclick="window.copySessionCode()" style="padding: 10px 16px; background: linear-gradient(135deg, #10b981, #059669); font-weight: 600;" title="Copy just the code">
                                ðŸ“‹ Copy Code
                            </button>
                            <button class="btn" onclick="window.copySyncInviteLink()" style="padding: 10px 16px; background: linear-gradient(135deg, #6366f1, #8b5cf6);" title="Copy full invite link">
                                ðŸ”— Copy Link
                            </button>
                            <button class="btn" onclick="window.emailSyncInvite()" style="padding: 10px 16px; background: linear-gradient(135deg, #f59e0b, #d97706);" title="Email invite">
                                ðŸ“§ Email
                            </button>
                        </div>

                        <!-- Full link (collapsed by default) -->
                        <details style="margin-top: 8px;">
                            <summary style="font-size: 11px; color: var(--text-secondary); cursor: pointer; text-align: center;">Show full invite link</summary>
                            <div style="margin-top: 8px;">
                                <input type="text" id="sync-invite-link" readonly
                                    style="width: 100%; padding: 10px; background: var(--bg); border: 2px solid var(--border); border-radius: 6px; font-family: monospace; font-size: 11px; color: var(--text-primary); box-sizing: border-box;">
                            </div>
                        </details>
                    </div>

                    <!-- Connected Collaborators -->
                    <div style="background: var(--card-bg); padding: 14px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 12px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                            <span style="font-weight: 600; font-size: 13px;">ðŸ‘¥ Connected</span>
                            <span id="sync-user-count" style="font-size: 12px; color: var(--text-secondary);">1 user</span>
                        </div>
                        <div id="sync-collaborators-list" style="display: flex; flex-wrap: wrap; gap: 8px;">
                            <!-- Collaborators will be populated here -->
                            <div class="collab-badge" style="display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 20px; font-size: 12px; font-weight: 600; color: white;">
                                <span>ðŸ‘‘</span> You (Host)
                            </div>
                        </div>
                    </div>

                    <!-- BUILD 272: Team Chat removed from modal - now in floating chat window -->
                    <!-- BUILD 281: API Key Sharing UI removed - guests enter keys manually -->

                    <!-- Actions -->
                    <div style="display: flex; gap: 8px;">
                        <button class="btn" onclick="window.saveCollabJSON()" style="flex: 1; padding: 10px; background: var(--card-bg); border: 1px solid var(--border);" title="Download current tree as JSON">
                            ðŸ’¾ Save Local Copy
                        </button>
                        <button class="btn" id="leave-sync-room-btn" onclick="window.leaveFirebaseSyncRoom()" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #ef4444, #dc2626); font-weight: 600;">
                            â¹ï¸ Leave Session
                        </button>
                    </div>
                </div>

                <!-- Hidden elements for backwards compatibility -->
                <div style="display: none;">
                    <div id="sync-status-section"></div>
                    <div id="sync-status-indicator"></div>
                    <div id="sync-status-text"></div>
                    <div id="sync-user-id"><span id="sync-user-id-value"></span></div>
                    <input type="text" id="active-room-id">
                    <div id="sync-last-update"></div>
                    <div id="sync-last-editor-row"><span id="sync-last-editor"></span></div>
                    <div id="api-session-start"></div>
                    <div id="api-session-active"></div>
                    <div id="api-session-expires-at"></div>
                    <div id="api-session-guest-count"></div>
                    <input id="api-session-share-link">
                    <div id="api-guest-session"></div>
                    <div id="api-guest-host-name"></div>
                    <div id="api-guest-expires"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- BUILD 268: Floating Collab Chat Box -->
    <!-- BUILD 272: Made draggable, removed onclick (handled in JS) -->
    <div id="floating-collab-chat" style="display: none; position: fixed; bottom: 20px; right: 20px; width: 320px; background: var(--card-bg); border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); border: 1px solid var(--border); z-index: 9999; overflow: hidden; font-family: inherit;">
        <!-- Header (draggable + click to toggle) -->
        <div id="floating-chat-header" style="cursor: move; padding: 12px 14px; background: linear-gradient(135deg, #f97316, #ea580c); display: flex; align-items: center; justify-content: space-between; user-select: none;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 8px; height: 8px; background: #10b981; border-radius: 50%; animation: watchPulse 2s ease-in-out infinite;"></div>
                <span style="font-weight: 600; color: white; font-size: 13px;">ðŸ”„ Live Session</span>
                <span id="floating-user-count" style="background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 10px; font-size: 11px; color: white;">1</span>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
                <span id="floating-unread-badge" style="display: none; background: #ef4444; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: 600;">0</span>
                <span id="floating-chat-toggle" style="color: white; font-size: 16px;">â–¼</span>
            </div>
        </div>
        <!-- Body (collapsible) -->
        <div id="floating-chat-body" style="max-height: 350px; overflow: hidden; transition: max-height 0.3s ease;">
            <!-- Collaborators -->
            <div style="padding: 10px 12px; border-bottom: 1px solid var(--border);">
                <div id="floating-collab-list" style="display: flex; flex-wrap: wrap; gap: 6px;">
                    <!-- Badges will be populated here -->
                </div>
            </div>
            <!-- Chat Messages -->
            <div id="floating-chat-messages" style="height: 160px; overflow-y: auto; padding: 10px 12px; background: var(--bg);">
                <div style="color: var(--text-secondary); text-align: center; padding: 50px 0; font-size: 12px;">No messages yet</div>
            </div>
            <!-- Chat Input -->
            <div style="padding: 10px 12px; border-top: 1px solid var(--border); display: flex; gap: 6px;">
                <input type="text" id="floating-chat-input" placeholder="Type a message..."
                    style="flex: 1; padding: 8px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 12px;"
                    onkeypress="if(event.key==='Enter') window.sendFloatingChatMessage()">
                <button onclick="window.sendFloatingChatMessage()" style="padding: 8px 12px; background: linear-gradient(135deg, #6366f1, #8b5cf6); border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600; font-size: 12px;">Send</button>
            </div>
            <!-- Session Controls -->
            <div style="padding: 8px 12px; border-top: 1px solid var(--border); display: flex; gap: 6px;">
                <!-- BUILD 322: Jitsi Voice Chat Button -->
                <button id="voice-chat-btn" onclick="window.startVoiceChat()" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 11px; font-weight: 600;" title="Start voice chat with collaborators">ðŸŽ™ï¸ Voice</button>
                <button onclick="document.getElementById('live-sync-modal').style.display='flex'" style="flex: 1; padding: 8px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); cursor: pointer; font-size: 11px;">âš™ï¸</button>
                <button onclick="window.leaveFirebaseSyncRoom()" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #ef4444, #dc2626); border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 11px; font-weight: 600;">Leave</button>
            </div>
        </div>
    </div>

    <!-- BUILD 325: Meeting Link Modal -->
    <div class="modal" id="meeting-link-modal" style="display: none;">
        <div class="modal-content" style="max-width: 480px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">
                <span>ðŸ“… Schedule Meeting Link</span>
                <button class="modal-close" onclick="window.closeMeetingModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <!-- Create Meeting Section -->
                <div id="meeting-create-section">
                    <div style="text-align: center; padding: 10px 0 20px;">
                        <div style="font-size: 40px; margin-bottom: 8px;">ðŸ“…</div>
                        <p style="margin: 0; font-size: 13px; color: var(--text-secondary);">
                            Create a meeting link to share via calendar invite.<br>
                            Guests get the full tree even before you arrive.
                        </p>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-size: 12px; font-weight: 600;">Meeting Name</label>
                        <input type="text" id="meeting-name-input" placeholder="e.g., CAPEX Review with Erwin"
                            style="width: 100%; padding: 12px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; box-sizing: border-box;">
                    </div>

                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-size: 12px; font-weight: 600;">Scheduled Time (optional)</label>
                        <input type="datetime-local" id="meeting-time-input"
                            style="width: 100%; padding: 12px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; box-sizing: border-box;">
                    </div>

                    <div style="margin-bottom: 20px; padding: 12px; background: var(--bg); border-radius: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer; font-size: 13px;">
                            <input type="checkbox" id="meeting-allow-edits" checked style="width: 16px; height: 16px;">
                            Allow guests to edit before I arrive
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer; font-size: 13px;">
                            <input type="checkbox" id="meeting-voice-prompt" checked style="width: 16px; height: 16px;">
                            Prompt for voice chat when ready
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px;">
                            <input type="checkbox" id="meeting-auto-backup" checked style="width: 16px; height: 16px;">
                            Auto-backup tree every 5 minutes
                        </label>
                    </div>

                    <button class="btn" onclick="window.createScheduledMeeting()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #6366f1, #8b5cf6); font-weight: 600; font-size: 15px;">
                        ðŸ”— Generate Meeting Link
                    </button>
                </div>

                <!-- Generated Link Section -->
                <div id="meeting-generated-section" style="display: none;">
                    <div style="text-align: center; padding: 20px 0;">
                        <div style="font-size: 48px; margin-bottom: 12px;">âœ…</div>
                        <h3 style="margin: 0 0 8px; color: var(--text-primary);">Meeting Link Ready!</h3>
                        <p style="margin: 0 0 20px; font-size: 13px; color: var(--text-secondary);">
                            Add this link to your Google Calendar invite
                        </p>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-size: 12px; font-weight: 600;">Meeting Link</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="meeting-link-url" readonly
                                style="flex: 1; padding: 12px; background: var(--bg); border: 2px solid var(--border); border-radius: 8px; font-family: monospace; font-size: 11px; color: var(--text-primary);">
                            <button class="btn" onclick="window.copyMeetingLink()" style="padding: 12px 16px; background: linear-gradient(135deg, #10b981, #059669);" title="Copy link">ðŸ“‹</button>
                        </div>
                    </div>

                    <div style="padding: 14px; background: rgba(99, 102, 241, 0.1); border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3); margin-bottom: 16px;">
                        <p style="margin: 0; font-size: 12px; color: var(--text-secondary);">
                            <strong style="color: var(--text-primary);">How it works:</strong><br>
                            1. Guests click the link â†’ tree loads instantly<br>
                            2. They can start editing while waiting for you<br>
                            3. When you click the link â†’ live session activates<br>
                            4. Everyone syncs automatically + voice prompt appears
                        </p>
                    </div>

                    <div style="display: flex; gap: 8px;">
                        <button class="btn" onclick="window.closeMeetingModal(); document.getElementById('live-sync-modal').style.display='flex';" style="flex: 1; padding: 12px; background: var(--card-bg); border: 1px solid var(--border);">
                            View Session
                        </button>
                        <button class="btn" onclick="window.closeMeetingModal()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #6366f1, #8b5cf6);">
                            Done
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- BUILD 325: Waiting Room Banner -->
    <div id="waiting-room-banner" style="display: none; position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; padding: 12px 20px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
        <div style="max-width: 1200px; margin: 0 auto; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px;">
            <div style="display: flex; align-items: center; gap: 12px;">
                <div style="font-size: 24px; animation: pulse 2s ease-in-out infinite;">â³</div>
                <div>
                    <div id="waiting-status" style="font-weight: 600; font-size: 14px;">Waiting for host to start the meeting...</div>
                    <div id="waiting-message" style="font-size: 12px; opacity: 0.9;">You can start editing - changes will sync when host arrives.</div>
                </div>
                <span id="waiting-timer" style="font-family: monospace; font-size: 13px; opacity: 0.8;"></span>
            </div>
            <div style="display: flex; gap: 8px;">
                <button onclick="window.downloadMeetingBackup('manual')" style="padding: 8px 14px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; color: white; cursor: pointer; font-size: 12px; font-weight: 600;">ðŸ’¾ Save Backup</button>
                <button onclick="window.location.href=window.location.pathname" style="padding: 8px 14px; background: rgba(239,68,68,0.8); border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 12px; font-weight: 600;">Leave</button>
            </div>
        </div>
    </div>

    <!-- BUILD 325: Voice Prompt Toast -->
    <div id="voice-prompt-toast" style="display: none; position: fixed; bottom: 100px; right: 20px; background: linear-gradient(135deg, #10b981, #059669); padding: 16px 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); z-index: 10001; color: white; max-width: 280px;">
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
            <span style="font-size: 24px;">ðŸŽ™ï¸</span>
            <div>
                <div style="font-weight: 600; font-size: 14px;">Ready for voice chat?</div>
                <div style="font-size: 12px; opacity: 0.9;">Host has joined the session</div>
            </div>
        </div>
        <div style="display: flex; gap: 8px;">
            <button onclick="window.acceptVoicePrompt()" style="flex: 1; padding: 10px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; color: white; cursor: pointer; font-weight: 600; font-size: 13px;">Join Voice</button>
            <button onclick="window.dismissVoicePrompt()" style="flex: 1; padding: 10px; background: transparent; border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; color: white; cursor: pointer; font-size: 13px;">Not now</button>
        </div>
    </div>

    <style>
        /* BUILD 325: Voice prompt animations */
        #voice-prompt-toast.slide-in {
            animation: slideInRight 0.3s ease-out;
        }
        #voice-prompt-toast.slide-out {
            animation: slideOutRight 0.3s ease-out;
        }
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>

    <!-- Hidden file input for JSON upload -->
    <input type="file" id="json-upload-input" accept=".json,.treelisty" style="display: none;" />

    <script>
        console.log('TreeListy - Universal Project Decomposition - Horizontal Layout with Pan/Zoom');

        // =============================================================================
        // SEMANTIC CHUNKING ENGINE (NLP + Vector Search)
        // =============================================================================

        /**
         * EmbeddingManager - Abstraction layer for embeddings from multiple providers
         */
        class EmbeddingManager {
            /**
             * Check if any embedding provider is available
             */
            static hasProvider() {
                const openaiKey = localStorage.getItem('openai_api_key');
                const geminiKey = localStorage.getItem('gemini_api_key');
                return !!(openaiKey || geminiKey);
            }

            /**
             * Get embeddings for an array of texts
             * @param {string[]} texts - Array of text strings to embed
             * @returns {Promise<number[][]>} Array of embedding vectors
             */
            static async getEmbeddings(texts) {
                if (!texts || texts.length === 0) {
                    throw new Error('No texts provided for embedding');
                }

                const openaiKey = localStorage.getItem('openai_api_key');
                const geminiKey = localStorage.getItem('gemini_api_key');

                // Try OpenAI first
                if (openaiKey) {
                    console.log(`ðŸ”¢ Getting embeddings from OpenAI (${texts.length} texts)`);
                    return await this._getOpenAIEmbeddings(texts, openaiKey);
                }

                // Fallback to Gemini
                if (geminiKey) {
                    console.log(`ðŸ”¢ Getting embeddings from Gemini (${texts.length} texts)`);
                    return await this._getGeminiEmbeddings(texts, geminiKey);
                }

                // No provider available
                console.warn('âš ï¸ No embedding provider available (OpenAI or Gemini API key required)');
                return null;
            }

            /**
             * OpenAI text-embedding-3-small
             */
            static async _getOpenAIEmbeddings(texts, apiKey) {
                const BATCH_SIZE = 20; // OpenAI limit
                const batches = [];

                for (let i = 0; i < texts.length; i += BATCH_SIZE) {
                    batches.push(texts.slice(i, i + BATCH_SIZE));
                }

                const allEmbeddings = [];

                for (const batch of batches) {
                    try {
                        const response = await fetch('https://api.openai.com/v1/embeddings', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                input: batch,
                                model: 'text-embedding-3-small'
                            })
                        });

                        if (!response.ok) {
                            const error = await response.text();
                            throw new Error(`OpenAI API error: ${error}`);
                        }

                        const data = await response.json();
                        const embeddings = data.data.map(item => item.embedding);
                        allEmbeddings.push(...embeddings);

                    } catch (error) {
                        console.error('OpenAI embedding error:', error);
                        throw error;
                    }
                }

                return allEmbeddings;
            }

            /**
             * Gemini text-embedding-004
             */
            static async _getGeminiEmbeddings(texts, apiKey) {
                const BATCH_SIZE = 20; // Conservative batch size
                const batches = [];

                for (let i = 0; i < texts.length; i += BATCH_SIZE) {
                    batches.push(texts.slice(i, i + BATCH_SIZE));
                }

                const allEmbeddings = [];

                for (const batch of batches) {
                    try {
                        // Gemini requires individual calls per text
                        const batchEmbeddings = await Promise.all(
                            batch.map(async (text) => {
                                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${apiKey}`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        content: {
                                            parts: [{ text: text }]
                                        }
                                    })
                                });

                                if (!response.ok) {
                                    const error = await response.text();
                                    throw new Error(`Gemini API error: ${error}`);
                                }

                                const data = await response.json();
                                return data.embedding.values;
                            })
                        );

                        allEmbeddings.push(...batchEmbeddings);

                    } catch (error) {
                        console.error('Gemini embedding error:', error);
                        throw error;
                    }
                }

                return allEmbeddings;
            }
        }

        /**
         * SemanticChunker - Rigorous semantic chunking with embedding-based breakpoints
         */
        class SemanticChunker {
            constructor() {
                this.DEFAULT_THRESHOLD = 0.7;
                this.PERCENTILE_THRESHOLD = 90;
            }

            /**
             * Calculate cosine similarity between two vectors
             * @param {number[]} vecA - First vector
             * @param {number[]} vecB - Second vector
             * @returns {number} Cosine similarity (0-1)
             */
            cosineSimilarity(vecA, vecB) {
                if (!vecA || !vecB || vecA.length !== vecB.length) {
                    throw new Error('Vectors must have same length');
                }

                let dotProduct = 0;
                let magnitudeA = 0;
                let magnitudeB = 0;

                for (let i = 0; i < vecA.length; i++) {
                    dotProduct += vecA[i] * vecB[i];
                    magnitudeA += vecA[i] * vecA[i];
                    magnitudeB += vecB[i] * vecB[i];
                }

                magnitudeA = Math.sqrt(magnitudeA);
                magnitudeB = Math.sqrt(magnitudeB);

                if (magnitudeA === 0 || magnitudeB === 0) {
                    return 0;
                }

                return dotProduct / (magnitudeA * magnitudeB);
            }

            /**
             * Calculate breakpoint threshold using percentile method
             * @param {number[]} distances - Array of cosine distances
             * @returns {number} Threshold value
             */
            calculateBreakpointThreshold(distances) {
                if (!distances || distances.length === 0) {
                    return this.DEFAULT_THRESHOLD;
                }

                // Sort distances
                const sorted = [...distances].sort((a, b) => a - b);

                // Find 90th percentile
                const index = Math.floor(sorted.length * (this.PERCENTILE_THRESHOLD / 100));
                const threshold = sorted[Math.min(index, sorted.length - 1)];

                console.log(`ðŸ“Š Calculated breakpoint threshold: ${threshold.toFixed(3)} (90th percentile)`);

                return threshold;
            }

            /**
             * Split text into sentences using robust regex
             * @param {string} text - Input text
             * @returns {string[]} Array of sentences
             */
            splitIntoSentences(text) {
                if (!text) return [];

                // Split on sentence boundaries (., !, ?) followed by whitespace and capital letter
                // or newline, but preserve acronyms (e.g., U.S.A.)
                const sentences = text
                    .replace(/([.!?])\s+(?=[A-Z])/g, '$1|SPLIT|')
                    .replace(/\n+/g, '|SPLIT|')
                    .split('|SPLIT|')
                    .map(s => s.trim())
                    .filter(s => s.length > 0);

                console.log(`âœ‚ï¸ Split into ${sentences.length} sentences`);
                return sentences;
            }

            /**
             * Structural fallback split (when embeddings unavailable)
             * @param {string} text - Input text
             * @returns {Array<{text: string, start: number, end: number}>} Array of chunks
             */
            structuralSplit(text) {
                console.log('ðŸ“ Using structural split (fallback mode)');

                const chunks = [];
                let currentChunk = '';
                let start = 0;

                // Split by Markdown headers first
                const headerRegex = /^(#{1,6})\s+(.+)$/gm;
                const parts = text.split(headerRegex);

                if (parts.length > 1) {
                    // Has headers - use them as boundaries
                    for (let i = 0; i < parts.length; i += 3) {
                        const content = parts[i] || '';
                        const headerLevel = parts[i + 1];
                        const headerText = parts[i + 2];

                        if (content.trim()) {
                            chunks.push({
                                text: content.trim(),
                                start: start,
                                end: start + content.length
                            });
                            start += content.length;
                        }

                        if (headerLevel && headerText) {
                            const header = `${headerLevel} ${headerText}`;
                            chunks.push({
                                text: header.trim(),
                                start: start,
                                end: start + header.length
                            });
                            start += header.length;
                        }
                    }
                } else {
                    // No headers - split by paragraphs
                    const paragraphs = text.split(/\n\n+/);

                    for (const para of paragraphs) {
                        if (para.trim()) {
                            chunks.push({
                                text: para.trim(),
                                start: start,
                                end: start + para.length
                            });
                            start += para.length;
                        }
                    }
                }

                // If still no chunks, split by lines
                if (chunks.length === 0) {
                    const lines = text.split(/\n/);
                    for (const line of lines) {
                        if (line.trim()) {
                            chunks.push({
                                text: line.trim(),
                                start: start,
                                end: start + line.length
                            });
                            start += line.length;
                        }
                    }
                }

                console.log(`âœ… Structural split: ${chunks.length} chunks`);
                return chunks;
            }

            /**
             * Core embedding-based chunking algorithm
             * @param {string} text - Input text
             * @returns {Promise<Array<{text: string, start: number, end: number}>>} Array of semantic chunks
             */
            async chunkByEmbedding(text) {
                console.log('ðŸ§  Starting embedding-based semantic chunking...');

                try {
                    // Step 1: Split into sentences
                    const sentences = this.splitIntoSentences(text);

                    if (sentences.length === 0) {
                        console.warn('âš ï¸ No sentences found');
                        return [{ text: text, start: 0, end: text.length }];
                    }

                    if (sentences.length === 1) {
                        console.log('Single sentence - no chunking needed');
                        return [{ text: text, start: 0, end: text.length }];
                    }

                    // Step 2: Create sliding window combinations (sentence + prev + next)
                    const windowedSentences = sentences.map((sentence, i) => {
                        const prev = i > 0 ? sentences[i - 1] : '';
                        const next = i < sentences.length - 1 ? sentences[i + 1] : '';
                        return `${prev} ${sentence} ${next}`.trim();
                    });

                    // Step 3: Get embeddings
                    console.log(`ðŸ“Š Getting embeddings for ${windowedSentences.length} windowed sentences...`);
                    const embeddings = await EmbeddingManager.getEmbeddings(windowedSentences);

                    if (!embeddings) {
                        console.warn('âš ï¸ Embeddings unavailable, falling back to structural split');
                        return this.structuralSplit(text);
                    }

                    // Step 4: Calculate cosine distances between adjacent sentences
                    const distances = [];
                    for (let i = 0; i < embeddings.length - 1; i++) {
                        const similarity = this.cosineSimilarity(embeddings[i], embeddings[i + 1]);
                        const distance = 1 - similarity; // Convert similarity to distance
                        distances.push(distance);
                    }

                    // Step 5: Calculate adaptive threshold
                    const threshold = this.calculateBreakpointThreshold(distances);

                    // Step 6: Identify breakpoints where distance > threshold
                    const breakpoints = [0]; // Start with first sentence
                    for (let i = 0; i < distances.length; i++) {
                        if (distances[i] > threshold) {
                            breakpoints.push(i + 1);
                            console.log(`ðŸ“ Breakpoint at sentence ${i + 1} (distance: ${distances[i].toFixed(3)})`);
                        }
                    }
                    breakpoints.push(sentences.length); // End with last sentence

                    // Step 7: Merge sentences between breakpoints into chunks
                    const chunks = [];
                    let charIndex = 0;

                    for (let i = 0; i < breakpoints.length - 1; i++) {
                        const startIdx = breakpoints[i];
                        const endIdx = breakpoints[i + 1];
                        const chunkSentences = sentences.slice(startIdx, endIdx);
                        const chunkText = chunkSentences.join(' ');

                        chunks.push({
                            text: chunkText,
                            start: charIndex,
                            end: charIndex + chunkText.length
                        });

                        charIndex += chunkText.length + 1; // +1 for space
                    }

                    console.log(`âœ… Semantic chunking complete: ${chunks.length} chunks (from ${sentences.length} sentences)`);
                    return chunks;

                } catch (error) {
                    console.error('âŒ Embedding-based chunking failed:', error);
                    console.log('Falling back to structural split');
                    return this.structuralSplit(text);
                }
            }
        }

        // =============================================================================
        // PAN & ZOOM SYSTEM
        // =============================================================================

        // Pan/Zoom state
        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startX = 0;
        let startY = 0;

        const MIN_ZOOM = 0.25;  // 25%
        const MAX_ZOOM = 3.0;   // 300%
        const ZOOM_STEP = 0.15; // 15% per click

        // Apply transform to tree
        function applyTransform() {
            const wrapper = document.getElementById('tree-transform-wrapper');
            if (wrapper) {
                wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
                updateZoomDisplay();
            }
        }

        // Update zoom level display
        function updateZoomDisplay() {
            const display = document.getElementById('zoom-level');
            if (display) {
                display.textContent = Math.round(zoomLevel * 100) + '%';
            }
        }

        // Zoom in
        function zoomIn() {
            if (zoomLevel < MAX_ZOOM) {
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
                applyTransform();
            }
        }

        // Zoom out
        function zoomOut() {
            if (zoomLevel > MIN_ZOOM) {
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
                applyTransform();
            }
        }

        // Reset view
        function resetZoom() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            applyTransform();
        }

        // Mouse wheel zoom - BUILD 410: Zoom toward cursor position
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY;

            // Get container and mouse position
            const container = document.getElementById('tree-container');
            const rect = container.getBoundingClientRect();

            // Mouse position relative to container
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Calculate the point in content space (before zoom)
            // This is where the mouse is pointing in the actual content
            const contentX = (mouseX - panX) / zoomLevel;
            const contentY = (mouseY - panY) / zoomLevel;

            // Apply zoom
            const oldZoom = zoomLevel;
            if (delta < 0) {
                // Scroll up = zoom in
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
            } else {
                // Scroll down = zoom out
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
            }

            // Adjust pan so the same content point stays under the cursor
            // New screen position of content point = contentX * newZoom + newPanX
            // We want this to equal mouseX, so: newPanX = mouseX - contentX * newZoom
            panX = mouseX - contentX * zoomLevel;
            panY = mouseY - contentY * zoomLevel;

            applyTransform();
        }

        // Mouse down - start panning
        function handleMouseDown(e) {
            // Don't pan if clicking on a node or button
            if (e.target.closest('.tree-node') || e.target.closest('button') || e.target.closest('.zoom-controls')) {
                return;
            }

            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;

            const container = document.getElementById('tree-container');
            const wrapper = document.getElementById('tree-transform-wrapper');
            container.classList.add('panning');
            if (wrapper) wrapper.classList.add('panning');  // BUILD 410: Disable transition during drag
        }

        // Mouse move - pan
        function handleMouseMove(e) {
            if (!isPanning) return;

            panX = e.clientX - startX;
            panY = e.clientY - startY;
            applyTransform();
        }

        // Mouse up - stop panning
        function handleMouseUp(e) {
            if (isPanning) {
                isPanning = false;
                const container = document.getElementById('tree-container');
                const wrapper = document.getElementById('tree-transform-wrapper');
                container.classList.remove('panning');
                if (wrapper) wrapper.classList.remove('panning');  // BUILD 410: Re-enable transition
            }
        }

        // Initialize pan/zoom after DOM loads
        function initPanZoom() {
            const container = document.getElementById('tree-container');

            // Zoom controls
            document.getElementById('zoom-in').addEventListener('click', zoomIn);
            document.getElementById('zoom-out').addEventListener('click', zoomOut);
            document.getElementById('zoom-reset').addEventListener('click', resetZoom);

            // Mouse wheel
            container.addEventListener('wheel', handleWheel, { passive: false });

            // Mouse drag
            container.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Prevent context menu on drag
            container.addEventListener('contextmenu', (e) => {
                if (isPanning) e.preventDefault();
            });

            console.log('âœ… Pan/Zoom initialized');
        }

        // =============================================================================
        // END PAN & ZOOM SYSTEM
        // =============================================================================

        // =============================================================================
        // AI TUNER - PERSONA PERSISTENCE
        // =============================================================================

        // Helper to get AI config with safe defaults
        function getAIConfig() {
            const defaults = {
                tone: 'neutral',        // neutral, critical, enthusiastic, socratic
                verbosity: 'concise',   // concise, balanced, verbose
                creativity: 0.5,        // 0.0 to 1.0 (maps to temperature)
                dialecticMode: false,   // Cognitive Citadel: force counter-arguments
                customInstructions: ''  // User override
            };

            // Merge saved config if it exists
            return { ...defaults, ...(capexTree.aiConfig || {}) };
        }

        // Apply persona tuning to system prompts
        function applyPersonaTuning(baseSystemPrompt) {
            const config = getAIConfig();
            let tuning = "";

            // 1. Tone Injection
            if (config.tone === 'critical') {
                tuning += "ROLE ADAPTATION: You are a ruthless Red Team critic. Challenge assumptions. Find flaws. Do not be polite.\n";
            } else if (config.tone === 'socratic') {
                tuning += "ROLE ADAPTATION: Do not give answers directly. Ask probing questions to guide the user to discover the solution themselves.\n";
            } else if (config.tone === 'enthusiastic') {
                tuning += "ROLE ADAPTATION: Be high-energy and encouraging. Focus on opportunities and 'yes, and' thinking. Use energizing language.\n";
            }
            // neutral = no injection

            // 2. Verbosity Injection
            if (config.verbosity === 'concise') {
                tuning += "OUTPUT STYLE: Be extremely brief. Use telegraphic style. No fluff. Bullet points preferred.\n";
            } else if (config.verbosity === 'verbose') {
                tuning += "OUTPUT STYLE: Be thorough and detailed. Explain reasoning fully. Provide comprehensive analysis with examples.\n";
            }
            // balanced = no injection

            // 3. DIALECTIC MODE (Cognitive Citadel)
            if (config.dialecticMode) {
                tuning += `
ðŸ›¡ï¸ DIALECTIC MODE ACTIVE:
Before responding to the user's request, you MUST:
1. Identify 2 hidden assumptions in their request
2. Generate 1 strong counter-argument or alternative perspective
3. Note 1 potential blind spot they may have

Present these briefly as "**ðŸ›¡ï¸ Considerations:**" (4-5 lines max), then proceed with the requested task.
Do not ask permissionâ€”just provide the critique, then help.
`;
            }

            // 4. User Override (HIGHEST PRIORITY)
            if (config.customInstructions && config.customInstructions.trim()) {
                tuning += `\nUSER PRIORITY INSTRUCTION: ${config.customInstructions.trim()}\n`;
            }

            // BUILD 260: Append specialist context to the BASE prompt (not prepend)
            // This makes it a natural extension of the persona, not a competing directive
            let enhancedBasePrompt = baseSystemPrompt;
            if (capexTree.specialistContext && capexTree.specialistContext.trim()) {
                enhancedBasePrompt += `\n\nFor this specific project, you have additional specialized expertise: ${capexTree.specialistContext.trim()}`;
            }

            // Prepend tuning to the enhanced base prompt
            if (tuning) {
                return `${tuning}\n${enhancedBasePrompt}`;
            }
            return enhancedBasePrompt;
        }

        // Open Project Settings Modal (Build 260, updated Build 262)
        function openProjectSettingsModal() {
            const modal = document.getElementById('project-settings-modal');

            // Populate fields with current values
            document.getElementById('project-name-input').value = capexTree.name || '';
            document.getElementById('project-description-input').value = capexTree.description || '';
            document.getElementById('project-specialist-context').value = capexTree.specialistContext || '';

            // Build 262: Render team displays
            renderHostDisplay();
            renderTeamList();

            modal.classList.add('open');

            // Focus on first field
            setTimeout(() => document.getElementById('project-name-input').focus(), 100);
        }

        // Save Project Settings (Build 260)
        function saveProjectSettings() {
            const newName = document.getElementById('project-name-input').value.trim();
            const newDescription = document.getElementById('project-description-input').value.trim();
            const newSpecialistContext = document.getElementById('project-specialist-context').value.trim();

            // Save state for undo
            saveState('Edit project settings');

            // Update tree root
            if (newName) capexTree.name = newName;
            capexTree.description = newDescription;
            capexTree.specialistContext = newSpecialistContext;

            // Close modal and re-render
            document.getElementById('project-settings-modal').classList.remove('open');
            render();

            // Show toast
            const hasSpecialist = newSpecialistContext ? ' with AI specialist context' : '';
            showToast(`Project settings saved${hasSpecialist}`, 'success');
        }

        // ==================== Build 262: Team Management ====================

        // Generate unique initials for a name, avoiding collisions with existing initials
        function generateUniqueInitials(name, existingInitials = []) {
            if (!name || !name.trim()) return '?';
            const cleanName = name.trim().toUpperCase();

            // Start with first letter
            let initials = cleanName.charAt(0);

            // If collision, add second letter
            if (existingInitials.includes(initials)) {
                initials = cleanName.substring(0, 2);
            }

            // If still collision, add third letter or number
            let counter = 1;
            while (existingInitials.includes(initials) && counter < 10) {
                if (cleanName.length > 2) {
                    initials = cleanName.substring(0, 3);
                } else {
                    initials = cleanName.charAt(0) + counter;
                }
                counter++;
            }

            return initials;
        }

        // Get all team members (host + collaborators + contributors)
        function getProjectTeam() {
            if (!capexTree.team) {
                capexTree.team = {
                    host: null,
                    collaborators: [],
                    contributors: []
                };
            }
            return capexTree.team;
        }

        // Recalculate all initials to ensure uniqueness
        function recalculateTeamInitials() {
            const team = getProjectTeam();
            const usedInitials = [];

            // Host first
            if (team.host) {
                team.host.initials = generateUniqueInitials(team.host.name, usedInitials);
                usedInitials.push(team.host.initials);
            }

            // Then collaborators
            for (const member of team.collaborators) {
                member.initials = generateUniqueInitials(member.name, usedInitials);
                usedInitials.push(member.initials);
            }

            // Then contributors
            for (const member of team.contributors) {
                member.initials = generateUniqueInitials(member.name, usedInitials);
                usedInitials.push(member.initials);
            }
        }

        // Add a new team member
        function addTeamMember() {
            const nameInput = document.getElementById('new-member-name');
            const emailInput = document.getElementById('new-member-email');
            const roleSelect = document.getElementById('new-member-role');

            const name = nameInput.value.trim();
            const email = emailInput.value.trim();
            const role = roleSelect.value;

            if (!name) {
                showToast('Please enter a name', 'error');
                nameInput.focus();
                return;
            }

            if (!email || !email.includes('@')) {
                showToast('Please enter a valid email', 'error');
                emailInput.focus();
                return;
            }

            const team = getProjectTeam();

            // Check for duplicate email
            const allMembers = [team.host, ...team.collaborators, ...team.contributors].filter(Boolean);
            if (allMembers.some(m => m.email.toLowerCase() === email.toLowerCase())) {
                showToast('This email is already on the team', 'error');
                return;
            }

            // Create new member
            const newMember = { name, email, initials: '' };

            if (role === 'collaborator') {
                team.collaborators.push(newMember);
            } else {
                team.contributors.push(newMember);
            }

            // Recalculate all initials
            recalculateTeamInitials();

            // Clear inputs
            nameInput.value = '';
            emailInput.value = '';

            // Re-render team list
            renderTeamList();

            showToast(`${name} added as ${role}`, 'success');
        }

        // Remove a team member
        function removeTeamMember(email, role) {
            const team = getProjectTeam();

            if (role === 'collaborator') {
                team.collaborators = team.collaborators.filter(m => m.email !== email);
            } else {
                team.contributors = team.contributors.filter(m => m.email !== email);
            }

            // Recalculate initials after removal
            recalculateTeamInitials();
            renderTeamList();

            showToast('Team member removed', 'success');
        }

        // Set the project host
        function setProjectHost() {
            const name = prompt('Enter host name:');
            if (!name || !name.trim()) return;

            const email = prompt('Enter host email:');
            if (!email || !email.includes('@')) {
                showToast('Please enter a valid email', 'error');
                return;
            }

            const team = getProjectTeam();
            team.host = { name: name.trim(), email: email.trim(), initials: '' };

            recalculateTeamInitials();
            renderTeamList();
            renderHostDisplay();

            showToast('Project host set', 'success');
        }

        // Render the host display in project settings
        function renderHostDisplay() {
            const team = getProjectTeam();
            const hostBadge = document.getElementById('host-badge');
            const hostName = document.getElementById('host-name');
            const hostEmail = document.getElementById('host-email');

            if (!hostBadge || !hostName || !hostEmail) return;

            if (team.host) {
                hostBadge.textContent = team.host.initials || '?';
                hostName.textContent = team.host.name;
                hostEmail.textContent = team.host.email;
            } else {
                hostBadge.textContent = '?';
                hostName.innerHTML = '<span style="color: var(--text-secondary); font-style: italic;">No host set</span> <button onclick="setProjectHost()" style="margin-left: 8px; padding: 4px 8px; background: var(--treeplex-primary); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Set Host</button>';
                hostEmail.textContent = '';
            }
        }

        // Render the team list in project settings
        function renderTeamList() {
            const team = getProjectTeam();
            const container = document.getElementById('project-team-list');
            if (!container) return;

            let html = '';

            // Collaborators
            if (team.collaborators.length > 0) {
                html += '<div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">ðŸ¤ Collaborators</div>';
                for (const member of team.collaborators) {
                    html += renderTeamMemberRow(member, 'collaborator');
                }
            }

            // Contributors
            if (team.contributors.length > 0) {
                html += '<div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); margin-top: 12px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">âœï¸ Contributors</div>';
                for (const member of team.contributors) {
                    html += renderTeamMemberRow(member, 'contributor');
                }
            }

            if (!html) {
                html = '<div style="text-align: center; padding: 16px; color: var(--text-secondary); font-size: 13px;">No team members yet. Add some above!</div>';
            }

            container.innerHTML = html;
        }

        // Render a single team member row
        function renderTeamMemberRow(member, role) {
            const badgeColor = role === 'collaborator' ?
                'linear-gradient(135deg, #3b82f6, #6366f1)' :
                'linear-gradient(135deg, #10b981, #059669)';

            return `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--item-bg); border: 1px solid var(--border); border-radius: 8px;">
                    <span style="width: 28px; height: 28px; background: ${badgeColor}; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 11px;" title="${member.email}">${member.initials}</span>
                    <span style="flex: 1; font-size: 14px;">${member.name}</span>
                    <span style="font-size: 11px; color: var(--text-secondary);">${member.email}</span>
                    <button onclick="removeTeamMember('${member.email}', '${role}')" style="padding: 4px 8px; background: transparent; border: 1px solid var(--border); border-radius: 4px; cursor: pointer; color: var(--text-secondary); font-size: 11px;" title="Remove">âœ•</button>
                </div>
            `;
        }

        // Get all team members as a flat array for contributor buttons
        function getAllTeamMembers() {
            const team = getProjectTeam();
            const members = [];

            if (team.host) members.push({ ...team.host, role: 'host' });
            team.collaborators.forEach(m => members.push({ ...m, role: 'collaborator' }));
            team.contributors.forEach(m => members.push({ ...m, role: 'contributor' }));

            return members;
        }

        // Generate contributor buttons HTML for the edit modal
        function generateContributorButtons() {
            const members = getAllTeamMembers();

            if (members.length === 0) {
                return '<span style="font-size: 11px; color: var(--text-secondary);">Add team members in Project Settings</span>';
            }

            return members.map(member => {
                const bgColor = member.role === 'host' ? 'linear-gradient(135deg, #ffc107, #ff9800)' :
                               member.role === 'collaborator' ? 'linear-gradient(135deg, #3b82f6, #6366f1)' :
                               'linear-gradient(135deg, #10b981, #059669)';
                const textColor = member.role === 'host' ? '#000' : 'white';

                return `<button type="button" onclick="document.getElementById('edit-contributor').value='${member.name}'" style="padding: 6px 12px; background: ${bgColor}; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; color: ${textColor}; font-weight: 500;" title="${member.email}">${member.initials}</button>`;
            }).join('');
        }

        // Populate watch mode team member buttons
        function populateWatchModeTeamButtons() {
            const container = document.getElementById('watch-name-container');
            if (!container) return;

            const members = getAllTeamMembers();
            const inputField = document.getElementById('watch-collaborator-name');

            // Clear existing buttons (keep only the input)
            const existingButtons = container.querySelectorAll('button');
            existingButtons.forEach(btn => btn.remove());

            // Add team member buttons
            members.forEach(member => {
                const bgColor = member.role === 'host' ? 'linear-gradient(135deg, #ffc107, #ff9800)' :
                               member.role === 'collaborator' ? 'linear-gradient(135deg, #3b82f6, #6366f1)' :
                               'linear-gradient(135deg, #10b981, #059669)';
                const textColor = member.role === 'host' ? '#000' : 'white';

                const btn = document.createElement('button');
                btn.type = 'button';
                btn.textContent = member.initials;
                btn.title = `${member.name} (${member.email})`;
                btn.style.cssText = `padding: 10px 16px; background: ${bgColor}; border: none; border-radius: 6px; cursor: pointer; color: ${textColor}; font-weight: bold; font-size: 12px;`;
                btn.onclick = () => {
                    if (inputField) inputField.value = member.name;
                };
                container.appendChild(btn);
            });

            // If no team members, show hint
            if (members.length === 0) {
                const hint = document.createElement('span');
                hint.style.cssText = 'font-size: 11px; color: var(--text-secondary); padding: 10px;';
                hint.textContent = 'Add team in Project Settings';
                container.appendChild(hint);
            }
        }

        // ==================== End Build 262 ====================

        // BUILD 328: Populate version display from single source of truth
        document.addEventListener('DOMContentLoaded', () => {
            const versionEl = document.getElementById('version-display');
            if (versionEl && window.TREELISTY_VERSION) {
                versionEl.textContent = window.TREELISTY_VERSION.full;
                versionEl.title = window.TREELISTY_VERSION.title;
            }
        });

        // BUILD 331: Dropdown Menu System with ARIA support
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize all dropdown menus
            document.querySelectorAll('.dropdown-menu').forEach(dropdown => {
                const trigger = dropdown.querySelector('.dropdown-menu-trigger');
                const content = dropdown.querySelector('.dropdown-menu-content');
                const items = dropdown.querySelectorAll('.dropdown-menu-item');

                if (!trigger || !content) return;

                // Toggle dropdown on trigger click
                trigger.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isOpen = content.classList.contains('open');

                    // Close all other dropdowns first
                    document.querySelectorAll('.dropdown-menu-content.open').forEach(d => {
                        d.classList.remove('open');
                        d.parentElement.querySelector('.dropdown-menu-trigger')?.setAttribute('aria-expanded', 'false');
                    });

                    // Toggle this dropdown
                    if (!isOpen) {
                        content.classList.add('open');
                        trigger.setAttribute('aria-expanded', 'true');
                        // Focus first item for keyboard nav
                        items[0]?.focus();
                    } else {
                        content.classList.remove('open');
                        trigger.setAttribute('aria-expanded', 'false');
                    }
                });

                // Keyboard navigation within dropdown
                content.addEventListener('keydown', (e) => {
                    const currentIndex = Array.from(items).indexOf(document.activeElement);

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        const nextIndex = (currentIndex + 1) % items.length;
                        items[nextIndex]?.focus();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        const prevIndex = (currentIndex - 1 + items.length) % items.length;
                        items[prevIndex]?.focus();
                    } else if (e.key === 'Escape') {
                        content.classList.remove('open');
                        trigger.setAttribute('aria-expanded', 'false');
                        trigger.focus();
                    } else if (e.key === 'Tab') {
                        // Allow tab to close dropdown and move focus naturally
                        content.classList.remove('open');
                        trigger.setAttribute('aria-expanded', 'false');
                    }
                });

                // Close dropdown when clicking menu items (after their handler runs)
                items.forEach(item => {
                    item.addEventListener('click', () => {
                        setTimeout(() => {
                            content.classList.remove('open');
                            trigger.setAttribute('aria-expanded', 'false');
                        }, 50);
                    });
                });
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.dropdown-menu')) {
                    document.querySelectorAll('.dropdown-menu-content.open').forEach(d => {
                        d.classList.remove('open');
                        d.parentElement.querySelector('.dropdown-menu-trigger')?.setAttribute('aria-expanded', 'false');
                    });
                }
            });

            // Close dropdowns on Escape key (global)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    document.querySelectorAll('.dropdown-menu-content.open').forEach(d => {
                        d.classList.remove('open');
                        d.parentElement.querySelector('.dropdown-menu-trigger')?.setAttribute('aria-expanded', 'false');
                    });
                }
            });
        });

        // BUILD 333: View Selector Dropdown - handles view switching
        document.addEventListener('DOMContentLoaded', () => {
            const viewIcons = { tree: 'ðŸŒ²', canvas: 'ðŸŽ¨', '3d': 'ðŸ§Š' };
            const viewLabels = { tree: 'Tree', canvas: 'Canvas', '3d': '3D' };

            function updateViewDropdown(newView) {
                // Update trigger button to show current state
                const icon = document.getElementById('current-view-icon');
                const text = document.getElementById('current-view-text');
                if (icon) icon.textContent = viewIcons[newView] || 'ðŸŒ²';
                if (text) text.textContent = viewLabels[newView] || 'Tree';

                // Update checkmarks
                document.getElementById('tree-check').style.opacity = newView === 'tree' ? '1' : '0';
                document.getElementById('canvas-check').style.opacity = newView === 'canvas' ? '1' : '0';
                document.getElementById('3d-check').style.opacity = newView === '3d' ? '1' : '0';

                // Show/hide export option based on view
                const exportBtn = document.getElementById('export-canvas-btn');
                if (exportBtn) {
                    exportBtn.style.display = (newView === 'canvas') ? 'flex' : 'none';
                }
            }

            // Tree View button
            document.getElementById('view-tree-btn')?.addEventListener('click', () => {
                if (typeof viewMode !== 'undefined' && viewMode !== 'tree') {
                    // Click the hidden toggle button to switch from canvas
                    if (viewMode === 'canvas') {
                        document.getElementById('toggle-view-mode')?.click();
                    } else if (viewMode === '3d') {
                        document.getElementById('toggle-3d-mode')?.click();
                    }
                }
                updateViewDropdown('tree');
            });

            // Canvas View button
            document.getElementById('view-canvas-btn')?.addEventListener('click', () => {
                if (typeof viewMode !== 'undefined') {
                    if (viewMode === 'tree') {
                        document.getElementById('toggle-view-mode')?.click();
                    } else if (viewMode === '3d') {
                        document.getElementById('toggle-3d-mode')?.click();
                        // After exiting 3D, we're in tree, so click again to go to canvas
                        setTimeout(() => {
                            document.getElementById('toggle-view-mode')?.click();
                        }, 100);
                    }
                }
                updateViewDropdown('canvas');
            });

            // 3D View button
            document.getElementById('view-3d-btn')?.addEventListener('click', () => {
                if (typeof viewMode !== 'undefined' && viewMode !== '3d') {
                    document.getElementById('toggle-3d-mode')?.click();
                }
                updateViewDropdown('3d');
            });

            // Expose update function globally so existing view toggle code can call it
            window.updateViewDropdown = updateViewDropdown;

            // Initialize based on current viewMode
            setTimeout(() => {
                if (typeof viewMode !== 'undefined') {
                    updateViewDropdown(viewMode);
                }
            }, 100);
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 414: SHARE VIEW STATE - Capture & restore view state for shared links
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Capture current view state for sharing
         * Returns object with current view type, canvas positions, expanded nodes, etc.
         */
        function captureViewState() {
            const state = {
                v: typeof viewMode !== 'undefined' ? viewMode : 'tree', // view type
                t: Date.now() // timestamp
            };

            // Capture selected node
            if (typeof activeNode !== 'undefined' && activeNode?.id) {
                state.s = activeNode.id; // selected
            }

            // Capture expanded nodes (tree view)
            const expandedNodes = [];
            document.querySelectorAll('.tree-node.expanded').forEach(node => {
                const nodeId = node.dataset?.id || node.querySelector('[data-id]')?.dataset?.id;
                if (nodeId) expandedNodes.push(nodeId);
            });
            if (expandedNodes.length > 0 && expandedNodes.length <= 50) {
                state.e = expandedNodes; // expanded
            }

            // Capture canvas positions if in canvas view
            if (state.v === 'canvas' && typeof canvasNodes !== 'undefined') {
                const positions = {};
                canvasNodes.forEach(({ data, element }) => {
                    if (data?.id && element) {
                        const rect = element.getBoundingClientRect();
                        const container = document.getElementById('canvas-container');
                        if (container) {
                            const containerRect = container.getBoundingClientRect();
                            positions[data.id] = {
                                x: Math.round(rect.left - containerRect.left),
                                y: Math.round(rect.top - containerRect.top)
                            };
                        }
                    }
                });
                if (Object.keys(positions).length > 0) {
                    state.p = positions; // positions
                }
            }

            // Capture canvas zoom/pan
            const canvasContainer = document.getElementById('canvas-container');
            if (canvasContainer) {
                const transform = canvasContainer.style.transform;
                if (transform) {
                    const scaleMatch = transform.match(/scale\(([\d.]+)\)/);
                    const translateMatch = transform.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
                    if (scaleMatch) state.z = parseFloat(scaleMatch[1]); // zoom
                    if (translateMatch) {
                        state.px = parseInt(translateMatch[1]); // pan x
                        state.py = parseInt(translateMatch[2]); // pan y
                    }
                }
            }

            return state;
        }
        window.captureViewState = captureViewState;

        /**
         * Encode view state with graceful degradation
         * Budget: 1500 bytes max for universal URL compatibility
         */
        function encodeViewState(state, budget = 1500) {
            // Priority levels for degradation
            // P0: view type, timestamp (~20 bytes) - never cut
            // P1: selected node (~30 bytes) - never cut
            // P2: zoom/pan (~20 bytes) - never cut
            // P3: expanded nodes (~10 bytes each) - cap at 20 if needed
            // P4: canvas positions (~15 bytes each) - first to cut

            let encoded = '';
            let currentState = { ...state };

            // Try full state first
            try {
                encoded = btoa(JSON.stringify(currentState));
                if (encoded.length <= budget) {
                    return encoded;
                }
            } catch (e) {
                console.warn('View state encoding failed:', e);
            }

            // Degradation step 1: Remove canvas positions
            if (currentState.p) {
                delete currentState.p;
                encoded = btoa(JSON.stringify(currentState));
                if (encoded.length <= budget) {
                    console.log('ðŸ“¦ View state: dropped canvas positions to fit budget');
                    return encoded;
                }
            }

            // Degradation step 2: Cap expanded nodes to 20
            if (currentState.e && currentState.e.length > 20) {
                currentState.e = currentState.e.slice(0, 20);
                encoded = btoa(JSON.stringify(currentState));
                if (encoded.length <= budget) {
                    console.log('ðŸ“¦ View state: capped expanded nodes to 20');
                    return encoded;
                }
            }

            // Degradation step 3: Remove expanded nodes entirely
            if (currentState.e) {
                delete currentState.e;
                encoded = btoa(JSON.stringify(currentState));
                if (encoded.length <= budget) {
                    console.log('ðŸ“¦ View state: dropped expanded nodes to fit budget');
                    return encoded;
                }
            }

            // Minimal state: just view type and selected
            const minimal = { v: state.v };
            if (state.s) minimal.s = state.s;
            encoded = btoa(JSON.stringify(minimal));
            console.log('ðŸ“¦ View state: using minimal (view + selection only)');
            return encoded;
        }
        window.encodeViewState = encodeViewState;

        /**
         * Decode view state from URL parameter
         */
        function decodeViewState(encoded) {
            if (!encoded) return null;
            try {
                return JSON.parse(atob(encoded));
            } catch (e) {
                console.warn('Failed to decode view state:', e);
                return null;
            }
        }
        window.decodeViewState = decodeViewState;

        /**
         * Generate share URL with current view state
         */
        function generateShareURL(baseParams = {}) {
            const state = captureViewState();
            const encoded = encodeViewState(state);

            let url = `${window.location.origin}${window.location.pathname}`;
            const params = [];

            // Add base params (room, session, etc.)
            Object.entries(baseParams).forEach(([key, value]) => {
                if (value) params.push(`${key}=${encodeURIComponent(value)}`);
            });

            // Add view state
            if (encoded) {
                params.push(`vs=${encoded}`);
            }

            // Add splash flag for shared links
            params.push('splash=1');

            if (params.length > 0) {
                url += '?' + params.join('&');
            }

            return url;
        }
        window.generateShareURL = generateShareURL;

        /**
         * Restore view state from decoded state object
         */
        async function restoreViewState(state) {
            if (!state) return;

            console.log('ðŸŽ¬ Restoring view state:', state);

            // Restore view type
            if (state.v && state.v !== 'tree') {
                if (state.v === 'canvas') {
                    document.getElementById('view-canvas-btn')?.click();
                } else if (state.v === '3d') {
                    document.getElementById('view-3d-btn')?.click();
                }
                // Wait for view transition
                await new Promise(r => setTimeout(r, 300));
            }

            // Restore expanded nodes
            if (state.e && Array.isArray(state.e)) {
                state.e.forEach(nodeId => {
                    const node = document.querySelector(`.tree-node[data-id="${nodeId}"]`);
                    if (node && !node.classList.contains('expanded')) {
                        const toggle = node.querySelector('.expand-toggle');
                        if (toggle) toggle.click();
                    }
                });
            }

            // Restore selected node
            if (state.s) {
                setTimeout(() => {
                    const node = document.querySelector(`.tree-node[data-id="${state.s}"]`);
                    if (node) {
                        node.click();
                        node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }

            // Restore canvas zoom/pan
            if (state.z || state.px || state.py) {
                const container = document.getElementById('canvas-container');
                if (container) {
                    const zoom = state.z || 1;
                    const px = state.px || 0;
                    const py = state.py || 0;
                    container.style.transform = `translate(${px}px, ${py}px) scale(${zoom})`;
                }
            }
        }
        window.restoreViewState = restoreViewState;

        /**
         * Play 3D cinematic splash animation (3 seconds)
         * Slow orbit around the tree before transitioning to target view
         */
        async function play3DSplash(onComplete) {
            console.log('ðŸŽ¬ Starting 3D cinematic splash...');

            // Switch to 3D view
            document.getElementById('view-3d-btn')?.click();
            await new Promise(r => setTimeout(r, 500)); // Wait for 3D to initialize

            // Get Three.js camera and controls
            const view3D = document.getElementById('view-3d');
            if (!view3D || !window.camera || !window.controls) {
                console.warn('3D view not available for splash');
                if (onComplete) onComplete();
                return;
            }

            // Disable user controls during animation
            if (window.controls) {
                window.controls.enabled = false;
            }

            // Cinematic orbit animation
            const startTime = Date.now();
            const duration = 3000; // 3 seconds
            const startAngle = 0;
            const endAngle = Math.PI * 0.75; // 135 degrees
            const radius = 1200;
            const height = 500;

            function animateOrbit() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease-in-out curve
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                const angle = startAngle + (endAngle - startAngle) * eased;

                // Update camera position (orbit)
                window.camera.position.x = Math.cos(angle) * radius;
                window.camera.position.z = Math.sin(angle) * radius;
                window.camera.position.y = height + Math.sin(progress * Math.PI) * 200; // Slight vertical arc
                window.camera.lookAt(0, 100, 0);

                if (progress < 1) {
                    requestAnimationFrame(animateOrbit);
                } else {
                    // Animation complete
                    console.log('ðŸŽ¬ Splash animation complete');
                    if (window.controls) {
                        window.controls.enabled = true;
                    }
                    if (onComplete) {
                        // Fade transition
                        view3D.style.transition = 'opacity 0.5s ease';
                        view3D.style.opacity = '0';
                        setTimeout(() => {
                            view3D.style.opacity = '1';
                            view3D.style.transition = '';
                            onComplete();
                        }, 500);
                    }
                }
            }

            requestAnimationFrame(animateOrbit);
        }
        window.play3DSplash = play3DSplash;

        /**
         * Handle shared link with view state on page load
         */
        function handleSharedViewState() {
            const urlParams = new URLSearchParams(window.location.search);
            const viewStateParam = urlParams.get('vs');
            const splashParam = urlParams.get('splash');

            if (!viewStateParam) return;

            const state = decodeViewState(viewStateParam);
            if (!state) return;

            console.log('ðŸ”— Shared link detected with view state:', state);

            // Wait for tree to load
            setTimeout(() => {
                if (splashParam === '1') {
                    // Play splash then restore view
                    play3DSplash(() => {
                        restoreViewState(state);
                    });
                } else {
                    // Restore view directly
                    restoreViewState(state);
                }
            }, 1000); // Give tree time to render
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(handleSharedViewState, 1500);
        });

        // BUILD 334: Mobile Detection & Touch Support
        document.addEventListener('DOMContentLoaded', () => {
            // Detect mobile device
            const isMobile = window.matchMedia('(max-width: 768px)').matches;
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

            if (isMobile) {
                console.log('ðŸ“± Mobile device detected - compact view enabled');
                document.body.classList.add('mobile-view');

                // Hide Canvas/3D options in view dropdown on mobile (CSS hides the views anyway)
                const canvasBtn = document.getElementById('view-canvas-btn');
                const view3dBtn = document.getElementById('view-3d-btn');
                if (canvasBtn) canvasBtn.style.display = 'none';
                if (view3dBtn) view3dBtn.style.display = 'none';
            }

            // Long-press context menu for touch devices
            if (isTouchDevice) {
                let longPressTimer = null;
                let longPressTarget = null;

                document.addEventListener('touchstart', (e) => {
                    const node = e.target.closest('.tree-node');
                    if (!node) return;

                    longPressTarget = node;
                    node.classList.add('long-press-active');

                    longPressTimer = setTimeout(() => {
                        // Trigger context menu
                        node.classList.remove('long-press-active');

                        // Create a synthetic right-click event at touch position
                        const touch = e.touches[0];
                        const contextEvent = new MouseEvent('contextmenu', {
                            bubbles: true,
                            cancelable: true,
                            clientX: touch.clientX,
                            clientY: touch.clientY
                        });
                        node.dispatchEvent(contextEvent);

                        // Vibrate feedback if available
                        if (navigator.vibrate) navigator.vibrate(50);
                    }, 500); // 500ms long press
                }, { passive: true });

                document.addEventListener('touchend', () => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                    if (longPressTarget) {
                        longPressTarget.classList.remove('long-press-active');
                        longPressTarget = null;
                    }
                });

                document.addEventListener('touchmove', () => {
                    // Cancel long press if finger moves
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                    if (longPressTarget) {
                        longPressTarget.classList.remove('long-press-active');
                        longPressTarget = null;
                    }
                }, { passive: true });

                console.log('ðŸ‘† Touch device - long-press for context menu enabled');
            }

            // BUILD 335: Hamburger Menu Toggle
            const hamburgerBtn = document.getElementById('mobile-menu-btn');
            const controlsMenu = document.querySelector('.header .controls');
            const menuOverlay = document.getElementById('mobile-menu-overlay');

            function openMobileMenu() {
                hamburgerBtn?.classList.add('open');
                controlsMenu?.classList.add('mobile-menu-open');
                menuOverlay?.classList.add('visible');
                hamburgerBtn?.setAttribute('aria-expanded', 'true');
                document.body.style.overflow = 'hidden'; // Prevent scroll
            }

            function closeMobileMenu() {
                hamburgerBtn?.classList.remove('open');
                controlsMenu?.classList.remove('mobile-menu-open');
                menuOverlay?.classList.remove('visible');
                hamburgerBtn?.setAttribute('aria-expanded', 'false');
                document.body.style.overflow = '';
            }

            if (hamburgerBtn) {
                hamburgerBtn.addEventListener('click', () => {
                    const isOpen = hamburgerBtn.classList.contains('open');
                    if (isOpen) {
                        closeMobileMenu();
                    } else {
                        openMobileMenu();
                    }
                });
            }

            // Close menu when clicking overlay
            if (menuOverlay) {
                menuOverlay.addEventListener('click', closeMobileMenu);
            }

            // Close menu when clicking action items (NOT dropdown triggers)
            // Only close for items that perform an action, not for opening submenus
            controlsMenu?.querySelectorAll('.dropdown-menu-item').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Delay close to allow button action to complete
                    setTimeout(closeMobileMenu, 150);
                });
            });

            // For regular buttons, only close if they're action buttons (not dropdown triggers)
            controlsMenu?.querySelectorAll('.btn:not(.dropdown-menu-trigger)').forEach(btn => {
                btn.addEventListener('click', () => {
                    setTimeout(closeMobileMenu, 150);
                });
            });

        });

        // Initialize Project Settings Modal listeners
        document.addEventListener('DOMContentLoaded', () => {
            const cancelBtn = document.getElementById('project-settings-cancel');
            const saveBtn = document.getElementById('project-settings-save');

            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => {
                    document.getElementById('project-settings-modal').classList.remove('open');
                });
            }

            if (saveBtn) {
                saveBtn.addEventListener('click', saveProjectSettings);
            }

            // Close on background click
            const modal = document.getElementById('project-settings-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('open');
                    }
                });
            }
        });

        // Open AI Settings Modal
        function openAISettingsModal() {
            const modal = document.getElementById('ai-settings-modal');
            const config = getAIConfig();

            // Load current settings
            document.querySelector(`input[name="ai-tone"][value="${config.tone}"]`).checked = true;
            document.querySelector(`input[name="ai-verbosity"][value="${config.verbosity}"]`).checked = true;

            const creativityValue = Math.round(config.creativity * 100);
            document.getElementById('creativity-slider').value = creativityValue;
            document.getElementById('creativity-value').textContent = config.creativity.toFixed(1);

            document.getElementById('custom-instructions').value = config.customInstructions;
            
            // Load Dialectic Mode (Cognitive Citadel)
            document.getElementById('ai-dialectic-mode').checked = config.dialecticMode || false;

            // BUILD 396: Load Chat UI preference
            document.getElementById('use-classic-chat').checked = !window.useNewChatUI;

            // Update preview
            updateAIPreview();

            modal.style.display = 'flex';
        }

        // Close AI Settings Modal
        function closeAISettingsModal() {
            document.getElementById('ai-settings-modal').style.display = 'none';
        }

        // Update Live Preview
        function updateAIPreview() {
            const tone = document.querySelector('input[name="ai-tone"]:checked').value;
            const verbosity = document.querySelector('input[name="ai-verbosity"]:checked').value;
            const creativity = document.getElementById('creativity-slider').value / 100;
            const customInstructions = document.getElementById('custom-instructions').value;
            const dialecticMode = document.getElementById('ai-dialectic-mode').checked;

            // Build preview tuning
            let tuning = "";

            if (tone === 'critical') {
                tuning += "ROLE ADAPTATION: You are a ruthless Red Team critic. Challenge assumptions. Find flaws. Do not be polite.\n";
            } else if (tone === 'socratic') {
                tuning += "ROLE ADAPTATION: Do not give answers directly. Ask probing questions to guide the user to discover the solution themselves.\n";
            } else if (tone === 'enthusiastic') {
                tuning += "ROLE ADAPTATION: Be high-energy and encouraging. Focus on opportunities and 'yes, and' thinking. Use energizing language.\n";
            }

            if (verbosity === 'concise') {
                tuning += "OUTPUT STYLE: Be extremely brief. Use telegraphic style. No fluff. Bullet points preferred.\n";
            } else if (verbosity === 'verbose') {
                tuning += "OUTPUT STYLE: Be thorough and detailed. Explain reasoning fully. Provide comprehensive analysis with examples.\n";
            }

            if (dialecticMode) {
                tuning += "ðŸ›¡ï¸ DIALECTIC MODE: Identify assumptions and counter-arguments before helping.\n";
            }

            if (customInstructions.trim()) {
                tuning += `\nUSER PRIORITY INSTRUCTION: ${customInstructions.trim()}\n`;
            }

            const basePrompt = "You are an expert project manager specializing in breaking down complex tasks...";
            const finalPrompt = tuning ? `${tuning}\n${basePrompt}` : basePrompt;

            document.getElementById('preview-after').textContent = finalPrompt;
        }

        // Save AI Settings
        function saveAISettings() {
            const tone = document.querySelector('input[name="ai-tone"]:checked').value;
            const verbosity = document.querySelector('input[name="ai-verbosity"]:checked').value;
            const creativity = document.getElementById('creativity-slider').value / 100;
            const customInstructions = document.getElementById('custom-instructions').value;
            const dialecticMode = document.getElementById('ai-dialectic-mode').checked;

            // BUILD 396: Save Chat UI preference
            const useClassic = document.getElementById('use-classic-chat').checked;
            window.useNewChatUI = !useClassic;
            localStorage.setItem('useNewChatUI', String(!useClassic));

            // Close any open chat panels if switching UI mode
            if (typeof chatState !== 'undefined' && chatState.isOpen) {
                if (typeof toggleChatPanel === 'function') toggleChatPanel();
            }

            // Save to tree
            capexTree.aiConfig = {
                tone,
                verbosity,
                creativity,
                dialecticMode,
                customInstructions
            };

            // Persist to localStorage
            if (typeof treeManager !== 'undefined') { treeManager.markAsChanged(); }

            console.log('âœ… AI Settings saved:', capexTree.aiConfig);

            // Show toast notification
            const uiMode = window.useNewChatUI ? 'Command Frame' : 'Classic Panel';
            showToast(`âœ… AI Settings Saved - Chat UI: ${uiMode}`);

            closeAISettingsModal();
        }

        // Reset to Defaults
        function resetAISettings() {
            document.querySelector('input[name="ai-tone"][value="neutral"]').checked = true;
            document.querySelector('input[name="ai-verbosity"][value="concise"]').checked = true;
            document.getElementById('creativity-slider').value = 50;
            document.getElementById('creativity-value').textContent = '0.5';
            document.getElementById('custom-instructions').value = '';
            document.getElementById('ai-dialectic-mode').checked = false;

            updateAIPreview();
        }

        // Event Listeners for AI Settings Modal
        window.addEventListener('DOMContentLoaded', () => {
            // AI Settings button
            const aiSettingsBtn = document.getElementById('ai-settings-btn');
            if (aiSettingsBtn) {
                aiSettingsBtn.addEventListener('click', openAISettingsModal);
            }

            // Tone radio buttons
            const toneRadios = document.querySelectorAll('input[name="ai-tone"]');
            toneRadios.forEach(radio => {
                radio.addEventListener('change', updateAIPreview);
            });

            // Verbosity radio buttons
            const verbosityRadios = document.querySelectorAll('input[name="ai-verbosity"]');
            verbosityRadios.forEach(radio => {
                radio.addEventListener('change', updateAIPreview);
            });

            // Creativity slider
            const slider = document.getElementById('creativity-slider');
            if (slider) {
                slider.addEventListener('input', (e) => {
                    const value = (e.target.value / 100).toFixed(1);
                    document.getElementById('creativity-value').textContent = value;
                    updateAIPreview();
                });
            }

            // Custom instructions
            const customInstructions = document.getElementById('custom-instructions');
            if (customInstructions) {
                customInstructions.addEventListener('input', updateAIPreview);
            }

            // Dialectic Mode checkbox (Cognitive Citadel)
            const dialecticCheckbox = document.getElementById('ai-dialectic-mode');
            if (dialecticCheckbox) {
                dialecticCheckbox.addEventListener('change', updateAIPreview);
            }

            // Pattern selector - handle pattern switching with translation
            const patternSelect = document.getElementById('pattern-select');
            if (patternSelect) {
                patternSelect.addEventListener('change', (e) => {
                    const oldPattern = currentPattern;
                    const newPattern = e.target.value;

                    // Check if a translation rule exists
                    const ruleKey = `${oldPattern}->${newPattern}`;
                    if (TRANSLATION_RULES[ruleKey]) {
                        const patternNames = {
                            generic: 'Generic Project',
                            sales: 'Sales Pipeline',
                            thesis: 'Academic Writing',
                            roadmap: 'Product Roadmap',
                            book: 'Book Writing',
                            film: 'Film Production',
                            veo3: 'Veo3 (Google)',
                            sora2: 'Sora2 (OpenAI)',
                            prompting: 'AI Prompt Design',
                            gmail: 'Gmail Threads',
                            eventplanning: 'Event Planning',
                            fitness: 'Fitness Program',
                            strategy: 'Strategy Consulting',
                            coursedesign: 'Course Design',
                            familytree: 'Family Tree',
                            philosophy: 'Philosophy Dialogue',
                            rhetoric: 'Rhetoric Analysis',
                            filesystem: 'Filesystem',
                            capex: 'CAPEX / Angel Pitch'
                        };

                        const confirmTranslation = confirm(
                            `âœ¨ Translate data from ${patternNames[oldPattern] || oldPattern} to ${patternNames[newPattern] || newPattern}?\n\n` +
                            `This will intelligently map fields (e.g., Cost â†’ Deal Value).\n\n` +
                            `Your original data will be preserved in shadow storage and can be restored.`
                        );

                        if (confirmTranslation) {
                            // Save state for undo
                            saveState(`Pattern Switch: ${oldPattern} â†’ ${newPattern}`);

                            // Apply translation
                            translateTree(oldPattern, newPattern);

                            // Update current pattern
                            currentPattern = newPattern;

                            // Re-render
                            render();

                            // Update cluster-by options for new pattern
                            if (typeof updateClusterByOptions === 'function') {
                                updateClusterByOptions();
                            }

                            showToast('âœ… Data translated successfully', `Fields mapped from ${patternNames[oldPattern]} to ${patternNames[newPattern]}`);
                        } else {
                            // User cancelled - revert dropdown
                            e.target.value = oldPattern;
                        }
                    } else {
                        // No translation rule - just switch pattern
                        saveState(`Pattern Switch: ${oldPattern} â†’ ${newPattern}`);
                        currentPattern = newPattern;
                        render();

                        // Update cluster-by options for new pattern
                        if (typeof updateClusterByOptions === 'function') {
                            updateClusterByOptions();
                        }
                    }
                });
            }
        });

        // =============================================================================
        // END AI TUNER
        // =============================================================================

        // =============================================================================
        // PATTERN TRANSLATION ENGINE - Shadow Data Preservation
        // =============================================================================

        // Translation rules: Map fields from one pattern to another
        const TRANSLATION_RULES = {
            'generic->sales': (item) => {
                const updates = {};

                // 1. Map Cost â†’ Deal Value
                if (item.cost !== undefined && item.cost !== null) {
                    updates.dealValue = item.cost;
                }

                // 2. Map Status â†’ Stage Probability (Heuristic)
                if (item.pmStatus) {
                    if (item.pmStatus === 'Done' || item.pmStatus === 'Completed') {
                        updates.stageProbability = 100;
                    } else if (item.pmStatus === 'In Progress') {
                        updates.stageProbability = 60;
                    } else {
                        updates.stageProbability = 10;
                    }
                }

                // 3. Map Lead Time â†’ Notes (preserve as context)
                if (item.leadTime) {
                    updates.notes = (item.notes || '') + `\n[Original Lead Time: ${item.leadTime}]`;
                }

                // 4. Map Owner Email â†’ Contact Person
                if (item.pmOwnerEmail) {
                    updates.contactPerson = item.pmOwnerEmail;
                }

                // 5. Map Description
                if (item.description) {
                    updates.description = item.description;
                }

                return updates;
            },

            'sales->generic': (item) => {
                const updates = {};

                // Reverse mapping: Sales â†’ Generic
                if (item.dealValue !== undefined && item.dealValue !== null) {
                    updates.cost = item.dealValue;
                }

                if (item.stageProbability !== undefined) {
                    if (item.stageProbability >= 90) {
                        updates.pmStatus = 'Done';
                    } else if (item.stageProbability >= 50) {
                        updates.pmStatus = 'In Progress';
                    } else {
                        updates.pmStatus = 'Not Started';
                    }
                }

                if (item.contactPerson) {
                    updates.pmOwnerEmail = item.contactPerson;
                }

                return updates;
            }
        };

        // Recursively translate a node and its children
        function translateNode(node, fromPattern, toPattern) {
            const ruleKey = `${fromPattern}->${toPattern}`;
            const translator = TRANSLATION_RULES[ruleKey];

            if (!translator) {
                console.log(`âš ï¸ No translation rule for ${ruleKey}`);
                return; // No rule exists
            }

            // 1. Initialize shadow storage if missing
            if (!node.shadowData) {
                node.shadowData = {};
            }

            // 2. Backup current pattern data (only fields being translated)
            if (!node.shadowData[fromPattern]) {
                node.shadowData[fromPattern] = {};
                // Store only fields that will be changed
                const updates = translator(node);
                Object.keys(updates).forEach(key => {
                    if (node[key] !== undefined) {
                        node.shadowData[fromPattern][key] = node[key];
                    }
                });
            }

            // 3. Apply translation updates
            const updates = translator(node);
            Object.assign(node, updates);

            console.log(`âœ… Translated node: ${node.name}`, updates);

            // 4. Process children recursively
            if (node.items) {
                node.items.forEach(child => translateNode(child, fromPattern, toPattern));
            }
            if (node.children) {
                node.children.forEach(child => translateNode(child, fromPattern, toPattern));
            }
            if (node.subItems) {
                node.subItems.forEach(child => translateNode(child, fromPattern, toPattern));
            }
        }

        // Translate entire tree
        function translateTree(fromPattern, toPattern) {
            console.log(`ðŸ”„ Starting tree translation: ${fromPattern} â†’ ${toPattern}`);

            // Start from root's children (phases)
            if (capexTree.children) {
                capexTree.children.forEach(phase => {
                    translateNode(phase, fromPattern, toPattern);
                });
            }

            console.log(`âœ… Tree translation complete`);
        }

        // =============================================================================
        // END PATTERN TRANSLATION ENGINE
        // =============================================================================

        // =============================================================================
        // REAL AI INTEGRATION - Claude by Anthropic (via Netlify Function)
        // =============================================================================

        // API Configuration - Supports both local API key and Netlify serverless function
        const AI_CONFIG = {
            provider: 'anthropic',
            get model() {
                // Dynamic model selection - user can choose Haiku (fast) or Sonnet (best)
                return getClaudeModelId();
            },
            // Netlify function endpoint (fallback)
            apiEndpoint: 'https://treelisty.netlify.app/.netlify/functions/claude-proxy',
            // Direct Anthropic API endpoint (when using local API key)
            directEndpoint: 'https://api.anthropic.com/v1/messages'
        };

        // Multi-provider API key management
        function getLocalAPIKey(provider = 'anthropic') {
            return localStorage.getItem(`${provider}_api_key`);
        }

        function setLocalAPIKey(key, provider = 'anthropic') {
            localStorage.setItem(`${provider}_api_key`, key);
        }

        function clearLocalAPIKey(provider = 'anthropic') {
            localStorage.removeItem(`${provider}_api_key`);
        }

        // Get AI provider preference
        function getAIProvider() {
            return localStorage.getItem('ai_provider') || 'anthropic';
        }

        function setAIProvider(provider) {
            localStorage.setItem('ai_provider', provider);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // OPTIMIZED MODEL SELECTION FOR IMPORT/APPEND (A/B tested results)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Based on extensive A/B testing comparing Claude Sonnet, Opus, Gemini Flash,
        // Gemini Pro, and GPT-4o across CAPEX and Philosophy patterns.
        //
        // Results showed +13.9% improvement using pattern-specific models vs single model
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const OPTIMIZED_IMPORT_MODELS = {
            // Philosophy patterns: Claude Opus excels at scholarly analysis, cross-references
            philosophy: {
                provider: 'anthropic',
                model: 'claude-opus-4-20250514',
                name: 'Claude Opus 4',
                score: 90,
                strengths: ['Scholarly citations', 'Argument structure', 'Technical terminology']
            },
            // CAPEX/business patterns: Claude Sonnet best for structured data, costs, vendors
            capex: {
                provider: 'anthropic',
                model: 'claude-sonnet-4-20250514',
                name: 'Claude Sonnet 4',
                score: 98,
                strengths: ['Cost extraction', 'Vendor tracking', 'Dependency detection']
            },
            generic: {
                provider: 'anthropic',
                model: 'claude-sonnet-4-20250514',
                name: 'Claude Sonnet 4',
                score: 95,
                strengths: ['General structure', 'Balanced performance']
            },
            sales: {
                provider: 'anthropic',
                model: 'claude-sonnet-4-20250514',
                name: 'Claude Sonnet 4',
                score: 96,
                strengths: ['Deal tracking', 'Pipeline structure', 'Contact management']
            },
            thesis: {
                provider: 'anthropic',
                model: 'claude-opus-4-20250514',
                name: 'Claude Opus 4',
                score: 89,
                strengths: ['Academic structure', 'Citation handling', 'Argument flow']
            },
            // Default for patterns not specifically tested
            default: {
                provider: 'anthropic',
                model: 'claude-sonnet-4-20250514',
                name: 'Claude Sonnet 4',
                score: 90,
                strengths: ['General purpose', 'Good balance of speed and quality']
            }
        };

        /**
         * Get the optimized model for importing/appending based on pattern
         * Returns the model config from A/B testing results
         */
        function getOptimizedImportModel(pattern) {
            // Check if user has the required API key for the optimized model
            const config = OPTIMIZED_IMPORT_MODELS[pattern] || OPTIMIZED_IMPORT_MODELS.default;

            // If Opus is recommended but user doesn't have Anthropic key, fall back
            if (config.model.includes('opus') && !getLocalAPIKey('anthropic')) {
                console.log(`âš ï¸ Opus recommended for ${pattern} but no API key - using Sonnet via proxy`);
                return OPTIMIZED_IMPORT_MODELS.default;
            }

            console.log(`ðŸŽ¯ Optimized model for ${pattern}: ${config.name} (${config.score}% accuracy)`);
            return config;
        }

        // Get redundancy mode preference
        function getRedundancyMode() {
            return localStorage.getItem('ai_redundancy_mode') === 'true';
        }

        function setRedundancyMode(enabled) {
            localStorage.setItem('ai_redundancy_mode', enabled.toString());
        }

        // Unified AI Mode management (combines provider, model, and processing mode)
        function getUnifiedAIMode() {
            return localStorage.getItem('unified_ai_mode') || 'server-sonnet';
        }

        function setUnifiedAIMode(mode) {
            localStorage.setItem('unified_ai_mode', mode);
            console.log(`âœ… Unified AI mode set to: ${mode}`);

            // Update the dropdown
            const select = document.getElementById('unified-ai-mode-select');
            if (select) {
                select.value = mode;
            }
        }

        // Parse unified mode into components
        function parseUnifiedMode(mode = null) {
            const unifiedMode = mode || getUnifiedAIMode();

            if (unifiedMode === 'off') {
                return {
                    enabled: false,
                    provider: null,
                    model: null,
                    mode: 'off',
                    requiresKey: false,
                    description: 'AI features disabled'
                };
            }

            // Model definitions - all available models with their API IDs and metadata
            const MODEL_DEFINITIONS = {
                // Claude models (server = uses our Netlify proxy key, user = user's key)
                'server-haiku': {
                    provider: 'anthropic',
                    model: 'haiku',
                    modelId: 'claude-3-haiku-20240307',
                    useServerKey: true,
                    description: 'Fast & cheap - 200 req/hr limit'
                },
                'server-sonnet': {
                    provider: 'anthropic',
                    model: 'sonnet',
                    modelId: 'claude-sonnet-4-20250514',
                    useServerKey: true,
                    description: 'Best reasoning - 200 req/hr limit'
                },
                'user-haiku': {
                    provider: 'anthropic',
                    model: 'haiku',
                    modelId: 'claude-3-5-haiku-20241022',
                    useServerKey: false,
                    description: 'Fast - Claude 3.5 Haiku (~$1/1M in, $5/1M out)'
                },
                'user-sonnet': {
                    provider: 'anthropic',
                    model: 'sonnet',
                    modelId: 'claude-sonnet-4-20250514',
                    useServerKey: false,
                    description: 'Best reasoning (~$3/1M in, $15/1M out)'
                },
                'user-opus': {
                    provider: 'anthropic',
                    model: 'opus',
                    modelId: 'claude-opus-4-20250514',
                    useServerKey: false,
                    description: 'Most capable (~$15/1M in, $75/1M out)'
                },
                'user-opus45': {
                    provider: 'anthropic',
                    model: 'opus45',
                    modelId: 'claude-opus-4-5-20251101',
                    useServerKey: false,
                    description: 'Frontier model (~$15/1M in, $75/1M out)'
                },
                // Gemini models (always user key, direct API = no timeout!)
                'user-gemini-flash': {
                    provider: 'gemini',
                    model: 'gemini-flash',
                    modelId: 'gemini-2.5-flash',
                    useServerKey: false,
                    description: 'Fast - Gemini 2.5 Flash (Stable)'
                },
                'user-gemini-pro': {
                    provider: 'gemini',
                    model: 'gemini-pro',
                    modelId: 'gemini-2.5-pro',
                    useServerKey: false,
                    description: 'Best reasoning - Gemini 2.5 Pro (Stable)'
                },
                'user-gemini-3-pro': {
                    provider: 'gemini',
                    model: 'gemini-3-pro',
                    modelId: 'gemini-3-pro-preview',
                    useServerKey: false,
                    description: 'Frontier - Gemini 3 Pro Preview (Nov 2025)'
                },
                // Legacy: user-gemini maps to flash
                'user-gemini': {
                    provider: 'gemini',
                    model: 'gemini-flash',
                    modelId: 'gemini-2.5-flash',
                    useServerKey: false,
                    description: 'Gemini 2.5 Flash'
                },
                // OpenAI models (always user key, direct API = no timeout!)
                // BUILD 392: Added GPT-5.2 models (released Dec 11, 2025)
                'user-gpt52-pro': {
                    provider: 'openai',
                    model: 'gpt-5.2-pro',
                    modelId: 'gpt-5.2-pro',
                    useServerKey: false,
                    description: 'Most Accurate - GPT-5.2 Pro (Dec 2025)'
                },
                'user-gpt52': {
                    provider: 'openai',
                    model: 'gpt-5.2',
                    modelId: 'gpt-5.2',
                    useServerKey: false,
                    description: 'Flagship - GPT-5.2 (Dec 2025)'
                },
                'user-gpt52-chat': {
                    provider: 'openai',
                    model: 'gpt-5.2-chat-latest',
                    modelId: 'gpt-5.2-chat-latest',
                    useServerKey: false,
                    description: 'ChatGPT Model - GPT-5.2 Chat'
                },
                'user-gpt5': {
                    provider: 'openai',
                    model: 'gpt-5',
                    modelId: 'gpt-5',
                    useServerKey: false,
                    description: 'Previous Gen - GPT-5 (Aug 2025)'
                },
                'user-gpt5-mini': {
                    provider: 'openai',
                    model: 'gpt-5-mini',
                    modelId: 'gpt-5-mini',
                    useServerKey: false,
                    description: 'Fast - GPT-5 Mini'
                },
                'user-o3': {
                    provider: 'openai',
                    model: 'o3',
                    modelId: 'o3',
                    useServerKey: false,
                    description: 'Best reasoning - o3'
                },
                'user-o4-mini': {
                    provider: 'openai',
                    model: 'o4-mini',
                    modelId: 'o4-mini',
                    useServerKey: false,
                    description: 'Fast reasoning - o4-mini'
                },
                'user-gpt4o': {
                    provider: 'openai',
                    model: 'gpt-4o',
                    modelId: 'gpt-4o',
                    useServerKey: false,
                    description: 'Legacy - GPT-4o'
                },
                // Legacy mappings
                'user-gpt4o-mini': {
                    provider: 'openai',
                    model: 'gpt-5-mini',
                    modelId: 'gpt-5-mini',
                    useServerKey: false,
                    description: 'Redirects to GPT-5 Mini'
                },
                'user-o1': {
                    provider: 'openai',
                    model: 'o3',
                    modelId: 'o3',
                    useServerKey: false,
                    description: 'Redirects to o3'
                },
                'user-chatgpt': {
                    provider: 'openai',
                    model: 'gpt-5.2-chat-latest',
                    modelId: 'gpt-5.2-chat-latest',
                    useServerKey: false,
                    description: 'GPT-5.2 Chat (Latest)'
                }
            };

            const modelDef = MODEL_DEFINITIONS[unifiedMode];

            if (!modelDef) {
                console.warn(`Unknown AI mode: ${unifiedMode}, falling back to server-sonnet`);
                return parseUnifiedMode('server-sonnet');
            }

            // Determine processing mode: server key = quick (10s limit), user key = deep (no limit for Gemini/ChatGPT)
            const processingMode = modelDef.useServerKey ? 'quick' : 'deep';

            return {
                enabled: true,
                provider: modelDef.provider,
                model: modelDef.model,
                modelId: modelDef.modelId,
                mode: processingMode,
                useServerKey: modelDef.useServerKey,
                requiresKey: !modelDef.useServerKey,
                description: modelDef.description
            };
        }

        // Legacy compatibility functions (for existing code)
        function getGlobalAIMode() {
            const parsed = parseUnifiedMode();
            return parsed.enabled ? parsed.mode : 'off';
        }

        function getAIProvider() {
            const parsed = parseUnifiedMode();
            return parsed.provider || 'anthropic';
        }

        function getClaudeModelId() {
            const parsed = parseUnifiedMode();
            return parsed.modelId || 'claude-sonnet-4-20250514';
        }

        function canUseServerlessAI() {
            return Boolean(AI_CONFIG && typeof AI_CONFIG.apiEndpoint === 'string' && AI_CONFIG.apiEndpoint.length > 0);
        }

        function showApiKeyModal(prefillExisting = false) {
            const apiKeyModal = document.getElementById('api-key-modal');
            const claudeInput = document.getElementById('claude-api-key-input');
            const geminiInput = document.getElementById('gemini-api-key-input');
            const openaiInput = document.getElementById('openai-api-key-input');
            const providerSelect = document.getElementById('provider-select');

            // Load existing keys
            const claudeKey = getLocalAPIKey('anthropic');
            const geminiKey = getLocalAPIKey('gemini');
            const openaiKey = getLocalAPIKey('openai');
            const currentProvider = getAIProvider();

            // Prefill keys if requested
            claudeInput.value = prefillExisting && claudeKey ? claudeKey : '';
            geminiInput.value = prefillExisting && geminiKey ? geminiKey : '';
            openaiInput.value = prefillExisting && openaiKey ? openaiKey : '';

            // Set provider dropdown
            providerSelect.value = currentProvider;

            // Update status badges
            updateKeyStatusBadges();

            // Reset show checkbox
            document.getElementById('api-key-show').checked = false;

            apiKeyModal.style.display = 'flex';
        }

        function updateKeyStatusBadges() {
            const claudeStatus = document.getElementById('claude-key-status');
            const geminiStatus = document.getElementById('gemini-key-status');
            const openaiStatus = document.getElementById('openai-key-status');

            const claudeKey = getLocalAPIKey('anthropic');
            const geminiKey = getLocalAPIKey('gemini');
            const openaiKey = getLocalAPIKey('openai');

            if (claudeKey) {
                claudeStatus.textContent = 'âœ“ Saved';
                claudeStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                claudeStatus.style.color = '#22c55e';
            } else {
                claudeStatus.textContent = 'Not saved';
                claudeStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                claudeStatus.style.color = '#9ca3af';
            }

            if (geminiKey) {
                geminiStatus.textContent = 'âœ“ Saved';
                geminiStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                geminiStatus.style.color = '#22c55e';
            } else {
                geminiStatus.textContent = 'Not saved';
                geminiStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                geminiStatus.style.color = '#9ca3af';
            }

            if (openaiKey) {
                openaiStatus.textContent = 'âœ“ Saved';
                openaiStatus.style.background = 'rgba(34, 197, 94, 0.2)';
                openaiStatus.style.color = '#22c55e';
            } else {
                openaiStatus.textContent = 'Not saved';
                openaiStatus.style.background = 'rgba(156, 163, 175, 0.2)';
                openaiStatus.style.color = '#9ca3af';
            }
        }

        // Helper: Direct API call to Anthropic (bypasses Netlify, no timeout limit)
        async function callClaudeDirectAPI(requestData, apiKey) {
            console.log('ðŸš€ Direct API: Calling Anthropic Claude directly (no Netlify timeout)');

            try {
                const response = await fetch(AI_CONFIG.directEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    throw new Error(error.error?.message || `Claude API error: ${response.status}`);
                }

                return response;
            } catch (error) {
                // CORS errors show as "Failed to fetch" or TypeError
                if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
                    console.error('âŒ CORS Error: Browser blocked direct API call to api.anthropic.com');
                    throw new Error('Failed to fetch'); // Re-throw for upstream handling
                }
                throw error;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 251: Edge Function Streaming API (No Timeout!)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Call Claude via Edge Function with streaming (SSE)
         * This bypasses Netlify's 10-second timeout by using Edge Functions
         * which have no timeout for streaming responses.
         *
         * @param {object} requestData - The Anthropic API request body
         * @param {string|null} userApiKey - Optional user API key
         * @param {function|null} onDelta - Optional callback for streaming deltas
         * @returns {Promise<string>} The complete response text
         */
        async function callClaudeStreamingAPI(requestData, userApiKey = null, onDelta = null) {
            const STREAMING_ENDPOINT = '/api/claude-stream';

            console.log('ðŸŒŠ Streaming: Using Edge Function (no timeout limit)');

            // Check if we're on deployed site (Edge Functions only work deployed)
            const isLocalFile = window.location.protocol === 'file:';
            if (isLocalFile) {
                throw new Error('STREAMING_NOT_AVAILABLE_LOCAL');
            }

            const requestBody = {
                ...requestData,
                userApiKey: userApiKey || undefined,
                stream: true, // Tell Edge Function we want streaming
            };

            try {
                const response = await fetch(STREAMING_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('âŒ Streaming API error:', response.status, errorText);
                    throw new Error(`Streaming API error: ${response.status}`);
                }

                // Read SSE stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let fullText = '';

                while (true) {
                    const { done, value } = await reader.read();

                    if (done) {
                        break;
                    }

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete SSE events
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);

                            if (data === '[DONE]') {
                                continue;
                            }

                            try {
                                const event = JSON.parse(data);

                                if (event.type === 'delta' && event.text) {
                                    fullText = event.accumulated || (fullText + event.text);

                                    // Call delta callback if provided (for UI updates)
                                    if (onDelta && typeof onDelta === 'function') {
                                        onDelta(event.text, fullText);
                                    }
                                }

                                if (event.type === 'message_complete') {
                                    fullText = event.content || fullText;
                                    console.log('âœ… Streaming complete:', {
                                        tokens: event.usage,
                                        model: event.model
                                    });
                                }

                                if (event.type === 'thinking_start') {
                                    console.log('ðŸ§  Extended Thinking started...');
                                }

                                if (event.error) {
                                    throw new Error(event.error);
                                }
                            } catch (parseError) {
                                if (parseError.message !== 'Unexpected end of JSON input') {
                                    console.warn('SSE parse error:', parseError);
                                }
                            }
                        }
                    }
                }

                return fullText;

            } catch (error) {
                console.error('âŒ Streaming failed:', error);
                throw error;
            }
        }

        /**
         * Call Claude via Edge Function (buffered mode - no streaming UI)
         * Still uses Edge Function for no timeout, but returns complete response
         */
        async function callClaudeEdgeBuffered(requestData, userApiKey = null) {
            const STREAMING_ENDPOINT = '/api/claude-stream';

            console.log('ðŸ“¦ Edge Buffered: Using Edge Function without streaming');

            const requestBody = {
                ...requestData,
                userApiKey: userApiKey || undefined,
                stream: false, // Tell Edge Function to buffer response
            };

            const response = await fetch(STREAMING_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Edge API error: ${response.status}`);
            }

            return response;
        }

        /**
         * Optimized API call for Import/Append operations
         * Uses pattern-specific models from A/B testing for best results
         * Automatically handles streaming via Edge Function for no timeout
         */
        async function callOptimizedImportAPI(prompt, systemPrompt, maxTokens, pattern) {
            const modelConfig = getOptimizedImportModel(pattern);
            const apiKey = getLocalAPIKey('anthropic');
            const isLocalFile = window.location.protocol === 'file:';

            console.log(`ðŸŽ¯ Optimized Import: Using ${modelConfig.name} for ${pattern} pattern`);

            // Build request data with optimized model
            const requestData = {
                model: modelConfig.model,
                max_tokens: maxTokens,
                system: systemPrompt,
                messages: [{ role: 'user', content: prompt }]
            };

            // Use streaming Edge Function for no timeout
            if (!isLocalFile) {
                try {
                    console.log('ðŸŒŠ Using Edge Function streaming for optimized import...');
                    const result = await callClaudeStreamingAPI(
                        { ...requestData, userApiKey: apiKey },
                        apiKey,
                        null // no delta callback needed
                    );
                    console.log(`âœ… Optimized import complete via Edge Function`);
                    return result;
                } catch (edgeError) {
                    console.warn('âš ï¸ Edge Function failed, trying fallback:', edgeError.message);
                }
            }

            // Fallback to regular API if Edge Function unavailable
            const response = await fetch(AI_CONFIG.apiEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    ...requestData,
                    userApiKey: apiKey
                })
            });

            if (!response.ok) {
                throw new Error(`Import API error: ${response.status}`);
            }

            const data = await response.json();
            return data.content?.[0]?.text || '';
        }

        // Helper: Direct API call to Google Gemini
        async function callGeminiDirectAPI(prompt, systemPrompt, maxTokens, apiKey) {
            console.log('ðŸš€ Direct API: Calling Google Gemini directly');

            // Enhanced default prompt with TreeListy context for Gemini
            const geminiDefaultPrompt = `You are an expert project analyst within TreeListy, a hierarchical project decomposition tool.

TREELISTY CONTEXT:
- 4-level hierarchy: Root â†’ Phases (children) â†’ Items (items) â†’ Subtasks (subItems)
- 19 patterns: generic, philosophy, sales, thesis, roadmap, book, event, fitness, strategy, course, prompting, film, veo3, sora2, dialogue, familytree, filesystem, gmail, freespeech
- Each pattern has unique fields for domain-specific data`;

            const effectiveSystemPrompt = systemPrompt || geminiDefaultPrompt;

            // Gemini API format is different from Claude
            const geminiRequest = {
                contents: [{
                    parts: [{
                        text: (effectiveSystemPrompt ? effectiveSystemPrompt + '\n\n' : '') + prompt
                    }]
                }],
                generationConfig: {
                    maxOutputTokens: maxTokens,
                    temperature: 0.7
                }
            };

            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(geminiRequest)
                }
            );

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `Gemini API error: ${response.status}`);
            }

            const data = await response.json();

            // Convert Gemini response format to Claude-like format for consistency
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                throw new Error('Invalid Gemini response structure');
            }

            return {
                json: async () => ({
                    content: [{
                        text: data.candidates[0].content.parts[0].text
                    }]
                }),
                ok: true
            };
        }

        // Helper: Direct API call to OpenAI ChatGPT
        async function callOpenAIDirectAPI(prompt, systemPrompt, maxTokens, apiKey) {
            console.log('ðŸš€ Direct API: Calling OpenAI ChatGPT directly');

            // OpenAI API format
            // Enhanced default prompt with TreeListy context for OpenAI
            const openaiDefaultPrompt = `You are an expert project analyst within TreeListy, a hierarchical project decomposition tool.

TREELISTY CONTEXT:
- 4-level hierarchy: Root â†’ Phases (children) â†’ Items (items) â†’ Subtasks (subItems)
- 19 patterns: generic, philosophy, sales, thesis, roadmap, book, event, fitness, strategy, course, prompting, film, veo3, sora2, dialogue, familytree, filesystem, gmail, freespeech
- Each pattern has unique fields for domain-specific data`;

            const openaiRequest = {
                model: 'gpt-4o', // Using GPT-4o (latest optimized model)
                max_tokens: maxTokens,
                temperature: 0.7,
                messages: [
                    {
                        role: 'system',
                        content: systemPrompt || openaiDefaultPrompt
                    },
                    {
                        role: 'user',
                        content: prompt
                    }
                ]
            };

            const response = await fetch(
                'https://api.openai.com/v1/chat/completions',
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(openaiRequest)
                }
            );

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `OpenAI API error: ${response.status}`);
            }

            const data = await response.json();

            // Convert OpenAI response format to Claude-like format for consistency
            if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                throw new Error('Invalid OpenAI response structure');
            }

            return {
                json: async () => ({
                    content: [{
                        text: data.choices[0].message.content
                    }]
                }),
                ok: true
            };
        }

        // Unified AI API caller - supports multiple providers (Claude, Gemini, OpenAI)
        async function callClaudeAPI(prompt, systemPrompt = '', maxTokens = 1024, useExtendedThinking = false, retryCount = 0) {
            const MAX_RETRIES = 2;
            const provider = getAIProvider();

            // Apply AI Tuner persona settings to system prompt
            systemPrompt = applyPersonaTuning(systemPrompt);

            // Debug logging for Deep Mode routing
            if (useExtendedThinking) {
                console.log('ðŸ” Deep Mode requested:', { provider, useExtendedThinking, hasLocalKey: !!getLocalAPIKey('anthropic') });
            }

            // If Gemini is selected and user has Gemini key, use Gemini directly
            if (provider === 'gemini') {
                const geminiKey = getLocalAPIKey('gemini');
                if (geminiKey) {
                    // Check if running from local file - CORS will block Gemini API
                    const isLocalFile = window.location.protocol === 'file:';
                    if (isLocalFile) {
                        console.error('âŒ Gemini API blocked - running from local file');
                        console.warn('ðŸ’¡ Gemini requires web server deployment to avoid CORS');
                        console.warn('âœ… Solution 1: Deploy to Netlify/Vercel for Gemini support');
                        console.warn('âœ… Solution 2: Use Claude (has proxy fallback for local files)');
                        throw new Error(`Gemini API requires web server deployment (CORS policy).\n\nðŸ’¡ Solutions:\n1. Deploy to Netlify/Vercel - full Gemini support\n2. Use Claude provider - works from local files via proxy\n3. Open in web server (not file://)\n\nðŸ” Running from: ${window.location.protocol}\nâœ… Claude has proxy fallback, Gemini requires deployment`);
                    }

                    console.log('ðŸ”· Using Google Gemini');
                    try {
                        const response = await callGeminiDirectAPI(prompt, systemPrompt, maxTokens, geminiKey);
                        const data = await response.json();
                        return data.content[0].text;
                    } catch (error) {
                        console.error('âŒ Gemini API error:', error);
                        throw new Error(`Gemini error: ${error.message}`);
                    }
                } else {
                    // Gemini selected but no key - show helpful error
                    throw new Error('Gemini API key not found. Please add your Gemini API key (ðŸ”‘ button) or switch to Claude.');
                }
            }

            // If OpenAI is selected and user has OpenAI key, use OpenAI directly
            if (provider === 'openai') {
                const openaiKey = getLocalAPIKey('openai');
                if (openaiKey) {
                    // Check if running from local file - CORS will block OpenAI API
                    const isLocalFile = window.location.protocol === 'file:';
                    if (isLocalFile) {
                        console.error('âŒ ChatGPT API blocked - running from local file');
                        console.warn('ðŸ’¡ ChatGPT requires web server deployment to avoid CORS');
                        console.warn('âœ… Solution 1: Deploy to Netlify/Vercel for ChatGPT support');
                        console.warn('âœ… Solution 2: Use Claude (has proxy fallback for local files)');
                        throw new Error(`ChatGPT API requires web server deployment (CORS policy).\n\nðŸ’¡ Solutions:\n1. Deploy to Netlify/Vercel - full ChatGPT support\n2. Use Claude provider - works from local files via proxy\n3. Open in web server (not file://)\n\nðŸ” Running from: ${window.location.protocol}\nâœ… Claude has proxy fallback, ChatGPT requires deployment`);
                    }

                    console.log('ðŸ’¬ Using OpenAI ChatGPT');
                    try {
                        const response = await callOpenAIDirectAPI(prompt, systemPrompt, maxTokens, openaiKey);
                        const data = await response.json();
                        return data.content[0].text;
                    } catch (error) {
                        console.error('âŒ OpenAI API error:', error);
                        throw new Error(`OpenAI error: ${error.message}`);
                    }
                } else {
                    // OpenAI selected but no key - show helpful error
                    throw new Error('OpenAI API key not found. Please add your OpenAI API key (ðŸ”‘ button) or switch to Claude.');
                }
            }

            // Otherwise, use Claude (existing logic below)
            const localApiKey = getLocalAPIKey('anthropic'); // Get Claude key for Claude logic

            // ENFORCE: Deep Mode requires user API key (consistent with Gemini/ChatGPT)
            if (useExtendedThinking && !localApiKey) {
                throw new Error(`ðŸ§  Deep Mode requires your own API key to avoid Netlify's 10-second timeout.\n\nâœ… Solutions:\n1. Add your Anthropic API key (ðŸ”‘ button) - enables Deep Mode with Extended Thinking\n2. Switch to âš¡ Fast Mode - works with server API key\n\nðŸ’¡ Deep Mode uses Extended Thinking (5000 token reasoning budget) which can take 15-30 seconds - too slow for Netlify's free tier limit.\n\nGemini and ChatGPT also require user API keys for the same reason.`);
            }

            // Apply AI Tuner persona settings to system prompt
            const aiConfig = getAIConfig(); // Get AI config for temperature
            // Enhanced default prompt with TreeListy context
            const defaultSystemPrompt = `You are an expert project analyst specializing in breaking down complex projects into manageable components within TreeListy.

TREELISTY CONTEXT:
- TreeListy uses a 4-level hierarchy: Root â†’ Phases (children) â†’ Items (items) â†’ Subtasks (subItems)
- 19 specialized patterns available: generic, philosophy, sales, thesis, roadmap, book, event, fitness, strategy, course, prompting, film, veo3, sora2, dialogue, familytree, filesystem, gmail, freespeech
- Each pattern has unique fields (e.g., philosophy has speaker, premises, objections; sales has dealValue, probability, closeDate)
- Output JSON must match this structure for proper integration into the tree`;
            const finalSystemPrompt = applyPersonaTuning(systemPrompt || defaultSystemPrompt);

            const requestData = {
                model: AI_CONFIG.model,
                max_tokens: maxTokens,
                temperature: aiConfig.creativity, // âœ… INJECTED: Maps slider (0.0-1.0) to API temperature
                system: finalSystemPrompt,
                messages: [{
                    role: 'user',
                    content: prompt
                }]
            };

            // Use extended thinking for JSON generation to avoid syntax errors
            if (useExtendedThinking) {
                requestData.thinking = {
                    type: "enabled",
                    budget_tokens: 5000  // Increased from 2000 for Deep Mode (more reasoning time)
                };
                // CRITICAL: Temperature MUST be 1 when thinking is enabled
                // https://docs.claude.com/en/docs/build-with-claude/extended-thinking#important-considerations-when-using-extended-thinking
                requestData.temperature = 1;
            }

            let response;

            // CRITICAL: Deep Mode with user key MUST use direct API (never Netlify)
            // Gemini and ChatGPT always use direct API, Sonnet must too

            // Auto-detect local file access (file:// protocol)
            const isLocalFile = window.location.protocol === 'file:';

            if (useExtendedThinking && localApiKey) {
                // Check if running from local file - CORS will block direct API
                if (isLocalFile) {
                    console.warn('âš ï¸ Deep Mode requested but running from local file');
                    console.warn('ðŸ”„ Auto-switching to Fast Mode (Netlify proxy) to avoid CORS');
                    console.warn('ðŸ’¡ Deploy to web server for full Deep Mode support');

                    // Show user-facing info message about the auto-switch
                    console.info('â„¹ï¸ Running from local file - using Fast Mode instead of Deep Mode to avoid CORS errors');
                    console.info('âœ… Fast Mode still works great from local files via Netlify proxy');

                    // Fall through to Fast Mode (Netlify proxy) below
                    // This will work from local files but has 10s timeout limit
                } else {
                    // Running from deployed web server
                    // IMPORTANT: Anthropic's API does NOT allow direct browser calls (CORS blocked)
                    // We MUST use Netlify proxy, but Extended Thinking often exceeds 10s timeout
                    console.warn('âš ï¸ Deep Mode: Anthropic API blocks direct browser calls (CORS policy)');
                    console.warn('ðŸ”„ Using Netlify proxy with Extended Thinking - may timeout on complex requests');
                    console.warn('ðŸ’¡ For guaranteed Deep Mode: Use Gemini (allows direct API) or upgrade to Netlify Pro');

                    // Keep Extended Thinking enabled - let it try via Netlify
                    // User will get timeout error if it takes >10s, but smaller requests may work
                    // Fall through to Netlify proxy below
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 251: Prioritize Edge Function Streaming (No Timeout!)
            // Fallback chain: Edge Stream â†’ Edge Buffered â†’ Regular Function
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Try Edge Function STREAMING first (no timeout - returns headers immediately)
            // CRITICAL: Buffered mode times out at 40s because headers aren't returned until done
            // Streaming mode returns headers immediately, so can run indefinitely
            if (!isLocalFile) {
                try {
                    console.log('ðŸŒŠ Using Edge Function streaming (no timeout limit)...');
                    const result = await callClaudeStreamingAPI(requestData, localApiKey, null);
                    console.log('âœ… Edge Function streaming success!');
                    return result;
                } catch (edgeError) {
                    // Edge Function failed - fall back to regular function
                    console.warn('âš ï¸ Edge Function streaming failed, falling back to regular function:', edgeError.message);
                    // Continue to fallback below
                }
            }

            // Fallback: Regular Netlify Function (has 10s timeout)
            console.log('ðŸ“¦ Using regular Netlify function (10s timeout limit)');
            if (requestData.thinking) {
                console.log('ðŸ§  Deep Mode: Extended Thinking enabled');
                console.log('âš ï¸ Complex requests may timeout on free tier');
            }
            console.log(localApiKey ? 'ðŸ”‘ Using your API key' : 'ðŸŒ Using server API key');

            // Check if we're a guest using host's session keys
            const sessionToken = window.getCollabSessionToken?.() || null;

            const netlifyRequestBody = {
                ...requestData,
                userApiKey: localApiKey || undefined,
                sessionToken: sessionToken || undefined
            };

            if (sessionToken) {
                const hostName = window.getCollabHostName?.() || 'Host';
                console.log(`ðŸŽŸï¸ Using ${hostName}'s API keys via live session`);
            }

            // Timeout for regular function (Netlify has 10s limit)
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 25000);

            try {
                response = await fetch(AI_CONFIG.apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(netlifyRequestBody),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
            } catch (fetchError) {
                clearTimeout(timeoutId);

                // Handle timeout
                if (fetchError.name === 'AbortError' && localApiKey) {
                    if (isLocalFile) {
                        console.warn('âš ï¸ Netlify timeout. Trying direct API...');
                        try {
                            response = await callClaudeDirectAPI(requestData, localApiKey);
                            console.log('âœ… Direct API fallback successful!');
                        } catch (directError) {
                            console.error('âŒ Direct API fallback failed:', directError);
                            throw new Error(`Netlify timeout AND direct API failed.\n\nâœ… Solutions:\n1. Run via local server: python -m http.server 8000\n2. Use deployed site: https://treelisty.netlify.app\n3. Use âš¡ Fast Mode (Haiku) - faster`);
                        }
                    } else {
                        // From deployed site but Edge Function also failed
                        throw new Error(`â±ï¸ Request timeout (Netlify 10-second limit exceeded)

âŒ Claude API doesn't support CORS - cannot bypass Netlify from browser

This happened because:
â€¢ Your request took longer than 10 seconds
â€¢ Netlify free tier has 10-second function timeout
â€¢ Claude's API blocks direct browser calls (CORS policy)
â€¢ Unlike Gemini/ChatGPT, Claude requires a proxy server

âœ… Solutions:
1. Use server-sonnet or server-haiku (Fast Mode) - usually completes in <10s
2. Reduce your request size - fewer nodes, shorter text
3. Self-host with backend that has no timeout limits

ðŸ’¡ The Chat Builder works best with Fast Mode on Netlify.`);
                    }
                } else if (fetchError.name === 'AbortError') {
                    // Timeout but no user API key - can't fallback
                    throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nAdd your API key (ðŸ”‘ button) to bypass Netlify timeout.\n\nOr use âš¡ Fast Mode (Haiku) - faster and works everywhere.`);
                } else {
                    throw fetchError;
                }

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));

                    // Log detailed error info for debugging
                    console.error('âŒ AI API Error Details:', {
                        status: response.status,
                        statusText: response.statusText,
                        usingLocalKey: !!localApiKey,
                        error: error
                    });

                    // Check for common errors
                    if (response.status === 0 || !response.status) {
                        throw new Error('Cannot connect to AI service. Please check your internet connection.');
                    }
                    if (response.status === 401) {
                        if (localApiKey) {
                            clearLocalAPIKey();
                            throw new Error('Invalid API key. Please check your Anthropic API key and try again.');
                        }
                        throw new Error('Authentication failed. Please configure your API key.');
                    }
                    if (response.status === 404) {
                        throw new Error('Netlify function not found (404). The serverless function may not be deployed.');
                    }
                    if (response.status === 504) {
                        // Gateway timeout from Netlify
                        if (localApiKey) {
                            // Fallback to direct API if user has key
                            console.warn('âš ï¸ Netlify 504 timeout. Falling back to direct API...');
                            try {
                                response = await callClaudeDirectAPI(requestData, localApiKey);
                                console.log('âœ… Direct API fallback successful after 504!');
                                // Exit error handling - response is now successful
                            } catch (directError) {
                                console.error('âŒ Direct API fallback failed:', directError);

                                // Check if this is a CORS error
                                if (directError.message === 'Failed to fetch' || directError.name === 'TypeError') {
                                    throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nDirect API fallback blocked by browser (CORS - you're running from file://).\n\nâœ… Solutions:\n1. Run via local server: python -m http.server 8000\n2. Use deployed site: https://treelisty.netlify.app\n3. Use âš¡ Fast Mode (Haiku) - faster and works everywhere\n\nðŸ’¡ Sonnet is powerful but slow - works best on deployed sites or with local server.`);
                                }

                                throw new Error(`Netlify 504 timeout AND direct API failed. Error: ${directError.message}`);
                            }
                        } else {
                            throw new Error(`Sonnet request timeout on Netlify (10s free tier limit).\n\nAdd your API key (ðŸ”‘ button) to bypass Netlify timeout.\n\nOr use âš¡ Fast Mode (Haiku) - faster and works everywhere.`);
                        }
                    }

                    // If response is now ok (after fallback), skip remaining error checks
                    if (response.ok) {
                        // Continue to response parsing below
                    } else if (response.status === 429) {
                        // Rate limit - retry with exponential backoff
                        if (retryCount < MAX_RETRIES) {
                            const delay = Math.pow(2, retryCount) * 3000; // 3s, 6s
                            console.log(`ðŸ”„ Rate limit hit. Retrying in ${delay/1000} seconds... (attempt ${retryCount + 1}/${MAX_RETRIES})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callClaudeAPI(prompt, systemPrompt, maxTokens, useExtendedThinking, retryCount + 1);
                        }
                        throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                    } else if (response.status === 529) {
                        // API overloaded - retry with exponential backoff
                        if (retryCount < MAX_RETRIES) {
                            const delay = Math.pow(2, retryCount) * 2000; // 2s, 4s
                            console.log(`ðŸ”„ API overloaded. Retrying in ${delay/1000} seconds... (attempt ${retryCount + 1}/${MAX_RETRIES})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callClaudeAPI(prompt, systemPrompt, maxTokens, useExtendedThinking, retryCount + 1);
                        }
                        throw new Error('Anthropic API is temporarily overloaded. Please wait 10-30 seconds and try again.');
                    } else if (response.status === 500 && error.error?.message?.includes('configuration')) {
                        throw new Error('AI service is not configured. Please set up your API key.');
                    } else {
                        // Generic error
                        throw new Error(error.error?.message || `AI Service Error: ${response.status}`);
                    }
                }
            } // End of Fast Mode (Netlify) path

            // Common response handling (works for both Deep Mode direct API and Fast Mode Netlify)
            const data = await response.json();
            console.log('âœ… AI analysis successful');
            console.log('API Response data:', data);

            // Handle response - check if content exists
            if (!data.content || !Array.isArray(data.content) || data.content.length === 0) {
                console.error('Invalid API response structure:', data);
                throw new Error('Invalid response from AI service');
            }

            return data.content[0].text;
        }

        // Generate intelligent project analysis
        async function generateAIAnalysis(item, analysisType = 'item') {
            // Determine if this is a subtask or regular item/phase
            const isSubtask = item.type === 'subtask';

            let systemPrompt = '';
            let userPrompt = '';

            if (isSubtask) {
                // SUBTASK AI: Pattern-aware analysis for subtasks
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;

                // Pattern-specific subtask analysis
                if (currentPattern === 'philosophy') {
                    systemPrompt = `You are a philosophy professor specializing in philosophical argumentation and dialectical reasoning.`;

                    userPrompt = `Analyze this philosophical ${levels.subtask.toLowerCase()}:

**${levels.subtask}:** ${item.name}
**Description:** ${item.description || 'N/A'}
${item.textualReference ? `**Textual Reference:** ${item.textualReference}\n` : ''}${item.notes ? `**Notes:** ${item.notes}\n` : ''}
Provide philosophical analysis covering:
1. **Argumentative Function** - How does this support strengthen the parent claim?
2. **Logical Structure** - Is the reasoning valid? Are there gaps?
3. **Evidence Quality** - How strong is the supporting evidence or reasoning?
4. **Objections** - What counter-arguments might challenge this support?
5. **Recommendations** - How to strengthen this supporting argument`;

                } else {
                    // Generic PM analysis for non-philosophy patterns
                    systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                    userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;
                }

            } else if (analysisType === 'subtask') {
                // Fallback - same as isSubtask, pattern-aware
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;

                if (currentPattern === 'philosophy') {
                    systemPrompt = `You are a philosophy professor specializing in philosophical argumentation and dialectical reasoning.`;

                    userPrompt = `Analyze this philosophical ${levels.subtask.toLowerCase()}:

**${levels.subtask}:** ${item.name}
**Description:** ${item.description || 'N/A'}
${item.textualReference ? `**Textual Reference:** ${item.textualReference}\n` : ''}${item.notes ? `**Notes:** ${item.notes}\n` : ''}
Provide philosophical analysis covering:
1. **Argumentative Function** - How does this support strengthen the parent claim?
2. **Logical Structure** - Is the reasoning valid? Are there gaps?
3. **Evidence Quality** - How strong is the supporting evidence or reasoning?
4. **Objections** - What counter-arguments might challenge this support?
5. **Recommendations** - How to strengthen this supporting argument`;

                } else {
                    systemPrompt = `You are an expert project manager specializing in breaking down complex tasks into actionable steps.
Your expertise includes:
- Task decomposition and milestone definition
- Identifying blockers and dependencies
- Creating clear, actionable next steps
- Risk mitigation for project execution
- Best practices for task completion and team coordination

Provide practical, step-by-step guidance formatted with clear sections and bullet points.`;

                    userPrompt = `Help me execute this task for a project:

**Task:** ${item.name}
**Status:** ${item.pmStatus || 'To Do'}
**Assignee:** ${item.pmAssignee || 'Unassigned'}
**Priority:** ${item.pmPriority || 'Medium'}
**Progress:** ${item.pmProgress || 0}%
**Description:** ${item.description || 'N/A'}
${item.pmDueDate ? `**Due Date:** ${new Date(item.pmDueDate).toLocaleDateString()}` : ''}
${item.pmBlockingIssue ? `**Current Blocker:** ${item.pmBlockingIssue}` : ''}
${item.pmNextSteps ? `**Planned Next Steps:** ${item.pmNextSteps}` : ''}
${item.pmNotes ? `**Task Notes:** ${item.pmNotes}` : ''}
${item.pmUpdates && item.pmUpdates.length > 0 ? `**Recent Updates:**\n${item.pmUpdates.slice(0, 3).map(u => `  - ${new Date(u.timestamp).toLocaleDateString()}: ${u.text}`).join('\n')}` : ''}

Help me with:
1. **Task Breakdown** - Break this into 3-5 specific, actionable sub-steps
2. **Success Criteria** - What does "done" look like? Clear completion criteria
3. **Potential Blockers** - What might prevent progress? How to address them
4. **Next Actions** - Immediate next steps to move forward (be specific)
5. **Recommendations** - Best practices, tips, or resources for successful completion

Focus on practical, executable guidance. Be specific and actionable.`;
                }

            } else if (analysisType === 'item') {
                // PROJECT ITEM AI: Pattern-aware analysis
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;

                // Pattern-specific system prompts and analysis
                if (currentPattern === 'philosophy') {
                    systemPrompt = `You are a philosophy professor specializing in classical and contemporary philosophical arguments, dialectical reasoning, and philosophical methodology.`;

                    userPrompt = `Analyze this philosophical ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.speaker ? `**Speaker/Philosopher:** ${item.speaker}\n` : ''}${item.argumentType ? `**Argument Type:** ${item.argumentType}\n` : ''}${item.premise1 ? `**Premise 1:** ${item.premise1}\n` : ''}${item.premise2 ? `**Premise 2:** ${item.premise2}\n` : ''}${item.conclusion ? `**Conclusion:** ${item.conclusion}\n` : ''}${item.keyTerms ? `**Key Terms:** ${item.keyTerms}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a philosophical analysis covering:
1. **Logical Validity** - Is the argument structure sound? Are the premises valid?
2. **Dialectical Strength** - How does this argument engage with opposing views?
3. **Conceptual Clarity** - Are key terms well-defined? Any ambiguities?
4. **Objections to Consider** - What counter-arguments should be addressed?
5. **Historical/Textual Context** - Relevant philosophical traditions or sources
6. **Recommendations** - How to strengthen this argument or explore it further`;

                } else if (currentPattern === 'sales') {
                    systemPrompt = `You are a sales strategist with 20 years of enterprise B2B experience, specializing in deal progression, competitive positioning, and revenue forecasting.`;

                    userPrompt = `Analyze this sales ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.dealValue ? `**Deal Value:** $${(item.dealValue || 0).toLocaleString()}\n` : ''}${item.expectedCloseDate ? `**Expected Close:** ${new Date(item.expectedCloseDate).toLocaleDateString()}\n` : ''}${item.leadSource ? `**Lead Source:** ${item.leadSource}\n` : ''}${item.contactPerson ? `**Contact:** ${item.contactPerson}\n` : ''}${item.stageProbability ? `**Close Probability:** ${item.stageProbability}%\n` : ''}${item.competitorInfo ? `**Competitive Intel:** ${item.competitorInfo}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a sales analysis covering:
1. **Deal Health** - Is this deal progressing appropriately for its stage?
2. **Competitive Positioning** - How to differentiate from competitors?
3. **Next Steps** - Specific actions to advance this deal (meetings, demos, proposals)
4. **Risk Factors** - What could derail this opportunity?
5. **Close Strategy** - Recommended approach to accelerate close
6. **Upsell/Cross-sell** - Opportunities to expand deal value`;

                } else if (currentPattern === 'thesis') {
                    systemPrompt = `You are an academic advisor helping graduate students structure rigorous research, with expertise in thesis development, argumentation, and scholarly writing.`;

                    userPrompt = `Analyze this academic ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.wordCount ? `**Current Words:** ${item.wordCount}\n` : ''}${item.targetWordCount ? `**Target Words:** ${item.targetWordCount}\n` : ''}${item.keyCitations ? `**Key Citations:** ${item.keyCitations}\n` : ''}${item.keyArgument ? `**Main Argument:** ${item.keyArgument}\n` : ''}${item.evidenceType ? `**Evidence Type:** ${item.evidenceType}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide an academic analysis covering:
1. **Argument Strength** - Is the thesis argument clear and defensible?
2. **Evidence Quality** - Is the evidence sufficient and appropriate?
3. **Citation Coverage** - Are key sources adequately referenced?
4. **Structural Coherence** - Does this fit logically within the overall thesis?
5. **Scholarly Rigor** - Areas to strengthen academic quality
6. **Recommendations** - Specific next steps for development`;

                } else if (currentPattern === 'roadmap') {
                    systemPrompt = `You are a product manager experienced in agile development, feature prioritization, and engineering execution strategy.`;

                    userPrompt = `Analyze this product ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.storyPoints ? `**Story Points:** ${item.storyPoints}\n` : ''}${item.userImpact ? `**User Impact:** ${item.userImpact}\n` : ''}${item.technicalRisk ? `**Technical Risk:** ${item.technicalRisk}\n` : ''}${item.engineeringEstimate ? `**Engineering Estimate:** ${item.engineeringEstimate}\n` : ''}${item.featureFlag ? `**Feature Flag:** ${item.featureFlag}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a product analysis covering:
1. **User Value** - Does this feature deliver clear user benefit?
2. **Technical Feasibility** - Are the story points and risk assessment realistic?
3. **Prioritization** - Where should this rank given impact vs effort?
4. **Dependencies** - Are upstream features properly identified?
5. **Implementation Strategy** - Recommended approach (MVP, feature flag, phased rollout)
6. **Success Metrics** - How to measure if this feature succeeds`;

                } else if (currentPattern === 'prompting') {
                    systemPrompt = `You are an AI/ML engineer expert in prompt engineering for Claude and GPT-4, specializing in system design, agent workflows, and prompt optimization.`;

                    userPrompt = `Analyze this prompt ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.systemPrompt ? `**System Prompt:** ${item.systemPrompt.substring(0, 200)}${item.systemPrompt.length > 200 ? '...' : ''}\n` : ''}${item.userPromptTemplate ? `**User Template:** ${item.userPromptTemplate.substring(0, 200)}${item.userPromptTemplate.length > 200 ? '...' : ''}\n` : ''}${item.modelTarget ? `**Model:** ${item.modelTarget}\n` : ''}${item.temperature ? `**Temperature:** ${item.temperature}\n` : ''}${item.maxTokens ? `**Max Tokens:** ${item.maxTokens}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a prompt engineering analysis covering:
1. **Prompt Quality** - Is the system/user prompt clear and well-structured?
2. **Best Practices** - OpenAI/Anthropic recommendations being followed?
3. **Few-Shot Examples** - Are examples sufficient and high-quality?
4. **Chain-of-Thought** - Should CoT be added for better reasoning?
5. **Edge Cases** - What failure modes should be addressed?
6. **Optimization** - How to improve accuracy, cost, or latency`;

                } else if (currentPattern === 'book') {
                    systemPrompt = `You are a professional fiction editor and writing coach, specializing in narrative structure, character development, and storytelling craft.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.wordCount ? `**Current Words:** ${item.wordCount}\n` : ''}${item.targetWordCount ? `**Target Words:** ${item.targetWordCount}\n` : ''}${item.plotPoints ? `**Plot Points:** ${item.plotPoints}\n` : ''}${item.characterArcs ? `**Character Arcs:** ${item.characterArcs}\n` : ''}${item.pacing ? `**Pacing:** ${item.pacing}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a narrative analysis covering:
1. **Story Structure** - Does this chapter serve the overall narrative arc?
2. **Character Development** - Are character arcs progressing appropriately?
3. **Pacing** - Is the rhythm and tension appropriate for this section?
4. **Plot Points** - Are key story beats landing effectively?
5. **Scene Craft** - Suggestions for strengthening individual scenes
6. **Recommendations** - Specific revisions to improve this chapter`;

                } else if (currentPattern === 'film') {
                    systemPrompt = `You are a cinematographer and film director specializing in AI video production (Sora, Veo, Runway Gen-3), with expertise in visual storytelling, camera work, and production planning.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.aiPlatform ? `**AI Platform:** ${item.aiPlatform}\n` : ''}${item.videoPrompt ? `**Video Prompt:** ${item.videoPrompt.substring(0, 200)}${item.videoPrompt.length > 200 ? '...' : ''}\n` : ''}${item.visualStyle ? `**Visual Style:** ${item.visualStyle}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.cameraMovement ? `**Camera Movement:** ${item.cameraMovement}\n` : ''}${item.lightingMood ? `**Lighting:** ${item.lightingMood}\n` : ''}${item.motionIntensity ? `**Motion Intensity:** ${item.motionIntensity}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a production analysis covering:
1. **Prompt Quality** - Is the video prompt detailed enough for Sora/Veo?
2. **Visual Cohesion** - Does this scene match the project's visual style?
3. **Camera & Lighting** - Are technical specs appropriate for the mood?
4. **Production Feasibility** - Can current AI platforms deliver this vision?
5. **Sequence Flow** - How does this scene connect to dependencies?
6. **Optimization** - How to improve prompt for better AI generation`;

                } else if (currentPattern === 'course') {
                    systemPrompt = `You are a senior instructional designer with 12+ years of experience and an M.Ed. in Curriculum & Instruction. Your expertise includes ADDIE and SAM methodologies, backward design (Wiggins & McTighe), Bloom's Taxonomy, Gagne's Nine Events of Instruction, adult learning theory (Knowles' andragogy), and Kirkpatrick's Four-Level Training Evaluation Model. You apply evidence-based pedagogical frameworks to optimize learning outcomes.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.learningObjectives ? `**Learning Objectives:** ${item.learningObjectives}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.difficultyLevel ? `**Difficulty:** ${item.difficultyLevel}\n` : ''}${item.prerequisites ? `**Prerequisites:** ${item.prerequisites}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a pedagogical analysis covering:
1. **Learning Objectives** - Are objectives SMART and mapped to Bloom's Taxonomy levels? (Remember/Understand/Apply/Analyze/Evaluate/Create)
2. **Content Structure** - Does it follow Gagne's Nine Events of Instruction?
3. **Difficulty Progression** - Is scaffolding appropriate for the prerequisite sequence?
4. **Assessment Design** - Are assessments formative, summative, or authentic? Do they align with objectives?
5. **Learning Modalities** - Does it address visual, auditory, kinesthetic, and multimodal learners?
6. **Recommendations** - How to improve learning outcomes using evidence-based practices`;

                } else if (currentPattern === 'fitness') {
                    systemPrompt = `You are a certified personal trainer and exercise physiologist with expertise in program design, exercise science, progressive overload, and injury prevention.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.targetMuscleGroups ? `**Target Muscles:** ${item.targetMuscleGroups}\n` : ''}${item.sets ? `**Sets:** ${item.sets}\n` : ''}${item.reps ? `**Reps:** ${item.reps}\n` : ''}${item.restTime ? `**Rest:** ${item.restTime}\n` : ''}${item.intensity ? `**Intensity:** ${item.intensity}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a fitness analysis covering:
1. **Exercise Selection** - Are exercises appropriate for the training goal?
2. **Volume & Intensity** - Are sets, reps, and intensity optimized for progression?
3. **Progressive Overload** - Is the program structured for strength/endurance gains?
4. **Injury Prevention** - Are there any form cues or mobility prerequisites needed?
5. **Recovery** - Is rest time and workout spacing appropriate?
6. **Recommendations** - How to optimize this workout for better results`;

                } else if (currentPattern === 'event') {
                    systemPrompt = `You are a professional event planner with experience in corporate events, weddings, and large-scale conferences, specializing in logistics, vendor coordination, and timeline management.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.venue ? `**Venue:** ${item.venue}\n` : ''}${item.attendeeCount ? `**Attendees:** ${item.attendeeCount}\n` : ''}${item.startTime ? `**Start Time:** ${item.startTime}\n` : ''}${item.duration ? `**Duration:** ${item.duration}\n` : ''}${item.vendor ? `**Vendor:** ${item.vendor}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide an event planning analysis covering:
1. **Timeline Feasibility** - Is the activity appropriately scheduled and paced?
2. **Logistics** - Are venue, equipment, and vendor requirements clear?
3. **Guest Experience** - How does this contribute to attendee satisfaction?
4. **Dependencies** - Are setup/breakdown and sequential activities properly coordinated?
5. **Contingency Planning** - What backup plans are needed for this activity?
6. **Recommendations** - How to improve execution and guest experience`;

                } else if (currentPattern === 'strategy') {
                    systemPrompt = `You are a senior business strategy consultant with 12+ years of experience leading Fortune 500 transformations. Your expertise spans classical strategic frameworks (Porter's Five Forces, SWOT, McKinsey 7-S Model, BCG Growth-Share Matrix), modern innovation theory (Clayton Christensen's disruption framework, Blue Ocean Strategy), and performance management systems (OKRs, Balanced Scorecard, Jobs-to-be-Done methodology). Your analytical approach integrates quantitative business metrics with qualitative market dynamics, drawing from the strategic thinking of Michael Porter, Andy Grove, and Rita McGrath.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.kpi ? `**KPI:** ${item.kpi}\n` : ''}${item.targetValue ? `**Target:** ${item.targetValue}\n` : ''}${item.currentValue ? `**Current:** ${item.currentValue}\n` : ''}${item.owner ? `**Owner:** ${item.owner}\n` : ''}${item.timeframe ? `**Timeframe:** ${item.timeframe}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a strategic analysis covering:
1. **Strategic Alignment** - Does this initiative support the overall strategic pillar?
2. **KPI Quality** - Are metrics measurable, achievable, and meaningful?
3. **Resource Requirements** - What capabilities or investments are needed?
4. **Dependencies** - Are prerequisite initiatives or decisions identified?
5. **Risk Assessment** - What could prevent success and how to mitigate?
6. **Recommendations** - How to maximize strategic impact`;

                } else if (currentPattern === 'familytree') {
                    systemPrompt = `You are a professional genealogist and family historian specializing in genealogical research, family tree documentation, and historical record analysis.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.birthDate ? `**Birth:** ${item.birthDate}\n` : ''}${item.deathDate ? `**Death:** ${item.deathDate}\n` : ''}${item.birthPlace ? `**Birth Place:** ${item.birthPlace}\n` : ''}${item.occupation ? `**Occupation:** ${item.occupation}\n` : ''}${item.spouse ? `**Spouse:** ${item.spouse}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a genealogical analysis covering:
1. **Record Completeness** - Are key vital records (birth, death, marriage) documented?
2. **Source Quality** - Are sources reliable and properly cited?
3. **Relationship Verification** - Are family connections well-supported by evidence?
4. **Research Gaps** - What additional records or information should be sought?
5. **Conflicting Data** - Are there any inconsistencies to resolve?
6. **Recommendations** - Next steps for strengthening this family branch documentation`;

                } else if (currentPattern === 'lifetree') {
                    // BUILD 374: LifeTree biographical event analysis
                    const subjectName = capexTree?.name?.replace(/^.*?['']s?\s*Life(tree)?$/i, '').trim() ||
                                       capexTree?.name?.replace(/\s*Life(tree)?$/i, '').trim() ||
                                       'the subject';

                    systemPrompt = `You are a compassionate oral historian and biographer helping document ${subjectName}'s life story. You specialize in:
- Helping people capture and preserve meaningful memories
- Asking thoughtful follow-up questions to enrich stories
- Providing historical and cultural context for time periods
- Connecting individual experiences to broader family narratives

Be warm, curious, and respectful. This is someone's precious life story.`;

                    userPrompt = `Help me understand and enrich this life event for ${subjectName}:

**Event:** ${item.name}
**When:** ${item.eventDate || item.description || 'Unknown time period'}
${item.location ? `**Where:** ${item.location}\n` : ''}${item.people ? `**Who was involved:** ${item.people}\n` : ''}${item.emotion ? `**Feeling/Tone:** ${item.emotion}\n` : ''}${item.source ? `**Remembered by:** ${item.source}\n` : ''}${item.confidence ? `**Certainty:** ${item.confidence}\n` : ''}${item.description ? `**Description:** ${item.description}\n` : ''}${item.notes ? `**Notes:** ${item.notes}\n` : ''}

Please provide:
1. **Historical Context** - What was happening in the world/community during this time that might relate to this event?
2. **Questions to Explore** - 2-3 thoughtful follow-up questions that could enrich this memory
3. **Connections** - How might this event connect to other life stages or family patterns?
4. **Details to Capture** - What sensory details, emotions, or specifics would make this memory more vivid?
5. **Preservation Notes** - Any documents, photos, or artifacts that might help verify or illustrate this event`;

                } else if (currentPattern === 'dialogue') {
                    systemPrompt = `You are a rhetoric and argumentation expert specializing in debate analysis, logical fallacies, persuasive communication, and interpersonal psychology. Your expertise includes classical rhetoric (Aristotle, Cicero), modern argumentation theory, and political theater analysis.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Speaker:** ${item.speaker || 'N/A'}
**Description:** ${item.description || 'N/A'}
${item.verbatimQuote ? `**Verbatim Quote:** "${item.verbatimQuote}"\n` : ''}${item.rhetoricalDevice ? `**Rhetorical Device:** ${item.rhetoricalDevice}\n` : ''}${item.logicalStructure ? `**Logical Structure:** ${item.logicalStructure}\n` : ''}${item.fallaciesPresent ? `**Fallacies Identified:** ${item.fallaciesPresent}\n` : ''}${item.hiddenMotivation ? `**Hidden Motivation:** ${item.hiddenMotivation}\n` : ''}${item.emotionalTone ? `**Emotional Tone:** ${item.emotionalTone}\n` : ''}${item.evidenceQuality ? `**Evidence Quality:** ${item.evidenceQuality}\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None'}

Provide a rhetorical analysis covering:
1. **Argument Strength** - Evaluate the logical validity and persuasive power of this statement
2. **Rhetorical Techniques** - What persuasive devices are employed? How effective are they?
3. **Logical Fallacies** - Identify any fallacies (ad hominem, straw man, false dichotomy, etc.) and their impact
4. **Hidden Motivations** - What unstated goals or biases might be driving this argument?
5. **Counterargument Strategy** - What would be the most effective rebuttal or opposing position?
6. **Evidence Assessment** - How strong is the supporting evidence? What's missing?
7. **Recommendations** - How could this argument be strengthened or how should an opponent respond?`;

                } else if (currentPattern === 'filesystem') {
                    systemPrompt = `You are "LibrarianAI" for TreeListy.

Your job is to manage and enrich a **single filesystem** (one TreeListy tree) without ever directly deleting or renaming anything. You operate only by updating node metadata and proposing non-destructive actions.

Given a list of nodes (files and folders) with:
- node_id, path, is_folder
- basic metadata (size, timestamps, mime/type hints)
- existing AI fields (if any)

Do the following for **this filesystem only**:

1. **Enrich metadata for each node**
   - Infer and/or update:
     - summary_short: 1â€“2 line human-readable description.
     - tags: topical keywords.
     - project_guess: likely project or collection name (string).
     - status: one of draft | working | final | archive_candidate.
     - sensitivity_level: low | medium | high (e.g. legal/financial/personal = high).
     - lifecycle_stage: active | stale | historical | junk_candidate.
     - ai_confidence: 0â€“1 float for your overall judgment.
   - Never invent impossible details; base everything on filenames, paths, and any provided content/metadata.

2. **Detect redundancy and clusters**
   - Group near-duplicate or strongly related files into clusters.
   - For each node, set:
     - cluster_id: stable ID shared by similar files, or null.
     - canonical_id: the node_id of the best representative in that cluster, or equal to its own node_id if it is canonical.
   - Prefer canonical files that are more recent, more complete, and more likely to be in the correct folder.

3. **Assess data quality**
   - For each node, compute:
     - data_quality_score: 0â€“100, based on naming clarity, location, redundancy, and completeness.
   - Higher scores = clearer, better placed, non-redundant, and likely still useful.

4. **Propose safe actions only**
   - Do **not** delete, rename, or move anything directly.
   - Instead, populate an ai_actions_pending list per node with suggested operations, for example:
     - {"action": "move", "target_folder": "...", "reason": "...", "confidence": 0.82}
     - {"action": "archive", "reason": "...", "confidence": 0.76}
   - Be conservative: when in doubt, lower confidence and prefer suggestion over aggressive cleanup.

Act as a cautious, explainable librarian: improve structure and clarity, reduce redundancy, and surface suggestions, but never take irreversible or destructive actions yourself.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'File'}
**Path:** ${item.filePath || 'N/A'}
${item.isFolder ? `**Is Folder:** Yes\n` : ''}${item.fileSize ? `**Size:** ${(item.fileSize / 1024).toFixed(1)} KB\n` : ''}${item.fileExtension ? `**Extension:** ${item.fileExtension}\n` : ''}${item.dateModified ? `**Modified:** ${new Date(item.dateModified).toLocaleDateString()}\n` : ''}${item.dateCreated ? `**Created:** ${new Date(item.dateCreated).toLocaleDateString()}\n` : ''}${item.fileOwner ? `**Owner:** ${item.fileOwner}\n` : ''}${item.mimeType ? `**MIME Type:** ${item.mimeType}\n` : ''}**Description:** ${item.description || 'None'}
**Notes:** ${item.notes || 'None'}

Provide a LibrarianAI analysis covering:
1. **Metadata Enrichment** - Suggest summary_short, tags, project_guess, status, sensitivity_level, lifecycle_stage, ai_confidence
2. **Redundancy Detection** - Is this part of a cluster? Suggest cluster_id and canonical_id if similar files exist
3. **Data Quality Score** - Rate 0-100 based on naming clarity, location appropriateness, redundancy, and usefulness
4. **Proposed Actions** - Suggest safe, non-destructive actions (move, archive, tag) with confidence scores
5. **Organization Insights** - How does this fit within the overall filesystem structure?
6. **Recommendations** - Conservative suggestions to improve organization without destructive changes`;

                } else {
                    // Generic/default pattern - Senior financial planning perspective
                    systemPrompt = `You are a senior financial planning manager with 15 years of experience in enterprise project finance, specializing in budget optimization, risk quantification, and resource allocation for Fortune 500 digital transformation initiatives. Your expertise spans Monte Carlo risk modeling, Earned Value Management (EVM), and Stage-Gate financial governance following PMI and COSO frameworks. You excel at translating complex project financials into executive-ready insights, identifying cost optimization opportunities, and creating data-driven contingency plans.`;

                    userPrompt = `Analyze this ${levels.item.toLowerCase()}:

**${levels.item}:** ${item.name}
**Type:** ${item.itemType || 'N/A'}
**Description:** ${item.description || 'N/A'}
${pattern.fields?.cost ? `**Cost:** $${(item.cost || 0).toLocaleString()}\n` : ''}${pattern.fields?.leadTime ? `**Lead Time:** ${item.leadTime || 'Not specified'}\n` : ''}${pattern.fields?.alternateSource ? `**Alternate Source:** ${item.alternateSource || 'Not specified'}\n` : ''}${item.pmRAGStatus ? `**RAG Status:** ${item.pmRAGStatus}\n` : ''}${item.pmOwnerEmail ? `**Owner:** ${item.pmOwnerEmail}\n` : ''}${item.pmEstimatedHours ? `**Estimated Hours:** ${item.pmEstimatedHours}h\n` : ''}${item.pmActualHours ? `**Actual Hours:** ${item.pmActualHours}h\n` : ''}**Dependencies:** ${item.dependencies?.length > 0 ? item.dependencies.join(', ') : 'None'}
**Notes:** ${item.notes || 'None provided'}

From a PM and CFO perspective, provide analysis covering:
1. **Financial Health** - Budget status, cost drivers, burn rate concerns, ROI considerations
2. **Risk Assessment** - Financial risks, schedule risks, resource constraints, mitigation strategies
3. **Time & Resource Management** - Timeline realism, resource allocation efficiency, critical path impacts
4. **Vendor & Procurement** - Supplier reliability, alternate source evaluation, contract considerations
5. **Stakeholder & Governance** - Approval gates, change management, reporting requirements
6. **Strategic Recommendations** - 2-3 actionable steps to improve delivery, reduce cost, or mitigate risk`;
                }

            } else if (analysisType === 'project') {
                // Project-level analysis (PATTERN-AWARE)
                const pattern = PATTERNS[currentPattern];
                const levels = pattern.levels;
                const allItems = getAllProjectItems();

                // Build phase breakdown
                const phaseBreakdown = capexTree.children?.map((phase, idx) => {
                    const phaseItems = allItems.filter(i => i.id?.startsWith(`p${idx}`));
                    let phaseLine = `- ${phase.name}`;

                    if (phase.subtitle) phaseLine += ` (${phase.subtitle})`;
                    phaseLine += `: ${phaseItems.length} ${levels.item.toLowerCase()}s`;

                    if (pattern.fields?.cost) {
                        const phaseTotal = phaseItems.reduce((sum, i) => sum + (i.cost || 0), 0);
                        phaseLine += `, $${phaseTotal.toLocaleString()}`;
                    }

                    return phaseLine;
                }).join('\n') || 'No phases defined';

                // Pattern-specific prompts
                if (currentPattern === 'book') {
                    systemPrompt = `You are a literary consultant specializing in narrative structure and book development. Provide insights on story structure, pacing, character development, and writing best practices.`;

                    userPrompt = `Analyze this book writing project:

**Title:** ${capexTree.name}
**Pattern:** Book Writing

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Story Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} builds on ${i.dependencies.length} previous element(s)`
).join('\n')}

` : ''}Provide an executive summary for this book project covering:
1. **Narrative Structure Assessment** - Is the part/chapter breakdown balanced and logical?
2. **Story Flow** - Comment on pacing and progression based on dependencies
3. **Development Recommendations** - Suggestions for strengthening the narrative structure
4. **Potential Issues** - Any structural concerns or gaps in the story arc
5. **Next Steps** - Actionable recommendations for the author

Focus on narrative structure and storytelling best practices.`;

                } else if (currentPattern === 'prompting') {
                    systemPrompt = `You are a prompt engineering expert specializing in LLM workflows, agent design, and AI system architecture. Provide insights on prompt structure, agent orchestration, and best practices.`;

                    userPrompt = `Analyze this AI prompt design project:

**Prompt Workbook:** ${capexTree.name}
**Pattern:** AI Prompt Design

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Agent Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} requires ${i.dependencies.length} upstream component(s)`
).join('\n')}

` : ''}Provide an executive summary for this prompt engineering project covering:
1. **Architecture Assessment** - Is the stage/module breakdown logical for an AI workflow?
2. **Agent Orchestration** - Comment on dependencies and data flow between modules
3. **Prompt Engineering Best Practices** - Recommendations for improving prompt quality
4. **Potential Issues** - Any architectural concerns or missing components
5. **Next Steps** - Actionable recommendations for the prompt engineer

Focus on prompt engineering and agent design best practices.`;

                } else if (pattern.fields?.cost) {
                    // Financial patterns (generic, sales, roadmap, etc.)
                    systemPrompt = `You are a senior project analyst specializing in project planning, budgeting, and execution strategy. Provide insights on project structure, resource allocation, and execution best practices.`;

                    const totalCost = calculateTotal(capexTree);

                    userPrompt = `Analyze this ${pattern.name.toLowerCase()} project:

**Project:** ${capexTree.name}
**Pattern:** ${pattern.name}
**Total Budget:** $${totalCost.toLocaleString()}

**${levels.phase} Breakdown:**
${phaseBreakdown}

${allItems.filter(i => i.cost > 1000000).length > 0 ? `**Major Line Items (>$1M):**
${allItems.filter(i => i.cost > 1000000).map(i =>
    `- ${i.name}: $${i.cost.toLocaleString()}${i.itemType ? ` (${i.itemType})` : ''}`
).join('\n')}

` : ''}${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Key Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} depends on ${i.dependencies.length} item(s)`
).join('\n')}

` : ''}Provide an executive-level analysis covering:
1. **Budget Assessment** - Is the allocation realistic for this type of project?
2. **Critical Path** - Key dependencies and timeline bottlenecks
3. **Risk Factors** - Top 3 risks to budget or timeline
4. **Optimization Opportunities** - Potential cost savings or efficiency gains
5. **Strategic Recommendations** - High-level guidance for stakeholders

Format for presentation to executives. Be concise but comprehensive.`;

                } else {
                    // Non-financial patterns (philosophy, thesis, etc.)
                    systemPrompt = `You are an expert consultant specializing in structured thinking and project organization. Provide insights on project structure, logical flow, and development best practices.`;

                    userPrompt = `Analyze this ${pattern.name.toLowerCase()} project:

**Project:** ${capexTree.name}
**Pattern:** ${pattern.name}

**Structure Breakdown:**
${phaseBreakdown}

**Total:** ${allItems.length} ${levels.item.toLowerCase()}s across ${capexTree.children?.length || 0} ${levels.phase.toLowerCase()}s

${allItems.filter(i => i.dependencies?.length > 0).length > 0 ? `**Logical Dependencies:**
${allItems.filter(i => i.dependencies?.length > 0).map(i =>
    `- ${i.name} builds on ${i.dependencies.length} previous element(s)`
).join('\n')}

` : ''}Provide an executive summary covering:
1. **Structure Assessment** - Is the ${levels.phase.toLowerCase()}/${levels.item.toLowerCase()} breakdown logical and well-organized?
2. **Logical Flow** - Comment on progression and dependencies between elements
3. **Development Recommendations** - Suggestions for strengthening the structure
4. **Potential Issues** - Any structural concerns or gaps in coverage
5. **Next Steps** - Actionable recommendations for the author/creator

Focus on logical structure and content organization best practices.`;
                }
            }

            return await callClaudeAPI(userPrompt, systemPrompt);
        }

        // Helper to get all items from tree
        function getAllProjectItems(node = capexTree, items = []) {
            if (node.items) items.push(...node.items);
            if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
            return items;
        }

        // =============================================================================
        // END AI INTEGRATION
        // =============================================================================

        // Data - "Welcome to TreeListy" starter tree - visually striking canvas layout with 5 hyperedges
        let capexTree = {
            id: 'root',
            name: 'Welcome to TreeListy',
            type: 'root',
            icon: 'ðŸŒ³',
            expanded: true,
            description: 'Your ideas deserve structure. TreeListy transforms thoughts into organized, actionable trees. This guide walks you through everything - try clicking around!',
            canvasX: 700,
            canvasY: 450,
            hyperedges: [
                {
                    id: 'edge-dual-views',
                    name: 'Dual View System',
                    nodeIds: ['item-tree-view', 'item-canvas-view'],
                    edgeType: 'relates',
                    color: '#6366f1',
                    description: 'Same data, two perspectives - Tree View for editing, Canvas View for visualization'
                },
                {
                    id: 'edge-ai-pipeline',
                    name: 'AI Creation Pipeline',
                    nodeIds: ['item-chat-builder', 'item-import-text', 'item-smart-expand', 'item-deep-dive'],
                    edgeType: 'sequence',
                    color: '#10b981',
                    description: 'Build â†’ Import â†’ Enhance â†’ Analyze: AI assists at every stage'
                },
                {
                    id: 'edge-collab-flow',
                    name: 'Collaboration Workflow',
                    nodeIds: ['item-share-url', 'item-contributor-tags', 'item-collab-comments', 'item-watch-mode'],
                    edgeType: 'relates',
                    color: '#f59e0b',
                    description: 'Share â†’ Tag edits â†’ Comment â†’ Sync: Complete collaboration toolkit'
                },
                {
                    id: 'edge-canvas-features',
                    name: 'Canvas-Specific Features',
                    nodeIds: ['item-canvas-view', 'item-hyperedges', 'item-dependencies'],
                    edgeType: 'relates',
                    color: '#ec4899',
                    description: 'Visual features that shine in Canvas View - drag nodes, see connections, create hyperedges'
                },
                {
                    id: 'edge-getting-started',
                    name: 'Start Here',
                    nodeIds: ['item-new-tree', 'item-import-existing', 'item-chat-builder'],
                    edgeType: 'relates',
                    color: '#8b5cf6',
                    description: 'Three paths to begin: Start fresh, import existing work, or let AI build it'
                }
            ],
            pattern: { key: 'generic' },
            children: [
                {
                    id: 'phase-getting-started',
                    name: 'Getting Started',
                    subtitle: 'Your first 2 minutes',
                    description: 'The essentials to get you productive right away. Each item below teaches a core concept.',
                    type: 'phase',
                    icon: 'ðŸš€',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 250,
                    canvasY: 180,
                    items: [
                        {
                            id: 'item-tree-view',
                            name: 'Tree View',
                            description: "You're looking at it! A structured outline where you can expand/collapse sections. Click the arrows (â–¶) to toggle. Great for detailed editing and data entry.",
                            type: 'item',
                            icon: 'ðŸ“‹',
                            expanded: true,
                            canvasX: 83.47,
                            canvasY: -48.39,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'Done',
                            pmProgress: 100,
                            pmPriority: 'High',
                            subtasks: [
                                {
                                    id: 'sub-expand',
                                    name: 'Click arrows to expand/collapse',
                                    description: 'Try it now - click the â–¶ next to any phase or item',
                                    type: 'subtask',
                                    pmStatus: 'Done',
                                    pmProgress: 100
                                },
                                {
                                    id: 'sub-click-edit',
                                    name: 'Click any node to see details',
                                    description: 'The detail panel appears on the right with all fields',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                }
                            ]
                        },
                        {
                            id: 'item-canvas-view',
                            name: 'Canvas View',
                            description: "You're seeing it now! Drag nodes anywhere. Zoom with scroll wheel. See colored lines connecting related nodes - those are hyperedges. Try the layout dropdown for different arrangements.",
                            type: 'item',
                            icon: 'ðŸŽ¨',
                            expanded: true,
                            canvasX: -81.94,
                            canvasY: 177.20,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: [
                                {
                                    id: 'sub-drag',
                                    name: 'Drag nodes to rearrange',
                                    description: 'Click and drag any node to move it freely on the canvas',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                },
                                {
                                    id: 'sub-layouts',
                                    name: 'Try different layouts',
                                    description: 'Use the layout dropdown for Timeline, Radial, Force-Directed views',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                }
                            ]
                        },
                        {
                            id: 'item-right-click',
                            name: 'Right-Click Menu',
                            description: 'Right-click any node for a menu of actions: Add Child, Edit, Duplicate, Delete, Share Branch, and more. This is how you build and modify your tree.',
                            type: 'item',
                            icon: 'ðŸ–±ï¸',
                            expanded: false,
                            canvasX: 80,
                            canvasY: 360,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            subtasks: []
                        }
                    ]
                },
                {
                    id: 'phase-ai-features',
                    name: 'AI Superpowers',
                    subtitle: 'Let AI do the heavy lifting',
                    description: "TreeListy's AI features help you think, organize, and create faster. All powered by Claude, Gemini, or ChatGPT - you choose.",
                    type: 'phase',
                    icon: 'ðŸ¤–',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 250,
                    canvasY: 720,
                    items: [
                        {
                            id: 'item-chat-builder',
                            name: 'Chat Builder (Live Tree Agent)',
                            description: "Click 'ðŸ’¬ Chat Builder' in the sidebar. A floating Tree Agent frame appears - describe your project in plain English while watching the tree grow in real-time! Nodes pulse green when added, yellow when modified. Drag the frame anywhere, or double-click to reset position.",
                            type: 'item',
                            icon: 'ðŸ’¬',
                            expanded: true,
                            canvasX: 80,
                            canvasY: 580,
                            cost: 0,
                            leadTime: 2,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: [
                                {
                                    id: 'sub-chat-example',
                                    name: "Example: 'Plan a weekend trip to Portland'",
                                    description: 'AI will ask clarifying questions, then build a complete tree',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                },
                                {
                                    id: 'sub-tree-agent',
                                    name: 'Live Tree Agent Features',
                                    description: 'Draggable frame, visual node highlights, progress bar, voice input, minimize/close controls',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                }
                            ]
                        },
                        {
                            id: 'item-import-text',
                            name: 'Import Text',
                            description: "Click 'ðŸ“¥ Import Text' to paste any document, outline, or notes. AI extracts the structure automatically. Quick Mode for simple docs, Deep Mode for complex analysis.",
                            type: 'item',
                            icon: 'ðŸ“¥',
                            expanded: true,
                            canvasX: -282.04,
                            canvasY: 710.75,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: [
                                {
                                    id: 'sub-quick-mode',
                                    name: 'Quick Mode: Fast extraction',
                                    description: 'For meeting notes, simple outlines, straightforward documents',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                },
                                {
                                    id: 'sub-deep-mode',
                                    name: 'Deep Mode: Extended thinking',
                                    description: 'For academic papers, complex arguments, detailed analysis',
                                    type: 'subtask',
                                    pmStatus: 'To Do'
                                }
                            ]
                        },
                        {
                            id: 'item-smart-expand',
                            name: 'Smart Expand',
                            description: "Click 'âœ¨ Smart Expand' to have AI enrich your existing tree. It adds subtasks, fills descriptions, and suggests missing pieces - without deleting your work.",
                            type: 'item',
                            icon: 'âœ¨',
                            expanded: false,
                            canvasX: 80,
                            canvasY: 860,
                            cost: 0,
                            leadTime: 2,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            subtasks: []
                        },
                        {
                            id: 'item-deep-dive',
                            name: 'Deep Dive Analysis',
                            description: "Select any node, right-click â†’ 'Deep Dive'. AI performs scholarly analysis: key concepts, implications, related ideas, counterarguments. Perfect for research.",
                            type: 'item',
                            icon: 'ðŸ”¬',
                            expanded: false,
                            canvasX: 250,
                            canvasY: 900,
                            cost: 0,
                            leadTime: 3,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            subtasks: []
                        }
                    ]
                },
                {
                    id: 'phase-patterns',
                    name: '18 Specialized Patterns',
                    subtitle: 'Purpose-built templates',
                    description: 'TreeListy adapts to your domain. Each pattern has custom fields, AI personas, and workflows optimized for that use case.',
                    type: 'phase',
                    icon: 'ðŸŽ¯',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 1150,
                    canvasY: 180,
                    items: [
                        {
                            id: 'item-pattern-selector',
                            name: 'Change Pattern',
                            description: "Click the pattern dropdown in the header (shows 'Generic Project' by default). Switch patterns anytime - your data is preserved and mapped to new fields.",
                            type: 'item',
                            icon: 'ðŸ”„',
                            expanded: true,
                            canvasX: 1341.98,
                            canvasY: -84.25,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: []
                        },
                        {
                            id: 'item-patterns-list',
                            name: 'Available Patterns',
                            description: 'Generic Project, Philosophy, Sales Pipeline, Academic Thesis, Product Roadmap, Book Writing, Event Planning, Fitness Program, Strategic Plan, Course Design, AI Video (Sora/Veo), Family Tree, Dialogue & Rhetoric, Gmail Workflow, File System, CAPEX/Angel Pitch, and more.',
                            type: 'item',
                            icon: 'ðŸ“š',
                            expanded: true,
                            canvasX: 1345.45,
                            canvasY: 59.22,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'In Progress',
                            pmProgress: 50,
                            pmPriority: 'Medium',
                            subtasks: [
                                {
                                    id: 'sub-philosophy',
                                    name: 'Philosophy: Arguments, premises, dialectics',
                                    description: 'Perfect for analyzing debates, building arguments, Socratic dialogue',
                                    type: 'subtask',
                                    pmStatus: 'Done',
                                    pmProgress: 100
                                },
                                {
                                    id: 'sub-sales',
                                    name: 'Sales: Deals, probability, contacts',
                                    description: 'Track your pipeline with deal values, close dates, and win probability',
                                    type: 'subtask',
                                    pmStatus: 'Done',
                                    pmProgress: 100
                                },
                                {
                                    id: 'sub-video',
                                    name: 'AI Video: Sora/Veo production prompts',
                                    description: 'Generate camera movements, lighting, and video prompts for AI video tools',
                                    type: 'subtask',
                                    pmStatus: 'Done',
                                    pmProgress: 100
                                }
                            ]
                        }
                    ]
                },
                {
                    id: 'phase-collaboration',
                    name: 'Collaboration',
                    subtitle: 'Work together',
                    description: 'Share trees with teammates, track who edited what, and sync changes in real-time or asynchronously.',
                    type: 'phase',
                    icon: 'ðŸ‘¥',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 1150,
                    canvasY: 720,
                    items: [
                        {
                            id: 'item-share-url',
                            name: 'Share via URL',
                            description: "Click 'Share' in header â†’ Copy link â†’ Anyone can open your exact tree instantly. No account needed. The entire tree is encoded in the URL.",
                            type: 'item',
                            icon: 'ðŸ”—',
                            expanded: false,
                            canvasX: 1568.69,
                            canvasY: 504.82,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: []
                        },
                        {
                            id: 'item-contributor-tags',
                            name: 'Contributor Tags',
                            description: "Edit any node â†’ scroll to 'Collaboration' section â†’ set your name. Your edits show a ðŸ‘¤ badge so collaborators know who changed what.",
                            type: 'item',
                            icon: 'ðŸ‘¤',
                            expanded: false,
                            canvasX: 1095.60,
                            canvasY: 697.69,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            contributor: 'TreeListy Team',
                            contributorTimestamp: '2024-12-01T12:00:00Z',
                            subtasks: []
                        },
                        {
                            id: 'item-collab-comments',
                            name: 'Collaboration Comments',
                            description: "Leave notes for teammates in the 'Collaboration Comments' field. Nodes with comments show a pulsing ðŸ’¬ indicator so they're easy to spot.",
                            type: 'item',
                            icon: 'ðŸ’¬',
                            expanded: false,
                            canvasX: 1540.93,
                            canvasY: 863.95,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            collabComments: 'This is an example comment! You can use this field to ask questions, leave feedback, or coordinate with collaborators.',
                            subtasks: []
                        },
                        {
                            id: 'item-live-sync',
                            name: 'Live Sync + Voice Chat',
                            description: "Click 'ðŸ”„ Live Sync' button â†’ Create or Join a room with 6-character ID. Multiple users edit simultaneously! Use the ðŸŽ™ï¸ Voice button for hands-free Jitsi voice chat.",
                            type: 'item',
                            icon: 'ðŸ”„',
                            expanded: false,
                            canvasX: 1150,
                            canvasY: 900,
                            cost: 0,
                            leadTime: 2,
                            pmStatus: 'To Do',
                            pmPriority: 'Low',
                            subtasks: []
                        }
                    ]
                },
                {
                    id: 'phase-advanced',
                    name: 'Power Features',
                    subtitle: 'Canvas-specific tools',
                    description: "These features shine in Canvas View - visual connections, dependencies, and project tracking.",
                    type: 'phase',
                    icon: 'âš¡',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 700,
                    canvasY: 180,
                    items: [
                        {
                            id: 'item-hyperedges',
                            name: 'Hyperedges',
                            description: "The colored lines connecting nodes in this view! Click the hyperedge panel (bottom-right) to create your own. Group related concepts across phases with visual connections.",
                            type: 'item',
                            icon: 'ðŸ”—',
                            expanded: false,
                            canvasX: 526.87,
                            canvasY: -88.80,
                            cost: 0,
                            leadTime: 2,
                            pmStatus: 'Done',
                            pmProgress: 100,
                            pmPriority: 'High',
                            subtasks: []
                        },
                        {
                            id: 'item-dependencies',
                            name: 'Dependencies',
                            description: "Link items that must complete before others can start. Edit an item â†’ Dependencies field â†’ select prerequisites. Dependencies show as arrows between nodes.",
                            type: 'item',
                            icon: 'â†—ï¸',
                            expanded: false,
                            canvasX: 825.71,
                            canvasY: 74.29,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'Medium',
                            dependencies: ['item-right-click'],
                            subtasks: []
                        },
                        {
                            id: 'item-pm-tracking',
                            name: 'Project Tracking',
                            description: "Each item has status (To Do, In Progress, Done), assignee, due date, priority, and progress percentage. This node shows example values - check the detail panel!",
                            type: 'item',
                            icon: 'ðŸ“Š',
                            expanded: false,
                            canvasX: 1152.84,
                            canvasY: 293.02,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'In Progress',
                            pmProgress: 75,
                            pmAssignee: 'You',
                            pmPriority: 'High',
                            pmDueDate: '2025-12-31',
                            subtasks: []
                        },
                        {
                            id: 'item-export',
                            name: 'Export Options',
                            description: 'File menu â†’ Export as Excel (4-sheet workbook), JSON (for backup/sharing), or generate AI prompts from your tree structure.',
                            type: 'item',
                            icon: 'ðŸ“¤',
                            expanded: false,
                            canvasX: 731.35,
                            canvasY: 312.64,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'Low',
                            subtasks: []
                        }
                    ]
                },
                {
                    id: 'phase-next-steps',
                    name: 'Your Next Steps',
                    subtitle: 'Start creating',
                    description: 'Ready to build your own tree? Here are some ways to begin.',
                    type: 'phase',
                    icon: 'ðŸŽ¯',
                    expanded: true,
                    showInCanvas: true,
                    canvasX: 700,
                    canvasY: 720,
                    items: [
                        {
                            id: 'item-new-tree',
                            name: 'Start Fresh',
                            description: 'File menu â†’ New Tree. Choose a pattern that fits your project. Then use Chat Builder or just start adding phases manually.',
                            type: 'item',
                            icon: 'ðŸ†•',
                            expanded: false,
                            canvasX: 550,
                            canvasY: 850,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: []
                        },
                        {
                            id: 'item-import-existing',
                            name: 'Import Existing Work',
                            description: 'Have notes, docs, or outlines? Use Import Text to convert them into a structured tree. AI handles the organization.',
                            type: 'item',
                            icon: 'ðŸ“„',
                            expanded: false,
                            canvasX: 711.57,
                            canvasY: 664.93,
                            cost: 0,
                            leadTime: 2,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: []
                        },
                        {
                            id: 'item-save-work',
                            name: 'Save Your Work',
                            description: 'TreeListy auto-saves to your browser, but also save as JSON (File â†’ Save) for backup. You can reload it anytime, on any device.',
                            type: 'item',
                            icon: 'ðŸ’¾',
                            expanded: false,
                            canvasX: 941.38,
                            canvasY: 491.43,
                            cost: 0,
                            leadTime: 1,
                            pmStatus: 'To Do',
                            pmPriority: 'High',
                            subtasks: []
                        }
                    ]
                }
            ]
        };

        // =====================================================================
        // CANVAS VIEW INTEGRATION
        // =====================================================================

        let viewMode = 'tree';
        let canvasNodes = [];
        let canvasPan = { x: 0, y: 0 };
        let canvasZoom = 1;
        let isPanningCanvas = false;
        let isDraggingCanvasNode = false;
        let draggedCanvasNode = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let panStartX = 0;
        let panStartY = 0;
        let maxExpandedDepth = Infinity;  // Track how deep we're currently showing
        let gridEnabled = false;
        const gridSize = 40;  // Grid snap size
        let clusterByField = '';  // Track which metadata field to cluster by (itemType, owner, etc.)
        let sortClusterLinked = true;  // Auto-sync Sort and Cluster dropdowns

        // Multi-selection state
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionEnd = { x: 0, y: 0 };
        let selectedNodes = [];
        let isDraggingSelection = false;
        let selectionDragStart = { x: 0, y: 0 };

        // BUILD 330: Space key for Mac-friendly panning
        let isSpacePressed = false;

        // Expose capexTree to window for Firebase sync (IIFE scope bridge)
        Object.defineProperty(window, 'capexTree', {
            get: function() { return capexTree; },
            set: function(value) { capexTree = value; },
            configurable: true
        });

        // Expose render functions to window for Firebase sync
        // These will be defined later, so we use a lazy getter pattern
        window.getTreeRenderer = function() { return typeof render === 'function' ? render : null; };
        window.getCanvasRenderer = function() { return typeof renderCanvas === 'function' ? renderCanvas : null; };

        /**
         * Get hyperedge membership for a node ID
         * Returns the hyperedge object if node is a member, null otherwise
         */
        function getNodeHyperedge(nodeId) {
            const hyperedges = capexTree.hyperedges || [];
            for (const he of hyperedges) {
                if (he.nodeIds && he.nodeIds.includes(nodeId)) {
                    return he;
                }
            }
            return null;
        }

        /**
         * Generate a unique color for a Deep Dive hyperedge based on index
         * Uses a palette of visually distinct, pleasant colors
         */
        const HYPEREDGE_COLOR_PALETTE = [
            { h: 270, s: 70, l: 60 },  // Purple (default analysis)
            { h: 200, s: 80, l: 55 },  // Blue
            { h: 160, s: 70, l: 45 },  // Teal
            { h: 340, s: 75, l: 60 },  // Pink
            { h: 30, s: 85, l: 55 },   // Orange
            { h: 280, s: 65, l: 65 },  // Violet
            { h: 180, s: 60, l: 45 },  // Cyan
            { h: 0, s: 70, l: 60 },    // Red
            { h: 45, s: 80, l: 50 },   // Gold
            { h: 220, s: 75, l: 60 },  // Royal Blue
            { h: 300, s: 60, l: 55 },  // Magenta
            { h: 140, s: 65, l: 45 },  // Green
        ];

        function generateHyperedgeColor(index) {
            const palette = HYPEREDGE_COLOR_PALETTE;
            const color = palette[index % palette.length];
            const { h, s, l } = color;

            return {
                fill: `hsla(${h}, ${s}%, ${l}%, 0.25)`,
                border: `hsla(${h}, ${s}%, ${l}%, 0.8)`,
                glow: `hsla(${h}, ${s}%, ${l}%, 0.5)`,
                solid: `hsl(${h}, ${s}%, ${l}%)`,
                hsl: { h, s, l }
            };
        }

        /**
         * Get hyperedge color - uses custom color if set, else type-based or generated
         */
        function getHyperedgeColor(hyperedge) {
            // If hyperedge has a custom color (check multiple locations)
            const customColor = hyperedge?.metadata?.color || hyperedge?.color;
            if (customColor) {
                // Handle both object format {fill, border, glow} and string format "#rrggbb"
                if (typeof customColor === 'string') {
                    // Convert hex color to RGBA variants
                    const hex = customColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    return {
                        fill: `rgba(${r}, ${g}, ${b}, 0.25)`,
                        border: `rgba(${r}, ${g}, ${b}, 0.9)`,
                        glow: `rgba(${r}, ${g}, ${b}, 0.5)`,
                        solid: customColor
                    };
                } else {
                    // Object format
                    return {
                        fill: customColor.fill || customColor,
                        border: customColor.border || customColor,
                        glow: customColor.glow || customColor,
                        solid: customColor.solid || customColor.border || customColor
                    };
                }
            }

            const typeColors = {
                'montage': { fill: 'rgba(251, 146, 60, 0.25)', border: 'rgba(251, 146, 60, 0.8)', glow: 'rgba(251, 146, 60, 0.4)', solid: '#fb923c' },
                'argument': { fill: 'rgba(59, 130, 246, 0.25)', border: 'rgba(59, 130, 246, 0.8)', glow: 'rgba(59, 130, 246, 0.4)', solid: '#3b82f6' },
                'theme': { fill: 'rgba(168, 85, 247, 0.25)', border: 'rgba(168, 85, 247, 0.8)', glow: 'rgba(168, 85, 247, 0.4)', solid: '#a855f7' },
                'dependency-cluster': { fill: 'rgba(34, 197, 94, 0.25)', border: 'rgba(34, 197, 94, 0.8)', glow: 'rgba(34, 197, 94, 0.4)', solid: '#22c55e' },
                'analysis': { fill: 'rgba(139, 92, 246, 0.25)', border: 'rgba(139, 92, 246, 0.8)', glow: 'rgba(139, 92, 246, 0.5)', solid: '#8b5cf6' },
                'default': { fill: 'rgba(156, 163, 175, 0.25)', border: 'rgba(156, 163, 175, 0.8)', glow: 'rgba(156, 163, 175, 0.4)', solid: '#9ca3af' }
            };
            return typeColors[hyperedge?.type] || typeColors.default;
        }

        // Track which hyperedge is being focused (null = show all)
        let focusedHyperedgeId = null;

        /**
         * Focus canvas view on a specific hyperedge
         * - Hides all nodes not in the hyperedge
         * - Auto-arranges member nodes in a clean layout
         * - Centers the view on the hyperedge
         */
        function focusOnHyperedge(hyperedgeId) {
            const hyperedge = (capexTree.hyperedges || []).find(h => h.id === hyperedgeId);
            if (!hyperedge) {
                console.warn('Hyperedge not found:', hyperedgeId);
                return;
            }

            console.log('ðŸŽ¯ Focusing on hyperedge:', hyperedge.label);
            focusedHyperedgeId = hyperedgeId;

            // Get all nodes that belong to this hyperedge
            const memberIds = new Set(hyperedge.nodeIds || []);

            // Find actual node objects and arrange them
            const memberNodes = [];
            function findNodes(node) {
                if (memberIds.has(node.id)) {
                    memberNodes.push(node);
                }
                // Check subitems
                if (node.subItems) {
                    node.subItems.forEach(sub => findNodes(sub));
                }
                if (node.children) {
                    node.children.forEach(child => findNodes(child));
                }
            }

            // Search through all phases
            capexTree.children.forEach(phase => {
                const nodeList = phase.items || phase.children || [];
                nodeList.forEach(item => findNodes(item));
            });

            console.log(`ðŸŽ¯ Found ${memberNodes.length} member nodes`);

            // Separate parent nodes from subitems
            const parentNodes = memberNodes.filter(n => !n.id.startsWith('subitem-'));
            const subitemNodes = memberNodes.filter(n => n.id.startsWith('subitem-'));

            // Calculate layout dimensions
            const canvasContainer = document.getElementById('canvas-container');
            const containerWidth = canvasContainer?.offsetWidth || 1200;
            const containerHeight = canvasContainer?.offsetHeight || 800;

            // Layout parameters
            const nodeWidth = 320;
            const nodeHeight = 150;
            const padding = 80;
            const centerX = containerWidth / 2;
            const centerY = containerHeight / 2;

            // Arrange parent nodes in a row at the top
            const parentStartX = centerX - ((parentNodes.length * (nodeWidth + padding)) / 2) + padding / 2;
            parentNodes.forEach((node, idx) => {
                node.canvasX = parentStartX + idx * (nodeWidth + padding);
                node.canvasY = 100;
                node.expanded = true; // Ensure expanded to show subitems
            });

            // Arrange subitems below their parents or in a grid
            if (subitemNodes.length > 0) {
                // Try to position subitems below their parent
                subitemNodes.forEach((subitem, idx) => {
                    // Find parent by checking which parent's subItems contains this subitem
                    let parentNode = null;
                    for (const parent of parentNodes) {
                        if (parent.subItems && parent.subItems.some(s => s.id === subitem.id)) {
                            parentNode = parent;
                            break;
                        }
                    }

                    if (parentNode) {
                        // Position below parent
                        const siblingIdx = parentNode.subItems.findIndex(s => s.id === subitem.id);
                        subitem.canvasX = parentNode.canvasX + 50 + (siblingIdx % 2) * 180;
                        subitem.canvasY = parentNode.canvasY + nodeHeight + 60 + Math.floor(siblingIdx / 2) * (nodeHeight + 40);
                    } else {
                        // No parent found, arrange in grid below
                        const cols = Math.ceil(Math.sqrt(subitemNodes.length));
                        const row = Math.floor(idx / cols);
                        const col = idx % cols;
                        subitem.canvasX = centerX - (cols * (nodeWidth + padding) / 2) + col * (nodeWidth + padding);
                        subitem.canvasY = 350 + row * (nodeHeight + 60);
                    }
                });
            }

            // Re-render canvas with focus filter active
            renderCanvasWithFocus(memberIds);

            // Center the view
            canvasPan = { x: 50, y: 50 };
            canvasZoom = 0.9;
            updateCanvasTransform();

            // Show "exit focus" button
            showFocusModeIndicator(hyperedge);
        }

        /**
         * Exit focus mode and show all nodes
         */
        function exitFocusMode() {
            console.log('ðŸŽ¯ Exiting focus mode');
            focusedHyperedgeId = null;
            hideFocusModeIndicator();
            renderCanvas();
        }

        /**
         * Render canvas showing only focused nodes (or all if no focus)
         */
        function renderCanvasWithFocus(memberIds) {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('canvas-connections');

            if (!canvas || !svg) {
                console.error('Canvas elements not found');
                return;
            }

            // Clear existing content
            canvas.querySelectorAll('.canvas-node').forEach(n => n.remove());
            svg.innerHTML = '';
            canvasNodes = [];

            // Render only member nodes
            capexTree.children.forEach((phase, phaseIdx) => {
                if (phase.showInCanvas === false) return;

                const nodeList = phase.items || phase.children || [];
                nodeList.forEach((item) => {
                    renderFocusedNodeAndDescendants(item, phase, null, 0, memberIds);
                });
            });

            // Draw connections and hyperedges
            drawConnections();
            updateCanvasTransform();
        }

        /**
         * Recursively render nodes, but only if they're in the focus set
         */
        function renderFocusedNodeAndDescendants(node, phase, parentNode, nestingLevel, memberIds) {
            // Only render if this node is in the focus set
            if (!memberIds.has(node.id)) {
                // But still check children in case they're members
                const childList = node.subItems || node.children || [];
                childList.forEach(child => {
                    renderFocusedNodeAndDescendants(child, phase, node, nestingLevel + 1, memberIds);
                });
                return;
            }

            // Check if parent is collapsed
            if (parentNode && parentNode.expanded === false) {
                return;
            }

            // Render this node
            renderCanvasNode(node, phase, parentNode, nestingLevel);

            // Recursively render children that are also members
            const childList = node.subItems || node.children || [];
            if (childList.length > 0 && node.expanded !== false) {
                childList.forEach((child, childIdx) => {
                    renderFocusedNodeAndDescendants(child, phase, node, nestingLevel + 1, memberIds);
                });
            }
        }

        /**
         * Show focus mode indicator with exit button
         */
        function showFocusModeIndicator(hyperedge) {
            // Remove existing indicator
            hideFocusModeIndicator();

            const indicator = document.createElement('div');
            indicator.id = 'focus-mode-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(139, 92, 246, 0.95);
                color: white;
                padding: 12px 24px;
                border-radius: 30px;
                display: flex;
                align-items: center;
                gap: 16px;
                z-index: 1000;
                box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);
                font-size: 14px;
            `;
            indicator.innerHTML = `
                <span>ðŸŽ¯ Focused: <strong>${getHyperedgeDisplayLabel(hyperedge)}</strong></span>
                <button onclick="exitFocusMode()" style="
                    background: rgba(255,255,255,0.2);
                    border: 1px solid rgba(255,255,255,0.3);
                    color: white;
                    padding: 6px 12px;
                    border-radius: 15px;
                    cursor: pointer;
                    font-size: 12px;
                ">âœ• Show All</button>
            `;

            document.body.appendChild(indicator);
        }

        /**
         * Hide focus mode indicator
         */
        function hideFocusModeIndicator() {
            const indicator = document.getElementById('focus-mode-indicator');
            if (indicator) {
                indicator.remove();
            }
        }

        // Track which hyperedges are hidden
        let hiddenHyperedges = new Set();

        /**
         * Toggle hyperedge visibility panel
         * BUILD 361: Enhanced with suggestions and aggregates
         */
        function toggleHyperedgePanel() {
            const existing = document.getElementById('hyperedge-visibility-panel');
            if (existing) {
                existing.remove();
                return;
            }

            // Detect suggestions on panel open
            detectSuggestedHyperedges();

            const hyperedges = capexTree.hyperedges || [];
            const suggestions = suggestedHyperedges || [];

            // Always allow panel to open - show empty state with Query option
            const isEmpty = hyperedges.length === 0 && suggestions.length === 0;

            // Check if info panel is open to adjust position
            const infoPanel = document.getElementById('info-panel');
            const infoPanelOpen = infoPanel && infoPanel.classList.contains('open');
            const rightOffset = infoPanelOpen ? 470 : 20; // 450px panel + 20px margin

            const panel = document.createElement('div');
            panel.id = 'hyperedge-visibility-panel';
            panel.style.cssText = `
                position: fixed;
                top: 120px;
                right: ${rightOffset}px;
                width: 320px;
                max-height: 500px;
                background: var(--surface-elevated);
                border: 1px solid var(--border-color);
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                z-index: 999;
                overflow: hidden;
                transition: right 0.3s;
            `;

            const header = document.createElement('div');
            header.style.cssText = `
                padding: 16px;
                border-bottom: 1px solid var(--border-color);
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;
            header.innerHTML = `
                <span style="font-weight: 600; color: var(--text-primary);">ðŸ”— Hyperedges (${hyperedges.length})</span>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button onclick="showQueryBuilderModal()" title="Create by Query"
                        style="background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.3); padding: 4px 8px; border-radius: 4px; color: #6366f1; cursor: pointer; font-size: 12px;">
                        ðŸ” Query
                    </button>
                    <button onclick="document.getElementById('hyperedge-visibility-panel').remove()"
                        style="background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 18px;">âœ•</button>
                </div>
            `;

            const list = document.createElement('div');
            list.style.cssText = `
                max-height: 380px;
                overflow-y: auto;
                padding: 8px;
            `;

            // BUILD 361: Suggestions section
            if (suggestions.length > 0) {
                const suggestionsHeader = document.createElement('div');
                suggestionsHeader.style.cssText = `
                    padding: 8px 12px;
                    margin-bottom: 8px;
                    background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.1));
                    border: 1px dashed rgba(251, 191, 36, 0.4);
                    border-radius: 8px;
                `;
                suggestionsHeader.innerHTML = `
                    <div style="font-size: 12px; font-weight: 600; color: #fbbf24; margin-bottom: 8px;">
                        ðŸ’¡ Suggested Groupings (${suggestions.length})
                    </div>
                `;

                suggestions.forEach(s => {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.style.cssText = `
                        padding: 8px 10px;
                        margin-bottom: 6px;
                        background: rgba(251, 191, 36, 0.05);
                        border: 1px solid rgba(251, 191, 36, 0.2);
                        border-radius: 6px;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    `;
                    suggestionItem.innerHTML = `
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-size: 12px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${s.label}
                            </div>
                            <div style="font-size: 10px; color: var(--text-secondary);">
                                ${s.nodeIds?.length || 0} nodes â€¢ ${s.description || ''}
                            </div>
                        </div>
                        <button onclick="event.stopPropagation(); acceptSuggestion('${s.id}'); toggleHyperedgePanel(); toggleHyperedgePanel();"
                            title="Create this hyperedge"
                            style="background: rgba(34, 197, 94, 0.2); border: 1px solid rgba(34, 197, 94, 0.3); padding: 4px 8px; border-radius: 4px; color: #22c55e; cursor: pointer; font-size: 11px;">
                            âœ“
                        </button>
                        <button onclick="event.stopPropagation(); dismissSuggestion('${s.id}'); this.closest('div').parentElement.remove();"
                            title="Dismiss suggestion"
                            style="background: rgba(239, 68, 68, 0.1); border: none; padding: 4px 6px; border-radius: 4px; color: #ef4444; cursor: pointer; font-size: 10px;">
                            âœ•
                        </button>
                    `;
                    suggestionsHeader.appendChild(suggestionItem);
                });

                list.appendChild(suggestionsHeader);
            }

            // BUILD 361: Empty state with helpful guidance
            if (isEmpty) {
                const emptyState = document.createElement('div');
                emptyState.style.cssText = `
                    padding: 24px 16px;
                    text-align: center;
                `;
                emptyState.innerHTML = `
                    <div style="font-size: 40px; margin-bottom: 12px; opacity: 0.6;">ðŸ”—</div>
                    <div style="font-size: 14px; color: var(--text-primary); margin-bottom: 8px;">
                        No hyperedges yet
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 16px; line-height: 1.5;">
                        Hyperedges group related nodes across your tree.<br>
                        Create one using the Query button above!
                    </div>
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 12px;">Try queries like:</div>
                    <div style="display: flex; flex-direction: column; gap: 6px; font-size: 11px;">
                        <code style="background: rgba(99, 102, 241, 0.1); padding: 6px 10px; border-radius: 4px; color: #818cf8;">
                            "show items over $500K"
                        </code>
                        <code style="background: rgba(99, 102, 241, 0.1); padding: 6px 10px; border-radius: 4px; color: #818cf8;">
                            "find blocked items"
                        </code>
                        <code style="background: rgba(99, 102, 241, 0.1); padding: 6px 10px; border-radius: 4px; color: #818cf8;">
                            "group by status"
                        </code>
                    </div>
                `;
                list.appendChild(emptyState);
            }

            // Existing hyperedges with aggregates
            if (hyperedges.length > 0) {
                const existingHeader = document.createElement('div');
                existingHeader.style.cssText = `
                    font-size: 11px;
                    color: var(--text-secondary);
                    padding: 4px 8px;
                    margin-top: ${suggestions.length > 0 ? '8px' : '0'};
                `;
                existingHeader.textContent = 'Your Hyperedges';
                list.appendChild(existingHeader);
            }

            hyperedges.forEach(he => {
                const colorObj = getHyperedgeColor(he);
                const isHidden = hiddenHyperedges.has(he.id);
                const aggregates = calculateHyperedgeAggregates(he);
                const aggregateStr = formatHyperedgeAggregates(aggregates);

                const item = document.createElement('div');
                item.style.cssText = `
                    padding: 10px 12px;
                    margin-bottom: 6px;
                    background: ${isHidden ? 'rgba(0,0,0,0.2)' : 'rgba(139, 92, 246, 0.1)'};
                    border: 1px solid ${isHidden ? 'var(--border-color)' : colorObj.border};
                    border-left: 3px solid ${colorObj.solid || '#8B5CF6'};
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    cursor: pointer;
                    transition: all 0.2s;
                    opacity: ${isHidden ? '0.5' : '1'};
                `;
                item.innerHTML = `
                    <input type="checkbox" ${isHidden ? '' : 'checked'}
                        onchange="toggleHyperedgeVisibility('${he.id}')"
                        style="width: 18px; height: 18px; cursor: pointer; accent-color: ${colorObj.solid || '#8B5CF6'};">
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-size: 13px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${getHyperedgeDisplayLabel(he)}
                        </div>
                        <div style="font-size: 11px; color: var(--text-secondary);">
                            ${he.nodeIds?.length || 0} nodes${aggregateStr ? ' â€¢ ' + aggregateStr : ''}
                        </div>
                    </div>
                    <button onclick="event.stopPropagation(); focusOnHyperedge('${he.id}'); document.getElementById('hyperedge-visibility-panel').remove();"
                        style="background: rgba(139, 92, 246, 0.2); border: none; padding: 4px 8px; border-radius: 4px; color: #8B5CF6; cursor: pointer; font-size: 11px;">
                        ðŸŽ¯
                    </button>
                `;
                list.appendChild(item);
            });

            const footer = document.createElement('div');
            footer.style.cssText = `
                padding: 12px 16px;
                border-top: 1px solid var(--border-color);
                display: flex;
                gap: 8px;
            `;
            footer.innerHTML = `
                <button onclick="showAllHyperedges()"
                    style="flex: 1; padding: 8px; background: rgba(34, 197, 94, 0.2); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 6px; color: #22C55E; cursor: pointer; font-size: 12px;">
                    Show All
                </button>
                <button onclick="hideAllHyperedges()"
                    style="flex: 1; padding: 8px; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 6px; color: #EF4444; cursor: pointer; font-size: 12px;">
                    Hide All
                </button>
            `;

            panel.appendChild(header);
            panel.appendChild(list);
            panel.appendChild(footer);
            document.body.appendChild(panel);
        }

        /**
         * Toggle visibility of a specific hyperedge
         */
        function toggleHyperedgeVisibility(hyperedgeId) {
            if (hiddenHyperedges.has(hyperedgeId)) {
                hiddenHyperedges.delete(hyperedgeId);
            } else {
                hiddenHyperedges.add(hyperedgeId);
            }
            renderCanvas();
            // Refresh the panel
            const panel = document.getElementById('hyperedge-visibility-panel');
            if (panel) {
                panel.remove();
                toggleHyperedgePanel();
            }
        }

        /**
         * Show all hyperedges
         */
        function showAllHyperedges() {
            hiddenHyperedges.clear();
            renderCanvas();
            const panel = document.getElementById('hyperedge-visibility-panel');
            if (panel) {
                panel.remove();
                toggleHyperedgePanel();
            }
        }

        /**
         * Hide all hyperedges
         */
        function hideAllHyperedges() {
            (capexTree.hyperedges || []).forEach(he => {
                hiddenHyperedges.add(he.id);
            });
            renderCanvas();
            const panel = document.getElementById('hyperedge-visibility-panel');
            if (panel) {
                panel.remove();
                toggleHyperedgePanel();
            }
        }

        function toggleViewMode() {
            viewMode = viewMode === 'tree' ? 'canvas' : 'tree';

            if (viewMode === 'canvas') {
                console.log('ðŸŽ¨ Switching to Canvas View');
                document.getElementById('view-mode-icon').textContent = 'ðŸ“Š';
                document.getElementById('view-mode-text').textContent = 'Tree View';
                document.querySelector('.tree-view-container').classList.add('hidden');
                document.getElementById('canvas-container').classList.add('active');

                const toolbar = document.getElementById('canvas-toolbar');
                if (toolbar) {
                    toolbar.classList.add('active');
                    console.log('âœ… Canvas toolbar activated');
                } else {
                    console.error('âŒ Canvas toolbar not found!');
                }

                // Migrate coordinates if needed
                const firstPhase = capexTree.children[0];
                const firstItem = firstPhase?.items?.[0] || firstPhase?.children?.[0];
                if (!firstItem?.canvasX) {
                    migrateToCanvasCoordinates();
                } else {
                    // Even if coordinates exist, ensure expanded state is initialized
                    capexTree.children.forEach(phase => {
                        const nodeList = phase.items || phase.children || [];
                        nodeList.forEach(item => {
                            initializeExpandedState(item);
                        });
                    });
                }

                // Initialize arrow markers first time
                initializeArrowMarkers();

                renderCanvas();
                updateZoomDisplay();
                console.log('âœ… Canvas View ready');

                // Show one-time canvas tips for new users
                if (!localStorage.getItem('treelisty-canvas-tips-seen')) {
                    localStorage.setItem('treelisty-canvas-tips-seen', 'true');
                    setTimeout(() => {
                        showToast('ðŸ–±ï¸ Canvas Tips: Wheel to zoom, Space+drag to pan (or middle-click), Left-drag nodes to move. Click â“ for more!', 'info', 8000);
                    }, 500);
                }

                // Show export button in Canvas view
                const exportBtn = document.getElementById('export-canvas-btn');
                if (exportBtn) exportBtn.style.display = 'inline-flex';

                // BUILD 333: Update view dropdown to show current state
                if (window.updateViewDropdown) window.updateViewDropdown('canvas');
            } else {
                console.log('ðŸ“Š Switching to Tree View');
                document.getElementById('view-mode-icon').textContent = 'ðŸŽ¨';
                document.getElementById('view-mode-text').textContent = 'Canvas View';
                document.querySelector('.tree-view-container').classList.remove('hidden');
                document.getElementById('canvas-container').classList.remove('active');

                const toolbar = document.getElementById('canvas-toolbar');
                if (toolbar) {
                    toolbar.classList.remove('active');
                }

                // Hide export button in Tree view
                const exportBtn = document.getElementById('export-canvas-btn');
                if (exportBtn) exportBtn.style.display = 'none';

                // BUILD 333: Update view dropdown to show current state
                if (window.updateViewDropdown) window.updateViewDropdown('tree');

                render();
                console.log('âœ… Tree View ready');
            }
        }

        // =============================================================================
        // CANVAS EXPORT AS IMAGE (Build 244)
        // Professional PNG export with title, metadata, and branding
        // =============================================================================

        async function exportCanvasAsImage() {
            const canvasContainer = document.getElementById('canvas-container');
            const canvas = document.getElementById('canvas');

            if (!canvasContainer || !canvasContainer.classList.contains('active')) {
                showToast('âš ï¸ Switch to Canvas view first', 'warning');
                return;
            }

            showToast('ðŸ“· Preparing high-quality export...', 'info', 2000);

            try {
                // Get all node positions to calculate bounds
                const nodes = canvas.querySelectorAll('.canvas-node');
                if (nodes.length === 0) {
                    showToast('âš ï¸ No nodes to export', 'warning');
                    return;
                }

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                nodes.forEach(node => {
                    const rect = node.getBoundingClientRect();
                    const x = parseFloat(node.style.left) || 0;
                    const y = parseFloat(node.style.top) || 0;
                    const width = node.offsetWidth;
                    const height = node.offsetHeight;

                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x + width);
                    maxY = Math.max(maxY, y + height);
                });

                // Add generous padding
                const padding = 80;
                const headerHeight = 100;
                const footerHeight = 60;

                const contentWidth = maxX - minX + (padding * 2);
                const contentHeight = maxY - minY + (padding * 2) + headerHeight + footerHeight;

                // Create export container
                const exportContainer = document.createElement('div');
                exportContainer.id = 'export-container';
                exportContainer.style.cssText = `
                    position: fixed;
                    left: -99999px;
                    top: 0;
                    width: ${contentWidth}px;
                    height: ${contentHeight}px;
                    background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%);
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                    overflow: hidden;
                `;

                // Add subtle grid pattern
                const gridPattern = document.createElement('div');
                gridPattern.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background-image:
                        linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
                    background-size: 40px 40px;
                    pointer-events: none;
                `;
                exportContainer.appendChild(gridPattern);

                // Create header with project info
                const header = document.createElement('div');
                const patternDef = PATTERNS[currentPattern] || PATTERNS.generic;
                const totalItems = countAllItems(capexTree);
                const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });

                header.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    height: ${headerHeight}px;
                    padding: 20px 30px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border-bottom: 1px solid rgba(255,255,255,0.1);
                    background: linear-gradient(180deg, rgba(0,0,0,0.3) 0%, transparent 100%);
                `;

                header.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 16px;">
                        <div style="font-size: 28px; font-weight: 700; color: #ffffff; letter-spacing: -0.5px;">
                            ${capexTree.name || 'Untitled Project'}
                        </div>
                        <div style="
                            background: linear-gradient(135deg, #00A67D, #1D6F42);
                            padding: 4px 12px;
                            border-radius: 20px;
                            font-size: 12px;
                            font-weight: 600;
                            color: white;
                            text-transform: uppercase;
                            letter-spacing: 0.5px;
                        ">
                            ${patternDef.icon} ${patternDef.name}
                        </div>
                    </div>
                    <div style="text-align: right; color: rgba(255,255,255,0.6); font-size: 13px;">
                        <div style="font-weight: 600; color: rgba(255,255,255,0.8);">${totalItems} items</div>
                        <div>${dateStr}</div>
                    </div>
                `;
                exportContainer.appendChild(header);

                // Clone canvas content
                const canvasClone = canvas.cloneNode(true);
                canvasClone.style.cssText = `
                    position: absolute;
                    top: ${headerHeight + padding - minY}px;
                    left: ${padding - minX}px;
                    transform: none;
                `;
                exportContainer.appendChild(canvasClone);

                // Clone SVG connections
                const svgOriginal = document.getElementById('canvas-connections');
                if (svgOriginal) {
                    const svgClone = svgOriginal.cloneNode(true);
                    svgClone.style.cssText = `
                        position: absolute;
                        top: ${headerHeight + padding - minY - 5000}px;
                        left: ${padding - minX - 5000}px;
                        width: 20000px;
                        height: 20000px;
                        pointer-events: none;
                    `;
                    exportContainer.appendChild(svgClone);
                }

                // Create footer with branding
                const footer = document.createElement('div');
                footer.style.cssText = `
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    height: ${footerHeight}px;
                    padding: 15px 30px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border-top: 1px solid rgba(255,255,255,0.1);
                    background: linear-gradient(0deg, rgba(0,0,0,0.3) 0%, transparent 100%);
                `;

                footer.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 18px;">ðŸŒ³</span>
                        <span style="
                            font-size: 14px;
                            font-weight: 600;
                            color: rgba(255,255,255,0.7);
                            letter-spacing: 1px;
                        ">TreeListy</span>
                        <span style="
                            font-size: 11px;
                            color: rgba(255,255,255,0.4);
                            margin-left: 8px;
                        ">treelisty.netlify.app</span>
                    </div>
                    <div style="
                        font-size: 11px;
                        color: rgba(255,255,255,0.4);
                    ">
                        Exported ${new Date().toLocaleTimeString()}
                    </div>
                `;
                exportContainer.appendChild(footer);

                // Add to DOM
                document.body.appendChild(exportContainer);

                // Use html2canvas to capture
                const exportCanvas = await html2canvas(exportContainer, {
                    backgroundColor: null,
                    scale: 2, // 2x for retina quality
                    useCORS: true,
                    allowTaint: true,
                    logging: false
                });

                // Remove export container
                document.body.removeChild(exportContainer);

                // Convert to blob and download
                exportCanvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const safeName = (capexTree.name || 'treelisty-canvas')
                        .toLowerCase()
                        .replace(/[^a-z0-9]+/g, '-')
                        .replace(/^-|-$/g, '');
                    link.download = `${safeName}-${new Date().toISOString().slice(0,10)}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);

                    showToast('âœ… Canvas exported as PNG!', 'success');
                }, 'image/png', 1.0);

            } catch (error) {
                console.error('Canvas export error:', error);
                showToast('âŒ Export failed: ' + error.message, 'error');
            }
        }

        // Helper to count all items recursively
        function countAllItems(tree) {
            let count = 0;
            function countNode(node) {
                count++;
                const children = node.subItems || node.children || node.items || [];
                children.forEach(countNode);
            }
            if (tree.children) {
                tree.children.forEach(phase => {
                    const items = phase.items || phase.children || [];
                    items.forEach(countNode);
                });
            }
            return count;
        }

        function migrateToCanvasCoordinates() {
            let xOffset = 200;
            const ySpacing = 180;

            capexTree.children.forEach((phase, phaseIdx) => {
                let yOffset = 100;
                // Support both 'items' (standard) and 'children' (filesystem pattern)
                const nodeList = phase.items || phase.children || [];
                nodeList.forEach((item) => {
                    item.canvasX = xOffset + 50;
                    item.canvasY = yOffset;
                    yOffset += ySpacing;

                    // Ensure all items with subItems have expanded state initialized
                    initializeExpandedState(item);
                });
                xOffset += 400;
            });
        }

        // Clear all canvas coordinates recursively to force re-positioning
        function clearCanvasCoordinates(node) {
            delete node.canvasX;
            delete node.canvasY;

            // Recursively clear for all child types
            const childList = node.items || node.children || node.subItems || [];
            childList.forEach(child => clearCanvasCoordinates(child));
        }

        // Recursively initialize expanded state for all items with children
        function initializeExpandedState(item) {
            // Support both 'subItems' (standard) and 'children' (filesystem pattern)
            const childList = item.subItems || item.children || [];
            if (childList.length > 0) {
                // Default to expanded if not explicitly set
                if (item.expanded === undefined) {
                    item.expanded = true;
                    console.log('Initializing expanded=true for:', item.name);
                }

                // Recursively initialize for all descendants
                childList.forEach(child => {
                    initializeExpandedState(child);
                });
            }
        }

        // Listen for Firebase sync updates
        window.addEventListener('treelisty-sync-update', (e) => {
            console.log('ðŸ”¥ Received sync update event, re-rendering...');
            // Always re-render tree view
            render();
            // Check if canvas view is active and render it too
            const canvasContainer = document.getElementById('canvas-container');
            if (canvasContainer && canvasContainer.classList.contains('active')) {
                renderCanvas();
            }
            // Mark as changed so auto-save will persist the synced data
            if (typeof treeManager !== 'undefined' && treeManager.markAsChanged) {
                treeManager.markAsChanged();
                console.log('ðŸ”¥ Marked tree as changed for auto-save');
            }
        });

        function renderCanvas() {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('canvas-connections');

            // Clear existing content
            canvas.querySelectorAll('.canvas-node').forEach(n => n.remove());
            svg.innerHTML = '';
            canvasNodes = [];

            // Render all nodes recursively
            capexTree.children.forEach((phase, phaseIdx) => {
                // Check if phase is visible in Canvas View (default: true)
                if (phase.showInCanvas === false) {
                    console.log(`Skipping phase "${phase.name}" - hidden in Canvas View`);
                    return; // Skip this phase
                }

                // Support both 'items' (standard) and 'children' (filesystem pattern)
                const nodeList = phase.items || phase.children || [];
                nodeList.forEach((item, itemIdx) => {
                    // Preserve existing positions for root items to prevent jumping
                    // Only set initial position if not already set
                    if (!item.canvasX || !item.canvasY) {
                        item.canvasX = item.canvasX || 50;
                        item.canvasY = item.canvasY || (50 + itemIdx * 180);
                    }
                    renderNodeAndDescendants(item, phase, null, 0);
                });
            });

            // Draw connection lines after all nodes are positioned
            drawConnections();
            updateCanvasTransform();
        }

        // Recursive function to render a node and all its descendants
        function renderNodeAndDescendants(node, phase, parentNode, nestingLevel) {
            // Check if parent is collapsed - if so, don't render this node
            if (parentNode && parentNode.expanded === false) {
                return;  // Parent is collapsed, skip this node
            }

            // Render this node with hierarchical depth
            renderCanvasNode(node, phase, parentNode, nestingLevel);

            // Recursively render all descendants only if this node is expanded (or has no explicit state)
            // Support both 'subItems' (standard) and 'children' (filesystem pattern)
            const childList = node.subItems || node.children || [];
            if (childList.length > 0) {
                // Default to expanded if not set
                if (node.expanded === undefined) {
                    node.expanded = true;
                }

                childList.forEach((child, childIdx) => {
                    // Auto-position children based on nesting level
                    if (!child.canvasX) {
                        // Each nesting level moves further right
                        child.canvasX = (node.canvasX || 0) + 350;
                        child.canvasY = (node.canvasY || 0) + (childIdx * 120);
                    }

                    // Recursively render this child and its descendants
                    renderNodeAndDescendants(child, phase, node, nestingLevel + 1);
                });
            }
        }

        // =============================================================================
        // CONVEX HULL COMPUTATION (Graham Scan Algorithm)
        // =============================================================================

        /**
         * Compute convex hull using Graham scan algorithm
         * @param {Array} points - Array of {x, y} points
         * @returns {Array} Points forming the convex hull in counter-clockwise order
         */
        function computeConvexHull(points) {
            if (points.length < 3) return points;

            // Sort points by y-coordinate (bottom to top), then x-coordinate (left to right)
            const sorted = [...points].sort((a, b) => {
                if (a.y !== b.y) return a.y - b.y;
                return a.x - b.x;
            });

            // Helper: Compute cross product of vectors OA and OB
            const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

            // Build lower hull
            const lower = [];
            for (const p of sorted) {
                while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                    lower.pop();
                }
                lower.push(p);
            }

            // Build upper hull
            const upper = [];
            for (let i = sorted.length - 1; i >= 0; i--) {
                const p = sorted[i];
                while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                    upper.pop();
                }
                upper.push(p);
            }

            // Remove last point of each half because it's repeated
            lower.pop();
            upper.pop();

            return lower.concat(upper);
        }

        /**
         * Create a capsule/pill SVG path connecting two points
         * Used for 2-node hyperedges where convex hull fails
         */
        function createCapsulePath(p1, p2, radius) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.hypot(dx, dy);

            // If points overlap, create a circle
            if (dist < 1) {
                return `M ${p1.x - radius} ${p1.y}
                        a ${radius} ${radius} 0 1 0 ${radius * 2} 0
                        a ${radius} ${radius} 0 1 0 ${-radius * 2} 0 Z`;
            }

            // Normalize direction vector
            const nx = dx / dist;
            const ny = dy / dist;

            // Perpendicular vector scaled by radius
            const px = -ny * radius;
            const py = nx * radius;

            // Four corners of the capsule body
            const c1 = { x: p1.x + px, y: p1.y + py };
            const c2 = { x: p1.x - px, y: p1.y - py };
            const c3 = { x: p2.x - px, y: p2.y - py };
            const c4 = { x: p2.x + px, y: p2.y + py };

            // SVG path: straight sides + semicircle end caps
            return `M ${c1.x} ${c1.y}
                    L ${c4.x} ${c4.y}
                    A ${radius} ${radius} 0 0 1 ${c3.x} ${c3.y}
                    L ${c2.x} ${c2.y}
                    A ${radius} ${radius} 0 0 1 ${c1.x} ${c1.y} Z`;
        }

        // =============================================================================
        // HYPEREDGE VISUALIZATION
        // =============================================================================

        /**
         * BUILD 283: Get a display label for a hyperedge
         * If no label exists, derive a concise one from description (<5 words)
         */
        function getHyperedgeDisplayLabel(hyperedge) {
            // If name exists (used by welcome tree and older hyperedges), use it
            if (hyperedge.name && hyperedge.name.trim()) {
                return hyperedge.name;
            }

            // If label exists and is meaningful, use it
            if (hyperedge.label && hyperedge.label.trim() && hyperedge.label !== 'Unnamed Hyperedge') {
                return hyperedge.label;
            }

            // Try to derive from description
            if (hyperedge.description && hyperedge.description.trim()) {
                const desc = hyperedge.description.trim();
                // Take first sentence or up to 50 chars
                let concise = desc.split(/[.!?]/)[0].trim();
                if (concise.length > 50) {
                    // Take first ~5 words
                    const words = concise.split(/\s+/).slice(0, 5);
                    concise = words.join(' ');
                    if (concise.length < desc.length) concise += '...';
                }
                return concise || 'Relationship';
            }

            // Fallback based on type
            if (hyperedge.type) {
                const typeLabels = {
                    'analysis': 'Deep Dive Analysis',
                    'dependency-cluster': 'Dependency Cluster',
                    'montage': 'Montage',
                    'argument': 'Argument',
                    'theme': 'Theme'
                };
                return typeLabels[hyperedge.type] || `${hyperedge.type} Relationship`;
            }

            return 'Relationship';
        }

        /**
         * BUILD 361: Calculate aggregates for a hyperedge's member nodes
         * Returns pattern-aware metrics (cost, progress, lead time, etc.)
         * Called live on render for dynamic updates
         */
        function calculateHyperedgeAggregates(hyperedge) {
            const nodeIds = hyperedge.nodeIds || [];
            const nodes = nodeIds.map(id => getNodeById(id)).filter(Boolean);

            if (nodes.length === 0) {
                return { count: 0 };
            }

            const pattern = capexTree.pattern?.key || 'generic';

            // Helper functions
            const sum = arr => arr.reduce((a, b) => a + b, 0);
            const avg = arr => arr.length > 0 ? sum(arr) / arr.length : 0;
            const countBy = (arr, key) => arr.reduce((acc, item) => {
                const val = item[key] || 'Unknown';
                acc[val] = (acc[val] || 0) + 1;
                return acc;
            }, {});

            // Universal aggregates (all patterns)
            const aggregates = {
                count: nodes.length,
                avgProgress: Math.round(avg(nodes.map(n => n.pmProgress || 0))),
                statusCounts: countBy(nodes, 'pmStatus'),
                priorityCounts: countBy(nodes, 'pmPriority')
            };

            // Cost aggregates (CAPEX, Sales, Generic patterns)
            if (['capex', 'generic', 'sales'].includes(pattern)) {
                const costs = nodes.map(n => n.cost || n.dealValue || 0).filter(c => c > 0);
                if (costs.length > 0) {
                    aggregates.totalCost = sum(costs);
                    aggregates.avgCost = Math.round(avg(costs));
                    aggregates.maxCost = Math.max(...costs);
                    aggregates.minCost = Math.min(...costs);
                    aggregates.costNodeCount = costs.length;
                }
            }

            // Lead time aggregates (CAPEX pattern)
            if (pattern === 'capex') {
                const leadTimes = nodes.map(n => n.leadTime || 0).filter(lt => lt > 0);
                if (leadTimes.length > 0) {
                    aggregates.totalLeadTime = sum(leadTimes);
                    aggregates.maxLeadTime = Math.max(...leadTimes);
                    aggregates.avgLeadTime = Math.round(avg(leadTimes));
                }
            }

            // Sales-specific aggregates
            if (pattern === 'sales') {
                const probabilities = nodes.map(n => n.probability || 0).filter(p => p > 0);
                if (probabilities.length > 0) {
                    aggregates.avgProbability = Math.round(avg(probabilities));
                }
                aggregates.stageCounts = countBy(nodes, 'dealStage');
            }

            // Assignee aggregates (all patterns)
            const assignees = nodes.map(n => n.pmAssignee).filter(a => a && a.trim());
            if (assignees.length > 0) {
                aggregates.assigneeCounts = countBy(nodes, 'pmAssignee');
                aggregates.assigneeCount = Object.keys(aggregates.assigneeCounts).length;
            }

            // Due date aggregates
            const dueDates = nodes.map(n => n.dueDate).filter(d => d);
            if (dueDates.length > 0) {
                const sorted = dueDates.sort();
                aggregates.nextDue = sorted[0];
                aggregates.lastDue = sorted[sorted.length - 1];
                // Check for overdue
                const today = new Date().toISOString().split('T')[0];
                aggregates.overdueCount = dueDates.filter(d => d < today).length;
            }

            return aggregates;
        }

        /**
         * BUILD 361: Format aggregates for display
         * Returns a compact string like "$2.3M â€¢ 67% â€¢ 4 nodes"
         */
        function formatHyperedgeAggregates(aggregates, compact = true) {
            const parts = [];
            const pattern = capexTree.pattern?.key || 'generic';

            // Cost (primary for CAPEX/Sales)
            if (aggregates.totalCost) {
                const cost = aggregates.totalCost;
                if (cost >= 1000000) {
                    parts.push(`$${(cost / 1000000).toFixed(1)}M`);
                } else if (cost >= 1000) {
                    parts.push(`$${(cost / 1000).toFixed(0)}K`);
                } else {
                    parts.push(`$${cost}`);
                }
            }

            // Progress (universal)
            if (aggregates.avgProgress > 0) {
                parts.push(`${aggregates.avgProgress}%`);
            }

            // Lead time (CAPEX)
            if (aggregates.maxLeadTime && pattern === 'capex') {
                parts.push(`${aggregates.maxLeadTime}mo`);
            }

            // Probability (Sales)
            if (aggregates.avgProbability && pattern === 'sales') {
                parts.push(`${aggregates.avgProbability}% prob`);
            }

            // Overdue warning
            if (aggregates.overdueCount > 0) {
                parts.push(`âš ï¸${aggregates.overdueCount} overdue`);
            }

            if (compact && parts.length > 3) {
                return parts.slice(0, 3).join(' â€¢ ');
            }

            return parts.join(' â€¢ ');
        }

        // BUILD 361: Suggested hyperedges (in-memory, opt-in)
        let suggestedHyperedges = [];
        const DISMISSED_SUGGESTIONS_KEY = 'treelisty-dismissed-suggestions';

        /**
         * BUILD 361: Get dismissed suggestion IDs from localStorage
         */
        function getDismissedSuggestions() {
            try {
                return JSON.parse(localStorage.getItem(DISMISSED_SUGGESTIONS_KEY) || '[]');
            } catch (e) {
                return [];
            }
        }

        /**
         * BUILD 361: Dismiss a suggestion (won't appear again)
         */
        function dismissSuggestion(suggestionId) {
            const dismissed = getDismissedSuggestions();
            if (!dismissed.includes(suggestionId)) {
                dismissed.push(suggestionId);
                localStorage.setItem(DISMISSED_SUGGESTIONS_KEY, JSON.stringify(dismissed));
            }
            suggestedHyperedges = suggestedHyperedges.filter(s => s.id !== suggestionId);
        }

        /**
         * BUILD 361: Accept a suggestion - create permanent hyperedge
         */
        function acceptSuggestion(suggestionId) {
            const suggestion = suggestedHyperedges.find(s => s.id === suggestionId);
            if (!suggestion) return;

            // Create real hyperedge
            saveState('Create Hyperedge from Suggestion');
            const hyperedge = addHyperedge(
                suggestion.type || 'suggested',
                suggestion.label,
                suggestion.nodeIds,
                {
                    color: suggestion.color,
                    description: suggestion.description,
                    source: 'auto-detected'
                }
            );

            // Set custom color if provided
            if (hyperedge && suggestion.color) {
                hyperedge.color = suggestion.color;
            }

            // Remove from suggestions
            suggestedHyperedges = suggestedHyperedges.filter(s => s.id !== suggestionId);

            // Re-render
            renderCanvas();
            showToast(`Created hyperedge: ${suggestion.label}`, 'success');
        }

        /**
         * BUILD 361: Detect suggested hyperedges based on tree data
         * Runs on tree load and after significant edits
         */
        function detectSuggestedHyperedges() {
            const dismissed = getDismissedSuggestions();
            const existingEdgeNodeSets = (capexTree.hyperedges || []).map(h =>
                new Set(h.nodeIds || [])
            );
            const suggestions = [];
            const pattern = capexTree.pattern?.key || 'generic';

            // Collect all items from tree
            const allItems = [];
            function collectItems(node) {
                if (node.type === 'item' || node.type === 'subtask') {
                    allItems.push(node);
                }
                (node.items || []).forEach(collectItems);
                (node.children || []).forEach(child => {
                    collectItems(child);
                    (child.items || []).forEach(collectItems);
                });
            }
            collectItems(capexTree);

            if (allItems.length < 2) return [];

            // Helper: Check if suggestion already exists as real hyperedge
            const alreadyExists = (nodeIds) => {
                const newSet = new Set(nodeIds);
                return existingEdgeNodeSets.some(existingSet => {
                    if (existingSet.size !== newSet.size) return false;
                    for (const id of newSet) {
                        if (!existingSet.has(id)) return false;
                    }
                    return true;
                });
            };

            // Helper: Create suggestion if valid
            const addSuggestion = (id, label, nodeIds, color, description, type = 'auto') => {
                if (nodeIds.length < 2) return;
                if (dismissed.includes(id)) return;
                if (alreadyExists(nodeIds)) return;
                suggestions.push({ id, label, nodeIds, color, description, type });
            };

            // ===========================================
            // UNIVERSAL RULES (All Patterns)
            // ===========================================

            // Rule 1: Status clusters (3+ items with same status)
            const statusGroups = {};
            allItems.forEach(item => {
                const status = item.pmStatus || 'Unknown';
                if (!statusGroups[status]) statusGroups[status] = [];
                statusGroups[status].push(item.id);
            });
            Object.entries(statusGroups).forEach(([status, ids]) => {
                if (ids.length >= 3 && status !== 'Unknown') {
                    const colors = {
                        'Done': '#22c55e',
                        'Completed': '#22c55e',
                        'In Progress': '#f59e0b',
                        'To Do': '#6366f1',
                        'Blocked': '#ef4444',
                        'Not Started': '#94a3b8'
                    };
                    addSuggestion(
                        `suggest-status-${status.toLowerCase().replace(/\s+/g, '-')}`,
                        `${status} Items`,
                        ids,
                        colors[status] || '#8b5cf6',
                        `${ids.length} items with status "${status}"`,
                        'status-cluster'
                    );
                }
            });

            // Rule 2: Assignee clusters (2+ items with same assignee)
            const assigneeGroups = {};
            allItems.forEach(item => {
                const assignee = item.pmAssignee?.trim();
                if (assignee) {
                    if (!assigneeGroups[assignee]) assigneeGroups[assignee] = [];
                    assigneeGroups[assignee].push(item.id);
                }
            });
            Object.entries(assigneeGroups).forEach(([assignee, ids]) => {
                if (ids.length >= 2) {
                    addSuggestion(
                        `suggest-assignee-${assignee.toLowerCase().replace(/\s+/g, '-')}`,
                        `${assignee}'s Items`,
                        ids,
                        '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'),
                        `${ids.length} items assigned to ${assignee}`,
                        'assignee-cluster'
                    );
                }
            });

            // Rule 3: Priority clusters (3+ items with same priority)
            const priorityGroups = {};
            allItems.forEach(item => {
                const priority = item.pmPriority;
                if (priority) {
                    if (!priorityGroups[priority]) priorityGroups[priority] = [];
                    priorityGroups[priority].push(item.id);
                }
            });
            Object.entries(priorityGroups).forEach(([priority, ids]) => {
                if (ids.length >= 3) {
                    const colors = {
                        'Critical': '#ef4444',
                        'High': '#f97316',
                        'Medium': '#eab308',
                        'Low': '#22c55e'
                    };
                    addSuggestion(
                        `suggest-priority-${priority.toLowerCase()}`,
                        `${priority} Priority`,
                        ids,
                        colors[priority] || '#8b5cf6',
                        `${ids.length} items with ${priority} priority`,
                        'priority-cluster'
                    );
                }
            });

            // Rule 4: Blocked items (items with incomplete dependencies)
            const blockedIds = allItems
                .filter(item => {
                    const deps = item.dependencies || [];
                    return deps.some(depId => {
                        const depNode = getNodeById(depId);
                        return depNode && depNode.pmStatus !== 'Done' && depNode.pmStatus !== 'Completed';
                    });
                })
                .map(item => item.id);
            if (blockedIds.length >= 2) {
                addSuggestion(
                    'suggest-blocked-items',
                    'Blocked Items',
                    blockedIds,
                    '#ef4444',
                    `${blockedIds.length} items waiting on incomplete dependencies`,
                    'blocked'
                );
            }

            // ===========================================
            // PATTERN-SPECIFIC RULES
            // ===========================================

            // CAPEX: High cost items (top 25% by cost)
            if (['capex', 'generic', 'sales'].includes(pattern)) {
                const itemsWithCost = allItems.filter(i => (i.cost || 0) > 0);
                if (itemsWithCost.length >= 4) {
                    const costs = itemsWithCost.map(i => i.cost).sort((a, b) => b - a);
                    const threshold = costs[Math.floor(costs.length * 0.25)] || costs[0];
                    const highCostIds = itemsWithCost
                        .filter(i => i.cost >= threshold)
                        .map(i => i.id);
                    if (highCostIds.length >= 2) {
                        const total = highCostIds.reduce((sum, id) => {
                            const node = getNodeById(id);
                            return sum + (node?.cost || 0);
                        }, 0);
                        const formatted = total >= 1000000
                            ? `$${(total/1000000).toFixed(1)}M`
                            : `$${(total/1000).toFixed(0)}K`;
                        addSuggestion(
                            'suggest-high-cost',
                            `High Cost Items`,
                            highCostIds,
                            '#dc2626',
                            `${highCostIds.length} items totaling ${formatted}`,
                            'cost-cluster'
                        );
                    }
                }
            }

            // CAPEX: Long lead time items
            if (pattern === 'capex') {
                const longLeadItems = allItems.filter(i => (i.leadTime || 0) >= 6);
                if (longLeadItems.length >= 2) {
                    addSuggestion(
                        'suggest-long-lead',
                        'Long Lead Items',
                        longLeadItems.map(i => i.id),
                        '#7c3aed',
                        `${longLeadItems.length} items with 6+ month lead time`,
                        'lead-time-cluster'
                    );
                }
            }

            // Philosophy: Extract philosopher names from descriptions
            if (pattern === 'philosophy') {
                const philosophers = ['Plato', 'Aristotle', 'Kant', 'Hegel', 'Nietzsche', 'Descartes',
                    'Hume', 'Locke', 'Spinoza', 'Leibniz', 'Socrates', 'Marx', 'Kierkegaard',
                    'Heidegger', 'Wittgenstein', 'Sartre', 'Husserl', 'Schopenhauer'];

                philosophers.forEach(philosopher => {
                    const regex = new RegExp(philosopher, 'i');
                    const matches = allItems.filter(i =>
                        regex.test(i.name || '') || regex.test(i.description || '')
                    );
                    if (matches.length >= 2) {
                        addSuggestion(
                            `suggest-philosopher-${philosopher.toLowerCase()}`,
                            `${philosopher}'s Ideas`,
                            matches.map(i => i.id),
                            '#8b5cf6',
                            `${matches.length} items referencing ${philosopher}`,
                            'philosopher-cluster'
                        );
                    }
                });
            }

            // Sales: Deal stage clusters
            if (pattern === 'sales') {
                const stageGroups = {};
                allItems.forEach(item => {
                    const stage = item.dealStage;
                    if (stage) {
                        if (!stageGroups[stage]) stageGroups[stage] = [];
                        stageGroups[stage].push(item.id);
                    }
                });
                Object.entries(stageGroups).forEach(([stage, ids]) => {
                    if (ids.length >= 2) {
                        addSuggestion(
                            `suggest-stage-${stage.toLowerCase().replace(/\s+/g, '-')}`,
                            `${stage} Deals`,
                            ids,
                            '#0ea5e9',
                            `${ids.length} deals in ${stage} stage`,
                            'stage-cluster'
                        );
                    }
                });
            }

            // Film: Character clusters (look for character names in descriptions)
            if (pattern === 'film') {
                // Look for quoted names or "Character:" patterns
                const characterMentions = {};
                allItems.forEach(item => {
                    const text = `${item.name || ''} ${item.description || ''}`;
                    // Match patterns like "John:", "MARY:", or names in quotes
                    const matches = text.match(/\b([A-Z][a-z]+):/g) || [];
                    matches.forEach(m => {
                        const name = m.replace(':', '');
                        if (!characterMentions[name]) characterMentions[name] = new Set();
                        characterMentions[name].add(item.id);
                    });
                });
                Object.entries(characterMentions).forEach(([character, idSet]) => {
                    const ids = Array.from(idSet);
                    if (ids.length >= 2) {
                        addSuggestion(
                            `suggest-character-${character.toLowerCase()}`,
                            `${character}'s Scenes`,
                            ids,
                            '#f472b6',
                            `${ids.length} items featuring ${character}`,
                            'character-cluster'
                        );
                    }
                });
            }

            suggestedHyperedges = suggestions;
            console.log(`ðŸ” Detected ${suggestions.length} suggested hyperedges`);
            return suggestions;
        }

        /**
         * BUILD 361: Query builder modal for creating hyperedges by filter
         */
        function showQueryBuilderModal() {
            // Close hyperedge panel if open
            const existingPanel = document.getElementById('hyperedge-visibility-panel');
            if (existingPanel) existingPanel.remove();

            const pattern = capexTree.pattern?.key || 'generic';

            // Define available fields based on pattern
            const fields = [
                { key: 'pmStatus', label: 'Status', type: 'select', options: ['To Do', 'In Progress', 'Done', 'Blocked', 'Not Started'] },
                { key: 'pmPriority', label: 'Priority', type: 'select', options: ['Critical', 'High', 'Medium', 'Low'] },
                { key: 'pmAssignee', label: 'Assignee', type: 'text' },
                { key: 'name', label: 'Name contains', type: 'text' },
                { key: 'description', label: 'Description contains', type: 'text' },
                { key: 'type', label: 'Node Type', type: 'select', options: ['item', 'subtask', 'phase'] }
            ];

            // Add pattern-specific fields
            if (['capex', 'generic', 'sales'].includes(pattern)) {
                fields.push({ key: 'cost', label: 'Cost ($)', type: 'number', operators: ['>', '<', '>=', '<=', '='] });
            }
            if (pattern === 'capex') {
                fields.push({ key: 'leadTime', label: 'Lead Time (months)', type: 'number', operators: ['>', '<', '>=', '<=', '='] });
            }
            if (pattern === 'sales') {
                fields.push({ key: 'probability', label: 'Probability (%)', type: 'number', operators: ['>', '<', '>=', '<=', '='] });
                fields.push({ key: 'dealStage', label: 'Deal Stage', type: 'text' });
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'ðŸ” Create Hyperedge by Query';

            const fieldOptions = fields.map(f => `<option value="${f.key}">${f.label}</option>`).join('');

            modalBody.innerHTML = `
                <div style="padding: 16px;">
                    <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 16px;">
                        Find nodes matching your criteria and group them into a hyperedge.
                    </p>

                    <div id="query-conditions" style="margin-bottom: 16px;">
                        <div class="query-condition" style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center;">
                            <select class="query-field" style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: #1e293b; color: #f8fafc; flex: 1;">
                                ${fieldOptions}
                            </select>
                            <select class="query-operator" style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: #1e293b; color: #f8fafc; width: 100px;">
                                <option value="equals">equals</option>
                                <option value="contains">contains</option>
                                <option value="not_equals">not equals</option>
                                <option value=">">></option>
                                <option value="<"><</option>
                            </select>
                            <input type="text" class="query-value" placeholder="Value..."
                                style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--surface); color: var(--text-primary); flex: 1;">
                        </div>
                    </div>

                    <button onclick="addQueryCondition()" style="
                        padding: 6px 12px;
                        background: rgba(99, 102, 241, 0.1);
                        border: 1px dashed rgba(99, 102, 241, 0.3);
                        border-radius: 6px;
                        color: #6366f1;
                        cursor: pointer;
                        font-size: 12px;
                        margin-bottom: 16px;
                    ">+ Add Condition (AND)</button>

                    <div style="padding: 12px; background: var(--surface); border-radius: 8px; margin-bottom: 16px;">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Preview:</div>
                        <div id="query-preview" style="font-size: 14px; color: var(--text-primary); font-weight: 500;">
                            Click "Preview" to see matching nodes
                        </div>
                    </div>

                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1;">
                            <label style="font-size: 12px; color: var(--text-secondary); display: block; margin-bottom: 4px;">Hyperedge Name</label>
                            <input type="text" id="query-hyperedge-name" placeholder="e.g., High Priority Items"
                                style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--surface); color: var(--text-primary);">
                        </div>
                        <div style="width: 100px;">
                            <label style="font-size: 12px; color: var(--text-secondary); display: block; margin-bottom: 4px;">Color</label>
                            <input type="color" id="query-hyperedge-color" value="#8b5cf6"
                                style="width: 100%; height: 34px; padding: 2px; border-radius: 6px; border: 1px solid var(--border); cursor: pointer;">
                        </div>
                    </div>

                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                        <input type="checkbox" id="query-dynamic" style="width: 16px; height: 16px;">
                        <label for="query-dynamic" style="font-size: 13px; color: var(--text-secondary);">
                            Update automatically when tree changes
                        </label>
                    </div>
                </div>
            `;

            document.querySelector('#modal .modal-footer').innerHTML = `
                <button class="btn" onclick="document.getElementById('modal').style.display='none'">Cancel</button>
                <button class="btn" onclick="previewQueryResults()" style="background: rgba(99, 102, 241, 0.2); color: #6366f1;">Preview</button>
                <button class="btn btn-primary" onclick="createHyperedgeFromQuery()">Create Hyperedge</button>
            `;

            modal.style.display = 'flex';
        }

        /**
         * BUILD 361: Add another condition to the query builder
         */
        function addQueryCondition() {
            const container = document.getElementById('query-conditions');
            const pattern = capexTree.pattern?.key || 'generic';

            const fields = [
                { key: 'pmStatus', label: 'Status' },
                { key: 'pmPriority', label: 'Priority' },
                { key: 'pmAssignee', label: 'Assignee' },
                { key: 'name', label: 'Name contains' },
                { key: 'description', label: 'Description contains' },
                { key: 'type', label: 'Node Type' }
            ];
            if (['capex', 'generic', 'sales'].includes(pattern)) {
                fields.push({ key: 'cost', label: 'Cost ($)' });
            }
            if (pattern === 'capex') {
                fields.push({ key: 'leadTime', label: 'Lead Time (months)' });
            }

            const fieldOptions = fields.map(f => `<option value="${f.key}">${f.label}</option>`).join('');

            const condition = document.createElement('div');
            condition.className = 'query-condition';
            condition.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px; align-items: center;';
            condition.innerHTML = `
                <span style="color: var(--text-secondary); font-size: 12px;">AND</span>
                <select class="query-field" style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: #1e293b; color: #f8fafc; flex: 1;">
                    ${fieldOptions}
                </select>
                <select class="query-operator" style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: #1e293b; color: #f8fafc; width: 100px;">
                    <option value="equals">equals</option>
                    <option value="contains">contains</option>
                    <option value="not_equals">not equals</option>
                    <option value=">">></option>
                    <option value="<"><</option>
                </select>
                <input type="text" class="query-value" placeholder="Value..."
                    style="padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--surface); color: var(--text-primary); flex: 1;">
                <button onclick="this.parentElement.remove()" style="background: none; border: none; color: #ef4444; cursor: pointer; font-size: 16px;">âœ•</button>
            `;
            container.appendChild(condition);
        }

        /**
         * BUILD 361: Evaluate query conditions against tree nodes
         */
        function evaluateQueryConditions() {
            const conditions = [];
            document.querySelectorAll('.query-condition').forEach(row => {
                const field = row.querySelector('.query-field')?.value;
                const operator = row.querySelector('.query-operator')?.value;
                const value = row.querySelector('.query-value')?.value?.trim();
                if (field && value) {
                    conditions.push({ field, operator, value });
                }
            });

            if (conditions.length === 0) {
                return [];
            }

            // Collect all items from tree
            const allItems = [];
            function collectItems(node) {
                if (node.type === 'item' || node.type === 'subtask' || node.type === 'phase') {
                    allItems.push(node);
                }
                (node.items || []).forEach(collectItems);
                (node.children || []).forEach(child => {
                    collectItems(child);
                    (child.items || []).forEach(collectItems);
                });
            }
            collectItems(capexTree);

            // Filter items by ALL conditions (AND logic)
            return allItems.filter(item => {
                return conditions.every(cond => {
                    const itemValue = item[cond.field];
                    const condValue = cond.value;

                    switch (cond.operator) {
                        case 'equals':
                            return String(itemValue || '').toLowerCase() === condValue.toLowerCase();
                        case 'not_equals':
                            return String(itemValue || '').toLowerCase() !== condValue.toLowerCase();
                        case 'contains':
                            return String(itemValue || '').toLowerCase().includes(condValue.toLowerCase());
                        case '>':
                            return Number(itemValue || 0) > Number(condValue);
                        case '<':
                            return Number(itemValue || 0) < Number(condValue);
                        case '>=':
                            return Number(itemValue || 0) >= Number(condValue);
                        case '<=':
                            return Number(itemValue || 0) <= Number(condValue);
                        default:
                            return false;
                    }
                });
            });
        }

        /**
         * BUILD 361: Preview query results
         */
        function previewQueryResults() {
            const matches = evaluateQueryConditions();
            const preview = document.getElementById('query-preview');

            if (matches.length === 0) {
                preview.innerHTML = '<span style="color: var(--text-secondary);">No matching nodes found</span>';
            } else {
                const names = matches.slice(0, 5).map(m => m.name).join(', ');
                const more = matches.length > 5 ? ` +${matches.length - 5} more` : '';
                preview.innerHTML = `<span style="color: #22c55e;">${matches.length} nodes match:</span> ${names}${more}`;
            }

            // Auto-generate name if empty
            const nameInput = document.getElementById('query-hyperedge-name');
            if (!nameInput.value && matches.length > 0) {
                const firstCondition = document.querySelector('.query-condition');
                if (firstCondition) {
                    const field = firstCondition.querySelector('.query-field')?.value;
                    const value = firstCondition.querySelector('.query-value')?.value;
                    if (field && value) {
                        const fieldLabels = {
                            pmStatus: 'Status',
                            pmPriority: 'Priority',
                            pmAssignee: 'Assigned to',
                            cost: 'Cost',
                            leadTime: 'Lead Time'
                        };
                        nameInput.value = `${fieldLabels[field] || field}: ${value}`;
                    }
                }
            }
        }

        /**
         * BUILD 361: Create hyperedge from query results
         */
        function createHyperedgeFromQuery() {
            const matches = evaluateQueryConditions();

            if (matches.length < 2) {
                showToast('Need at least 2 matching nodes to create a hyperedge', 'error');
                return;
            }

            const name = document.getElementById('query-hyperedge-name').value || 'Query Result';
            const color = document.getElementById('query-hyperedge-color').value || '#8b5cf6';
            const isDynamic = document.getElementById('query-dynamic').checked;

            // Collect conditions for dynamic hyperedge
            const conditions = [];
            document.querySelectorAll('.query-condition').forEach(row => {
                const field = row.querySelector('.query-field')?.value;
                const operator = row.querySelector('.query-operator')?.value;
                const value = row.querySelector('.query-value')?.value?.trim();
                if (field && value) {
                    conditions.push({ field, operator, value });
                }
            });

            saveState('Create Hyperedge from Query');

            const hyperedge = addHyperedge(
                'query',
                name,
                matches.map(m => m.id),
                {
                    color: color,
                    description: `Query-generated: ${matches.length} matching nodes`,
                    query: isDynamic ? { conditions, logic: 'AND' } : null,
                    dynamic: isDynamic
                }
            );

            if (hyperedge) {
                hyperedge.color = color;
            }

            document.getElementById('modal').style.display = 'none';
            renderCanvas();
            showToast(`Created hyperedge "${name}" with ${matches.length} nodes`, 'success');
        }

        // SVG offset to match the large canvas-connections area (top: -5000px, left: -5000px)
        const SVG_OFFSET = 5000;

        /**
         * Draw all hyperedges as convex hull blobs
         * Performance optimized: Uses O(1) Map lookup instead of O(N) recursive getNodeById
         * Enhanced: Groups each hyperedge for hover/focus interactions
         */
        function drawHyperedges() {
            const svg = document.getElementById('canvas-connections');
            const allHyperedges = getAllHyperedges();

            // Filter out hidden hyperedges
            const hyperedges = (allHyperedges || []).filter(he => !hiddenHyperedges.has(he.id));

            console.log('ðŸ”— drawHyperedges called, found', allHyperedges?.length || 0, 'hyperedges,', hyperedges.length, 'visible');
            console.log('ðŸ”— canvasNodes array has', canvasNodes.length, 'entries');

            if (!hyperedges || hyperedges.length === 0) {
                console.log('ðŸ”— No visible hyperedges to draw');
                return;
            }

            // Track all hyperedge groups for hover interactions
            const hyperedgeGroups = [];

            // Build O(1) lookup map from canvasNodes to avoid O(N) getNodeById calls per node
            // This reduces complexity from O(H * N * TreeDepth) to O(H * N) where H = hyperedges, N = nodes per edge
            const nodeLookup = new Map();
            canvasNodes.forEach(n => {
                if (n.data && n.data.id) {
                    nodeLookup.set(n.data.id, n.data);
                }
            });
            console.log('ðŸ”— nodeLookup built with', nodeLookup.size, 'nodes. Keys:', Array.from(nodeLookup.keys()).slice(0, 15));

            // Color palette for hyperedge types
            const typeColors = {
                'montage': 'rgba(251, 146, 60, 0.15)',       // Orange
                'argument': 'rgba(59, 130, 246, 0.15)',      // Blue
                'theme': 'rgba(168, 85, 247, 0.15)',         // Purple
                'dependency-cluster': 'rgba(34, 197, 94, 0.15)', // Green
                'analysis': 'rgba(139, 92, 246, 0.25)',      // Violet/Purple for Deep Dive (slightly more opaque)
                'default': 'rgba(156, 163, 175, 0.15)'       // Gray
            };

            hyperedges.forEach((hyperedge, idx) => {
                // Guard against malformed hyperedges
                if (!hyperedge || !hyperedge.nodeIds || !Array.isArray(hyperedge.nodeIds)) {
                    console.warn(`âš ï¸ Skipping malformed hyperedge[${idx}]:`, hyperedge);
                    return;
                }

                console.log(`ðŸ”— Processing hyperedge[${idx}]: "${hyperedge.label || hyperedge.name}" with nodeIds:`, hyperedge.nodeIds);

                // Get all nodes in this hyperedge using O(1) lookup
                const nodes = hyperedge.nodeIds.map(id => {
                    const found = nodeLookup.get(id);
                    if (!found) {
                        console.warn(`  âŒ Node ID "${id}" NOT found in canvasNodes`);
                    } else {
                        console.log(`  âœ… Node ID "${id}" found at (${found.canvasX}, ${found.canvasY})`);
                    }
                    return found;
                }).filter(n => n);

                console.log(`ðŸ”— Hyperedge "${hyperedge.label}": ${hyperedge.nodeIds.length} nodeIds â†’ ${nodes.length} found in canvasNodes`);

                if (nodes.length < 2) {
                    console.warn(`âŒ Hyperedge ${hyperedge.id} has < 2 valid nodes, skipping. NodeIds:`, hyperedge.nodeIds);
                    return;
                }

                // Create SVG group for this hyperedge (enables hover/focus interactions)
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'hyperedge-group');
                group.setAttribute('data-hyperedge-id', hyperedge.id);
                group.style.transition = 'opacity 0.3s ease';
                hyperedgeGroups.push({ group, hyperedge });

                // Get node positions (center of each node card) + SVG offset
                const points = nodes.map(node => ({
                    x: (node.canvasX || 0) + 160 + SVG_OFFSET,  // Center X (320px width / 2) + offset
                    y: (node.canvasY || 0) + 60 + SVG_OFFSET   // Center Y (120px height / 2) + offset
                }));
                console.log('ðŸ”— Raw points (with SVG_OFFSET):', points);

                // =====================================================================
                // SPECIAL CASE: 2-node hyperedges use capsule/pill shape
                // Convex hull fails for 2 points (collinear), so we draw a capsule
                // =====================================================================
                if (nodes.length === 2) {
                    const p1 = points[0];
                    const p2 = points[1];
                    const capsuleRadius = 80;  // Generous radius for visibility

                    const colorObj = getHyperedgeColor(hyperedge);
                    const capsulePath = createCapsulePath(p1, p2, capsuleRadius);

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('class', 'hyperedge-capsule');
                    path.setAttribute('d', capsulePath);
                    path.setAttribute('fill', colorObj.fill);
                    path.setAttribute('stroke', colorObj.border);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('stroke-dasharray', '8,4');
                    path.style.cursor = 'pointer';
                    path.style.transition = 'opacity 0.2s';
                    path.addEventListener('mouseenter', () => path.style.opacity = '0.8');
                    path.addEventListener('mouseleave', () => path.style.opacity = '1');
                    path.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });

                    group.appendChild(path);
                    console.log('ðŸ”— Capsule path created for 2-node hyperedge');

                    // Add label at midpoint
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;

                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', midX);
                    label.setAttribute('y', midY - 35);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', colorObj.solid || colorObj.border);
                    label.setAttribute('font-size', '14');
                    label.setAttribute('font-weight', 'bold');
                    label.style.cursor = 'pointer';
                    label.style.textShadow = '0 0 6px rgba(0,0,0,0.8)';
                    label.textContent = getHyperedgeDisplayLabel(hyperedge);
                    label.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });
                    group.appendChild(label);

                    const hint = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    hint.setAttribute('x', midX);
                    hint.setAttribute('y', midY - 18);
                    hint.setAttribute('text-anchor', 'middle');
                    hint.setAttribute('fill', 'rgba(255,255,255,0.6)');
                    hint.setAttribute('font-size', '11');
                    hint.style.cursor = 'pointer';
                    hint.style.textShadow = '0 0 4px rgba(0,0,0,0.8)';
                    hint.textContent = 'â–¶ click to explore relationship';
                    hint.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });
                    group.appendChild(hint);

                    // Append group to SVG and return (skip hull processing)
                    svg.appendChild(group);
                    return;
                }

                // Add padding around the hull with SAFE division (avoid NaN from div-by-zero)
                const padding = 60;  // Increased for better visibility
                const centroid = {
                    x: points.reduce((sum, p) => sum + p.x, 0) / points.length,
                    y: points.reduce((sum, p) => sum + p.y, 0) / points.length
                };
                console.log('ðŸ”— Centroid:', centroid);

                // Safe padding: avoid division by zero when point equals centroid
                const paddedPoints = points.map(p => {
                    const dx = p.x - centroid.x;
                    const dy = p.y - centroid.y;
                    const dist = Math.hypot(dx, dy);

                    // If point is at centroid (dist=0), expand outward in a default direction
                    if (dist < 1) {
                        // Use point index to spread overlapping points
                        const angle = (points.indexOf(p) / points.length) * 2 * Math.PI;
                        return {
                            x: centroid.x + Math.cos(angle) * padding,
                            y: centroid.y + Math.sin(angle) * padding
                        };
                    }

                    return {
                        x: p.x + dx * (padding / dist),
                        y: p.y + dy * (padding / dist)
                    };
                });
                console.log('ðŸ”— Padded points:', paddedPoints);

                // Check for NaN values
                const hasNaN = paddedPoints.some(p => isNaN(p.x) || isNaN(p.y));
                if (hasNaN) {
                    console.error('âŒ NaN detected in padded points! Skipping hyperedge.');
                    return;
                }

                // Compute convex hull
                const hull = computeConvexHull(paddedPoints);
                console.log('ðŸ”— Convex hull computed with', hull.length, 'points');

                if (hull.length < 3) {
                    // Fallback: if hull fails (collinear points), create a simple rounded rect around the centroid
                    console.warn(`âš ï¸ Hyperedge ${hyperedge.id} hull has < 3 points, using fallback rectangle`);

                    // Calculate bounding box
                    const minX = Math.min(...paddedPoints.map(p => p.x)) - 20;
                    const maxX = Math.max(...paddedPoints.map(p => p.x)) + 20;
                    const minY = Math.min(...paddedPoints.map(p => p.y)) - 20;
                    const maxY = Math.max(...paddedPoints.map(p => p.y)) + 20;

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', minX);
                    rect.setAttribute('y', minY);
                    rect.setAttribute('width', maxX - minX);
                    rect.setAttribute('height', maxY - minY);
                    rect.setAttribute('rx', '20');
                    rect.setAttribute('ry', '20');

                    // Get color object (custom from metadata, or type-based fallback)
                    const colorObj = getHyperedgeColor(hyperedge);
                    rect.setAttribute('fill', colorObj.fill);
                    rect.setAttribute('stroke', colorObj.border);
                    rect.setAttribute('stroke-width', '2');
                    rect.setAttribute('stroke-dasharray', '8,4');
                    rect.style.cursor = 'pointer';
                    rect.style.transition = 'opacity 0.2s';
                    rect.addEventListener('mouseenter', () => rect.style.opacity = '0.8');
                    rect.addEventListener('mouseleave', () => rect.style.opacity = '1');
                    rect.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });

                    group.appendChild(rect);
                    console.log('ðŸ”— Fallback rect created');
                } else {
                    // Create SVG polygon for the hull
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const pointsStr = hull.map(p => `${p.x},${p.y}`).join(' ');
                    polygon.setAttribute('points', pointsStr);

                    // Get color object (custom from metadata, or type-based fallback)
                    const colorObj = getHyperedgeColor(hyperedge);
                    polygon.setAttribute('fill', colorObj.fill);
                    polygon.setAttribute('stroke', colorObj.border);
                    polygon.setAttribute('stroke-width', '2');
                    polygon.setAttribute('stroke-dasharray', '8,4');
                    polygon.style.cursor = 'pointer';
                    polygon.style.transition = 'opacity 0.2s';
                    polygon.addEventListener('mouseenter', () => polygon.style.opacity = '0.8');
                    polygon.addEventListener('mouseleave', () => polygon.style.opacity = '1');
                    polygon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showHyperedgeInfo(hyperedge);
                    });

                    group.appendChild(polygon);
                    console.log('ðŸ”— Polygon appended to group');
                }

                // Add label at centroid (also clickable)
                const labelColorObj = getHyperedgeColor(hyperedge);

                // Main label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', centroid.x);
                label.setAttribute('y', centroid.y - 35);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', labelColorObj.solid || labelColorObj.border);
                label.setAttribute('font-size', '14');
                label.setAttribute('font-weight', 'bold');
                label.style.cursor = 'pointer';
                label.style.textShadow = '0 0 6px rgba(0,0,0,0.8)';
                label.textContent = getHyperedgeDisplayLabel(hyperedge);
                label.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showHyperedgeInfo(hyperedge);
                });
                group.appendChild(label);

                // Subtitle hint "click to explore"
                const hint = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                hint.setAttribute('x', centroid.x);
                hint.setAttribute('y', centroid.y - 18);
                hint.setAttribute('text-anchor', 'middle');
                hint.setAttribute('fill', 'rgba(255,255,255,0.6)');
                hint.setAttribute('font-size', '11');
                hint.style.cursor = 'pointer';
                hint.style.textShadow = '0 0 4px rgba(0,0,0,0.8)';
                hint.textContent = 'â–¶ click to explore relationship';
                hint.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showHyperedgeInfo(hyperedge);
                });
                group.appendChild(hint);

                // Append group to SVG
                svg.appendChild(group);
                console.log('ðŸ”— Group added to SVG');
            });

            // =========================================================================
            // HOVER INTERACTIONS: Dim other hyperedges AND unrelated nodes when hovering one
            // =========================================================================
            hyperedgeGroups.forEach(({ group, hyperedge }) => {
                group.addEventListener('mouseenter', () => {
                    // Dim all other hyperedge groups
                    hyperedgeGroups.forEach(({ group: otherGroup, hyperedge: otherHyperedge }) => {
                        if (otherHyperedge.id !== hyperedge.id) {
                            otherGroup.style.opacity = '0.2';
                        }
                    });

                    // Dim all canvas nodes NOT in this hyperedge
                    const memberNodeIds = new Set(hyperedge.nodeIds || []);
                    document.querySelectorAll('.canvas-node').forEach(nodeEl => {
                        const nodeId = nodeEl.dataset.itemId;  // Canvas nodes use data-item-id
                        if (!memberNodeIds.has(nodeId)) {
                            nodeEl.style.opacity = '0.25';
                            nodeEl.style.transition = 'opacity 0.3s ease';
                        } else {
                            // Highlight member nodes
                            nodeEl.style.opacity = '1';
                            nodeEl.style.boxShadow = '0 0 20px rgba(139, 92, 246, 0.6)';
                            nodeEl.style.transition = 'opacity 0.3s ease, box-shadow 0.3s ease';
                        }
                    });
                });

                group.addEventListener('mouseleave', () => {
                    // Restore all hyperedge groups
                    hyperedgeGroups.forEach(({ group: otherGroup }) => {
                        otherGroup.style.opacity = '1';
                    });

                    // Restore all canvas nodes
                    document.querySelectorAll('.canvas-node').forEach(nodeEl => {
                        nodeEl.style.opacity = '1';
                        nodeEl.style.boxShadow = '';
                    });
                });
            });

            console.log('ðŸ”— drawHyperedges complete with', hyperedgeGroups.length, 'groups');
        }

        /**
         * Show hyperedge info panel with philosophy relationship fields
         */
        function showHyperedgeInfo(hyperedge) {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'ðŸ”— Hyperedge Details';

            const meta = hyperedge.metadata || {};
            const philo = meta.philosophyFields || {};
            const isPhilosophy = currentPattern === 'philosophy';
            const pattern = capexTree.pattern?.key || 'generic';

            // Calculate live aggregates
            const aggregates = calculateHyperedgeAggregates(hyperedge);
            const nodeCount = hyperedge.nodeIds?.length || 0;

            // Get member nodes for display
            const memberNodes = [];
            function findMemberNodes(node) {
                if (hyperedge.nodeIds?.includes(node.id)) {
                    memberNodes.push(node);
                }
                if (node.subItems) node.subItems.forEach(findMemberNodes);
                if (node.children) node.children.forEach(findMemberNodes);
            }
            capexTree.children?.forEach(phase => {
                (phase.items || phase.children || []).forEach(findMemberNodes);
            });

            // Build aggregates display
            let aggregatesHTML = '';
            if (aggregates.count > 0) {
                const parts = [];
                if (aggregates.totalCost) parts.push(`<span style="color: #22c55e;">ðŸ’° ${formatCost(aggregates.totalCost)}</span>`);
                if (aggregates.avgProgress > 0) parts.push(`<span style="color: #6366f1;">ðŸ“Š ${Math.round(aggregates.avgProgress)}% avg</span>`);

                // Status breakdown
                const statusColors = { 'Done': '#22c55e', 'In Progress': '#f59e0b', 'To Do': '#94a3b8', 'Blocked': '#ef4444' };
                const statusParts = Object.entries(aggregates.statusCounts || {})
                    .map(([status, count]) => `<span style="color: ${statusColors[status] || '#94a3b8'};">${count} ${status}</span>`)
                    .join(' â€¢ ');

                aggregatesHTML = `
                    <div style="padding: 16px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 10px; margin-bottom: 16px;">
                        <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px;">ðŸ“Š Live Aggregates</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 16px; font-size: 14px; font-weight: 500;">
                            ${parts.join('')}
                        </div>
                        ${statusParts ? `<div style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">${statusParts}</div>` : ''}
                    </div>
                `;
            }

            // Build query conditions display (for query-generated hyperedges)
            let queryHTML = '';
            if (hyperedge.query?.conditions?.length > 0) {
                const conditionsList = hyperedge.query.conditions.map(c =>
                    `<div style="padding: 6px 10px; background: rgba(99, 102, 241, 0.1); border-radius: 4px; font-size: 12px;">
                        <span style="color: #818cf8;">${c.field}</span>
                        <span style="color: var(--text-secondary);">${c.operator}</span>
                        <span style="color: #22c55e;">"${c.value}"</span>
                    </div>`
                ).join('');
                queryHTML = `
                    <div style="padding: 16px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <span style="font-size: 14px;">ðŸ”</span>
                            <span style="font-size: 11px; color: #fbbf24; text-transform: uppercase; letter-spacing: 1px;">Query-Based Grouping</span>
                            ${hyperedge.dynamic ? '<span style="padding: 2px 8px; background: rgba(34, 197, 94, 0.2); border-radius: 4px; font-size: 10px; color: #22c55e;">DYNAMIC</span>' : ''}
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                            ${conditionsList}
                        </div>
                    </div>
                `;
            }

            // Build member nodes list with status indicators
            let memberNodesHTML = '';
            if (memberNodes.length > 0) {
                const nodeItems = memberNodes.slice(0, 8).map(n => {
                    const statusColor = { 'Done': '#22c55e', 'In Progress': '#f59e0b', 'To Do': '#94a3b8', 'Blocked': '#ef4444' }[n.pmStatus] || '#94a3b8';
                    return `
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                            <span style="width: 8px; height: 8px; border-radius: 50%; background: ${statusColor};"></span>
                            <span style="flex: 1; font-size: 13px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${n.name}</span>
                            ${n.cost ? `<span style="font-size: 11px; color: #22c55e;">${formatCost(n.cost)}</span>` : ''}
                        </div>
                    `;
                }).join('');
                const moreCount = memberNodes.length - 8;
                memberNodesHTML = `
                    <div style="margin-bottom: 16px;">
                        <div style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px;">ðŸ“ Member Nodes (${nodeCount})</div>
                        <div style="display: grid; gap: 6px; max-height: 200px; overflow-y: auto;">
                            ${nodeItems}
                            ${moreCount > 0 ? `<div style="padding: 8px; text-align: center; font-size: 12px; color: var(--text-secondary);">+ ${moreCount} more nodes</div>` : ''}
                        </div>
                    </div>
                `;
            }

            // AI Analysis section
            let analysisHTML = '';
            if (meta.aiAnalysis || hyperedge.aiInsight) {
                analysisHTML = `
                    <div style="padding: 16px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <span style="font-size: 14px;">ðŸ§ </span>
                            <span style="font-size: 11px; color: #a78bfa; text-transform: uppercase; letter-spacing: 1px;">AI Analysis</span>
                        </div>
                        <p style="margin: 0; color: var(--text-primary); line-height: 1.6; font-size: 13px;">
                            ${meta.aiAnalysis || hyperedge.aiInsight}
                        </p>
                    </div>
                `;
            }

            // Philosophy-specific fields (condensed)
            let philosophySection = '';
            if (isPhilosophy && Object.keys(philo).length > 0) {
                const philoItems = [];
                if (philo.dialecticalRelation) philoItems.push(`<div><strong>Dialectical:</strong> ${philo.dialecticalRelation}</div>`);
                if (philo.argumentativeFlow) philoItems.push(`<div><strong>Flow:</strong> ${philo.argumentativeFlow}</div>`);
                if (philo.conceptualBridge) philoItems.push(`<div><strong>Bridge:</strong> ${philo.conceptualBridge}</div>`);
                if (philo.tension) philoItems.push(`<div style="color: #f87171;"><strong>Tension:</strong> ${philo.tension}</div>`);
                if (philo.synthesis) philoItems.push(`<div style="color: #4ade80;"><strong>Synthesis:</strong> ${philo.synthesis}</div>`);

                philosophySection = `
                    <div style="padding: 16px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <span style="font-size: 14px;">ðŸ›ï¸</span>
                            <span style="font-size: 11px; color: #a78bfa; text-transform: uppercase; letter-spacing: 1px;">Philosophy Analysis</span>
                        </div>
                        <div style="display: grid; gap: 8px; font-size: 13px; color: var(--text-primary); line-height: 1.5;">
                            ${philoItems.join('')}
                        </div>
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div style="padding: 24px; max-width: 550px;">
                    <!-- Editable Header -->
                    <div style="margin-bottom: 20px;">
                        <input type="text" id="hyperedge-name-input" value="${(hyperedge.name || hyperedge.label || '').replace(/"/g, '&quot;')}"
                            placeholder="Hyperedge name..."
                            style="width: 100%; padding: 12px; font-size: 18px; font-weight: 600; background: rgba(0,0,0,0.2); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary);">
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <span style="font-size: 12px; color: var(--text-secondary);">${hyperedge.type || 'manual'} â€¢ ${nodeCount} nodes</span>
                            <span style="font-size: 12px; color: var(--text-secondary);">${hyperedge.createdAt ? new Date(hyperedge.createdAt).toLocaleDateString() : ''}</span>
                            <input type="color" id="hyperedge-color-input" value="${hyperedge.color || '#8b5cf6'}"
                                style="width: 24px; height: 24px; border: none; border-radius: 4px; cursor: pointer;" title="Change color">
                        </div>
                    </div>

                    <!-- Description -->
                    <div style="margin-bottom: 16px;">
                        <textarea id="hyperedge-desc-input" rows="2" placeholder="Describe why these nodes are grouped together..."
                            style="width: 100%; padding: 10px; font-size: 13px; background: rgba(0,0,0,0.2); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); resize: vertical; line-height: 1.5;">${hyperedge.description || ''}</textarea>
                    </div>

                    ${aggregatesHTML}
                    ${queryHTML}
                    ${analysisHTML}
                    ${philosophySection}
                    ${memberNodesHTML}

                    <!-- Action Buttons -->
                    <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px;">
                        <button onclick="analyzeHyperedgeWithAI('${hyperedge.id}')"
                            style="flex: 1; min-width: 120px; padding: 10px 16px; background: rgba(139, 92, 246, 0.2); color: #a78bfa; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px; cursor: pointer; font-size: 13px; display: flex; align-items: center; justify-content: center; gap: 6px;">
                            <span>ðŸ§ </span> Analyze
                        </button>
                        <button onclick="document.getElementById('modal').style.display='none'; focusOnHyperedge('${hyperedge.id}')"
                            style="flex: 1; min-width: 120px; padding: 10px 16px; background: rgba(99, 102, 241, 0.2); color: #818cf8; border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; cursor: pointer; font-size: 13px; display: flex; align-items: center; justify-content: center; gap: 6px;">
                            <span>ðŸŽ¯</span> Focus View
                        </button>
                        <button onclick="deleteHyperedgeWithConfirm('${hyperedge.id}')"
                            style="padding: 10px 16px; background: rgba(239, 68, 68, 0.1); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 8px; cursor: pointer; font-size: 13px;">
                            ðŸ—‘ï¸
                        </button>
                    </div>
                </div>
            `;

            // Set up auto-save on blur
            setTimeout(() => {
                const nameInput = document.getElementById('hyperedge-name-input');
                const descInput = document.getElementById('hyperedge-desc-input');
                const colorInput = document.getElementById('hyperedge-color-input');

                const saveChanges = () => {
                    const he = capexTree.hyperedges?.find(h => h.id === hyperedge.id);
                    if (!he) return;

                    const newName = nameInput?.value?.trim();
                    const newDesc = descInput?.value?.trim();
                    const newColor = colorInput?.value;

                    let changed = false;
                    if (newName && newName !== (he.name || he.label)) {
                        he.name = newName;
                        he.label = newName;
                        changed = true;
                    }
                    if (newDesc !== he.description) {
                        he.description = newDesc;
                        changed = true;
                    }
                    if (newColor !== he.color) {
                        he.color = newColor;
                        changed = true;
                    }

                    if (changed) {
                        saveState('Edit Hyperedge');
                        renderCanvas();
                    }
                };

                nameInput?.addEventListener('blur', saveChanges);
                descInput?.addEventListener('blur', saveChanges);
                colorInput?.addEventListener('change', saveChanges);
            }, 100);

            document.querySelector('#modal .modal-footer').innerHTML = `
                <button class="btn btn-primary" onclick="document.getElementById('modal').style.display='none'">Done</button>
            `;

            modal.style.display = 'flex';
        }

        /**
         * BUILD 364: Analyze hyperedge relationship with AI
         */
        async function analyzeHyperedgeWithAI(hyperedgeId) {
            const hyperedge = capexTree.hyperedges?.find(h => h.id === hyperedgeId);
            if (!hyperedge) return;

            // Get member nodes
            const memberNodes = [];
            function findNodes(node) {
                if (hyperedge.nodeIds?.includes(node.id)) {
                    memberNodes.push({ name: node.name, description: node.description, status: node.pmStatus, cost: node.cost });
                }
                if (node.subItems) node.subItems.forEach(findNodes);
                if (node.children) node.children.forEach(findNodes);
            }
            capexTree.children?.forEach(phase => {
                (phase.items || phase.children || []).forEach(findNodes);
            });

            const pattern = capexTree.pattern?.key || 'generic';
            const nodesSummary = memberNodes.map(n => `- ${n.name}${n.description ? ': ' + n.description.slice(0, 100) : ''}`).join('\n');

            const prompt = `Analyze why these ${memberNodes.length} items are grouped together in this "${hyperedge.name || hyperedge.label || 'hyperedge'}" relationship.

Pattern: ${pattern}
Hyperedge type: ${hyperedge.type || 'manual'}
${hyperedge.query?.conditions ? 'Query conditions: ' + hyperedge.query.conditions.map(c => `${c.field} ${c.operator} "${c.value}"`).join(' AND ') : ''}

Member nodes:
${nodesSummary}

Provide a concise (2-3 sentences) analysis explaining:
1. The key relationship or theme connecting these items
2. Why this grouping is meaningful for the ${pattern} context
3. Any insights or patterns you notice

Be specific and insightful, not generic.`;

            showToast('Analyzing relationship...', 'info');

            try {
                const response = await callAIWithStreaming(prompt, 'Analyze hyperedge relationship', false);

                if (response) {
                    // Save analysis to hyperedge
                    hyperedge.aiInsight = response;
                    if (!hyperedge.metadata) hyperedge.metadata = {};
                    hyperedge.metadata.aiAnalysis = response;
                    hyperedge.metadata.analysisDate = new Date().toISOString();

                    saveState('AI Hyperedge Analysis');

                    // Refresh the modal
                    showHyperedgeInfo(hyperedge);
                    showToast('Analysis complete!', 'success');
                }
            } catch (error) {
                console.error('AI analysis failed:', error);
                showToast('Analysis failed. Check API key.', 'error');
            }
        }

        /**
         * Delete hyperedge with confirmation
         */
        function deleteHyperedgeWithConfirm(hyperedgeId) {
            if (confirm('Delete this hyperedge? Member nodes will remain but lose their visual grouping.')) {
                window.deleteHyperedge(hyperedgeId);
                document.getElementById('modal').style.display = 'none';
            }
        }

        /**
         * BUILD 282: Edit hyperedge label and description
         */
        function editHyperedge(hyperedgeId) {
            if (!capexTree.hyperedges) return;
            const hyperedge = capexTree.hyperedges.find(h => h.id === hyperedgeId);
            if (!hyperedge) {
                showToast('Hyperedge not found', 'error');
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            modalBody.innerHTML = `
                <div style="padding: 30px; max-width: 500px;">
                    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 24px;">
                        <div style="font-size: 48px;">âœï¸</div>
                        <div>
                            <h3 style="color: var(--treeplex-primary); margin-bottom: 4px;">Edit Hyperedge</h3>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                Update the label and description
                            </div>
                        </div>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">Label</label>
                        <input type="text" id="edit-hyperedge-label" value="${(hyperedge.label || '').replace(/"/g, '&quot;')}"
                            style="width: 100%; padding: 10px 12px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                            placeholder="e.g., Dialectical Opposition, Causal Link">
                    </div>

                    <div style="margin-bottom: 24px;">
                        <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">Description</label>
                        <textarea id="edit-hyperedge-description" rows="3"
                            style="width: 100%; padding: 10px 12px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-size: 14px; resize: vertical;"
                            placeholder="Describe the relationship between the connected nodes...">${(hyperedge.description || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
                    </div>

                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button onclick="showHyperedgeInfo(capexTree.hyperedges.find(h => h.id === '${hyperedgeId}'))"
                            style="padding: 10px 20px; background: rgba(107, 114, 128, 0.2); color: var(--text-secondary); border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; font-size: 13px;">
                            Cancel
                        </button>
                        <button onclick="saveHyperedgeEdit('${hyperedgeId}')"
                            style="padding: 10px 20px; background: var(--treeplex-primary); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">
                            Save Changes
                        </button>
                    </div>
                </div>
            `;

            // Focus the label input
            setTimeout(() => {
                const labelInput = document.getElementById('edit-hyperedge-label');
                if (labelInput) labelInput.focus();
            }, 100);
        }

        /**
         * BUILD 282: Save hyperedge edits
         */
        function saveHyperedgeEdit(hyperedgeId) {
            if (!capexTree.hyperedges) return;
            const hyperedge = capexTree.hyperedges.find(h => h.id === hyperedgeId);
            if (!hyperedge) {
                showToast('Hyperedge not found', 'error');
                return;
            }

            const labelInput = document.getElementById('edit-hyperedge-label');
            const descInput = document.getElementById('edit-hyperedge-description');

            const newLabel = labelInput?.value.trim() || 'Unnamed Hyperedge';
            const newDesc = descInput?.value.trim() || '';

            // Update hyperedge
            hyperedge.label = newLabel;
            hyperedge.description = newDesc;

            // Save state and re-render
            saveState('Edit hyperedge');
            renderCanvas();
            drawHyperedges();

            // Show updated info modal
            showHyperedgeInfo(hyperedge);
            showToast('Hyperedge updated', 'success');
        }

        /**
         * BUILD 283: Deep dive into a hyperedge relationship using AI
         * Analyzes the connected nodes in the context of the current tree
         * Uses handleAnalyzeSelection directly for reliable execution
         */
        function deepDiveHyperedge(hyperedgeId) {
            if (!capexTree.hyperedges) return;
            const hyperedge = capexTree.hyperedges.find(h => h.id === hyperedgeId);
            if (!hyperedge) {
                showToast('Hyperedge not found', 'error');
                return;
            }

            // Find all nodes in this hyperedge
            const nodeIds = hyperedge.nodeIds || [];
            if (nodeIds.length < 2) {
                showToast('Hyperedge needs at least 2 nodes for deep dive', 'error');
                return;
            }

            // Gather nodes from the tree
            const nodes = [];
            function findNode(item) {
                if (nodeIds.includes(item.id)) {
                    nodes.push(item);
                }
                if (item.subItems) {
                    item.subItems.forEach(findNode);
                }
            }
            capexTree.children.forEach(phase => {
                if (nodeIds.includes(phase.id)) {
                    nodes.push(phase);
                }
                phase.items?.forEach(findNode);
            });

            if (nodes.length < 2) {
                showToast('Could not find enough nodes for deep dive', 'error');
                return;
            }

            // Close the modal first
            document.getElementById('modal').style.display = 'none';

            // Store context about the existing hyperedge for the analysis
            window._hyperedgeDeepDiveContext = {
                label: getHyperedgeDisplayLabel(hyperedge),
                type: hyperedge.type || 'general',
                description: hyperedge.description || '',
                philosophyFields: hyperedge.metadata?.philosophyFields || null
            };

            // Trigger the deep dive analysis using handleAnalyzeSelection
            showToast(`Starting deep dive on ${nodes.length} nodes...`, 'info');
            handleAnalyzeSelection(nodes);
        }

        // =============================================================================
        // END HYPEREDGE VISUALIZATION
        // =============================================================================

        function drawConnections() {
            // Skip drawing connections for filesystem pattern (uses indent-based hierarchy)
            if (currentPattern === 'filesystem') {
                return;
            }

            const svg = document.getElementById('canvas-connections');
            svg.innerHTML = '';

            // Draw hyperedges first (so they appear behind regular connections)
            drawHyperedges();

            // Recursively draw connections for all nodes
            capexTree.children.forEach(phase => {
                // Skip hidden phases - don't draw connections for nodes that aren't visible
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach(item => {
                    drawNodeConnections(item);
                });
            });
        }

        // Recursive function to draw connections for a node and its descendants
        function drawNodeConnections(node) {
            // Only draw connections if this node is expanded (showing children)
            if (node.expanded !== false && node.subItems && node.subItems.length > 0) {
                node.subItems.forEach(subtask => {
                    // Only draw line if subtask is actually visible
                    if (isNodeVisible(subtask.id)) {
                        drawConnection(
                            node.canvasX + 160, node.canvasY + 60,      // From parent center-right
                            subtask.canvasX, subtask.canvasY + 60,      // To subtask center-left
                            'rgba(99, 102, 241, 0.5)',                  // Purple for parent-child
                            'solid'
                        );
                    }

                    // Recursively draw connections for this subtask's descendants
                    drawNodeConnections(subtask);
                });
            }

            // Draw lines for dependencies only if both nodes are visible
            if (node.dependencies && node.dependencies.length > 0) {
                node.dependencies.forEach(depId => {
                    const depNode = canvasNodes.find(n => n.data.id === depId);
                    if (depNode && depNode.data) {
                        // Only draw if both the dependency and this node are visible
                        if (isNodeVisible(depId) && isNodeVisible(node.id)) {
                            drawConnection(
                                depNode.data.canvasX + 160, depNode.data.canvasY + 60,  // From dependency
                                node.canvasX, node.canvasY + 60,                        // To dependent item
                                'rgba(239, 68, 68, 0.4)',                               // Red for dependencies
                                'dashed'
                            );
                        }
                    }
                });
            }
        }

        function drawConnection(x1, y1, x2, y2, color, style = 'solid') {
            const svg = document.getElementById('canvas-connections');

            // Adjust coordinates for SVG offset
            x1 += SVG_OFFSET;
            y1 += SVG_OFFSET;
            x2 += SVG_OFFSET;
            y2 += SVG_OFFSET;

            // Create curved path (Bezier curve)
            const midX = (x1 + x2) / 2;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

            // Curved line from x1,y1 to x2,y2
            const d = `M ${x1} ${y1} Q ${midX} ${y1}, ${midX} ${(y1 + y2) / 2} T ${x2} ${y2}`;

            path.setAttribute('d', d);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            if (style === 'dashed') {
                path.setAttribute('stroke-dasharray', '5,5');
            }

            // Add arrow marker
            path.setAttribute('marker-end', 'url(#arrowhead-' + style + ')');

            svg.appendChild(path);
        }

        // Initialize arrow markers for SVG
        function initializeArrowMarkers() {
            const svg = document.getElementById('canvas-connections');

            // Define arrow markers
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Solid arrow (for parent-child)
            const solidMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            solidMarker.setAttribute('id', 'arrowhead-solid');
            solidMarker.setAttribute('markerWidth', '10');
            solidMarker.setAttribute('markerHeight', '10');
            solidMarker.setAttribute('refX', '9');
            solidMarker.setAttribute('refY', '3');
            solidMarker.setAttribute('orient', 'auto');
            const solidPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            solidPath.setAttribute('points', '0 0, 10 3, 0 6');
            solidPath.setAttribute('fill', 'rgba(99, 102, 241, 0.5)');
            solidMarker.appendChild(solidPath);

            // Dashed arrow (for dependencies)
            const dashedMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            dashedMarker.setAttribute('id', 'arrowhead-dashed');
            dashedMarker.setAttribute('markerWidth', '10');
            dashedMarker.setAttribute('markerHeight', '10');
            dashedMarker.setAttribute('refX', '9');
            dashedMarker.setAttribute('refY', '3');
            dashedMarker.setAttribute('orient', 'auto');
            const dashedPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            dashedPath.setAttribute('points', '0 0, 10 3, 0 6');
            dashedPath.setAttribute('fill', 'rgba(239, 68, 68, 0.4)');
            dashedMarker.appendChild(dashedPath);

            defs.appendChild(solidMarker);
            defs.appendChild(dashedMarker);
            svg.appendChild(defs);
        }

        /**
         * Show dialog to create a hyperedge from selected nodes
         */
        function showHyperedgeDialog() {
            // Remove any existing dialog
            const existingDialog = document.getElementById('hyperedge-dialog');
            if (existingDialog) existingDialog.remove();

            // Create modal dialog
            const dialog = document.createElement('div');
            dialog.id = 'hyperedge-dialog';
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--card-bg);
                border: 2px solid var(--border);
                border-radius: 12px;
                padding: 24px;
                z-index: 10001;
                box-shadow: 0 12px 48px rgba(0,0,0,0.8);
                min-width: 400px;
                max-width: 500px;
            `;

            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: var(--text-primary);">Create Hyperedge</h3>
                <p style="color: var(--text-secondary); font-size: 14px;">
                    Creating hyperedge with ${selectedNodes.length} selected nodes
                </p>

                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-primary); font-weight: 600;">
                        Hyperedge Type:
                    </label>
                    <select id="hyperedge-type" style="
                        width: 100%;
                        padding: 10px;
                        background: var(--input-bg);
                        border: 1px solid var(--border);
                        border-radius: 6px;
                        color: var(--text-primary);
                        font-size: 14px;
                    ">
                        <option value="montage">ðŸŽ¬ Montage (Film)</option>
                        <option value="argument">ðŸ—£ï¸ Argument (Philosophy)</option>
                        <option value="theme">ðŸŽ¯ Theme (Roadmap/Product)</option>
                        <option value="dependency-cluster">ðŸ“¦ Dependency Cluster</option>
                        <option value="location">ðŸ“ Location Group (Film)</option>
                        <option value="character">ðŸ‘¥ Character Arc (Film)</option>
                        <option value="custom">âœï¸ Custom</option>
                    </select>
                </div>

                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-primary); font-weight: 600;">
                        Label:
                    </label>
                    <input type="text" id="hyperedge-label" placeholder="e.g., 'Training Montage', 'Socratic Refutation'" style="
                        width: 100%;
                        padding: 10px;
                        background: var(--input-bg);
                        border: 1px solid var(--border);
                        border-radius: 6px;
                        color: var(--text-primary);
                        font-size: 14px;
                    ">
                </div>

                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button id="hyperedge-create-btn" style="
                        flex: 1;
                        padding: 12px 24px;
                        background: var(--treeplex-primary);
                        border: none;
                        border-radius: 6px;
                        color: white;
                        font-weight: 600;
                        cursor: pointer;
                        font-size: 14px;
                    ">Create Hyperedge</button>
                    <button id="hyperedge-cancel-btn" style="
                        flex: 1;
                        padding: 12px 24px;
                        background: var(--input-bg);
                        border: 1px solid var(--border);
                        border-radius: 6px;
                        color: var(--text-primary);
                        font-weight: 600;
                        cursor: pointer;
                        font-size: 14px;
                    ">Cancel</button>
                </div>
            `;

            // Add backdrop
            const backdrop = document.createElement('div');
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
            `;
            backdrop.id = 'hyperedge-backdrop';

            document.body.appendChild(backdrop);
            document.body.appendChild(dialog);

            // Focus label input
            const labelInput = document.getElementById('hyperedge-label');
            labelInput.focus();

            // Handle create button
            const createBtn = document.getElementById('hyperedge-create-btn');
            createBtn.addEventListener('click', () => {
                const type = document.getElementById('hyperedge-type').value;
                const label = labelInput.value.trim();

                if (!label) {
                    alert('Please enter a label for the hyperedge');
                    return;
                }

                // Get node IDs
                const nodeIds = selectedNodes.map(n => n.id);

                // Create hyperedge
                const hyperedge = addHyperedge(type, label, nodeIds);

                if (hyperedge) {
                    console.log('âœ… Hyperedge created:', hyperedge);

                    // Clear selection
                    selectedNodes = [];
                    document.querySelectorAll('.canvas-node').forEach(n => n.classList.remove('selected'));
                    updateSelectionCounter();

                    // Re-render canvas to show the new hyperedge
                    renderCanvas();

                    // Close dialog
                    dialog.remove();
                    backdrop.remove();
                } else {
                    alert('Failed to create hyperedge');
                }
            });

            // Handle cancel button
            const cancelBtn = document.getElementById('hyperedge-cancel-btn');
            cancelBtn.addEventListener('click', () => {
                dialog.remove();
                backdrop.remove();
            });

            // Close on backdrop click
            backdrop.addEventListener('click', () => {
                dialog.remove();
                backdrop.remove();
            });

            // Close on Escape
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    dialog.remove();
                    backdrop.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }

        function showCanvasContextMenu(x, y, item) {
            console.log('Showing canvas context menu for:', item.name);

            // Remove any existing context menu
            const existing = document.getElementById('canvas-context-menu');
            if (existing) existing.remove();

            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'canvas-context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                background: var(--card-bg);
                border: 2px solid var(--border);
                border-radius: 8px;
                padding: 8px;
                z-index: 10000;
                box-shadow: 0 8px 24px rgba(0,0,0,0.6);
                min-width: 200px;
            `;

            const menuItems = [
                { label: 'âœï¸ Edit Details', action: () => {
                    console.log('Edit Details clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's native handleEdit function
                    if (typeof handleEdit === 'function') {
                        console.log('Calling TreeListy handleEdit function');
                        handleEdit();
                    } else {
                        console.error('handleEdit function not found!');
                    }
                }},
                { label: 'âž• Add Subtask', action: () => {
                    console.log('Add Subtask clicked for:', item.name);
                    activeNode = item;

                    if (!item.subItems) item.subItems = [];
                    const newSubtask = {
                        id: 'subtask-' + Date.now(),
                        name: 'New Subtask',
                        type: 'subtask',
                        description: '',
                        pmStatus: 'To Do',
                        pmProgress: 0,
                        pmRAGStatus: 'Amber',
                        pmPriority: 'Medium',
                        icon: 'ðŸ“‹',
                        itemType: 'Feature'  // Add itemType to match pattern
                    };
                    item.subItems.push(newSubtask);

                    // Set the new subtask as active and open edit
                    activeNode = newSubtask;

                    // Save state for undo before opening edit
                    if (typeof saveState === 'function') {
                        saveState('Add subtask');
                    }

                    if (typeof handleEdit === 'function') {
                        console.log('Opening edit for new subtask');
                        handleEdit();

                        // Re-render canvas AFTER modal closes (when user saves)
                        // Listen for modal close event
                        const modal = document.getElementById('edit-modal');
                        const renderOnClose = () => {
                            if (modal.style.display === 'none') {
                                console.log('Edit modal closed, re-rendering canvas');
                                renderCanvas();
                                modal.removeEventListener('DOMSubtreeModified', renderOnClose);
                            }
                        };

                        // Watch for modal close
                        setTimeout(() => {
                            const observer = new MutationObserver((mutations) => {
                                mutations.forEach((mutation) => {
                                    if (mutation.attributeName === 'style') {
                                        if (modal.style.display === 'none') {
                                            console.log('Edit modal closed, re-rendering canvas');
                                            renderCanvas();
                                            observer.disconnect();
                                        }
                                    }
                                });
                            });
                            observer.observe(modal, { attributes: true });
                        }, 100);
                    }
                }},
                { label: 'ðŸ” Quick Insight', action: () => {
                    console.log('Quick Insight clicked for:', item.name);
                    activeNode = item;
                    handleAI();
                }},
                { label: 'ðŸ“Š Show Info Panel', action: () => {
                    console.log('Show Info Panel clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's showInfo function
                    if (typeof showInfo === 'function') {
                        console.log('Calling TreeListy showInfo function');
                        showInfo(item);
                    } else {
                        console.error('showInfo function not found!');
                    }
                }},
                { label: 'ðŸ—‘ï¸ Delete Item', action: () => {
                    console.log('Delete clicked for:', item.name);
                    activeNode = item;

                    // Call TreeListy's native handleDelete function
                    if (typeof handleDelete === 'function') {
                        console.log('Calling TreeListy handleDelete function');
                        handleDelete();
                        // Re-render canvas after deletion
                        renderCanvas();
                    } else {
                        console.error('handleDelete function not found!');
                    }
                }}
            ];

            // Add "Create Hyperedge" option if 2+ nodes are selected
            if (selectedNodes.length >= 2) {
                menuItems.push({
                    label: `ðŸ”— Create Hyperedge (${selectedNodes.length} nodes)`,
                    action: () => {
                        console.log('Create Hyperedge clicked');
                        showHyperedgeDialog();
                    }
                });
            }

            // Add "Analyze Selection" - Deep Dive feature (Structured Scholar)
            // Works for single node or multiple nodes
            const nodesToAnalyze = selectedNodes.length > 0 ? selectedNodes : [item];
            const analyzeLabel = nodesToAnalyze.length > 1
                ? `ðŸŽ“ Deep Dive (${nodesToAnalyze.length} nodes)`
                : 'ðŸŽ“ Deep Dive';

            menuItems.push({
                label: analyzeLabel,
                action: () => {
                    console.log('Deep Dive Analysis clicked for:', nodesToAnalyze.map(n => n.name));
                    handleAnalyzeSelection(nodesToAnalyze);
                }
            });

            // Add "Share for Collaboration" option (works for 1+ nodes)
            const shareNodes = selectedNodes.length > 0 ? selectedNodes : [item];
            const shareLabel = shareNodes.length > 1
                ? `ðŸ“¤ Share ${shareNodes.length} nodes for collaboration`
                : 'ðŸ“¤ Share for collaboration';

            menuItems.push({
                label: shareLabel,
                action: () => {
                    console.log('Share for collaboration clicked for:', shareNodes.map(n => n.name));
                    showShareBranchModal(shareNodes.map(n => n.id));
                }
            });

            // Add "Generate Image" option (Nano Banana / Imagen 4)
            const imageNodes = selectedNodes.length > 0 ? selectedNodes : [item];
            const imageLabel = imageNodes.length > 1
                ? `ðŸŒ Generate Image (${imageNodes.length} nodes)`
                : 'ðŸŒ Generate Image';

            menuItems.push({
                label: imageLabel,
                action: () => {
                    console.log('Generate Image clicked for:', imageNodes.map(n => n.name));
                    showImagenModal(imageNodes);
                }
            });

            menuItems.forEach(menuItem => {
                const btn = document.createElement('button');
                btn.textContent = menuItem.label;
                btn.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 10px 12px;
                    background: transparent;
                    border: none;
                    color: var(--text-primary);
                    text-align: left;
                    cursor: pointer;
                    border-radius: 4px;
                    font-size: 14px;
                    margin-bottom: 4px;
                `;
                btn.onmouseover = () => btn.style.background = 'var(--treeplex-primary)';
                btn.onmouseout = () => btn.style.background = 'transparent';
                btn.onclick = (e) => {
                    console.log('Context menu button clicked:', menuItem.label);
                    e.preventDefault();
                    e.stopPropagation();

                    // Execute action first
                    try {
                        menuItem.action();
                    } catch (error) {
                        console.error('Error executing menu action:', error);
                    }

                    // Remove menu after a tiny delay to ensure action completes
                    setTimeout(() => menu.remove(), 10);
                };
                menu.appendChild(btn);
            });

            document.body.appendChild(menu);

            // Close menu on click outside
            setTimeout(() => {
                const closeMenu = (e) => {
                    // Don't close if clicking inside the menu
                    if (menu.contains(e.target)) {
                        console.log('Click inside menu, not closing');
                        return;
                    }
                    console.log('Click outside menu, closing');
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                };
                document.addEventListener('click', closeMenu);
            }, 100);

            // Also close on Escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    menu.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }

        function renderCanvasNode(item, phase, parentItem = null, nestingLevel = 0) {
            const canvas = document.getElementById('canvas');
            const node = document.createElement('div');
            node.className = 'canvas-node';

            // Preserve selection state across re-renders
            if (selectedNodes && selectedNodes.some(n => n.id === item.id)) {
                node.classList.add('selected');
            }

            // Check if this node belongs to a hyperedge
            const hyperedge = getNodeHyperedge(item.id);
            const heColors = hyperedge ? getHyperedgeColor(hyperedge) : null;

            // Calculate hierarchical shadow based on nesting level
            // Level 0 (root items): High elevation (big shadow)
            // Level 1+ (subtasks): Lower elevation (smaller shadow)
            const shadowIntensity = Math.max(0, 5 - nestingLevel);  // 5, 4, 3, 2, 1, 0
            const shadowBlur = 8 + (shadowIntensity * 4);  // 8-28px blur
            const shadowSpread = shadowIntensity * 2;  // 0-10px spread
            const shadowOffset = 2 + (shadowIntensity * 2);  // 2-12px offset

            // Apply hyperedge glow if member, otherwise default shadow
            if (heColors) {
                // Hyperedge member: tinted glow effect
                node.style.boxShadow = `
                    0 ${shadowOffset}px ${shadowBlur}px rgba(0, 0, 0, 0.3),
                    0 0 20px ${heColors.glow},
                    inset 0 0 30px ${heColors.fill}
                `;
                node.style.border = `3px solid ${heColors.border}`;
                node.dataset.hyperedgeId = hyperedge.id;
            } else {
                node.style.boxShadow = `
                    0 ${shadowOffset}px ${shadowBlur}px rgba(0, 0, 0, 0.3),
                    0 ${shadowOffset / 2}px ${shadowBlur / 2}px rgba(99, 102, 241, ${0.1 + shadowIntensity * 0.05})
                `;

                // Add visual distinction for subtasks
                if (parentItem || item.type === 'subtask') {
                    node.style.border = '2px dashed rgba(99, 102, 241, 0.4)';
                    node.style.opacity = '0.95';
                } else {
                    // Root items get solid border with glow
                    node.style.border = '2px solid rgba(99, 102, 241, 0.3)';
                }
            }

            node.style.left = `${item.canvasX}px`;
            node.style.top = `${item.canvasY}px`;
            node.dataset.itemId = item.id;
            node.dataset.nestingLevel = nestingLevel;

            // Check if node has children (support both subItems and children)
            const childList = item.subItems || item.children || [];
            const hasChildren = childList.length > 0;

            // Dynamic tooltip based on whether node has children
            node.title = hasChildren
                ? 'Left-click: Expand/Collapse | Double-click: Edit | Right-click: Menu | Middle-click: Drag'
                : 'Left-click: Info | Double-click: Edit | Right-click: Menu | Middle-click: Drag';

            // Add collapse/expand indicator if node has children
            let expandIndicator = '';
            if (hasChildren) {
                const isExpanded = item.expanded !== false;
                const indicatorIcon = isExpanded ? 'â–¼' : 'â–¶';
                expandIndicator = `<div style="position: absolute; top: 8px; right: 8px; font-size: 12px; cursor: pointer; padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; user-select: none;" class="expand-indicator" data-item-id="${item.id}">${indicatorIcon} ${childList.length}</div>`;
            }

            // RAG status indicator
            let ragHtml = '';
            if (item.pmRAGStatus) {
                const ragColors = { Green: '#22C55E', Amber: '#F59E0B', Red: '#EF4444' };
                const ragColor = ragColors[item.pmRAGStatus];
                ragHtml = `<span style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: ${ragColor}; margin-left: 8px; box-shadow: 0 0 6px ${ragColor}80;"></span>`;
            }

            // Cost badge - only show if pattern supports cost AND cost > 0
            let costHtml = '';
            const patternSupportsCost = PATTERNS[currentPattern]?.fields?.cost;
            if (patternSupportsCost && item.cost && item.cost > 0) {
                const costStr = item.cost >= 1000000 ? `$${(item.cost/1000000).toFixed(1)}M` :
                               item.cost >= 1000 ? `$${(item.cost/1000).toFixed(0)}K` :
                               `$${item.cost}`;
                costHtml = `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; background: rgba(34, 197, 94, 0.2); color: #22C55E;">${costStr}</span>`;
            }

            // Type badge - BUILD 390: Enhanced visual cues for semantic types
            let typeHtml = '';
            let typeLeftBorder = '';
            let typeBackgroundTint = '';
            const semType = typeof getSemanticType === 'function' ? getSemanticType(item) : item.itemType;
            if (semType) {
                // BUILD 390: Expanded type color palette with icons
                const typeStyles = {
                    // Philosophy pattern - dialectical types
                    'critique': { color: '#EF4444', icon: 'âš”' },      // Red - attack
                    'response': { color: '#3B82F6', icon: 'â†©' },      // Blue - reply
                    'argument': { color: '#8B5CF6', icon: 'â—†' },      // Purple - main point
                    'counter': { color: '#F59E0B', icon: 'â‡„' },       // Amber - counter
                    'objection': { color: '#F97316', icon: 'âœ—' },     // Orange - objection
                    'defense': { color: '#22C55E', icon: 'ðŸ›¡' },      // Green - defense
                    'synthesis': { color: '#10B981', icon: 'âˆ´' },     // Teal - synthesis
                    'thesis': { color: '#3B82F6', icon: 'â†’' },        // Blue - thesis
                    'antithesis': { color: '#EF4444', icon: 'â†' },    // Red - antithesis
                    'premise': { color: '#A855F7', icon: 'âˆµ' },       // Violet - premise
                    'conclusion': { color: '#06B6D4', icon: 'âˆŽ' },    // Cyan - conclusion
                    'implicit-premise': { color: '#D946EF', icon: 'â‡' }, // Fuchsia - hidden
                    'distinction': { color: '#EC4899', icon: 'â‰ ' },   // Pink - distinction
                    'thought-experiment': { color: '#14B8A6', icon: 'ðŸ’­' }, // Teal - thought
                    // Generic/structural types
                    'risk-factor': { color: '#EF4444', icon: 'âš ' },   // Red - risk
                    'sub-node': { color: '#6B7280', icon: 'â†³' },      // Gray - sub
                    'supporting': { color: '#22C55E', icon: 'âœ“' },    // Green - support
                    // LifeTree pattern
                    'birth': { color: '#EC4899', icon: 'â˜…' },
                    'education': { color: '#3B82F6', icon: 'ðŸ“š' },
                    'career': { color: '#10B981', icon: 'ðŸ’¼' },
                    'relationship': { color: '#EC4899', icon: 'â¤' },
                    'milestone': { color: '#F59E0B', icon: 'ðŸ†' },
                    'loss': { color: '#6B7280', icon: 'â—‡' },
                    'achievement': { color: '#F59E0B', icon: 'â­' },
                    // Sales pattern
                    'lead': { color: '#3B82F6', icon: 'ðŸŽ¯' },
                    'opportunity': { color: '#F59E0B', icon: 'ðŸ’¡' },
                    'deal': { color: '#22C55E', icon: 'ðŸ¤' },
                    'closed': { color: '#10B981', icon: 'âœ…' },
                    'lost': { color: '#EF4444', icon: 'âŒ' }
                };
                const style = typeStyles[semType.toLowerCase()] || { color: 'var(--treeplex-primary)', icon: 'â€¢' };
                const badgeColor = style.color;

                // BUILD 390: Visual cues - left border stripe and background tint
                typeLeftBorder = `border-left: 4px solid ${badgeColor};`;
                typeBackgroundTint = `background: linear-gradient(135deg, ${badgeColor}08 0%, transparent 50%);`;

                // Type badge with icon
                typeHtml = `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; background: ${badgeColor}20; color: ${badgeColor};">${style.icon} ${semType}</span>`;

                // BUILD 390: Apply visual cues to node
                node.style.borderLeft = `4px solid ${badgeColor}`;
                node.style.background = `linear-gradient(135deg, ${badgeColor}08 0%, var(--card-bg, #1E1E2F) 50%)`;
            }

            // Progress indicator
            let progressHtml = '';
            if (item.pmProgress) {
                progressHtml = `<div style="margin-top: 8px; background: rgba(255,255,255,0.1); height: 4px; border-radius: 2px; overflow: hidden;">
                    <div style="background: var(--treeplex-primary); height: 100%; width: ${item.pmProgress}%;"></div>
                </div>`;
            }

            // Contributor badge for canvas
            let canvasContributorHtml = '';
            if (item.contributor) {
                canvasContributorHtml = `<span class="contributor-badge" title="Last edited by ${item.contributor}${item.contributorTimestamp ? ' on ' + new Date(item.contributorTimestamp).toLocaleDateString() : ''}">ðŸ‘¤ ${item.contributor}</span>`;
            }

            // Collab comments indicator for canvas
            let canvasCollabHtml = '';
            if (item.collabComments) {
                canvasCollabHtml = `<span class="collab-indicator" title="${item.collabComments.substring(0, 100)}${item.collabComments.length > 100 ? '...' : ''}">ðŸ’¬</span>`;
            }

            node.innerHTML = `
                ${expandIndicator}
                <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                    <div style="font-size: 24px;">${item.icon || 'ðŸ“¦'}</div>
                    <div style="flex: 1;">
                        <div style="font-size: 14px; font-weight: 600; margin-bottom: 4px;">
                            ${(item.name && item.name !== 'undefined') ? item.name : (item.title || 'âš ï¸ Unnamed')}${typeof getTypeIndicator === 'function' ? getTypeIndicator(item) : ''}${ragHtml}${canvasCollabHtml}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                            ${(item.description || 'No description').substring(0, 100)}${item.description?.length > 100 ? '...' : ''}
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    ${typeHtml}
                    ${costHtml}
                    ${item.pmOwnerEmail ? `<span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; background: rgba(255,255,255,0.1);">ðŸ‘¤ ${item.pmOwnerEmail.split('@')[0]}</span>` : ''}
                    ${canvasContributorHtml}
                </div>
                ${progressHtml}
            `;

            // Add expand/collapse handler
            const expandBtn = node.querySelector('.expand-indicator');
            if (expandBtn) {
                expandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    item.expanded = !item.expanded;
                    console.log('Toggling expand for:', item.name, 'expanded:', item.expanded);
                    renderCanvas();
                });
            }

            // Left-click to expand/collapse if has children, otherwise show info panel
            // CTRL+CLICK to multi-select
            node.addEventListener('click', (e) => {
                console.log('Left-click detected on:', item.name);
                e.stopPropagation();

                // CTRL+CLICK or CMD+CLICK: Toggle selection (multi-select)
                if (e.ctrlKey || e.metaKey) {
                    console.log('Ctrl+Click detected - toggling selection');

                    // Check if already selected
                    const index = selectedNodes.indexOf(item);

                    if (index > -1) {
                        // Already selected - DESELECT
                        selectedNodes.splice(index, 1);
                        node.classList.remove('selected');
                        console.log(`Deselected: ${item.name}. Now ${selectedNodes.length} selected.`);
                    } else {
                        // Not selected - ADD TO SELECTION
                        selectedNodes.push(item);
                        node.classList.add('selected');
                        console.log(`Selected: ${item.name}. Now ${selectedNodes.length} selected.`);
                    }

                    // Set most recently clicked as activeNode
                    activeNode = item;

                    // Update selection counter
                    updateSelectionCounter();

                } else {
                    // NORMAL CLICK: Clear all selections and select only this node

                    // Clear all selections
                    selectedNodes = [];
                    document.querySelectorAll('.canvas-node').forEach(n => n.classList.remove('selected'));

                    // Select this node
                    activeNode = item;
                    selectedNodes = [item];
                    node.classList.add('selected');

                    // Update selection counter
                    updateSelectionCounter();

                    // Check if node has children (support both subItems and children)
                    const hasChildren = (item.subItems && item.subItems.length > 0) ||
                                      (item.children && item.children.length > 0);

                    if (hasChildren) {
                        // Toggle expand/collapse
                        item.expanded = !item.expanded;
                        console.log('Toggling expand for:', item.name, 'expanded:', item.expanded);
                        renderCanvas();
                    }

                    // Always show info panel for selected node (regardless of children)
                    if (typeof showInfo === 'function') {
                        console.log('Calling TreeListy showInfo function');
                        showInfo(item);
                    } else {
                        console.error('showInfo function not found!');
                    }
                }
            });

            // Double-click to edit (HIGHEST PRIORITY)
            node.addEventListener('dblclick', (e) => {
                console.log('Double-click detected on:', item.name);
                e.preventDefault();
                e.stopPropagation();

                // Cancel any drag that might have started
                isDraggingCanvasNode = false;
                draggedCanvasNode = null;
                node.classList.remove('dragging');

                // Set active node and call TreeListy's edit function
                activeNode = item;
                console.log('Opening edit dialog for:', item.name);

                if (typeof handleEdit === 'function') {
                    console.log('Calling TreeListy handleEdit function');
                    handleEdit();
                } else {
                    console.error('handleEdit function not found!');
                }
            });

            // Right-click context menu
            node.addEventListener('contextmenu', (e) => {
                console.log('Right-click detected on:', item.name);
                e.preventDefault();
                e.stopPropagation();

                // Cancel any drag
                isDraggingCanvasNode = false;
                draggedCanvasNode = null;
                node.classList.remove('dragging');

                activeNode = item;

                // Show simple inline context menu
                showCanvasContextMenu(e.pageX, e.pageY, item);
            });

            // Drag with MIDDLE MOUSE BUTTON (button 1) only - left button reserved for panning
            node.addEventListener('mousedown', (e) => {
                const containerRect = document.getElementById('canvas-container').getBoundingClientRect();

                // Middle-click - drag group if node is selected, otherwise drag individual
                if (e.button === 1) {
                    e.preventDefault(); // Prevent browser's middle-click scroll
                    e.stopPropagation();

                    // Check if this node is part of a selection
                    if (selectedNodes.includes(item) && selectedNodes.length > 1) {
                        console.log('Middle-click drag group activated (', selectedNodes.length, 'nodes )');
                        isDraggingSelection = true;
                        const clickX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                        const clickY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                        selectionDragStart = { x: clickX, y: clickY };
                    } else {
                        // Individual node drag
                        console.log('Middle-click drag activated for:', item.name);
                        isDraggingCanvasNode = true;
                        draggedCanvasNode = item;
                        dragStartX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x - item.canvasX;
                        dragStartY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y - item.canvasY;
                        node.classList.add('dragging');
                    }
                }
                // Left-click (button 0) is reserved for panning
                // Right-click (button 2) is free for context menu
            });

            canvas.appendChild(node);
            canvasNodes.push({ element: node, data: item, phase: phase });
        }

        function updateCanvasTransform() {
            const canvas = document.getElementById('canvas');
            if (canvas) {
                canvas.style.transform = `translate(${canvasPan.x}px, ${canvasPan.y}px) scale(${canvasZoom})`;
            }
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const zoomLevel = document.getElementById('zoom-level');
            if (zoomLevel) {
                zoomLevel.textContent = Math.round(canvasZoom * 100) + '%';
            }
        }

        function updateSelectionCounter() {
            const counter = document.getElementById('selection-counter');
            const countSpan = document.getElementById('selection-count');

            if (counter && countSpan) {
                if (selectedNodes.length > 1) {
                    countSpan.textContent = selectedNodes.length;
                    counter.style.display = 'block';
                } else {
                    counter.style.display = 'none';
                }
            }
        }

        function resetView() {
            canvasPan = { x: 0, y: 0 };
            canvasZoom = 1;
            updateCanvasTransform();
        }

        function fitToView() {
            if (canvasNodes.length === 0) return;

            // Find bounding box of all nodes
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            canvasNodes.forEach(({ data }) => {
                minX = Math.min(minX, data.canvasX);
                minY = Math.min(minY, data.canvasY);
                maxX = Math.max(maxX, data.canvasX + 320);  // node width
                maxY = Math.max(maxY, data.canvasY + 120);  // node height
            });

            const container = document.getElementById('canvas-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const contentWidth = maxX - minX + 200;  // padding
            const contentHeight = maxY - minY + 200;

            const scaleX = containerWidth / contentWidth;
            const scaleY = containerHeight / contentHeight;
            canvasZoom = Math.min(scaleX, scaleY, 1);  // Don't zoom in beyond 100%

            // Center the content
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            canvasPan.x = containerWidth / 2 - centerX * canvasZoom;
            canvasPan.y = containerHeight / 2 - centerY * canvasZoom;

            updateCanvasTransform();
        }

        function snapToGrid(value) {
            if (!gridEnabled) return value;
            return Math.round(value / gridSize) * gridSize;
        }

        function clearSelection() {
            // Remove selected class from all nodes
            selectedNodes.forEach(nodeData => {
                const nodeEl = canvasNodes.find(n => n.data.id === nodeData.id)?.element;
                if (nodeEl) {
                    nodeEl.classList.remove('selected');
                }
            });
            selectedNodes = [];
            updateSelectionCounter();
        }

        function toggleGrid() {
            gridEnabled = !gridEnabled;
            const gridBtn = document.getElementById('grid-toggle');
            const gridSvg = document.getElementById('canvas-grid');

            if (gridBtn) {
                if (gridEnabled) {
                    gridBtn.style.background = 'rgba(99, 102, 241, 0.6)';
                    gridBtn.style.borderColor = 'rgba(99, 102, 241, 0.8)';
                    gridBtn.style.color = 'white';
                } else {
                    gridBtn.style.background = 'rgba(99, 102, 241, 0.1)';
                    gridBtn.style.borderColor = 'rgba(99, 102, 241, 0.3)';
                    gridBtn.style.color = 'var(--text-primary)';
                }
            }

            if (gridSvg) {
                gridSvg.style.opacity = gridEnabled ? '1' : '0';
            }

            console.log('Grid:', gridEnabled ? 'ON (visible + snapping)' : 'OFF');
        }

        // Auto-layout algorithms
        function applyAutoLayout(layoutType) {
            console.log('Applying layout:', layoutType);

            if (layoutType === 'hierarchical') {
                applyHierarchicalLayout();
            } else if (layoutType === 'timeline') {
                applyTimelineLayout();
            } else if (layoutType === 'force') {
                applyForceDirectedLayout();
            } else if (layoutType === 'radial') {
                applyRadialLayout();
            } else if (layoutType === 'grid') {
                applyGridLayout();
            }

            renderCanvas();
            fitToView();
        }

        function applyHierarchicalLayout() {
            let currentY = 100;
            const levelGap = 250;
            const nodeGap = 350;

            capexTree.children.forEach((phase, phaseIdx) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                let currentX = 200;

                phase.items?.forEach((item) => {
                    item.canvasX = currentX;
                    item.canvasY = currentY;

                    // Layout subtasks to the right and down
                    layoutSubtasksHierarchical(item, currentX + nodeGap, currentY, 1);

                    currentX += nodeGap;
                });

                currentY += levelGap;
            });
        }

        function layoutSubtasksHierarchical(item, startX, startY, level) {
            if (!item.subItems || item.subItems.length === 0) return;

            let currentY = startY;
            const verticalGap = 140;

            item.subItems.forEach((subtask, idx) => {
                subtask.canvasX = startX;
                subtask.canvasY = currentY;

                layoutSubtasksHierarchical(subtask, startX + 350, currentY, level + 1);

                currentY += verticalGap;
            });
        }

        function applyTimelineLayout() {
            let currentX = 200;
            const xGap = 400;
            let currentY = 100;

            capexTree.children.forEach((phase) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach((item) => {
                    item.canvasX = currentX;
                    item.canvasY = currentY;

                    // Layout subtasks vertically below
                    if (item.subItems) {
                        let subY = currentY + 150;
                        item.subItems.forEach(subtask => {
                            subtask.canvasX = currentX;
                            subtask.canvasY = subY;
                            subY += 140;
                        });
                    }

                    currentX += xGap;
                });
            });
        }

        function applyGridLayout() {
            const cols = 4;
            const nodeWidth = 350;
            const nodeHeight = 180;
            let index = 0;

            capexTree.children.forEach((phase) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach((item) => {
                    const col = index % cols;
                    const row = Math.floor(index / cols);

                    item.canvasX = 100 + col * nodeWidth;
                    item.canvasY = 100 + row * nodeHeight;

                    index++;

                    // Layout subtasks in continuation of grid
                    if (item.subItems) {
                        item.subItems.forEach(subtask => {
                            index++;
                            const col = index % cols;
                            const row = Math.floor(index / cols);
                            subtask.canvasX = 100 + col * nodeWidth;
                            subtask.canvasY = 100 + row * nodeHeight;
                        });
                    }
                });
            });
        }

        function applyRadialLayout() {
            const centerX = 600;
            const centerY = 400;
            const radius = 300;
            let totalItems = 0;

            // Count items (only from visible phases)
            capexTree.children.forEach(phase => {
                if (phase.showInCanvas !== false) {
                    totalItems += phase.items?.length || 0;
                }
            });

            let index = 0;

            capexTree.children.forEach((phase) => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach((item) => {
                    const angle = (index / totalItems) * Math.PI * 2;
                    item.canvasX = centerX + Math.cos(angle) * radius;
                    item.canvasY = centerY + Math.sin(angle) * radius;

                    // Place subtasks further out
                    if (item.subItems) {
                        item.subItems.forEach((subtask, subIdx) => {
                            const subAngle = angle + (subIdx * 0.2);
                            subtask.canvasX = centerX + Math.cos(subAngle) * (radius + 200);
                            subtask.canvasY = centerY + Math.sin(subAngle) * (radius + 200);
                        });
                    }

                    index++;
                });
            });
        }

        // Barnes-Hut Quadtree for O(n log n) force approximation
        class QuadtreeNode {
            constructor(x, y, width, height, depth = 0) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.depth = depth;  // Track recursion depth
                this.mass = 0;
                this.centerX = 0;
                this.centerY = 0;
                this.children = [];
                this.node = null;  // Actual canvas node if leaf
                this.subdivided = false;
            }

            insert(node) {
                // Check if node is within bounds
                if (node.canvasX < this.x || node.canvasX > this.x + this.width ||
                    node.canvasY < this.y || node.canvasY > this.y + this.height) {
                    return false;
                }

                // If this is empty, place node here
                if (this.mass === 0) {
                    this.node = node;
                    this.mass = 1;
                    this.centerX = node.canvasX;
                    this.centerY = node.canvasY;
                    return true;
                }

                // PREVENT INFINITE RECURSION: Max depth or minimum size check
                const MAX_DEPTH = 15;
                const MIN_SIZE = 1;
                if (this.depth >= MAX_DEPTH || this.width < MIN_SIZE || this.height < MIN_SIZE) {
                    // Can't subdivide further - keep both nodes at this level
                    // Update center of mass to include both
                    const totalMass = this.mass + 1;
                    this.centerX = (this.centerX * this.mass + node.canvasX) / totalMass;
                    this.centerY = (this.centerY * this.mass + node.canvasY) / totalMass;
                    this.mass = totalMass;
                    return true;
                }

                // If this is a leaf, subdivide
                if (!this.subdivided) {
                    this.subdivide();
                }

                // Update center of mass
                const totalMass = this.mass + 1;
                this.centerX = (this.centerX * this.mass + node.canvasX) / totalMass;
                this.centerY = (this.centerY * this.mass + node.canvasY) / totalMass;
                this.mass = totalMass;

                // Insert into appropriate child
                for (let child of this.children) {
                    if (child.insert(node)) {
                        return true;
                    }
                }

                // SAFETY: If no child accepted it, keep it here (prevents infinite recursion)
                // This can happen with floating point precision issues or nodes exactly on boundaries
                return true;
            }

            subdivide() {
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;

                // Create 4 quadrants: NW, NE, SW, SE (pass depth + 1)
                this.children = [
                    new QuadtreeNode(this.x, this.y, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x + halfWidth, this.y, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x, this.y + halfHeight, halfWidth, halfHeight, this.depth + 1),
                    new QuadtreeNode(this.x + halfWidth, this.y + halfHeight, halfWidth, halfHeight, this.depth + 1)
                ];

                // Reinsert existing node
                if (this.node) {
                    for (let child of this.children) {
                        if (child.insert(this.node)) {
                            break;
                        }
                    }
                    this.node = null;
                }

                this.subdivided = true;
            }

            calculateForce(node, force, repulsion, theta = 0.5) {
                // Skip if this is the same node
                if (this.node === node) {
                    return;
                }

                const dx = this.centerX - node.canvasX;
                const dy = this.centerY - node.canvasY;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                // If this is a leaf or far enough, treat as single body
                if (!this.subdivided || (this.width / dist < theta)) {
                    const forceMag = repulsion * this.mass / (dist * dist);
                    force.x -= (dx / dist) * forceMag;
                    force.y -= (dy / dist) * forceMag;
                } else {
                    // Recurse into children
                    for (let child of this.children) {
                        if (child.mass > 0) {
                            child.calculateForce(node, force, repulsion, theta);
                        }
                    }
                }
            }
        }

        function buildQuadtree(nodes) {
            // Find bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.canvasX);
                minY = Math.min(minY, node.canvasY);
                maxX = Math.max(maxX, node.canvasX);
                maxY = Math.max(maxY, node.canvasY);
            });

            // Add padding
            const padding = 100;
            minX -= padding;
            minY -= padding;
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;

            // Build tree
            const root = new QuadtreeNode(minX, minY, width, height);
            nodes.forEach(node => root.insert(node));
            return root;
        }

        function applyForceDirectedLayout() {
            // Enhanced force-directed layout with Barnes-Hut, collision detection, and phase-aware forces
            const iterations = 500;  // Increased from 100 for better convergence
            const baseRepulsion = 8000;  // Stronger repulsion
            const baseAttraction = 0.02;  // Stronger attraction
            const nodeRadius = 120;  // Collision detection radius
            const phaseAttractionStrength = 0.008;  // Keep nodes near their phase
            const centerPull = 0.001;  // Weak pull toward center

            // Collect all nodes and track phase membership
            let allNodes = [];
            const phaseMap = new Map();  // Map node ID to phase

            // Recursive function to add node and all its descendants
            function addNodeAndDescendants(node, phase) {
                allNodes.push(node);
                phaseMap.set(node.id, phase);

                // Recursively add all subItems
                if (node.subItems) {
                    node.subItems.forEach(subtask => {
                        addNodeAndDescendants(subtask, phase);
                    });
                }

                // Also handle 'children' for filesystem pattern
                if (node.children) {
                    node.children.forEach(child => {
                        addNodeAndDescendants(child, phase);
                    });
                }
            }

            capexTree.children.forEach(phase => {
                // Skip hidden phases
                if (phase.showInCanvas === false) {
                    return;
                }

                phase.items?.forEach(item => {
                    addNodeAndDescendants(item, phase);
                });
            });

            // Calculate initial phase centers for phase-aware forces
            const phaseCenters = new Map();
            capexTree.children.forEach(phase => {
                const phaseNodes = allNodes.filter(n => phaseMap.get(n.id) === phase);
                if (phaseNodes.length > 0) {
                    const avgX = phaseNodes.reduce((sum, n) => sum + n.canvasX, 0) / phaseNodes.length;
                    const avgY = phaseNodes.reduce((sum, n) => sum + n.canvasY, 0) / phaseNodes.length;
                    phaseCenters.set(phase.id, { x: avgX, y: avgY });
                }
            });

            // Main simulation loop with progressive damping
            for (let iter = 0; iter < iterations; iter++) {
                const progress = iter / iterations;
                const damping = 0.95 - (progress * 0.45);  // Progressive cooling: 0.95 â†’ 0.5
                const tempRepulsion = baseRepulsion * (1 - progress * 0.3);  // Reduce repulsion over time

                // Build quadtree for Barnes-Hut approximation (O(n log n) instead of O(nÂ²))
                const quadtree = buildQuadtree(allNodes);

                // Apply repulsion using Barnes-Hut approximation
                allNodes.forEach(node => {
                    const force = { x: 0, y: 0 };
                    quadtree.calculateForce(node, force, tempRepulsion);
                    node.canvasX += force.x * damping;
                    node.canvasY += force.y * damping;
                });

                // Collision detection: prevent overlaps (still O(nÂ²) but necessary for precision)
                for (let i = 0; i < allNodes.length; i++) {
                    for (let j = i + 1; j < allNodes.length; j++) {
                        const dx = allNodes[j].canvasX - allNodes[i].canvasX;
                        const dy = allNodes[j].canvasY - allNodes[i].canvasY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        const minDist = nodeRadius * 2;
                        if (dist < minDist && dist > 0) {
                            // Push nodes apart to prevent overlap
                            const pushForce = (minDist - dist) / dist * 0.5;
                            const pushX = dx * pushForce;
                            const pushY = dy * pushForce;

                            allNodes[i].canvasX -= pushX;
                            allNodes[i].canvasY -= pushY;
                            allNodes[j].canvasX += pushX;
                            allNodes[j].canvasY += pushY;
                        }
                    }
                }

                // Apply attraction for parent-child relationships (recursive)
                function applyParentChildAttraction(parent, damping) {
                    const childList = parent.subItems || parent.children || [];
                    childList.forEach(child => {
                        const dx = child.canvasX - parent.canvasX;
                        const dy = child.canvasY - parent.canvasY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 0) {
                            // Spring-like attraction
                            const force = baseAttraction * dist;
                            const fx = (dx / dist) * force;
                            const fy = (dy / dist) * force;

                            parent.canvasX += fx * damping;
                            parent.canvasY += fy * damping;
                            child.canvasX -= fx * damping;
                            child.canvasY -= fy * damping;
                        }

                        // Recursively apply to this child's children
                        applyParentChildAttraction(child, damping);
                    });
                }

                capexTree.children.forEach(phase => {
                    // Skip hidden phases
                    if (phase.showInCanvas === false) {
                        return;
                    }

                    phase.items?.forEach(item => {
                        applyParentChildAttraction(item, damping);
                    });
                });

                // Apply phase-aware forces (keep nodes grouped by phase)
                allNodes.forEach(node => {
                    const phase = phaseMap.get(node.id);
                    if (phase) {
                        const phaseCenter = phaseCenters.get(phase.id);
                        if (phaseCenter) {
                            const dx = phaseCenter.x - node.canvasX;
                            const dy = phaseCenter.y - node.canvasY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist > 0) {
                                // Gentle pull toward phase center (weaker over time)
                                const force = phaseAttractionStrength * dist * (1 - progress);
                                node.canvasX += (dx / dist) * force;
                                node.canvasY += (dy / dist) * force;
                            }
                        }
                    }
                });

                // Apply metadata-based clustering (if enabled)
                if (clusterByField) {
                    const clusterStrength = 0.015;  // Strength of clustering attraction

                    // Helper function to get comparable value for clustering
                    const getClusterValue = (node, field) => {
                        if (field === 'cost') {
                            // Group by cost ranges (0-10k, 10k-50k, 50k-200k, 200k+)
                            const cost = node.cost || 0;
                            if (cost < 10000) return 'low';
                            if (cost < 50000) return 'medium';
                            if (cost < 200000) return 'high';
                            return 'very-high';
                        } else if (field === 'modifiedDate') {
                            // Group by month
                            if (!node.modifiedDate) return 'unknown';
                            return node.modifiedDate.substring(0, 7); // YYYY-MM
                        } else {
                            // Direct field value (itemType, owner, pmRAGStatus, etc.)
                            return node[field] || 'unknown';
                        }
                    };

                    // Apply clustering forces between nodes with matching metadata
                    for (let i = 0; i < allNodes.length; i++) {
                        for (let j = i + 1; j < allNodes.length; j++) {
                            const valueA = getClusterValue(allNodes[i], clusterByField);
                            const valueB = getClusterValue(allNodes[j], clusterByField);

                            // If nodes share the same metadata value, attract them
                            if (valueA === valueB && valueA !== 'unknown') {
                                const dx = allNodes[j].canvasX - allNodes[i].canvasX;
                                const dy = allNodes[j].canvasY - allNodes[i].canvasY;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist > 0) {
                                    // Gentle attraction between similar nodes
                                    const force = clusterStrength * dist * (1 - progress * 0.5);
                                    const fx = (dx / dist) * force;
                                    const fy = (dy / dist) * force;

                                    allNodes[i].canvasX += fx;
                                    allNodes[i].canvasY += fy;
                                    allNodes[j].canvasX -= fx;
                                    allNodes[j].canvasY -= fy;
                                }
                            }
                        }
                    }
                }

                // Pull towards global center (very weak)
                allNodes.forEach(node => {
                    node.canvasX -= (node.canvasX - 600) * centerPull * damping;
                    node.canvasY -= (node.canvasY - 400) * centerPull * damping;
                });

                // Recalculate phase centers every 50 iterations for better clustering
                if (iter % 50 === 0) {
                    capexTree.children.forEach(phase => {
                        const phaseNodes = allNodes.filter(n => phaseMap.get(n.id) === phase);
                        if (phaseNodes.length > 0) {
                            const avgX = phaseNodes.reduce((sum, n) => sum + n.canvasX, 0) / phaseNodes.length;
                            const avgY = phaseNodes.reduce((sum, n) => sum + n.canvasY, 0) / phaseNodes.length;
                            phaseCenters.set(phase.id, { x: avgX, y: avgY });
                        }
                    });
                }
            }

            const clusterMsg = clusterByField ? ` with clustering by ${clusterByField}` : '';
            console.log(`Force-directed layout complete: ${iterations} iterations, ${allNodes.length} nodes${clusterMsg}`);
        }

        // Canvas container event listeners
        function initializeCanvasEvents() {
            const container = document.getElementById('canvas-container');

            container.addEventListener('mousedown', (e) => {
                const containerRect = container.getBoundingClientRect();

                // Middle mouse button - start selection
                if (e.button === 1 && (e.target === container || e.target.id === 'canvas')) {
                    e.preventDefault();
                    isSelecting = true;
                    const x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                    selectionStart = { x, y };
                    selectionEnd = { x, y };

                    // Clear previous selection
                    clearSelection();

                    // Create selection overlay
                    let selectionBox = document.getElementById('selection-box');
                    if (!selectionBox) {
                        selectionBox = document.createElement('div');
                        selectionBox.id = 'selection-box';
                        selectionBox.style.position = 'absolute';
                        selectionBox.style.border = '2px dashed var(--treeplex-primary)';
                        selectionBox.style.background = 'rgba(0, 166, 125, 0.1)';
                        selectionBox.style.pointerEvents = 'none';
                        selectionBox.style.zIndex = '9999';
                        document.getElementById('canvas').appendChild(selectionBox);
                    }
                    selectionBox.style.display = 'block';
                    return;
                }

                // Left mouse button on canvas background - pan
                // BUILD 330: Also allow Space+Left-drag for Mac trackpad users
                if (e.button === 0 && (e.target === container || e.target.id === 'canvas')) {
                    // Clear selection when clicking on empty space (unless holding modifier)
                    if (selectedNodes.length > 0 && !e.ctrlKey && !e.metaKey && !isSpacePressed) {
                        clearSelection();
                    }

                    // Start panning
                    isPanningCanvas = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    container.classList.add('grabbing');
                }

                // BUILD 330: Space+Left-drag also pans (Mac-friendly)
                if (e.button === 0 && isSpacePressed) {
                    e.preventDefault();
                    isPanningCanvas = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    container.classList.add('grabbing');
                }
            });

            container.addEventListener('mousemove', (e) => {
                const containerRect = container.getBoundingClientRect();

                // Drawing selection box with middle mouse
                if (isSelecting) {
                    const x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;
                    selectionEnd = { x, y };

                    // Update selection box visual
                    const selectionBox = document.getElementById('selection-box');
                    if (selectionBox) {
                        const minX = Math.min(selectionStart.x, selectionEnd.x);
                        const minY = Math.min(selectionStart.y, selectionEnd.y);
                        const maxX = Math.max(selectionStart.x, selectionEnd.x);
                        const maxY = Math.max(selectionStart.y, selectionEnd.y);

                        // Convert canvas coordinates back to screen coordinates (reverse the zoom/pan transformation)
                        const screenMinX = (minX + canvasPan.x) * canvasZoom;
                        const screenMinY = (minY + canvasPan.y) * canvasZoom;
                        const screenMaxX = (maxX + canvasPan.x) * canvasZoom;
                        const screenMaxY = (maxY + canvasPan.y) * canvasZoom;

                        selectionBox.style.left = `${screenMinX}px`;
                        selectionBox.style.top = `${screenMinY}px`;
                        selectionBox.style.width = `${screenMaxX - screenMinX}px`;
                        selectionBox.style.height = `${screenMaxY - screenMinY}px`;
                    }
                    return;
                }

                // Dragging multiple selected nodes
                if (isDraggingSelection && selectedNodes.length > 0) {
                    const currentX = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x;
                    const currentY = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y;

                    const deltaX = currentX - selectionDragStart.x;
                    const deltaY = currentY - selectionDragStart.y;

                    // Move all selected nodes
                    selectedNodes.forEach(nodeData => {
                        nodeData.canvasX += deltaX;
                        nodeData.canvasY += deltaY;

                        const nodeEl = canvasNodes.find(n => n.data.id === nodeData.id)?.element;
                        if (nodeEl) {
                            nodeEl.style.left = `${nodeData.canvasX}px`;
                            nodeEl.style.top = `${nodeData.canvasY}px`;
                        }

                        // Move children of each selected node
                        function moveChildren(node, dx, dy) {
                            const childList = node.items || node.children || node.subItems || [];
                            childList.forEach(child => {
                                if (child.canvasX !== undefined && child.canvasY !== undefined) {
                                    child.canvasX += dx;
                                    child.canvasY += dy;

                                    const childEl = canvasNodes.find(n => n.data.id === child.id)?.element;
                                    if (childEl) {
                                        childEl.style.left = `${child.canvasX}px`;
                                        childEl.style.top = `${child.canvasY}px`;
                                    }

                                    moveChildren(child, dx, dy);
                                }
                            });
                        }
                        moveChildren(nodeData, deltaX, deltaY);
                    });

                    selectionDragStart = { x: currentX, y: currentY };
                    drawConnections();
                    return;
                }

                if (isPanningCanvas) {
                    const dx = (e.clientX - panStartX) / canvasZoom;
                    const dy = (e.clientY - panStartY) / canvasZoom;
                    canvasPan.x += dx;
                    canvasPan.y += dy;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    updateCanvasTransform();
                } else if (isDraggingCanvasNode && draggedCanvasNode) {
                    const containerRect = container.getBoundingClientRect();
                    let x = (e.clientX - containerRect.left) / canvasZoom - canvasPan.x - dragStartX;
                    let y = (e.clientY - containerRect.top) / canvasZoom - canvasPan.y - dragStartY;

                    // Apply grid snapping if enabled
                    x = snapToGrid(x);
                    y = snapToGrid(y);

                    // Calculate delta (how much the node moved)
                    const deltaX = x - draggedCanvasNode.canvasX;
                    const deltaY = y - draggedCanvasNode.canvasY;

                    // Update parent position
                    draggedCanvasNode.canvasX = x;
                    draggedCanvasNode.canvasY = y;

                    const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                    if (nodeEl) {
                        nodeEl.style.left = `${x}px`;
                        nodeEl.style.top = `${y}px`;
                    }

                    // Recursively move all children by the same delta
                    function moveChildren(node, dx, dy) {
                        const childList = node.items || node.children || node.subItems || [];
                        childList.forEach(child => {
                            if (child.canvasX !== undefined && child.canvasY !== undefined) {
                                child.canvasX += dx;
                                child.canvasY += dy;

                                // Update child DOM element
                                const childEl = canvasNodes.find(n => n.data.id === child.id)?.element;
                                if (childEl) {
                                    childEl.style.left = `${child.canvasX}px`;
                                    childEl.style.top = `${child.canvasY}px`;
                                }

                                // Recursively move grandchildren
                                moveChildren(child, dx, dy);
                            }
                        });
                    }

                    // Move all descendants
                    if (deltaX !== 0 || deltaY !== 0) {
                        moveChildren(draggedCanvasNode, deltaX, deltaY);
                    }

                    // Redraw connections while dragging
                    drawConnections();
                }
            });

            container.addEventListener('mouseup', (e) => {
                // Finalize selection
                if (isSelecting) {
                    isSelecting = false;

                    // Hide selection box
                    const selectionBox = document.getElementById('selection-box');
                    if (selectionBox) {
                        selectionBox.style.display = 'none';
                    }

                    // Calculate selection bounds
                    const minX = Math.min(selectionStart.x, selectionEnd.x);
                    const minY = Math.min(selectionStart.y, selectionEnd.y);
                    const maxX = Math.max(selectionStart.x, selectionEnd.x);
                    const maxY = Math.max(selectionStart.y, selectionEnd.y);

                    // Find nodes within selection
                    const containerRect = container.getBoundingClientRect();
                    canvasNodes.forEach(nodeObj => {
                        const node = nodeObj.data;
                        const nodeEl = nodeObj.element;

                        if (node.canvasX !== undefined && node.canvasY !== undefined) {
                            const rect = nodeEl.getBoundingClientRect();
                            const nodeX = (rect.left - containerRect.left) / canvasZoom - canvasPan.x;
                            const nodeY = (rect.top - containerRect.top) / canvasZoom - canvasPan.y;
                            const nodeW = rect.width / canvasZoom;
                            const nodeH = rect.height / canvasZoom;

                            // Check if node intersects with selection box
                            if (nodeX < maxX && nodeX + nodeW > minX &&
                                nodeY < maxY && nodeY + nodeH > minY) {
                                selectedNodes.push(node);
                                nodeEl.classList.add('selected');
                            }
                        }
                    });

                    console.log(`Selected ${selectedNodes.length} nodes`);
                    return;
                }

                // End dragging selection
                if (isDraggingSelection) {
                    isDraggingSelection = false;
                    return;
                }

                isPanningCanvas = false;
                container.classList.remove('grabbing');

                // Clean up dragging state
                if (isDraggingCanvasNode || draggedCanvasNode) {
                    if (draggedCanvasNode) {
                        const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                        if (nodeEl) {
                            nodeEl.classList.remove('dragging');
                        }
                    }
                    isDraggingCanvasNode = false;
                    draggedCanvasNode = null;
                }
            });

            // Also handle mouseleave to stop dragging when mouse leaves container
            container.addEventListener('mouseleave', () => {
                isPanningCanvas = false;
                container.classList.remove('grabbing');

                if (isDraggingCanvasNode || draggedCanvasNode) {
                    if (draggedCanvasNode) {
                        const nodeEl = canvasNodes.find(n => n.data.id === draggedCanvasNode.id)?.element;
                        if (nodeEl) {
                            nodeEl.classList.remove('dragging');
                        }
                    }
                    isDraggingCanvasNode = false;
                    draggedCanvasNode = null;
                }
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                canvasZoom = Math.max(0.1, Math.min(5, canvasZoom * delta));
                updateCanvasTransform();
            }, { passive: false });

            // BUILD 330: Space key for Mac-friendly panning (hold Space + drag)
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && viewMode === 'canvas') {
                    // Only if not typing in an input
                    if (!['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                        isSpacePressed = true;
                        container.style.cursor = 'grab';
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    isSpacePressed = false;
                    if (!isPanningCanvas) {
                        container.style.cursor = '';
                    }
                }
            });
        }

        // =====================================================================
        // PROGRESSIVE EXPAND/COLLAPSE - Works in both Tree and Canvas Views
        // =====================================================================

        // Calculate the maximum depth of the tree
        function getMaxDepth(node = capexTree, depth = 0) {
            let maxDepth = depth;
            if (node.children) {
                node.children.forEach(child => {
                    maxDepth = Math.max(maxDepth, getMaxDepth(child, depth + 1));
                });
            }
            if (node.items) {
                node.items.forEach(item => {
                    maxDepth = Math.max(maxDepth, getItemMaxDepth(item, depth + 1));
                });
            }
            return maxDepth;
        }

        function getItemMaxDepth(item, depth = 0) {
            let maxDepth = depth;
            if (item.subItems && item.subItems.length > 0) {
                item.subItems.forEach(subItem => {
                    maxDepth = Math.max(maxDepth, getItemMaxDepth(subItem, depth + 1));
                });
            }
            return maxDepth;
        }

        // Collapse one level at a time (deepest first)
        function collapseOneLevel() {
            console.log('ðŸ” collapseOneLevel called');

            // Find all items with subItems that are currently expanded
            let deepestExpandedWithChildren = [];
            let maxDepthFound = 0;

            function findExpandedWithChildren(node, depth = 0, path = []) {
                // For phases (node.children)
                if (node.children) {
                    node.children.forEach(child => {
                        findExpandedWithChildren(child, depth + 1, [...path, node]);
                    });
                }

                // For items
                if (node.items) {
                    node.items.forEach(item => {
                        findExpandedItems(item, depth + 1, [...path, node]);
                    });
                }
            }

            function findExpandedItems(item, depth, path) {
                // If this item has subItems and is expanded, record it
                if (item.subItems && item.subItems.length > 0 && item.expanded !== false) {
                    deepestExpandedWithChildren.push({ item, depth, path });
                    maxDepthFound = Math.max(maxDepthFound, depth);

                    // Recurse into subItems
                    item.subItems.forEach(subItem => {
                        findExpandedItems(subItem, depth + 1, [...path, item]);
                    });
                } else if (item.subItems) {
                    // Has children but collapsed - still check children in case some are expanded
                    item.subItems.forEach(subItem => {
                        findExpandedItems(subItem, depth + 1, [...path, item]);
                    });
                }
            }

            findExpandedWithChildren(capexTree);

            console.log('Found', deepestExpandedWithChildren.length, 'expanded items with children');
            console.log('Max depth:', maxDepthFound);

            if (deepestExpandedWithChildren.length === 0) {
                console.log('âœ… Already fully collapsed - no items with children are expanded');
                return;
            }

            // Collapse only the items at the deepest level
            const toCollapse = deepestExpandedWithChildren.filter(x => x.depth === maxDepthFound);
            console.log('Collapsing', toCollapse.length, 'items at depth', maxDepthFound);

            toCollapse.forEach(({ item }) => {
                console.log('  - Collapsing:', item.name);
                item.expanded = false;
            });
        }

        // Expand one level at a time (shallowest first)
        function expandOneLevel() {
            console.log('ðŸ” expandOneLevel called');

            // Find all items with subItems that are currently collapsed
            let collapsedWithChildren = [];
            let minDepthFound = Infinity;

            function findCollapsedWithChildren(node, depth = 0, path = []) {
                // For phases (node.children)
                if (node.children) {
                    node.children.forEach(child => {
                        findCollapsedWithChildren(child, depth + 1, [...path, node]);
                    });
                }

                // For items
                if (node.items) {
                    node.items.forEach(item => {
                        findCollapsedItems(item, depth + 1, [...path, node]);
                    });
                }
            }

            function findCollapsedItems(item, depth, path) {
                // If this item has subItems and is collapsed, record it
                if (item.subItems && item.subItems.length > 0 && item.expanded === false) {
                    collapsedWithChildren.push({ item, depth, path });
                    minDepthFound = Math.min(minDepthFound, depth);
                }

                // Still recurse into subItems even if collapsed (to find deeper collapsed items)
                if (item.subItems) {
                    item.subItems.forEach(subItem => {
                        findCollapsedItems(subItem, depth + 1, [...path, item]);
                    });
                }
            }

            findCollapsedWithChildren(capexTree);

            console.log('Found', collapsedWithChildren.length, 'collapsed items with children');
            console.log('Min depth:', minDepthFound);

            if (collapsedWithChildren.length === 0) {
                console.log('âœ… Already fully expanded - no collapsed items with children');
                return;
            }

            // Expand only the items at the shallowest level
            const toExpand = collapsedWithChildren.filter(x => x.depth === minDepthFound);
            console.log('Expanding', toExpand.length, 'items at depth', minDepthFound);

            toExpand.forEach(({ item }) => {
                console.log('  - Expanding:', item.name);
                item.expanded = true;
            });
        }

        // Canvas-aware expand/collapse handlers
        window.canvasExpandOneLevel = function() {
            console.log('ðŸŽ¯ canvasExpandOneLevel called, viewMode:', viewMode);
            expandOneLevel();

            // Always update tree view
            if (typeof render === 'function') {
                console.log('Calling render() for tree view');
                render();
            }

            // Update canvas view if we're in canvas mode
            if (viewMode === 'canvas') {
                console.log('Calling renderCanvas() for canvas view');
                renderCanvas();
            }

            console.log('âœ… Expand complete');
        };

        window.canvasCollapseOneLevel = function() {
            console.log('ðŸŽ¯ canvasCollapseOneLevel called, viewMode:', viewMode);
            collapseOneLevel();

            // Always update tree view
            if (typeof render === 'function') {
                console.log('Calling render() for tree view');
                render();
            }

            // Update canvas view if we're in canvas mode
            if (viewMode === 'canvas') {
                console.log('Calling renderCanvas() for canvas view');
                renderCanvas();
            }

            console.log('âœ… Collapse complete');
        };

        // Helper to check if a node is visible (not hidden by collapsed parent)
        function isNodeVisible(nodeId) {
            // Find the node and check all its ancestors
            function findAndCheckNode(searchId, node = capexTree, ancestors = []) {
                if (node.id === searchId) {
                    // Check if any ancestor is collapsed
                    return ancestors.every(ancestor => ancestor.expanded !== false);
                }

                if (node.items) {
                    for (const item of node.items) {
                        if (checkItemVisibility(searchId, item, ancestors)) {
                            return true;
                        }
                    }
                }

                if (node.children) {
                    for (const child of node.children) {
                        const result = findAndCheckNode(searchId, child, [...ancestors, node]);
                        if (result !== undefined) return result;
                    }
                }

                return undefined;
            }

            function checkItemVisibility(searchId, item, ancestors = []) {
                if (item.id === searchId) {
                    return ancestors.every(ancestor => ancestor.expanded !== false);
                }

                if (item.subItems) {
                    for (const subItem of item.subItems) {
                        const result = checkItemVisibility(searchId, subItem, [...ancestors, item]);
                        if (result !== undefined) return result;
                    }
                }

                return undefined;
            }

            const result = findAndCheckNode(nodeId);
            return result === undefined ? true : result;  // Default to visible if not found
        }

        window.isNodeVisible = isNodeVisible;


        // =============================================================================
        // UNDO/REDO SYSTEM
        // =============================================================================

        // History stack for undo functionality
        const historyStack = [];
        const MAX_HISTORY = 50; // Keep last 50 states

        // Save current state to history before making changes
        function saveState(actionName = 'Unknown action') {
            const state = {
                tree: JSON.parse(JSON.stringify(capexTree)), // Deep copy
                pattern: currentPattern,
                timestamp: Date.now(),
                action: actionName
            };

            historyStack.push(state);

            // Limit history size
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift(); // Remove oldest
            }

            updateUndoButton();

            // Mark tree as changed (for auto-save)
            if (typeof treeManager !== 'undefined') {
                treeManager.markAsChanged();
            }
            console.log(`ðŸ’¾ State saved: ${actionName} (${historyStack.length} states in history)`);
        }

        // Undo last action
        function undo() {
            if (historyStack.length === 0) {
                console.warn('âš ï¸ No history to undo');
                return;
            }

            const previousState = historyStack.pop();

            // Restore previous state
            capexTree = previousState.tree;
            currentPattern = previousState.pattern;
            document.getElementById('pattern-select').value = currentPattern;

            // Re-render
            render();

            updateUndoButton();

            console.log(`â†©ï¸ Undo: Restored state from "${previousState.action}" (${historyStack.length} states remaining)`);

            // Show toast notification
            showToast(`Undone: ${previousState.action}`);
        }

        // Update undo button state
        function updateUndoButton() {
            const undoBtn = document.getElementById('undo-btn');
            if (undoBtn) {
                if (historyStack.length > 0) {
                    undoBtn.disabled = false;
                    undoBtn.style.opacity = '1';
                    const lastAction = historyStack[historyStack.length - 1].action;
                    undoBtn.title = `Undo: ${lastAction}`;
                } else {
                    undoBtn.disabled = true;
                    undoBtn.style.opacity = '0.5';
                    undoBtn.title = 'Nothing to undo';
                }
            }
        }

        // Toast notification for undo
        function showToast(message) {
            // Remove existing toast if any
            const existingToast = document.getElementById('undo-toast');
            if (existingToast) {
                existingToast.remove();
            }

            // Create toast
            const toast = document.createElement('div');
            toast.id = 'undo-toast';
            toast.style.cssText = `
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.85);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                animation: slideUp 0.3s ease-out;
            `;
            toast.textContent = message;

            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideUp {
                    from {
                        opacity: 0;
                        transform: translateX(-50%) translateY(20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(toast);

            // Auto-remove after 2 seconds
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        // Attach undo button handler
        const undoBtnEl = document.getElementById('undo-btn');
        if (undoBtnEl) {
            undoBtnEl.addEventListener('click', undo);
        }

        // Keyboard shortcut for undo (Ctrl+Z / Cmd+Z)
        document.addEventListener('keydown', (e) => {
            // Check for Ctrl+Z (Windows/Linux) or Cmd+Z (Mac)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                // Don't trigger undo if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle undo in text fields
                }

                e.preventDefault();
                undo();
            }

            // Check for Ctrl+S (Windows/Linux) or Cmd+S (Mac) - Save shortcut
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                // Don't trigger save if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle save in text fields if needed
                }

                e.preventDefault();
                console.log('âŒ¨ï¸ Ctrl+S pressed - triggering manual save');
                if (typeof treeManager !== 'undefined') {
                    treeManager.save(capexTree, { forceSaveAs: false });
                } else {
                    console.warn('TreeManager not initialized yet');
                }
            }

            // BUILD 396: Ctrl+/ or Cmd+/ - Toggle Chat Panel
            if ((e.ctrlKey || e.metaKey) && e.key === '/') {
                // Don't toggle if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return;
                }

                e.preventDefault();
                console.log('âŒ¨ï¸ Ctrl+/ pressed - toggling chat');
                if (typeof toggleChatPanel === 'function') {
                    toggleChatPanel();
                }
            }

            // Check for Ctrl+A (Windows/Linux) or Cmd+A (Mac) - Select all nodes in Canvas View
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                // Only work in Canvas View and not when typing in text fields
                const activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                     activeElement.tagName === 'TEXTAREA' ||
                     activeElement.isContentEditable)) {
                    return; // Let the browser handle Ctrl+A in text fields
                }

                // Only work in Canvas View
                if (viewMode === 'canvas' && canvasNodes.length > 0) {
                    e.preventDefault();
                    console.log('âŒ¨ï¸ Ctrl+A pressed - selecting all visible nodes');

                    // Clear current selection
                    selectedNodes = [];

                    // Select all visible canvas nodes
                    canvasNodes.forEach(nodeObj => {
                        const node = nodeObj.data;
                        const nodeEl = nodeObj.element;

                        if (node.canvasX !== undefined && node.canvasY !== undefined) {
                            selectedNodes.push(node);
                            nodeEl.classList.add('selected');
                        }
                    });

                    updateSelectionCounter();
                    console.log(`Selected ${selectedNodes.length} nodes`);
                }
            }

            // Check for Escape - Clear selection in Canvas View
            if (e.key === 'Escape') {
                // Only work in Canvas View
                if (viewMode === 'canvas' && selectedNodes.length > 0) {
                    console.log('âŒ¨ï¸ Escape pressed - clearing selection');
                    clearSelection();
                }
            }
        });

        // =============================================================================
        // END UNDO/REDO SYSTEM
        // =============================================================================

// TREEPLEXITY PATTERN SELECTOR
// Insert this code into treelisty.html

// ============================================================================
// PATTERN DEFINITIONS
// ============================================================================

const PATTERNS = {
    generic: {
        name: 'Generic Project',
        icon: 'ðŸ“‹',
        levels: {
            root: 'Project',
            phase: 'Phase',
            item: 'Item',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Seed', 'Seed', 'Build'],
        types: [
            { value: 'land', label: 'Land' },
            { value: 'engineering', label: 'Engineering' },
            { value: 'equipment', label: 'Equipment' },
            { value: 'infrastructure', label: 'Infrastructure' },
            { value: 'corporate', label: 'Corporate' },
            { value: 'professional', label: 'Professional' },
            { value: 'contingency', label: 'Contingency' }
        ],
        description: 'Universal structure for any project',
        sortOptions: [
            { value: 'cost-high', label: 'ðŸ’° Cost (Highest First)', field: 'cost', order: 'desc', type: 'number' },
            { value: 'cost-low', label: 'ðŸ’° Cost (Lowest First)', field: 'cost', order: 'asc', type: 'number' },
            { value: 'leadtime-soonest', label: 'â±ï¸ Lead Time (Soonest First)', field: 'leadTime', order: 'asc', type: 'leadtime' },
            { value: 'leadtime-latest', label: 'â±ï¸ Lead Time (Latest First)', field: 'leadTime', order: 'desc', type: 'leadtime' },
            { value: 'name-az', label: 'ðŸ”¤ Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ðŸ”¤ Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ],
        fields: {
            cost: { label: 'Cost ($)', type: 'number', step: 1000, helpText: 'ðŸ’° Budget allocated for this item' },
            alternateSource: { label: 'Alternate Source', type: 'text', placeholder: 'Backup vendor, supplier, or alternative solution...', helpText: 'ðŸ“¦ Alternative supplier or backup option for risk mitigation' },
            leadTime: { label: 'Lead Time', type: 'text', placeholder: 'e.g., 12-18 months, 6 weeks, 90 days...', helpText: 'â±ï¸ Expected procurement or delivery timeline' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    sales: {
        name: 'Sales Pipeline',
        icon: 'ðŸ’¼',
        levels: {
            root: 'Pipeline',
            phase: 'Quarter',
            item: 'Deal',
            subtask: 'Action'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'inbound', label: 'Inbound Lead' },
            { value: 'outbound', label: 'Outbound Prospect' },
            { value: 'partnership', label: 'Partnership' },
            { value: 'expansion', label: 'Account Expansion' },
            { value: 'renewal', label: 'Renewal' },
            { value: 'upsell', label: 'Upsell' },
            { value: 'cross-sell', label: 'Cross-sell' },
            { value: 'enterprise', label: 'Enterprise Deal' }
        ],
        description: 'Track sales opportunities through quarters',
        sortOptions: [
            { value: 'dealvalue-high', label: 'ðŸ’° Deal Value (Largest First)', field: 'dealValue', order: 'desc', type: 'number' },
            { value: 'dealvalue-low', label: 'ðŸ’° Deal Value (Smallest First)', field: 'dealValue', order: 'asc', type: 'number' },
            { value: 'closedate-soonest', label: 'ðŸ“… Close Date (Soonest First)', field: 'expectedCloseDate', order: 'asc', type: 'date' },
            { value: 'closedate-latest', label: 'ðŸ“… Close Date (Latest First)', field: 'expectedCloseDate', order: 'desc', type: 'date' },
            { value: 'probability-high', label: 'ðŸ“Š Probability (Highest First)', field: 'stageProbability', order: 'desc', type: 'number' },
            { value: 'probability-low', label: 'ðŸ“Š Probability (Lowest First)', field: 'stageProbability', order: 'asc', type: 'number' },
            { value: 'name-az', label: 'ðŸ”¤ Deal Name (A-Z)', field: 'name', order: 'asc', type: 'text' }
        ],
        fields: {
            dealValue: { label: 'Deal Value ($)', type: 'number', step: 1000, helpText: 'ðŸ’° Potential revenue from this deal' },
            expectedCloseDate: { label: 'Expected Close Date', type: 'date', helpText: 'ðŸ“… Target date to close this deal' },
            leadSource: { label: 'Lead Source', type: 'text', placeholder: 'Inbound, Referral, Cold Outreach...', helpText: 'ðŸ“ How did this lead originate?' },
            contactPerson: { label: 'Contact Person', type: 'text', placeholder: 'Primary contact name...', helpText: 'ðŸ‘¤ Main decision maker or champion' },
            stageProbability: { label: 'Stage Probability (%)', type: 'number', min: 0, max: 100, step: 5, helpText: 'ðŸ“Š Likelihood of closing this deal' },
            competitorInfo: { label: 'Competitor Info', type: 'textarea', placeholder: 'Who else is competing for this deal...', helpText: 'ðŸŽ¯ Other vendors in consideration' },
            includeDependencies: false,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    thesis: {
        name: 'Academic Writing',
        icon: 'ðŸŽ“',
        levels: {
            root: 'Thesis',
            phase: 'Chapter',
            item: 'Section',
            subtask: 'Point'
        },
        phaseSubtitles: ['Introduction', 'Body', 'Conclusion'],
        types: [
            { value: 'literature-review', label: 'Literature Review' },
            { value: 'methodology', label: 'Methodology' },
            { value: 'analysis', label: 'Analysis' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'theory', label: 'Theoretical Framework' },
            { value: 'evidence', label: 'Evidence' },
            { value: 'argument', label: 'Argument' },
            { value: 'conclusion', label: 'Conclusion' }
        ],
        description: 'Structure academic papers and dissertations',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'ðŸ“ Current word count for this section' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'ðŸŽ¯ Goal word count for this section' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: 'âœï¸ Current revision stage' },
            citations: { label: 'Key Citations', type: 'textarea', placeholder: 'List main sources and references...', helpText: 'ðŸ“š Important sources for this section' },
            keyArgument: { label: 'Key Argument', type: 'textarea', placeholder: 'Main point of this section...', helpText: 'ðŸ’¡ Central claim or thesis' },
            evidenceType: { label: 'Evidence Type', type: 'select', options: ['Empirical', 'Theoretical', 'Mixed', 'N/A'], helpText: 'ðŸ”¬ Nature of supporting evidence' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    roadmap: {
        name: 'Product Roadmap',
        icon: 'ðŸš€',
        levels: {
            root: 'Product',
            phase: 'Quarter',
            item: 'Feature',
            subtask: 'Story'
        },
        phaseSubtitles: ['Q1', 'Q2', 'Q3', 'Q4'],
        types: [
            { value: 'core-feature', label: 'Core Feature' },
            { value: 'enhancement', label: 'Enhancement' },
            { value: 'bug-fix', label: 'Bug Fix' },
            { value: 'technical-debt', label: 'Technical Debt' },
            { value: 'research', label: 'Research/Spike' },
            { value: 'platform', label: 'Platform' },
            { value: 'integration', label: 'Integration' },
            { value: 'ux', label: 'UX Improvement' }
        ],
        description: 'Plan product features across quarters',
        fields: {
            storyPoints: { label: 'Story Points', type: 'number', min: 0, step: 1, placeholder: '1, 2, 3, 5, 8, 13...', helpText: 'ðŸŽ¯ Effort estimate (Fibonacci scale)' },
            engineeringEstimate: { label: 'Engineering Estimate', type: 'text', placeholder: '2 weeks, 1 sprint, 3 days...', helpText: 'â±ï¸ Time estimate from engineering' },
            userImpact: { label: 'User Impact', type: 'select', options: ['High', 'Medium', 'Low'], helpText: 'ðŸ‘¥ How many users does this affect?' },
            technicalRisk: { label: 'Technical Risk', type: 'select', options: ['Low', 'Medium', 'High', 'Unknown'], helpText: 'âš ï¸ Complexity and technical uncertainty' },
            featureFlag: { label: 'Feature Flag', type: 'text', placeholder: 'flag_name...', helpText: 'ðŸš© Feature flag for gradual rollout' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    book: {
        name: 'Book Writing',
        icon: 'ðŸ“š',
        levels: {
            root: 'Book',
            phase: 'Part',
            item: 'Chapter',
            subtask: 'Scene'
        },
        phaseSubtitles: ['Act I', 'Act II', 'Act III'],
        types: [
            { value: 'narrative', label: 'Narrative' },
            { value: 'dialogue', label: 'Dialogue' },
            { value: 'description', label: 'Description' },
            { value: 'action', label: 'Action' },
            { value: 'reflection', label: 'Reflection' },
            { value: 'transition', label: 'Transition' },
            { value: 'climax', label: 'Climax' },
            { value: 'exposition', label: 'Exposition' }
        ],
        description: 'Organize books into parts, chapters, and scenes',
        fields: {
            wordCount: { label: 'Word Count', type: 'number', min: 0, step: 50, helpText: 'ðŸ“ Current word count' },
            targetWordCount: { label: 'Target Word Count', type: 'number', min: 0, step: 50, helpText: 'ðŸŽ¯ Goal word count' },
            draftStatus: { label: 'Draft Status', type: 'select', options: ['Outline', 'First Draft', 'Revision', 'Final'], helpText: 'âœï¸ Current revision stage' },
            povCharacter: { label: 'POV Character', type: 'text', placeholder: 'Whose perspective...', helpText: 'ðŸ‘¤ Point-of-view character' },
            sceneSetting: { label: 'Scene Setting', type: 'textarea', placeholder: 'Location, time, mood...', helpText: 'ðŸŽ­ Where and when this takes place' },
            plotFunction: { label: 'Plot Function', type: 'select', options: ['Setup', 'Conflict', 'Resolution', 'Transition'], helpText: 'ðŸ“– Role in story structure' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    event: {
        name: 'Event Planning',
        icon: 'ðŸŽ‰',
        levels: {
            root: 'Event',
            phase: 'Stage',
            item: 'Activity',
            subtask: 'Task'
        },
        phaseSubtitles: ['Pre-Event', 'Event Day', 'Post-Event'],
        types: [
            { value: 'logistics', label: 'Logistics' },
            { value: 'catering', label: 'Catering' },
            { value: 'entertainment', label: 'Entertainment' },
            { value: 'venue', label: 'Venue' },
            { value: 'marketing', label: 'Marketing' },
            { value: 'registration', label: 'Registration' },
            { value: 'follow-up', label: 'Follow-up' },
            { value: 'av-tech', label: 'AV/Tech' }
        ],
        description: 'Plan events from prep to execution to follow-up',
        fields: {
            budget: { label: 'Budget ($)', type: 'number', step: 100, helpText: 'ðŸ’° Budget for this activity' },
            vendor: { label: 'Vendor/Supplier', type: 'text', placeholder: 'Company or person name...', helpText: 'ðŸ¢ External vendor or supplier' },
            bookingDeadline: { label: 'Booking Deadline', type: 'date', helpText: 'ðŸ“… Last date to book/reserve' },
            guestCount: { label: 'Guest Count', type: 'number', min: 0, placeholder: 'Expected attendees...', helpText: 'ðŸ‘¥ Number of expected guests' },
            location: { label: 'Location', type: 'text', placeholder: 'Venue, room, area...', helpText: 'ðŸ“ Where this takes place' },
            responsiblePerson: { label: 'Responsible Person', type: 'text', placeholder: 'Team member name...', helpText: 'ðŸ‘¤ Who\'s handling this' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    fitness: {
        name: 'Fitness Program',
        icon: 'ðŸ’ª',
        levels: {
            root: 'Program',
            phase: 'Phase',
            item: 'Workout',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Foundation', 'Build', 'Peak'],
        types: [
            { value: 'strength', label: 'Strength Training' },
            { value: 'cardio', label: 'Cardio' },
            { value: 'flexibility', label: 'Flexibility' },
            { value: 'recovery', label: 'Recovery' },
            { value: 'nutrition', label: 'Nutrition' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'conditioning', label: 'Conditioning' },
            { value: 'mobility', label: 'Mobility' }
        ],
        description: 'Structure training programs with periodization',
        fields: {
            sets: { label: 'Sets', type: 'number', min: 0, step: 1, placeholder: 'Number of sets...', helpText: 'ðŸ”¢ Number of sets' },
            reps: { label: 'Reps', type: 'text', placeholder: '8-12, 10, AMRAP...', helpText: 'ðŸ” Repetitions per set' },
            duration: { label: 'Duration', type: 'text', placeholder: '30 minutes, 45 sec...', helpText: 'â±ï¸ Time for this exercise/workout' },
            intensity: { label: 'Intensity Level', type: 'select', options: ['Light', 'Moderate', 'High', 'Max'], helpText: 'ðŸ”¥ Effort level' },
            equipment: { label: 'Equipment Needed', type: 'text', placeholder: 'Dumbbells, Barbell, Bodyweight...', helpText: 'ðŸ‹ï¸ Required equipment' },
            formCues: { label: 'Form Cues', type: 'textarea', placeholder: 'Key technique reminders...', helpText: 'âœ… Important form tips' },
            restPeriod: { label: 'Rest Period', type: 'text', placeholder: '60 sec, 2 min...', helpText: 'â¸ï¸ Rest between sets' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    strategy: {
        name: 'Strategic Plan',
        icon: 'ðŸ“Š',
        levels: {
            root: 'Strategy',
            phase: 'Pillar',
            item: 'Initiative',
            subtask: 'Action'
        },
        phaseSubtitles: ['Planning', 'Execution', 'Review'],
        types: [
            { value: 'market-expansion', label: 'Market Expansion' },
            { value: 'operational', label: 'Operational Excellence' },
            { value: 'financial', label: 'Financial' },
            { value: 'hr', label: 'Human Resources' },
            { value: 'technology', label: 'Technology' },
            { value: 'risk-management', label: 'Risk Management' },
            { value: 'innovation', label: 'Innovation' },
            { value: 'customer', label: 'Customer Experience' }
        ],
        description: 'Organize business strategy into pillars and initiatives',
        fields: {
            investment: { label: 'Investment ($)', type: 'number', step: 10000, helpText: 'ðŸ’° Capital investment required' },
            keyMetric: { label: 'Key Metric', type: 'text', placeholder: 'What defines success...', helpText: 'ðŸ“Š Success measurement' },
            targetValue: { label: 'Target Value', type: 'text', placeholder: 'Goal for metric...', helpText: 'ðŸŽ¯ Goal to achieve' },
            responsibleExecutive: { label: 'Responsible Executive', type: 'text', placeholder: 'C-level owner...', helpText: 'ðŸ‘” Executive sponsor' },
            strategicTheme: { label: 'Strategic Theme', type: 'select', options: ['Growth', 'Efficiency', 'Innovation', 'Transformation', 'Risk Mitigation'], helpText: 'ðŸŽ­ Strategic category' },
            riskLevel: { label: 'Risk Level', type: 'select', options: ['Low', 'Medium', 'High'], helpText: 'âš ï¸ Implementation risk' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    course: {
        name: 'Course Design',
        icon: 'ðŸ“–',
        levels: {
            root: 'Course',
            phase: 'Unit',
            item: 'Lesson',
            subtask: 'Exercise'
        },
        phaseSubtitles: ['Beginning', 'Middle', 'Advanced'],
        types: [
            { value: 'lecture', label: 'Lecture' },
            { value: 'lab', label: 'Lab/Practical' },
            { value: 'discussion', label: 'Discussion' },
            { value: 'assessment', label: 'Assessment' },
            { value: 'reading', label: 'Reading' },
            { value: 'project', label: 'Project' },
            { value: 'workshop', label: 'Workshop' },
            { value: 'field-work', label: 'Field Work' }
        ],
        description: 'Build educational curricula with units and lessons',
        fields: {
            learningObjectives: { label: 'Learning Objectives', type: 'textarea', placeholder: 'What students will learn...', helpText: 'ðŸŽ“ Expected learning outcomes' },
            duration: { label: 'Duration', type: 'text', placeholder: '50 minutes, 2 hours...', helpText: 'â±ï¸ Class time needed' },
            difficultyLevel: { label: 'Difficulty Level', type: 'select', options: ['Beginner', 'Intermediate', 'Advanced'], helpText: 'ðŸ“Š Complexity level' },
            prerequisites: { label: 'Prerequisites', type: 'textarea', placeholder: 'Prior knowledge needed...', helpText: 'ðŸ“‹ Required background' },
            assessmentType: { label: 'Assessment Type', type: 'select', options: ['Quiz', 'Assignment', 'Project', 'Discussion', 'Exam', 'None'], helpText: 'âœ… How learning is evaluated' },
            resourcesNeeded: { label: 'Resources Needed', type: 'textarea', placeholder: 'Textbook chapters, videos, materials...', helpText: 'ðŸ“š Required materials' },
            homework: { label: 'Homework', type: 'textarea', placeholder: 'Out-of-class work...', helpText: 'ðŸ“ Assignments for students' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    film: {
        name: 'AI Video Production',
        icon: 'ðŸŽ¬',
        levels: {
            root: 'Film',
            phase: 'Act',
            item: 'Scene',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Act I - Setup', 'Act II - Conflict', 'Act III - Resolution'],
        types: [
            { value: 'establishing', label: 'Establishing Shot' },
            { value: 'character-intro', label: 'Character Introduction' },
            { value: 'dialogue', label: 'Dialogue Scene' },
            { value: 'action', label: 'Action Sequence' },
            { value: 'montage', label: 'Montage' },
            { value: 'transition', label: 'Transition' },
            { value: 'climax', label: 'Climax' },
            { value: 'resolution', label: 'Resolution' }
        ],
        description: 'Create films using AI video generation (Sora, Veo, Runway, Pika)',
        fields: {
            aiPlatform: { label: 'AI Platform', type: 'select', options: ['Sora (OpenAI)', 'Veo 3 (Google)', 'Runway Gen-3', 'Pika 2.0', 'Kling AI', 'Luma Dream Machine', 'Haiper', 'Testing Multiple'], helpText: 'ðŸ¤– Which AI video model to use' },
            videoPrompt: { label: 'Video Prompt', type: 'textarea', placeholder: 'Detailed text-to-video prompt...', helpText: 'âœï¸ Primary prompt describing the scene (be specific: camera movement, lighting, mood, action)' },
            visualStyle: { label: 'Visual Style', type: 'select', options: ['Photorealistic', 'Cinematic', 'Documentary', 'Anime', 'Pixar 3D', 'Stop Motion', 'Vintage Film', 'Noir', 'Sci-Fi', 'Fantasy'], helpText: 'ðŸŽ¨ Overall aesthetic and look' },
            duration: { label: 'Duration', type: 'select', options: ['2 seconds', '4 seconds', '6 seconds', '10 seconds', '20 seconds', 'Extended (loop)'], helpText: 'â±ï¸ Video clip length' },
            aspectRatio: { label: 'Aspect Ratio', type: 'select', options: ['16:9 (Widescreen)', '9:16 (Vertical/Mobile)', '1:1 (Square)', '2.39:1 (Cinematic)', '4:3 (Classic)'], helpText: 'ðŸ“ Video dimensions for target platform' },
            cameraMovement: { label: 'Camera Movement', type: 'select', options: ['Static', 'Slow Pan', 'Dolly In', 'Dolly Out', 'Tracking Shot', 'Crane Up', 'Crane Down', 'Handheld', 'Orbiting'], helpText: 'ðŸŽ¥ How camera moves through scene' },
            motionIntensity: { label: 'Motion Intensity', type: 'select', options: ['Minimal', 'Subtle', 'Moderate', 'Dynamic', 'Intense'], helpText: 'ðŸŒŠ Amount of movement and action' },
            lightingMood: { label: 'Lighting Mood', type: 'select', options: ['Golden Hour', 'Overcast', 'Night', 'Neon', 'Dramatic', 'Soft Natural', 'High Contrast', 'Backlit'], helpText: 'ðŸ’¡ Lighting setup and atmosphere' },
            iterationNotes: { label: 'Generation Notes', type: 'textarea', placeholder: 'Prompt refinements, variations tried, best practices learned...', helpText: 'ðŸ“ What worked, what didn\'t, prompt engineering insights' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        },
        sortOptions: [
            { value: 'visualstyle', label: 'ðŸŽ¨ Visual Style', field: 'visualStyle', order: 'asc', type: 'text' },
            { value: 'lightingmood', label: 'ðŸ’¡ Lighting Mood', field: 'lightingMood', order: 'asc', type: 'text' },
            { value: 'cameramovement', label: 'ðŸŽ¥ Camera Movement', field: 'cameraMovement', order: 'asc', type: 'text' },
            { value: 'aiplatform', label: 'ðŸ¤– AI Platform', field: 'aiPlatform', order: 'asc', type: 'text' },
            { value: 'duration', label: 'â±ï¸ Duration', field: 'duration', order: 'asc', type: 'text' },
            { value: 'name-az', label: 'ðŸ”¤ Scene Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ðŸ”¤ Scene Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ]
    },
    veo3: {
        name: 'Veo3 (Google)',
        icon: 'ðŸŽ¥',
        levels: {
            root: 'Project',
            phase: 'Sequence',
            item: 'Scene',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Opening Sequence', 'Development', 'Climax Sequence'],
        types: [
            { value: 'ingredients', label: 'Ingredients to Video' },
            { value: 'frames', label: 'Frames to Video' },
            { value: 'extend', label: 'Extend Video' },
            { value: 'standard', label: 'Standard Generation' }
        ],
        description: 'Google Veo 3.1 AI video generation with Flow workflow',
        fields: {
            flowMode: { label: 'Flow Mode', type: 'select', options: ['Ingredients to Video', 'Frames to Video', 'Extend', 'Standard'], helpText: 'ðŸŽ¬ Veo 3 generation mode (ingredients, frame bridging, or extension)' },
            videoPrompt: { label: 'Video Prompt', type: 'textarea', placeholder: 'Detailed text-to-video prompt...', helpText: 'âœï¸ Primary prompt for Veo 3 generation' },
            ingredientImages: { label: 'Ingredient Images', type: 'textarea', placeholder: 'URLs of reference images (character, objects, style)...', helpText: 'ðŸ–¼ï¸ Reference images for character/object/style control (Ingredients mode)' },
            startFrame: { label: 'Start Frame', type: 'text', placeholder: 'URL or ID...', helpText: 'ðŸŽžï¸ Starting frame for frame bridging (Frames mode)' },
            endFrame: { label: 'End Frame', type: 'text', placeholder: 'URL or ID...', helpText: 'ðŸŽžï¸ Ending frame for frame bridging (Frames mode)' },
            extendDuration: { label: 'Extend Duration', type: 'select', options: ['10 seconds', '20 seconds', '30 seconds', '60+ seconds'], helpText: 'â±ï¸ Target duration for extended video (Extend mode)' },
            duration: { label: 'Duration', type: 'select', options: ['4 seconds', '6 seconds', '8 seconds'], helpText: 'â±ï¸ Standard Veo 3 durations @ 24 FPS' },
            resolution: { label: 'Resolution', type: 'select', options: ['720p', '1080p'], helpText: 'ðŸ“º Output resolution' },
            audioType: { label: 'Audio Type', type: 'select', options: ['Dialogue', 'Sound Effects', 'Ambience', 'Mixed', 'Silent'], helpText: 'ðŸ”Š Native audio generation type' },
            cinematicStyle: { label: 'Cinematic Style', type: 'select', options: ['Realistic', 'Dramatic', 'Documentary', 'Commercial', 'Artistic', 'Music Video'], helpText: 'ðŸŽ­ Veo 3 cinematic style understanding' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    sora2: {
        name: 'Sora2 (OpenAI)',
        icon: 'ðŸŽ¬',
        levels: {
            root: 'Project',
            phase: 'Sequence',
            item: 'Beat',
            subtask: 'Shot'
        },
        phaseSubtitles: ['Setup', 'Conflict', 'Resolution'],
        types: [
            { value: 'cameo', label: 'Cameo Shot' },
            { value: 'remix', label: 'Remix Variant' },
            { value: 'standard', label: 'Standard Generation' },
            { value: 'physics-complex', label: 'Complex Physics' }
        ],
        description: 'OpenAI Sora 2 AI video generation with cameo and remix capabilities',
        fields: {
            videoPrompt: { label: 'Video Prompt', type: 'textarea', placeholder: 'Detailed text-to-video prompt for Sora 2...', helpText: 'âœï¸ Primary prompt for Sora 2 generation (physics-aware)' },
            beatType: { label: 'Beat Type', type: 'select', options: ['Setup', 'Conflict', 'Transition', 'Resolution', 'Character Moment'], helpText: 'ðŸŽ¯ Narrative beat purpose in storyboard' },
            cameoUsed: { label: 'Uses Cameo', type: 'select', options: ['None', 'Cameo ID 1', 'Cameo ID 2', 'Cameo ID 3'], helpText: 'ðŸ‘¤ Insert pre-recorded cameo (person/object) into scene' },
            remixSource: { label: 'Remix Source', type: 'text', placeholder: 'Source shot ID...', helpText: 'ðŸ”„ Source shot for remix/modification (instead of full regeneration)' },
            physicsComplexity: { label: 'Physics Complexity', type: 'select', options: ['Simple', 'Medium', 'Complex (Gymnastics/Water/Ballistics)'], helpText: 'âš¡ Physics accuracy level needed' },
            duration: { label: 'Duration', type: 'select', options: ['4 seconds', '8 seconds', '12 seconds'], helpText: 'â±ï¸ Sora 2 Pro fixed durations' },
            resolution: { label: 'Resolution', type: 'select', options: ['720p', '1080p'], helpText: 'ðŸ“º Output resolution for cinematic quality' },
            nleExportFormat: { label: 'NLE Export', type: 'select', options: ['Premiere Pro', 'Final Cut Pro', 'DaVinci Resolve', 'After Effects', 'Raw Files'], helpText: 'ðŸ“¤ Post-production NLE format' },
            audioSync: { label: 'Audio Sync', type: 'select', options: ['Synchronized Dialogue', 'Sound Effects', 'Background Score', 'Silent'], helpText: 'ðŸŽµ Sora 2 synchronized audio generation' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    philosophy: {
        name: 'Philosophy',
        icon: 'ðŸ¤”',
        levels: {
            root: 'Dialogue',
            phase: 'Movement',
            item: 'Claim',
            subtask: 'Support'
        },
        phaseSubtitles: ['Opening Question', 'First Definition', 'Refutation', 'Second Attempt', 'Deeper Inquiry', 'Resolution'],
        types: [
            // Dialectical moves
            { value: 'question', label: 'â“ Question' },
            { value: 'definition', label: 'ðŸ“ Definition' },
            { value: 'refutation', label: 'âŒ Refutation/Elenchus' },
            { value: 'premise', label: 'ðŸ“ Premise' },
            { value: 'conclusion', label: 'âœ“ Conclusion' },
            { value: 'objection', label: 'âš ï¸ Objection' },
            { value: 'response', label: 'ðŸ’¬ Response' },
            { value: 'example', label: 'ðŸ“– Example' },
            { value: 'analogy', label: 'ðŸ”„ Analogy' },
            { value: 'distinction', label: 'âš–ï¸ Distinction' },
            { value: 'paradox', label: 'ðŸŒ€ Paradox' },
            { value: 'thought-experiment', label: 'ðŸ’­ Thought Experiment' },
            { value: 'aporia', label: 'ðŸ¤· Aporia (Impasse)' },
            // Philosophical domains
            { value: 'metaphysical', label: 'ðŸŒŒ Metaphysical' },
            { value: 'epistemological', label: 'ðŸ§  Epistemological' },
            { value: 'ethical', label: 'âš–ï¸ Ethical' },
            { value: 'political', label: 'ðŸ›ï¸ Political' },
            { value: 'logical', label: 'ðŸ”¢ Logical' }
        ],
        description: 'Structure philosophical dialogues, treatises, and arguments with dialectical precision',
        fields: {
            speaker: { label: 'Speaker', type: 'text', placeholder: 'Socrates, Meno, etc...', helpText: 'ðŸ—£ï¸ Who makes this claim or argument' },
            argumentType: { label: 'Argument Type', type: 'select', options: ['Deductive', 'Inductive', 'Abductive', 'Dialectical', 'Reductio ad Absurdum', 'Socratic Elenchus'], helpText: 'ðŸŽ¯ Type of reasoning employed' },
            validity: { label: 'Logical Validity', type: 'select', options: ['Valid', 'Invalid', 'Sound', 'Unsound', 'Uncertain'], helpText: 'âœ“ Logical soundness' },
            keyTerms: { label: 'Key Terms', type: 'text', placeholder: 'virtue, knowledge, piety...', helpText: 'ðŸ“ Central concepts defined or discussed' },
            premise1: { label: 'Premise 1', type: 'textarea', placeholder: 'First premise of argument...', helpText: '1ï¸âƒ£ First assumption or claim' },
            premise2: { label: 'Premise 2', type: 'textarea', placeholder: 'Second premise...', helpText: '2ï¸âƒ£ Second assumption or claim' },
            conclusion: { label: 'Conclusion', type: 'textarea', placeholder: 'What follows from premises...', helpText: 'âœ“ Logical conclusion' },
            objection: { label: 'Objection', type: 'textarea', placeholder: 'Main counterargument...', helpText: 'âŒ Key objection raised' },
            response: { label: 'Response to Objection', type: 'textarea', placeholder: 'How objection is addressed...', helpText: 'ðŸ’¡ Defense or reply to objection' },
            textualReference: { label: 'Textual Reference', type: 'text', placeholder: 'e.g., Meno 70a-72c, Republic 347c...', helpText: 'ðŸ“– Stephanus number or page reference' },
            philosophicalSchool: { label: 'School of Thought', type: 'select', options: ['Pre-Socratic', 'Platonic', 'Aristotelian', 'Stoic', 'Epicurean', 'Skeptic', 'Medieval', 'Rationalist', 'Empiricist', 'Kantian', 'Hegelian', 'Phenomenological', 'Analytic', 'Continental', 'Pragmatist', 'Other'], helpText: 'ðŸ›ï¸ Philosophical tradition or school' },
            includeDependencies: true,
            includeTracking: false
        },
        sortOptions: [
            { value: 'speaker-az', label: 'ðŸ—£ï¸ Speaker (A-Z)', field: 'speaker', order: 'asc', type: 'text' },
            { value: 'speaker-za', label: 'ðŸ—£ï¸ Speaker (Z-A)', field: 'speaker', order: 'desc', type: 'text' },
            { value: 'argumenttype', label: 'ðŸŽ¯ Argument Type', field: 'argumentType', order: 'asc', type: 'text' },
            { value: 'validity', label: 'âœ“ Logical Validity', field: 'validity', order: 'asc', type: 'text' },
            { value: 'school', label: 'ðŸ›ï¸ Philosophical School', field: 'philosophicalSchool', order: 'asc', type: 'text' },
            { value: 'name-az', label: 'ðŸ”¤ Claim Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ðŸ”¤ Claim Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ]
    },
    prompting: {
        name: 'Prompt Engineering',
        icon: 'ðŸ§ ',
        levels: {
            root: 'Prompt Library',
            phase: 'Category',
            item: 'Prompt',
            subtask: 'Test Case'
        },
        phaseSubtitles: ['Customer Support', 'Content Generation', 'Data Analysis', 'Code Assistance', 'Research', 'Creative Writing'],
        types: [
            { value: 'task-instruction', label: 'ðŸ’¬ Task Instruction' },
            { value: 'few-shot', label: 'ðŸ“š Few-Shot Examples' },
            { value: 'chain-of-thought', label: 'ðŸ§  Chain-of-Thought' },
            { value: 'structured-output', label: 'ðŸ“ Structured Output' },
            { value: 'xml-guided', label: 'ðŸ—ï¸ XML-Guided (Anthropic)' },
            { value: 'prefill-guided', label: 'ðŸŽ¯ Prefill-Guided (Claude)' },
            { value: 'production', label: 'âœ… Production-Ready' },
            { value: 'experimental', label: 'ðŸ§ª Experimental' }
        ],
        description: 'Design and test AI prompts with best practices from OpenAI and Anthropic',
        fields: {
            systemPrompt: {
                label: 'System Prompt (Required)',
                type: 'textarea',
                placeholder: 'You are an expert customer support agent with 10 years of experience. You are helpful, empathetic, and solution-focused. Always maintain a professional yet friendly tone.',
                helpText: 'ðŸ‘¤ Define the AI\'s role, expertise, and behavior. This sets the foundation for all responses.'
            },
            userPromptTemplate: {
                label: 'User Prompt (Required)',
                type: 'textarea',
                placeholder: 'Analyze the following customer support ticket and provide a recommended response:\n\nTicket: {{ticket_text}}\nPriority: {{priority}}\nCustomer Tier: {{tier}}\n\nProvide:\n1. Issue summary\n2. Recommended resolution\n3. Escalation needed (yes/no)',
                helpText: 'ðŸ’¬ The main instruction telling the AI what to do. Use {{variables}} for dynamic content.'
            },
            fewShotExamples: {
                label: 'Examples (Recommended)',
                type: 'textarea',
                placeholder: '<example>\nInput: Customer reports login issue on mobile app\nOutput: {\n  "summary": "Authentication failure on iOS app",\n  "resolution": "Clear app cache and reinstall",\n  "escalate": "no"\n}\n</example>\n\n<example>\nInput: Customer requests refund for annual subscription\nOutput: {\n  "summary": "Refund request - annual plan",\n  "resolution": "Process pro-rated refund per policy",\n  "escalate": "yes"\n}\n</example>',
                helpText: 'ðŸ“š Show 2-3 examples of input â†’ output. This dramatically improves accuracy and consistency.'
            },
            outputFormat: {
                label: 'Output Format (Recommended)',
                type: 'textarea',
                placeholder: 'Return your response as JSON with this exact structure:\n{\n  "summary": "brief issue description",\n  "resolution": "recommended action",\n  "escalate": "yes or no"\n}',
                helpText: 'ðŸ“ Specify exactly how you want the output structured (JSON, markdown, bullet points, etc.)'
            },
            chainOfThought: {
                label: 'Chain-of-Thought (Optional)',
                type: 'textarea',
                placeholder: 'Before providing your answer, think through this step-by-step:\n1. What is the core issue?\n2. What are possible solutions?\n3. Which solution is best and why?',
                helpText: 'ðŸ§  Ask the AI to "think out loud" before answering. Improves reasoning quality.'
            },
            modelTarget: {
                label: 'Target Model',
                type: 'select',
                options: ['Claude 3.5 Sonnet', 'Claude 3 Opus', 'GPT-4o', 'GPT-4 Turbo', 'o1-preview'],
                helpText: 'ðŸ¤– Which AI model this prompt is optimized for'
            },
            temperature: {
                label: 'Temperature',
                type: 'number',
                min: 0,
                max: 1,
                step: 0.1,
                placeholder: '0.7',
                helpText: 'ðŸŒ¡ï¸ 0 = consistent/factual, 1 = creative/varied. Use 0-0.3 for analysis, 0.7-1.0 for creative writing.'
            },
            testResults: {
                label: 'Test Results',
                type: 'textarea',
                placeholder: 'Tested on 50 examples:\nâœ… 94% accuracy\nâš¡ Avg response time: 1.3s\nðŸ’° Cost per request: $0.015',
                helpText: 'âœ… Track how well this prompt performs on real test cases'
            },
            testStatus: {
                label: 'Status',
                type: 'select',
                options: ['Draft', 'Testing', 'Validated', 'Production', 'Deprecated'],
                helpText: 'âœ… Development stage'
            },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    familytree: {
        name: 'Family Tree',
        icon: 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦',
        levels: {
            root: 'Family',
            phase: 'Generation',
            item: 'Person',
            subtask: 'Event'
        },
        phaseSubtitles: ['Self/Siblings', 'Parents', 'Grandparents', 'Great-Grandparents', 'Great-Great-Grandparents', 'Children', 'Grandchildren', 'Great-Grandchildren'],
        types: [
            { value: 'paternal', label: 'Paternal Line' },
            { value: 'maternal', label: 'Maternal Line' },
            { value: 'spouse', label: 'Spouse' },
            { value: 'biological', label: 'Biological' },
            { value: 'adopted', label: 'Adopted' },
            { value: 'step', label: 'Step-Family' },
            { value: 'foster', label: 'Foster' },
            { value: 'half', label: 'Half-Sibling' }
        ],
        description: 'Build and document your family genealogy',
        fields: {
            fullName: { label: 'Full Name', type: 'text', placeholder: 'First Middle Last...', helpText: 'ðŸ‘¤ Complete name including middle names' },
            maidenName: { label: 'Maiden Name', type: 'text', placeholder: 'Birth surname if different...', helpText: 'ðŸ’ Birth surname (if changed after marriage)' },
            gender: { label: 'Gender', type: 'select', options: ['Male', 'Female', 'Other', 'Unknown'], helpText: 'âš§ Gender identity' },
            birthDate: { label: 'Birth Date', type: 'date', helpText: 'ðŸŽ‚ Date of birth' },
            birthPlace: { label: 'Birth Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'ðŸ“ Place of birth (city, state, country)' },
            livingStatus: { label: 'Living Status', type: 'select', options: ['Living', 'Deceased', 'Unknown'], helpText: 'ðŸ’š Current living status' },
            deathDate: { label: 'Death Date', type: 'date', helpText: 'ðŸ•Šï¸ Date of death (if deceased)' },
            deathPlace: { label: 'Death Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'ðŸ“ Place of death (if deceased)' },
            marriageDate: { label: 'Marriage Date', type: 'date', helpText: 'ðŸ’’ Date of marriage' },
            marriagePlace: { label: 'Marriage Place', type: 'text', placeholder: 'City, State, Country...', helpText: 'ðŸ“ Place of marriage ceremony' },
            spouseName: { label: 'Spouse Name', type: 'text', placeholder: 'Name of spouse...', helpText: 'ðŸ’‘ Current or former spouse' },
            occupation: { label: 'Occupation', type: 'text', placeholder: 'Profession or career...', helpText: 'ðŸ’¼ Primary occupation or career' },
            photoURL: { label: 'Photo URL', type: 'text', placeholder: 'https://...', helpText: 'ðŸ“· Link to portrait or photo' },
            dnaInfo: { label: 'DNA/Genetic Info', type: 'textarea', placeholder: 'Haplogroup, DNA matches, test results...', helpText: 'ðŸ§¬ DNA test results, haplogroups, genetic markers' },
            sources: { label: 'Sources/Citations', type: 'textarea', placeholder: 'Documents, certificates, records...', helpText: 'ðŸ“„ Birth certificates, census records, documents' },
            relationshipType: { label: 'Relationship Type', type: 'select', options: ['Biological', 'Adopted', 'Step', 'Foster', 'Half-Sibling', 'Unknown'], helpText: 'ðŸ”— Type of family relationship' },
            includeDependencies: true,
            includeTracking: false
        }
    },
    dialogue: {
        name: 'Dialogue & Rhetoric',
        icon: 'ðŸ’¬',
        levels: {
            root: 'Conversation',
            phase: 'Speaker',
            item: 'Statement',
            subtask: 'Point'
        },
        phaseSubtitles: ['Speaker A', 'Speaker B', 'Speaker C', 'Moderator'],
        types: [
            { value: 'logical', label: 'ðŸ§  Logical Argument' },
            { value: 'emotional', label: 'â¤ï¸ Emotional Appeal (Pathos)' },
            { value: 'ethical', label: 'âš–ï¸ Ethical Appeal (Ethos)' },
            { value: 'statistical', label: 'ðŸ“Š Statistical Evidence' },
            { value: 'anecdotal', label: 'ðŸ“– Anecdotal Evidence' },
            { value: 'rhetorical-question', label: 'â“ Rhetorical Question' },
            { value: 'counterargument', label: 'ðŸ”„ Counterargument' },
            { value: 'deflection', label: 'â†©ï¸ Deflection/Dodge' },
            { value: 'concession', label: 'ðŸ¤ Concession/Agreement' }
        ],
        description: 'Analyze conversations, debates, and rhetoric to uncover hidden logic, fallacies, and motivations',
        fields: {
            speaker: {
                label: 'Speaker/Character',
                type: 'text',
                placeholder: 'e.g., Senator Jane Smith, John (protagonist), Anonymous commenter...',
                helpText: 'ðŸ‘¤ Who is making this statement? Include role, title, or context if known'
            },
            verbatimQuote: {
                label: 'Verbatim Quote',
                type: 'textarea',
                placeholder: 'Copy/paste the exact words spoken or written...',
                helpText: 'ðŸ’¬ The actual statement, word-for-word. Essential for accurate analysis of rhetoric and tone'
            },
            rhetoricalDevice: {
                label: 'Rhetorical Device Used',
                type: 'select',
                options: ['Logos (Logic)', 'Pathos (Emotion)', 'Ethos (Credibility)', 'Kairos (Timing)', 'Metaphor', 'Analogy', 'Repetition', 'Hyperbole', 'Irony', 'Appeal to Authority', 'None'],
                helpText: 'ðŸŽ­ Primary rhetorical technique used to persuade or communicate. Identify the dominant device'
            },
            logicalStructure: {
                label: 'Logical Structure',
                type: 'textarea',
                placeholder: 'Premise 1: All experts agree...\nPremise 2: Dr. Chen is an expert...\nConclusion: Therefore, Dr. Chen\'s view is valid',
                helpText: 'ðŸ§© Break down the argument into premises and conclusion. How does the speaker construct their logic?'
            },
            fallaciesPresent: {
                label: 'Fallacies Present',
                type: 'textarea',
                placeholder: 'Ad hominem: Attacks opponent\'s character instead of argument\nStraw man: Misrepresents opponent\'s position...',
                helpText: 'âš ï¸ Identify any logical fallacies (ad hominem, straw man, slippery slope, false dichotomy, etc.) and explain how they appear'
            },
            hiddenMotivation: {
                label: 'Hidden Motivation/Subtext',
                type: 'textarea',
                placeholder: 'Surface: Arguing for policy change\nHidden: Positioning for re-election, deflecting from scandal, protecting financial interests...',
                helpText: 'ðŸ” What unstated goals or motivations might underlie this statement? Consider political, financial, or personal incentives'
            },
            emotionalTone: {
                label: 'Emotional Tone',
                type: 'select',
                options: ['Calm/Neutral', 'Passionate', 'Angry', 'Defensive', 'Condescending', 'Empathetic', 'Dismissive', 'Fearful', 'Confident', 'Sarcastic'],
                helpText: 'ðŸŽ­ The emotional delivery and affect. How does tone enhance or undermine the message?'
            },
            counterargument: {
                label: 'Strongest Counterargument',
                type: 'textarea',
                placeholder: 'The strongest rebuttal would be: "While the speaker claims X, evidence shows Y because..."',
                helpText: 'ðŸ”„ What is the most effective counter to this statement? Build the opposing case using logic and evidence'
            },
            evidenceQuality: {
                label: 'Evidence Quality',
                type: 'select',
                options: ['Strong (Peer-reviewed, verified)', 'Moderate (Credible sources)', 'Weak (Anecdotal, unverified)', 'None (Opinion only)', 'Misleading (Cherry-picked data)'],
                helpText: 'ðŸ“Š Assess the strength and credibility of any evidence or data cited. Is it rigorous or rhetorical?'
            },
            effectivenessRating: {
                label: 'Persuasiveness Rating',
                type: 'number',
                min: 1,
                max: 10,
                step: 1,
                placeholder: '7',
                helpText: 'ðŸŽ¯ Rate 1-10: How persuasive is this statement to the target audience? (1=unconvincing, 10=highly compelling)'
            },
            includeDependencies: true,
            includeTracking: false
        }
    },
    filesystem: {
        name: 'File System',
        icon: 'ðŸ’¾',
        isFlexibleDepth: true,
        levels: {
            root: 'Drive',
            phase: 'Folder',
            item: 'File/Folder',
            subtask: 'File'
        },
        phaseSubtitles: ['Documents', 'Downloads', 'Desktop', 'Pictures', 'Videos', 'Projects'],
        types: [
            // Folder types
            { value: 'folder', label: 'ðŸ“ Folder' },
            { value: 'folder-shared', label: 'ðŸ“‚ Shared Folder' },
            { value: 'folder-cloud', label: 'â˜ï¸ Cloud Folder' },

            // Document types
            { value: 'pdf', label: 'ðŸ“• PDF' },
            { value: 'word', label: 'ðŸ“˜ Word Doc' },
            { value: 'excel', label: 'ðŸ“— Spreadsheet' },
            { value: 'powerpoint', label: 'ðŸ“™ Presentation' },
            { value: 'text', label: 'ðŸ“ Text File' },
            { value: 'document', label: 'ðŸ“„ Document' },

            // Media types
            { value: 'image', label: 'ðŸ–¼ï¸ Image' },
            { value: 'video', label: 'ðŸŽ¬ Video' },
            { value: 'audio', label: 'ðŸŽµ Audio' },

            // Code types
            { value: 'code', label: 'ðŸ’» Code' },
            { value: 'html', label: 'ðŸŒ HTML' },
            { value: 'css', label: 'ðŸŽ¨ CSS' },
            { value: 'javascript', label: 'âš¡ JavaScript' },
            { value: 'python', label: 'ðŸ Python' },

            // Archive types
            { value: 'archive', label: 'ðŸ“¦ Archive' },
            { value: 'zip', label: 'ðŸ—œï¸ ZIP' },

            // Other
            { value: 'executable', label: 'âš™ï¸ Executable' },
            { value: 'database', label: 'ðŸ—„ï¸ Database' },
            { value: 'unknown', label: 'â“ Unknown' }
        ],
        description: 'Organize files and folders from local drives, Google Drive, and OneDrive',
        sortOptions: [
            { value: 'name-az', label: 'ðŸ”¤ Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ðŸ”¤ Name (Z-A)', field: 'name', order: 'desc', type: 'text' },
            { value: 'size-large', label: 'ðŸ“Š Size (Largest First)', field: 'fileSize', order: 'desc', type: 'number' },
            { value: 'size-small', label: 'ðŸ“Š Size (Smallest First)', field: 'fileSize', order: 'asc', type: 'number' },
            { value: 'modified-newest', label: 'ðŸ•’ Modified (Newest First)', field: 'dateModified', order: 'desc', type: 'date' },
            { value: 'modified-oldest', label: 'ðŸ•’ Modified (Oldest First)', field: 'dateModified', order: 'asc', type: 'date' },
            { value: 'created-newest', label: 'ðŸ“… Created (Newest First)', field: 'dateCreated', order: 'desc', type: 'date' },
            { value: 'created-oldest', label: 'ðŸ“… Created (Oldest First)', field: 'dateCreated', order: 'asc', type: 'date' },
            { value: 'type-folders-first', label: 'ðŸ“ Type (Folders First)', field: 'isFolder', order: 'desc', type: 'boolean' },
            { value: 'type-files-first', label: 'ðŸ“„ Type (Files First)', field: 'isFolder', order: 'asc', type: 'boolean' },
            { value: 'extension-az', label: 'ðŸ·ï¸ Extension (A-Z)', field: 'fileExtension', order: 'asc', type: 'text' },
            { value: 'extension-za', label: 'ðŸ·ï¸ Extension (Z-A)', field: 'fileExtension', order: 'desc', type: 'text' },
            { value: 'owner-az', label: 'ðŸ‘¤ Owner (A-Z)', field: 'fileOwner', order: 'asc', type: 'text' },
            { value: 'owner-za', label: 'ðŸ‘¤ Owner (Z-A)', field: 'fileOwner', order: 'desc', type: 'text' }
        ],
        fields: {
            fileSize: {
                label: 'File Size (bytes)',
                type: 'number',
                min: 0,
                step: 1,
                placeholder: '2500000',
                helpText: 'ðŸ“Š Size in bytes (will be formatted as KB/MB/GB)'
            },
            fileExtension: {
                label: 'File Extension',
                type: 'text',
                placeholder: '.pdf, .docx, .jpg...',
                helpText: 'ðŸ·ï¸ File type extension (e.g., .pdf, .docx, .mp4)'
            },
            filePath: {
                label: 'Full Path',
                type: 'text',
                placeholder: 'C:\\Users\\Documents\\file.pdf',
                helpText: 'ðŸ“‚ Complete file path'
            },
            dateModified: {
                label: 'Date Modified',
                type: 'datetime-local',
                helpText: 'ðŸ•’ Last modification date and time'
            },
            dateCreated: {
                label: 'Date Created',
                type: 'datetime-local',
                helpText: 'ðŸ“… Creation date and time'
            },
            fileOwner: {
                label: 'Owner',
                type: 'text',
                placeholder: 'john.doe@company.com',
                helpText: 'ðŸ‘¤ File owner (for cloud files)'
            },
            sharedWith: {
                label: 'Shared With',
                type: 'textarea',
                placeholder: 'user1@email.com, user2@email.com...',
                helpText: 'ðŸ‘¥ Users with access (for cloud files)'
            },
            permissions: {
                label: 'Permissions',
                type: 'select',
                options: ['Read Only', 'Read/Write', 'Owner', 'Viewer', 'Editor', 'Commenter'],
                helpText: 'ðŸ”’ Access permissions'
            },
            driveType: {
                label: 'Drive Type',
                type: 'select',
                options: ['Local Drive', 'Google Drive', 'OneDrive', 'Dropbox', 'Network Drive', 'External Drive'],
                helpText: 'ðŸ’¾ Storage location type'
            },
            mimeType: {
                label: 'MIME Type',
                type: 'text',
                placeholder: 'application/pdf, image/jpeg...',
                helpText: 'ðŸ“‹ File MIME type (for web/cloud files)'
            },
            tags: {
                label: 'Tags',
                type: 'text',
                placeholder: 'work, important, archive...',
                helpText: 'ðŸ·ï¸ Custom tags for organization'
            },
            fileUrl: {
                label: 'Cloud URL',
                type: 'text',
                placeholder: 'https://drive.google.com/...',
                helpText: 'ðŸ”— Direct link to cloud file'
            },
            isFolder: {
                label: 'Is Folder',
                type: 'checkbox',
                helpText: 'ðŸ“ Check if this is a folder (not a file)'
            },
            includeDependencies: false,
            includeTracking: false
        }
    },
    gmail: {
        name: 'Email Workflow',
        icon: 'ðŸ“§',
        levels: {
            root: 'Inbox/Campaign',
            phase: 'Label/Stage',
            item: 'Thread',
            subtask: 'Message'
        },
        phaseSubtitles: ['Inbox', 'Sent', 'Important', 'Archive'],
        types: [
            { value: 'cold-outreach', label: 'â„ï¸ Cold Outreach' },
            { value: 'newsletter', label: 'ðŸ“° Newsletter' },
            { value: 'response', label: 'â†©ï¸ Response' },
            { value: 'follow-up', label: 'âž¡ï¸ Follow-up' },
            { value: 'internal', label: 'ðŸ¢ Internal Update' },
            { value: 'transactional', label: 'ðŸ§¾ Transactional' }
        ],
        description: 'Import and analyze Gmail threads with full conversation context',
        sortOptions: [
            { value: 'date-newest', label: 'ðŸ“… Date (Newest First)', field: 'sendDate', order: 'desc', type: 'date' },
            { value: 'date-oldest', label: 'ðŸ“… Date (Oldest First)', field: 'sendDate', order: 'asc', type: 'date' },
            { value: 'subject-az', label: 'ðŸ”¤ Subject (A-Z)', field: 'subjectLine', order: 'asc', type: 'text' },
            { value: 'subject-za', label: 'ðŸ”¤ Subject (Z-A)', field: 'subjectLine', order: 'desc', type: 'text' },
            { value: 'messages-most', label: 'ðŸ’¬ Messages (Most First)', field: 'messageCount', order: 'desc', type: 'number' },
            { value: 'messages-least', label: 'ðŸ’¬ Messages (Least First)', field: 'messageCount', order: 'asc', type: 'number' }
        ],
        fields: {
            recipientEmail: {
                label: 'To (Email)',
                type: 'text',
                placeholder: 'client@company.com',
                helpText: 'ðŸ‘¤ Primary recipient address'
            },
            ccEmail: {
                label: 'CC',
                type: 'text',
                placeholder: 'manager@company.com',
                helpText: 'ðŸ‘¥ Carbon copy recipients'
            },
            subjectLine: {
                label: 'Subject Line',
                type: 'text',
                placeholder: 'Meeting Request: Q4 Planning',
                helpText: 'ðŸ“ The email subject line'
            },
            emailBody: {
                label: 'Email Body',
                type: 'textarea',
                placeholder: 'Hi [Name],\n\nWriting to follow up on...',
                helpText: 'âœï¸ The main content of the email'
            },
            sendDate: {
                label: 'Date Sent',
                type: 'date',
                helpText: 'ðŸ“… When this email was sent/received'
            },
            status: {
                label: 'Status',
                type: 'select',
                options: ['Draft', 'Ready', 'Sent', 'Replied', 'Archived'],
                helpText: 'ðŸ“¬ Email status'
            },
            threadId: {
                label: 'Thread ID',
                type: 'text',
                placeholder: 'Gmail thread ID',
                helpText: 'ðŸ”— Gmail thread identifier'
            },
            messageCount: {
                label: 'Message Count',
                type: 'number',
                min: 1,
                helpText: 'ðŸ’¬ Number of messages in this thread'
            },
            sender: {
                label: 'Sender',
                type: 'text',
                placeholder: 'john@company.com',
                helpText: 'ðŸ‘¤ Email sender'
            },
            labels: {
                label: 'Gmail Labels',
                type: 'text',
                placeholder: 'INBOX, IMPORTANT, SENT',
                helpText: 'ðŸ·ï¸ Gmail labels/categories'
            },
            includeDependencies: true,
            includeTracking: true
        }
    },
    capex: {
        name: 'CAPEX / Angel Pitch',
        icon: 'ðŸ’°',
        levels: {
            root: 'Project',
            phase: 'Funding Phase',
            item: 'Investment',
            subtask: 'Deliverable'
        },
        phaseSubtitles: ['Seed', 'Series A', 'Series B'],
        types: [
            { value: 'equipment', label: 'Equipment' },
            { value: 'infrastructure', label: 'Infrastructure' },
            { value: 'validation', label: 'Validation' },
            { value: 'development', label: 'Development' },
            { value: 'milestone', label: 'Milestone' },
            { value: 'risk-mitigation', label: 'Risk Mitigation' },
            { value: 'working-capital', label: 'Working Capital' },
            { value: 'personnel', label: 'Personnel' }
        ],
        description: 'Investor-ready capital expenditure structure for fundraising',
        sortOptions: [
            { value: 'cost-high', label: 'ðŸ’° Cost (Highest First)', field: 'cost', order: 'desc', type: 'number' },
            { value: 'cost-low', label: 'ðŸ’° Cost (Lowest First)', field: 'cost', order: 'asc', type: 'number' },
            { value: 'name-az', label: 'ðŸ”¤ Name (A-Z)', field: 'name', order: 'asc', type: 'text' },
            { value: 'name-za', label: 'ðŸ”¤ Name (Z-A)', field: 'name', order: 'desc', type: 'text' }
        ],
        fields: {
            cost: { label: 'Cost ($)', type: 'number', step: 1000, helpText: 'ðŸ’° Capital expenditure for this item' },
            risk: { label: 'Key Risk', type: 'text', placeholder: 'Primary risk associated with this item...', helpText: 'âš ï¸ Main risk investors should know about' },
            mitigation: { label: 'Mitigation', type: 'text', placeholder: 'How we address this risk...', helpText: 'ðŸ›¡ï¸ Specific strategy to mitigate the risk' },
            valuationImpact: { label: 'Valuation Impact', type: 'text', placeholder: 'e.g., Enables 2x ARR, De-risks Series A...', helpText: 'ðŸ“ˆ How this investment affects company valuation' },
            leadTime: { label: 'Lead Time', type: 'text', placeholder: 'e.g., 12 weeks, 6 months...', helpText: 'â±ï¸ Time to complete or procure' },
            includeDependencies: true,
            includeTracking: true,
            trackingFor: ['subtask']
        }
    },
    freespeech: {
        name: 'Free Speech',
        icon: 'ðŸŽ™ï¸',
        levels: {
            root: 'Session',
            phase: 'Theme',
            item: 'Pattern',
            subtask: 'Evidence'
        },
        phaseSubtitles: ['Surface Themes', 'Hidden Patterns', 'Contradictions', 'Silences', 'Recurring Structures'],
        types: [
            { value: 'repetition', label: 'ðŸ” Repetition (mentioned multiple times)' },
            { value: 'emotional', label: 'â¤ï¸ Emotional Weight (intensity markers)' },
            { value: 'contradiction', label: 'âš¡ Contradiction (opposing statements)' },
            { value: 'avoidance', label: 'ðŸ•³ï¸ Avoidance (logical gaps)' },
            { value: 'implicit', label: 'ðŸ’­ Implicit Belief (unstated assumption)' },
            { value: 'entity', label: 'ðŸ‘¤ Named Entity (person/thing mentioned)' },
            { value: 'structure', label: 'ðŸ“ Sentence Structure (grammar pattern)' }
        ],
        description: 'Stream-of-consciousness voice capture with psychological pattern analysis',
        sortOptions: [
            { value: 'frequency-high', label: 'ðŸ”¢ Frequency (Most First)', field: 'frequency', order: 'desc', type: 'number' },
            { value: 'frequency-low', label: 'ðŸ”¢ Frequency (Least First)', field: 'frequency', order: 'asc', type: 'number' },
            { value: 'emotional-high', label: 'ðŸ’“ Emotional Intensity (Highest)', field: 'emotionalIntensity', order: 'desc', type: 'text' },
            { value: 'emotional-low', label: 'ðŸ’“ Emotional Intensity (Lowest)', field: 'emotionalIntensity', order: 'asc', type: 'text' }
        ],
        fields: {
            frequency: {
                label: 'Frequency',
                type: 'number',
                min: 1,
                step: 1,
                helpText: 'ðŸ”¢ Times this pattern appeared in speech'
            },
            emotionalIntensity: {
                label: 'Emotional Intensity',
                type: 'select',
                options: ['Low', 'Medium', 'High', 'Peak'],
                helpText: 'ðŸ’“ Detected emotional weight of this pattern'
            },
            quotedText: {
                label: 'Quoted Text',
                type: 'textarea',
                placeholder: 'Exact words from transcript...',
                helpText: 'ðŸ’¬ Verbatim speech that evidences this pattern'
            },
            insight: {
                label: 'AI Insight',
                type: 'textarea',
                placeholder: 'What this pattern reveals about the speaker...',
                helpText: 'ðŸ”® Psychological interpretation of what this pattern suggests'
            },
            includeDependencies: false,
            includeTracking: false
        }
    },
    lifetree: {
        name: 'LifeTree',
        icon: 'ðŸŒ³',
        levels: {
            root: 'Life',
            phase: 'Decade',
            item: 'Event',
            subtask: 'Detail'
        },
        phaseSubtitles: [], // Auto-generated from birth year
        types: [
            { value: 'birth', label: 'Birth' },
            { value: 'family', label: 'Family' },
            { value: 'education', label: 'Education' },
            { value: 'career', label: 'Career' },
            { value: 'relationship', label: 'Relationship' },
            { value: 'residence', label: 'Residence/Move' },
            { value: 'health', label: 'Health' },
            { value: 'milestone', label: 'Milestone' },
            { value: 'loss', label: 'Loss' },
            { value: 'travel', label: 'Travel' },
            { value: 'achievement', label: 'Achievement' },
            { value: 'memory', label: 'Memory/Story' }
        ],
        description: 'Biographical timeline for a life story',
        sortOptions: [
            { value: 'date-oldest', label: 'ðŸ“… Date (Oldest First)', field: 'eventDate', order: 'asc', type: 'date' },
            { value: 'date-newest', label: 'ðŸ“… Date (Newest First)', field: 'eventDate', order: 'desc', type: 'date' },
            { value: 'age-youngest', label: 'ðŸŽ‚ Age (Youngest First)', field: 'age', order: 'asc', type: 'number' },
            { value: 'age-oldest', label: 'ðŸŽ‚ Age (Oldest First)', field: 'age', order: 'desc', type: 'number' },
            { value: 'emotion', label: 'ðŸ’­ By Emotion', field: 'emotion', order: 'asc', type: 'text' },
            { value: 'type', label: 'ðŸ“ By Type', field: 'itemType', order: 'asc', type: 'text' }
        ],
        fields: {
            eventDate: {
                label: 'When',
                type: 'text',
                placeholder: 'March 1965, Summer 1952, age 7...',
                helpText: 'ðŸ“… Date or approximate time (AI parses natural language)'
            },
            age: {
                label: 'Age',
                type: 'number',
                computed: true,
                helpText: 'ðŸŽ‚ Auto-calculated from birth year'
            },
            location: {
                label: 'Where',
                type: 'text',
                placeholder: 'Brooklyn, NY...',
                helpText: 'ðŸ“ Location of this event'
            },
            people: {
                label: 'Who',
                type: 'text',
                placeholder: 'Dad, Aunt Rose, friend Betty...',
                helpText: 'ðŸ‘¥ People involved in this event'
            },
            emotion: {
                label: 'Feeling',
                type: 'select',
                options: ['Joyful', 'Proud', 'Bittersweet', 'Difficult', 'Routine', 'Milestone'],
                helpText: 'ðŸ’­ Emotional tone of this memory'
            },
            source: {
                label: 'Remembered by',
                type: 'text',
                placeholder: 'Mom, sister, family letter...',
                helpText: 'ðŸ—£ï¸ Who contributed this memory'
            },
            confidence: {
                label: 'Certainty',
                type: 'select',
                options: ['Exact', 'Approximate', 'Family legend'],
                helpText: 'ðŸŽ¯ How certain is this date/detail?'
            },
            historicalContext: {
                label: 'Historical Context',
                type: 'textarea',
                placeholder: 'AI-generated: what was happening in the world...',
                computed: true,
                helpText: 'ðŸŒ World events at this time'
            },
            locationContext: {
                label: 'Location Context',
                type: 'textarea',
                placeholder: 'AI-generated: what this place was like...',
                computed: true,
                helpText: 'ðŸ˜ï¸ What this location was like then'
            },
            mediaUrl: {
                label: 'Photo/Document',
                type: 'text',
                placeholder: 'URL or file path...',
                helpText: 'ðŸ“· Attach image or document'
            },
            includeDependencies: false,
            includeTracking: false
        },
        // LifeTree-specific metadata
        requiresBirthYear: true,
        supportsDeathYear: true,
        autoGenerateDecades: true
    },
    custom: {
        name: 'Custom Names',
        icon: 'âœï¸',
        levels: {
            root: 'Level 0',
            phase: 'Level 1',
            item: 'Level 2',
            subtask: 'Level 3'
        },
        description: 'Define your own names for all four levels',
        customizable: true
    }
};

// =============================================================================
// MIGRATION & SCHEMA MANAGEMENT (Cognitive Citadel Foundation)
// =============================================================================

const SCHEMA_VERSION = 1;

/**
 * Recursively normalizes node structure and adds defense fields
 */
function normalizeNode(node, source = 'legacy') {
    if (!node) return;
    
    // 1. Provenance Stamping
    if (!node.provenance) {
        node.provenance = {
            source: source,
            timestamp: new Date().toISOString(),
            modelId: null
        };
    }

    // 2. Phenomenology (The "Residue" - node-specific reflections)
    if (!node.phenomenology) {
        node.phenomenology = [];
    }

    // 3. Metrics (Attention Economics)
    if (!node.metrics) {
        node.metrics = {
            editCount: 0,
            focusTime: 0,
            lastModified: Date.now()
        };
    }

    // Recurse through all child types
    if (node.children) node.children.forEach(child => normalizeNode(child, source));
    if (node.items) node.items.forEach(child => normalizeNode(child, source));
    if (node.subItems) node.subItems.forEach(child => normalizeNode(child, source));
}

/**
 * Migrates tree to current SCHEMA_VERSION
 * Called on every file load to ensure backward compatibility
 */
function migrateTree(tree) {
    const currentVersion = tree.schemaVersion || 0;

    if (currentVersion < 1) {
        console.log(`ðŸ›¡ï¸ Migrating tree from v${currentVersion} to v1 (Cognitive Citadel Foundation)`);
        
        // Initialize Hyperedges if missing
        if (!tree.hyperedges) tree.hyperedges = [];
        
        // Initialize Snapshot references (for future IndexedDB storage)
        if (!tree.snapshotRefs) tree.snapshotRefs = [];

        // Normalize all nodes with legacy source
        normalizeNode(tree, 'legacy');

        tree.schemaVersion = 1;
        console.log('âœ… Migration to v1 complete');
    }

    // Future migrations stack here:
    // if (currentVersion < 2) { ... }

    return tree;
}

// ============================================================================
// FILE SYSTEM ICON MAPPING
// ============================================================================

const FILE_ICON_MAP = {
    // Documents
    '.pdf': { icon: 'ðŸ“•', type: 'pdf' },
    '.doc': { icon: 'ðŸ“˜', type: 'word' },
    '.docx': { icon: 'ðŸ“˜', type: 'word' },
    '.odt': { icon: 'ðŸ“˜', type: 'document' },

    // Spreadsheets
    '.xls': { icon: 'ðŸ“—', type: 'excel' },
    '.xlsx': { icon: 'ðŸ“—', type: 'excel' },
    '.csv': { icon: 'ðŸ“Š', type: 'excel' },
    '.ods': { icon: 'ðŸ“Š', type: 'excel' },

    // Presentations
    '.ppt': { icon: 'ðŸ“™', type: 'powerpoint' },
    '.pptx': { icon: 'ðŸ“™', type: 'powerpoint' },
    '.key': { icon: 'ðŸ“™', type: 'powerpoint' },
    '.odp': { icon: 'ðŸ“™', type: 'powerpoint' },

    // Text
    '.txt': { icon: 'ðŸ“', type: 'text' },
    '.md': { icon: 'ðŸ“', type: 'text' },
    '.rtf': { icon: 'ðŸ“', type: 'text' },

    // Images
    '.jpg': { icon: 'ðŸ–¼ï¸', type: 'image' },
    '.jpeg': { icon: 'ðŸ–¼ï¸', type: 'image' },
    '.png': { icon: 'ðŸ–¼ï¸', type: 'image' },
    '.gif': { icon: 'ðŸŽ¨', type: 'image' },
    '.bmp': { icon: 'ðŸ–¼ï¸', type: 'image' },
    '.svg': { icon: 'ðŸŽ¨', type: 'image' },
    '.webp': { icon: 'ðŸ–¼ï¸', type: 'image' },

    // Videos
    '.mp4': { icon: 'ðŸŽ¬', type: 'video' },
    '.avi': { icon: 'ðŸŽ¬', type: 'video' },
    '.mov': { icon: 'ðŸŽ¬', type: 'video' },
    '.mkv': { icon: 'ðŸŽ¬', type: 'video' },
    '.webm': { icon: 'ðŸŽ¬', type: 'video' },
    '.flv': { icon: 'ðŸŽ¬', type: 'video' },

    // Audio
    '.mp3': { icon: 'ðŸŽµ', type: 'audio' },
    '.wav': { icon: 'ðŸŽµ', type: 'audio' },
    '.flac': { icon: 'ðŸŽµ', type: 'audio' },
    '.aac': { icon: 'ðŸŽµ', type: 'audio' },
    '.ogg': { icon: 'ðŸŽµ', type: 'audio' },
    '.m4a': { icon: 'ðŸŽµ', type: 'audio' },

    // Code
    '.html': { icon: 'ðŸŒ', type: 'html' },
    '.htm': { icon: 'ðŸŒ', type: 'html' },
    '.css': { icon: 'ðŸŽ¨', type: 'css' },
    '.js': { icon: 'âš¡', type: 'javascript' },
    '.jsx': { icon: 'âš¡', type: 'javascript' },
    '.ts': { icon: 'ðŸ’™', type: 'javascript' },
    '.tsx': { icon: 'ðŸ’™', type: 'javascript' },
    '.py': { icon: 'ðŸ', type: 'python' },
    '.java': { icon: 'â˜•', type: 'code' },
    '.cpp': { icon: 'âš™ï¸', type: 'code' },
    '.c': { icon: 'âš™ï¸', type: 'code' },
    '.php': { icon: 'ðŸ˜', type: 'code' },
    '.rb': { icon: 'ðŸ’Ž', type: 'code' },
    '.go': { icon: 'ðŸ”µ', type: 'code' },
    '.rs': { icon: 'ðŸ¦€', type: 'code' },
    '.json': { icon: 'ðŸ“‹', type: 'code' },
    '.xml': { icon: 'ðŸ“‹', type: 'code' },
    '.yaml': { icon: 'ðŸ“‹', type: 'code' },
    '.yml': { icon: 'ðŸ“‹', type: 'code' },

    // Archives
    '.zip': { icon: 'ðŸ—œï¸', type: 'zip' },
    '.rar': { icon: 'ðŸ“¦', type: 'archive' },
    '.7z': { icon: 'ðŸ“¦', type: 'archive' },
    '.tar': { icon: 'ðŸ“¦', type: 'archive' },
    '.gz': { icon: 'ðŸ“¦', type: 'archive' },

    // Executables
    '.exe': { icon: 'âš™ï¸', type: 'executable' },
    '.msi': { icon: 'âš™ï¸', type: 'executable' },
    '.app': { icon: 'âš™ï¸', type: 'executable' },
    '.dmg': { icon: 'ðŸ’¿', type: 'executable' },
    '.deb': { icon: 'ðŸ“¦', type: 'executable' },

    // Database
    '.db': { icon: 'ðŸ—„ï¸', type: 'database' },
    '.sqlite': { icon: 'ðŸ—„ï¸', type: 'database' },
    '.sql': { icon: 'ðŸ—„ï¸', type: 'database' },

    // Default
    'default': { icon: 'â“', type: 'unknown' }
};

const FOLDER_ICON_MAP = {
    'default': 'ðŸ“',
    'open': 'ðŸ“‚',
    'shared': 'ðŸ‘¥',
    'cloud': 'â˜ï¸',
    'system': 'âš™ï¸',
    'user': 'ðŸ‘¤',
    'downloads': 'ðŸ“¥',
    'documents': 'ðŸ“„',
    'pictures': 'ðŸ–¼ï¸',
    'videos': 'ðŸŽ¬',
    'music': 'ðŸŽµ',
    'desktop': 'ðŸ–¥ï¸',
    'trash': 'ðŸ—‘ï¸'
};

function getFileIcon(fileName, isFolder = false) {
    if (isFolder) {
        // Check for special folder names
        const folderNameLower = fileName.toLowerCase();
        if (folderNameLower.includes('download')) return FOLDER_ICON_MAP.downloads;
        if (folderNameLower.includes('document')) return FOLDER_ICON_MAP.documents;
        if (folderNameLower.includes('picture') || folderNameLower.includes('photo')) return FOLDER_ICON_MAP.pictures;
        if (folderNameLower.includes('video') || folderNameLower.includes('movie')) return FOLDER_ICON_MAP.videos;
        if (folderNameLower.includes('music') || folderNameLower.includes('audio')) return FOLDER_ICON_MAP.music;
        if (folderNameLower.includes('desktop')) return FOLDER_ICON_MAP.desktop;
        if (folderNameLower.includes('trash') || folderNameLower.includes('recycle')) return FOLDER_ICON_MAP.trash;
        if (folderNameLower.includes('user')) return FOLDER_ICON_MAP.user;
        return FOLDER_ICON_MAP.default;
    }

    // Extract extension
    const ext = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
    const mapping = FILE_ICON_MAP[ext] || FILE_ICON_MAP.default;
    return mapping.icon;
}

function getFileType(fileName, isFolder = false) {
    if (isFolder) return 'folder';
    const ext = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
    const mapping = FILE_ICON_MAP[ext] || FILE_ICON_MAP.default;
    return mapping.type;
}

// ============================================================================
// PATTERN STATE
// ============================================================================

let currentPattern = 'generic';
let customPatternNames = null;
let currentSortConfig = null; // Stores current sort configuration

// ============================================================================
// PATTERN FUNCTIONS
// ============================================================================

// Helper: Get pattern key from either string or object format
function getPatternKey(pattern) {
    if (typeof pattern === 'string') {
        return pattern;
    } else if (pattern && pattern.key) {
        return pattern.key;
    }
    return null;
}

function getPatternLabels() {
    console.log('getPatternLabels called, currentPattern:', currentPattern);
    if (currentPattern === 'custom' && customPatternNames) {
        console.log('Returning custom labels:', customPatternNames);
        return customPatternNames;
    }
    const labels = PATTERNS[currentPattern].levels;
    console.log('Returning pattern labels:', labels);
    return labels;
}

function renameNodesForPattern(node, labels) {
    if (!node) return;

    // Collect all possible terms from all patterns for replacement
    const allRootTerms = ['Project', 'Pipeline', 'Thesis', 'Product', 'Book', 'Event', 'Program', 'Strategy', 'Course', 'Film', 'Treatise', 'Family'];
    const allPhaseTerms = ['Phase', 'Quarter', 'Chapter', 'Part', 'Stage', 'Pillar', 'Unit', 'Generation', 'Act', 'Sequence'];
    const allItemTerms = ['Item', 'Deal', 'Section', 'Feature', 'Chapter', 'Activity', 'Workout', 'Initiative', 'Lesson', 'Scene', 'Argument', 'Person', 'Beat'];
    const allSubtaskTerms = ['Task', 'Sub-task', 'Action', 'Point', 'Story', 'Scene', 'Exercise', 'Shot', 'Premise', 'Event', 'Frame', 'Remix'];

    // Rename based on node type - replace ANY pattern term with the new one
    if (node.type === 'root') {
        // Try to replace any root term from any pattern
        for (const term of allRootTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.root);
        }
    } else if (node.type === 'phase') {
        // Try to replace any phase term from any pattern
        for (const term of allPhaseTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.phase);
        }
        // Update phase subtitle based on pattern
        if (PATTERNS[currentPattern].phaseSubtitles && node.phase !== undefined) {
            const phaseIndex = parseInt(node.phase);
            if (!isNaN(phaseIndex) && phaseIndex < PATTERNS[currentPattern].phaseSubtitles.length) {
                node.subtitle = PATTERNS[currentPattern].phaseSubtitles[phaseIndex];
            }
        }
    } else if (node.type === 'item') {
        // Try to replace any item term from any pattern
        for (const term of allItemTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.item);
        }
    } else if (node.type === 'subtask') {
        // Try to replace any subtask term from any pattern
        for (const term of allSubtaskTerms) {
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            node.name = node.name.replace(regex, labels.subtask);
        }
    }

    // Recursively process children
    if (node.children) {
        node.children.forEach(child => renameNodesForPattern(child, labels));
    }

    // Process items in phases
    if (node.items) {
        node.items.forEach(item => {
            renameNodesForPattern(item, labels);
            // Process subtasks
            if (item.subItems) {
                item.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
            }
        });
    }

    // Process nested subtasks
    if (node.subItems) {
        node.subItems.forEach(subtask => renameNodesForPattern(subtask, labels));
    }
}

function applyPattern(patternKey) {
    console.log('applyPattern called with:', patternKey);
    currentPattern = patternKey;

    if (patternKey === 'custom') {
        showCustomPatternDialog();
    } else {
        // Store in data
        if (!capexTree.pattern) {
            capexTree.pattern = {};
        }
        capexTree.pattern.key = patternKey;
        capexTree.pattern.labels = PATTERNS[patternKey].levels;
        console.log('Pattern applied:', PATTERNS[patternKey].name);
        console.log('New labels:', PATTERNS[patternKey].levels);

        // Auto-rename existing nodes to match pattern
        renameNodesForPattern(capexTree, PATTERNS[patternKey].levels);
        console.log('Nodes renamed to match pattern');

        // Re-render to apply new labels
        render();

        // Update sort dropdown for new pattern
        updateSortDropdown();

        // Update AI button label to match pattern
        updateAIButtonLabel();

        // BUILD 380: Update biographer indicator for LifeTree
        if (typeof checkBiographerIndicator === 'function') {
            checkBiographerIndicator();
        }
    }
}

// Update AI Analysis button label based on active pattern
function updateAIButtonLabel() {
    const btn = document.getElementById('ai-btn');
    if (!btn) return;

    const span = btn.querySelector('span');
    if (!span) return;

    const labelMap = {
        'generic': { text: 'ðŸ“Š Project Report', tooltip: 'Generate executive summary and risk assessment' },
        'sales': { text: 'ðŸ’° Deal Scorecard', tooltip: 'Analyze deal probability, revenue weight, and blockers' },
        'film': { text: 'ðŸŽ¬ Scene Breakdown', tooltip: 'Analyze shot lists, camera moves, and continuity' },
        'book': { text: 'ðŸ“– Story Arc Review', tooltip: 'Analyze pacing, character beats, and plot structure' },
        'philosophy': { text: 'ðŸ§  Logic Audit', tooltip: 'Check validity of premises and argument strength' },
        'thesis': { text: 'ðŸ“š Academic Review', tooltip: 'Analyze structure, citations, and argumentation' },
        'roadmap': { text: 'ðŸš€ Roadmap Analysis', tooltip: 'Check feature dependencies and timeline coherence' },
        'prompting': { text: 'ðŸ§ª Prompt Test', tooltip: 'Analyze prompt structure against best practices' },
        'gmail': { text: 'ðŸ“§ Thread Summary', tooltip: 'Summarize conversation and identify action items' },
        'event': { text: 'ðŸŽ‰ Event Checklist', tooltip: 'Check logistics, timeline, and vendor coordination' },
        'fitness': { text: 'ðŸ’ª Workout Audit', tooltip: 'Analyze progression, volume, and recovery balance' },
        'strategy': { text: 'ðŸŽ¯ Strategy Review', tooltip: 'Analyze objectives, initiatives, and resource alignment' },
        'course': { text: 'ðŸŽ“ Curriculum Check', tooltip: 'Check learning objectives and scaffolding' },
        'family': { text: 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family Tree Analysis', tooltip: 'Analyze relationships and genealogical connections' },
        'rhetoric': { text: 'ðŸ—£ï¸ Argument Review', tooltip: 'Analyze rhetorical devices and persuasion structure' },
        'filesystem': { text: 'ðŸ§¹ Clean Up Files', tooltip: 'Find duplicates, suggest better names and organization' },
        'default': { text: 'ðŸ“Š Project Report', tooltip: 'Generate analysis report for this tree' }
    };

    const config = labelMap[currentPattern] || labelMap.default;
    span.textContent = config.text;
    btn.title = config.tooltip;
    btn.setAttribute('data-icon', config.text.split(' ')[0]); // Extract emoji for collapsed view

    console.log(`âœ… AI button updated for "${currentPattern}" pattern: ${config.text}`);
}

// Populate sort dropdown based on current pattern
function updateSortDropdown() {
    console.log('ðŸ”„ updateSortDropdown called, currentPattern:', currentPattern);

    const sortSection = document.getElementById('sort-section');
    const sortSelect = document.getElementById('pattern-sort-select');

    if (!sortSection || !sortSelect) {
        console.log('âŒ Sort elements not found in DOM');
        return;
    }

    const pattern = PATTERNS[currentPattern];
    console.log('Pattern object:', pattern ? pattern.name : 'undefined');

    // Check if pattern has sortOptions
    if (pattern && pattern.sortOptions && pattern.sortOptions.length > 0) {
        // Show sort section
        sortSection.style.display = 'flex';

        // Clear existing options
        const previousCount = sortSelect.options.length;
        sortSelect.innerHTML = '<option value="">Sort By</option>';

        // Add pattern-specific sort options
        pattern.sortOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.label;
            opt.dataset.field = option.field;
            opt.dataset.order = option.order;
            opt.dataset.type = option.type;
            sortSelect.appendChild(opt);
        });

        console.log(`âœ… Sort dropdown updated: ${previousCount} â†’ ${sortSelect.options.length} options (${pattern.sortOptions.length} + Default) for "${currentPattern}" pattern`);
    } else {
        // Hide sort section if pattern has no sort options
        sortSection.style.display = 'none';
        console.log(`âš ï¸ Pattern "${currentPattern}" has no sort options`);
    }
}

// Dynamically populate cluster-by dropdown based on current pattern
function updateClusterByOptions() {
    const clusterBySelect = document.getElementById('cluster-by-select');
    if (!clusterBySelect) {
        console.log('âš ï¸ Cluster-by select not found in DOM');
        return;
    }

    const currentValue = clusterBySelect.value;
    clusterBySelect.innerHTML = '';

    // Always start with default option
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = 'ðŸ”— Cluster By';
    defaultOption.style.cssText = 'background: #1a1a2e; color: #ffffff;';
    clusterBySelect.appendChild(defaultOption);

    // Universal fields (work for all patterns)
    const universalFields = [
        { value: 'itemType', label: 'ðŸ“¦ Type' },
        { value: 'owner', label: 'ðŸ‘¤ Owner' },
        { value: 'pmRAGStatus', label: 'ðŸš¦ Status' },
        { value: 'cost', label: 'ðŸ’° Cost Range' },
        { value: 'modifiedDate', label: 'ðŸ“… Date' }
    ];

    // Pattern-specific fields
    const patternFields = {
        philosophy: [
            { value: 'argumentType', label: 'ðŸŽ¯ Argument Type' },
            { value: 'validity', label: 'âœ“ Logical Validity' },
            { value: 'speaker', label: 'ðŸ—£ï¸ Speaker' },
            { value: 'philosophicalSchool', label: 'ðŸ›ï¸ School of Thought' }
        ],
        film: [
            { value: 'visualStyle', label: 'ðŸŽ¨ Visual Style' },
            { value: 'lightingMood', label: 'ðŸ’¡ Lighting Mood' },
            { value: 'cameraMovement', label: 'ðŸŽ¥ Camera Movement' },
            { value: 'aiPlatform', label: 'ðŸ¤– AI Platform' }
        ],
        veo3: [
            { value: 'flowMode', label: 'ðŸŽ¬ Flow Mode' },
            { value: 'audioType', label: 'ðŸ”Š Audio Type' },
            { value: 'cinematicStyle', label: 'ðŸŽ¨ Cinematic Style' }
        ],
        sora2: [
            { value: 'beatType', label: 'ðŸŽµ Beat Type' },
            { value: 'cameoUsed', label: 'ðŸ‘¤ Cameo Used' },
            { value: 'physicsComplexity', label: 'âš›ï¸ Physics Complexity' }
        ],
        sales: [
            { value: 'leadStage', label: 'ðŸ“Š Lead Stage' },
            { value: 'leadSource', label: 'ðŸ“ Lead Source' },
            { value: 'dealSize', label: 'ðŸ’° Deal Size' }
        ],
        roadmap: [
            { value: 'priority', label: 'â­ Priority' },
            { value: 'stakeholder', label: 'ðŸ‘¥ Stakeholder' },
            { value: 'featureCategory', label: 'ðŸ“¦ Feature Category' }
        ]
    };

    // Get pattern-specific fields for current pattern
    const specificFields = patternFields[currentPattern] || [];

    // Add universal fields first
    universalFields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.value;
        option.textContent = field.label;
        option.style.cssText = 'background: #1a1a2e; color: #ffffff;';
        clusterBySelect.appendChild(option);
    });

    // Add separator if we have pattern-specific fields
    if (specificFields.length > 0) {
        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
        separator.style.cssText = 'background: #1a1a2e; color: #555;';
        clusterBySelect.appendChild(separator);

        // Add pattern-specific fields
        specificFields.forEach(field => {
            const option = document.createElement('option');
            option.value = field.value;
            option.textContent = field.label;
            option.style.cssText = 'background: #1a1a2e; color: #ffffff;';
            clusterBySelect.appendChild(option);
        });
    }

    // Restore previous value if it still exists
    if (currentValue) {
        const optionExists = Array.from(clusterBySelect.options).some(opt => opt.value === currentValue);
        if (optionExists) {
            clusterBySelect.value = currentValue;
        }
    }

    console.log(`âœ… Cluster-by options updated for pattern: ${currentPattern} (${specificFields.length} pattern-specific fields)`);
}

function showCustomPatternDialog() {
    const pattern = PATTERNS[currentPattern];
    const currentLabels = customPatternNames || pattern.levels;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = `
        <div style="padding: 20px;">
            <h3 style="color: var(--treeplex-primary); margin-bottom: 20px;">Custom Pattern Names</h3>
            <p style="margin-bottom: 20px; color: var(--text-secondary); font-size: 14px;">
                Define your own names for each level of your project structure.
            </p>

            <div style="display: flex; flex-direction: column; gap: 16px;">
                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 0 (Root):
                    </label>
                    <input type="text" id="custom-root" value="${currentLabels.root}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Project, Campaign, Thesis">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 1 (Phase):
                    </label>
                    <input type="text" id="custom-phase" value="${currentLabels.phase}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Phase, Quarter, Chapter">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 2 (Item):
                    </label>
                    <input type="text" id="custom-item" value="${currentLabels.item}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Item, Feature, Section">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;">
                        Level 3 (Subtask):
                    </label>
                    <input type="text" id="custom-subtask" value="${currentLabels.subtask}"
                           style="width: 100%; padding: 8px 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;"
                           placeholder="e.g., Task, Story, Point">
                </div>
            </div>

            <div style="display: flex; gap: 12px; margin-top: 24px;">
                <button class="btn btn-primary" onclick="saveCustomPattern()" style="flex: 1;">
                    âœ“ Apply Custom Names
                </button>
                <button class="btn" onclick="closeModal()" style="flex: 1;">
                    Cancel
                </button>
            </div>
        </div>
    `;

    document.getElementById('modal').style.display = 'flex';
}

function saveCustomPattern() {
    const root = document.getElementById('custom-root').value.trim() || 'Level 0';
    const phase = document.getElementById('custom-phase').value.trim() || 'Level 1';
    const item = document.getElementById('custom-item').value.trim() || 'Level 2';
    const subtask = document.getElementById('custom-subtask').value.trim() || 'Level 3';

    customPatternNames = { root, phase, item, subtask };

    // Store in data
    if (!capexTree.pattern) {
        capexTree.pattern = {};
    }
    capexTree.pattern.key = 'custom';
    capexTree.pattern.labels = customPatternNames;

    closeModal();
    render();
}

// ============================================================================
// INITIALIZATION
// ============================================================================


function showPatternDescription() {
    const select = document.getElementById('pattern-select');
    const selectedOption = select.options[select.selectedIndex];
    const desc = selectedOption.getAttribute('data-desc');

    if (desc) {
        select.setAttribute('title', desc);
    }
}

function hidePatternDescription() {
    // Keep title for basic tooltip
}

        // State
        let activeNode = null;

        // Utilities
        function formatCost(cost) {
            // Handle null, undefined, or non-numeric values
            if (cost === null || cost === undefined || cost === '' || isNaN(cost)) {
                return '$0';
            }

            // Convert to number if it's a string
            const numCost = typeof cost === 'string' ? parseFloat(cost) : cost;

            if (numCost >= 1000000) return '$' + (numCost / 1000000).toFixed(1) + 'M';
            if (numCost >= 1000) return '$' + (numCost / 1000).toFixed(0) + 'k';
            return '$' + numCost.toLocaleString();
        }

        // BUILD 387: Safe node name helper - prevents "undefined" from displaying
        function safeNodeName(node) {
            if (!node) return 'âš ï¸ Unnamed';
            const name = node.name || node.title;
            if (!name || name === 'undefined' || (typeof name === 'string' && name.trim() === '')) {
                return 'âš ï¸ Unnamed';
            }
            return name;
        }

        // BUILD 389: Get semantic type for display (when type field is used for categorization)
        // Structural types (root, phase, item, subtask) are inferred from position, not displayed
        const STRUCTURAL_TYPES = ['root', 'phase', 'item', 'subtask', 'subItem', 'child', undefined, null, ''];
        function getSemanticType(node) {
            if (!node || !node.type) return null;
            // If it's a structural type, check itemType instead
            if (STRUCTURAL_TYPES.includes(node.type)) {
                return node.itemType || null;
            }
            // Otherwise, the type IS the semantic type (e.g., 'risk-factor', 'critique')
            return node.type;
        }

        // BUILD 390: Subtle type indicator - small colored pip or abbreviated label
        // Chess-like notation: different paths/variations get subtle markers
        function getTypeIndicator(node) {
            const semType = getSemanticType(node);
            if (!semType) return '';

            // Map semantic types to subtle indicators (short, unobtrusive)
            // BUILD 390: Expanded with philosophy dialectical types
            const typeStyles = {
                // Philosophy pattern - dialectical types
                'critique': { icon: 'âš”', color: '#EF4444', abbr: 'crit' },
                'response': { icon: 'â†©', color: '#3B82F6', abbr: 'resp' },
                'argument': { icon: 'â—†', color: '#8B5CF6', abbr: 'arg' },
                'counter': { icon: 'â‡„', color: '#F59E0B', abbr: 'ctr' },
                'objection': { icon: 'âœ—', color: '#F97316', abbr: 'obj' },
                'defense': { icon: 'ðŸ›¡', color: '#22C55E', abbr: 'def' },
                'synthesis': { icon: 'âˆ´', color: '#10B981', abbr: 'syn' },
                'thesis': { icon: 'â†’', color: '#3B82F6', abbr: 'th' },
                'antithesis': { icon: 'â†', color: '#EF4444', abbr: 'anti' },
                'premise': { icon: 'âˆµ', color: '#A855F7', abbr: 'prem' },
                'conclusion': { icon: 'âˆŽ', color: '#06B6D4', abbr: 'conc' },
                'implicit-premise': { icon: 'â‡', color: '#D946EF', abbr: 'impl' },
                'distinction': { icon: 'â‰ ', color: '#EC4899', abbr: 'dist' },
                'thought-experiment': { icon: 'ðŸ’­', color: '#14B8A6', abbr: 'thgt' },
                // Generic/structural types
                'risk-factor': { icon: 'âš ', color: '#EF4444', abbr: 'risk' },
                'sub-node': { icon: 'â†³', color: '#6B7280', abbr: 'sub' },
                'supporting': { icon: 'âœ“', color: '#22C55E', abbr: 'supp' },
                // LifeTree pattern
                'birth': { icon: 'â˜…', color: '#EC4899', abbr: 'birth' },
                'education': { icon: 'ðŸ“š', color: '#3B82F6', abbr: 'edu' },
                'career': { icon: 'ðŸ’¼', color: '#10B981', abbr: 'work' },
                'relationship': { icon: 'â¤', color: '#EC4899', abbr: 'rel' },
                'milestone': { icon: 'ðŸ†', color: '#F59E0B', abbr: 'mile' },
                'loss': { icon: 'â—‡', color: '#6B7280', abbr: 'loss' },
                'achievement': { icon: 'â­', color: '#F59E0B', abbr: 'achv' },
                'travel': { icon: 'âœˆ', color: '#06B6D4', abbr: 'trvl' },
                'residence': { icon: 'ðŸ ', color: '#8B5CF6', abbr: 'home' },
                'family': { icon: 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§', color: '#EC4899', abbr: 'fam' },
                'memory': { icon: 'ðŸ’­', color: '#6B7280', abbr: 'mem' },
                'health': { icon: 'â¤ï¸â€ðŸ©¹', color: '#EF4444', abbr: 'hlth' },
                // Sales pattern
                'lead': { icon: 'ðŸŽ¯', color: '#3B82F6', abbr: 'lead' },
                'opportunity': { icon: 'ðŸ’¡', color: '#F59E0B', abbr: 'oppt' },
                'deal': { icon: 'ðŸ¤', color: '#22C55E', abbr: 'deal' },
                'closed': { icon: 'âœ…', color: '#10B981', abbr: 'won' },
                'lost': { icon: 'âŒ', color: '#EF4444', abbr: 'lost' }
            };

            const style = typeStyles[semType.toLowerCase()] || { icon: 'â€¢', color: '#6B7280', abbr: semType.substring(0, 4) };
            // Return subtle inline indicator - just a small colored marker with tooltip
            return `<span class="type-indicator" style="color: ${style.color}; font-size: 10px; margin-left: 6px; opacity: 0.8;" title="${semType}">${style.icon}</span>`;
        }

        // Calculate total including all children (for root node)
        function calculateTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            if (node.children) {
                node.children.forEach(child => {
                    total += calculateTotal(child);
                });
            }
            return total;
        }

        // Calculate only items in this phase (NOT children phases)
        function calculatePhaseTotal(node) {
            let total = node.cost || 0;
            if (node.items) {
                node.items.forEach(item => {
                    total += item.cost || 0;
                });
            }
            return total;
        }

        function findNode(id, node = capexTree) {
            if (node.id === id) return node;
            if (node.children) {
                for (let child of node.children) {
                    const found = findNode(id, child);
                    if (found) return found;
                }
            }
            return null;
        }

        // Render tree - phases flow left to right
        function render() {
            const container = document.getElementById('tree-root');
            container.innerHTML = '';

            // Show/hide empty state CTA based on tree content
            const emptyStateCta = document.getElementById('empty-state-cta');
            if (emptyStateCta && typeof hasExistingContent === 'function') {
                const showEmptyState = !hasExistingContent();
                emptyStateCta.style.display = showEmptyState ? 'block' : 'none';
            }

            const tableEl = document.createElement('div');
            tableEl.className = 'tree';

            // FILESYSTEM PATTERN: Use vertical tree layout
            if (currentPattern === 'filesystem') {
                tableEl.classList.add('filesystem-tree');

                function buildFilesystemNode(node, depth = 0) {
                    // BUILD 409: Ensure node has type set for context menu to work
                    if (!node.type) {
                        if (node.id === 'root' || depth === 0) node.type = 'root';
                        else if (node.children && node.children.length > 0) node.type = 'phase'; // Folders
                        else node.type = 'item'; // Files
                    }

                    // Initialize expanded property if not set
                    if (node.expanded === undefined) {
                        node.expanded = (depth === 0 || depth === 1); // Auto-expand root and drives
                    }

                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = `tree-node ${node.type} filesystem-indent-${depth}`;
                    if (node.expanded) nodeDiv.classList.add('expanded');
                    else nodeDiv.classList.add('collapsed');
                    nodeDiv.dataset.nodeId = node.id;

                    // BUILD 406: Apply visual highlighting for recently changed nodes
                    if (typeof hasRecentChange === 'function') {
                        const change = hasRecentChange(node.id);
                        if (change) {
                            nodeDiv.classList.add(change.type === 'new' ? 'node-new-highlight' : 'node-modified-highlight');
                        }
                    }

                    // Build node content
                    if (node.type === 'root') {
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0) || (node.children && node.children.length > 0);
                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? 'â–¼' : 'â–¶') + '</span>' : ''}
                                <span class="node-icon">${node.icon || 'ðŸ“'}</span>
                                <div class="node-content">
                                    <div class="node-title">${safeNodeName(node)}</div>
                                </div>
                            </div>
                        `;
                    } else if (node.type === 'phase') {
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0) || (node.children && node.children.length > 0);
                        const isVisibleInCanvas = node.showInCanvas !== false;
                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? 'â–¼' : 'â–¶') + '</span>' : ''}
                                <span class="node-icon">${node.icon || 'ðŸ“‹'}</span>
                                <div class="node-content">
                                    <div class="node-title">${safeNodeName(node)}</div>
                                </div>
                                <button class="canvas-visibility-toggle" title="${isVisibleInCanvas ? 'Hide from Canvas View' : 'Show in Canvas View'}" style="background: none; border: none; cursor: pointer; padding: 4px; margin-left: 8px; font-size: 16px; opacity: ${isVisibleInCanvas ? '1' : '0.3'};">
                                    ${isVisibleInCanvas ? 'ðŸ‘ï¸' : 'ðŸ‘ï¸'}
                                </button>
                            </div>
                        `;
                    } else {
                        // Item/Subtask - file or folder
                        const hasChildren = (node.items && node.items.length > 0) || (node.subItems && node.subItems.length > 0) || (node.children && node.children.length > 0);
                        // Build contributor badge HTML if contributor exists
                        const fsContributorBadge = node.contributor ? `<span class="contributor-badge" title="Last edited by ${node.contributor}${node.contributorTimestamp ? ' on ' + new Date(node.contributorTimestamp).toLocaleDateString() : ''}">ðŸ‘¤ ${node.contributor}</span>` : '';
                        const fsCollabIndicator = node.collabComments ? `<span class="collab-indicator" title="${node.collabComments.substring(0, 100)}${node.collabComments.length > 100 ? '...' : ''}">ðŸ’¬</span>` : '';

                        nodeDiv.innerHTML = `
                            <div class="node-header">
                                ${hasChildren ? '<span class="expand-toggle">' + (node.expanded ? 'â–¼' : 'â–¶') + '</span>' : ''}
                                <span class="node-icon">${node.icon || 'ðŸ“„'}</span>
                                <div class="node-content">
                                    <span class="item-name">${safeNodeName(node)}</span>
                                    ${fsContributorBadge}
                                    ${fsCollabIndicator}
                                </div>
                            </div>
                        `;
                    }

                    // Add event listener for canvas visibility toggle (phases only)
                    if (node.type === 'phase') {
                        const toggleBtn = nodeDiv.querySelector('.canvas-visibility-toggle');
                        if (toggleBtn) {
                            toggleBtn.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();

                                // Toggle visibility
                                node.showInCanvas = !(node.showInCanvas !== false);
                                console.log(`Phase "${node.name}" showInCanvas: ${node.showInCanvas}`);

                                // Re-render tree to update button appearance
                                const treeContainer = document.getElementById('tree-container');
                                const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;
                                render();
                                if (treeContainer) {
                                    setTimeout(() => {
                                        treeContainer.scrollTop = scrollTop;
                                        treeContainer.scrollLeft = scrollLeft;
                                    }, 0);
                                }

                                // If in Canvas View, re-render canvas
                                if (viewMode === 'canvas') {
                                    renderCanvas();
                                }
                            });
                        }
                    }

                    // Event listeners
                    nodeDiv.addEventListener('click', (e) => {
                        e.stopPropagation();

                        const hasChildren = (node.items && node.items.length > 0) ||
                                          (node.subItems && node.subItems.length > 0) ||
                                          (node.children && node.children.length > 0);

                        console.log('Clicked node:', node.name, {
                            type: node.type,
                            hasItems: node.items?.length || 0,
                            hasSubItems: node.subItems?.length || 0,
                            hasChildren: node.children?.length || 0,
                            expanded: node.expanded,
                            hasChildrenTotal: hasChildren
                        });

                        if (hasChildren) {
                            node.expanded = !node.expanded;
                            console.log('â†’ Toggled', node.name, 'to', node.expanded ? 'EXPANDED' : 'COLLAPSED');

                            // Preserve scroll position during re-render (both vertical and horizontal)
                            const treeContainer = document.getElementById('tree-container');
                            const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                            const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                            render();

                            // Restore scroll position after render
                            if (treeContainer) {
                                setTimeout(() => {
                                    treeContainer.scrollTop = scrollTop;
                                    treeContainer.scrollLeft = scrollLeft;
                                }, 0);
                            }
                        } else {
                            console.log('â†’ No children, showing info panel');
                            showInfo(node);
                        }
                    });

                    nodeDiv.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        activeNode = node;
                        showContextMenu(e.pageX, e.pageY);
                    });

                    tableEl.appendChild(nodeDiv);

                    // Recursively render children if expanded
                    if (node.expanded) {
                        if (node.children && node.children.length > 0) {
                            node.children.forEach(child => buildFilesystemNode(child, depth + 1));
                        }
                        if (node.items && node.items.length > 0) {
                            node.items.forEach(item => buildFilesystemNode(item, depth + 1));
                        }
                        if (node.subItems && node.subItems.length > 0) {
                            node.subItems.forEach(subItem => buildFilesystemNode(subItem, depth + 1));
                        }
                    }
                }

                // Start rendering from root
                buildFilesystemNode(capexTree, 0);

                container.appendChild(tableEl);
                return;
            }

            // DEFAULT PATTERN: Use horizontal column layout
            // Traverse and build columns
            function buildColumn(node) {
                // BUILD 409: Ensure node has type set for context menu to work
                if (!node.type) {
                    if (node.id === 'root' || node.id === capexTree.id) node.type = 'root';
                    else if (node.phase !== undefined || node.phaseNumber !== undefined) node.type = 'phase';
                    else node.type = 'item';
                }

                const levelDiv = document.createElement('div');
                levelDiv.className = 'tree-level';

                // Render current node
                const nodeDiv = document.createElement('div');
                nodeDiv.className = `tree-node ${node.type}`;
                if (node.type === 'phase') nodeDiv.classList.add(`phase-${node.phase}`);
                if (node.expanded) nodeDiv.classList.add('expanded');
                else nodeDiv.classList.add('collapsed');

                nodeDiv.dataset.nodeId = node.id;

                // BUILD 406: Apply visual highlighting for recently changed nodes
                if (typeof hasRecentChange === 'function') {
                    const change = hasRecentChange(node.id);
                    if (change) {
                        nodeDiv.classList.add(change.type === 'new' ? 'node-new-highlight' : 'node-modified-highlight');
                    }
                }

                if (node.type === 'root') {
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon || 'ðŸŒ³'}</span>
                            <div class="node-content">
                                <div class="node-title">${safeNodeName(node)}</div>
                                <div class="node-subtitle">by geej</div>
                            </div>
                            ${node.children ? '<span class="expand-toggle">â–¶</span>' : ''}
                        </div>
                    `;
                } else if (node.type === 'phase') {
                    const total = calculatePhaseTotal(node);
                    const isVisibleInCanvas = node.showInCanvas !== false;
                    nodeDiv.innerHTML = `
                        <div class="node-header">
                            <span class="node-icon">${node.icon || 'ðŸ“‹'}</span>
                            <div class="node-content">
                                <div class="node-title">${safeNodeName(node)}</div>
                                ${node.subtitle ? `<div class="node-subtitle">${node.subtitle}</div>` : ''}
                                ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost && total > 0 ? `<div class="node-cost">${formatCost(total)}</div>` : ''}
                            </div>
                            <button class="canvas-visibility-toggle" title="${isVisibleInCanvas ? 'Hide from Canvas View' : 'Show in Canvas View'}" style="background: none; border: none; cursor: pointer; padding: 4px 8px; margin-right: 8px; font-size: 18px; opacity: ${isVisibleInCanvas ? '1' : '0.3'};">
                                ${isVisibleInCanvas ? 'ðŸ‘ï¸' : 'ðŸ‘ï¸'}
                            </button>
                            ${node.items || node.children ? '<span class="expand-toggle">â–¶</span>' : ''}
                        </div>
                    `;
                } else {
                    // Build contributor badge HTML if contributor exists
                    const contributorBadge = node.contributor ? `<span class="contributor-badge" title="Last edited by ${node.contributor}${node.contributorTimestamp ? ' on ' + new Date(node.contributorTimestamp).toLocaleDateString() : ''}">ðŸ‘¤ ${node.contributor}</span>` : '';
                    const collabIndicator = node.collabComments ? `<span class="collab-indicator" title="${node.collabComments.substring(0, 100)}${node.collabComments.length > 100 ? '...' : ''}">ðŸ’¬</span>` : '';
                    // BUILD 389: Subtle type indicator for semantic types (like chess variation markers)
                    const typeIndicator = typeof getTypeIndicator === 'function' ? getTypeIndicator(node) : '';

                    // BUILD 390: Compute type styling for tree view
                    const semType = typeof getSemanticType === 'function' ? getSemanticType(node) : node.itemType;
                    let typeStyleAttr = '';
                    let typeBadgeHtml = '';
                    if (semType) {
                        // BUILD 390: Expanded type color palette matching canvas view
                        const typeStyles = {
                            'critique': { color: '#EF4444', icon: 'âš”' },
                            'response': { color: '#3B82F6', icon: 'â†©' },
                            'argument': { color: '#8B5CF6', icon: 'â—†' },
                            'counter': { color: '#F59E0B', icon: 'â‡„' },
                            'objection': { color: '#F97316', icon: 'âœ—' },
                            'defense': { color: '#22C55E', icon: 'ðŸ›¡' },
                            'synthesis': { color: '#10B981', icon: 'âˆ´' },
                            'thesis': { color: '#3B82F6', icon: 'â†’' },
                            'antithesis': { color: '#EF4444', icon: 'â†' },
                            'premise': { color: '#A855F7', icon: 'âˆµ' },
                            'conclusion': { color: '#06B6D4', icon: 'âˆŽ' },
                            'implicit-premise': { color: '#D946EF', icon: 'â‡' },
                            'distinction': { color: '#EC4899', icon: 'â‰ ' },
                            'thought-experiment': { color: '#14B8A6', icon: 'ðŸ’­' },
                            'risk-factor': { color: '#EF4444', icon: 'âš ' },
                            'sub-node': { color: '#6B7280', icon: 'â†³' },
                            'supporting': { color: '#22C55E', icon: 'âœ“' }
                        };
                        const style = typeStyles[semType.toLowerCase()] || { color: 'var(--treeplex-primary)', icon: 'â€¢' };
                        // Left border stripe for tree view nodes
                        typeStyleAttr = `style="border-left: 3px solid ${style.color}; padding-left: 8px;"`;
                        typeBadgeHtml = `<span class="badge" style="background: ${style.color}20; color: ${style.color};">${style.icon} ${semType}</span>`;
                    }

                    nodeDiv.innerHTML = `
                        <div class="node-header" ${typeStyleAttr}>
                            <span class="node-icon">${node.icon || 'ðŸ“„'}</span>
                            <div class="node-content">
                                <div class="item-name">${safeNodeName(node)}${typeIndicator}</div>
                                ${node.description ? `<div class="item-description">${node.description}</div>` : ''}
                                <div class="item-meta">
                                    ${typeBadgeHtml}
                                    ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost && node.cost > 0 ? `<span class="item-cost">${formatCost(node.cost)}</span>` : ''}
                                    ${contributorBadge}
                                    ${collabIndicator}
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Add event listener for canvas visibility toggle (phases only)
                if (node.type === 'phase') {
                    const toggleBtn = nodeDiv.querySelector('.canvas-visibility-toggle');
                    if (toggleBtn) {
                        toggleBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            // Toggle visibility
                            node.showInCanvas = !(node.showInCanvas !== false);
                            console.log(`Phase "${node.name}" showInCanvas: ${node.showInCanvas}`);

                            // Re-render tree to update button appearance
                            const treeContainer = document.getElementById('tree-container');
                            const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                            const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;
                            render();
                            if (treeContainer) {
                                setTimeout(() => {
                                    treeContainer.scrollTop = scrollTop;
                                    treeContainer.scrollLeft = scrollLeft;
                                }, 0);
                            }

                            // If in Canvas View, re-render canvas
                            if (viewMode === 'canvas') {
                                renderCanvas();
                            }
                        });
                    }
                }

                nodeDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if ((node.items && node.items.length > 0) || (node.children && node.children.length > 0)) {
                        node.expanded = !node.expanded;

                        // Preserve scroll position during re-render (both vertical and horizontal)
                        const treeContainer = document.getElementById('tree-container');
                        const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                        const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                        render();

                        // Restore scroll position after render
                        if (treeContainer) {
                            setTimeout(() => {
                                treeContainer.scrollTop = scrollTop;
                                treeContainer.scrollLeft = scrollLeft;
                            }, 0);
                        }
                    } else {
                        showInfo(node);
                    }
                });

                nodeDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    activeNode = node;
                    showContextMenu(e.pageX, e.pageY);
                });

                levelDiv.appendChild(nodeDiv);
                tableEl.appendChild(levelDiv);

                // If expanded, show items in next column, then next phase in following column
                if (node.expanded) {
                    // Show items if any
                    if (node.items && node.items.length > 0) {
                        const itemsColumn = document.createElement('div');
                        itemsColumn.className = 'tree-level';

                        // Get all item IDs in this phase to check for same-phase dependencies
                        const phaseItemIds = node.items.map(i => i.id);

                        // Topological sort: order items by dependencies
                        // Items with no same-phase dependencies first, then items that depend on them
                        function topologicalSort(items, phaseIds) {
                            const sorted = [];
                            const visited = new Set();
                            const visiting = new Set();

                            function visit(item) {
                                if (visited.has(item.id)) return;
                                if (visiting.has(item.id)) {
                                    // Circular dependency - just add it
                                    sorted.push(item);
                                    visited.add(item.id);
                                    return;
                                }

                                visiting.add(item.id);

                                // Visit dependencies first (only same-phase dependencies)
                                if (item.dependencies) {
                                    // Handle both array and string formats
                                    const deps = Array.isArray(item.dependencies) ? item.dependencies : [];
                                    deps.forEach(depId => {
                                        if (phaseIds.includes(depId)) {
                                            const depItem = items.find(i => i.id === depId);
                                            if (depItem) {
                                                visit(depItem);
                                            }
                                        }
                                    });
                                }

                                visiting.delete(item.id);
                                visited.add(item.id);
                                sorted.push(item);
                            }

                            items.forEach(item => visit(item));
                            return sorted;
                        }

                        // Calculate dependency depth/level for hierarchical indentation
                        // Returns the depth in the dependency chain (0 = no deps, 1 = direct child, 2 = grandchild, etc.)
                        function calculateDependencyLevel(item, phaseItems, phaseItemIds, visited = new Set()) {
                            // Base case: no same-phase dependencies
                            if (!item.dependencies || item.dependencies.length === 0) {
                                return 0;
                            }

                            const samePhaseDeps = item.dependencies.filter(depId => phaseItemIds.includes(depId));
                            if (samePhaseDeps.length === 0) {
                                return 0;
                            }

                            // Prevent circular dependency infinite loops
                            if (visited.has(item.id)) {
                                return 0;
                            }

                            visited.add(item.id);

                            // Find max depth among all same-phase dependencies
                            let maxLevel = 0;
                            samePhaseDeps.forEach(depId => {
                                const depItem = phaseItems.find(i => i.id === depId);
                                if (depItem) {
                                    const depLevel = calculateDependencyLevel(depItem, phaseItems, phaseItemIds, new Set(visited));
                                    maxLevel = Math.max(maxLevel, depLevel + 1);
                                }
                            });

                            return maxLevel;
                        }

                        // Use topological sort only when no custom sort is active
                        const sortedItems = (typeof currentSortConfig !== 'undefined' && currentSortConfig !== null)
                            ? node.items  // Use existing order when user has sorted
                            : topologicalSort(node.items, phaseItemIds);  // Use dependency-based order otherwise

                        sortedItems.forEach(item => {
                            // BUILD 409: Ensure item has type set (matches subtask behavior)
                            if (!item.type) {
                                item.type = 'item';
                            }

                            const itemDiv = document.createElement('div');
                            itemDiv.className = `tree-node item phase-${node.phase}`;
                            itemDiv.dataset.itemId = item.id; // Add item ID for dependency linking

                            // Calculate dependency depth for hierarchical indentation
                            const dependencyLevel = calculateDependencyLevel(item, node.items, phaseItemIds);

                            // Add multi-level indentation based on dependency depth
                            // Level 0 = no indent, Level 1 = 20px, Level 2 = 40px, Level 3 = 60px, etc.
                            if (dependencyLevel > 0) {
                                itemDiv.classList.add('has-same-phase-dependency');
                                itemDiv.style.marginLeft = `${dependencyLevel * 20}px`;
                                itemDiv.style.position = 'relative';
                                itemDiv.dataset.dependencyLevel = dependencyLevel; // Store for potential visual enhancements
                            }

                            // Add expanded class if item has subtasks and is expanded
                            if (item.subItems && item.subItems.length > 0 && item.expanded) {
                                itemDiv.classList.add('has-expanded-subtasks');
                            }

                            // Add dependency indicator
                            const depInfo = item.dependencies && item.dependencies.length > 0
                                ? `<div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">Depends: ${item.dependencies.join(', ')}</div>`
                                : '';

                            // Check if item has subtasks for expand/collapse indicator
                            const hasSubtasks = item.subItems && item.subItems.length > 0;
                            const expandIndicator = hasSubtasks
                                ? `<span class="expand-toggle" onclick="event.stopPropagation(); window.toggleSubtasks('${item.id}');" style="margin-left: 8px; font-size: 12px; opacity: 0.7; cursor: pointer; user-select: none;">${item.expanded ? 'â–¼' : 'â–¶'}</span>`
                                : '';

                            // RAG Status indicator
                            const ragStatusColors = {
                                'Green': '#22C55E',
                                'Amber': '#F59E0B',
                                'Red': '#EF4444'
                            };
                            const itemRAGStatus = item.pmRAGStatus;
                            const ragIndicator = itemRAGStatus ?
                                `<span style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: ${ragStatusColors[itemRAGStatus]}; margin-left: 8px; box-shadow: 0 0 6px ${ragStatusColors[itemRAGStatus]}80; vertical-align: middle;" title="RAG Status: ${itemRAGStatus}"></span>` : '';

                            // PM Status badge
                            const pmStatusBadge = item.pmStatus && item.pmStatus !== 'To Do' ?
                                `<span style="font-size: 10px; padding: 2px 6px; border-radius: 4px; background: ${item.pmStatus === 'Completed' ? '#22C55E' : item.pmStatus === 'Blocked' ? '#EF4444' : '#3B82F6'}; color: white; margin-left: 8px; font-weight: 600;">${item.pmStatus}</span>` : '';

                            itemDiv.innerHTML = `
                                <div class="node-header">
                                    <span class="node-icon">${item.icon}</span>
                                    <div class="node-content">
                                        <div class="item-name">
                                            ${safeNodeName(item)}
                                            ${ragIndicator}
                                            ${pmStatusBadge}
                                            ${expandIndicator}
                                            ${hasSubtasks ? `<span style="font-size: 10px; color: var(--text-secondary); margin-left: 8px;">(${item.subItems.length} tasks)</span>` : ''}
                                        </div>
                                        <div class="item-description">${item.description || ''}</div>
                                        <div class="item-meta">
                                            ${item.itemType ? `<span class="badge badge-${item.itemType}">${item.itemType}</span>` : ''}
                                            ${PATTERNS[currentPattern].fields && PATTERNS[currentPattern].fields.cost && item.cost > 0 ? `<span class="item-cost">${formatCost(item.cost)}</span>` : ''}
                                            ${item.pmOwnerEmail ? `<span style="font-size: 10px; color: var(--text-secondary); margin-left: 12px;">ðŸ‘¤ ${item.pmOwnerEmail.split('@')[0]}</span>` : ''}
                                            ${item.pmProgress > 0 ? `<span style="font-size: 10px; color: var(--treeplex-primary); margin-left: 12px; font-weight: 600;">${item.pmProgress}%</span>` : ''}
                                        </div>
                                        ${depInfo}
                                    </div>
                                </div>
                            `;
                            itemDiv.addEventListener('click', (e) => {
                                e.stopPropagation();

                                const panel = document.getElementById('info-panel');
                                const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === item.id;

                                if (isPanelOpen) {
                                    // Second click: Close panel and collapse subtasks
                                    panel.classList.remove('open');
                                    currentOpenItemId = null;
                                    if (hasSubtasks) {
                                        item.expanded = false;

                                        // Preserve scroll position during re-render (both vertical and horizontal)
                                        const treeContainer = document.getElementById('tree-container');
                                        const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                        const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                        render();

                                        // Restore scroll position after render
                                        if (treeContainer) {
                                            setTimeout(() => {
                                                treeContainer.scrollTop = scrollTop;
                                                treeContainer.scrollLeft = scrollLeft;
                                            }, 0);
                                        }
                                    }
                                } else {
                                    // First click: Open panel and expand subtasks
                                    showInfo(item);
                                    if (hasSubtasks) {
                                        item.expanded = true;

                                        // Preserve scroll position during re-render (both vertical and horizontal)
                                        const treeContainer = document.getElementById('tree-container');
                                        const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                        const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                        render();

                                        // Restore scroll position after render
                                        if (treeContainer) {
                                            setTimeout(() => {
                                                treeContainer.scrollTop = scrollTop;
                                                treeContainer.scrollLeft = scrollLeft;
                                            }, 0);
                                        }
                                    }
                                }
                            });

                            itemDiv.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                activeNode = item;
                                showContextMenu(e.pageX, e.pageY);
                            });

                            itemsColumn.appendChild(itemDiv);

                            // RECURSIVE function to render subtasks - keeps same generation on horizontal plane
                            function renderSubtasks(parentItem, containerEl, phaseNum, nestLevel = 0) {
                                if (!parentItem.expanded || !parentItem.subItems || parentItem.subItems.length === 0) {
                                    return;
                                }

                                const subtaskContainer = document.createElement('div');
                                subtaskContainer.className = 'subtask-container';
                                subtaskContainer.style.marginLeft = `${(dependencyLevel + nestLevel) * 20}px`;

                                // Get sub-item IDs for dependency calculations
                                const subItemIds = parentItem.subItems.map(s => s.id);

                                // Sort sub-items by dependencies (topological sort)
                                const sortedSubItems = topologicalSort(parentItem.subItems, subItemIds);

                                // Collect all expanded children that need rendering in next generation
                                const allExpandedGrandchildren = [];

                                // Render all subtasks horizontally first (same generation on same row)
                                sortedSubItems.forEach((subItem, index) => {
                                    const subItemDiv = document.createElement('div');
                                    subItemDiv.className = `tree-node item phase-${phaseNum} subtask`;
                                    subItemDiv.dataset.itemId = subItem.id;

                                    // Ensure subItem has type set
                                    if (!subItem.type) {
                                        subItem.type = 'subtask';
                                    }

                                    // Status color indicator
                                    const statusColors = {
                                        'To Do': '#9CA3AF',
                                        'In Progress': '#3B82F6',
                                        'Completed': '#10B981',
                                        'Done': '#10B981',
                                        'Blocked': '#EF4444'
                                    };
                                    const statusColor = statusColors[subItem.pmStatus] || '#9CA3AF';

                                    // Get initials from assignee name
                                    const getInitials = (name) => {
                                        if (!name || name === 'Unassigned') return '?';
                                        const parts = name.trim().split(' ');
                                        if (parts.length === 1) return parts[0].substring(0, 2).toUpperCase();
                                        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                                    };

                                    // Check if this task has children
                                    const hasChildren = subItem.subItems && subItem.subItems.length > 0;
                                    const chevronIcon = hasChildren ? (subItem.expanded ? 'â–¼' : 'â–¶') : '';

                                    // RAG Status for subtasks
                                    const subRAGColors = {
                                        'Green': '#22C55E',
                                        'Amber': '#F59E0B',
                                        'Red': '#EF4444'
                                    };
                                    const subRAGStatus = subItem.pmRAGStatus;
                                    const ragDot = subRAGStatus ?
                                        `<div style="width: 8px; height: 8px; border-radius: 50%; background: ${subRAGColors[subRAGStatus]}; box-shadow: 0 0 4px ${subRAGColors[subRAGStatus]}; flex-shrink: 0; position: absolute; top: -2px; right: -2px; border: 1.5px solid var(--card-bg-light);" title="RAG: ${subRAGStatus}"></div>` : '';

                                    subItemDiv.innerHTML = `
                                        <div style="display: flex; flex-direction: column; gap: 6px; width: 100%; height: 100%;">
                                            <!-- Task Title with optional chevron -->
                                            <div style="display: flex; align-items: flex-start; gap: 4px;">
                                                ${chevronIcon ? `<span style="font-size: 8px; color: var(--text-secondary); cursor: pointer; margin-top: 2px;" class="task-chevron">${chevronIcon}</span>` : ''}
                                                <div style="font-size: 11px; font-weight: 600; line-height: 1.2; color: var(--text-primary); flex: 1; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                                                    ${safeNodeName(subItem)}
                                                </div>
                                            </div>

                                            <!-- Visual Indicators Row -->
                                            <div style="display: flex; align-items: center; gap: 6px; margin-top: auto;">
                                                <!-- Status Dot with RAG overlay -->
                                                <div style="position: relative; width: 12px; height: 12px; flex-shrink: 0;">
                                                    <div style="width: 12px; height: 12px; border-radius: 50%; background: ${statusColor}; box-shadow: 0 0 6px ${statusColor}; flex-shrink: 0;" title="${subItem.pmStatus || 'To Do'}"></div>
                                                    ${ragDot}
                                                </div>

                                                <!-- Owner Badge -->
                                                <div style="width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; color: white; flex-shrink: 0;" title="${subItem.pmOwnerEmail || subItem.pmAssignee || 'Unassigned'}">
                                                    ${getInitials(subItem.pmOwnerEmail || subItem.pmAssignee)}
                                                </div>

                                                <!-- Progress % -->
                                                <div style="font-size: 11px; font-weight: 700; color: var(--treeplex-primary); margin-left: auto;" title="Progress">
                                                    ${subItem.pmProgress || 0}%
                                                </div>
                                            </div>

                                            <!-- Mini Progress Bar -->
                                            <div style="width: 100%; height: 3px; background: rgba(0, 0, 0, 0.3); border-radius: 2px; overflow: hidden;">
                                                <div style="height: 100%; width: ${subItem.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                                            </div>
                                        </div>
                                    `;

                                    // Click to show info panel AND toggle nested subtasks
                                    subItemDiv.addEventListener('click', (e) => {
                                        e.stopPropagation();

                                        const panel = document.getElementById('info-panel');
                                        const isPanelOpen = panel.classList.contains('open') && currentOpenItemId === subItem.id;

                                        if (isPanelOpen) {
                                            // Second click: Close panel and collapse nested subtasks
                                            panel.classList.remove('open');
                                            currentOpenItemId = null;
                                            if (hasChildren) {
                                                subItem.expanded = false;

                                                // Preserve scroll position during re-render (both vertical and horizontal)
                                                const treeContainer = document.getElementById('tree-container');
                                                const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                                const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                                render();

                                                // Restore scroll position after render
                                                if (treeContainer) {
                                                    setTimeout(() => {
                                                        treeContainer.scrollTop = scrollTop;
                                                        treeContainer.scrollLeft = scrollLeft;
                                                    }, 0);
                                                }
                                            }
                                        } else {
                                            // First click: Open panel and expand nested subtasks
                                            showInfo(subItem);
                                            if (hasChildren) {
                                                subItem.expanded = true;

                                                // Preserve scroll position during re-render (both vertical and horizontal)
                                                const treeContainer = document.getElementById('tree-container');
                                                const scrollTop = treeContainer ? treeContainer.scrollTop : 0;
                                                const scrollLeft = treeContainer ? treeContainer.scrollLeft : 0;

                                                render();

                                                // Restore scroll position after render
                                                if (treeContainer) {
                                                    setTimeout(() => {
                                                        treeContainer.scrollTop = scrollTop;
                                                        treeContainer.scrollLeft = scrollLeft;
                                                    }, 0);
                                                }
                                            }
                                        }
                                    });

                                    subItemDiv.addEventListener('contextmenu', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        activeNode = subItem;
                                        showContextMenu(e.pageX, e.pageY);
                                    });

                                    subtaskContainer.appendChild(subItemDiv);

                                    // Collect expanded children for next generation
                                    if (subItem.expanded && subItem.subItems && subItem.subItems.length > 0) {
                                        allExpandedGrandchildren.push(subItem);
                                    }
                                });

                                containerEl.appendChild(subtaskContainer);

                                // Now render ALL children of this generation on the NEXT horizontal row below
                                allExpandedGrandchildren.forEach(expandedChild => {
                                    renderSubtasks(expandedChild, containerEl, phaseNum, nestLevel + 1);
                                });
                            }

                            // Initial call to render subtasks
                            renderSubtasks(item, itemsColumn, node.phase, 0);
                        });

                        tableEl.appendChild(itemsColumn);
                    }

                    // Recursively render next phase
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => buildColumn(child));
                    }
                }
            }

            buildColumn(capexTree);
            container.appendChild(tableEl);

            // Draw dependency lines after rendering
            setTimeout(drawDependencyLines, 100);
        }

        // Draw dependency lines using SVG
        function drawDependencyLines() {
            const svg = document.getElementById('dependency-svg');
            const treeEl = document.getElementById('tree-root');
            const wrapperEl = document.getElementById('tree-transform-wrapper');

            // Clear existing lines
            svg.innerHTML = '';

            // Set SVG dimensions to be large enough for panning/zooming
            // Use a fixed large size that the CSS will position correctly
            svg.setAttribute('width', '20000');
            svg.setAttribute('height', '20000');

            // Add arrow marker definitions
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Create markers for each phase color - using darker vibrant colors
            const colors = {
                'phase-0': '#4CAF50',
                'phase-1': '#2196F3',
                'phase-2': '#FB8C00',
                'cross-phase': '#008F6D'
            };

            Object.entries(colors).forEach(([className, color]) => {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', `arrow-${className}`);
                marker.setAttribute('viewBox', '0 0 10 10');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '5');
                marker.setAttribute('markerWidth', '8');
                marker.setAttribute('markerHeight', '8');
                marker.setAttribute('orient', 'auto');

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                path.setAttribute('fill', color);
                path.setAttribute('opacity', '0.8');
                path.setAttribute('filter', 'drop-shadow(0 2px 2px rgba(0,0,0,0.2))');

                marker.appendChild(path);
                defs.appendChild(marker);
            });

            svg.appendChild(defs);

            // Find all items with dependencies
            function getAllItems(node, items = [], phase = null) {
                if (node.phase !== undefined) phase = node.phase;
                if (node.items) {
                    node.items.forEach(item => items.push({ ...item, currentPhase: phase }));
                }
                if (node.children) {
                    node.children.forEach(child => getAllItems(child, items, phase));
                }
                return items;
            }

            const allItems = getAllItems(capexTree);

            // Helper to find item phase
            function findItemPhase(itemId) {
                const item = allItems.find(i => i.id === itemId);
                return item ? item.currentPhase : null;
            }

            // Draw lines for each dependency
            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    const targetEl = document.querySelector(`[data-item-id="${item.id}"]`);
                    if (!targetEl) return;

                    item.dependencies.forEach(depId => {
                        const sourceEl = document.querySelector(`[data-item-id="${depId}"]`);
                        if (!sourceEl) return;

                        // Get positions in tree's local coordinate space (not viewport)
                        // This accounts for the transform by using offsetLeft/Top instead of getBoundingClientRect
                        function getElementPosition(el) {
                            let x = 0;
                            let y = 0;
                            let current = el;

                            // Walk up to the tree root to get cumulative offset
                            while (current && current !== treeEl.parentElement) {
                                x += current.offsetLeft || 0;
                                y += current.offsetTop || 0;
                                current = current.offsetParent;
                            }

                            return { x, y, width: el.offsetWidth, height: el.offsetHeight };
                        }

                        const sourcePos = getElementPosition(sourceEl);
                        const targetPos = getElementPosition(targetEl);

                        // SVG offset constant (matches CSS top/left offset)
                        const SVG_OFFSET = 5000;

                        const x1 = sourcePos.x + sourcePos.width + SVG_OFFSET;
                        const y1 = sourcePos.y + sourcePos.height / 2 + SVG_OFFSET;
                        const x2 = targetPos.x + SVG_OFFSET;
                        const y2 = targetPos.y + targetPos.height / 2 + SVG_OFFSET;

                        // Determine if cross-phase dependency
                        const sourcePhase = findItemPhase(depId);
                        const targetPhase = item.currentPhase;
                        const isCrossPhase = sourcePhase !== targetPhase;

                        // Skip same-phase dependencies - only draw cross-phase arrows
                        if (!isCrossPhase) return;

                        const lineClass = 'cross-phase';

                        // Create curved path (quadratic bezier)
                        const midX = (x1 + x2) / 2;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const d = `M ${x1} ${y1} Q ${midX} ${y1}, ${midX} ${(y1 + y2) / 2} T ${x2} ${y2}`;

                        path.setAttribute('d', d);
                        path.setAttribute('class', `dependency-line ${lineClass}`);
                        path.setAttribute('marker-end', `url(#arrow-${lineClass})`);

                        // Add tooltip
                        const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                        title.textContent = `${depId} â†’ ${item.id}${isCrossPhase ? ' (cross-phase)' : ''}`;
                        path.appendChild(title);

                        svg.appendChild(path);
                    });
                }
            });

            // =================================================================
            // DRAW PARENT-CHILD CONNECTORS FOR TASKS (Symmetrical Grey Lines)
            // =================================================================
            // Find all subtasks and draw symmetrical connectors to their parent items
            function getAllSubtasksWithParent(node, subtasks = []) {
                if (node.items) {
                    node.items.forEach(item => {
                        if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                            // Collect parent with all its children for symmetrical layout
                            subtasks.push({
                                parent: item,
                                children: item.subItems
                            });

                            // Recursively handle nested tasks
                            item.subItems.forEach(subtask => {
                                if (subtask.subItems && Array.isArray(subtask.subItems) && subtask.subItems.length > 0) {
                                    subtasks.push({
                                        parent: subtask,
                                        children: subtask.subItems
                                    });
                                }
                            });
                        }
                    });
                }
                if (node.children) {
                    node.children.forEach(child => getAllSubtasksWithParent(child, subtasks));
                }
                return subtasks;
            }

            const allParentChildPairs = getAllSubtasksWithParent(capexTree);

            // Helper to get element position
            function getElementPosition(el) {
                let x = 0;
                let y = 0;
                let current = el;

                while (current && current !== treeEl.parentElement) {
                    x += current.offsetLeft || 0;
                    y += current.offsetTop || 0;
                    current = current.offsetParent;
                }

                return { x, y, width: el.offsetWidth, height: el.offsetHeight };
            }

            const SVG_OFFSET = 5000;

            allParentChildPairs.forEach(({ parent, children }) => {
                const parentEl = document.querySelector(`[data-item-id="${parent.id}"]`);
                if (!parentEl) return;

                const parentPos = getElementPosition(parentEl);

                // Draw symmetrical lines from parent to each child
                children.forEach(child => {
                    const childEl = document.querySelector(`[data-item-id="${child.id}"]`);
                    if (!childEl) return;

                    const childPos = getElementPosition(childEl);

                    // Start from bottom-center of parent
                    const x1 = parentPos.x + parentPos.width / 2 + SVG_OFFSET;
                    const y1 = parentPos.y + parentPos.height + SVG_OFFSET;

                    // End at top-center of child
                    const x2 = childPos.x + childPos.width / 2 + SVG_OFFSET;
                    const y2 = childPos.y + SVG_OFFSET;

                    // Create symmetrical line (no arrow head)
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', 'rgba(128, 128, 128, 0.4)');  // Grey
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('opacity', '0.6');

                    // Add tooltip
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = `${parent.name} â†’ ${child.name}`;
                    line.appendChild(title);

                    svg.appendChild(line);
                });
            });
        }


        // Info Panel
        function showInfo(node) {
            const panel = document.getElementById('info-panel');
            const titleElement = document.getElementById('info-title');

            // Enhanced title for subtasks - just the name, prominent
            if (node.type === 'subtask') {
                titleElement.innerHTML = `
                    <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); line-height: 1.3;">
                        ${node.name}
                    </div>
                `;
            } else {
                titleElement.textContent = `${node.icon || 'ðŸ“„'} ${node.name}`;
            }

            const body = document.getElementById('info-body');

            // Build dependencies section
            let depsHtml = '';
            if (node.dependencies && node.dependencies.length > 0) {
                const depNames = node.dependencies.map(depId => {
                    // Find the dependency item to get its name
                    function findItemById(id, n = capexTree) {
                        if (n.id === id) return n;
                        if (n.items) {
                            const found = n.items.find(i => i.id === id);
                            if (found) return found;
                        }
                        if (n.children) {
                            for (let child of n.children) {
                                const found = findItemById(id, child);
                                if (found) return found;
                            }
                        }
                        return null;
                    }
                    const depItem = findItemById(depId);
                    return depItem ? `${depItem.icon} ${depItem.name}` : depId;
                }).join('<br>');

                depsHtml = `
                    <div class="info-section">
                        <h4>Dependencies</h4>
                        <p style="line-height: 1.8;">${depNames}</p>
                    </div>
                `;
            }

            // Build dependents section (items that depend on this one)
            let dependentsHtml = '';
            if (node.id) {
                function findDependents(nodeId, n = capexTree, dependents = []) {
                    if (n.items) {
                        n.items.forEach(item => {
                            if (item.dependencies && item.dependencies.includes(nodeId)) {
                                dependents.push(item);
                            }
                        });
                    }
                    if (n.children) {
                        n.children.forEach(child => findDependents(nodeId, child, dependents));
                    }
                    return dependents;
                }

                const dependents = findDependents(node.id);
                if (dependents.length > 0) {
                    const depList = dependents.map(d => `${d.icon} ${d.name}`).join('<br>');
                    dependentsHtml = `
                        <div class="info-section">
                            <h4>Required By</h4>
                            <p style="line-height: 1.8;">${depList}</p>
                        </div>
                    `;
                }
            }

            // Build PM Dashboard section for subtasks (only if pattern has tracking enabled)
            let pmDashboardHtml = '';
            const pattern = PATTERNS[currentPattern];
            const hasTracking = pattern.fields?.includeTracking === true;

            if (node.type === 'subtask' && hasTracking) {
                const statusColors = {
                    'To Do': { bg: 'rgba(156, 163, 175, 0.3)', color: '#9CA3AF' },
                    'In Progress': { bg: 'rgba(59, 130, 246, 0.3)', color: '#3B82F6' },
                    'Completed': { bg: 'rgba(16, 185, 129, 0.3)', color: '#10B981' },
                    'Blocked': { bg: 'rgba(239, 68, 68, 0.3)', color: '#EF4444' }
                };
                const statusStyle = statusColors[node.pmStatus] || statusColors['To Do'];

                const priorityEmojis = { 'Low': 'ðŸŸ¢', 'Medium': 'ðŸŸ¡', 'High': 'ðŸŸ ', 'Critical': 'ðŸ”´' };
                const priorityEmoji = priorityEmojis[node.pmPriority] || 'âšª';

                // Calculate days until/since due date
                let dueDateInfo = '';
                if (node.pmDueDate) {
                    const dueDate = new Date(node.pmDueDate);
                    const today = new Date();
                    const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                    if (diffDays < 0) {
                        dueDateInfo = `<span style="color: #EF4444; font-weight: 600;">âš ï¸ ${Math.abs(diffDays)} days overdue</span>`;
                    } else if (diffDays === 0) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">ðŸ“… Due today!</span>`;
                    } else if (diffDays <= 3) {
                        dueDateInfo = `<span style="color: #F59E0B; font-weight: 600;">â° ${diffDays} days left</span>`;
                    } else {
                        dueDateInfo = `<span style="color: var(--text-secondary);">${diffDays} days left</span>`;
                    }
                }

                pmDashboardHtml = `
                    <!-- Status + Progress Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: ${statusStyle.bg}; border-radius: 10px; border: 2px solid ${statusStyle.color};">
                            <div style="font-size: 28px; font-weight: 700; color: ${statusStyle.color};">
                                ${node.pmStatus || 'To Do'}
                            </div>
                        </div>
                        <div style="flex: 1; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); border-radius: 10px; border: 2px solid rgba(0, 166, 125, 0.4); display: flex; flex-direction: column; justify-content: center;">
                            <div style="font-size: 36px; font-weight: 700; color: var(--treeplex-primary); line-height: 1;">${node.pmProgress || 0}%</div>
                            <div style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden; margin-top: 8px;">
                                <div style="height: 100%; width: ${node.pmProgress || 0}%; background: linear-gradient(90deg, var(--treeplex-primary), var(--treeplex-primary-dark)); transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Owner + Priority Row -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <div style="flex: 1; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; align-items: center; gap: 12px;">
                            <div style="width: 48px; height: 48px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: 700; color: white; flex-shrink: 0;">
                                ${node.pmAssignee ? node.pmAssignee.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2) : '?'}
                            </div>
                            <div style="font-size: 18px; font-weight: 600;">${node.pmAssignee || 'Unassigned'}</div>
                        </div>
                        <div style="width: 120px; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <div style="font-size: 40px; margin-bottom: 4px;">${priorityEmoji}</div>
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-secondary);">${node.pmPriority || 'Medium'}</div>
                        </div>
                    </div>

                    <!-- Timeline -->
                    <div style="padding: 16px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-around; margin-bottom: 12px;">
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">ðŸ“…</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmStartDate ? new Date(node.pmStartDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                            <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
                                <div style="height: 2px; flex: 1; background: linear-gradient(90deg, var(--treeplex-primary), transparent);"></div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 28px; margin-bottom: 4px;">ðŸŽ¯</div>
                                <div style="font-size: 14px; font-weight: 600;">${node.pmDueDate ? new Date(node.pmDueDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric'}) : 'Not set'}</div>
                            </div>
                        </div>
                        ${dueDateInfo ? `<div style="text-align: center; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; font-size: 13px;">${dueDateInfo}</div>` : ''}
                    </div>

                    <!-- Notes -->
                    ${node.pmNotes ? `
                        <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; border-left: 4px solid var(--treeplex-primary); margin-bottom: 16px;">
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary);">${node.pmNotes}</div>
                        </div>
                    ` : ''}

                    <!-- Blocking Issue -->
                    ${node.pmBlockingIssue ? `
                        <div style="padding: 14px; background: rgba(239, 68, 68, 0.15); border-radius: 10px; border-left: 4px solid #EF4444; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">ðŸš§</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #FCA5A5;">${node.pmBlockingIssue}</div>
                        </div>
                    ` : ''}

                    <!-- Next Steps -->
                    ${node.pmNextSteps ? `
                        <div style="padding: 14px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; border-left: 4px solid #3B82F6; margin-bottom: 16px;">
                            <div style="font-size: 20px; margin-bottom: 8px;">âž¡ï¸</div>
                            <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: #93C5FD;">${node.pmNextSteps}</div>
                        </div>
                    ` : ''}

                    <!-- Latest Updates -->
                    ${node.pmUpdates && node.pmUpdates.length > 0 ? `
                        <div style="max-height: 300px; overflow-y: auto;">
                            ${node.pmUpdates.map(update => `
                                <div style="margin-bottom: 10px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 6px;">
                                        ðŸ“… ${new Date(update.timestamp).toLocaleString('en-US', {month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'})}
                                    </div>
                                    <div style="font-size: 13px; line-height: 1.5; white-space: pre-wrap;">${update.text}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            }

            // Build pattern-specific infographic (geometric and visual)
            let patternInfoHtml = '';

            // SALES PIPELINE - Funnel with probability
            if (currentPattern === 'sales' && (node.dealValue || node.stageProbability || node.expectedCloseDate || node.competitorInfo)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(16, 185, 129, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #10B981; margin-bottom: 8px;">ðŸ’¼ Sales Deal Pipeline</div>
                        </div>

                        <!-- Deal Value + Probability Row -->
                        <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                            ${node.dealValue ? `
                                <div style="flex: 1; padding: 20px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ðŸ’° Deal Value</div>
                                    <div style="font-size: 32px; font-weight: 700; color: #10B981;">$${node.dealValue.toLocaleString()}</div>
                                </div>
                            ` : ''}
                            ${node.stageProbability !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ðŸ“Š Close Probability</div>
                                    <div style="font-size: 32px; font-weight: 700; color: #3B82F6;">${node.stageProbability}%</div>
                                    <div style="width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; overflow: hidden; margin-top: 12px;">
                                        <div style="height: 100%; width: ${node.stageProbability}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Expected Revenue (Value Ã— Probability) -->
                        ${node.dealValue && node.stageProbability !== undefined ? `
                            <div style="text-align: center; padding: 16px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; margin-bottom: 20px;">
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">Expected Revenue (Value Ã— Probability)</div>
                                <div style="font-size: 24px; font-weight: 700; color: #F59E0B;">$${Math.round(node.dealValue * (node.stageProbability / 100)).toLocaleString()}</div>
                            </div>
                        ` : ''}

                        <!-- Timeline & Contact -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.expectedCloseDate ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“… Target Close</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${new Date(node.expectedCloseDate).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                            ${node.contactPerson ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‘¤ Contact</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.contactPerson}</div>
                                </div>
                            ` : ''}
                            ${node.leadSource ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“ Source</div>
                                    <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.leadSource}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Competitor Info -->
                        ${node.competitorInfo ? `
                            <div style="padding: 16px; background: rgba(239, 68, 68, 0.12); border-left: 4px solid #EF4444; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #EF4444; margin-bottom: 8px; text-transform: uppercase;">ðŸŽ¯ Competitive Landscape</div>
                                <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.competitorInfo}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILM/VIDEO - Scene storyboard card
            else if (currentPattern === 'film' && (node.videoPrompt || node.aiPlatform || node.cameraMovement)) {
                const platformColors = {
                    'Sora (OpenAI)': '#74aa9c',
                    'Veo 3 (Google)': '#4285f4',
                    'Runway Gen-3': '#6366f1',
                    'Pika 2.0': '#f59e0b',
                    'Testing Multiple': '#8b5cf6'
                };
                const platformColor = platformColors[node.aiPlatform] || '#9ca3af';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ðŸŽ¬ AI Video Scene</div>
                        </div>

                        <!-- Platform & Technical Specs -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.aiPlatform ? `
                                <div style="padding: 12px; background: rgba(${parseInt(platformColor.slice(1, 3), 16)}, ${parseInt(platformColor.slice(3, 5), 16)}, ${parseInt(platformColor.slice(5, 7), 16)}, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Platform</div>
                                    <div style="font-size: 13px; font-weight: 600; color: ${platformColor};">ðŸ¤– ${node.aiPlatform}</div>
                                </div>
                            ` : ''}
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #3B82F6;">â±ï¸ ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.aspectRatio ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Ratio</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #10B981;">ðŸ“ ${node.aspectRatio.split(' ')[0]}</div>
                                </div>
                            ` : ''}
                            ${node.visualStyle ? `
                                <div style="padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Style</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #A78BFA;">ðŸŽ¨ ${node.visualStyle}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Cinematography -->
                        ${node.cameraMovement || node.lightingMood || node.motionIntensity ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 12px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 12px; text-transform: uppercase;">ðŸŽ¥ Cinematography</div>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                    ${node.cameraMovement && node.cameraMovement !== 'Static' ? `
                                        <div style="padding: 8px 14px; background: rgba(245, 158, 11, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #F59E0B;">
                                            ðŸ“¹ ${node.cameraMovement}
                                        </div>
                                    ` : ''}
                                    ${node.lightingMood ? `
                                        <div style="padding: 8px 14px; background: rgba(251, 191, 36, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #FCD34D;">
                                            ðŸ’¡ ${node.lightingMood}
                                        </div>
                                    ` : ''}
                                    ${node.motionIntensity ? `
                                        <div style="padding: 8px 14px; background: rgba(59, 130, 246, 0.15); border-radius: 20px; font-size: 12px; font-weight: 600; color: #60A5FA;">
                                            ðŸŒŠ ${node.motionIntensity}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}

                        <!-- Video Prompt (Main) -->
                        ${node.videoPrompt ? `
                            <div style="padding: 16px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid var(--treeplex-primary); border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px; text-transform: uppercase;">âœï¸ Video Prompt</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">${node.videoPrompt}</div>
                            </div>
                        ` : ''}

                        <!-- Iteration Notes -->
                        ${node.iterationNotes ? `
                            <div style="padding: 14px; background: rgba(139, 92, 246, 0.12); border-left: 4px solid #A78BFA; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #A78BFA; margin-bottom: 6px; text-transform: uppercase;">ðŸ“ Generation Notes</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.iterationNotes}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // PHILOSOPHY - Logical argument structure (already implemented)
            else if (currentPattern === 'philosophy' && (node.premise1 || node.premise2 || node.conclusion || node.objection || node.response)) {
                // Philosophy Pattern Infographic
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ðŸ¤” Philosophical Argument Structure</div>
                            ${node.speaker ? `<div style="font-size: 14px; color: var(--text-secondary);">ðŸ—£ï¸ Speaker: <span style="color: var(--text-primary); font-weight: 600;">${node.speaker}</span></div>` : ''}
                        </div>

                        <!-- Argument Metadata Row -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.argumentType ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Argument Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #60A5FA;">ðŸŽ¯ ${node.argumentType}</div>
                                </div>
                            ` : ''}
                            ${node.validity ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: ${node.validity === 'Valid' || node.validity === 'Sound' ? 'rgba(16, 185, 129, 0.15)' : 'rgba(239, 68, 68, 0.15)'}; border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Validity</div>
                                    <div style="font-size: 14px; font-weight: 600; color: ${node.validity === 'Valid' || node.validity === 'Sound' ? '#10B981' : '#EF4444'};">âœ“ ${node.validity}</div>
                                </div>
                            ` : ''}
                            ${node.philosophicalSchool ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">School</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">ðŸ›ï¸ ${node.philosophicalSchool}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Argument Flow: Premises â†’ Conclusion -->
                        ${node.premise1 || node.premise2 || node.conclusion ? `
                            <div style="margin-bottom: 24px;">
                                <div style="text-align: center; font-size: 13px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px;">âš¡ Logical Structure</div>

                                ${node.premise1 ? `
                                    <div style="position: relative; margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">1ï¸âƒ£ Premise 1</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.premise1}</div>
                                        </div>
                                        <div style="text-align: center; margin: 8px 0; font-size: 20px; color: var(--treeplex-primary);">â†“</div>
                                    </div>
                                ` : ''}

                                ${node.premise2 ? `
                                    <div style="position: relative; margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">2ï¸âƒ£ Premise 2</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.premise2}</div>
                                        </div>
                                        <div style="text-align: center; margin: 8px 0; font-size: 20px; color: var(--treeplex-primary);">â†“</div>
                                    </div>
                                ` : ''}

                                ${node.conclusion ? `
                                    <div style="position: relative;">
                                        <div style="text-align: center; margin-bottom: 8px;">
                                            <span style="display: inline-block; padding: 6px 16px; background: var(--treeplex-primary); color: white; border-radius: 20px; font-size: 13px; font-weight: 700;">âˆ´ THEREFORE</span>
                                        </div>
                                        <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1)); border: 2px solid #10B981; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">âœ“ Conclusion</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; font-weight: 500;">${node.conclusion}</div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Objection & Response (Dialectic) -->
                        ${node.objection || node.response ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 13px; font-weight: 700; color: #F59E0B; margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px;">âš”ï¸ Dialectical Challenge</div>

                                ${node.objection ? `
                                    <div style="margin-bottom: 12px;">
                                        <div style="background: rgba(239, 68, 68, 0.12); border-left: 4px solid #EF4444; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #EF4444; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">âŒ Objection</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.objection}</div>
                                        </div>
                                    </div>
                                ` : ''}

                                ${node.response ? `
                                    <div style="text-align: center; margin: 12px 0; font-size: 16px; color: var(--treeplex-primary);">â¤·</div>
                                    <div style="margin-bottom: 12px;">
                                        <div style="background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; padding: 16px; border-radius: 8px;">
                                            <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">ðŸ’¡ Response to Objection</div>
                                            <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.response}</div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Key Concepts & References -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.keyTerms ? `
                                <div style="flex: 1; min-width: 200px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“ Key Terms</div>
                                    <div style="font-size: 13px; line-height: 1.5; color: var(--text-primary);">${node.keyTerms}</div>
                                </div>
                            ` : ''}
                            ${node.textualReference ? `
                                <div style="flex: 1; min-width: 200px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“– Reference</div>
                                    <div style="font-size: 13px; line-height: 1.5; color: var(--text-primary); font-family: monospace;">${node.textualReference}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // THESIS - Academic structure with argument â†’ evidence
            else if (currentPattern === 'thesis' && (node.keyArgument || node.citations || node.evidenceType)) {
                const progressPercent = node.targetWordCount ? Math.min(100, Math.round((node.wordCount / node.targetWordCount) * 100)) : 0;

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(16, 185, 129, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #10B981; margin-bottom: 8px;">ðŸŽ“ Academic Section</div>
                        </div>

                        <!-- Word Count Progress -->
                        ${node.wordCount !== undefined || node.targetWordCount ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-radius: 10px; margin-bottom: 20px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="font-size: 13px; color: var(--text-secondary);">ðŸ“ Word Count</span>
                                    <span style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.wordCount || 0} / ${node.targetWordCount || '?'} words</span>
                                </div>
                                ${node.targetWordCount ? `
                                    <div style="width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; overflow: hidden;">
                                        <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                    <div style="text-align: center; margin-top: 6px; font-size: 12px; color: var(--text-secondary);">${progressPercent}% complete</div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Draft Status + Evidence Type -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.draftStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Status</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B;">âœï¸ ${node.draftStatus}</div>
                                </div>
                            ` : ''}
                            ${node.evidenceType ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Evidence</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">ðŸ”¬ ${node.evidenceType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Key Argument (Central claim) -->
                        ${node.keyArgument ? `
                            <div style="padding: 16px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase;">ðŸ’¡ Key Argument</div>
                                <div style="font-size: 14px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.keyArgument}</div>
                            </div>
                        ` : ''}

                        <!-- Citations -->
                        ${node.citations ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid #9ca3af; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">ðŸ“š Key Citations</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.citations}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // ROADMAP - Feature card with user impact & technical risk
            else if (currentPattern === 'roadmap' && (node.storyPoints || node.userImpact || node.technicalRisk)) {
                const impactColors = { 'High': '#10B981', 'Medium': '#F59E0B', 'Low': '#9CA3AF' };
                const riskColors = { 'Low': '#10B981', 'Medium': '#F59E0B', 'High': '#EF4444', 'Unknown': '#9CA3AF' };

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ðŸš€ Product Feature</div>
                        </div>

                        <!-- Story Points (Large) -->
                        ${node.storyPoints !== undefined ? `
                            <div style="text-align: center; padding: 24px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.1)); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">Effort Estimate</div>
                                <div style="font-size: 48px; font-weight: 700; color: var(--treeplex-primary); line-height: 1;">${node.storyPoints}</div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">Story Points</div>
                            </div>
                        ` : ''}

                        <!-- Impact & Risk Matrix -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
                            ${node.userImpact ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(impactColors[node.userImpact].slice(1, 3), 16)}, ${parseInt(impactColors[node.userImpact].slice(3, 5), 16)}, ${parseInt(impactColors[node.userImpact].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">User Impact</div>
                                    <div style="font-size: 20px; font-weight: 700; color: ${impactColors[node.userImpact]};">ðŸ‘¥ ${node.userImpact}</div>
                                </div>
                            ` : ''}
                            ${node.technicalRisk ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(riskColors[node.technicalRisk].slice(1, 3), 16)}, ${parseInt(riskColors[node.technicalRisk].slice(3, 5), 16)}, ${parseInt(riskColors[node.technicalRisk].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Technical Risk</div>
                                    <div style="font-size: 20px; font-weight: 700; color: ${riskColors[node.technicalRisk]};">âš ï¸ ${node.technicalRisk}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Engineering Estimate & Feature Flag -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.engineeringEstimate ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">â±ï¸ Estimate</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.engineeringEstimate}</div>
                                </div>
                            ` : ''}
                            ${node.featureFlag ? `
                                <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸš© Feature Flag</div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--treeplex-primary); font-family: monospace;">${node.featureFlag}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // PROMPTING - Layered prompt structure
            else if (currentPattern === 'prompting' && (node.systemPrompt || node.userPromptTemplate || node.fewShotExamples)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(167, 139, 250, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(139, 92, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #8B5CF6; margin-bottom: 8px;">ðŸ§  Prompt Structure</div>
                        </div>

                        <!-- Model + Temperature -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                            ${node.modelTarget ? `
                                <div style="flex: 1; min-width: 180px; padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Target Model</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #60A5FA;">ðŸ¤– ${node.modelTarget}</div>
                                </div>
                            ` : ''}
                            ${node.temperature !== undefined ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Temperature</div>
                                    <div style="font-size: 18px; font-weight: 700; color: #F59E0B;">ðŸ”¥ ${node.temperature}</div>
                                </div>
                            ` : ''}
                            ${node.maxTokens ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Max Tokens</div>
                                    <div style="font-size: 18px; font-weight: 700; color: #10B981;">ðŸ“ ${node.maxTokens}</div>
                                </div>
                            ` : ''}
                            ${node.testStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Status</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #A78BFA;">âœ… ${node.testStatus}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Layered Structure -->
                        ${node.systemPrompt ? `
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #8B5CF6; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 1: SYSTEM</span>
                                </div>
                                <div style="padding: 14px; background: rgba(139, 92, 246, 0.12); border-left: 4px solid #8B5CF6; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.systemPrompt}</div>
                                </div>
                            </div>
                        ` : ''}

                        ${node.userPromptTemplate ? `
                            <div style="text-align: center; margin: 12px 0; font-size: 18px; color: var(--treeplex-primary);">â†“</div>
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #3B82F6; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 2: USER PROMPT</span>
                                </div>
                                <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.userPromptTemplate}</div>
                                </div>
                            </div>
                        ` : ''}

                        ${node.fewShotExamples ? `
                            <div style="text-align: center; margin: 12px 0; font-size: 18px; color: var(--treeplex-primary);">â†“</div>
                            <div style="margin-bottom: 12px;">
                                <div style="text-align: center; margin-bottom: 8px;">
                                    <span style="display: inline-block; padding: 6px 12px; background: #10B981; color: white; border-radius: 20px; font-size: 11px; font-weight: 700;">LAYER 3: FEW-SHOT EXAMPLES</span>
                                </div>
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px;">
                                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${node.fewShotExamples}</div>
                                </div>
                            </div>
                        ` : ''}

                        <!-- Test Results -->
                        ${node.testResults ? `
                            <div style="padding: 14px; background: rgba(245, 158, 11, 0.12); border-left: 4px solid #F59E0B; border-radius: 8px; margin-top: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 6px; text-transform: uppercase;">âœ… Test Results</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.testResults}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // BOOK - Narrative arc card
            else if (currentPattern === 'book' && (node.povCharacter || node.sceneSetting || node.plotFunction)) {
                const progressPercent = node.targetWordCount ? Math.min(100, Math.round((node.wordCount / node.targetWordCount) * 100)) : 0;

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.08), rgba(251, 146, 60, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(245, 158, 11, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #F59E0B; margin-bottom: 8px;">ðŸ“š Narrative Scene</div>
                        </div>

                        <!-- Word Count -->
                        ${node.wordCount !== undefined || node.targetWordCount ? `
                            <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-radius: 10px; margin-bottom: 16px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 12px; color: var(--text-secondary);">ðŸ“ Words</span>
                                    <span style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.wordCount || 0} / ${node.targetWordCount || '?'}</span>
                                </div>
                                ${node.targetWordCount ? `
                                    <div style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden;">
                                        <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #3B82F6, #2563EB); transition: width 0.3s;"></div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- POV + Plot Function -->
                        <div style="display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">
                            ${node.povCharacter ? `
                                <div style="flex: 1; min-width: 180px; padding: 14px; background: rgba(139, 92, 246, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‘¤ POV Character</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #A78BFA;">${node.povCharacter}</div>
                                </div>
                            ` : ''}
                            ${node.plotFunction ? `
                                <div style="flex: 1; min-width: 180px; padding: 14px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“– Plot Function</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #10B981;">${node.plotFunction}</div>
                                </div>
                            ` : ''}
                            ${node.draftStatus ? `
                                <div style="flex: 1; min-width: 140px; padding: 14px; background: rgba(245, 158, 11, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">Status</div>
                                    <div style="font-size: 15px; font-weight: 600; color: #F59E0B;">âœï¸ ${node.draftStatus}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Scene Setting -->
                        ${node.sceneSetting ? `
                            <div style="padding: 16px; background: rgba(0, 0, 0, 0.3); border-left: 4px solid #F59E0B; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 8px; text-transform: uppercase;">ðŸŽ­ Scene Setting</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.sceneSetting}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // COURSE - Learning module
            else if (currentPattern === 'course' && (node.learningObjectives || node.duration || node.assessmentType)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(96, 165, 250, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">ðŸ“– Learning Module</div>
                        </div>

                        <!-- Duration + Difficulty + Assessment -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #10B981;">â±ï¸ ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.difficultyLevel ? `
                                <div style="padding: 12px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Level</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B;">ðŸ“Š ${node.difficultyLevel}</div>
                                </div>
                            ` : ''}
                            ${node.assessmentType ? `
                                <div style="padding: 12px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Assessment</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #A78BFA;">âœ… ${node.assessmentType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Learning Objectives -->
                        ${node.learningObjectives ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase;">ðŸŽ“ Learning Objectives</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.learningObjectives}</div>
                            </div>
                        ` : ''}

                        <!-- Prerequisites & Resources -->
                        ${node.prerequisites || node.resourcesNeeded ? `
                            <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                                ${node.prerequisites ? `
                                    <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">ðŸ“‹ Prerequisites</div>
                                        <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.prerequisites}</div>
                                    </div>
                                ` : ''}
                                ${node.resourcesNeeded ? `
                                    <div style="flex: 1; min-width: 200px; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase;">ðŸ“š Resources</div>
                                        <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.resourcesNeeded}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // EVENT PLANNING - Timeline with logistics grid
            else if (currentPattern === 'event' && (node.budget || node.vendor || node.guestCount || node.bookingDeadline)) {
                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(236, 72, 153, 0.08), rgba(219, 39, 119, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(236, 72, 153, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #EC4899; margin-bottom: 8px;">ðŸŽ‰ Event Activity</div>
                        </div>

                        <!-- Budget + Guest Count -->
                        <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                            ${node.budget !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ðŸ’° Budget</div>
                                    <div style="font-size: 28px; font-weight: 700; color: #10B981;">$${node.budget.toLocaleString()}</div>
                                </div>
                            ` : ''}
                            ${node.guestCount !== undefined ? `
                                <div style="flex: 1; padding: 20px; background: rgba(59, 130, 246, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">ðŸ‘¥ Guests</div>
                                    <div style="font-size: 28px; font-weight: 700; color: #3B82F6;">${node.guestCount}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Vendor + Location + Deadline -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            ${node.vendor ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ¢ Vendor</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.vendor}</div>
                                </div>
                            ` : ''}
                            ${node.location ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“ Location</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.location}</div>
                                </div>
                            ` : ''}
                            ${node.responsiblePerson ? `
                                <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‘¤ Owner</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.responsiblePerson}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Booking Deadline (Urgent Banner) -->
                        ${node.bookingDeadline ? `
                            <div style="padding: 16px; background: rgba(245, 158, 11, 0.15); border-left: 4px solid #F59E0B; border-radius: 8px; text-align: center;">
                                <div style="font-size: 11px; font-weight: 700; color: #F59E0B; margin-bottom: 6px; text-transform: uppercase;">ðŸ“… Booking Deadline</div>
                                <div style="font-size: 18px; font-weight: 700; color: var(--text-primary);">${new Date(node.bookingDeadline).toLocaleDateString('en-US', {weekday: 'long', month: 'short', day: 'numeric', year: 'numeric'})}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FITNESS PROGRAM - Exercise card with sets/reps grid
            else if (currentPattern === 'fitness' && (node.sets || node.reps || node.duration || node.intensity)) {
                const intensityColors = { 'Light': '#10B981', 'Moderate': '#F59E0B', 'High': '#EF4444', 'Max': '#DC2626' };
                const intensityColor = intensityColors[node.intensity] || '#9CA3AF';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.08), rgba(220, 38, 38, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(239, 68, 68, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #EF4444; margin-bottom: 8px;">ðŸ’ª Exercise Specification</div>
                        </div>

                        <!-- Sets Ã— Reps (Large Display) -->
                        ${node.sets || node.reps ? `
                            <div style="text-align: center; padding: 24px; background: rgba(239, 68, 68, 0.15); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 48px; font-weight: 700; color: #EF4444; line-height: 1;">
                                    ${node.sets || '?'} <span style="font-size: 32px; color: var(--text-secondary);">Ã—</span> ${node.reps || '?'}
                                </div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-top: 8px;">Sets Ã— Reps</div>
                            </div>
                        ` : ''}

                        <!-- Duration + Intensity + Rest -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.duration ? `
                                <div style="padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Duration</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #3B82F6;">â±ï¸ ${node.duration}</div>
                                </div>
                            ` : ''}
                            ${node.intensity ? `
                                <div style="padding: 12px; background: rgba(${parseInt(intensityColor.slice(1, 3), 16)}, ${parseInt(intensityColor.slice(3, 5), 16)}, ${parseInt(intensityColor.slice(5, 7), 16)}, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Intensity</div>
                                    <div style="font-size: 16px; font-weight: 600; color: ${intensityColor};">ðŸ”¥ ${node.intensity}</div>
                                </div>
                            ` : ''}
                            ${node.restPeriod ? `
                                <div style="padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Rest</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #10B981;">â¸ï¸ ${node.restPeriod}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Equipment -->
                        ${node.equipment ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‹ï¸ Equipment</div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.equipment}</div>
                            </div>
                        ` : ''}

                        <!-- Form Cues -->
                        ${node.formCues ? `
                            <div style="padding: 16px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 8px; text-transform: uppercase;">âœ… Form Cues</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary); white-space: pre-wrap;">${node.formCues}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // STRATEGY - Strategic initiative card with metrics
            else if (currentPattern === 'strategy' && (node.investment || node.keyMetric || node.strategicTheme)) {
                const themeColors = { 'Growth': '#10B981', 'Efficiency': '#3B82F6', 'Innovation': '#8B5CF6', 'Transformation': '#F59E0B', 'Risk Mitigation': '#EF4444' };
                const themeColor = themeColors[node.strategicTheme] || '#9CA3AF';
                const riskColors = { 'Low': '#10B981', 'Medium': '#F59E0B', 'High': '#EF4444' };

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(37, 99, 235, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">ðŸ“Š Strategic Initiative</div>
                        </div>

                        <!-- Investment (Large) -->
                        ${node.investment !== undefined ? `
                            <div style="text-align: center; padding: 24px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1)); border-radius: 12px; margin-bottom: 20px;">
                                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">Capital Investment</div>
                                <div style="font-size: 40px; font-weight: 700; color: #10B981; line-height: 1;">$${node.investment.toLocaleString()}</div>
                            </div>
                        ` : ''}

                        <!-- Strategic Theme + Risk Level -->
                        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
                            ${node.strategicTheme ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(themeColor.slice(1, 3), 16)}, ${parseInt(themeColor.slice(3, 5), 16)}, ${parseInt(themeColor.slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Theme</div>
                                    <div style="font-size: 18px; font-weight: 700; color: ${themeColor};">ðŸŽ­ ${node.strategicTheme}</div>
                                </div>
                            ` : ''}
                            ${node.riskLevel ? `
                                <div style="flex: 1; padding: 16px; background: rgba(${parseInt(riskColors[node.riskLevel].slice(1, 3), 16)}, ${parseInt(riskColors[node.riskLevel].slice(3, 5), 16)}, ${parseInt(riskColors[node.riskLevel].slice(5, 7), 16)}, 0.15); border-radius: 10px; text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Risk</div>
                                    <div style="font-size: 18px; font-weight: 700; color: ${riskColors[node.riskLevel]};">âš ï¸ ${node.riskLevel}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Key Metric â†’ Target Value -->
                        ${node.keyMetric || node.targetValue ? `
                            <div style="margin-bottom: 20px;">
                                <div style="text-align: center; font-size: 12px; font-weight: 700; color: #3B82F6; margin-bottom: 12px; text-transform: uppercase;">ðŸ“ˆ Success Metrics</div>
                                ${node.keyMetric ? `
                                    <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 10px;">
                                        <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 4px; text-transform: uppercase;">ðŸ“Š Key Metric</div>
                                        <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.keyMetric}</div>
                                    </div>
                                ` : ''}
                                ${node.targetValue ? `
                                    <div style="text-align: center; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸŽ¯ Target</div>
                                        <div style="font-size: 20px; font-weight: 700; color: #10B981;">${node.targetValue}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Executive Owner -->
                        ${node.responsibleExecutive ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‘” Executive Sponsor</div>
                                <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${node.responsibleExecutive}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FAMILY TREE - Person card with genealogy info
            else if (currentPattern === 'familytree' && (node.fullName || node.birthDate || node.birthPlace)) {
                const isLiving = node.livingStatus === 'Living';
                const statusColor = isLiving ? '#10B981' : '#9CA3AF';

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(124, 58, 237, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(139, 92, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #8B5CF6; margin-bottom: 8px;">ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family Member</div>
                        </div>

                        <!-- Full Name + Living Status -->
                        ${node.fullName ? `
                            <div style="text-align: center; padding: 20px; background: rgba(139, 92, 246, 0.15); border-radius: 10px; margin-bottom: 20px;">
                                <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">${node.fullName}</div>
                                ${node.maidenName ? `<div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;">(nÃ©e ${node.maidenName})</div>` : ''}
                                ${node.livingStatus ? `
                                    <div style="display: inline-block; padding: 6px 14px; background: rgba(${parseInt(statusColor.slice(1, 3), 16)}, ${parseInt(statusColor.slice(3, 5), 16)}, ${parseInt(statusColor.slice(5, 7), 16)}, 0.2); border-radius: 20px; font-size: 12px; font-weight: 600; color: ${statusColor};">
                                        ${isLiving ? 'ðŸ’š' : 'ðŸ•Šï¸'} ${node.livingStatus}
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Birth & Death Info -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            ${node.birthDate || node.birthPlace ? `
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.12); border-left: 4px solid #10B981; border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: #10B981; margin-bottom: 8px; text-transform: uppercase;">ðŸŽ‚ Birth</div>
                                    ${node.birthDate ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${new Date(node.birthDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                    ${node.birthPlace ? `<div style="font-size: 13px; color: var(--text-secondary);">ðŸ“ ${node.birthPlace}</div>` : ''}
                                </div>
                            ` : ''}
                            ${node.deathDate || node.deathPlace ? `
                                <div style="padding: 14px; background: rgba(156, 163, 175, 0.12); border-left: 4px solid #9CA3AF; border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: #9CA3AF; margin-bottom: 8px; text-transform: uppercase;">ðŸ•Šï¸ Death</div>
                                    ${node.deathDate ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${new Date(node.deathDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                    ${node.deathPlace ? `<div style="font-size: 13px; color: var(--text-secondary);">ðŸ“ ${node.deathPlace}</div>` : ''}
                                </div>
                            ` : ''}
                        </div>

                        <!-- Marriage & Family -->
                        ${node.spouseName || node.marriageDate ? `
                            <div style="padding: 14px; background: rgba(236, 72, 153, 0.12); border-left: 4px solid #EC4899; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #EC4899; margin-bottom: 8px; text-transform: uppercase;">ðŸ’‘ Marriage</div>
                                ${node.spouseName ? `<div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">Spouse: ${node.spouseName}</div>` : ''}
                                ${node.marriageDate ? `<div style="font-size: 13px; color: var(--text-secondary);">${new Date(node.marriageDate).toLocaleDateString('en-US', {month: 'long', day: 'numeric', year: 'numeric'})}</div>` : ''}
                                ${node.marriagePlace ? `<div style="font-size: 13px; color: var(--text-secondary);">ðŸ“ ${node.marriagePlace}</div>` : ''}
                            </div>
                        ` : ''}

                        <!-- Occupation & Gender & Relationship -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 16px;">
                            ${node.gender ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Gender</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">âš§ ${node.gender}</div>
                                </div>
                            ` : ''}
                            ${node.occupation ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Occupation</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">ðŸ’¼ ${node.occupation}</div>
                                </div>
                            ` : ''}
                            ${node.relationshipType ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">Relationship</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">ðŸ”— ${node.relationshipType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- DNA Info -->
                        ${node.dnaInfo ? `
                            <div style="padding: 14px; background: rgba(59, 130, 246, 0.12); border-left: 4px solid #3B82F6; border-radius: 8px; margin-bottom: 16px;">
                                <div style="font-size: 11px; font-weight: 700; color: #3B82F6; margin-bottom: 6px; text-transform: uppercase;">ðŸ§¬ DNA / Genetic Info</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.dnaInfo}</div>
                            </div>
                        ` : ''}

                        <!-- Sources -->
                        ${node.sources ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid #9ca3af; border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“„ Sources</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); white-space: pre-wrap;">${node.sources}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILE SYSTEM - File preview/open button with thumbnail
            else if (currentPattern === 'filesystem' && !node.isFolder && (node.fileUrl || node.filePath)) {
                // Format file size
                const formatFileSize = (bytes) => {
                    if (!bytes) return 'Unknown size';
                    if (bytes < 1024) return bytes + ' B';
                    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                    if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                    return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
                };

                // Get file icon based on extension
                const fileIcon = node.icon || getFileIcon(node.name, false);
                const fileSize = formatFileSize(node.fileSize);

                patternInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(99, 102, 241, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 8px;">ðŸ’¾ File Details</div>
                        </div>

                        <!-- File Thumbnail/Icon & Open Button -->
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 16px; margin-bottom: 20px;">
                            <!-- Large Icon -->
                            <div style="font-size: 80px; line-height: 1;">${fileIcon}</div>

                            <!-- File Name -->
                            <div style="font-size: 18px; font-weight: 600; color: var(--text-primary); text-align: center; word-break: break-all;">
                                ${node.name}
                            </div>

                            <!-- Open File Button -->
                            ${node.fileUrl ? `
                                <button onclick="window.open('${node.fileUrl}', '_blank')"
                                        style="padding: 14px 32px;
                                               background: linear-gradient(135deg, #6366f1, #8b5cf6);
                                               border: none;
                                               border-radius: 12px;
                                               color: white;
                                               font-size: 16px;
                                               font-weight: 700;
                                               cursor: pointer;
                                               transition: all 0.2s;
                                               box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);"
                                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(99, 102, 241, 0.4)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(99, 102, 241, 0.3)'">
                                    ðŸ”— Open File
                                </button>
                            ` : ''}
                        </div>

                        <!-- File Metadata Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px;">
                            ${node.fileSize ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ“Š Size</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${fileSize}</div>
                                </div>
                            ` : ''}
                            ${node.fileExtension ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ·ï¸ Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.fileExtension}</div>
                                </div>
                            ` : ''}
                            ${node.dateModified ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ•’ Modified</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary);">${new Date(node.dateModified).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                            ${node.dateCreated ? `
                                <div style="padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ“… Created</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary);">${new Date(node.dateCreated).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- File Path -->
                        ${node.filePath ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-left: 4px solid var(--treeplex-primary); border-radius: 8px; margin-bottom: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“‚ Path</div>
                                <div style="font-size: 12px; line-height: 1.5; color: var(--text-primary); font-family: monospace; word-break: break-all;">${node.filePath}</div>
                            </div>
                        ` : ''}

                        <!-- Permissions & Owner -->
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            ${node.permissions ? `
                                <div style="flex: 1; min-width: 150px; padding: 12px; background: rgba(16, 185, 129, 0.15); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">ðŸ”’ Permissions</div>
                                    <div style="font-size: 13px; font-weight: 600; color: #10B981;">${node.permissions}</div>
                                </div>
                            ` : ''}
                            ${node.fileOwner ? `
                                <div style="flex: 1; min-width: 150px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                    <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; text-transform: uppercase;">ðŸ‘¤ Owner</div>
                                    <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${node.fileOwner}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Shared With -->
                        ${node.sharedWith ? `
                            <div style="padding: 14px; background: rgba(168, 85, 247, 0.15); border-left: 4px solid #a855f7; border-radius: 8px; margin-top: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: #a855f7; margin-bottom: 6px; text-transform: uppercase;">ðŸ‘¥ Shared With</div>
                                <div style="font-size: 13px; line-height: 1.6; color: var(--text-primary);">${node.sharedWith}</div>
                            </div>
                        ` : ''}

                        <!-- Tags -->
                        ${node.tags ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-top: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ·ï¸ Tags</div>
                                <div style="font-size: 13px; color: var(--text-primary);">${node.tags}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // FILESYSTEM - File/Folder info card with Open button
            let filesystemInfoHtml = '';
            if (currentPattern === 'filesystem' && node.type === 'item') {
                const formatFileSize = (bytes) => {
                    if (!bytes || bytes === 0) return 'N/A';
                    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
                    let size = bytes;
                    let unitIndex = 0;
                    while (size >= 1024 && unitIndex < units.length - 1) {
                        size /= 1024;
                        unitIndex++;
                    }
                    return `${size.toFixed(2)} ${units[unitIndex]}`;
                };

                const formatDate = (dateStr) => {
                    if (!dateStr) return 'N/A';
                    try {
                        return new Date(dateStr).toLocaleString('en-US', {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                    } catch (e) {
                        return dateStr;
                    }
                };

                // Determine if it's a folder or file
                const isFolder = node.isFolder === true;
                const entityType = isFolder ? 'Folder' : 'File';
                const entityIcon = isFolder ? 'ðŸ“' : node.icon || 'ðŸ“„';

                filesystemInfoHtml = `
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(99, 102, 241, 0.08)); border-radius: 12px; padding: 20px; margin-bottom: 24px; border: 2px solid rgba(59, 130, 246, 0.3);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 18px; font-weight: 700; color: #3B82F6; margin-bottom: 8px;">${entityIcon} ${entityType} Details</div>
                        </div>

                        <!-- Open Button (Prominent) -->
                        ${node.fileUrl || node.filePath ? `
                            <div style="text-align: center; margin-bottom: 20px;">
                                <button onclick="window.open('${node.fileUrl || node.filePath}', '_blank')" style="
                                    padding: 16px 32px;
                                    background: linear-gradient(135deg, var(--treeplex-primary), var(--treeplex-primary-dark));
                                    color: white;
                                    border: none;
                                    border-radius: 12px;
                                    font-size: 16px;
                                    font-weight: 700;
                                    cursor: pointer;
                                    display: inline-flex;
                                    align-items: center;
                                    gap: 10px;
                                    transition: all 0.3s;
                                    box-shadow: 0 4px 12px rgba(0, 166, 125, 0.3);
                                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0, 166, 125, 0.4)';" onmouseout="this.style.transform=''; this.style.boxShadow='0 4px 12px rgba(0, 166, 125, 0.3)';">
                                    <span style="font-size: 20px;">ðŸ”—</span>
                                    <span>Open ${isFolder ? 'Folder' : 'File'}</span>
                                </button>
                            </div>
                        ` : ''}

                        <!-- File/Folder Metadata Grid -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 16px;">
                            ${!isFolder && node.fileSize !== undefined ? `
                                <div style="padding: 14px; background: rgba(16, 185, 129, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ’¾ Size</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #10B981;">${formatFileSize(node.fileSize)}</div>
                                </div>
                            ` : ''}
                            ${node.fileExtension ? `
                                <div style="padding: 14px; background: rgba(245, 158, 11, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ“‹ Type</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #F59E0B; font-family: monospace;">${node.fileExtension}</div>
                                </div>
                            ` : ''}
                            ${node.mimeType ? `
                                <div style="padding: 14px; background: rgba(139, 92, 246, 0.15); border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ðŸ”– MIME</div>
                                    <div style="font-size: 11px; font-weight: 600; color: #A78BFA; font-family: monospace; word-break: break-all;">${node.mimeType}</div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Dates -->
                        ${node.dateModified || node.dateCreated ? `
                            <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                                ${node.dateModified ? `
                                    <div style="flex: 1; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“… Modified</div>
                                        <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${formatDate(node.dateModified)}</div>
                                    </div>
                                ` : ''}
                                ${node.dateCreated ? `
                                    <div style="flex: 1; padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                        <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ†• Created</div>
                                        <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${formatDate(node.dateCreated)}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <!-- Owner & Path -->
                        ${node.fileOwner ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 12px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ‘¤ Owner</div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${node.fileOwner}</div>
                            </div>
                        ` : ''}
                        ${node.filePath ? `
                            <div style="padding: 14px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                <div style="font-size: 11px; font-weight: 700; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase;">ðŸ“‚ Path</div>
                                <div style="font-size: 12px; color: var(--text-primary); font-family: monospace; word-break: break-all;">${node.filePath}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            body.innerHTML = `
                <!-- HERO: Description Field (Primary Content) -->
                <div style="margin-bottom: 20px; padding: 20px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.08), rgba(0, 140, 105, 0.04)); border-radius: 12px; border: 1px solid rgba(0, 166, 125, 0.2);">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                        <span style="font-size: 18px;">ðŸ“</span>
                        <span style="font-size: 13px; font-weight: 600; color: var(--treeplex-primary); text-transform: uppercase; letter-spacing: 0.5px;">Description</span>
                    </div>
                    <div style="font-size: 15px; line-height: 1.7; color: var(--text-primary); white-space: pre-wrap;">${node.description || node.subtitle || '<span style="color: var(--text-secondary); font-style: italic;">No description yet. Double-click to edit.</span>'}</div>
                </div>

                <!-- Metadata Row: Type + ID + Cost (compact) -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                    <div style="flex: 1; min-width: 100px; padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 8px; border: 1px solid var(--border);">
                        <div style="font-size: 10px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 4px;">Type</div>
                        <div style="font-size: 13px; font-weight: 500; color: var(--text-primary);">${node.itemType || node.type || 'N/A'}</div>
                    </div>
                    <div style="flex: 1; min-width: 140px; padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 8px; border: 1px solid var(--border);">
                        <div style="font-size: 10px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 4px;">ID</div>
                        <div style="font-size: 11px; font-family: monospace; color: var(--text-secondary); word-break: break-all;">${node.id || 'N/A'}</div>
                    </div>
                    ${PATTERNS[currentPattern].fields?.cost && node.cost > 0 ? `
                    <div style="flex: 1; min-width: 100px; padding: 12px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05)); border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.3);">
                        <div style="font-size: 10px; font-weight: 600; color: #10B981; text-transform: uppercase; margin-bottom: 4px;">Cost</div>
                        <div style="font-size: 15px; font-weight: 700; color: #10B981;">${formatCost(node.cost)}</div>
                    </div>
                    ` : ''}
                </div>

                ${node.type === 'root' && PATTERNS[currentPattern].fields?.cost && calculateTotal(node) > 0 ? `
                <div style="padding: 16px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.08)); border-radius: 10px; border: 2px solid rgba(16, 185, 129, 0.4); margin-bottom: 20px; text-align: center;">
                    <div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 6px;">Total Project Cost</div>
                    <div style="font-size: 28px; font-weight: 700; color: #10B981;">${formatCost(calculateTotal(node))}</div>
                </div>
                ` : ''}

                ${pmDashboardHtml}
                ${patternInfoHtml}
                ${filesystemInfoHtml}
                ${node.alternateSource ? `
                    <div class="info-section">
                        <h4>Alternate Source</h4>
                        <p style="font-size: 14px; line-height: 1.6;">ðŸ“¦ ${node.alternateSource}</p>
                    </div>
                ` : ''}
                ${node.leadTime ? `
                    <div class="info-section">
                        <h4>Lead Time</h4>
                        <p style="font-size: 14px; line-height: 1.6;">â±ï¸ ${node.leadTime}</p>
                    </div>
                ` : ''}
                ${node.notes ? `
                    <div class="info-section">
                        <h4>Context Notes</h4>
                        <p style="background: var(--bg); padding: 12px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary); font-size: 13px; line-height: 1.6; white-space: pre-wrap;">${node.notes}</p>
                    </div>
                ` : ''}
                ${depsHtml}
                ${dependentsHtml}
                ${node.type === 'phase' && PATTERNS[currentPattern].fields?.cost && calculatePhaseTotal(node) > 0 ? `
                    <div class="info-section">
                        <h4>Phase Total</h4>
                        <p class="value">${formatCost(calculatePhaseTotal(node))}</p>
                    </div>
                ` : ''}
                ${node.type === 'root' && PATTERNS[currentPattern].fields?.cost && calculateTotal(node) > 0 ? `
                    <div class="info-section">
                        <h4>Total Cost</h4>
                        <p class="value">${formatCost(calculateTotal(node))}</p>
                    </div>
                ` : ''}
                ${node.type === 'root' && node.hyperedges && node.hyperedges.length > 0 ? `
                    <div class="info-section">
                        <h4>Hyperedges (Groups)</h4>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            ${node.hyperedges.map(h => `
                                <div style="display: flex; align-items: center; justify-content: space-between; background: rgba(255,255,255,0.05); padding: 10px 12px; border-radius: 8px; border-left: 3px solid ${h.type === 'montage' ? '#fb923c' : h.type === 'argument' ? '#3b82f6' : h.type === 'theme' ? '#a855f7' : h.type === 'dependency-cluster' ? '#22c55e' : '#9ca3af'};">
                                    <div style="flex: 1;">
                                        <span style="font-size: 14px; font-weight: 500;">${h.label || 'Unnamed Group'}</span>
                                        <span style="opacity: 0.5; font-size: 12px; margin-left: 8px;">(${h.type || 'group'})</span>
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">${h.nodeIds?.length || 0} nodes</div>
                                    </div>
                                    <button onclick="window.deleteHyperedge('${h.id}')" style="background: rgba(239, 68, 68, 0.2); border: none; cursor: pointer; font-size: 14px; padding: 6px 10px; border-radius: 6px; color: #ef4444;" title="Delete hyperedge">ðŸ—‘ï¸</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            `;

            panel.classList.add('open');
            currentOpenItemId = node.id;

            // Reposition hyperedge panel if it's open
            repositionHyperedgePanel(true);

            // Build 411: Update reader navigation bar
            updateReaderNav();
        }

        // Track which item's panel is currently open
        let currentOpenItemId = null;

        // ========================================================================
        // BUILD 411: READER NAVIGATION
        // Sequential prev/next navigation through all nodes
        // ========================================================================

        // Reader navigation state
        const readerNavState = {
            linearList: [],      // Flattened list of all nodes
            currentIndex: -1,    // Current position in the list
            readModeActive: false // Read mode toggle state
        };

        // Load read mode preference from localStorage
        readerNavState.readModeActive = localStorage.getItem('treelistyReadMode') === 'true';

        /**
         * Flatten tree into linear node list (depth-first traversal)
         * Respects current sort/filter if active
         * @returns {Array} Array of node objects
         */
        function getLinearNodeList() {
            const list = [];

            function traverse(node, depth = 0) {
                // Add this node to the list
                list.push({ node, depth });

                // For root node, traverse children (phases)
                if (node.type === 'root' && node.children) {
                    node.children.forEach(phase => traverse(phase, depth + 1));
                }

                // For phases, traverse items
                if (node.type === 'phase' && node.items) {
                    node.items.forEach(item => traverse(item, depth + 1));
                }

                // For items and subtasks, traverse subtasks
                if ((node.type === 'item' || node.type === 'subtask') && node.subtasks) {
                    node.subtasks.forEach(subtask => traverse(subtask, depth + 1));
                }
            }

            // Start from root
            if (capexTree) {
                traverse(capexTree, 0);
            }

            return list;
        }

        /**
         * Update the reader nav bar in info panel
         */
        function updateReaderNav() {
            const readerNav = document.getElementById('reader-nav');
            const prevBtn = document.getElementById('reader-prev');
            const nextBtn = document.getElementById('reader-next');
            const positionText = document.getElementById('reader-position');
            const readModeBtn = document.getElementById('reader-mode-toggle');
            const infoPanel = document.getElementById('info-panel');

            if (!readerNav || !currentOpenItemId) {
                if (readerNav) readerNav.style.display = 'none';
                return;
            }

            // Rebuild linear list
            readerNavState.linearList = getLinearNodeList();

            // Find current index
            readerNavState.currentIndex = readerNavState.linearList.findIndex(
                entry => entry.node.id === currentOpenItemId
            );

            const total = readerNavState.linearList.length;
            const current = readerNavState.currentIndex + 1;

            if (total <= 1) {
                // Hide nav for single-node trees
                readerNav.style.display = 'none';
                return;
            }

            // Show nav bar
            readerNav.style.display = 'flex';

            // Update position text
            positionText.textContent = `${current} of ${total}`;

            // Update button states
            prevBtn.disabled = readerNavState.currentIndex <= 0;
            nextBtn.disabled = readerNavState.currentIndex >= total - 1;

            // Update read mode button state
            if (readModeBtn) {
                readModeBtn.classList.toggle('active', readerNavState.readModeActive);
            }

            // Apply read mode class to info panel
            if (infoPanel) {
                infoPanel.classList.toggle('read-mode', readerNavState.readModeActive);
            }

            // Highlight current node in tree view
            highlightCurrentNodeInTree();
        }

        /**
         * Navigate to a specific node by index
         * @param {number} index - Index in the linear list
         */
        function navigateToNode(index) {
            if (index < 0 || index >= readerNavState.linearList.length) return;

            const entry = readerNavState.linearList[index];
            if (!entry || !entry.node) return;

            // Show the node in the info panel
            showInfo(entry.node);

            // Scroll the tree view to the node
            scrollToNodeInTree(entry.node.id);
        }

        /**
         * Navigate to previous node
         */
        function navigatePrev() {
            if (readerNavState.currentIndex > 0) {
                navigateToNode(readerNavState.currentIndex - 1);
            }
        }

        /**
         * Navigate to next node
         */
        function navigateNext() {
            if (readerNavState.currentIndex < readerNavState.linearList.length - 1) {
                navigateToNode(readerNavState.currentIndex + 1);
            }
        }

        /**
         * Toggle read mode on/off
         */
        function toggleReadMode() {
            readerNavState.readModeActive = !readerNavState.readModeActive;
            localStorage.setItem('treelistyReadMode', readerNavState.readModeActive);
            updateReaderNav();
        }

        /**
         * Highlight the current node in tree view with visual indicator
         */
        function highlightCurrentNodeInTree() {
            // Remove existing highlight
            document.querySelectorAll('.tree-node.reader-current').forEach(el => {
                el.classList.remove('reader-current');
            });

            if (readerNavState.currentIndex < 0) return;

            const entry = readerNavState.linearList[readerNavState.currentIndex];
            if (!entry || !entry.node) return;

            // Find the node element in tree view
            const nodeEl = document.querySelector(`[data-node-id="${entry.node.id}"]`);
            if (nodeEl) {
                nodeEl.classList.add('reader-current');
            }
        }

        /**
         * Scroll tree view to show a specific node
         * @param {string} nodeId - ID of the node to scroll to
         */
        function scrollToNodeInTree(nodeId) {
            const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (nodeEl) {
                nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Reader navigation button event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const prevBtn = document.getElementById('reader-prev');
            const nextBtn = document.getElementById('reader-next');
            const readModeBtn = document.getElementById('reader-mode-toggle');

            if (prevBtn) {
                prevBtn.addEventListener('click', navigatePrev);
            }
            if (nextBtn) {
                nextBtn.addEventListener('click', navigateNext);
            }
            if (readModeBtn) {
                readModeBtn.addEventListener('click', toggleReadMode);
            }
        });

        // Keyboard navigation (arrow keys when info panel is open)
        document.addEventListener('keydown', (e) => {
            const infoPanel = document.getElementById('info-panel');
            if (!infoPanel || !infoPanel.classList.contains('open')) return;

            // Don't trigger if user is typing in an input/textarea
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable)) {
                return;
            }

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                navigatePrev();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                navigateNext();
            }
        });

        // ========================================================================
        // END BUILD 411: READER NAVIGATION
        // ========================================================================

        /**
         * Reposition the hyperedge visibility panel based on info panel state
         * @param {boolean} infoPanelOpen - Whether info panel is open
         */
        function repositionHyperedgePanel(infoPanelOpen) {
            const hyperedgePanel = document.getElementById('hyperedge-visibility-panel');
            if (hyperedgePanel) {
                const rightOffset = infoPanelOpen ? 470 : 20;
                hyperedgePanel.style.right = `${rightOffset}px`;
            }
        }

        document.getElementById('close-info').addEventListener('click', () => {
            document.getElementById('info-panel').classList.remove('open');
            currentOpenItemId = null;

            // Reposition hyperedge panel back to right edge
            repositionHyperedgePanel(false);

            // Build 411: Clear reader navigation highlight
            document.querySelectorAll('.tree-node.reader-current').forEach(el => {
                el.classList.remove('reader-current');
            });
        });

        // Context Menu
        function showContextMenu(x, y) {
            const menu = document.getElementById('context-menu');
            const labels = getPatternLabels();

            // Build menu dynamically based on node type
            let menuHtml = '';

            if (activeNode.type === 'item') {
                // Item context menu
                menuHtml = `
                    <div class="context-item" id="ctx-view">ðŸ“‹ View Details</div>
                    <div class="context-item" id="ctx-edit">âœï¸ Edit ${labels.item}</div>
                    <div class="context-item" id="ctx-add-subtask">âž• Add ${labels.subtask}</div>
                    <div class="context-item" id="ctx-attach">ðŸ“Ž Attachments</div>
                    <div class="context-item" id="ctx-delete">ðŸ—‘ï¸ Delete ${labels.item}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ðŸ” Quick Insight</div>
                    <div class="context-item" id="ctx-deep-dive">ðŸŽ“ Deep Dive</div>
                `;
            } else if (activeNode.type === 'subtask') {
                // Subtask context menu (can now have nested subtasks)
                menuHtml = `
                    <div class="context-item" id="ctx-view">ðŸ“‹ View Details</div>
                    <div class="context-item" id="ctx-edit">âœï¸ Edit ${labels.subtask}</div>
                    <div class="context-item" id="ctx-add-subtask">âž• Add Nested ${labels.subtask}</div>
                    <div class="context-item" id="ctx-attach">ðŸ“Ž Attachments</div>
                    <div class="context-item" id="ctx-delete">ðŸ—‘ï¸ Delete ${labels.subtask}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ðŸ” Quick Insight</div>
                    <div class="context-item" id="ctx-deep-dive">ðŸŽ“ Deep Dive</div>
                `;
            } else if (activeNode.type === 'phase') {
                // Phase context menu (Build 391: Added delete option)
                const itemCount = activeNode.items ? activeNode.items.length : 0;
                const deleteWarning = itemCount > 0 ? ` (${itemCount} items)` : '';
                menuHtml = `
                    <div class="context-item" id="ctx-view">ðŸ“‹ View Details</div>
                    <div class="context-item" id="ctx-edit">âœï¸ Edit ${labels.phase}</div>
                    <div class="context-item" id="ctx-create">âž• Add ${labels.item} to ${activeNode.name}</div>
                    <div class="context-item" id="ctx-delete" style="color: #ef4444;">ðŸ—‘ï¸ Delete ${labels.phase}${deleteWarning}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ðŸ” Quick Insight</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">ðŸ’¾ Download JSON</div>
                    <div class="context-item" id="ctx-upload">ðŸ“‚ Upload JSON</div>
                `;
            } else if (activeNode.type === 'root') {
                // Root context menu (Build 260: Edit opens Project Settings)
                menuHtml = `
                    <div class="context-item" id="ctx-view">ðŸ“‹ View Details</div>
                    <div class="context-item" id="ctx-edit">âš™ï¸ Project Settings</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-expand">ðŸ“‚ Expand All</div>
                    <div class="context-item" id="ctx-collapse">ðŸ“ Collapse All</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-ai">ðŸ” ${labels.root} Quick Insight</div>
                    <div class="context-divider"></div>
                    <div class="context-item" id="ctx-download">ðŸ’¾ Download JSON</div>
                    <div class="context-item" id="ctx-upload">ðŸ“‚ Upload JSON</div>
                `;
            }

            menu.innerHTML = menuHtml;
            menu.style.display = 'block';

            // Position menu first (to measure dimensions)
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Check if menu goes off screen and adjust position
            const menuRect = menu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            let finalX = x;
            let finalY = y;

            // Adjust horizontal position if menu goes off right edge
            if (menuRect.right > viewportWidth) {
                finalX = viewportWidth - menuRect.width - 10;
            }

            // Adjust vertical position if menu goes off bottom edge
            if (menuRect.bottom > viewportHeight) {
                finalY = viewportHeight - menuRect.height - 10;
            }

            // Ensure menu doesn't go off left edge
            if (finalX < 10) finalX = 10;

            // Ensure menu doesn't go off top edge
            if (finalY < 10) finalY = 10;

            menu.style.left = finalX + 'px';
            menu.style.top = finalY + 'px';

            // Re-attach event listeners
            attachContextMenuListeners();
        }

        function attachContextMenuListeners() {
            const viewBtn = document.getElementById('ctx-view');
            const editBtn = document.getElementById('ctx-edit');
            const createBtn = document.getElementById('ctx-create');
            const addSubtaskBtn = document.getElementById('ctx-add-subtask');
            const attachBtn = document.getElementById('ctx-attach');
            const deleteBtn = document.getElementById('ctx-delete');
            const aiBtn = document.getElementById('ctx-ai');
            const deepDiveBtn = document.getElementById('ctx-deep-dive');
            const downloadBtn = document.getElementById('ctx-download');
            const uploadBtn = document.getElementById('ctx-upload');
            const expandBtn = document.getElementById('ctx-expand');
            const collapseBtn = document.getElementById('ctx-collapse');

            if (viewBtn) viewBtn.onclick = handleViewDetails;
            if (editBtn) editBtn.onclick = handleEdit;
            if (createBtn) createBtn.onclick = handleCreate;
            if (addSubtaskBtn) addSubtaskBtn.onclick = handleAddSubtask;
            if (attachBtn) attachBtn.onclick = handleAttachments;
            if (deleteBtn) deleteBtn.onclick = handleDelete;
            if (aiBtn) aiBtn.onclick = handleAI;
            if (deepDiveBtn) deepDiveBtn.onclick = () => handleAnalyzeSelection([activeNode]);
            if (downloadBtn) downloadBtn.onclick = handleDownload;
            if (uploadBtn) uploadBtn.onclick = handleUpload;
            if (expandBtn) expandBtn.onclick = handleExpandAll;
            if (collapseBtn) collapseBtn.onclick = handleCollapseAll;
        }

        // BUILD 371: Handle attachments context menu
        function handleAttachments() {
            if (activeNode) {
                document.getElementById('context-menu').style.display = 'none';
                window.openArtifactPanel(activeNode.id, activeNode.name);
            }
        }

        document.addEventListener('click', () => {
            document.getElementById('context-menu').style.display = 'none';
        });

        // Context menu handlers
        function handleViewDetails() {
            if (activeNode) showInfo(activeNode);
        }

        // =============================================================================
        // SMART SUGGESTION ENGINE - AI-Powered with Pattern Expertise
        // =============================================================================

        // Helper: Extract tree context for AI suggestions
        function extractTreeContext(itemContext) {
            const allItems = getAllProjectItems(capexTree);

            // Find current phase
            let currentPhase = null;
            let siblingItems = [];
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    if (phase.items && phase.items.find(item => item.id === itemContext.id)) {
                        currentPhase = phase;
                        siblingItems = phase.items.filter(item => item.id !== itemContext.id);
                        break;
                    }
                }
            }

            // Find items this depends on
            const dependencies = [];
            if (itemContext.dependencies) {
                itemContext.dependencies.forEach(depId => {
                    const depItem = allItems.find(item => item.id === depId);
                    if (depItem) dependencies.push(depItem);
                });
            }

            // Find items that depend on this
            const dependents = allItems.filter(item =>
                item.dependencies && item.dependencies.includes(itemContext.id)
            );

            return {
                projectName: capexTree.name || 'Project',
                projectDescription: capexTree.description || '',
                pattern: currentPattern,
                totalItems: allItems.length,
                currentPhase: currentPhase ? {
                    name: currentPhase.name,
                    subtitle: currentPhase.subtitle,
                    itemCount: currentPhase.items?.length || 0
                } : null,
                siblingItems: siblingItems.slice(0, 5), // Limit to 5 for context
                dependencies: dependencies.slice(0, 3),
                dependents: dependents.slice(0, 3),
                allItems: allItems.slice(0, 10) // Sample for pattern learning
            };
        }

        // Helper: Build pattern-expert AI prompts
        function buildPatternExpertPrompt(fieldType, itemContext, treeContext) {
            const pattern = currentPattern;

            // Base context shared across all patterns
            let prompt = `You are a subject matter expert for ${pattern} pattern projects. `;

            // Pattern-specific expert persona
            const expertPersonas = {
                philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments.',
                sales: 'You are a sales strategist with 20 years of enterprise B2B experience.',
                thesis: 'You are an academic advisor helping graduate students structure rigorous research.',
                roadmap: 'You are a product manager experienced in agile development and feature prioritization.',
                prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude and GPT-4.',
                book: 'You are a professional fiction editor and writing coach.',
                film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway).',
                course: 'You are a senior instructional designer with 12+ years of experience and an M.Ed. in Curriculum & Instruction, specializing in competency-based learning design, Bloom\'s Taxonomy application, ADDIE methodology, and Gagne\'s Nine Events of Instruction. You apply adult learning theory (Knowles\' andragogy) and backward design principles (Wiggins & McTighe).',
                fitness: 'You are a certified personal trainer and exercise physiologist with expertise in program design, exercise science, and progressive overload.',
                event: 'You are a professional event planner with experience in corporate events, weddings, and large-scale conferences.',
                strategy: 'You are a senior business strategy consultant with 12+ years of experience. Your expertise spans Porter\'s Five Forces, McKinsey 7-S Model, BCG Matrix, Blue Ocean Strategy, and OKRs. You draw from the strategic thinking of Michael Porter, Clayton Christensen, and Rita McGrath.',
                familytree: 'You are a professional genealogist and family historian specializing in genealogical research and family tree documentation.',
                dialogue: 'You are a rhetoric and argumentation expert specializing in debate analysis, persuasive communication, and identifying logical fallacies.',
                gmail: 'You are an expert email analyst and communication strategist. You analyze email threads for tone, intent, rhetoric, and relationship dynamics. You provide context-aware suggestions for responses based on the full conversation history.',
                capex: 'You are an expert financial strategist and CFO crafting investor-ready CAPEX structures for angel investor presentations. Your approach: (1) FUNDING STORY - structure phases as stepping stones to funding milestones with clear de-risking; (2) RISK TRANSPARENCY - for each item, identify risks and concrete mitigations (sophisticated investors will find them anyway); (3) RETURN NARRATIVE - connect phases to valuation drivers and path to returns; (4) COMPETITIVE MOAT - highlight cost advantages and sustainable competitive edges. Demonstrate capital efficiency and make the path to value creation explicit.',
                generic: 'You are an experienced Project Manager with expertise in breaking down complex projects into manageable phases and tasks. Focus on clear structure, logical dependencies, and realistic planning.'
            };

            prompt += expertPersonas[pattern] || expertPersonas.generic;
            prompt += `\n\n`;

            // Project context (trimmed for speed)
            prompt += `PROJECT: ${treeContext.projectName}`;
            if (treeContext.currentPhase) {
                prompt += ` - ${treeContext.currentPhase.name}`;
            }
            prompt += `\n\n`;

            // Current item context (trimmed)
            prompt += `ITEM: ${itemContext.name || 'New Item'}\n`;
            if (itemContext.description && itemContext.description.length < 200) {
                prompt += `${itemContext.description.substring(0, 200)}\n`;
            }

            // Add existing field values for context
            const relevantFields = ['speaker', 'conclusion', 'premise1', 'premise2',
                                    'dealValue', 'contactPerson', 'leadSource',
                                    'keyArgument', 'evidenceType',
                                    'videoPrompt', 'visualStyle', 'cameraMovement',
                                    'itemType', 'notes'];
            relevantFields.forEach(field => {
                if (itemContext[field] && field !== fieldType) {
                    prompt += `- ${field}: ${itemContext[field]}\n`;
                }
            });

            // Dependencies (minimal, for speed)
            if (treeContext.dependencies.length > 0) {
                prompt += `Builds on: ${treeContext.dependencies.map(d => d.name).join(', ')}\n`;
            }

            // Sibling examples (limit to 2, show only relevant field)
            if (treeContext.siblingItems.length > 0) {
                const examples = treeContext.siblingItems
                    .filter(sib => sib[fieldType])
                    .slice(0, 2)
                    .map(sib => String(sib[fieldType]).substring(0, 60));
                if (examples.length > 0) {
                    prompt += `Examples: ${examples.join('; ')}\n`;
                }
            }

            prompt += `\n`;

            // CONTINUITY INSTRUCTIONS for sequential/narrative patterns
            const sequentialPatterns = ['film', 'book', 'roadmap'];
            if (sequentialPatterns.includes(pattern) && treeContext.siblingItems.length > 0) {
                const lastSibling = treeContext.siblingItems[treeContext.siblingItems.length - 1];
                prompt += `âš ï¸ CONTINUITY REQUIREMENT:\n`;
                prompt += `This item follows: "${lastSibling.name}"\n`;

                if (pattern === 'film') {
                    prompt += `Ensure visual/narrative continuity from previous scene:\n`;
                    if (lastSibling.description) prompt += `- Previous scene: ${lastSibling.description.substring(0, 100)}\n`;
                    if (lastSibling.lightingMood) prompt += `- Previous lighting: ${lastSibling.lightingMood}\n`;
                    prompt += `- If previous scene ended with location change/fade, this scene must establish new context\n`;
                    prompt += `- Maintain consistent visual style and tone unless intentionally shifting\n`;
                } else if (pattern === 'book') {
                    prompt += `Ensure narrative continuity from previous chapter/section:\n`;
                    if (lastSibling.description) prompt += `- Previous: ${lastSibling.description.substring(0, 100)}\n`;
                    prompt += `- Maintain character consistency, plot coherence, and thematic threads\n`;
                    prompt += `- If starting new section/arc, provide logical handover from previous\n`;
                } else if (pattern === 'roadmap') {
                    prompt += `Ensure feature sequencing makes sense:\n`;
                    if (lastSibling.description) prompt += `- Previous feature: ${lastSibling.description.substring(0, 100)}\n`;
                    prompt += `- Check dependencies: does this feature build on or require the previous one?\n`;
                    prompt += `- If starting new phase, ensure logical progression from previous phase goals\n`;
                }
                prompt += `\n`;
            }

            // Pattern-specific field instructions
            prompt += buildFieldInstructions(pattern, fieldType, itemContext);

            // CRITICAL: For video prompts and other direct-use fields, be VERY strict
            const directUseFields = ['videoPrompt', 'visualStyle', 'cameraMovement', 'flowMode', 'audioType',
                                     'cinematicStyle', 'beatType', 'physicsComplexity', 'nleExportFormat', 'audioSync'];
            if (directUseFields.includes(fieldType)) {
                prompt += `\nâš ï¸ CRITICAL OUTPUT FORMAT âš ï¸
Return ONLY the raw ${fieldType} text that will be used directly with AI video generation.
NO conversational introductions like "Okay, buckle up..." or "Get ready..." or "Here's..." or "Let me..."
NO explanations, NO context, NO meta-commentary, NO exclamation marks before the actual content
JUST the actual ${fieldType} text itself, ready to paste directly into Sora/Veo/Runway.

Example WRONG: "Okay, buckle up! Here's an amazing prompt: [actual prompt]"
Example WRONG: "Get ready to ignite the screen with this: [actual prompt]"
Example CORRECT: "[actual prompt]"

Your response:`;
            } else {
                prompt += `\nReturn ONLY the ${fieldType} value (1-3 sentences, no explanation).\n`;
            }

            return prompt;
        }

        // Helper: Pattern-specific field instructions
        function buildFieldInstructions(pattern, fieldType, itemContext) {
            let instructions = `YOUR TASK: Suggest a ${fieldType} for the current item.\n\n`;

            // Philosophy pattern
            if (pattern === 'philosophy') {
                const fieldInstructions = {
                    speaker: 'Suggest the most appropriate philosophical speaker/author for this argument based on the topic and historical context.',
                    premise1: 'Suggest a first premise that would logically support the conclusion. Use clear, precise philosophical language.',
                    premise2: 'Suggest a second premise that bridges premise1 to the conclusion, creating a valid logical inference.',
                    premise3: 'Suggest a third premise if needed to complete the argument structure.',
                    conclusion: 'Suggest a philosophical conclusion that follows from the premises. State it clearly and precisely.',
                    objection: 'Suggest a strong objection to this argument - what would a critic say? Be specific and philosophically rigorous.',
                    response: 'Suggest how the author would respond to the objection. Use careful distinctions and counterarguments.',
                    keyTerms: 'List 3-5 key philosophical terms central to this argument (comma-separated).',
                    textualReference: 'Suggest specific textual references (work and section numbers) where this argument appears or is discussed.',
                    description: 'Write a 2-3 sentence description of this philosophical argument, its method, and its significance.',
                    name: 'Suggest a concise title for this philosophical argument that captures its core claim.',
                    notes: 'Suggest key considerations for evaluating this argument: validity, soundness, implications, objections.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Sales pattern
            else if (pattern === 'sales') {
                const fieldInstructions = {
                    dealValue: 'Suggest a realistic deal value (in thousands $K) based on the deal type and company size.',
                    contactPerson: 'Suggest the most likely decision-maker title for this type of deal.',
                    leadSource: 'Suggest the most probable lead source for this deal type.',
                    competitorInfo: 'Suggest realistic competitive intelligence: who are we competing against and how do we differentiate? (2-3 sentences)',
                    expectedCloseDate: 'Suggest a realistic close date based on deal size and sales cycle.',
                    stageProbability: 'Suggest a close probability (0-100) based on the deal stage and context.',
                    description: 'Write a 2-3 sentence description of this sales opportunity, key stakeholders, and success factors.',
                    name: 'Suggest a descriptive name for this deal that includes company type and solution.',
                    notes: 'Suggest key considerations: budget timing, decision process, procurement, champion identification.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Thesis pattern
            else if (pattern === 'thesis') {
                const fieldInstructions = {
                    keyArgument: 'Suggest the main thesis argument for this chapter/section. What gap does it address? What contribution does it make?',
                    citations: 'Suggest 3-5 realistic academic citations (Author Year format) relevant to this topic.',
                    evidenceType: 'Suggest the most appropriate evidence type (Empirical, Theoretical, Mixed, Case Study, etc.).',
                    wordCount: 'Suggest a realistic current word count for this section.',
                    targetWordCount: 'Suggest an appropriate target word count based on section type.',
                    description: 'Write a 2-3 sentence description of this chapter/section: its argument, evidence, and contribution.',
                    name: 'Suggest a clear chapter/section title that reflects its content and argument.',
                    notes: 'Suggest key considerations: citation completeness, argument coherence, methodological rigor.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Film pattern
            else if (pattern === 'film') {
                const fieldInstructions = {
                    videoPrompt: 'Suggest a detailed Sora/Veo prompt (100-200 chars) for this scene. Include: subject, action, camera movement, lighting, style. Be cinematic and specific.',
                    cameraMovement: 'Suggest the most appropriate camera movement for this scene type and mood.',
                    lightingMood: 'Suggest the best lighting mood based on time of day, genre, and emotional tone.',
                    visualStyle: 'Suggest the visual style that best matches this scene\'s purpose and genre.',
                    duration: 'Suggest appropriate clip duration based on scene complexity and action.',
                    aiPlatform: 'Suggest the best AI platform (Sora, Veo 3, Runway Gen-3) for this scene type.',
                    description: 'Write a 2-3 sentence description of this scene: what happens, mood, visual approach.',
                    name: 'Suggest a concise scene name that captures the key action or emotion.',
                    notes: 'Suggest key considerations: continuity, platform strengths, prompt specificity, motion artifacts.',
                    iterationNotes: 'Suggest prompt engineering tips specific to this scene type.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Veo3 pattern
            else if (pattern === 'veo3') {
                const fieldInstructions = {
                    videoPrompt: 'Suggest a detailed Veo 3 prompt optimized for Google\'s model. Include: subject, action, camera movement, lighting, cinematic style.',
                    flowMode: 'Suggest the best Veo 3 Flow mode (Ingredients/Frames/Extend/Standard) for this scene.',
                    ingredientImages: 'Suggest what reference images would be needed for character/object/style consistency.',
                    startFrame: 'Suggest description of the starting frame for frame-to-frame bridging.',
                    endFrame: 'Suggest description of the ending frame for frame-to-frame bridging.',
                    extendDuration: 'Suggest target duration for video extension based on scene complexity.',
                    audioType: 'Suggest the best native audio type (Dialogue/SFX/Ambience/Mixed) for this scene.',
                    cinematicStyle: 'Suggest the Veo 3 cinematic style that best matches this scene.',
                    description: 'Write 2-3 sentences: what this scene shows, the Flow workflow, and visual approach.',
                    name: 'Suggest a concise scene name capturing the key visual or action.',
                    notes: 'Suggest key considerations: ingredient image quality, frame coherence, extension strategy.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Sora2 pattern
            else if (pattern === 'sora2') {
                const fieldInstructions = {
                    videoPrompt: 'Suggest a detailed Sora 2 prompt optimized for OpenAI\'s physics-accurate model. Include: subject, action, physics requirements, lighting, style.',
                    beatType: 'Suggest the narrative beat type (Setup/Conflict/Transition/Resolution) for this shot.',
                    cameoUsed: 'Suggest if this shot should use cameo integration and which cameo ID.',
                    remixSource: 'Suggest if this should be a remix of an existing shot, and which shot ID.',
                    physicsComplexity: 'Suggest physics complexity level (Simple/Medium/Complex) based on motion requirements.',
                    duration: 'Suggest Sora 2 duration (4s/8s/12s) based on action complexity.',
                    nleExportFormat: 'Suggest the best NLE format for post-production workflow.',
                    audioSync: 'Suggest audio type (Synchronized Dialogue/SFX/Background Score) for this beat.',
                    description: 'Write 2-3 sentences: what this beat accomplishes, physics requirements, and narrative purpose.',
                    name: 'Suggest a concise beat name capturing the narrative moment.',
                    notes: 'Suggest key considerations: physics accuracy, cameo setup, remix strategy, NLE workflow.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Roadmap pattern
            else if (pattern === 'roadmap') {
                const fieldInstructions = {
                    storyPoints: 'Suggest story point estimate (Fibonacci: 1,2,3,5,8,13) based on feature complexity.',
                    userImpact: 'Suggest user impact level (Low/Medium/High/Critical) based on affected user percentage and importance.',
                    technicalRisk: 'Suggest technical risk (Low/Medium/High) considering dependencies, unknowns, and complexity.',
                    engineeringEstimate: 'Suggest time estimate in sprints/weeks based on complexity.',
                    featureFlag: 'Suggest a feature flag name following naming conventions (feature_*).',
                    description: 'Write 2-3 sentences: what this feature does, who it affects, and key success metrics.',
                    name: 'Suggest a clear feature name that describes the user-facing capability.',
                    notes: 'Suggest key considerations: testing requirements, rollout strategy, monitoring, documentation.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Prompting pattern
            else if (pattern === 'prompting') {
                const fieldInstructions = {
                    systemPrompt: 'Suggest a clear, specific system prompt defining the AI\'s role, capabilities, and constraints. Use Anthropic best practices.',
                    userPromptTemplate: 'Suggest a user prompt template with {{variables}} and XML tags for structure.',
                    fewShotExamples: 'Suggest 1-2 few-shot examples in <examples><example> format showing input/output patterns.',
                    chainOfThought: 'Suggest CoT instructions: "Think step by step..." tailored to this task.',
                    outputFormat: 'Suggest the expected output structure (markdown, JSON, specific sections).',
                    structuralTags: 'Suggest XML tags for this task (e.g., <thinking>, <answer>, <critique>).',
                    assistantPrefill: 'Suggest an assistant prefill to guide tone and format.',
                    toolDefinitions: 'Suggest tool/function definitions if this task needs tool calling (JSON schema).',
                    modelTarget: 'Suggest the best model (Claude 3.5 Sonnet, GPT-4o, etc.) for this use case.',
                    temperature: 'Suggest temperature (0-1). Use 0-0.3 for deterministic tasks, 0.7-1.0 for creative.',
                    description: 'Write 2-3 sentences: what this prompt does, its approach, and optimization goals.',
                    name: 'Suggest a descriptive name for this prompt use case.',
                    notes: 'Suggest OpenAI/Anthropic best practices applied to this specific prompt.'
                };
                instructions += fieldInstructions[fieldType] || `Suggest an appropriate ${fieldType} value.`;
            }

            // Generic pattern - PM and CFO perspective
            else if (pattern === 'generic') {
                const fieldInstructions = {
                    cost: 'Suggest a realistic cost estimate based on the item type, scope, and market rates. Consider labor, materials, overhead.',
                    leadTime: 'Suggest a realistic timeline considering procurement cycles, dependencies, and resource availability.',
                    alternateSource: 'Suggest a credible backup vendor or alternative approach to mitigate supply chain/delivery risks.',
                    pmNextSteps: 'Suggest 2-3 specific, actionable next steps a PM would take to advance this task.',
                    pmBlockingIssue: 'Identify likely blockers: budget constraints, resource conflicts, vendor delays, approvals needed.',
                    description: 'Write 2-3 sentences describing this deliverable, its business value, and key execution considerations.',
                    name: 'Suggest a clear deliverable name that communicates scope and business value.',
                    notes: 'Suggest PM considerations: budget burn rate, stakeholder alignment, risk mitigation, change management.',
                    pmOwnerEmail: 'Suggest the most appropriate role/person to own this (e.g., engineering-lead@, procurement@, finance@).'
                };
                instructions += fieldInstructions[fieldType] || `From a PM and CFO perspective, suggest a realistic ${fieldType} value considering budget, timeline, and risk factors.`;
            }

            // Gmail pattern - Email analysis and response generation
            else if (pattern === 'gmail') {
                const fieldInstructions = {
                    subjectLine: 'Suggest 2-3 high-converting subject lines based on the email context. Keep under 50 characters. Avoid spammy words. Focus on value or curiosity.',
                    emailBody: 'Analyze the full conversation thread and suggest a contextually-appropriate response. Reference previous messages. Match the tone and formality level. Include a clear call to action if appropriate.',
                    recipientEmail: 'Suggest the likely recipient based on the conversation context and sender patterns.',
                    status: 'Suggest the appropriate email status (Draft/Sent/Replied/Archived) based on the conversation state.',
                    name: 'Suggest a short internal name for this email thread that captures the main topic or business context.',
                    description: 'Analyze this email thread: summarize the key points, identify the tone/sentiment, note any action items, and assess relationship dynamics.',
                    notes: 'Suggest key observations: communication style, negotiation position, objections raised, next steps needed, relationship temperature (warm/neutral/cold).'
                };
                instructions += fieldInstructions[fieldType] || `Analyze the email context and conversation history to suggest an appropriate ${fieldType} value.`;
            }

            // Event Planning pattern
            else if (pattern === 'event') {
                const fieldInstructions = {
                    budget: 'Suggest realistic budget based on activity type. Catering: $25-75/person, Venue: $2-10K, AV/Tech: $1-5K, Entertainment: $500-5K. Consider event scale and location.',
                    vendor: 'Suggest appropriate vendor type and realistic company name. Include specialization (e.g., "ABC Catering - Corporate Events", "Premier AV - Full-service production").',
                    bookingDeadline: 'Suggest booking deadline based on vendor type: Venues (6-12 months ahead), Catering (2-3 months), Entertainment (3-6 months), AV/Tech (1-2 months).',
                    guestCount: 'Suggest realistic guest count based on event type: Corporate (50-500), Wedding (100-250), Conference (100-1000), Team building (20-100).',
                    location: 'Suggest specific location based on activity. Be detailed: "Grand Ballroom, 2nd floor" not just "Hotel". Include practical details.',
                    responsiblePerson: 'Suggest appropriate role based on activity type: Event Manager (overall), AV Coordinator (tech), Catering Manager (food), Registration Lead (check-in).',
                    description: 'Write 2-3 sentences: what this activity entails, its role in the event, and key success factors.',
                    name: 'Suggest a clear activity name that includes the type and purpose.',
                    notes: 'Suggest key considerations: vendor contracts, backup plans, timing dependencies, permits needed, weather contingencies.'
                };
                instructions += fieldInstructions[fieldType] || `From an event planner\'s perspective, suggest a realistic ${fieldType} value considering logistics, timeline, and vendor coordination.`;
            }

            // Fitness pattern
            else if (pattern === 'fitness') {
                const fieldInstructions = {
                    sets: 'Suggest sets based on training goal: Hypertrophy (3-4 sets), Strength (5+ sets), Endurance (2-3 sets), Skill work (3-5 sets). Consider training age and recovery capacity.',
                    reps: 'Suggest rep ranges by goal: Strength (3-6 reps), Hypertrophy (8-12 reps), Endurance (15+ reps), Power (1-5 reps explosive). Match to exercise type (compound vs isolation).',
                    duration: 'Suggest duration based on workout type: Strength session (45-75 min), Cardio (20-60 min), Circuit training (30-45 min), Recovery/mobility (15-30 min).',
                    intensity: 'Suggest intensity level based on training phase, exercise type, and proximity to competition/testing. Consider recovery status.',
                    equipment: 'Suggest realistic equipment based on exercise. Be specific: "Olympic Barbell, 45lb plates" not just "weights". Consider gym vs home setup.',
                    formCues: 'Provide 3 specific biomechanical safety cues focusing on joint angles, spine position, and common injury risks. Example: "Deadlift: Neutral spine, shoulders over bar, drive through heels." Reference anatomy.',
                    restPeriod: 'Suggest rest based on goal: Strength (3-5 min - CNS recovery), Hypertrophy (60-90s - metabolic stress), Endurance (30-45s - conditioning), Power (2-3 min).',
                    description: 'Write 2-3 sentences: training stimulus, primary muscle groups, and how this fits into the program phase.',
                    name: 'Suggest a descriptive workout name indicating focus (e.g., "Upper Body Hypertrophy A", "Lower Power Day").',
                    notes: 'Suggest key considerations: progression scheme (linear, wave, double progression), deload timing, exercise substitutions, injury prevention.'
                };
                instructions += fieldInstructions[fieldType] || `From a certified strength coach perspective (CSCS), suggest a ${fieldType} value based on training science and periodization principles.`;
            }

            // Strategic Planning pattern
            else if (pattern === 'strategy') {
                const fieldInstructions = {
                    investment: 'Suggest realistic capital investment based on initiative scope. Consider: Technology ($100K-$5M), Market expansion ($500K-$10M), Operational improvements ($50K-$2M). Include CAPEX and OPEX.',
                    keyMetric: 'Suggest a specific, measurable KPI that defines success. Use SMART criteria. Examples: "Revenue growth %", "Customer acquisition cost", "Market share %", "Employee retention rate".',
                    targetValue: 'Suggest a specific, ambitious but achievable target for the metric. Base on industry benchmarks. Example: "Increase revenue by 25% YoY", "Reduce CAC by $150".',
                    responsibleExecutive: 'Suggest appropriate C-level owner: CEO (transformation), CFO (financial), CTO (technology), CMO (marketing), COO (operations), CHRO (people).',
                    strategicTheme: 'Assign theme based on initiative nature: Growth (revenue expansion), Efficiency (cost reduction), Innovation (new products), Transformation (business model change), Risk Mitigation (compliance, security).',
                    riskLevel: 'Assess risk considering: Market uncertainty, technical complexity, regulatory factors, resource constraints. High risk: unproven, complex, resource-intensive.',
                    description: 'Write 2-3 sentences: strategic rationale, expected business impact, and key success factors.',
                    name: 'Suggest a clear initiative name that communicates strategic intent and business value.',
                    notes: 'Suggest key considerations: competitive response, regulatory requirements, change management, ROI timeline, resource conflicts.'
                };
                instructions += fieldInstructions[fieldType] || `From a strategy consultant perspective (McKinsey/BCG), suggest a ${fieldType} value considering competitive dynamics, market forces, and organizational capabilities.`;
            }

            // Course Design pattern
            else if (pattern === 'course') {
                const fieldInstructions = {
                    learningObjectives: 'Write 2-3 specific learning objectives using Bloom\'s Taxonomy action verbs (Remember: define, list; Understand: explain, summarize; Apply: demonstrate, solve; Analyze: compare, critique; Evaluate: judge, defend; Create: design, compose). Make them measurable and specific.',
                    duration: 'Suggest duration based on lesson type: Lecture (50-75 min), Lab/Practical (90-120 min), Discussion (30-60 min), Workshop (2-4 hours), Field work (half-day to full-day).',
                    difficultyLevel: 'Suggest level based on prerequisite knowledge, cognitive complexity (Bloom\'s level), and abstraction required. Beginner: foundational concepts. Intermediate: application/analysis. Advanced: synthesis/evaluation.',
                    prerequisites: 'List specific prior knowledge, skills, or courses needed. Be concrete: "Understanding of basic statistics (mean, median, standard deviation)" not just "some statistics".',
                    assessmentType: 'Suggest assessment matching learning objectives. Use Bloom\'s level: Quiz (remember/understand), Assignment (apply/analyze), Project (analyze/evaluate/create), Discussion (understand/evaluate), Exam (comprehensive).',
                    resourcesNeeded: 'List specific resources: Textbook chapters with page numbers, required readings with citations, software/tools, datasets, lab equipment, handouts.',
                    homework: 'Suggest homework that reinforces learning objectives. Estimate time required (typically 2-3x class time for college courses). Make it specific and scaffolded.',
                    description: 'Write 2-3 sentences: key concepts covered, pedagogical approach, and how this builds toward course goals.',
                    name: 'Suggest a clear lesson title that reflects content and cognitive level.',
                    notes: 'Suggest key considerations: active learning strategies, accommodation needs, technology requirements, formative assessment touchpoints.'
                };
                instructions += fieldInstructions[fieldType] || `From an instructional designer perspective (ADDIE model, Bloom\'s Taxonomy), suggest a ${fieldType} value considering learning science and curriculum design principles.`;
            }

            // Family Tree pattern
            else if (pattern === 'familytree') {
                const fieldInstructions = {
                    fullName: 'Suggest full legal name including middle names. Use historical naming conventions for era (e.g., patronymics, matronymics in certain cultures).',
                    maidenName: 'Suggest maiden name (birth surname) if person changed name after marriage. Consider cultural naming traditions.',
                    gender: 'Suggest gender based on name and historical context. Use "Unknown" if insufficient evidence.',
                    birthDate: 'Suggest realistic birth date based on generation, parent ages, and historical context. Parents typically 20-35 years older than children.',
                    birthPlace: 'Suggest birth location with specificity appropriate to era and records. Format: City, State/Province, Country. Consider migration patterns.',
                    livingStatus: 'Determine based on birth year and typical lifespan. Anyone born before 1920 likely deceased. Use "Unknown" if uncertain.',
                    deathDate: 'Suggest death date if deceased. Consider typical lifespan for era: pre-1900 (40-60 years), 1900-1950 (60-70 years), post-1950 (70-85 years).',
                    deathPlace: 'Suggest death location considering migration history and family patterns. Often different from birthplace.',
                    marriageDate: 'Suggest marriage date considering historical marriage ages: Pre-1900 (women 18-22, men 22-26), Modern (women 25-30, men 27-32). Check birth dates of children.',
                    marriagePlace: 'Suggest marriage location based on family residence patterns and cultural traditions.',
                    spouseName: 'Suggest spouse name if married. Consider multiple marriages if dates suggest (remarriage after death/divorce).',
                    occupation: 'Suggest historically appropriate occupation for era, location, and social class. Be specific: "Locomotive Engineer" not just "Railroad worker".',
                    photoURL: 'Suggest type of photo if known: "Portrait photo circa 1920s" or "Family photo, wedding day". Note if no photo available.',
                    dnaInfo: 'Suggest relevant genetic information: Haplogroups (Y-DNA for paternal line, mtDNA for maternal line), ethnic percentages, DNA matches, genetic markers.',
                    sources: 'Suggest appropriate primary sources: Birth/death certificates, census records (1850-1940 US), marriage licenses, military records, church records, immigration documents.',
                    relationshipType: 'Classify relationship: Biological (default), Adopted, Step (remarriage), Foster, Half-Sibling (shared one parent). Consider family dynamics.',
                    description: 'Write 2-3 sentences: brief biography, significant life events, and family role/legacy.',
                    name: 'Suggest identifying name (often nickname or commonly used name): "John Smith (Big John)" or "Mary Johnson (nÃ©e Williams)".',
                    notes: 'Suggest key considerations: Missing records, conflicting data, DNA confirmation status, historical context, research leads to pursue.'
                };
                instructions += fieldInstructions[fieldType] || `From a genealogist perspective (NGSQ standards), suggest a ${fieldType} value based on historical records, naming patterns, and genealogical best practices.`;
            }

            // Dialogue & Rhetoric pattern
            else if (pattern === 'dialogue') {
                const fieldInstructions = {
                    speaker: 'Identify speaker and relevant context: Name, role/title, political affiliation, expertise, or motivation. Example: "Senator Jane Smith (R-TX, Healthcare Committee Chair)".',
                    verbatimQuote: 'Extract the exact statement word-for-word. Capture tone indicators (emphasis, pauses). Essential for accurate rhetorical analysis.',
                    rhetoricalDevice: 'Identify primary persuasion technique: Logos (logical reasoning), Pathos (emotional appeal), Ethos (credibility), Metaphor, Analogy, Repetition, Hyperbole, Irony, Appeal to Authority.',
                    logicalStructure: 'Break down argument into formal logic: "Premise 1: [claim], Premise 2: [claim], Conclusion: [claim]". Identify deductive/inductive/abductive reasoning.',
                    fallaciesPresent: 'Identify logical fallacies with examples: Ad hominem (attack person not argument), Straw man (misrepresent position), Slippery slope, False dichotomy, Appeal to emotion, Hasty generalization. Explain how fallacy appears.',
                    hiddenMotivation: 'Analyze subtext and hidden agenda. What is the speaker really trying to achieve? Consider: Political positioning, fundraising, deflection, changing topic, rallying base.',
                    description: 'Write 2-3 sentences: summarize the argument, identify rhetorical strategy, and assess persuasive effectiveness.',
                    name: 'Suggest a short label capturing the argument\'s core claim or tactic (e.g., "Healthcare Cost Deflection", "Moral Authority Appeal").',
                    notes: 'Suggest key observations: Communication style, negotiation position, emotional valence, audience targeting, cultural context, historical parallels.'
                };
                instructions += fieldInstructions[fieldType] || `From a rhetoric expert perspective (Aristotelian persuasion, critical discourse analysis), suggest a ${fieldType} value analyzing argument structure, persuasion techniques, and logical coherence.`;
            }

            // Filesystem pattern - Digital Librarian AI
            else if (pattern === 'filesystem') {
                const fieldInstructions = {
                    tags: 'Suggest 3-5 taxonomic tags based on the filename, location, and file extension. Use consistent casing (lowercase-kebab). Examples: "financial-report", "customer-data", "design-asset", "code-source", "archive-2024".',
                    fileOwner: 'Suggest the most likely owner/creator based on the folder context, file type, and naming patterns. Format as email or department: "finance@company.com", "engineering-dept", "john.doe", "admin".',
                    permissions: 'Suggest appropriate permissions (Read Only, Read/Write, Owner, Viewer, Editor) based on file type, sensitivity, and likely use case. Financial data â†’ Read Only, Shared docs â†’ Read/Write, System files â†’ Owner only.',
                    description: 'Write a clear 1-2 sentence summary of what this file/folder likely contains based on its name, extension, location, and context. Be specific about content type and purpose.',
                    name: 'Suggest a clean, standardized filename if the current one is messy. Use ISO 8601 dates (YYYY-MM-DD), no spaces (use hyphens or underscores), descriptive keywords, and proper casing. Example: "2024-Q3-financial-report.pdf" instead of "report final FINAL (1).pdf".',
                    notes: 'Suggest data governance notes: retention policy (how long to keep), backup priority (critical/standard/low), security classification (public/internal/confidential/restricted), compliance requirements (GDPR, HIPAA, SOX), and archival recommendations.',
                    fileSize: 'Estimate realistic file size in bytes based on file type and likely content. Documents (50KB-5MB), Images (100KB-10MB), Videos (10MB-2GB), Code (10KB-500KB), Archives (1MB-500MB).',
                    fileExtension: 'Suggest the correct file extension based on the filename and file type. Be specific: .pdf, .docx, .xlsx, .pptx, .jpg, .png, .mp4, .zip, .py, .js, .html, etc.',
                    filePath: 'Suggest a logical full file path based on the file type, organizational context, and best practices for file organization. Use clear folder hierarchies.',
                    dateModified: 'Suggest when this file was likely last modified based on context clues (project timelines, version numbers, naming patterns). Use ISO 8601 format.',
                    dateCreated: 'Suggest when this file was likely created based on naming conventions, project context, or folder structure. Use ISO 8601 format.',
                    sharedWith: 'Suggest who should have access to this file based on content type, sensitivity, and organizational context. List email addresses or group names.',
                    driveType: 'Suggest the appropriate storage location (Local Drive, Google Drive, OneDrive, Dropbox, Network Drive, External Drive) based on file type, sharing needs, and organizational policies.',
                    mimeType: 'Suggest the MIME type based on file extension. Examples: application/pdf, image/jpeg, text/html, video/mp4, application/zip, text/plain, application/json.',
                    fileUrl: 'Suggest whether this should be stored in cloud storage and note the URL pattern (e.g., "Google Drive - shared link", "OneDrive - team folder", "Local only").',
                    isFolder: 'Determine if this should be a folder or file based on naming patterns. Folders typically have generic names (Documents, 2024-Reports, Assets) while files have extensions.'
                };
                instructions += fieldInstructions[fieldType] || `Act as a Digital Librarian and File Management expert. Suggest appropriate metadata for this file/folder, considering: organizational best practices, data governance, security classification, and clean naming conventions. Help tame messy filesystems.`;
            }

            // Other patterns
            else {
                instructions += `Consider the project context, dependencies, and sibling items. Suggest a realistic, specific ${fieldType} value that fits the pattern.`;
            }

            return instructions;
        }

        // MAIN AI SUGGESTION FUNCTION (async with AI integration)
        async function generateAISuggestion(fieldType, itemContext) {
            console.log('ðŸ¤– generateAISuggestion called:', fieldType);

            // Check global AI mode
            const aiMode = getGlobalAIMode();
            console.log('ðŸ¤– Global AI Mode:', aiMode);

            if (aiMode === 'off') {
                console.log('âŒ AI features disabled, using static fallback');
                return generateStaticSuggestion(fieldType, itemContext);
            }

            // Check if API key is available (needed for all modes)
            const apiKey = getLocalAPIKey(getAIProvider());
            console.log('ðŸ”‘ API Key present:', !!apiKey);

            if (!apiKey && aiMode === 'deep') {
                console.log('âš ï¸ Deep Mode requires API key, falling back to static');
                alert('ðŸ”¬ Deep Mode requires your own API key.\n\nPlease configure your API key (ðŸ”‘ button) or switch to Quick Mode in the header.');
                return generateStaticSuggestion(fieldType, itemContext);
            }

            if (!apiKey && aiMode === 'quick') {
                console.log('âš¡ Quick Mode: Will use server API key');
            }

            try {
                // Extract full tree context
                console.log('ðŸ“Š Extracting tree context...');
                const treeContext = extractTreeContext(itemContext);
                console.log('ðŸ“Š Tree context extracted:', treeContext);

                // Build pattern-expert prompt
                console.log('ðŸ“ Building expert prompt...');
                const expertPrompt = buildPatternExpertPrompt(fieldType, itemContext, treeContext);
                console.log('ðŸ“ Expert prompt built, length:', expertPrompt.length);

                // Call Claude API for intelligent suggestion (low token limit for speed)
                console.log('â˜ï¸ Calling Claude API...');
                const suggestion = await callClaudeAPI(expertPrompt, '', 256); // 256 tokens max = faster, stays under 10s Netlify limit
                console.log('â˜ï¸ Claude API response:', suggestion);

                // Clean up the response (remove quotes, trim)
                let cleaned = suggestion.trim();
                if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
                    cleaned = cleaned.slice(1, -1);
                }
                if (cleaned.startsWith("'") && cleaned.endsWith("'")) {
                    cleaned = cleaned.slice(1, -1);
                }

                console.log('âœ¨ Returning cleaned suggestion:', cleaned);
                return cleaned || generateStaticSuggestion(fieldType, itemContext);

            } catch (error) {
                console.error('âŒ AI suggestion failed, falling back to static:', error);
                console.error('Error details:', error.message, error.stack);
                return generateStaticSuggestion(fieldType, itemContext);
            }
        }

        // STATIC SUGGESTION ENGINE (fallback when no API key)
        function generateStaticSuggestion(fieldType, itemContext) {
            const pattern = PATTERNS[currentPattern];
            const itemType = itemContext.itemType || '';
            const phase = itemContext.id ? itemContext.id.split('-')[0] : 'p0';
            const notes = itemContext.notes || '';

            // Get all existing items for contextual analysis
            function getAllProjectItems(node = capexTree, items = []) {
                if (node.items) items.push(...node.items);
                if (node.children) node.children.forEach(child => getAllProjectItems(child, items));
                return items;
            }
            const existingItems = getAllProjectItems();

            // Pattern-aware AI suggestion templates - Subject matter experts for each domain
            const patternSuggestions = {
                philosophy: {
                    name: ['Knowledge is Virtue', 'The Nature of Justice', 'Definition of Piety', 'Forms vs Particulars', 'The Good Life', 'Moral Relativism Critique', 'Socratic Paradox', 'The Cave Allegory', 'Mind-Body Problem', 'Free Will vs Determinism'],
                    description: 'Dialectical examination of fundamental concepts through logical argumentation. Present premises systematically, consider objections, and respond with careful distinctions. Ground claims in textual evidence and philosophical tradition.',
                    speaker: ['Socrates', 'Plato', 'Aristotle', 'Meno', 'Euthyphro', 'Thrasymachus', 'Glaucon', 'Adeimantus'],
                    premise1: 'All humans desire what is genuinely good for them.',
                    premise2: 'If someone pursues what is harmful, they must not recognize it as harmful.',
                    conclusion: 'Therefore, wrongdoing is a form of ignorance, not deliberate evil.',
                    objection: 'Some people knowingly pursue harmful pleasures despite understanding the consequences.',
                    response: 'True knowledge of harm would necessarily prevent pursuit; what appears as knowledge may be mere belief.',
                    keyTerms: 'virtue, knowledge, piety, justice, wisdom, excellence (arete)',
                    textualReference: 'Meno 77b-78b, Protagoras 352-358',
                    notes: 'Consider: logical validity of argument, strength of premises, historical context, counterexamples from lived experience, implications for ethics and epistemology.'
                },
                sales: {
                    name: ['Enterprise Cloud Migration', 'SaaS Platform Expansion', 'Strategic Partnership Deal', 'Fortune 500 Account', 'Multi-Year Service Agreement', 'Technology Integration Project'],
                    description: 'High-value opportunity requiring executive engagement and multi-stakeholder alignment. Key success factors: clear ROI demonstration, competitive differentiation, and relationship-building with economic buyer.',
                    leadSource: 'Inbound marketing, industry conference referral, or strategic partner introduction',
                    contactPerson: 'VP of IT, CFO, or Chief Digital Officer',
                    competitorInfo: 'Competing against 2-3 established vendors. Differentiation: superior support, proven ROI, and industry-specific features.',
                    notes: 'Key considerations: budget approval timing, decision-making process, technical evaluation criteria, procurement requirements, champion identification, stakeholder mapping.'
                },
                thesis: {
                    name: ['Literature Review', 'Theoretical Framework', 'Methodology Design', 'Data Analysis', 'Results Interpretation', 'Discussion of Findings', 'Limitations & Future Research'],
                    description: 'Critical analysis of existing scholarship establishing theoretical foundation for research. Synthesize major debates, identify gaps in literature, and position current study within academic discourse.',
                    keyArgument: 'Previous research has overlooked [specific aspect], creating need for [your contribution]. This study addresses gap through [your approach].',
                    citations: 'Smith (2020), Johnson & Lee (2019), Martinez et al. (2018), Chen (2021)',
                    evidenceType: 'Mixed: quantitative data analysis combined with qualitative case studies',
                    notes: 'Key considerations: citation completeness, argument coherence, gap identification, methodological rigor, contribution to field, clarity of research questions.'
                },
                roadmap: {
                    name: ['User Authentication V2', 'Mobile App Redesign', 'API Performance Optimization', 'Analytics Dashboard', 'Third-Party Integration', 'Search Functionality'],
                    description: 'User-facing feature delivering measurable business value. Requires cross-functional coordination between product, engineering, and design. Success metrics defined upfront.',
                    userImpact: 'High - affects 80% of active users',
                    technicalRisk: 'Medium - depends on third-party API stability',
                    engineeringEstimate: '2 sprints (4 weeks)',
                    featureFlag: 'feature_new_search_v2',
                    notes: 'Key considerations: user testing requirements, performance benchmarks, rollout strategy, rollback plan, monitoring and alerting, documentation needs.'
                },
                prompting: {
                    name: ['Customer Support Agent', 'Code Reviewer with CoT', 'RAG Query Handler', 'Content Generator', 'Multi-Agent Router', 'Safety Classifier', 'Summarizer with Examples', 'Function Calling Orchestrator'],
                    description: 'Production prompt engineered using OpenAI/Anthropic best practices. Clear role definition, task breakdown, few-shot examples, output format specification, and evaluation criteria. Optimized for consistency and reliability.',
                    systemPrompt: 'You are an expert customer support agent for a SaaS platform. Your goal is to resolve customer issues quickly while maintaining a friendly, professional tone. Always prioritize customer satisfaction. If you cannot resolve an issue, escalate appropriately with clear context.',
                    userPromptTemplate: 'A customer has reported the following issue:\n\n<customer_issue>\n{{issue}}\n</customer_issue>\n\n<context>\nAccount: {{account_tier}}\nPrevious tickets: {{ticket_history}}\n</context>\n\nAnalyze the issue and provide: 1) Root cause, 2) Resolution steps, 3) Prevention advice.',
                    fewShotExamples: '<examples>\n<example>\n<user>Login broken after password reset</user>\n<assistant>Root cause: Session cache not cleared. Resolution: Clear browser cache or wait 5 minutes for auto-refresh. Prevention: Use incognito mode during password changes.</assistant>\n</example>\n</examples>',
                    structuralTags: '<thinking>\nAnalyze issue type and severity\n</thinking>\n\n<answer>\nProvide structured response\n</answer>',
                    assistantPrefill: 'Here is my analysis of the customer issue:',
                    chainOfThought: 'Think step by step: First identify the symptom, then trace back to root cause, then propose the minimal effective solution.',
                    outputFormat: 'Use this structure:\n**Root Cause:** [one sentence]\n**Resolution:** [numbered steps]\n**Prevention:** [actionable advice]',
                    modelTarget: 'Claude 3.5 Sonnet',
                    temperature: 0.3,
                    maxTokens: 1500,
                    testResults: 'Golden set: 94% accuracy on 200 support tickets\nAvg latency: 1.8s\nCost: $0.025 per call\nCustomer satisfaction: 4.7/5',
                    toolDefinitions: '{\n  "escalate_ticket": {\n    "description": "Escalate to human agent",\n    "parameters": {"reason": "string", "priority": "high|medium|low"}\n  }\n}',
                    agentWorkflow: 'Single agent (support responder)\nâ†’ Optionally calls escalate_ticket function\nâ†’ Human agent takes over if escalated',
                    contextManagement: 'Sliding window: keep last 6 messages (3 turns)\nCompress older history with summarization\nToken budget: 8K context, 1.5K completion',
                    promptInjectionDefense: 'Use XML tags to separate user input: <customer_issue>{{untrusted}}</customer_issue>\nValidate output doesn\'t leak system prompt\nMonitor for jailbreak patterns',
                    iterationNotes: 'v1: Too verbose, 350 tokens avg\nv2: Added output format, reduced to 180 tokens\nv3: Few-shot examples improved consistency to 94%\nv4: Lowered temp from 0.7â†’0.3 for more deterministic responses',
                    notes: 'OpenAI/Anthropic best practices applied:\n- Clear system role (Anthropic: system parameter)\n- XML tags for structure (Anthropic recommendation)\n- Few-shot examples in <examples> tags\n- Assistant prefill to guide tone (Claude-specific)\n- Chain-of-thought instruction for reasoning\n- Explicit output format\n- Prompt injection defense with delimiters\n- Golden test set for validation\n- Iterative refinement based on metrics'
                },
                book: {
                    name: ['Opening Scene', 'Character Introduction', 'Rising Action', 'Climactic Confrontation', 'Resolution', 'Twist Reveal', 'Emotional Payoff', 'Transition Chapter'],
                    description: 'Narrative chapter advancing plot through character development, conflict escalation, or thematic exploration. Balance dialogue, action, and description. Maintain pacing and reader engagement.',
                    wordCount: 3500,
                    targetWordCount: 4000,
                    draftStatus: 'First Draft',
                    povCharacter: 'Sarah Chen (protagonist)',
                    sceneSetting: 'Downtown coffee shop, early morning, rain outside',
                    plotFunction: 'Establishes protagonist motivation and introduces central conflict',
                    notes: 'Key considerations: POV consistency, show vs tell balance, scene vs sequel structure, sensory details, dialogue authenticity, pacing variation, emotional beats, foreshadowing.'
                },
                film: {
                    name: ['Opening Establishing Shot', 'Character Introduction', 'Emotional Dialogue', 'Action Chase Sequence', 'Atmospheric Transition', 'Climactic Confrontation', 'Dream/Memory Sequence', 'Final Resolution'],
                    description: 'AI-generated video scene created through detailed text-to-video prompting. Specify camera movement, lighting, mood, action, and visual style. Iterate on prompt wording for best results. Consider continuity across shots.',
                    aiPlatform: 'Sora (OpenAI)',
                    videoPrompt: 'A cinematic close-up shot slowly pulling back to reveal a woman in her 30s standing at a rain-streaked window overlooking a neon-lit city at night. Soft blue and purple lighting from the city illuminates her contemplative expression. Camera movement: slow dolly back. Mood: melancholic, cyberpunk aesthetic. Shot on 35mm film, shallow depth of field, bokeh lights in background.',
                    visualStyle: 'Cinematic',
                    duration: '10 seconds',
                    aspectRatio: '16:9 (Widescreen)',
                    cameraMovement: 'Dolly Out',
                    motionIntensity: 'Subtle',
                    lightingMood: 'Neon',
                    iterationNotes: 'Best practices: Be extremely specific about camera movement and speed. Mention lighting sources explicitly. Use cinematography terms (bokeh, depth of field, shot types). Reference film stock or camera models for aesthetic cues. Specify exact actions and their duration. Include mood/emotion words. Test multiple aspect ratios - some models handle certain ratios better. Start with shorter durations for complex scenes. Use "slow", "gradual", "subtle" for smoother motion.',
                    notes: 'Key considerations: Prompt engineering (specificity vs brevity), continuity between shots, aspect ratio consistency, motion artifacts detection, prompt variations for A/B testing, platform-specific strengths (Sora: physics/realism, Veo: motion control, Runway: speed), generation cost budgeting, style consistency across scenes, temporal coherence for extended clips, copyright/likeness considerations.'
                },
                course: {
                    name: ['Introduction to Topic', 'Foundational Concepts', 'Hands-On Lab Exercise', 'Case Study Analysis', 'Group Discussion', 'Skill Application Project', 'Assessment', 'Review Session'],
                    description: 'Instructional session designed to build student knowledge and skills through active learning. Combines lecture, practice, and assessment. Aligned with course learning objectives.',
                    learningObjectives: 'Students will be able to: 1) Define key concepts, 2) Apply techniques to novel problems, 3) Analyze real-world examples, 4) Evaluate trade-offs',
                    duration: '90 minutes',
                    difficultyLevel: 'Intermediate',
                    prerequisites: 'Completion of Module 2, basic programming knowledge, familiarity with data structures',
                    assessmentType: 'Quiz',
                    resourcesNeeded: 'Textbook Chapter 5, online simulation tool, practice dataset, reference handout',
                    homework: 'Complete problem set 4 (problems 1-10), read Chapter 6, prepare discussion questions',
                    notes: 'Key considerations: accessibility accommodations, engagement strategies, timing flexibility, technology backup plans, formative assessment checkpoints, inclusive pedagogy, active learning techniques.'
                },
                strategic: {
                    name: ['Digital Transformation Initiative', 'Market Expansion Strategy', 'Operational Excellence Program', 'Customer Experience Overhaul', 'Innovation Portfolio', 'Risk Mitigation Plan', 'Sustainability Initiative'],
                    description: 'Strategic initiative aligned with organizational priorities. Requires executive sponsorship, cross-functional resources, and measurable outcomes. Board-level visibility and quarterly review cadence.',
                    investment: 2500000,
                    keyMetric: 'Revenue growth in target segment',
                    targetValue: '25% year-over-year increase',
                    responsibleExecutive: 'Chief Strategy Officer',
                    strategicTheme: 'Growth',
                    riskLevel: 'Medium',
                    notes: 'Key considerations: stakeholder alignment, resource allocation, change management, governance structure, milestone tracking, competitive response, market timing, regulatory compliance.'
                },
                generic: {
                    name: {
                        land: ['Land Acquisition & Title', 'Site Purchase & Legal', 'Property Option Agreement'],
                        engineering: ['Engineering Design Services', 'Technical Specification Development', 'System Architecture'],
                        equipment: ['Equipment Procurement', 'Hardware Purchase & Installation', 'Capital Equipment'],
                        infrastructure: ['Infrastructure Development', 'Site Preparation', 'Facility Build-Out'],
                        corporate: ['Corporate Administration', 'Business Operations', 'Management Overhead'],
                        professional: ['Professional Services', 'Consulting & Advisory', 'Expert Services'],
                        contingency: ['Contingency Reserve', 'Risk Mitigation Fund', 'Budget Reserve']
                    },
                    description: {
                        equipment: 'Procurement of capital equipment with extended lead times. Requires vendor evaluation, competitive bidding, and early commitment to secure production slots.',
                        default: 'Detailed specification of deliverables, timeline, dependencies, and success criteria. Coordinate with stakeholders and manage risks proactively.'
                    },
                    cost: { p0: [50000, 100000, 250000], p1: [500000, 1000000, 2000000], p2: [25000000, 50000000, 100000000] },
                    alternateSource: 'Secondary vendors, in-house capability, strategic partnerships, or alternative procurement strategies',
                    leadTime: { p0: '2-8 weeks', p1: '3-6 months', p2: '12-24 months' },
                    notes: 'Key considerations: timeline, budget allocation, vendor selection, risk mitigation, quality assurance, regulatory compliance.'
                }
            };

            // PATTERN-AWARE SUGGESTION GENERATION - Each pattern acts as subject expert
            const patternKey = currentPattern;
            const patternData = patternSuggestions[patternKey] || patternSuggestions.generic;

            // Handle pattern-specific fields (philosophy, sales, thesis, etc.)
            if (patternData[fieldType]) {
                const suggestion = patternData[fieldType];

                // If array, pick random option
                if (Array.isArray(suggestion)) {
                    return suggestion[Math.floor(Math.random() * suggestion.length)];
                }

                // If string, return directly
                return suggestion;
            }

            // Common fields handled for all patterns
            if (fieldType === 'name') {
                if (patternKey === 'generic' && patternData.name[itemType]) {
                    const options = patternData.name[itemType];
                    return options[Math.floor(Math.random() * options.length)];
                }
                return `New ${pattern.levels.item || 'Item'}`;
            }

            if (fieldType === 'description') {
                if (patternKey === 'generic' && itemType) {
                    return patternData.description[itemType] || patternData.description.default;
                }
                return patternData.description || 'Enter detailed description here...';
            }

            if (fieldType === 'notes') {
                return patternData.notes || 'Key considerations and implementation notes...';
            }

            if (fieldType === 'icon') {
                const iconMap = {
                    philosophy: ['ðŸ¤”', 'ðŸ’­', 'ðŸ“œ', 'ðŸ›ï¸', 'âš–ï¸'],
                    sales: ['ðŸ’¼', 'ðŸ’°', 'ðŸ“Š', 'ðŸ¤', 'ðŸ“ˆ'],
                    thesis: ['ðŸ“š', 'ðŸ“', 'ðŸŽ“', 'ðŸ“–', 'âœï¸'],
                    roadmap: ['ðŸš€', 'âš¡', 'ðŸ”§', 'ðŸ’¡', 'ðŸŽ¯'],
                    prompting: ['ðŸ§ ', 'ðŸ¤–', 'âš™ï¸', 'ðŸ”®', 'ðŸ’¬'],
                    book: ['ðŸ“–', 'âœï¸', 'ðŸ“š', 'ðŸ–‹ï¸', 'ðŸ“'],
                    film: ['ðŸŽ¬', 'ðŸŽ¥', 'ðŸŽžï¸', 'ðŸŽ­', 'ðŸ“¹'],
                    course: ['ðŸ“–', 'ðŸŽ“', 'ðŸ“š', 'ðŸ‘¨â€ðŸ«', 'ðŸ“'],
                    strategic: ['ðŸŽ¯', 'ðŸ“Š', 'ðŸ›ï¸', 'ðŸ’¼', 'ðŸ—ºï¸'],
                    generic: ['ðŸ“¦', 'âš™ï¸', 'ðŸ”§', 'ðŸ“Š', 'ðŸ’¼']
                };
                const icons = iconMap[patternKey] || iconMap.generic;
                return icons[Math.floor(Math.random() * icons.length)];
            }

            // Generic pattern: cost and leadTime (other patterns don't use these)
            if (fieldType === 'cost' && patternKey === 'generic') {
                const similarItems = existingItems.filter(item => item.itemType === itemType && item.cost > 0);
                if (similarItems.length > 0) {
                    const costs = similarItems.map(i => i.cost).sort((a, b) => a - b);
                    const median = costs[Math.floor(costs.length / 2)];
                    return Math.round(median * (0.9 + Math.random() * 0.2));
                }
                const costRanges = patternData.cost[phase] || patternData.cost.p1;
                return costRanges[Math.floor(Math.random() * costRanges.length)];
            }

            if (fieldType === 'leadTime' && patternKey === 'generic') {
                return patternData.leadTime[phase] || patternData.leadTime.p1;
            }

            if (fieldType === 'alternateSource' && patternKey === 'generic') {
                return patternData.alternateSource;
            }

            return '';
        }

        // Add AI suggestion capability to text fields
        function enableAISuggestionsOnField(fieldElement, fieldType, itemContext) {
            fieldElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Check if API key available for AI mode
                const hasAPIKey = getLocalAPIKey();
                const modeLabel = hasAPIKey ? 'âœ¨ AI Suggest' : 'ðŸ’¡ Quick Suggest';
                const modeDesc = hasAPIKey ? 'AI-powered contextual suggestion' : 'Template-based suggestion (add API key for AI mode)';

                // Show smart suggestion context menu
                const menu = document.getElementById('context-menu');
                menu.innerHTML = `
                    <div class="context-item" id="ai-suggest-field">${modeLabel}</div>
                    <div class="context-divider"></div>
                    <div class="context-item" style="font-size: 11px; color: var(--text-secondary); cursor: default; padding: 8px 14px;" onmouseover="this.style.background='transparent'">${modeDesc}</div>
                `;
                menu.style.display = 'block';

                // Position menu
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';

                // Smart positioning to avoid going off screen
                const menuRect = menu.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                let finalX = e.pageX;
                let finalY = e.pageY;

                if (menuRect.right > viewportWidth) {
                    finalX = viewportWidth - menuRect.width - 10;
                }
                if (menuRect.bottom > viewportHeight) {
                    finalY = viewportHeight - menuRect.height - 10;
                }
                if (finalX < 10) finalX = 10;
                if (finalY < 10) finalY = 10;

                menu.style.left = finalX + 'px';
                menu.style.top = finalY + 'px';

                // Attach AI suggest handler (ASYNC)
                const aiSuggestBtn = document.getElementById('ai-suggest-field');
                aiSuggestBtn.onclick = async () => {
                    console.log('ðŸ” Smart Suggest clicked:', fieldType, hasAPIKey ? 'AI mode' : 'Quick mode');
                    menu.style.display = 'none';

                    // Get current context including notes field value
                    const currentContext = { ...itemContext };
                    const notesField = document.getElementById('edit-notes');
                    if (notesField) {
                        currentContext.notes = notesField.value;
                    }

                    console.log('ðŸ“‹ Context:', currentContext);

                    // Show loading state
                    const originalValue = fieldElement.value;
                    const originalPlaceholder = fieldElement.placeholder;
                    fieldElement.value = '';
                    fieldElement.placeholder = hasAPIKey ? 'âœ¨ AI is thinking...' : 'ðŸ’¡ Generating suggestion...';
                    fieldElement.style.transition = 'all 0.3s';
                    fieldElement.style.background = 'rgba(99, 102, 241, 0.1)';
                    fieldElement.disabled = true;

                    try {
                        console.log('â³ Calling generateAISuggestion...');
                        // Call AI suggestion (async)
                        const suggestion = await generateAISuggestion(fieldType, currentContext);
                        console.log('âœ… Got suggestion:', suggestion);

                        // Apply suggestion
                        fieldElement.value = suggestion;

                        // Trigger input event for any listeners
                        fieldElement.dispatchEvent(new Event('input', { bubbles: true }));

                        // Success feedback
                        fieldElement.style.background = 'rgba(0, 166, 125, 0.15)';
                        setTimeout(() => {
                            fieldElement.style.background = 'var(--bg)';
                        }, 600);

                    } catch (error) {
                        console.error('âŒ Smart Suggest error:', error);
                        console.error('Error stack:', error.stack);

                        // Restore original value on error
                        fieldElement.value = originalValue;

                        // Error feedback
                        fieldElement.style.background = 'rgba(239, 68, 68, 0.1)';
                        setTimeout(() => {
                            fieldElement.style.background = 'var(--bg)';
                        }, 600);

                        // Show error to user
                        alert(`Smart Suggest Error: ${error.message}\n\nCheck browser console (F12) for details.`);
                    } finally {
                        console.log('ðŸ”„ Re-enabling field');
                        // Re-enable field
                        fieldElement.disabled = false;
                        fieldElement.placeholder = originalPlaceholder;
                    }
                };
            });
        }

        // Helper function to generate dynamic field HTML based on pattern
        function generateFieldHTML(fieldKey, fieldConfig, node) {
            const value = node[fieldKey] || '';
            const fieldId = `edit-${fieldKey}`;

            let inputHTML = '';

            if (fieldConfig.type === 'select') {
                const options = fieldConfig.options.map(opt =>
                    `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`
                ).join('');
                inputHTML = `<select id="${fieldId}">${options}</select>`;
            } else if (fieldConfig.type === 'textarea') {
                inputHTML = `<textarea id="${fieldId}" placeholder="${fieldConfig.placeholder || ''}" style="min-height: 80px;">${value}</textarea>`;
            } else if (fieldConfig.type === 'number') {
                const min = fieldConfig.min !== undefined ? `min="${fieldConfig.min}"` : '';
                const max = fieldConfig.max !== undefined ? `max="${fieldConfig.max}"` : '';
                const step = fieldConfig.step !== undefined ? `step="${fieldConfig.step}"` : '';
                inputHTML = `<input type="number" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" ${min} ${max} ${step} />`;
            } else if (fieldConfig.type === 'date') {
                inputHTML = `<input type="date" id="${fieldId}" value="${value}" />`;
            } else {
                // default to text
                inputHTML = `<input type="text" id="${fieldId}" value="${value}" placeholder="${fieldConfig.placeholder || ''}" />`;
            }

            return `
                <div class="form-group">
                    <label>${fieldConfig.label} <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                    ${inputHTML}
                    ${fieldConfig.helpText ? `<p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">${fieldConfig.helpText}</p>` : ''}
                </div>
            `;
        }

        function handleEdit() {
            if (!activeNode) return;

            // Root node - open Project Settings modal (Build 260)
            if (activeNode.type === 'root') {
                openProjectSettingsModal();
                return;
            }

            // Simple name editing for phase nodes
            if (activeNode.type === 'phase') {
                const labels = getPatternLabels();
                const newName = prompt(`Enter new ${labels.phase} name:`, activeNode.name);

                if (newName && newName !== activeNode.name) {
                    activeNode.name = newName;
                    render();
                }
                return;
            }

            // BUILD 388: Full edit modal for any non-root/non-phase node (items, subtasks, subItems, deep nodes)
            // This enables editing at any depth in the tree
            if (activeNode.type !== 'root' && activeNode.type !== 'phase') {
                const modal = document.getElementById('edit-modal');
                const body = document.getElementById('edit-modal-body');

                // Get all items from all phases for dependency selection
                function getAllItems(node, items = [], phaseName = '') {
                    if (node.phase !== undefined) phaseName = `Phase ${node.phase}`;
                    if (node.items) {
                        node.items.forEach(item => {
                            items.push({ ...item, phaseName });
                        });
                    }
                    if (node.children) {
                        node.children.forEach(child => getAllItems(child, items, phaseName));
                    }
                    return items;
                }

                const allItems = getAllItems(capexTree).filter(item => item.id !== activeNode.id);

                // Build dependency checkboxes
                const currentDeps = activeNode.dependencies || [];
                const depsHtml = allItems.map(item => {
                    const checked = currentDeps.includes(item.id) ? 'checked' : '';
                    return `
                        <label style="display: flex; align-items: center; gap: 10px; padding: 8px 10px; cursor: pointer; font-weight: normal; text-transform: none; letter-spacing: normal; border-radius: 6px; transition: background 0.2s; margin-bottom: 4px;" onmouseover="this.style.background='var(--card-bg-light)'" onmouseout="this.style.background='transparent'">
                            <input type="checkbox" class="dep-checkbox" value="${item.id}" ${checked} style="flex-shrink: 0; width: 18px; height: 18px; cursor: pointer; accent-color: var(--treeplex-primary);" />
                            <span style="flex: 1; display: flex; align-items: center; gap: 8px; font-size: 14px;">
                                <span style="font-size: 18px; flex-shrink: 0;">${item.icon}</span>
                                <span style="flex: 1; color: var(--text-primary);">${item.name}</span>
                                <span style="color: var(--text-secondary); font-size: 11px; padding: 2px 8px; background: var(--card-bg); border-radius: 4px; border: 1px solid var(--border);">${item.phaseName}</span>
                            </span>
                        </label>
                    `;
                }).join('');

                // Get current pattern and its fields configuration
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                // Check if PM tracking should be shown
                const showTracking = fields.includeTracking &&
                                    fields.trackingFor &&
                                    fields.trackingFor.includes(activeNode.type);

                // Build field HTML
                let fieldsHTML = '';

                // 1. PM Tracking Section (conditional)
                if (showTracking) {
                    // Calculate RAG status color
                    const ragStatus = activeNode.pmRAGStatus || 'Amber';
                    const ragColors = {
                        'Green': '#22C55E',
                        'Amber': '#F59E0B',
                        'Red': '#EF4444'
                    };
                    const ragColor = ragColors[ragStatus] || ragColors.Amber;

                    // Calculate time tracking metrics
                    const estHours = activeNode.pmEstimatedHours || 0;
                    const actHours = activeNode.pmActualHours || 0;
                    const remHours = activeNode.pmRemainingHours || estHours - actHours;
                    const timeProgress = estHours > 0 ? Math.min(100, (actHours / estHours) * 100) : 0;
                    const isOverBudget = actHours > estHours;

                    fieldsHTML += `
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--treeplex-primary);">ðŸŽ¯ Project Management</h3>

                        <!-- PM Infographic Dashboard -->
                        <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(99, 102, 241, 0.05) 100%); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 16px;">
                                <!-- RAG Status Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">RAG Status</div>
                                    <div style="width: 48px; height: 48px; border-radius: 50%; background: ${ragColor}; margin: 0 auto; box-shadow: 0 4px 12px ${ragColor}40, inset 0 2px 4px rgba(255,255,255,0.3);"></div>
                                    <div style="font-size: 13px; font-weight: 600; margin-top: 8px; color: ${ragColor};">${ragStatus}</div>
                                </div>

                                <!-- Progress Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Progress</div>
                                    <div style="position: relative; width: 64px; height: 64px; margin: 0 auto;">
                                        <svg width="64" height="64" style="transform: rotate(-90deg);">
                                            <circle cx="32" cy="32" r="28" stroke="var(--border)" stroke-width="6" fill="none"></circle>
                                            <circle cx="32" cy="32" r="28" stroke="var(--treeplex-primary)" stroke-width="6" fill="none"
                                                stroke-dasharray="${(activeNode.pmProgress || 0) * 1.759} 175.9"
                                                stroke-linecap="round"
                                                style="transition: stroke-dasharray 0.3s ease;"></circle>
                                        </svg>
                                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 16px; font-weight: 700; color: var(--treeplex-primary);">${activeNode.pmProgress || 0}%</div>
                                    </div>
                                </div>

                                <!-- Priority Indicator -->
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Priority</div>
                                    <div style="margin-top: 4px;">
                                        ${(() => {
                                            const priority = activeNode.pmPriority || 'Medium';
                                            const priorityIcons = {
                                                'Low': 'ðŸŸ¢',
                                                'Medium': 'ðŸŸ¡',
                                                'High': 'ðŸŸ ',
                                                'Critical': 'ðŸ”´'
                                            };
                                            return `<div style="font-size: 32px; margin: 4px 0;">${priorityIcons[priority] || priorityIcons.Medium}</div>
                                                   <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">${priority}</div>`;
                                        })()}
                                    </div>
                                </div>
                            </div>

                            <!-- Time Tracking Visualization -->
                            ${estHours > 0 ? `
                            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
                                <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); margin-bottom: 8px;">Time Tracking</div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 12px;">
                                    <span>â±ï¸ Estimated: <strong>${estHours}h</strong></span>
                                    <span>âœ… Actual: <strong style="color: ${isOverBudget ? '#EF4444' : '#22C55E'};">${actHours}h</strong></span>
                                    <span>â³ Remaining: <strong>${remHours}h</strong></span>
                                </div>
                                <div style="width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
                                    <div style="width: ${timeProgress}%; height: 100%; background: ${isOverBudget ? '#EF4444' : '#22C55E'}; transition: width 0.3s ease;"></div>
                                </div>
                                ${isOverBudget ? `<div style="font-size: 11px; color: #EF4444; margin-top: 4px; font-weight: 600;">âš ï¸ Over Budget by ${actHours - estHours}h</div>` : ''}
                            </div>
                            ` : ''}
                        </div>

                        <!-- PM Form Fields -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                            <div class="form-group">
                                <label>Status</label>
                                <select id="edit-pm-status">
                                    <option value="To Do" ${activeNode.pmStatus === 'To Do' ? 'selected' : ''}>To Do</option>
                                    <option value="In Progress" ${activeNode.pmStatus === 'In Progress' ? 'selected' : ''}>In Progress</option>
                                    <option value="Completed" ${activeNode.pmStatus === 'Completed' ? 'selected' : ''}>Completed</option>
                                    <option value="Blocked" ${activeNode.pmStatus === 'Blocked' ? 'selected' : ''}>Blocked</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>RAG Status ðŸš¦</label>
                                <select id="edit-pm-rag-status">
                                    <option value="Green" ${ragStatus === 'Green' ? 'selected' : ''}>ðŸŸ¢ Green - On Track</option>
                                    <option value="Amber" ${ragStatus === 'Amber' ? 'selected' : ''}>ðŸŸ¡ Amber - At Risk</option>
                                    <option value="Red" ${ragStatus === 'Red' ? 'selected' : ''}>ðŸ”´ Red - Critical</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Owner Email ðŸ‘¤</label>
                            <input type="email" id="edit-pm-owner-email" value="${activeNode.pmOwnerEmail || activeNode.pmAssignee || ''}" placeholder="owner@company.com" />
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 4px; font-style: italic;">ðŸ“§ Email for collaborative pipeline reviews</p>
                        </div>
                        <div class="form-group">
                            <label>Progress (%)</label>
                            <input type="number" id="edit-pm-progress" value="${activeNode.pmProgress || 0}" min="0" max="100" step="5" />
                        </div>
                        <div class="form-group">
                            <label>Priority</label>
                            <select id="edit-pm-priority">
                                <option value="Low" ${activeNode.pmPriority === 'Low' ? 'selected' : ''}>Low</option>
                                <option value="Medium" ${activeNode.pmPriority === 'Medium' ? 'selected' : ''}>Medium</option>
                                <option value="High" ${activeNode.pmPriority === 'High' ? 'selected' : ''}>High</option>
                                <option value="Critical" ${activeNode.pmPriority === 'Critical' ? 'selected' : ''}>Critical</option>
                            </select>
                        </div>

                        <!-- Time Management Fields -->
                        <div style="margin-top: 16px; padding: 16px; background: rgba(99, 102, 241, 0.05); border: 1px dashed var(--border); border-radius: 8px;">
                            <h4 style="font-size: 14px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">â±ï¸ Time Management</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Estimated (hours)</label>
                                    <input type="number" id="edit-pm-estimated-hours" value="${estHours}" min="0" step="0.5" placeholder="0" />
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Actual (hours)</label>
                                    <input type="number" id="edit-pm-actual-hours" value="${actHours}" min="0" step="0.5" placeholder="0" />
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Remaining (hours)</label>
                                    <input type="number" id="edit-pm-remaining-hours" value="${remHours}" min="0" step="0.5" placeholder="Auto" />
                                </div>
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">ðŸ’¡ Remaining auto-calculates if left empty (Estimated - Actual)</p>
                        </div>
                        <div class="form-group">
                            <label>Start Date</label>
                            <input type="date" id="edit-pm-start-date" value="${activeNode.pmStartDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>Due Date</label>
                            <input type="date" id="edit-pm-due-date" value="${activeNode.pmDueDate || ''}" />
                        </div>
                        <div class="form-group">
                            <label>ðŸš§ Blocking Issue <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                            <textarea id="edit-pm-blocking-issue" style="min-height: 60px;" placeholder="What's preventing progress?">${activeNode.pmBlockingIssue || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>âž¡ï¸ Next Steps <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                            <textarea id="edit-pm-next-steps" style="min-height: 80px;" placeholder="Specific actions needed...">${activeNode.pmNextSteps || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>PM Notes</label>
                            <textarea id="edit-pm-notes" style="min-height: 80px;" placeholder="Task-specific notes, blockers, action items...">${activeNode.pmNotes || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>ðŸ“ Latest Updates</label>
                            <div style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 8px; max-height: 200px; overflow-y: auto;">
                                ${activeNode.pmUpdates && activeNode.pmUpdates.length > 0 ? activeNode.pmUpdates.map((update, idx) => `
                                    <div style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border);">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">${new Date(update.timestamp).toLocaleString()}</div>
                                        <div style="font-size: 13px; line-height: 1.5;">${update.text}</div>
                                        <button onclick="window.deleteUpdate(${idx})" style="margin-top: 6px; padding: 2px 8px; font-size: 10px; background: rgba(239, 68, 68, 0.2); border: 1px solid #EF4444; border-radius: 4px; color: #EF4444; cursor: pointer;">Delete</button>
                                    </div>
                                `).join('') : '<p style="color: var(--text-secondary); font-size: 13px; text-align: center; padding: 20px;">No updates yet</p>'}
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <textarea id="edit-pm-new-update" style="flex: 1; min-height: 60px;" placeholder="Add a new update..."></textarea>
                                <button onclick="window.addUpdate()" style="padding: 8px 16px; background: var(--treeplex-primary); border: none; border-radius: 6px; color: white; font-weight: 600; cursor: pointer; white-space: nowrap;">Add Update</button>
                            </div>
                        </div>
                        <hr style="margin: 24px 0; border: none; border-top: 1px solid var(--border);" />
                        <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--text-secondary);">Details</h3>
                    `;
                }

                // 2. Universal Fields (always shown)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Name <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                        <input type="text" id="edit-name" value="${activeNode.name || ''}" />
                    </div>
                    <div class="form-group">
                        <label>Description <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                        <textarea id="edit-description">${activeNode.description || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label>Icon <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                        <input type="text" id="edit-icon" value="${activeNode.icon || ''}" maxlength="2" />
                    </div>
                    <div class="form-group">
                        <label>Type</label>
                        <select id="edit-type">
                            ${PATTERNS[currentPattern].types.map(type =>
                                `<option value="${type.value}" ${activeNode.itemType === type.value ? 'selected' : ''}>${type.label}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;

                // 3. Collaboration Section (universal - prominent placement) - Build 262: Dynamic team buttons
                fieldsHTML += `
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 12px; padding: 16px; margin: 16px 0;">
                        <h3 style="font-size: 14px; font-weight: 600; margin: 0 0 12px 0; color: var(--treeplex-primary);">ðŸ‘¥ Collaboration</h3>
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label style="font-size: 12px;">ðŸ‘¤ Contributor</label>
                            <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                                <input type="text" id="edit-contributor" style="flex: 1; min-width: 120px; padding: 8px 12px;" placeholder="Your name" value="${activeNode.contributor || ''}" />
                                ${generateContributorButtons()}
                            </div>
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label style="font-size: 12px;">ðŸ’¬ Comments for Collaborators</label>
                            <textarea id="edit-collab-comments" style="min-height: 60px; padding: 8px 12px;" placeholder="Leave notes, questions, or feedback for collaborators...">${activeNode.collabComments || ''}</textarea>
                        </div>
                    </div>
                `;

                // 4. Pattern-Specific Custom Fields (dynamic)
                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }
                    const fieldConfig = fields[fieldKey];
                    fieldsHTML += generateFieldHTML(fieldKey, fieldConfig, activeNode);
                });

                // 5. Notes (universal)
                fieldsHTML += `
                    <div class="form-group">
                        <label>Notes <span style="font-size: 10px; color: var(--text-secondary); font-weight: normal; margin-left: 4px;">(right-click ðŸ’¡)</span></label>
                        <textarea id="edit-notes" style="min-height: 100px;" placeholder="Additional notes...">${activeNode.notes || ''}</textarea>
                    </div>
                `;

                // 6. Dependencies (conditional)
                if (fields.includeDependencies) {
                    fieldsHTML += `
                        <div class="form-group">
                            <label>Dependencies</label>
                            <div style="max-height: 240px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 6px; background: var(--bg);">
                                ${depsHtml || '<p style="color: var(--text-secondary); font-size: 13px; margin: 0; padding: 10px; text-align: center;">No other items available</p>'}
                            </div>
                            <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px; font-style: italic;">âœ“ Select prerequisite items that must be completed first</p>
                        </div>
                    `;
                }

                body.innerHTML = fieldsHTML;

                modal.style.display = 'flex';

                // Enable AI suggestions on text fields after modal is displayed
                setTimeout(() => {
                    // Universal fields
                    const nameField = document.getElementById('edit-name');
                    const descField = document.getElementById('edit-description');
                    const iconField = document.getElementById('edit-icon');
                    const notesField = document.getElementById('edit-notes');

                    if (nameField) enableAISuggestionsOnField(nameField, 'name', activeNode);
                    if (descField) enableAISuggestionsOnField(descField, 'description', activeNode);
                    if (iconField) enableAISuggestionsOnField(iconField, 'icon', activeNode);
                    if (notesField) enableAISuggestionsOnField(notesField, 'notes', activeNode);

                    // Pattern-specific fields (dynamic)
                    Object.keys(fields).forEach(fieldKey => {
                        if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                            return;
                        }
                        const fieldElement = document.getElementById(`edit-${fieldKey}`);
                        if (fieldElement) {
                            enableAISuggestionsOnField(fieldElement, fieldKey, activeNode);
                        }
                    });

                    // Enable AI suggestions for PM fields (conditional)
                    if (showTracking) {
                        const pmBlockingIssueField = document.getElementById('edit-pm-blocking-issue');
                        const pmNextStepsField = document.getElementById('edit-pm-next-steps');

                        if (pmBlockingIssueField) enableAISuggestionsOnField(pmBlockingIssueField, 'pmBlockingIssue', activeNode);
                        if (pmNextStepsField) enableAISuggestionsOnField(pmNextStepsField, 'pmNextSteps', activeNode);
                    }
                }, 50);
            }
        }

        function handleCreate() {
            if (activeNode && activeNode.type === 'phase') {
                // Save state for undo
                saveState(`Create item in ${activeNode.name}`);

                // Create new item in this phase
                const labels = getPatternLabels();
                const defaultType = PATTERNS[currentPattern].types[0].value;
                const newItem = {
                    id: `p${activeNode.phase}-${Date.now()}`,
                    name: `New ${labels.item}`,
                    description: 'Enter description',
                    cost: 0,
                    icon: 'ðŸ“¦',
                    itemType: defaultType,
                    type: 'item',
                    dependencies: [],
                    provenance: {
                        source: 'user',
                        timestamp: new Date().toISOString()
                    }
                };

                if (!activeNode.items) activeNode.items = [];
                activeNode.items.push(newItem);
                activeNode.expanded = true;
                render();
            }
        }

        function handleAddSubtask() {
            // Allow both items AND subtasks to have nested sub-tasks
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask')) {
                const labels = getPatternLabels();
                const isNestedSubtask = activeNode.type === 'subtask';
                const promptLabel = isNestedSubtask ? `nested ${labels.subtask}` : labels.subtask;

                // Prompt for sub-task name
                const subtaskName = prompt(`Enter ${promptLabel} name:`, `New ${isNestedSubtask ? 'Nested ' : ''}${labels.subtask}`);
                if (!subtaskName) return;

                // Save state for undo
                saveState(`Add subtask to ${activeNode.name}`);

                // Get today's date in YYYY-MM-DD format
                const today = new Date().toISOString().split('T')[0];

                // Create new sub-task with PM fields
                const newSubtask = {
                    id: `${activeNode.id}-sub-${Date.now()}`,
                    name: subtaskName,
                    description: 'Task description',
                    cost: 0,
                    icon: 'ðŸ“‹',
                    itemType: 'subtask',
                    type: 'subtask',
                    dependencies: [],
                    parentId: activeNode.id,
                    // Project Management fields
                    pmStatus: 'To Do',
                    pmAssignee: 'Unassigned',
                    pmStartDate: today,
                    pmDueDate: today,
                    pmProgress: 0,
                    pmPriority: 'Medium',
                    pmNotes: '',
                    pmBlockingIssue: '',
                    pmNextSteps: '',
                    pmUpdates: [],
                    // Initialize subItems for nested support
                    subItems: [],
                    // Provenance stamping
                    provenance: {
                        source: 'user',
                        timestamp: new Date().toISOString()
                    }
                };

                // Initialize subItems array if it doesn't exist
                if (!activeNode.subItems) activeNode.subItems = [];
                activeNode.subItems.push(newSubtask);

                // Mark parent as expanded to show sub-tasks
                activeNode.expanded = true;

                render();
                document.getElementById('context-menu').style.display = 'none';
            }
        }

        function handleDelete() {
            // Build 391: Extended to support phase deletion
            if (activeNode && (activeNode.type === 'item' || activeNode.type === 'subtask' || activeNode.type === 'phase')) {
                const labels = getPatternLabels();
                let itemType, confirmMsg;

                if (activeNode.type === 'phase') {
                    itemType = labels.phase || 'phase';
                    const itemCount = activeNode.items ? activeNode.items.length : 0;
                    if (itemCount > 0) {
                        confirmMsg = `Delete "${activeNode.name}" ${itemType}?\n\nâš ï¸ This will also delete ${itemCount} item${itemCount > 1 ? 's' : ''} inside it.`;
                    } else {
                        confirmMsg = `Delete "${activeNode.name}" ${itemType}?`;
                    }
                } else {
                    itemType = activeNode.type === 'subtask' ? 'sub-task' : 'item';
                    confirmMsg = `Delete "${activeNode.name}" ${itemType}?`;
                }

                if (confirm(confirmMsg)) {
                    // Save state for undo
                    saveState(`Delete ${itemType}: ${activeNode.name}`);
                    if (activeNode.type === 'subtask') {
                        // Remove subtask from its parent item (supports nested subtasks)
                        function removeSubtaskRecursive(subtaskId, node = capexTree) {
                            // Check items in this node
                            if (node.items) {
                                for (let item of node.items) {
                                    if (item.subItems) {
                                        const index = item.subItems.findIndex(s => s.id === subtaskId);
                                        if (index !== -1) {
                                            item.subItems.splice(index, 1);
                                            return true;
                                        }
                                        // Check nested subtasks within subtasks
                                        for (let subtask of item.subItems) {
                                            if (removeFromSubItems(subtaskId, subtask)) return true;
                                        }
                                    }
                                }
                            }
                            // Check child phases
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeSubtaskRecursive(subtaskId, child)) return true;
                                }
                            }
                            return false;
                        }
                        // Helper to remove from nested subItems
                        function removeFromSubItems(subtaskId, parent) {
                            if (parent.subItems) {
                                const index = parent.subItems.findIndex(s => s.id === subtaskId);
                                if (index !== -1) {
                                    parent.subItems.splice(index, 1);
                                    return true;
                                }
                                // Recursively check deeper nesting
                                for (let subtask of parent.subItems) {
                                    if (removeFromSubItems(subtaskId, subtask)) return true;
                                }
                            }
                            return false;
                        }
                        removeSubtaskRecursive(activeNode.id);
                    } else if (activeNode.type === 'phase') {
                        // Build 391: Remove phase from root's children array
                        if (capexTree.children) {
                            const index = capexTree.children.findIndex(p => p.id === activeNode.id);
                            if (index !== -1) {
                                capexTree.children.splice(index, 1);
                                console.log(`ðŸ—‘ï¸ Deleted phase: ${activeNode.name}`);
                            }
                        }
                    } else {
                        // Find and remove the item from its parent phase
                        function removeItem(itemId, node = capexTree) {
                            if (node.items) {
                                const index = node.items.findIndex(i => i.id === itemId);
                                if (index !== -1) {
                                    node.items.splice(index, 1);
                                    return true;
                                }
                            }
                            if (node.children) {
                                for (let child of node.children) {
                                    if (removeItem(itemId, child)) return true;
                                }
                            }
                            return false;
                        }
                        removeItem(activeNode.id);
                    }
                    render();

                    // Trigger Firebase sync immediately after delete
                    if (window.pushTreeToFirebase) {
                        console.log('ðŸ”¥ Triggering Firebase sync after delete');
                        window.pushTreeToFirebase();
                    }

                    // Mark as changed for auto-save
                    if (window.treeManager && window.treeManager.markAsChanged) {
                        window.treeManager.markAsChanged();
                    }
                }
            }
        }

        // =============================================================================
        // BUILD 284: LOAD TREE DATA FUNCTION - Centralized tree loading
        // =============================================================================

        /**
         * Load tree data into capexTree and update UI
         * Used by JSON upload, version conflict resolution, and other loaders
         */
        function loadTreeData(data) {
            // BUILD 352: Exit 3D view before loading new tree data
            if (viewMode === '3d') {
                const toggle3DBtn = document.getElementById('toggle-3d-mode');
                if (toggle3DBtn) toggle3DBtn.click();
            }

            // Replace the tree data
            Object.assign(capexTree, data);

            // BUILD 387: Ensure root node has type="root" for editing support
            if (!capexTree.type) {
                capexTree.type = 'root';
            }

            // Restore pattern if saved
            if (capexTree.pattern) {
                // Handle both string and object formats
                if (typeof capexTree.pattern === 'string') {
                    currentPattern = capexTree.pattern;
                } else if (capexTree.pattern.key) {
                    currentPattern = getPatternKey(capexTree.pattern);
                    if (currentPattern === 'custom' && capexTree.pattern.labels) {
                        customPatternNames = capexTree.pattern.labels;
                    }
                }

                const patternSelect = document.getElementById('pattern-select');
                if (patternSelect) {
                    patternSelect.value = currentPattern;
                }

                console.log('Pattern loaded from file:', currentPattern);
                updateSortDropdown();

                if (typeof updateClusterByOptions === 'function') {
                    updateClusterByOptions();
                }
            } else {
                console.log('No pattern in file, using current:', currentPattern);
                updateSortDropdown();

                if (typeof updateClusterByOptions === 'function') {
                    updateClusterByOptions();
                }
            }

            render();

            // Apply default sort for filesystem pattern
            if (currentPattern === 'filesystem') {
                sortTree(null);
            }

            // BUILD 285: Restore view state if saved
            if (data.viewState) {
                const vs = data.viewState;
                console.log('ðŸ“ Restoring view state:', vs);

                // Restore tree view zoom/pan
                if (typeof vs.treeZoom === 'number') zoomLevel = vs.treeZoom;
                if (typeof vs.treePanX === 'number') panX = vs.treePanX;
                if (typeof vs.treePanY === 'number') panY = vs.treePanY;

                // Restore canvas zoom/pan
                if (typeof vs.canvasZoom === 'number') canvasZoom = vs.canvasZoom;
                if (typeof vs.canvasPanX === 'number') canvasPan.x = vs.canvasPanX;
                if (typeof vs.canvasPanY === 'number') canvasPan.y = vs.canvasPanY;

                // Apply tree view transform
                const wrapper = document.getElementById('tree-transform-wrapper');
                if (wrapper) {
                    wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
                }
                const zoomDisplay = document.getElementById('zoom-display');
                if (zoomDisplay) {
                    zoomDisplay.textContent = Math.round(zoomLevel * 100) + '%';
                }

                // Restore view mode (tree or canvas)
                if (vs.viewMode && vs.viewMode !== viewMode) {
                    // Switch to the saved view mode
                    setTimeout(() => {
                        const toggleBtn = document.getElementById('view-toggle');
                        if (toggleBtn && vs.viewMode === 'canvas' && viewMode === 'tree') {
                            toggleBtn.click();
                        } else if (toggleBtn && vs.viewMode === 'tree' && viewMode === 'canvas') {
                            toggleBtn.click();
                        }
                    }, 100);
                }
            } else {
                // BUILD 310: Smart default view for large trees without saved viewState
                // Count total nodes to determine if tree is "large"
                let nodeCount = 0;
                function countNodes(node) {
                    nodeCount++;
                    // Check all child properties - must check length to avoid empty arrays
                    if (node.children && node.children.length > 0) node.children.forEach(countNodes);
                    if (node.items && node.items.length > 0) node.items.forEach(countNodes);
                    if (node.subItems && node.subItems.length > 0) node.subItems.forEach(countNodes);
                }
                countNodes(capexTree);

                console.log(`ðŸ“Š Loaded tree with ${nodeCount} nodes (no saved viewState)`);

                // For large trees (>30 nodes), collapse to show only root + phases
                if (nodeCount > 30) {
                    console.log('ðŸŒ³ Large tree detected - collapsing for better initial view');

                    // Collapse all nodes recursively, getting children from the right property
                    function getChildren(node) {
                        // Check items first (used by philosophy pattern), then children
                        if (node.items && node.items.length > 0) return node.items;
                        if (node.children && node.children.length > 0) return node.children;
                        if (node.subItems && node.subItems.length > 0) return node.subItems;
                        return [];
                    }

                    // Keep root expanded, expand phases (depth 1), collapse rest
                    capexTree.expanded = true;
                    getChildren(capexTree).forEach(phase => {
                        phase.expanded = true; // Show phases
                        // Collapse items within phases
                        getChildren(phase).forEach(item => {
                            item.expanded = false;
                            getChildren(item).forEach(sub => {
                                sub.expanded = false;
                            });
                        });
                    });

                    // Re-render with collapsed state
                    render();
                }

                // Reset zoom/pan to defaults
                zoomLevel = 1.0;
                panX = 0;
                panY = 0;

                const wrapper = document.getElementById('tree-transform-wrapper');
                if (wrapper) {
                    wrapper.style.transform = `translate(0px, 0px) scale(1)`;
                }
                const zoomDisplay = document.getElementById('zoom-display');
                if (zoomDisplay) {
                    zoomDisplay.textContent = '100%';
                }

                // BUILD 312: Reset scroll position to show tree from top-left
                const treeContainer = document.getElementById('tree-container');
                if (treeContainer) {
                    treeContainer.scrollTop = 0;
                    treeContainer.scrollLeft = 0;
                }

                // BUILD 313/314: For filesystem pattern, align tree to top-left instead of center
                if (currentPattern === 'filesystem') {
                    if (wrapper) {
                        wrapper.style.alignItems = 'flex-start';
                        wrapper.style.justifyContent = 'flex-start';
                        wrapper.style.padding = '20px';
                        wrapper.style.transformOrigin = 'top left';
                    }
                    if (treeContainer) {
                        treeContainer.style.alignItems = 'flex-start';
                        treeContainer.style.justifyContent = 'flex-start';
                    }
                } else {
                    // For other patterns, ensure transform-origin is center (default)
                    if (wrapper) {
                        wrapper.style.transformOrigin = 'center center';
                    }
                }
            }

            // Mark tree manager as having this tree loaded
            if (window.treeManager) {
                window.treeManager.currentTreeId = data.id;
                window.treeManager.hasUnsavedChanges = false;
            }
        }

        /**
         * BUILD 284: Show version conflict dialog
         * When loading a file that has a newer version in LocalStorage
         */
        function showVersionConflictDialog(options) {
            const { treeId, treeName, fileData, fileDate, localData, localDate, localItemCount } = options;

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            // Count items in file
            let fileItemCount = 0;
            if (fileData.children) {
                fileData.children.forEach(phase => {
                    if (phase.items) {
                        fileItemCount += phase.items.length;
                        phase.items.forEach(item => {
                            if (item.subItems) fileItemCount += item.subItems.length;
                        });
                    }
                });
            }

            modalBody.innerHTML = `
                <div style="padding: 30px; max-width: 550px;">
                    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 24px;">
                        <div style="font-size: 48px;">âš ï¸</div>
                        <div>
                            <h3 style="color: #F59E0B; margin-bottom: 4px;">Newer Version Found Locally</h3>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                "${treeName}" has a more recent version in your browser
                            </div>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 24px;">
                        <!-- File Version -->
                        <div style="padding: 16px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px;">
                            <div style="font-size: 11px; color: rgba(239, 68, 68, 0.8); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">ðŸ“ File Version (Older)</div>
                            <div style="font-size: 13px; color: var(--text-primary); margin-bottom: 4px;">Modified: ${fileDate}</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">${fileItemCount} items</div>
                        </div>

                        <!-- Local Version -->
                        <div style="padding: 16px; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px;">
                            <div style="font-size: 11px; color: rgba(16, 185, 129, 0.8); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">ðŸ’¾ Local Version (Newer)</div>
                            <div style="font-size: 13px; color: var(--text-primary); margin-bottom: 4px;">Modified: ${localDate}</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">${localItemCount} items</div>
                        </div>
                    </div>

                    <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 24px; line-height: 1.6;">
                        Your browser has auto-saved changes that aren't in the file you're loading.
                        Which version would you like to use?
                    </p>

                    <div style="display: flex; gap: 12px; justify-content: flex-end; flex-wrap: wrap;">
                        <button onclick="document.getElementById('modal').style.display='none'"
                            style="padding: 10px 20px; background: rgba(107, 114, 128, 0.2); color: var(--text-secondary); border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; font-size: 13px;">
                            Cancel
                        </button>
                        <button onclick="loadVersionChoice('file')"
                            style="padding: 10px 20px; background: rgba(239, 68, 68, 0.2); color: #EF4444; border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 6px; cursor: pointer; font-size: 13px;">
                            ðŸ“ Load File (Older)
                        </button>
                        <button onclick="loadVersionChoice('local', '${treeId}')"
                            style="padding: 10px 20px; background: rgba(16, 185, 129, 0.2); color: #10B981; border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 6px; cursor: pointer; font-size: 13px;">
                            ðŸ’¾ Load Local (Newer)
                        </button>
                    </div>
                </div>
            `;

            // Store file data for potential loading
            window._pendingFileData = fileData;

            modal.style.display = 'flex';
        }

        /**
         * BUILD 284: Handle version choice from conflict dialog
         */
        function loadVersionChoice(choice, treeId) {
            document.getElementById('modal').style.display = 'none';

            if (choice === 'file') {
                // Load the file version from stored pending data
                const data = window._pendingFileData;
                if (data) {
                    loadTreeData(data);
                    showToast(`Loaded file version: ${data.name || 'Tree'}`, 'success');
                }
            } else if (choice === 'local') {
                // Load from LocalStorage
                const localTree = localStorage.getItem(`treelisty:tree:${treeId}`);
                if (localTree) {
                    try {
                        const data = JSON.parse(localTree);
                        migrateTree(data);
                        loadTreeData(data);
                        showToast(`Loaded local version: ${data.name || 'Tree'}`, 'success');
                    } catch (err) {
                        showToast('Failed to load local version', 'error');
                    }
                }
            }

            // Cleanup
            window._pendingFileData = null;
        }

        // =============================================================================
        // TREE MANAGER - Save/Load with Auto-Save & Organized Folders
        // =============================================================================

        class TreeManager {
            constructor() {
                this.currentTreeId = null;
                this.lastSaveTimestamp = null;
                this.hasUnsavedChanges = false;
                this.autoSaveInterval = null;
            }

            initialize() {
                console.log('ðŸŒ³ TreeManager: Initializing...');
                console.log('ðŸ’¾ Save mode: LocalStorage + Download to Downloads folder');
                this.loadTreeFromURLOrStorage();
                this.startAutoSave(120);
                this.startIndicatorUpdates();
                this.watchForChanges();
            }

            getTimestamp() {
                const now = new Date();
                const y = now.getFullYear();
                const m = String(now.getMonth() + 1).padStart(2, '0');
                const d = String(now.getDate()).padStart(2, '0');
                const h = String(now.getHours()).padStart(2, '0');
                const min = String(now.getMinutes()).padStart(2, '0');
                const s = String(now.getSeconds()).padStart(2, '0');
                return `${y}${m}${d}-${h}${min}${s}`;
            }

            slugify(text) {
                return text.toString().toLowerCase().trim()
                    .replace(/\s+/g, '-').replace(/[^\w\-]+/g, '')
                    .replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
            }

            generateFilename(tree) {
                const pattern = tree.pattern?.key || 'generic';
                const treeName = tree.name || 'project';
                const slug = this.slugify(treeName);
                const timestamp = this.getTimestamp();

                // Format: treelisty-<pattern>-<name>-<timestamp>.json
                // Example: treelisty-philosophy-plato-cave-20251118-153045.json
                return `treelisty-${pattern}-${slug}-${timestamp}.json`;
            }

            saveToLocalStorage(tree) {
                try {
                    const treeId = tree.id || 'default';
                    const jsonStr = JSON.stringify(tree, null, 2);
                    localStorage.setItem(`treelisty:tree:${treeId}`, jsonStr);
                    const metadata = this.extractMetadata(tree);
                    localStorage.setItem(`treelisty:meta:${treeId}`, JSON.stringify(metadata));
                    this.lastSaveTimestamp = Date.now();
                    this.hasUnsavedChanges = false;
                    console.log(`ðŸ’¾ Saved to LocalStorage: ${treeId}`);
                    return true;
                } catch (error) {
                    console.error('âŒ LocalStorage save failed:', error);
                    return false;
                }
            }

            extractMetadata(tree) {
                return {
                    id: tree.id || 'default',
                    name: tree.name || 'Untitled',
                    pattern: tree.pattern?.key || 'generic',
                    itemCount: this.countItems(tree),
                    lastModified: Date.now(),
                    lastSaved: this.lastSaveTimestamp
                };
            }

            countItems(tree) {
                let count = 0;
                if (tree.children) {
                    tree.children.forEach(phase => {
                        if (phase.items) {
                            count += phase.items.length;
                            phase.items.forEach(item => {
                                if (item.subItems) count += item.subItems.length;
                                if (item.subtasks) count += item.subtasks.length;
                            });
                        }
                    });
                }
                return count;
            }

            downloadJSON(tree) {
                try {
                    const filename = this.generateFilename(tree);
                    const jsonStr = JSON.stringify(tree, null, 2);
                    const blob = new Blob([jsonStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    console.log(`ðŸ’¾ Downloaded: ${filename}`);
                    if (typeof showToast === 'function') showToast(`âœ… Saved: ${filename}`);
                    return true;
                } catch (error) {
                    console.error('âŒ Download failed:', error);
                    return false;
                }
            }

            save(tree, options = {}) {
                const { silent = false, forceSaveAs = false } = options;

                // BUILD 285: Capture current view state before saving
                tree.viewState = {
                    viewMode: typeof viewMode !== 'undefined' ? viewMode : 'tree',
                    treeZoom: typeof zoomLevel !== 'undefined' ? zoomLevel : 1,
                    treePanX: typeof panX !== 'undefined' ? panX : 0,
                    treePanY: typeof panY !== 'undefined' ? panY : 0,
                    canvasZoom: typeof canvasZoom !== 'undefined' ? canvasZoom : 1,
                    canvasPanX: typeof canvasPan !== 'undefined' ? canvasPan.x : 0,
                    canvasPanY: typeof canvasPan !== 'undefined' ? canvasPan.y : 0
                };

                // Save to LocalStorage for auto-save tracking
                this.saveToLocalStorage(tree);

                // Download JSON file (only on manual save, not auto-save)
                if (!silent) {
                    this.downloadJSON(tree);
                    this.updateSaveIndicator('saved');
                }

                this.addToRecentFiles(tree);
            }

            startAutoSave(intervalSeconds) {
                console.log(`â° Auto-save enabled: every ${intervalSeconds} seconds`);
                this.autoSaveInterval = setInterval(() => {
                    if (this.hasUnsavedChanges) {
                        console.log('ðŸ’¾ Auto-saving...');
                        this.save(capexTree, { silent: true });
                    }
                }, intervalSeconds * 1000);
            }

            startIndicatorUpdates() {
                // Update save indicator every 30 seconds to keep "Saved Xm ago" current
                setInterval(() => {
                    if (this.lastSaveTimestamp && !this.hasUnsavedChanges) {
                        this.updateSaveIndicator('saved');
                    }
                }, 30000); // 30 seconds
            }

            watchForChanges() {
                this.hasUnsavedChanges = true;
            }

            markAsChanged() {
                this.hasUnsavedChanges = true;
                this.updateSaveIndicator('unsaved');
            }

            updateSaveIndicator(status) {
                const indicator = document.getElementById('save-indicator');
                if (!indicator) return;
                if (status === 'saving') {
                    indicator.textContent = 'ðŸ’¾ Saving...';
                    indicator.style.color = '#9DA3B4';
                } else if (status === 'saved') {
                    const timeAgo = this.getTimeAgo(this.lastSaveTimestamp);
                    indicator.textContent = `âœ“ Saved ${timeAgo}`;
                    indicator.style.color = '#5FA463';
                } else if (status === 'unsaved') {
                    indicator.textContent = 'â— Unsaved changes';
                    indicator.style.color = '#D68A2E';
                }
            }

            getTimeAgo(timestamp) {
                if (!timestamp) return 'just now';
                const seconds = Math.floor((Date.now() - timestamp) / 1000);
                if (seconds < 10) return 'just now';
                if (seconds < 60) return `${seconds}s ago`;
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            }

            addToRecentFiles(tree) {
                try {
                    let recent = this.getRecentFiles();
                    const metadata = this.extractMetadata(tree);
                    recent = recent.filter(r => r.id !== metadata.id);
                    recent.unshift(metadata);
                    recent = recent.slice(0, 10);
                    localStorage.setItem('treelisty:recent', JSON.stringify(recent));
                } catch (error) {
                    console.error('âŒ Failed to update recent files:', error);
                }
            }

            getRecentFiles() {
                try {
                    const data = localStorage.getItem('treelisty:recent');
                    return data ? JSON.parse(data) : [];
                } catch (error) {
                    return [];
                }
            }

            loadTreeFromURLOrStorage() {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('data')) {
                    console.log('ðŸ“¥ Loading tree from shared URL...');
                    return;
                }
                const treeId = 'default';
                const treeData = localStorage.getItem(`treelisty:tree:${treeId}`);
                if (treeData) {
                    try {
                        const tree = JSON.parse(treeData);

                        // Migrate tree to current schema (Cognitive Citadel Foundation)
                        migrateTree(tree);

                        console.log('ðŸ“¥ Loaded tree from LocalStorage:', treeId);
                        Object.assign(capexTree, tree);
                        this.currentTreeId = treeId;

                        // BUILD 379: Restore pattern from saved tree
                        if (tree.pattern) {
                            const patternKey = typeof tree.pattern === 'string'
                                ? tree.pattern
                                : (tree.pattern.key || 'generic');

                            if (PATTERNS[patternKey]) {
                                currentPattern = patternKey;
                                console.log(`ðŸŽ¨ Restored pattern: ${patternKey}`);

                                // Update pattern selector UI
                                const patternSelect = document.getElementById('pattern-select');
                                if (patternSelect) {
                                    patternSelect.value = patternKey;
                                }

                                // Handle custom pattern labels
                                if (patternKey === 'custom' && tree.pattern.labels) {
                                    customPatternNames = tree.pattern.labels;
                                }

                                // BUILD 380: Show biographer indicator for LifeTree
                                setTimeout(() => {
                                    if (typeof checkBiographerIndicator === 'function') {
                                        checkBiographerIndicator();
                                    }
                                }, 100);
                            }
                        }
                    } catch (error) {
                        console.error('âŒ Failed to load tree from LocalStorage:', error);
                    }
                }
            }
        }

        const treeManager = new TreeManager();
        // Expose treeManager to window for Firebase sync
        window.treeManager = treeManager;
        window.addEventListener('DOMContentLoaded', () => {
            treeManager.initialize();
        });

        // BUILD 284: Warn user before closing if there are unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (treeManager.hasUnsavedChanges) {
                const message = 'You have unsaved changes. Are you sure you want to leave?';
                e.preventDefault();
                e.returnValue = message;
                return message;
            }
        });

        // Enhanced save function
        function handleDownload() {
            treeManager.save(capexTree, { forceSaveAs: false });
        }

        function handleUpload() {
            document.getElementById('json-upload-input').click();
        }

        function handleExpandAll() {
            function expandAll(node) {
                if (node.children) {
                    node.expanded = true;
                    node.children.forEach(expandAll);
                }
            }
            expandAll(capexTree);
            render();
        }

        function handleCollapseAll() {
            function collapseAll(node) {
                if (node.children) {
                    node.expanded = false;
                    node.children.forEach(collapseAll);
                }
            }
            capexTree.children.forEach(collapseAll);
            render();
        }

        // Toggle subtasks for a specific item
        window.toggleSubtasks = function(itemId) {
            function findAndToggle(node) {
                if (node.items) {
                    const item = node.items.find(i => i.id === itemId);
                    if (item) {
                        item.expanded = !item.expanded;
                        render();
                        return true;
                    }
                }
                if (node.children) {
                    for (let child of node.children) {
                        if (findAndToggle(child)) return true;
                    }
                }
                return false;
            }
            findAndToggle(capexTree);
        };

        // Add update to current activeNode
        window.addUpdate = function() {
            if (!activeNode) return;
            const updateText = document.getElementById('edit-pm-new-update').value.trim();
            if (!updateText) {
                alert('Please enter an update message');
                return;
            }

            if (!activeNode.pmUpdates) activeNode.pmUpdates = [];
            activeNode.pmUpdates.unshift({
                timestamp: new Date().toISOString(),
                text: updateText
            });

            // Clear the input and re-render the modal
            document.getElementById('edit-pm-new-update').value = '';
            handleEdit(); // Re-render the edit modal to show the new update
        };

        // Delete update from current activeNode
        window.deleteUpdate = function(index) {
            if (!activeNode || !activeNode.pmUpdates) return;
            if (confirm('Delete this update?')) {
                activeNode.pmUpdates.splice(index, 1);
                handleEdit(); // Re-render the edit modal
            }
        };

        async function handleAI() {
            if (activeNode) {
                const modal = document.getElementById('modal');
                const modalBody = document.getElementById('modal-body');

                // Show loading state
                modalBody.innerHTML = `
                    <div style="padding: 40px; text-align: center;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">AI is analyzing ${activeNode.name}...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                `;
                modal.style.display = 'flex';

                try {
                    // Determine analysis type (subtask, item, or project)
                    let analysisType = 'item';
                    if (activeNode.type === 'root') {
                        analysisType = 'project';
                    } else if (activeNode.type === 'subtask') {
                        analysisType = 'subtask';
                    }

                    // Call real AI
                    const aiResponse = await generateAIAnalysis(activeNode, analysisType);

                    // Display AI response with markdown-like formatting
                    modalBody.innerHTML = `
                        <div style="padding: 20px; line-height: 1.8;">
                            <div style="white-space: pre-wrap; font-size: 14px; color: var(--text-primary);">${aiResponse}</div>
                            <div style="margin-top: 24px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ðŸ¤– Analysis powered by Claude Sonnet â€¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;

                } catch (error) {
                    // Show error
                    modalBody.innerHTML = `
                        <div style="padding: 30px; text-align: center;">
                            <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                            <h3 style="margin-bottom: 16px; color: var(--text-primary);">AI Analysis Failed</h3>
                            <p style="margin-bottom: 24px; color: var(--text-secondary); line-height: 1.6;">
                                ${error.message}
                            </p>
                            <p style="font-size: 12px; color: var(--text-secondary);">
                                If this problem persists, contact geej support.
                            </p>
                        </div>
                    `;
                }
            }
        }

        // =============================================================================
        // DEEP DIVE ANALYSIS - Structured Scholar for Selected Nodes
        // =============================================================================
        // PHILOSOPHY RELATIONSHIP INFERENCE HELPERS
        // =============================================================================

        /**
         * Infer dialectical relation between nodes based on their types
         */
        function inferDialecticalRelation(nodes) {
            const types = nodes.map(n => n.itemType).filter(Boolean);

            // Check for thesis-antithesis patterns
            if (types.includes('premise') && types.includes('objection')) {
                return 'Thesis-Antithesis: A claim is challenged by a counter-argument';
            }
            if (types.includes('premise') && types.includes('refutation')) {
                return 'Dialectical Exchange: Premises face critical refutation';
            }
            if (types.includes('conclusion') && types.includes('objection')) {
                return 'Conclusion Under Scrutiny: Final claim faces objection';
            }
            if (types.includes('definition') && types.includes('distinction')) {
                return 'Conceptual Clarification: Definitions refined through distinction';
            }
            if (types.includes('implicit-premise') && types.includes('premise')) {
                return 'Hidden Foundations: Explicit claims rest on implicit assumptions';
            }
            if (types.every(t => t === 'premise')) {
                return 'Cumulative Argument: Multiple premises building toward conclusion';
            }
            if (types.includes('thought-experiment')) {
                return 'Exploratory Dialectic: Thought experiments probe conceptual boundaries';
            }

            return 'Conceptual Network: Interrelated philosophical claims';
        }

        /**
         * Infer argumentative flow direction
         */
        function inferArgumentativeFlow(nodes) {
            const types = nodes.map(n => n.itemType).filter(Boolean);

            if (types.includes('premise') && types.includes('conclusion')) {
                return 'Deductive: Premises â†’ Conclusion';
            }
            if (types.includes('objection') && types.includes('refutation')) {
                return 'Refutational: Objection â†’ Counter-Response';
            }
            if (types.filter(t => t === 'premise').length >= 2) {
                return 'Synthetic: Multiple premises converging';
            }
            if (types.includes('distinction')) {
                return 'Analytical: Concepts being differentiated';
            }
            if (types.includes('definition')) {
                return 'Foundational: Establishing base definitions';
            }

            return 'Exploratory: Mapping conceptual territory';
        }

        /**
         * Infer the conceptual bridge connecting the nodes
         */
        function inferConceptualBridge(nodes) {
            // Look for shared key terms or speakers
            const allKeyTerms = nodes.flatMap(n => n.keyTerms || []);
            const termCounts = {};
            allKeyTerms.forEach(t => {
                const term = typeof t === 'string' ? t : t.term;
                if (term) termCounts[term] = (termCounts[term] || 0) + 1;
            });

            // Find terms appearing in multiple nodes
            const sharedTerms = Object.entries(termCounts)
                .filter(([_, count]) => count > 1)
                .map(([term, _]) => term);

            if (sharedTerms.length > 0) {
                return `Shared Concepts: ${sharedTerms.slice(0, 3).join(', ')}`;
            }

            // Check speakers
            const speakers = [...new Set(nodes.map(n => n.speaker).filter(Boolean))];
            if (speakers.length === 1) {
                return `Single Voice: All claims attributed to ${speakers[0]}`;
            }
            if (speakers.length > 1) {
                return `Dialogue: Exchange between ${speakers.slice(0, 2).join(' and ')}`;
            }

            return 'Thematic Unity: Connected through subject matter';
        }

        // =============================================================================
        // DEEP DIVE ANALYSIS (Structured Scholar)
        // =============================================================================
        // Enriches selected nodes with:
        // - subItems (objections, counter-arguments, implications)
        // - Missing fields (speaker, keyTerms, textualReference)
        // - Creates hyperedge linking analyzed nodes
        // =============================================================================

        async function handleAnalyzeSelection(nodes) {
            if (!nodes || nodes.length === 0) {
                console.warn('No nodes to analyze');
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            // Get pattern context
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;
            const isPhilosophy = currentPattern === 'philosophy';

            // Show loading state with progress
            const nodeNames = nodes.map(n => n.name).join(', ');
            const truncatedNames = nodeNames.length > 100 ? nodeNames.substring(0, 100) + '...' : nodeNames;

            modalBody.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <div class="spinner" style="margin: 0 auto 20px;"></div>
                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px;">ðŸŽ“ Deep Dive Analysis</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 8px;">
                        Analyzing ${nodes.length} node${nodes.length > 1 ? 's' : ''}...
                    </p>
                    <p style="font-size: 12px; color: var(--text-secondary); opacity: 0.7;">
                        ${truncatedNames}
                    </p>
                    <div style="margin-top: 20px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 8px;">
                        <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                            ðŸ”¬ Structured Scholar technique: Identifying objections, implications, and hidden premises...
                        </p>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';

            try {
                // Build context from tree
                const treeContext = {
                    projectName: capexTree.name,
                    projectDescription: capexTree.description,
                    pattern: currentPattern,
                    metadata: capexTree.metadata || {}
                };

                // Find parent phases for context
                const nodesWithContext = nodes.map(node => {
                    let parentPhase = null;
                    if (capexTree.children) {
                        for (const phase of capexTree.children) {
                            if (phase.items && phase.items.find(item => item.id === node.id)) {
                                parentPhase = { name: phase.name, subtitle: phase.subtitle };
                                break;
                            }
                        }
                    }
                    return { ...node, parentPhase };
                });

                // Build the Structured Scholar prompt
                const prompt = buildDeepDivePrompt(nodesWithContext, treeContext, isPhilosophy);

                // Call AI
                const response = await callDeepDiveAI(prompt, isPhilosophy);

                // Parse and merge the enriched data (new format returns { nodes, relationshipAnalysis })
                const parseResult = parseDeepDiveResponse(response, nodes);
                const enrichedNodes = parseResult.nodes || parseResult; // Handle both new and legacy format
                const aiRelationshipAnalysis = parseResult.relationshipAnalysis || null;

                if (enrichedNodes && enrichedNodes.length > 0) {
                    // Save state for undo
                    saveState('Deep Dive Analysis');

                    // Merge enriched data into actual nodes
                    let totalSubItemsAdded = 0;
                    enrichedNodes.forEach(enriched => {
                        const originalNode = nodes.find(n => n.id === enriched.id);
                        if (originalNode) {
                            // Merge fields (don't overwrite existing non-empty values)
                            if (enriched.speaker && !originalNode.speaker) originalNode.speaker = enriched.speaker;
                            if (enriched.keyTerms && !originalNode.keyTerms) originalNode.keyTerms = enriched.keyTerms;
                            if (enriched.textualReference && !originalNode.textualReference) originalNode.textualReference = enriched.textualReference;
                            if (enriched.argumentType && !originalNode.argumentType) originalNode.argumentType = enriched.argumentType;

                            // Merge subItems (add new ones, don't duplicate)
                            if (enriched.subItems && enriched.subItems.length > 0) {
                                if (!originalNode.subItems) originalNode.subItems = [];
                                enriched.subItems.forEach(newSubItem => {
                                    // Check if similar subItem already exists
                                    const exists = originalNode.subItems.some(
                                        existing => existing.name.toLowerCase() === newSubItem.name.toLowerCase()
                                    );
                                    if (!exists) {
                                        // Add ID and type if missing
                                        newSubItem.id = newSubItem.id || `subitem-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
                                        newSubItem.type = newSubItem.type || 'subtask';
                                        originalNode.subItems.push(newSubItem);
                                        totalSubItemsAdded++;
                                    }
                                });
                            }
                        }
                    });

                    // Create hyperedge if multiple nodes were analyzed
                    // Include BOTH original nodes AND their newly generated subitems (Venn diagram effect)
                    let hyperedgeCreated = false;
                    if (nodes.length >= 2) {
                        // Collect all node IDs including subitems
                        const allNodeIds = [];
                        nodes.forEach(n => {
                            allNodeIds.push(n.id);
                            // Include subitems in the hyperedge
                            if (n.subItems) {
                                n.subItems.forEach(sub => allNodeIds.push(sub.id));
                            }
                        });
                        const nodeIds = allNodeIds;
                        console.log('ðŸ”— Creating Deep Dive hyperedge with nodeIds:', nodeIds);

                        // Build analysis metadata - USE AI's relationship analysis if available
                        const analysisMetadata = {
                            analyzedNodes: nodes.map(n => ({ id: n.id, name: n.name, itemType: n.itemType })),
                            totalSubItemsGenerated: totalSubItemsAdded,
                            analysisMethod: 'Structured Scholar',
                            pattern: currentPattern
                        };

                        // Use AI-generated relationship analysis if available, else fallback to inference
                        if (aiRelationshipAnalysis) {
                            // AI provided scholarly analysis of the relationship
                            analysisMetadata.philosophyFields = {
                                dialecticalRelation: aiRelationshipAnalysis.dialecticalRelation || '',
                                argumentativeFlow: aiRelationshipAnalysis.argumentativeFlow || '',
                                conceptualBridge: aiRelationshipAnalysis.conceptualBridge || '',
                                tension: aiRelationshipAnalysis.tension || '',
                                synthesis: aiRelationshipAnalysis.synthesis || '',
                                relationshipType: aiRelationshipAnalysis.relationshipType || '',
                                speakers: [...new Set(nodes.map(n => n.speaker).filter(Boolean))],
                                itemTypes: [...new Set(nodes.map(n => n.itemType).filter(Boolean))],
                                tradition: capexTree.metadata?.tradition || 'Unknown',
                                aiGenerated: true  // Flag that this came from AI analysis
                            };
                            console.log('ðŸ§  Using AI-generated relationship analysis:', aiRelationshipAnalysis);
                        } else if (isPhilosophy) {
                            // Fallback to rule-based inference
                            const itemTypes = nodes.map(n => n.itemType).filter(Boolean);
                            const speakers = nodes.map(n => n.speaker).filter(Boolean);

                            analysisMetadata.philosophyFields = {
                                dialecticalRelation: inferDialecticalRelation(nodes),
                                argumentativeFlow: inferArgumentativeFlow(nodes),
                                conceptualBridge: inferConceptualBridge(nodes),
                                speakers: [...new Set(speakers)],
                                itemTypes: [...new Set(itemTypes)],
                                tradition: capexTree.metadata?.tradition || 'Unknown',
                                aiGenerated: false
                            };
                        }

                        // Generate label from AI's relationshipType or fallback
                        let hyperedgeLabel = 'ðŸŽ“ Deep Dive Analysis';
                        if (aiRelationshipAnalysis?.relationshipType) {
                            // Use AI's concise relationship type as the label
                            hyperedgeLabel = `ðŸ›ï¸ ${aiRelationshipAnalysis.relationshipType}`;
                        } else if (isPhilosophy && analysisMetadata.philosophyFields) {
                            // Fallback to inferred dialectical relation
                            const dialectical = analysisMetadata.philosophyFields.dialecticalRelation || '';
                            const labelType = dialectical.split(':')[0].trim();
                            if (labelType && labelType !== 'Conceptual Network') {
                                hyperedgeLabel = `ðŸ›ï¸ ${labelType}`;
                            }
                        }

                        // Generate unique color based on number of existing analysis hyperedges
                        if (!capexTree.hyperedges) capexTree.hyperedges = [];
                        const existingAnalysisCount = capexTree.hyperedges.filter(h => h.type === 'analysis').length;
                        const uniqueColor = generateHyperedgeColor(existingAnalysisCount);

                        // Store the color in metadata
                        analysisMetadata.color = uniqueColor;

                        const hyperedge = {
                            id: `hyperedge-deepdive-${Date.now()}`,
                            nodeIds: nodeIds,
                            label: hyperedgeLabel,
                            description: aiRelationshipAnalysis?.dialecticalRelation || `Structured Scholar analysis linking: ${nodes.map(n => n.name).join(', ')}`,
                            createdAt: new Date().toISOString(),
                            type: 'analysis',
                            metadata: analysisMetadata
                        };

                        capexTree.hyperedges.push(hyperedge);
                        hyperedgeCreated = true;

                        console.log('ðŸ”— Hyperedge created:', hyperedge);
                        console.log('ðŸ”— Total hyperedges now:', capexTree.hyperedges.length);
                    }

                    // Re-render
                    render();
                    // Check if canvas view is active by looking at container class
                    const canvasContainer = document.getElementById('canvas-container');
                    const isCanvasActive = canvasContainer && canvasContainer.classList.contains('active');

                    // If hyperedge was created, auto-focus on it for clean visualization
                    if (hyperedgeCreated && isCanvasActive) {
                        // Short delay to ensure modal is shown first
                        setTimeout(() => {
                            focusOnHyperedge(hyperedge.id);
                        }, 100);
                    } else if (isCanvasActive) {
                        renderCanvas();
                        drawHyperedges();
                    }

                    // Show success with summary
                    modalBody.innerHTML = `
                        <div style="padding: 30px;">
                            <div style="text-align: center; margin-bottom: 24px;">
                                <div style="font-size: 48px; margin-bottom: 16px;">ðŸŽ“</div>
                                <h3 style="color: var(--treeplex-primary); margin-bottom: 8px;">Deep Dive Complete!</h3>
                                <p style="color: var(--text-secondary);">
                                    Analyzed ${nodes.length} node${nodes.length > 1 ? 's' : ''} using Structured Scholar
                                </p>
                            </div>

                            <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                                <h4 style="color: #10B981; margin-bottom: 12px;">ðŸ“Š Analysis Summary</h4>
                                <ul style="margin: 0; padding-left: 20px; color: var(--text-primary); line-height: 1.8;">
                                    <li><strong>${totalSubItemsAdded}</strong> new sub-items added (objections, implications, etc.)</li>
                                    <li><strong>${enrichedNodes.filter(n => n.speaker).length}</strong> speaker attributions</li>
                                    <li><strong>${enrichedNodes.filter(n => n.keyTerms).length}</strong> key term annotations</li>
                                    ${hyperedgeCreated ? `<li>ðŸ”— <strong>Hyperedge created</strong> linking analyzed nodes</li>` : ''}
                                </ul>
                            </div>

                            <div style="background: rgba(99, 102, 241, 0.1); border-radius: 8px; padding: 16px;">
                                <h4 style="color: var(--treeplex-primary); margin-bottom: 8px;">ðŸ’¡ What's New</h4>
                                <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                                    Expand the analyzed nodes to see new sub-items including objections, counter-arguments,
                                    hidden premises, and philosophical implications. ${hyperedgeCreated ? 'The purple hyperedge in Canvas View shows the conceptual relationship between these nodes.' : ''}
                                </p>
                            </div>

                            <div style="margin-top: 20px; text-align: center;">
                                <button onclick="document.getElementById('modal').style.display='none'"
                                    style="padding: 12px 24px; background: var(--treeplex-primary); color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
                                    Got it!
                                </button>
                            </div>
                        </div>
                    `;

                } else {
                    throw new Error('AI returned no enrichment data. Try again or select different nodes.');
                }

            } catch (error) {
                console.error('Deep Dive Analysis failed:', error);
                modalBody.innerHTML = `
                    <div style="padding: 30px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                        <h3 style="margin-bottom: 16px; color: var(--text-primary);">Deep Dive Analysis Failed</h3>
                        <p style="margin-bottom: 24px; color: var(--text-secondary); line-height: 1.6;">
                            ${error.message}
                        </p>
                        <button onclick="document.getElementById('modal').style.display='none'"
                            style="padding: 10px 20px; background: var(--treeplex-primary); color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Close
                        </button>
                    </div>
                `;
            }
        }

        // Build the Structured Scholar deep dive prompt
        function buildDeepDivePrompt(nodesWithContext, treeContext, isPhilosophy) {
            const nodesJson = JSON.stringify(nodesWithContext, null, 2);
            const multipleNodes = nodesWithContext.length >= 2;

            if (isPhilosophy) {
                return {
                    system: `You are a philosophy professor using the "Structured Scholar" technique for deep textual analysis within TreeListy, a hierarchical project decomposition tool.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TREELISTY CONTEXT (Important for output structure)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TREE STRUCTURE: Root â†’ Phases (children) â†’ Items (items) â†’ Subtasks (subItems)
- Each node has: id, name, type, icon, description, and pattern-specific fields
- Philosophy pattern fields: speaker, premises, objections, keyTerms, textualReference, argumentType
- SubItems appear as collapsible nested content under their parent item
- Multiple nodes can be connected via Hyperedges to show cross-cutting relationships

PURPOSE: Your enriched output will be integrated back into the tree, adding depth and scholarly rigor to the user's philosophical analysis. The subItems you generate become visible nested content.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Your expertise includes: identifying hidden premises, reconstructing arguments, citing secondary sources, anticipating objections, and ANALYZING RELATIONSHIPS between philosophical claims.

You will receive JSON data for philosophical nodes to analyze. Your tasks:
1. For EACH node: Fill in missing fields and generate 2-4 subItems
2. ${multipleNodes ? 'CRITICAL: Analyze the RELATIONSHIP between these nodes - what is their dialectical connection?' : ''}

SubItem types to generate:
- "implicit-premise" (ðŸ”®): Hidden assumptions the argument relies on
- "objection" (âš”ï¸): Named philosophical objections with specific critics (e.g., "Carnap", "Ryle")
- "refutation" (ðŸ”„): Responses to objections
- "implication" (ðŸ’¡): Philosophical consequences or downstream effects
- "distinction" (âš–ï¸): Important conceptual distinctions

CRITICAL: Return ONLY valid JSON. No markdown, no explanations.`,

                    user: `Analyze these philosophical nodes and enrich them with deeper analysis.

PROJECT CONTEXT:
- Name: ${treeContext.projectName}
- Pattern: ${treeContext.pattern}
${treeContext.metadata?.tradition ? `- Tradition: ${treeContext.metadata.tradition}` : ''}
${treeContext.metadata?.method ? `- Method: ${treeContext.metadata.method}` : ''}
${treeContext.metadata?.secondarySources ? `- Secondary Sources Available: ${treeContext.metadata.secondarySources.slice(0, 3).join(', ')}` : ''}

NODES TO ANALYZE:
${nodesJson}

Return a JSON object with this structure:
{
  "enrichedNodes": [
    {
      "id": "original-node-id",
      "speaker": "Philosopher name",
      "keyTerms": ["term1", "term2"],
      "textualReference": "Specific citation",
      "argumentType": "deductive|inductive|transcendental|dialectical",
      "subItems": [
        {
          "id": "sub-unique-id",
          "name": "Objection/Implication name",
          "type": "subtask",
          "itemType": "objection|implicit-premise|implication|distinction",
          "speaker": "Critic name if applicable",
          "description": "Detailed description with citations...",
          "icon": "âš”ï¸|ðŸ”®|ðŸ’¡|âš–ï¸"
        }
      ]
    }
  ]${multipleNodes ? `,
  "relationshipAnalysis": {
    "relationshipType": "Short label (3-5 words) e.g., 'Thesis-Antithesis Dialectic', 'Premises Supporting Conclusion', 'Conceptual Dependency Chain'",
    "dialecticalRelation": "One sentence describing how these claims relate dialectically",
    "argumentativeFlow": "How arguments flow between these nodes (e.g., 'Node A provides grounds for Node B')",
    "conceptualBridge": "The key concept or term that connects these nodes",
    "tension": "Any philosophical tension or contradiction between the nodes",
    "synthesis": "If applicable, what synthesis emerges from considering these nodes together"
  }` : ''}
}

${multipleNodes ? `IMPORTANT: The relationshipAnalysis must reflect YOUR scholarly analysis of how these specific philosophical claims relate to each other based on their CONTENT, not just their types. Consider:
- Are they premises building toward a conclusion?
- Is one an objection to another?
- Do they represent different aspects of the same problem?
- Is there a dialectical progression (thesis â†’ antithesis â†’ synthesis)?
- Do they share conceptual dependencies?` : ''}

Return ONLY the JSON object, no other text.`
                };
            } else {
                // Generic pattern - McKinsey-style structured analysis
                return {
                    system: `You are a senior management consultant with 15 years at McKinsey & Company specializing in project risk assessment and work breakdown structures within TreeListy, a hierarchical project decomposition tool.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TREELISTY CONTEXT (Important for output structure)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TREE STRUCTURE: Root â†’ Phases (children) â†’ Items (items) â†’ Subtasks (subItems)
- Each node has: id, name, type, icon, description, and pattern-specific fields
- Generic pattern fields: cost, leadTime, dependencies
- SubItems appear as collapsible nested content under their parent item
- TreeListy supports 19 patterns including: Sales Pipeline, Product Roadmap, Course, Book, Film Production, Gmail Workflow, Free Speech, and more

PURPOSE: Your enriched output will be integrated back into the tree, adding depth and rigor to the user's project analysis. The subItems you generate become visible nested content that can be further expanded.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Your expertise includes: RAID analysis (Risks, Assumptions, Issues, Dependencies), RACI matrix construction, Critical Path Method, stakeholder impact assessment, and ANALYZING INTERDEPENDENCIES between project components.

SubItem types to generate:
- "risk-factor" (âš ï¸): Specific risks with probability/impact assessment
- "dependency" (ðŸ”—): Hard dependencies with named stakeholders/systems
- "assumption" (ðŸ’­): Hidden assumptions that could invalidate the approach
- "subtask" (âœ…): Actionable work items with clear ownership
- "constraint" (ðŸš«): Resource, time, or regulatory limitations
- "success-metric" (ðŸ“Š): Measurable outcomes and KPIs

Return ONLY valid JSON. No markdown, no explanations.`,

                    user: `Analyze these project items using RAID methodology and enrich with structured analysis.

PROJECT: ${treeContext.projectName}
PATTERN: ${treeContext.pattern}

ITEMS TO ANALYZE:
${nodesJson}

Return a JSON array with the SAME item IDs, enriched with:
1. Any missing fields you can infer
2. subItems: Array of 2-4 structured analysis items using the types above

Each subItem needs: id (generate unique), name, type (one of: risk-factor, dependency, assumption, subtask, constraint, success-metric), itemType, description, icon (use emoji matching type)

Include severity/priority where applicable: "high", "medium", "low"

Return ONLY the JSON array.`
                };
            }
        }

        // Call AI for deep dive analysis
        async function callDeepDiveAI(prompt, isPhilosophy) {
            // Use the existing unified AI infrastructure (callClaudeAPI handles all providers)
            const aiProvider = document.getElementById('ai-provider')?.value || 'gemini';
            const modelSelect = document.getElementById('ai-model-select');
            const selectedModel = modelSelect?.value || '';

            console.log(`Deep Dive using ${aiProvider} (${selectedModel})`);

            // callClaudeAPI is the unified wrapper that routes to Gemini/OpenAI/Claude
            // based on the selected provider in the UI
            const maxTokens = 4096; // Allow room for detailed subItems
            const useExtendedThinking = false; // Fast mode for now

            return await callClaudeAPI(prompt.user, prompt.system, maxTokens, useExtendedThinking);
        }

        // Parse AI response and extract enriched nodes + relationship analysis
        function parseDeepDiveResponse(response, originalNodes) {
            try {
                // Try to extract JSON from response
                let jsonStr = response;

                // Remove markdown code blocks if present
                if (jsonStr.includes('```json')) {
                    jsonStr = jsonStr.replace(/```json\s*/g, '').replace(/```\s*/g, '');
                } else if (jsonStr.includes('```')) {
                    jsonStr = jsonStr.replace(/```\s*/g, '');
                }

                // Trim whitespace
                jsonStr = jsonStr.trim();

                // Parse JSON
                const parsedData = JSON.parse(jsonStr);

                // Handle new structure with enrichedNodes + relationshipAnalysis
                let enrichedData;
                let relationshipAnalysis = null;

                if (parsedData.enrichedNodes) {
                    // New format: { enrichedNodes: [...], relationshipAnalysis: {...} }
                    enrichedData = parsedData.enrichedNodes;
                    relationshipAnalysis = parsedData.relationshipAnalysis || null;
                    console.log('ðŸ”— AI Relationship Analysis:', relationshipAnalysis);
                } else if (Array.isArray(parsedData)) {
                    // Legacy format: just an array
                    enrichedData = parsedData;
                } else {
                    // Single object, wrap it
                    console.warn('Deep Dive response is not expected format, wrapping...');
                    enrichedData = [parsedData];
                }

                // Map enriched data back to original node IDs
                const mappedNodes = enrichedData.map(enriched => {
                    // Try to match by ID or name
                    const matchingOriginal = originalNodes.find(
                        orig => orig.id === enriched.id || orig.name === enriched.name
                    );

                    if (matchingOriginal) {
                        return {
                            id: matchingOriginal.id,
                            speaker: enriched.speaker,
                            keyTerms: enriched.keyTerms,
                            textualReference: enriched.textualReference,
                            argumentType: enriched.argumentType,
                            subItems: enriched.subItems || []
                        };
                    }
                    return enriched;
                });

                // Return both enriched nodes and relationship analysis
                return {
                    nodes: mappedNodes,
                    relationshipAnalysis: relationshipAnalysis
                };

            } catch (parseError) {
                console.error('Failed to parse Deep Dive response:', parseError);
                console.log('Raw response:', response);
                throw new Error('AI response was not valid JSON. Please try again.');
            }
        }

        // Edit modal save/cancel handlers
        document.getElementById('edit-save').addEventListener('click', () => {
            if (activeNode) {
                // Save state for undo
                saveState(`Edit ${activeNode.type}: ${activeNode.name}`);

                // Save universal fields
                activeNode.name = document.getElementById('edit-name').value;
                activeNode.description = document.getElementById('edit-description').value;
                activeNode.icon = document.getElementById('edit-icon').value;
                activeNode.itemType = document.getElementById('edit-type').value;
                activeNode.notes = document.getElementById('edit-notes').value;

                // Save collaboration fields
                const collabComments = document.getElementById('edit-collab-comments');
                const contributor = document.getElementById('edit-contributor');
                if (collabComments) activeNode.collabComments = collabComments.value;
                if (contributor && contributor.value) {
                    activeNode.contributor = contributor.value;
                    activeNode.contributorTimestamp = new Date().toISOString();
                }

                // Save pattern-specific fields dynamically
                const pattern = PATTERNS[currentPattern];
                const fields = pattern.fields || {};

                Object.keys(fields).forEach(fieldKey => {
                    // Skip configuration keys
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    const fieldElement = document.getElementById(`edit-${fieldKey}`);
                    if (fieldElement) {
                        const fieldConfig = fields[fieldKey];
                        if (fieldConfig.type === 'number') {
                            activeNode[fieldKey] = parseInt(fieldElement.value) || 0;
                        } else {
                            activeNode[fieldKey] = fieldElement.value;
                        }
                    }
                });

                // Collect selected dependencies from checkboxes (conditional)
                if (fields.includeDependencies) {
                    const depCheckboxes = document.querySelectorAll('.dep-checkbox');
                    const selectedDeps = [];
                    depCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedDeps.push(checkbox.value);
                        }
                    });
                    activeNode.dependencies = selectedDeps;
                }

                // Save PM fields for subtasks
                if (activeNode.type === 'subtask') {
                    const pmStatus = document.getElementById('edit-pm-status');
                    const pmRAGStatus = document.getElementById('edit-pm-rag-status');
                    const pmOwnerEmail = document.getElementById('edit-pm-owner-email');
                    const pmStartDate = document.getElementById('edit-pm-start-date');
                    const pmDueDate = document.getElementById('edit-pm-due-date');
                    const pmProgress = document.getElementById('edit-pm-progress');
                    const pmPriority = document.getElementById('edit-pm-priority');
                    const pmEstimatedHours = document.getElementById('edit-pm-estimated-hours');
                    const pmActualHours = document.getElementById('edit-pm-actual-hours');
                    const pmRemainingHours = document.getElementById('edit-pm-remaining-hours');
                    const pmNotes = document.getElementById('edit-pm-notes');
                    const pmBlockingIssue = document.getElementById('edit-pm-blocking-issue');
                    const pmNextSteps = document.getElementById('edit-pm-next-steps');

                    if (pmStatus) activeNode.pmStatus = pmStatus.value;
                    if (pmRAGStatus) activeNode.pmRAGStatus = pmRAGStatus.value;
                    if (pmOwnerEmail) {
                        activeNode.pmOwnerEmail = pmOwnerEmail.value;
                        // Backward compatibility: also save as pmAssignee
                        activeNode.pmAssignee = pmOwnerEmail.value;
                    }
                    if (pmStartDate) activeNode.pmStartDate = pmStartDate.value;
                    if (pmDueDate) activeNode.pmDueDate = pmDueDate.value;
                    if (pmProgress) activeNode.pmProgress = parseInt(pmProgress.value) || 0;
                    if (pmPriority) activeNode.pmPriority = pmPriority.value;
                    if (pmEstimatedHours) activeNode.pmEstimatedHours = parseFloat(pmEstimatedHours.value) || 0;
                    if (pmActualHours) activeNode.pmActualHours = parseFloat(pmActualHours.value) || 0;
                    if (pmRemainingHours) {
                        // If remaining is explicitly set, use it; otherwise auto-calculate
                        const remValue = parseFloat(pmRemainingHours.value);
                        if (remValue > 0) {
                            activeNode.pmRemainingHours = remValue;
                        } else {
                            // Auto-calculate: Estimated - Actual
                            const est = parseFloat(pmEstimatedHours?.value) || 0;
                            const act = parseFloat(pmActualHours?.value) || 0;
                            activeNode.pmRemainingHours = Math.max(0, est - act);
                        }
                    }
                    if (pmNotes) activeNode.pmNotes = pmNotes.value;
                    if (pmBlockingIssue) activeNode.pmBlockingIssue = pmBlockingIssue.value;
                    if (pmNextSteps) activeNode.pmNextSteps = pmNextSteps.value;
                    // pmUpdates are managed separately via window.addUpdate and window.deleteUpdate
                }

                document.getElementById('edit-modal').style.display = 'none';
                render();
            }
        });

        document.getElementById('edit-cancel').addEventListener('click', () => {
            document.getElementById('edit-modal').style.display = 'none';
        });

        // JSON upload handler (BUILD 372: Also handles .treelisty bundles)
        document.getElementById('json-upload-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                // BUILD 372: Handle .treelisty bundle files
                if (file.name.endsWith('.treelisty')) {
                    await window.importTreelistyBundle(file);
                    e.target.value = '';
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);

                        // Migrate tree to current schema (Cognitive Citadel Foundation)
                        migrateTree(data);

                        // Validate basic structure
                        if (data.id && data.children) {
                            // BUILD 284: Check for newer LocalStorage version
                            const treeId = data.id || 'default';
                            const localStorageKey = `treelisty:tree:${treeId}`;
                            const localMetaKey = `treelisty:meta:${treeId}`;
                            const localTree = localStorage.getItem(localStorageKey);
                            const localMeta = localStorage.getItem(localMetaKey);

                            if (localTree && localMeta) {
                                try {
                                    const localMetaData = JSON.parse(localMeta);
                                    const fileLastModified = data.metadata?.lastModified || data.lastModified || 0;
                                    const localLastModified = localMetaData.lastModified || 0;

                                    // If local version is newer, show conflict dialog
                                    if (localLastModified > fileLastModified) {
                                        const localDate = new Date(localLastModified).toLocaleString();
                                        const fileDate = fileLastModified ? new Date(fileLastModified).toLocaleString() : 'Unknown';

                                        showVersionConflictDialog({
                                            treeId,
                                            treeName: data.name || 'Untitled',
                                            fileData: data,
                                            fileDate,
                                            localData: JSON.parse(localTree),
                                            localDate,
                                            localItemCount: localMetaData.itemCount || 0
                                        });
                                        e.target.value = '';
                                        return; // Don't load file yet - wait for user choice
                                    }
                                } catch (parseErr) {
                                    console.warn('Could not parse local metadata:', parseErr);
                                }
                            }

                            // No conflict - proceed with loading
                            loadTreeData(data);
                            showToast(`Loaded: ${data.name || 'Tree'}`, 'success');
                        } else {
                            alert('Invalid JSON structure. Must have "id" and "children" properties.');
                        }
                    } catch (err) {
                        alert('Error parsing JSON: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
            // Reset input
            e.target.value = '';
        });

        // Controls - Expand/Collapse All
        const expandBtn = document.getElementById('expand-btn');
        const collapseBtn = document.getElementById('collapse-btn');

        if (expandBtn) {
            console.log('âœ… Expand button found, attaching event listener');
            expandBtn.addEventListener('click', () => {
                console.log('â¬‡ï¸ Expand button clicked!');
                console.log('Current tree state:', capexTree);

                function expandAll(node) {
                    // Set expanded on this node
                    node.expanded = true;

                    // Recursively expand all children (phases/folders in filesystem)
                    if (node.children) {
                        node.children.forEach(expandAll);
                    }

                    // Recursively expand all items (standard patterns)
                    if (node.items) {
                        node.items.forEach(expandAll);
                    }

                    // Recursively expand all subItems (nested tasks)
                    if (node.subItems) {
                        node.subItems.forEach(expandAll);
                    }
                }
                expandAll(capexTree);

                console.log('Tree after expand:', capexTree);
                render();
                console.log('Render complete');
            });
        } else {
            console.error('âŒ Expand button not found!');
        }

        if (collapseBtn) {
            console.log('âœ… Collapse button found, attaching event listener');
            collapseBtn.addEventListener('click', () => {
                console.log('â¬†ï¸ Collapse button clicked!');
                console.log('Current tree state:', capexTree);

                function collapseAll(node) {
                    // Set collapsed on this node
                    node.expanded = false;

                    // Recursively collapse all children (phases/folders in filesystem)
                    if (node.children) {
                        node.children.forEach(collapseAll);
                    }

                    // Recursively collapse all items (standard patterns)
                    if (node.items) {
                        node.items.forEach(collapseAll);
                    }

                    // Recursively collapse all subItems (nested tasks)
                    if (node.subItems) {
                        node.subItems.forEach(collapseAll);
                    }
                }

                // Start from the root's children
                if (capexTree.children) {
                    capexTree.children.forEach(collapseAll);
                }
                if (capexTree.items) {
                    capexTree.items.forEach(collapseAll);
                }

                console.log('Tree after collapse:', capexTree);
                render();
                console.log('Render complete');
            });
        } else {
            console.error('âŒ Collapse button not found!');
        }

        // Search functionality
        document.getElementById('search-btn').addEventListener('click', () => {
            const modal = document.getElementById('search-modal');
            modal.style.display = 'flex';
            document.getElementById('search-input').focus();
        });

        document.getElementById('close-search-modal').addEventListener('click', () => {
            document.getElementById('search-modal').style.display = 'none';
        });

        // Recursive search function
        function searchNodes(query, node, path = [], results = []) {
            const queryLower = query.toLowerCase();

            // Helper to check if a value contains the query
            function matchesQuery(value) {
                if (value === null || value === undefined) return false;
                return String(value).toLowerCase().includes(queryLower);
            }

            // Search all fields in this node
            const matches = [];
            Object.keys(node).forEach(key => {
                // Skip non-searchable fields
                if (['children', 'items', 'subItems', 'dependencies', 'expanded', 'type', 'canvasX', 'canvasY'].includes(key)) {
                    return;
                }

                if (matchesQuery(node[key])) {
                    matches.push({ field: key, value: node[key] });
                }
            });

            // If this node has matches, add it to results
            if (matches.length > 0) {
                results.push({
                    node: node,
                    path: path,
                    matches: matches
                });
            }

            // Recursively search children (support both standard and filesystem patterns)
            const childList = node.children || node.items || node.subItems || [];
            childList.forEach((child, idx) => {
                searchNodes(query, child, [...path, { name: node.name || node.id, index: idx }], results);
            });

            return results;
        }

        // Perform search and display results
        function performSearch() {
            const query = document.getElementById('search-input').value.trim();
            const resultsContainer = document.getElementById('search-results');
            const emptyState = document.getElementById('search-results-empty');

            if (!query) {
                resultsContainer.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }

            const results = [];

            // Search through all phases
            if (capexTree.children) {
                capexTree.children.forEach((phase, phaseIdx) => {
                    // Search the phase itself
                    searchNodes(query, phase, [{ name: capexTree.name, index: phaseIdx }], results);
                });
            }

            // Display results
            if (results.length === 0) {
                resultsContainer.style.display = 'none';
                emptyState.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 12px;">ðŸ¤·</div>
                    <div style="font-size: 14px;">No results found for "${query}"</div>
                `;
                emptyState.style.display = 'block';
            } else {
                emptyState.style.display = 'none';
                resultsContainer.style.display = 'block';

                resultsContainer.innerHTML = `
                    <div style="margin-bottom: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px;">
                        <strong style="color: var(--treeplex-primary);">${results.length}</strong> result${results.length !== 1 ? 's' : ''} found
                    </div>
                    ${results.map((result, idx) => {
                        const pathStr = result.path.map(p => p.name).join(' â†’ ') + ' â†’ ' + result.node.name;
                        const matchesHtml = result.matches.map(m => {
                            const value = String(m.value).substring(0, 200);
                            return `<div style="margin: 4px 0;"><strong>${m.field}:</strong> ${highlightMatch(value, query)}</div>`;
                        }).join('');

                        return `
                            <div class="search-result-item" data-node-id="${result.node.id}" style="padding: 12px 16px; margin-bottom: 12px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px; display: flex; align-items: center; gap: 8px;">
                                    ${result.node.icon || 'ðŸ“„'} ${result.node.name}
                                </div>
                                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                                    ${pathStr}
                                </div>
                                <div style="font-size: 13px; color: var(--text-primary); padding: 8px; background: var(--bg-secondary); border-radius: 4px;">
                                    ${matchesHtml}
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;

                // Add click handlers to results
                resultsContainer.querySelectorAll('.search-result-item').forEach((el, idx) => {
                    el.addEventListener('click', () => {
                        const nodeId = el.dataset.nodeId;
                        // Close search modal
                        document.getElementById('search-modal').style.display = 'none';
                        // Highlight and scroll to the node
                        highlightNode(nodeId);
                    });

                    // Hover effect
                    el.addEventListener('mouseenter', () => {
                        el.style.borderColor = 'var(--treeplex-primary)';
                        el.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                    el.addEventListener('mouseleave', () => {
                        el.style.borderColor = 'var(--border)';
                        el.style.background = 'var(--card-bg)';
                    });
                });
            }
        }

        // Highlight matched text
        function highlightMatch(text, query) {
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<mark style="background: rgba(255, 187, 0, 0.3); padding: 2px 4px; border-radius: 3px; font-weight: 600;">$1</mark>');
        }

        // Highlight node in tree view and show info panel
        function highlightNode(nodeId) {
            let foundNode = null;

            // Find and expand ancestors to make node visible
            function findAndExpandNode(node, targetId, ancestors = []) {
                if (node.id === targetId) {
                    foundNode = node;
                    // Expand all ancestors
                    ancestors.forEach(ancestor => {
                        ancestor.expanded = true;
                    });
                    return true;
                }

                // Recursively search children
                const childList = node.children || node.items || node.subItems || [];
                for (const child of childList) {
                    if (findAndExpandNode(child, targetId, [...ancestors, node])) {
                        return true;
                    }
                }
                return false;
            }

            // Search through all phases
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    if (findAndExpandNode(phase, nodeId, [capexTree])) {
                        break;
                    }
                }
            }

            // Also check root
            if (!foundNode && capexTree.id === nodeId) {
                foundNode = capexTree;
            }

            if (foundNode) {
                // Re-render tree with expanded ancestors
                render();

                // Show the info panel for this node
                if (typeof showInfo === 'function') {
                    showInfo(foundNode);
                }

                // Select the node
                selectedNodes = [foundNode];

                // Scroll to node after render
                setTimeout(() => {
                    const nodeEl = document.querySelector(`[data-item-id="${nodeId}"]`);
                    if (nodeEl) {
                        nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Flash highlight
                        nodeEl.style.background = 'rgba(99, 102, 241, 0.3)';
                        nodeEl.style.boxShadow = '0 0 0 2px var(--treeplex-primary)';
                        nodeEl.style.transition = 'all 0.3s';
                        setTimeout(() => {
                            nodeEl.style.background = '';
                            nodeEl.style.boxShadow = '';
                        }, 2000);
                    }
                }, 150);
            }
        }

        // Search on input
        const searchInput = document.getElementById('search-input');
        searchInput.addEventListener('input', debounce(performSearch, 300));
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });

        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Save and Load JSON buttons in console
        // New Project button - Start fresh
        document.getElementById('new-project-btn').addEventListener('click', () => {
            // Check if LifeTree pattern - needs special initialization
            if (currentPattern === 'lifetree') {
                showLifeTreeInitModal();
                return;
            }

            const confirmNew = confirm(
                'ðŸ†• Start New Project?\n\n' +
                'This will clear your current project.\n\n' +
                'Make sure to save first if you want to keep your work!'
            );

            if (confirmNew) {
                createNewProject();
            }
        });

        /**
         * BUILD 365: LifeTree initialization modal
         * Collects subject name, birth year, and living status
         */
        function showLifeTreeInitModal() {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'ðŸŒ³ Start a New LifeTree';

            const currentYear = new Date().getFullYear();

            modalBody.innerHTML = `
                <div style="padding: 24px; max-width: 480px;">
                    <p style="color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6;">
                        A LifeTree is a biographical timeline. Let's start with the basics.
                    </p>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                            Whose life is this? *
                        </label>
                        <input type="text" id="lifetree-subject-name" placeholder="e.g., Mom, Grandpa Joe, Marie Curie..."
                            style="width: 100%; padding: 12px; font-size: 16px; background: #1e293b; border: 1px solid var(--border-color); border-radius: 8px; color: #f8fafc;">
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                                Birth Year *
                            </label>
                            <input type="number" id="lifetree-birth-year" placeholder="${currentYear - 70}"
                                min="-3000" max="${currentYear}"
                                style="width: 100%; padding: 12px; font-size: 16px; background: #1e293b; border: 1px solid var(--border-color); border-radius: 8px; color: #f8fafc;">
                            <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                                Use negative for BC (e.g., -428 for Plato)
                            </div>
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                                Still Living?
                            </label>
                            <select id="lifetree-living-status"
                                style="width: 100%; padding: 12px; font-size: 16px; background: #1e293b; border: 1px solid var(--border-color); border-radius: 8px; color: #f8fafc;">
                                <option value="living">Yes, still living</option>
                                <option value="deceased">No, passed away</option>
                            </select>
                        </div>
                    </div>

                    <div id="lifetree-death-year-container" style="display: none; margin-bottom: 20px;">
                        <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                            Year of Passing
                        </label>
                        <input type="number" id="lifetree-death-year" placeholder="${currentYear}"
                            min="-3000" max="${currentYear}"
                            style="width: 100%; padding: 12px; font-size: 16px; background: #1e293b; border: 1px solid var(--border-color); border-radius: 8px; color: #f8fafc;">
                    </div>

                    <div style="padding: 16px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px; margin-bottom: 20px;">
                        <div style="font-size: 12px; color: #a78bfa; margin-bottom: 8px;">ðŸ’¡ What happens next</div>
                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                            TreeBeard will help you build the timeline by asking about key life events,
                            family members, and memories. You can also add events and photos anytime.
                        </div>
                    </div>
                </div>
            `;

            // Show/hide death year based on selection
            setTimeout(() => {
                const livingSelect = document.getElementById('lifetree-living-status');
                const deathContainer = document.getElementById('lifetree-death-year-container');
                livingSelect?.addEventListener('change', () => {
                    deathContainer.style.display = livingSelect.value === 'deceased' ? 'block' : 'none';
                });
            }, 100);

            document.querySelector('#modal .modal-footer').innerHTML = `
                <button class="btn" onclick="document.getElementById('modal').style.display='none'">Cancel</button>
                <button class="btn btn-primary" onclick="createLifeTree()">ðŸŒ³ Create LifeTree</button>
            `;

            modal.style.display = 'flex';
        }

        /**
         * BUILD 365: Create LifeTree with decades generated from birth year
         */
        function createLifeTree() {
            const subjectName = document.getElementById('lifetree-subject-name')?.value?.trim();
            const birthYear = parseInt(document.getElementById('lifetree-birth-year')?.value);
            const livingStatus = document.getElementById('lifetree-living-status')?.value;
            const deathYear = livingStatus === 'deceased'
                ? parseInt(document.getElementById('lifetree-death-year')?.value)
                : null;

            // Validation
            if (!subjectName) {
                showToast('Please enter a name', 'error');
                return;
            }
            if (isNaN(birthYear)) {
                showToast('Please enter a birth year', 'error');
                return;
            }
            if (livingStatus === 'deceased' && isNaN(deathYear)) {
                showToast('Please enter year of passing', 'error');
                return;
            }

            saveState('New LifeTree');

            // Generate decades from birth year to now (or death year)
            const currentYear = new Date().getFullYear();
            const endYear = deathYear || currentYear;
            const decades = generateDecades(birthYear, endYear);

            const pattern = PATTERNS.lifetree;
            const levels = pattern.levels;

            // Create birth event as first item
            const birthEvent = {
                id: 'event-birth-' + Date.now(),
                name: `${subjectName} was born`,
                description: '',
                icon: 'ðŸ‘¶',
                itemType: 'birth',
                type: 'item',
                eventDate: birthYear.toString(),
                age: 0,
                location: '',
                people: '',
                emotion: 'Milestone',
                source: '',
                confidence: 'Exact',
                dependencies: [],
                subItems: [],
                expanded: true
            };

            // Build decade phases
            const decadePhases = decades.map((decade, idx) => ({
                id: `phase-${idx}`,
                name: decade.label,
                subtitle: decade.subtitle,
                type: 'phase',
                phase: idx,
                icon: decade.icon,
                expanded: idx === 0, // Expand first decade
                items: idx === 0 ? [birthEvent] : [],
                children: []
            }));

            // Create the LifeTree
            capexTree = {
                id: 'root',
                name: `${subjectName}'s Life`,
                type: 'root',
                icon: 'ðŸŒ³',
                expanded: true,
                children: decadePhases,
                pattern: {
                    key: 'lifetree',
                    labels: levels
                },
                // LifeTree-specific metadata
                lifetree: {
                    subjectName: subjectName,
                    birthYear: birthYear,
                    deathYear: deathYear,
                    isLiving: livingStatus === 'living',
                    people: [] // Will store relationship data
                }
            };

            document.getElementById('modal').style.display = 'none';
            render();
            renderCanvas();
            showToast(`ðŸŒ³ ${subjectName}'s LifeTree created!`, 'success');
            console.log(`ðŸŒ³ LifeTree created for ${subjectName}, born ${birthYear}`);

            // Open TreeBeard to start guided interview
            setTimeout(() => {
                const treebeard = document.getElementById('treebeard-panel');
                if (treebeard && !treebeard.classList.contains('open')) {
                    treebeard.classList.add('open');
                }
                // Add welcome message
                if (typeof addMessage === 'function') {
                    addMessage(
                        `ðŸŒ³ Welcome to ${subjectName}'s LifeTree!\n\n` +
                        `I've created decades from ${formatDecadeYear(birthYear)} to ${formatDecadeYear(endYear)}.\n\n` +
                        `Let's start filling in the story. You can:\n` +
                        `â€¢ Tell me a memory or story\n` +
                        `â€¢ Drop in a photo\n` +
                        `â€¢ Answer my questions\n\n` +
                        `**First question:** Who were ${subjectName}'s parents?`,
                        'assistant'
                    );
                }
            }, 500);
        }

        /**
         * BUILD 365: Generate decade phases from birth to end year
         */
        function generateDecades(birthYear, endYear) {
            const decades = [];
            const isBC = birthYear < 0;

            // Round birth year down to decade start
            const startDecade = Math.floor(birthYear / 10) * 10;
            const endDecade = Math.floor(endYear / 10) * 10;

            const decadeIcons = ['ðŸ‘¶', 'ðŸ’’', 'ðŸ§’', 'ðŸŽ“', 'ðŸ’¼', 'ðŸ ', 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§', 'ðŸŒŸ', 'ðŸ“š', 'ðŸŽ„', 'ðŸŒ…', 'âœ¨'];

            if (isBC) {
                // BC years go backwards (higher numbers are earlier)
                for (let d = startDecade; d >= endDecade; d -= 10) {
                    const idx = decades.length;
                    decades.push({
                        label: `${Math.abs(d)}s BC`,
                        subtitle: getDecadeSubtitle(birthYear, d, idx),
                        icon: decadeIcons[idx % decadeIcons.length]
                    });
                }
            } else {
                for (let d = startDecade; d <= endDecade; d += 10) {
                    const idx = decades.length;
                    decades.push({
                        label: `${d}s`,
                        subtitle: getDecadeSubtitle(birthYear, d, idx),
                        icon: decadeIcons[idx % decadeIcons.length]
                    });
                }
            }

            return decades;
        }

        /**
         * Get appropriate subtitle for a decade based on age
         */
        function getDecadeSubtitle(birthYear, decadeStart, idx) {
            const ageAtDecadeStart = Math.abs(decadeStart - birthYear);
            if (ageAtDecadeStart < 10) return 'Childhood';
            if (ageAtDecadeStart < 20) return 'Teen Years';
            if (ageAtDecadeStart < 30) return 'Twenties';
            if (ageAtDecadeStart < 40) return 'Thirties';
            if (ageAtDecadeStart < 50) return 'Forties';
            if (ageAtDecadeStart < 60) return 'Fifties';
            if (ageAtDecadeStart < 70) return 'Sixties';
            if (ageAtDecadeStart < 80) return 'Seventies';
            if (ageAtDecadeStart < 90) return 'Eighties';
            return 'Golden Years';
        }

        /**
         * Format year for display (handles BC)
         */
        function formatDecadeYear(year) {
            if (year < 0) return `${Math.abs(year)} BC`;
            return year.toString();
        }

        /**
         * Standard new project creation (non-LifeTree patterns)
         */
        function createNewProject() {
            saveState('New Project');

            // Use current pattern from dropdown (pattern-aware)
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;
            const fields = pattern.fields || {};

            // Build starter item with only pattern-specific fields
            const starterItem = {
                id: 'item-' + Date.now(),
                name: `New ${levels.item}`,
                description: 'Enter description',
                icon: 'ðŸ“¦',
                itemType: '',
                type: 'item',
                dependencies: [],
                subItems: [],
                expanded: true
            };

            // Add pattern-specific fields
            Object.keys(fields).forEach(fieldKey => {
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return; // Skip meta fields
                }

                const fieldConfig = fields[fieldKey];

                // Set default values based on field type
                if (fieldConfig.type === 'number') {
                    starterItem[fieldKey] = 0;
                } else if (fieldConfig.type === 'date') {
                    starterItem[fieldKey] = '';
                } else if (fieldConfig.type === 'select') {
                    starterItem[fieldKey] = '';
                } else if (fieldConfig.type === 'textarea') {
                    starterItem[fieldKey] = '';
                } else {
                    starterItem[fieldKey] = '';
                }
            });

            // Reset to fresh tree with pattern-specific structure
            capexTree = {
                id: 'root',
                name: `My ${levels.root}`,
                type: 'root',
                icon: pattern.icon,
                expanded: true,
                children: [
                    {
                        id: 'phase-0',
                        name: `${levels.phase} 0`,
                        subtitle: pattern.phaseSubtitles ? pattern.phaseSubtitles[0] : '',
                        type: 'phase',
                        phase: 0,
                        icon: '1ï¸âƒ£',
                        expanded: true,
                        items: [starterItem],
                        children: []
                    }
                ],
                pattern: {
                    key: currentPattern,
                    labels: levels
                }
            };

            render();
            renderCanvas();  // Also update canvas view if visible
            showToast(`âœ… New ${pattern.name} project started!`);
            console.log(`ðŸ†• New ${pattern.name} project created`);
        }

        document.getElementById('save-json-btn').addEventListener('click', handleDownload);
        document.getElementById('load-json-btn').addEventListener('click', handleUpload);

        // Share button - Generate shareable URL
        document.getElementById('share-btn').addEventListener('click', () => {
            const shareableURL = generateShareableURL();

            // Show modal with URL
            const modal = document.getElementById('share-modal');
            const urlInput = document.getElementById('share-url-input');
            urlInput.value = shareableURL;

            // Update stats
            const nodeCount = countAllNodes(capexTree);
            document.getElementById('share-node-count').textContent = nodeCount;
            document.getElementById('share-url-length').textContent = shareableURL.length;

            // Show warning if URL is very long (>2000 chars might have issues in some apps)
            const warning = document.getElementById('share-size-warning');
            if (shareableURL.length > 2000) {
                warning.style.display = 'block';
            } else {
                warning.style.display = 'none';
            }

            modal.style.display = 'flex';

            // Select the URL text for easy copying
            setTimeout(() => urlInput.select(), 100);
        });

        // Share modal - Copy button
        document.getElementById('copy-share-url').addEventListener('click', () => {
            const urlInput = document.getElementById('share-url-input');
            urlInput.select();
            document.execCommand('copy');

            // Change button text temporarily
            const btn = document.getElementById('copy-share-url');
            const originalText = btn.textContent;
            btn.textContent = 'âœ… Copied!';
            btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';

            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
            }, 2000);
        });

        // Share modal - Open in new tab button
        document.getElementById('open-share-url').addEventListener('click', () => {
            const url = document.getElementById('share-url-input').value;
            window.open(url, '_blank');
        });

        // Share modal - Close button
        document.getElementById('share-close').addEventListener('click', () => {
            document.getElementById('share-modal').style.display = 'none';
        });

        // Generate shareable URL with compressed data
        function generateShareableURL() {
            // DEBUG: Check cost values before serialization
            if (capexTree.children && capexTree.children[0] && capexTree.children[0].items && capexTree.children[0].items[0]) {
                console.log('First item cost before stringify:', capexTree.children[0].items[0].cost);
            }

            const jsonData = JSON.stringify(capexTree);

            // DEBUG: Log first 500 chars of JSON
            console.log('JSON before compress (first 500 chars):', jsonData.substring(0, 500));

            const compressed = LZString.compressToEncodedURIComponent(jsonData);
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?p=${compressed}`;
        }

        // Count all nodes in tree (for stats)
        function countAllNodes(node) {
            let count = 1; // Count this node
            if (node.children) {
                node.children.forEach(child => {
                    if (child.items) {
                        count += child.items.length;
                        child.items.forEach(item => {
                            if (item.subtasks) {
                                count += item.subtasks.length;
                            }
                        });
                    } else {
                        count += countAllNodes(child);
                    }
                });
            }
            return count;
        }

        // =============================================================================
        // AI WIZARD SYSTEM
        // =============================================================================

        // Wizard state
        let wizardState = {
            active: false,
            conversation: [],
            questionsAsked: 0,
            fieldsCompleted: new Set(),
            totalFields: 0,
            awaitingResponse: false,
            workingTree: null,
            patternKey: null
        };

        // Check if tree has meaningful content
        function hasExistingContent() {
            // Check if any phase has items or children (filesystem pattern uses 'children')
            if (capexTree.children) {
                for (const phase of capexTree.children) {
                    // Support both 'items' (standard patterns) and 'children' (filesystem pattern)
                    const nodeList = phase.items || phase.children || [];
                    if (nodeList.length > 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Start wizard
        document.getElementById('wizard-btn').addEventListener('click', () => {
            // Check global AI mode
            const aiMode = getGlobalAIMode();
            if (aiMode === 'off') {
                alert('âŒ AI features are currently disabled.\n\nPlease enable AI mode in the header (ðŸ¤– AI Mode dropdown) to use the AI Wizard.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            // If tree has content, ask user if they want to enhance or start fresh
            if (hasExistingContent()) {
                showWizardModeChoice();
            } else {
                startWizard(false); // false = start fresh
            }
        });

        // Show modal to choose wizard mode
        function showWizardModeChoice() {
            const pattern = PATTERNS[currentPattern];
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸª„ AI Wizard Mode';

            // Count existing items
            const itemCount = capexTree.children?.reduce((sum, phase) =>
                sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 24px;">
                        Your tree already has <strong style="color: var(--treeplex-primary);">${itemCount} ${pattern.levels.item.toLowerCase()}(s)</strong>.
                        How would you like to proceed?
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="mode-enhance" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">âœ¨</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Enhance Existing
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Keep your current tree and use the wizard to add more detail, fill gaps, or expand sections.
                            </div>
                        </div>

                        <div id="mode-fresh" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">ðŸŒ±</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Start Fresh
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Clear the current tree and build a completely new structure from scratch.
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 16px; padding: 12px; background: rgba(163, 85, 247, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                        ðŸ’¡ <strong>Tip:</strong> Enhancement mode is great for iterative refinement. The wizard will see your existing structure and help you improve it.
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Add click handlers
            document.getElementById('mode-enhance').onclick = () => {
                modal.style.display = 'none';
                // BUILD 413: Route to Tree Agent (fixes Build 397 command frame routing)
                startWizard(true); // true = enhance mode
            };

            document.getElementById('mode-fresh').onclick = () => {
                modal.style.display = 'none';
                startWizard(false); // false = start fresh
            };
        }

        async function startWizard(enhanceMode = false) {
            // Reset wizard state
            wizardState = {
                active: true,
                conversation: [],
                questionsAsked: 0,
                fieldsCompleted: new Set(),
                totalFields: 0,
                awaitingResponse: false,
                workingTree: JSON.parse(JSON.stringify(capexTree)), // Deep copy
                patternKey: currentPattern,
                enhanceMode: enhanceMode,
                retryCount: 0 // Track recovery attempts
            };

            // Get pattern info
            const pattern = PATTERNS[currentPattern];
            const patternFields = pattern.fields || {};
            wizardState.totalFields = Object.keys(patternFields).length;

            // Get pattern info
            const modeLabel = enhanceMode ? 'âœ¨ Enhancing' : 'ðŸª„ Building';

            // BUILD 408: Clear old wizard history (still used internally for compatibility)
            const wizardChatHistory = document.getElementById('wizard-chat-history');
            if (wizardChatHistory) wizardChatHistory.innerHTML = '';
            updateWizardPreview();

            // BUILD 408: Use Tree Agent as primary UI (replaces old wizard modal)
            const agentTitle = `${modeLabel} ${pattern.name}`;
            if (typeof openTreeAgent === 'function') {
                openTreeAgent(agentTitle);
            } else {
                // Fallback to old modal if Tree Agent not available
                document.getElementById('wizard-title').textContent = `${modeLabel} Your ${pattern.name}`;
                document.getElementById('wizard-fields-total').textContent = wizardState.totalFields;
                document.getElementById('wizard-modal').style.display = 'flex';
            }

            // Hide chat bubble to prevent overlap with modal buttons
            const chatBubble = document.getElementById('chat-assistant-bubble');
            if (chatBubble) chatBubble.style.display = 'none';

            // Start conversation
            await wizardAsk();
        }

        // Add message to chat with optional clickable choices
        function addWizardMessage(role, content, choices = null) {
            const chatHistory = document.getElementById('wizard-chat-history');
            const messageDiv = document.createElement('div');

            if (role === 'ai') {
                // Neutral Slate Grey for AI (modern ChatGPT/Claude aesthetic)
                messageDiv.style.cssText = `
                    background: #2A2F3C;
                    color: #E2E2E2;
                    padding: 16px 20px;
                    border-radius: 12px;
                    border-top-left-radius: 2px;
                    max-width: 85%;
                    align-self: flex-start;
                    line-height: 1.6;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    border: 1px solid #3A3F4D;
                    font-size: 14px;
                `;

                // Parse content for [CHOICE:label] markers and convert to buttons
                let displayContent = content;
                const choiceMatches = content.match(/\[CHOICE:([^\]]+)\]/g);

                if (choiceMatches) {
                    // Remove choice markers from display text
                    displayContent = content.replace(/\[CHOICE:[^\]]+\]/g, '').trim();
                    messageDiv.innerHTML = displayContent.replace(/\n/g, '<br>');

                    // Create clickable choice buttons
                    const choicesDiv = document.createElement('div');
                    choicesDiv.style.cssText = `
                        display: flex;
                        flex-wrap: wrap;
                        gap: 8px;
                        margin-top: 12px;
                        padding-top: 12px;
                        border-top: 1px solid #3A3F4D;
                    `;

                    choiceMatches.forEach(match => {
                        const label = match.replace('[CHOICE:', '').replace(']', '');
                        const btn = document.createElement('button');
                        btn.textContent = label;
                        btn.style.cssText = `
                            padding: 8px 16px;
                            background: linear-gradient(135deg, #6366f1, #8b5cf6);
                            color: white;
                            border: none;
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 13px;
                            font-weight: 500;
                            transition: all 0.2s ease;
                            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
                        `;
                        btn.onmouseover = () => btn.style.transform = 'scale(1.05)';
                        btn.onmouseout = () => btn.style.transform = 'scale(1)';
                        btn.onclick = () => {
                            // Disable all choice buttons after selection
                            choicesDiv.querySelectorAll('button').forEach(b => {
                                b.disabled = true;
                                b.style.opacity = '0.5';
                                b.style.cursor = 'default';
                            });
                            btn.style.opacity = '1';
                            btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                            // Send the choice as user input
                            handleWizardChoice(label);
                        };
                        choicesDiv.appendChild(btn);
                    });

                    messageDiv.appendChild(choicesDiv);
                } else {
                    messageDiv.innerHTML = displayContent.replace(/\n/g, '<br>');
                }
            } else {
                // Vibrant Primary for User
                messageDiv.style.cssText = `
                    background: linear-gradient(135deg, #6366f1, #4f46e5);
                    color: white;
                    padding: 12px 18px;
                    border-radius: 12px;
                    border-bottom-right-radius: 2px;
                    max-width: 80%;
                    align-self: flex-end;
                    line-height: 1.5;
                    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
                    font-size: 14px;
                `;
                messageDiv.textContent = content;
            }

            // BUILD 408: Tree Agent is now primary UI
            // Add to Tree Agent first (primary), then old wizard (secondary/fallback)
            if (typeof addAgentMessage === 'function' && treeAgentState?.open) {
                const agentRole = role === 'ai' ? 'assistant' : 'user';
                addAgentMessage(agentRole, content);
            }

            // Also add to old wizard chat history (for compatibility/fallback)
            if (chatHistory) {
                chatHistory.appendChild(messageDiv);
                chatHistory.scrollTop = chatHistory.scrollHeight;
            }
        }

        // Handle wizard choice button click
        function handleWizardChoice(choice) {
            // Add user's choice as a message
            addWizardMessage('user', choice);

            // Add to conversation history
            wizardState.conversation.push({ role: 'user', content: choice });

            // Trigger next AI response
            wizardAsk();
        }

        // Ask AI for next question
        async function wizardAsk() {
            if (wizardState.awaitingResponse) return;
            wizardState.awaitingResponse = true;

            // Disable input while waiting
            document.getElementById('wizard-user-input').disabled = true;
            document.getElementById('wizard-send').disabled = true;

            try {
                const systemPrompt = buildWizardSystemPrompt();
                const conversationContext = wizardState.conversation.map(msg =>
                    `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`
                ).join('\n\n');

                const userPrompt = conversationContext ||
                    (wizardState.enhanceMode ?
                        "The user wants to enhance their existing tree. Acknowledge what they have and ask how you can help improve it." :
                        "Start the wizard conversation. Ask the user what they want to build.");

                console.log('ðŸª„ Wizard asking AI...');
                console.log('ðŸª„ System prompt length:', systemPrompt.length);
                console.log('ðŸª„ User prompt length:', userPrompt.length);

                // SMART MODEL SELECTION for large trees
                // Large trees (50+ items) should use fast models to avoid timeout/cutoff
                const itemCount = (wizardState.workingTree.children || []).reduce((acc, phase) =>
                    acc + (phase.items || []).length, 0);
                const isLargeTree = itemCount >= 50;

                // Check if user selected Deep Mode (user-sonnet, user-gemini, user-chatgpt)
                const aiModeInfo = parseUnifiedMode();
                let useDeepMode = aiModeInfo.mode === 'deep'; // Deep Mode = Extended Thinking

                // Check if we're in fallback mode (from previous cutoff error)
                const useFastFallback = wizardState.useFastFallback || false;

                if (isLargeTree && !useFastFallback) {
                    console.log(`ðŸª„ Large tree detected (${itemCount} items) - recommending fast model`);
                    // For large trees, warn but still try their selected mode first
                    if (useDeepMode) {
                        console.warn('âš ï¸ Deep Mode on large tree may timeout. Will auto-fallback to fast model if needed.');
                    }
                }

                if (useFastFallback) {
                    console.log('ðŸš€ Using fast fallback mode (previous response was cut off)');
                    useDeepMode = false; // Force fast mode
                }

                if (useDeepMode) {
                    console.log('ðŸ§  Wizard using Deep Mode (Extended Thinking enabled)');
                }

                const response = await callClaudeAPI(userPrompt, systemPrompt, 8000, useDeepMode); // Increased to 8000 for complex patterns (Film, Philosophy, etc.)

                console.log('ðŸª„ AI Raw Response:', response);

                // Guard against undefined response
                if (!response) {
                    throw new Error('AI returned empty response. The request may have timed out or failed silently.');
                }

                // Try to extract JSON if AI added text before/after
                let jsonStr = response.trim();

                // If response has markdown code blocks, extract JSON from them
                if (jsonStr.includes('```json')) {
                    const match = jsonStr.match(/```json\s*\n([\s\S]*?)\n```/);
                    if (match) {
                        jsonStr = match[1];
                        console.log('ðŸª„ Extracted from ```json block');
                    }
                } else if (jsonStr.includes('```')) {
                    const match = jsonStr.match(/```\s*\n([\s\S]*?)\n```/);
                    if (match) {
                        jsonStr = match[1];
                        console.log('ðŸª„ Extracted from ``` block');
                    }
                }

                // Find the FIRST complete JSON object using proper brace matching
                // This handles cases where AI adds text before/after the JSON
                const firstBrace = jsonStr.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response. AI may not be following instructions.');
                }

                if (firstBrace > 0) {
                    console.log('ðŸª„ Skipping text before JSON:', jsonStr.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonStr.length; i++) {
                    const char = jsonStr[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    console.error('ðŸª„ Incomplete JSON - Wizard response was cut off!');
                    console.error('ðŸª„ Full response length:', response.length);
                    console.error('ðŸª„ Response (first 500 chars):', response.substring(0, 500));
                    console.error('ðŸª„ Response (last 500 chars):', response.substring(Math.max(0, response.length - 500)));

                    // Check retry limit
                    wizardState.retryCount = (wizardState.retryCount || 0) + 1;
                    if (wizardState.retryCount > 3) {
                        throw new Error('Response was cut off multiple times. Try asking the wizard to add fewer items at once, or click "Finish & Apply" to save current progress.');
                    }

                    // SMART FALLBACK: After first cutoff, switch to fast mode
                    if (wizardState.retryCount === 1 && !wizardState.useFastFallback) {
                        console.log('ðŸš€ First cutoff - enabling fast fallback mode for subsequent requests');
                        wizardState.useFastFallback = true;
                        addWizardMessage('ai', "âš¡ Switching to fast mode for better reliability with your large project...");
                    }

                    // Try to recover by asking AI to simplify
                    console.log('ðŸª„ Attempting auto-recovery (attempt ' + wizardState.retryCount + '/3)...');

                    // Add a recovery message to conversation
                    wizardState.conversation.push({
                        role: 'system',
                        content: 'Your last response was cut off (too long). CRITICAL: Return ONLY a short message and treeUpdate: null. Do NOT include any tree data. Just ask a simple question.'
                    });

                    // Show user-friendly message
                    addWizardMessage('ai', "Oops! My response was too long. Let me try with a much shorter answer...");

                    // Retry with simplified prompt
                    document.getElementById('wizard-user-input').disabled = false;
                    document.getElementById('wizard-send').disabled = false;
                    wizardState.awaitingResponse = false;
                    setTimeout(() => wizardAsk(), 500);
                    return;
                }

                jsonStr = jsonStr.substring(firstBrace, endPos);

                if (endPos < response.length) {
                    console.log('ðŸª„ Skipping text after JSON:', response.substring(endPos, endPos + 50) + '...');
                }

                console.log('ðŸª„ Extracted JSON (first 200 chars):', jsonStr.substring(0, 200) + '...');
                console.log('ðŸª„ JSON length:', jsonStr.length);

                // Sanitize JSON: Fix control characters in string values
                // This handles cases where AI generates unescaped newlines/tabs in strings
                let parsed;
                try {
                    // First, try parsing as-is
                    parsed = JSON.parse(jsonStr);
                } catch (firstError) {
                    console.warn('ðŸª„ JSON parse failed, attempting sanitization...', firstError.message);

                    // Sanitize by escaping control characters within string values
                    // Strategy: Replace literal newlines/tabs/etc with escaped versions
                    // but only within quoted string values (not in JSON structure)

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonStr.length; i++) {
                        const char = jsonStr[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                // Other control characters - escape as unicode
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonStr = sanitized;
                    console.log('ðŸª„ Sanitized JSON:', jsonStr.substring(0, 200) + '...');

                    // Try parsing again after sanitization
                    parsed = JSON.parse(jsonStr);
                }

                // Validate required fields
                if (!parsed.message) {
                    throw new Error('AI response missing "message" field');
                }

                // Success! Reset retry count
                wizardState.retryCount = 0;

                // Add AI message to conversation history
                let messageWithChoices = parsed.message;
                const choiceCount = (parsed.message.match(/\[CHOICE:[^\]]+\]/g) || []).length;
                console.log('ðŸª„ AI message [CHOICE:] markers found:', choiceCount);

                // BUILD 400: Fallback - add default choices if AI forgot
                if (choiceCount === 0 && !parsed.done) {
                    console.log('ðŸª„ No choices found - adding defaults');
                    messageWithChoices += '\n\n[CHOICE:âž• Add more][CHOICE:ðŸ“ More detail][CHOICE:âœ… Looks good][CHOICE:ðŸ”„ Change something]';
                }

                wizardState.conversation.push({role: 'assistant', content: messageWithChoices});
                addWizardMessage('ai', messageWithChoices);

                // Update tree if provided
                if (parsed.treeUpdate) {
                    console.log('ðŸª„ Applying tree update:', parsed.treeUpdate);
                    const aiSource = `ai-${aiModeInfo.model}`;  // e.g., 'ai-sonnet', 'ai-gemini', 'ai-chatgpt'
                    mergeTreeUpdate(parsed.treeUpdate, aiSource);
                    updateWizardPreview();
                }

                // Update progress
                if (parsed.fieldsUpdated && Array.isArray(parsed.fieldsUpdated)) {
                    parsed.fieldsUpdated.forEach(field => wizardState.fieldsCompleted.add(field));
                    document.getElementById('wizard-fields-complete').textContent = wizardState.fieldsCompleted.size;
                }

                // Update progress bar (from AI's progress field 0.0 to 1.0)
                if (parsed.progress !== undefined) {
                    const percentComplete = Math.round(parsed.progress * 100);
                    document.getElementById('wizard-progress-percent').textContent = `${percentComplete}%`;
                    document.getElementById('wizard-progress-bar').style.width = `${percentComplete}%`;

                    // BUILD 405: Also update Tree Agent progress
                    if (typeof updateAgentProgress === 'function') {
                        updateAgentProgress(percentComplete);
                    }
                }

                // Check if done
                if (parsed.done) {
                    document.getElementById('wizard-completion').style.display = 'block';
                    document.getElementById('wizard-progress-bar').style.width = '100%';
                    document.getElementById('wizard-progress-percent').textContent = '100%';

                    // BUILD 405: Update Tree Agent to 100%
                    if (typeof updateAgentProgress === 'function') {
                        updateAgentProgress(100, 'âœ“ Done!');
                    }
                }

            } catch (error) {
                console.error('ðŸª„ Wizard error details:', {
                    error: error.message,
                    stack: error.stack,
                    conversation: wizardState.conversation
                });

                // SMART FALLBACK: Detect timeout and auto-retry with fast mode
                const isTimeout = error.message?.includes('timeout') || error.message?.includes('10-second') || error.message?.includes('10s');

                if (isTimeout && !wizardState.useFastFallback) {
                    console.log('ðŸš€ Timeout detected - enabling fast fallback mode and retrying...');
                    wizardState.useFastFallback = true;
                    wizardState.retryCount = (wizardState.retryCount || 0) + 1;

                    if (wizardState.retryCount <= 2) {
                        addWizardMessage('ai', "âš¡ Request timed out. Switching to fast mode and trying again...");

                        // Retry with fast mode
                        document.getElementById('wizard-user-input').disabled = false;
                        document.getElementById('wizard-send').disabled = false;
                        wizardState.awaitingResponse = false;
                        setTimeout(() => wizardAsk(), 500);
                        return;
                    }
                }

                // Show error message in chat
                const errorMsg = error.message || 'Unknown error occurred';

                // Simplify timeout errors for users
                if (isTimeout) {
                    addWizardMessage('ai', `â±ï¸ Request timed out. Try:\n\n1. Switch to Gemini (Settings â†’ Provider) - no timeout limit\n2. Use Fast Mode (Haiku) - usually faster\n3. Ask me to make smaller changes at a time`);
                } else {
                    addWizardMessage('ai', `I'm having trouble: ${errorMsg}\n\nPlease check:\n1. Is your API key configured? (Settings â†’ API Key)\n2. Try refreshing the page\n3. Check browser console for details (F12)`);
                }
            }

            // Re-enable input
            document.getElementById('wizard-user-input').disabled = false;
            document.getElementById('wizard-send').disabled = false;
            document.getElementById('wizard-user-input').focus();
            wizardState.awaitingResponse = false;
        }

        // User sends message
        document.getElementById('wizard-send').addEventListener('click', async () => {
            const input = document.getElementById('wizard-user-input');
            const message = input.value.trim();

            if (!message || wizardState.awaitingResponse) return;

            // Add to conversation
            wizardState.conversation.push({role: 'user', content: message});
            addWizardMessage('user', message);
            wizardState.questionsAsked++;
            document.getElementById('wizard-question-count').textContent = wizardState.questionsAsked;

            // Clear input
            input.value = '';

            // Get AI response
            await wizardAsk();
        });

        // Build system prompt for wizard
        function buildWizardSystemPrompt() {
            const pattern = PATTERNS[wizardState.patternKey];
            const levels = pattern.levels;
            const fields = pattern.fields || {};

            // Build a summary of current tree (not full JSON to save tokens)
            const treeSummary = wizardState.workingTree.name || 'Empty';
            const phaseCount = (wizardState.workingTree.children || []).length;
            const itemCount = (wizardState.workingTree.children || []).reduce((acc, phase) =>
                acc + (phase.items || phase.children || []).length, 0);

            // Build detailed existing structure summary for enhance mode
            let existingStructure = '';
            if (wizardState.enhanceMode && itemCount > 0) {
                existingStructure = '\n\nðŸŒ³ EXISTING TREE STRUCTURE (DO NOT DELETE - ADD TO THIS):\n\n';
                existingStructure += `**${wizardState.workingTree.name}**\n`;
                if (wizardState.workingTree.description) {
                    existingStructure += `Description: ${wizardState.workingTree.description}\n`;
                }
                existingStructure += '\n';

                (wizardState.workingTree.children || []).forEach((phase, idx) => {
                    existingStructure += `${levels.phase} ${idx + 1}: ${phase.name}`;
                    if (phase.subtitle) existingStructure += ` (${phase.subtitle})`;
                    existingStructure += `\n`;

                    const phaseItems = phase.items || phase.children || [];
                    if (phaseItems.length > 0) {
                        phaseItems.forEach(item => {
                            existingStructure += `  - ${item.name}`;
                            if (item.description) {
                                existingStructure += `: ${item.description.substring(0, 60)}${item.description.length > 60 ? '...' : ''}`;
                            }
                            existingStructure += `\n`;

                            const itemSubtasks = item.subtasks || item.subItems || item.children || [];
                            if (itemSubtasks.length > 0) {
                                existingStructure += `    (${itemSubtasks.length} subtasks)\n`;
                            }
                        });
                    } else {
                        existingStructure += `  (no items yet)\n`;
                    }
                    existingStructure += '\n';
                });

                existingStructure += `Total: ${phaseCount} ${levels.phase.toLowerCase()}(s), ${itemCount} ${levels.item.toLowerCase()}(s)\n\n`;
                existingStructure += `ðŸŽ¯ YOUR MISSION: Help the user ENHANCE this existing tree by:\n`;
                existingStructure += `- Adding more detail to existing items\n`;
                existingStructure += `- Filling gaps or missing sections\n`;
                existingStructure += `- Expanding phases that seem incomplete\n`;
                existingStructure += `- Adding subtasks to items that need them\n\n`;
                existingStructure += `\nâš ï¸âš ï¸âš ï¸ CRITICAL - DO NOT ECHO THE ENTIRE TREE âš ï¸âš ï¸âš ï¸\n`;
                existingStructure += `The tree already has ${itemCount} items. Your treeUpdate MUST contain ONLY:\n`;
                existingStructure += `- NEW items you are ADDING (not existing ones)\n`;
                existingStructure += `- Items you are MODIFYING (with changes)\n`;
                existingStructure += `- DO NOT include unchanged items - they are preserved automatically\n`;
                existingStructure += `- If just asking a question with no changes, use treeUpdate: null\n`;
                existingStructure += `\nâŒ WRONG: Echoing all ${itemCount} items back (wastes tokens, causes cutoff)\n`;
                existingStructure += `âœ… RIGHT: Only new/changed items, or null if just asking\n`;
            }

            const modeInstruction = wizardState.enhanceMode ?
                `You are ENHANCING an existing ${pattern.name} project. The user already has a tree with ${itemCount} items. Help them improve, expand, or fill gaps.` :
                `You are BUILDING a complete ${pattern.name} project from scratch. Extract NECESSARY and SUFFICIENT data in MINIMUM questions.`;

            return `âš ï¸ CRITICAL OUTPUT FORMAT: You MUST return ONLY a valid JSON object. NO text before the opening {. NO text after the closing }. NO explanations. NO commentary. JUST JSON.

You are an EXPERT INFORMATION EXTRACTION WIZARD. ${modeInstruction}

CURRENT STATE:
- Pattern: ${pattern.name}
- Structure: ${levels.root} â†’ ${levels.phase} â†’ ${levels.item} â†’ ${levels.subtask}
- Fields: ${Object.keys(fields).join(', ') || 'none'}
- Completed Fields: ${Array.from(wizardState.fieldsCompleted).join(', ') || 'none'}
- Tree: ${treeSummary} (${phaseCount} phases, ${itemCount} items)${existingStructure}

ðŸŽ¯ CORE MISSION: Extract 100% of required information in â‰¤5 strategic questions

ðŸ–±ï¸ MOUSE-DRIVEN UI - CLICKABLE CHOICES (CRITICAL):
Every question MUST include 2-4 clickable options using [CHOICE:label] markers.
The user clicks to answer - no typing required!

Format your message like this:
"What type of project is this?
[CHOICE:ðŸ“Š Business/Strategy][CHOICE:ðŸŽ¨ Creative/Design][CHOICE:ðŸ“š Educational][CHOICE:ðŸ”§ Technical]"

CHOICE GUIDELINES:
- Use emoji + short label (max 20 chars)
- Offer 2-4 meaningful options that cover common cases
- Include a catch-all like "Something else" or "Custom"
- ALWAYS provide choices - never ask open-ended questions without options
- Choices should help BUILD the tree, not just categorize

EXAMPLE MESSAGES WITH CHOICES:

Turn 1 (Goal):
"What's the main purpose of this ${wizardState.patternKey}?
[CHOICE:ðŸ“‹ Planning/Organizing][CHOICE:ðŸ“ Documenting][CHOICE:ðŸŽ¯ Decision-making][CHOICE:ðŸ’¡ Brainstorming]"

Turn 2 (Scope):
"How many main phases should this have?
[CHOICE:3 phases (simple)][CHOICE:4-5 phases (standard)][CHOICE:6+ phases (complex)][CHOICE:Let me describe]"

Turn 3 (Details):
"I've built the structure. What should I focus on next?
[CHOICE:âž• Add more items][CHOICE:ðŸ“ More detail][CHOICE:âœ… Looks good][CHOICE:ðŸ”„ Restructure]"

ðŸ“Š STRATEGIC QUESTIONING FRAMEWORK:

ðŸŽ¯ QUESTIONING ORDER (CRITICAL - Follow this sequence):

**TURN 1 - UNDERSTAND THE GOAL**
First question MUST clarify: "What is this ${pattern.name.toLowerCase()} trying to ACHIEVE? What's the exact goal?"
- Example: "What specific problem does this ${pattern.name.toLowerCase()} solve?"
- Example: "What output/result should this ${pattern.name.toLowerCase()} produce?"
${pattern.name === 'Prompt Engineering' ? `- âš ï¸ META-LEVEL CLARITY: User is DESIGNING a prompt (not using one). Guide them to describe what THE PROMPT will do, not what THEY want to know.
  â†’ Good: "A prompt that takes X and returns Y"
  â†’ Bad: "I want to know about X"` : ''}
- DO NOT ask about safety, edge cases, or technical details yet
- DO NOT build the tree until you understand the GOAL

**TURN 2 - BUILD MAIN STRUCTURE**
After understanding the goal, propose the main phases/structure:
- "Based on your goal of [X], I'm thinking you need phases: [A, B, C]. Does that cover the main workflow?"
- Build 60-70% of the tree based on the goal
- Ask ONE clarifying question about structure

**TURN 3 - FILL CRITICAL DETAILS**
Add items and subtasks to each phase:
- "I've added [N] items across [M] phases. The biggest gap I see is [X]. Should I add that?"
- Build to 85-90% complete
- Focus on what's MISSING, not refinements

**TURN 4 - VALIDATE & REFINE**
Present near-complete tree and ask about completeness:
- "Does this capture the full workflow for [goal]? Or am I missing critical steps?"
- Now is when you can ask about edge cases, dependencies, special scenarios
- Build to 95%+ complete

**TURN 5 - CLOSE**
Final validation:
- "This looks complete for [goal]. Should I mark it done, or do you want to add/change anything?"
- Set done=true if approved

ðŸš« PRIORITY ORDER (What to ask when):

1. **THE GOAL** (Turn 1) - "What is this prompt trying to achieve exactly?"
2. **MAIN STRUCTURE** (Turn 2) - "What are the main phases/stages to achieve [goal]?"
3. **KEY ITEMS** (Turn 3) - "What are the critical items in each phase?"
4. **COMPLETENESS** (Turn 4) - "Am I missing any critical steps?"
5. **EDGE CASES/REFINEMENTS** (Turn 4) - "Any special scenarios or dependencies?"
6. **VALIDATION** (Turn 5) - "Does this fully capture everything?"

âŒ NEVER ask about these BEFORE understanding the goal:
- Safety considerations
- Model parameters (temperature, tokens)
- Edge cases
- Technical implementation details

âš¡ EFFICIENCY TARGETS (UPDATED):
- Turn 1: Ask about GOAL. Build NOTHING until you understand the purpose.
- Turn 2: Build 60-70% of tree based on goal + ask about structure
- Turn 3: Fill to 85-90% + ask about biggest gaps
- Turn 4: Fill to 95%+ + validate completeness
- Turn 5: Set done=true if approved

ðŸ” INFORMATION EXTRACTION TACTICS:
1. **EMBEDDED CONFIRMATION**: "I've added X, Y, Z as defaults. What am I missing?" (validates + extracts gaps)
2. **CONSTRAINT TESTING**: "I see this needs A. Does it also need B or is A sufficient?" (tests boundaries)
3. **DEPENDENCY PROBING**: "X blocks Y. Anything else blocked by X?" (maps critical paths)
4. **COMPLETENESS CHECK**: "I have N items for phase P. Too many/few/just right?" (validates scope)

ðŸ“‹ NECESSARY & SUFFICIENT DATA:
ALWAYS include in treeUpdate:
- Phases (3-6 typical)
- Items per phase (2-5 typical)
- âš ï¸ NESTED ITEMS${wizardState.patternKey === 'filesystem' ? ' (use "children" property for File System pattern)' : ' (use "subItems" property, NOT "subtasks")'}: Add 2-4 ${levels.subtask}s to items that need decomposition
  â†’ ${levels.subtask}s are PATTERN-SPECIFIC breakdowns:
    â€¢ ${pattern.name === 'Philosophy' ? 'Philosophy: premises, objections, evidence, citations' : ''}
    â€¢ ${pattern.name === 'Sales Pipeline' ? 'Sales: follow-up actions, next steps, deliverables' : ''}
    â€¢ ${pattern.name === 'Thesis' ? 'Thesis: arguments, evidence, citations, counter-arguments' : ''}
    â€¢ ${pattern.name === 'Product Roadmap' ? 'Roadmap: tasks, specs, acceptance criteria, tests' : ''}
    â€¢ ${pattern.name === 'Book' ? 'Book: scenes, character moments, plot points' : ''}
    â€¢ ${pattern.name === 'Course' ? 'Course: lessons, activities, assessments, exercises' : ''}
    â€¢ ${pattern.name === 'Film Production' ? 'Film: shots, camera movements, lighting, blocking' : ''}
    â€¢ ${pattern.name === 'Veo3 (Google)' ? 'Veo3: ingredient images, frame transitions, extensions, audio types (dialogue/SFX/ambience)' : ''}
    â€¢ ${pattern.name === 'Sora2 (OpenAI)' ? 'Sora2: cameo shots, remix variants, physics complexity, beat types (setup/conflict/resolution)' : ''}
    â€¢ ${pattern.name === 'Prompt Engineering' ? 'Prompting: test cases, variations, edge cases' : ''}
    â€¢ Generic: steps, components, or sub-elements
  â†’ Focus on ${pattern.name} deliverables, not generic task lists
  â†’ âœ¨ UNLIMITED NESTING: ${wizardState.patternKey === 'filesystem' ? 'children can have their own children for N-level depth (e.g., Folder â†’ Subfolder â†’ File)' : 'subItems can have their own subItems for N-level depth (e.g., Step 1 â†’ Step 1.1 â†’ Step 1.1.1)'}
- Dependency info in descriptions (e.g., "After Phase 1 completes...")
- Pattern-specific fields (infer from conversation)

NEVER ask about:
- Formatting preferences
- Nice-to-have details that can be added later
- Information already inferrable from context

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ RESPONSE FORMAT - MANDATORY: Return ONLY the JSON below âš ï¸
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO NOT write ANY text before or after the JSON.
Your ENTIRE response must be ONLY this JSON object:

${wizardState.patternKey === 'filesystem' ? `
âš ï¸ FILESYSTEM PATTERN - SPECIAL STRUCTURE:
For File System pattern, use "children" arrays at ALL levels (not "items" or "subItems"):

{
  "message": "I've built [X drives, Y folders]. [State what you added]. [Ask ONE follow-up question]",
  "treeUpdate": {
    "name": "My Computer",
    "description": "File system structure",
    "children": [
      {
        "name": "C:\\ Local Drive",
        "type": "phase",
        "icon": "ðŸ’¾",
        "children": [
          {
            "name": "Projects",
            "type": "item",
            "icon": "ðŸ“",
            "isFolder": true,
            "dateModified": "2025-11-15T14:30:00",
            "children": [
              {
                "name": "report.xlsx",
                "type": "item",
                "icon": "ðŸ“—",
                "isFolder": false,
                "fileSize": 15728640,
                "fileExtension": ".xlsx",
                "dateModified": "2025-11-10T16:45:00"
              }
            ]
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["fileSize", "isFolder"],
  "progress": 0.7,
  "done": false
}

âš ï¸ FILESYSTEM REQUIREMENTS:
- Use "children" for folders AND files (NOT "items" or "subItems")
- Set isFolder: true for folders, false for files
- Include fileSize (bytes), fileExtension, dateModified for files
- Auto-detect icons based on extension (.xlsxâ†’ðŸ“—, .pdfâ†’ðŸ“•, .jpgâ†’ðŸ–¼ï¸, etc.)
- Unlimited nesting depth supported via children arrays
` : wizardState.patternKey === 'prompting' ? `
âš ï¸ AI PROMPT DESIGN PATTERN - SPECIAL FIELDS:
For AI Prompt Design, items MUST include these pattern-specific fields:

{
  "message": "I've designed [X] prompt stages with system instructions, user templates, and examples. [Ask ONE follow-up question]",
  "treeUpdate": {
    "name": "Master Prompt Engineer",
    "description": "Transform weak prompts into highly effective, structured instructions using proven prompt engineering framework",
    "children": [
      {
        "name": "System Configuration",
        "subtitle": "Role, framework, and process",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Core System Prompt",
            "description": "Expert persona and meta-framework for prompt engineering",
            "itemType": "system-prompt",
            "systemPrompt": "You are a Master Prompt Engineer specializing in Large Language Model interactions. Your expertise is transforming vague, simple, or inefficient prompts into highly effective, structured instructions.\n\nYour Framework (apply to every prompt):\n1. PERSONA/ROLE - Assign specific expert identity\n2. TASK - Define objective with active verbs\n3. CONTEXT - Add necessary background\n4. CONSTRAINTS - Define rules (do's and don'ts)\n5. OUTPUT FORMAT - Specify exact structure (Table, JSON, Markdown, etc.)\n\nYour Process:\n1. INPUT ACQUISITION - If no prompt provided, request it\n2. ANALYSIS - Evaluate for Clarity, Context, Constraints (3C Framework)\n3. IMPROVEMENT - Rewrite using the 5-part framework above\n4. DELIVERY - Present as: Critique â†’ Optimized Prompt â†’ Explanation\n\nBe analytical, precise, and helpful. Every improved prompt must be copy-paste ready.",
            "subItems": [
              {
                "name": "Tone Guidelines",
                "description": "Analytical, precise, helpful. Focus on teaching principles, not just fixing."
              },
              {
                "name": "Quality Standards",
                "description": "Every output must be immediately usable. No placeholders unless explicitly requested."
              }
            ]
          }
        ]
      },
      {
        "name": "User Interaction",
        "subtitle": "How users engage with this prompt",
        "type": "phase",
        "phase": 1,
        "items": [
          {
            "name": "User Prompt Template",
            "description": "Ready-to-use prompt for improving other prompts",
            "itemType": "user-template",
            "userPromptTemplate": "Please provide the prompt you would like me to improve. I'll analyze it for clarity, context, and constraints, then rewrite it using proven prompt engineering principles (Persona â†’ Task â†’ Context â†’ Constraints â†’ Output Format). I'll deliver a structured response with: (1) Critique of the original, (2) Optimized version, and (3) Explanation of improvements.",
            "subItems": [
              {
                "name": "Alternative: Batch Mode",
                "description": "For multiple prompts: 'I have three prompts to improve. I'll share them one at a time. For each, provide: Critique â†’ Optimized Version â†’ Key Improvements. Ready for the first one?'"
              }
            ]
          }
        ]
      },
      {
        "name": "Examples & Training",
        "subtitle": "Before/after prompt transformations",
        "type": "phase",
        "phase": 2,
        "items": [
          {
            "name": "Example Set",
            "description": "Demonstrate weak â†’ strong prompt transformations",
            "itemType": "examples",
            "fewShotExamples": "Example 1 - Weak Prompt:\n'Write about climate change.'\n\nOptimized:\n'You are an environmental scientist specializing in climate policy. Write a 500-word article explaining the top 3 impacts of climate change on coastal cities for a general audience. Use concrete examples from Miami, Venice, and Jakarta. Structure: (1) Introduction with thesis, (2) Three impacts with data, (3) Conclusion with actionable steps. Tone: Informative but accessible, avoid jargon.'\n\nKey Improvement: Added persona (environmental scientist), specific task (3 impacts, 500 words, examples), constraints (avoid jargon), and output structure.\n\n---\n\nExample 2 - Weak Prompt:\n'Help me with my resume.'\n\nOptimized:\n'You are a senior tech recruiter with 15 years of experience at FAANG companies. Review my software engineer resume and provide feedback in this format:\n1. STRENGTHS - What stands out positively\n2. GAPS - What's missing or unclear\n3. IMPROVEMENTS - 3 specific changes to increase interview callbacks\n4. REWRITE - Rewrite the Experience section for my top role using STAR format (Situation, Task, Action, Result)\n\nFocus on quantifiable achievements and technical impact. Target: Senior SWE roles at large tech companies.'\n\nKey Improvement: Added expert persona (tech recruiter), clear analysis framework (4-part structure), constraints (quantifiable, STAR format), and target audience (senior roles, big tech).",
            "subItems": [
              {
                "name": "Domain-Specific Example: Gardening Assistant",
                "description": "Full prompt structure for fall/winter gardening in Victoria, BC. System: 'You are an expert Pacific Northwest gardening consultant specializing in fall and winter cultivation in USDA zones 8-9. You provide specific, actionable advice based on local climate patterns, soil conditions, and seasonal timing for Victoria, BC and surrounding regions.' User: 'I need fall/winter gardening advice for Victoria, BC. Start by asking me what plants I want to grow, my experience level, and my garden conditions (soil type, sun exposure). Then provide a tailored planting and maintenance guide based on my answers.' Output Format: '1. Planting Timeline (specific dates/months), 2. Soil Preparation (pH, amendments, prep steps), 3. Planting Instructions (depth, spacing, technique), 4. Maintenance Schedule (weekly tasks through season), 5. Harvest Timing (when and how to harvest).' This shows how the meta-framework applies to a concrete domain."
              }
            ]
          }
        ]
      },
      {
        "name": "Output Specification",
        "subtitle": "Standardized delivery format",
        "type": "phase",
        "phase": 3,
        "items": [
          {
            "name": "Response Structure",
            "description": "Consistent 3-part delivery format",
            "itemType": "output-format",
            "outputFormat": "Deliver every improved prompt in this format:\n\n**1. CRITIQUE OF ORIGINAL PROMPT**\n- Briefly explain weaknesses (e.g., 'Lacked persona,' 'Too vague on formatting,' 'No constraints')\n\n**2. OPTIMIZED PROMPT**\n> [Full rewritten prompt in blockquote or code block for easy copying]\n\n**3. EXPLANATION OF CHANGES**\n- Explain why specific changes improve results (e.g., 'Added expert persona to increase authority,' 'Specified output format to ensure consistency')\n\nOptional: If the original prompt is ambiguous, ask 1-2 clarifying questions before optimizing.",
            "chainOfThought": "Before rewriting, analyze using 3C Framework: (1) CLARITY - Is intent obvious? (2) CONTEXT - Does AI know its role and audience? (3) CONSTRAINTS - Are there guardrails on length, format, style? Then apply 5-part framework: Persona â†’ Task â†’ Context â†’ Constraints â†’ Output Format."
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["systemPrompt", "userPromptTemplate", "fewShotExamples", "outputFormat", "chainOfThought"],
  "progress": 0.8,
  "done": false
}

âš ï¸ CRITICAL for Prompt Engineering pattern:
- ALWAYS populate systemPrompt, userPromptTemplate, fewShotExamples, outputFormat fields
- TEACH THE META-FRAMEWORK: Persona â†’ Task â†’ Context â†’ Constraints â†’ Output Format
- SHOW THE PROCESS: Input Acquisition â†’ Analysis (3C: Clarity, Context, Constraints) â†’ Improvement â†’ Delivery
- NO PLACEHOLDER VARIABLES: Use interactive style (AI asks questions) or specific style (list concrete topics)
- READY-TO-USE: Prompts must work immediately when pasted (no {{variable}} substitution needed)
- Use subItems for supplementary details (tone guidelines, quality standards, alternatives)
- Each phase represents a component of the final prompt (System, User, Examples, Output)
- The Generate Prompt feature extracts these fields to create the executable prompt
` : wizardState.patternKey === 'lifetree' ? `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ðŸŽ™ï¸ LARRY KING BIOGRAPHER MODE (Build 402)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

You interview like LARRY KING: simple questions, genuine curiosity, never interrupt a good story, always follow the interesting thread. You're building someone's life story one memory at a time.

YOUR INTERVIEWING STYLE:
â€¢ ONE simple question at a time - Larry never asked compound questions
â€¢ "Where were you born?" NOT "Tell me about your early childhood and family"
â€¢ When they give gold, acknowledge it: "Fascinating." then dig deeper on THAT
â€¢ Follow THEIR energy - if they light up about something, stay there
â€¢ Yes/No or A/B/C choices make it easy: offer clickable [CHOICE:] options
â€¢ Numbers are easy: "How many siblings?" "What year was that?"
â€¢ If they ramble (good!), extract the gems and save each one

LARRY'S SIGNATURE MOVES:
â€¢ "Let me make sure I got that..." (confirm facts, then save them)
â€¢ "What was that like?" (open the emotional door)
â€¢ "And then what happened?" (keep the story flowing)
â€¢ "Who else was there?" (get the people)
â€¢ "Where was this?" (get the place)
â€¢ "Wait - go back to that part about..." (follow the gold)

THE 12 LIFE TERRITORIES (probe systematically but follow their lead):
1. Birth/Origins - where, when, hospital, parents
2. Childhood Home - address, neighborhood, what it looked like
3. Family - parents' jobs, siblings, grandparents
4. School - which ones, favorite subjects, friends
5. Activities - sports, music, hobbies, collections
6. Pets - names, types, stories
7. Work - first job, career arc, memorable bosses
8. Love - dating, marriage, kids
9. Places - moves, vacations, adventures
10. Hard Times - losses, challenges, how they coped
11. Proud Moments - achievements, graduations, awards
12. Characters - the unforgettable people in their life

+1 SCORING: Every memory you capture = +1 to their LifeTree Score
In your message, acknowledge saves with: "âœ“ Added: [memory title] (+1)"

RICH EVENT FORMAT (capture everything you learn):
{
  "name": "Memory title",
  "eventDate": "Month Year or exact date",
  "age": "How old they were",
  "location": "Where it happened",
  "people": "Who was involved",
  "description": "The story details",
  "emotion": "joy|sadness|pride|fear|love|surprise|gratitude|determination",
  "source": "How you know this (conversation, photo, document)",
  "confidence": "Exact|Approximate|Uncertain"
}

DECADE PHASES: Organize memories into life phases (decades or life stages):
- Early Childhood (0-5)
- Childhood (6-12)
- Teen Years (13-19)
- Young Adulthood (20s)
- 30s, 40s, 50s, etc.

âš ï¸ CRITICAL: Every response MUST include [CHOICE:] buttons!
Make it easy to continue the conversation:
[CHOICE:ðŸ“ Add location][CHOICE:ðŸ‘¥ Add people][CHOICE:ðŸ“… More about that time][CHOICE:âž¡ï¸ Next memory]

EXAMPLE JSON RESPONSES:

Turn 1 - Getting started:
{
  "message": "I'm excited to help capture your life story! Let's start at the very beginning.\\n\\nWhere were you born?\\n\\n[CHOICE:ðŸ¥ Hospital][CHOICE:ðŸ  At home][CHOICE:ðŸŒ Another country][CHOICE:ðŸ“ I'll type it]",
  "treeUpdate": {
    "name": "My Life Story",
    "description": "A biographical journey through key life moments",
    "children": []
  },
  "fieldsUpdated": [],
  "progress": 0.05,
  "done": false
}

Turn 2+ - Capturing memories:
{
  "message": "âœ“ Added: Born at Grey Nuns Hospital, Regina (+1)\\n\\nFascinating - your mother worked right at the hospital where you were born! The Grey Nuns founded that place in 1898.\\n\\nWhat was that like, growing up with a nurse for a mother?\\n\\n[CHOICE:ðŸ‘©â€âš•ï¸ She worked a lot][CHOICE:ðŸ  She was home mostly][CHOICE:ðŸ’‰ I learned medical stuff][CHOICE:ðŸ“– Tell you a story]",
  "treeUpdate": {
    "name": "My Life Story",
    "children": [
      {
        "name": "Early Years (1960-1965)",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Born at Grey Nuns Hospital",
            "eventDate": "May 18, 1960",
            "age": "0",
            "location": "Regina, Saskatchewan",
            "people": "Mom (nurse at the hospital)",
            "description": "Born at the historic Grey Nuns Hospital where my mother worked as a nurse",
            "emotion": "joy",
            "confidence": "Exact"
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["eventDate", "location", "people"],
  "progress": 0.15,
  "done": false
}

âš ï¸ LIFETREE CRITICAL RULES:
- Ask ONE simple question at a time (Larry King style)
- ALWAYS include 3-4 [CHOICE:] buttons for easy responses
- Save memories IMMEDIATELY when shared - don't batch them
- Acknowledge every save with "âœ“ Added: [title] (+1)"
- Follow the interesting thread - if they light up about something, stay there
- Calculate ages from birth year if known
- Use emotion field to capture the feeling of the memory
- Progress slowly (0.05-0.1 per turn) - life stories take time!
` : `
âš ï¸ OPTION A - When just asking a question (NO tree changes):
{
  "message": "Your question here? [CHOICE:Option A][CHOICE:Option B][CHOICE:Something else]",  // âš ï¸ ALWAYS include [CHOICE:] markers!
  "treeUpdate": null,
  "fieldsUpdated": [],
  "progress": 0.5,
  "done": false
}

âš ï¸ OPTION B - When ADDING new items (include ONLY the new items):
{
  "message": "I've added [X]. What should I focus on next? [CHOICE:âž• Add more][CHOICE:ðŸ“ More detail][CHOICE:âœ… Looks good]",  // âš ï¸ ALWAYS include [CHOICE:] markers!
  "treeUpdate": {
    "name": "Project Name",
    "description": "Brief description",
    "children": [
      {
        "name": "Phase 1",
        "subtitle": "Phase subtitle",
        "type": "phase",
        "phase": 0,
        "items": [
          {
            "name": "Item name",
            "description": "Item description (include dependency notes like 'Requires X to complete first' if order matters)",
            "itemType": "type",
            "subItems": [
              {
                "name": "Step 1",
                "description": "Detail",
                "subItems": [
                  {"name": "Step 1.1", "description": "Nested detail (supports N-level depth)"}
                ]
              },
              {"name": "Step 2", "description": "Detail"}
            ]
          }
        ]
      }
    ]
  },
  "fieldsUpdated": ["field1", "field2"],
  "progress": 0.7,
  "done": false
}`}

ðŸŽ¯ CRITICAL RULES:
- Return ONLY JSON, no text before/after
- âš ï¸ KEEP RESPONSES CONCISE: Don't add too many items at once (max 5-7 items per turn)
- Turn 1: Build MINIMAL tree (just project name), ask about GOAL
- Turn 2+: Include treeUpdate with 2-4+ new items per turn
- INFER AGGRESSIVELY: Add details based on context, let user correct
- EVERY message must end with ONE strategic follow-up question (unless done=true)
- Follow the QUESTIONING ORDER above (Goal â†’ Structure â†’ Details â†’ Validation)
- Track progress field accurately (0.0 â†’ 1.0)
- Set done=true when tree is complete (typically turn 5)
- If tree is getting large (>20 items), add fewer items per turn to avoid truncation

ðŸš€ FIRST RESPONSE INSTRUCTION:
${wizardState.enhanceMode ? `
ENHANCE MODE - First response:
${itemCount > 30 ? `
â›” LARGE TREE DETECTED (${itemCount} items) - DO NOT ECHO THE TREE!
1. Set treeUpdate to NULL (the system already has all the data)
2. Set progress based on how complete the tree already is (0.5 to 0.8 typical)
3. Ask: "I can see you have ${phaseCount} ${levels.phase.toLowerCase()}s and ${itemCount} ${levels.item.toLowerCase()}s. What would you like me to help you with? Add more items, expand existing ones, or fill gaps?"

â›”â›”â›” CRITICAL: For trees with 30+ items, you MUST use treeUpdate: null
The existing tree is already loaded. Echoing it back wastes tokens and causes cutoff errors.
` : `
1. Return a SUMMARY of the tree structure in treeUpdate (max 5-10 representative items, NOT everything)
2. Set progress based on how complete the tree already is (0.5 to 0.8 typical)
3. Ask: "I can see you have [X]. What would you like me to help you with? Add more ${levels.item.toLowerCase()}s, expand existing ones with more detail, add subtasks, or fill gaps?"
`}

âš ï¸ ALL RESPONSES (including first): Include ONLY new or modified items. NEVER echo the full tree.
   - If just asking a question: Use treeUpdate: null
   - If adding new items to an existing phase: Include just that phase with the new items
   - If modifying an existing item: Include just that item with changes
   - If adding a new phase: Include just the new phase
   - Items not mentioned are automatically preserved!
` : `
BUILD MODE - First response:
1. Create minimal tree with just project name and empty description
2. Set progress to 0.1
3. ${pattern.name === 'Prompt Engineering' ? `Ask: "What prompt do you want to design? Describe what it should DO when someone uses it.

Examples:
â€¢ 'A prompt that takes a business idea and returns a 5-year financial projection with key metrics'
â€¢ 'A prompt that analyzes code for security vulnerabilities and suggests fixes with severity ratings'
â€¢ 'A prompt that converts casual emails into formal business communications'

Remember: You're DESIGNING a prompt (meta-level), not using one. Tell me what task the prompt should perform."` : `Ask: "What is the exact GOAL of this ${pattern.name.toLowerCase()}? What specific output/result should it produce?"`}

DO NOT build phases, items, or subtasks in Turn 1. Wait to understand the goal first.
`}`;
        }

        // Merge tree update into working tree (SMART MERGE - preserves existing data)
        function mergeTreeUpdate(update, aiSource = 'ai-sonnet') {
            if (update.name) wizardState.workingTree.name = update.name;
            if (update.description) wizardState.workingTree.description = update.description;

            if (update.children) {
                // Initialize existing children if none
                if (!wizardState.workingTree.children) {
                    wizardState.workingTree.children = [];
                }

                // Helper: Find matching phase by name (case-insensitive, fuzzy)
                function findMatchingPhase(phaseName, existingPhases) {
                    const normalizedName = phaseName.toLowerCase().trim();
                    return existingPhases.find(p =>
                        p.name.toLowerCase().trim() === normalizedName ||
                        p.name.toLowerCase().includes(normalizedName) ||
                        normalizedName.includes(p.name.toLowerCase())
                    );
                }

                // Helper: Find matching item by name (case-insensitive, fuzzy)
                function findMatchingItem(itemName, existingItems) {
                    const normalizedName = itemName.toLowerCase().trim();
                    return existingItems.find(i =>
                        i.name.toLowerCase().trim() === normalizedName ||
                        i.name.toLowerCase().includes(normalizedName) ||
                        normalizedName.includes(i.name.toLowerCase())
                    );
                }

                // Track which existing phases were matched
                const matchedPhaseIds = new Set();

                // Process each phase from update
                update.children.forEach((updatedPhase, phaseIdx) => {
                    const existingPhase = findMatchingPhase(updatedPhase.name, wizardState.workingTree.children);

                    if (existingPhase) {
                        // MERGE with existing phase
                        console.log(`ðŸ”„ Merging phase: ${updatedPhase.name}`);
                        matchedPhaseIds.add(existingPhase.id);

                        // Update phase-level fields (preserve existing if not in update)
                        existingPhase.name = updatedPhase.name || existingPhase.name;
                        existingPhase.subtitle = updatedPhase.subtitle || existingPhase.subtitle;
                        if (updatedPhase.description) existingPhase.description = updatedPhase.description;

                        // Merge items (standard patterns) OR children (filesystem pattern)
                        const itemsArrayName = updatedPhase.items ? 'items' : (updatedPhase.children ? 'children' : null);
                        if (itemsArrayName) {
                            if (!existingPhase[itemsArrayName]) existingPhase[itemsArrayName] = [];

                            const matchedItemIds = new Set();

                            updatedPhase[itemsArrayName].forEach((updatedItem, itemIdx) => {
                                const existingItem = findMatchingItem(updatedItem.name, existingPhase[itemsArrayName]);

                                if (existingItem) {
                                    // MERGE with existing item - preserve ALL existing fields
                                    console.log(`  ðŸ”„ Merging item: ${updatedItem.name}`);
                                    matchedItemIds.add(existingItem.id);

                                    // BUILD 406: Track as modified
                                    if (typeof trackNodeChange === 'function') {
                                        trackNodeChange(existingItem.id, 'modified');
                                    }

                                    // Merge all fields (keep existing if not in update)
                                    Object.keys(updatedItem).forEach(key => {
                                        if (key !== 'subItems' && key !== 'children' && updatedItem[key] !== undefined && updatedItem[key] !== '') {
                                            existingItem[key] = updatedItem[key];
                                        }
                                    });

                                    // Merge subItems (RECURSIVE for N-level depth support)
                                    // Supports both 'subItems' (standard) and 'children' (filesystem)
                                    function mergeSubItems(existingParent, updatedParent, parentPhase, parentItemIdx) {
                                        const nestedArrayName = updatedParent.subItems ? 'subItems' : (updatedParent.children ? 'children' : null);
                                        if (!nestedArrayName) return;
                                        if (!existingParent[nestedArrayName]) existingParent[nestedArrayName] = [];

                                        updatedParent[nestedArrayName].forEach(newSubItem => {
                                            const existingSubItem = existingParent[nestedArrayName].find(s =>
                                                s.name.toLowerCase().trim() === newSubItem.name.toLowerCase().trim()
                                            );

                                            if (existingSubItem) {
                                                // Update existing subItem
                                                Object.keys(newSubItem).forEach(key => {
                                                    if (key !== 'subItems' && key !== 'children' && newSubItem[key] !== undefined && newSubItem[key] !== '') {
                                                        existingSubItem[key] = newSubItem[key];
                                                    }
                                                });

                                                // RECURSIVE: Merge nested items (supports N-level depth)
                                                mergeSubItems(existingSubItem, newSubItem, parentPhase, parentItemIdx);
                                            } else {
                                                // Add new item with auto-generated ID
                                                const subIdx = existingParent[nestedArrayName].length;
                                                const newSubItemWithId = {
                                                    id: `${nestedArrayName === 'children' ? 'child' : 'subtask'}-${parentPhase}-${parentItemIdx}-${subIdx}`,
                                                    type: nestedArrayName === 'children' ? 'item' : 'subtask',
                                                    ...newSubItem,
                                                    provenance: {
                                                        source: aiSource,
                                                        timestamp: new Date().toISOString()
                                                    }
                                                };
                                                existingParent[nestedArrayName].push(newSubItemWithId);
                                            }
                                        });
                                    }

                                    mergeSubItems(existingItem, updatedItem, existingPhase.phase, existingPhase[itemsArrayName].indexOf(existingItem));
                                } else {
                                    // ADD new item to existing phase
                                    console.log(`  âœ… Adding new item: ${updatedItem.name}`);
                                    const newItemIdx = existingPhase[itemsArrayName].length;

                                    // RECURSIVE function to add IDs to nested items (supports both subItems and children)
                                    function addNestedItemIds(nestedItems, nestedArrayName, phaseIdx, itemIdx, parentPath = '') {
                                        if (!nestedItems) return [];
                                        return nestedItems.map((nestedItem, nestedIdx) => {
                                            const childArrayName = nestedItem.subItems ? 'subItems' : (nestedItem.children ? 'children' : null);
                                            const result = {
                                                id: `${nestedArrayName === 'children' ? 'child' : 'subtask'}-${phaseIdx}-${itemIdx}-${parentPath}${nestedIdx}`,
                                                type: nestedArrayName === 'children' ? 'item' : 'subtask',
                                                ...nestedItem
                                            };
                                            if (childArrayName) {
                                                result[childArrayName] = addNestedItemIds(nestedItem[childArrayName], childArrayName, phaseIdx, itemIdx, `${parentPath}${nestedIdx}-`);
                                            }
                                            return result;
                                        });
                                    }

                                    const nestedArrayName = updatedItem.subItems ? 'subItems' : (updatedItem.children ? 'children' : null);
                                    const newItem = {
                                        id: `item-${existingPhase.phase}-${newItemIdx}`,
                                        type: 'item',
                                        icon: 'ðŸ“„',
                                        expanded: false,
                                        ...updatedItem,
                                        provenance: {
                                            source: aiSource,
                                            timestamp: new Date().toISOString()
                                        }
                                    };
                                    if (nestedArrayName) {
                                        newItem[nestedArrayName] = addNestedItemIds(updatedItem[nestedArrayName], nestedArrayName, existingPhase.phase, newItemIdx);
                                    }
                                    existingPhase[itemsArrayName].push(newItem);

                                    // BUILD 406: Track as new
                                    if (typeof trackNodeChange === 'function') {
                                        trackNodeChange(newItem.id, 'new');
                                    }
                                }
                            });

                            // PRESERVE existing items that weren't in the update
                            console.log(`  â„¹ï¸ Preserved ${existingPhase[itemsArrayName].filter(i => !matchedItemIds.has(i.id)).length} existing items not in update`);
                        }
                    } else {
                        // ADD new phase
                        console.log(`âœ… Adding new phase: ${updatedPhase.name}`);
                        const newPhaseIdx = wizardState.workingTree.children.length;

                        // RECURSIVE function to add IDs to nested subItems (reuse from above)
                        function addSubItemIds(subItems, phaseIdx, itemIdx, parentPath = '') {
                            if (!subItems) return [];
                            return subItems.map((subItem, subIdx) => ({
                                id: `subtask-${phaseIdx}-${itemIdx}-${parentPath}${subIdx}`,
                                type: 'subtask',
                                ...subItem,
                                provenance: {
                                    source: aiSource,
                                    timestamp: new Date().toISOString()
                                },
                                subItems: addSubItemIds(subItem.subItems, phaseIdx, itemIdx, `${parentPath}${subIdx}-`)
                            }));
                        }

                        const newPhase = {
                            id: `phase-${newPhaseIdx}`,
                            type: 'phase',
                            phase: newPhaseIdx,
                            icon: 'ðŸ“‹',
                            expanded: true,
                            ...updatedPhase,
                            provenance: {
                                source: aiSource,
                                timestamp: new Date().toISOString()
                            },
                            items: (updatedPhase.items || []).map((item, itemIdx) => ({
                                id: `item-${newPhaseIdx}-${itemIdx}`,
                                type: 'item',
                                icon: 'ðŸ“„',
                                expanded: false,
                                ...item,
                                provenance: {
                                    source: aiSource,
                                    timestamp: new Date().toISOString()
                                },
                                subItems: addSubItemIds(item.subItems, newPhaseIdx, itemIdx)
                            }))
                        };
                        wizardState.workingTree.children.push(newPhase);

                        // BUILD 406: Track new phase and its items
                        if (typeof trackNodeChange === 'function') {
                            trackNodeChange(newPhase.id, 'new');
                            // Also track each new item in the phase
                            (newPhase.items || []).forEach(item => {
                                trackNodeChange(item.id, 'new');
                            });
                        }
                    }
                });

                // PRESERVE existing phases that weren't in the update
                const preservedPhases = wizardState.workingTree.children.filter(p => !matchedPhaseIds.has(p.id));
                console.log(`â„¹ï¸ Preserved ${preservedPhases.length} existing phases not in update`);

                // Re-index phase numbers
                wizardState.workingTree.children.forEach((phase, idx) => {
                    phase.phase = idx;
                });

                console.log(`âœ… Smart merge complete: ${wizardState.workingTree.children.length} phases, ${wizardState.workingTree.children.reduce((sum, p) => sum + (p.items?.length || 0), 0)} items`);
            }
        }

        // =============================================================================
        // HYPEREDGE MANAGEMENT (Wolfram-style N-ary relationships)
        // =============================================================================

        /**
         * Add a new hyperedge to the root-level hyperedges array
         * @param {string} type - Type of hyperedge (e.g., 'montage', 'argument', 'theme', 'dependency-cluster')
         * @param {string} label - Human-readable label for the hyperedge
         * @param {string[]} nodeIds - Array of global node IDs (2+ nodes)
         * @param {object} metadata - Optional metadata (color, pattern, created, etc.)
         * @returns {object} The created hyperedge
         */
        function addHyperedge(type, label, nodeIds, metadata = {}) {
            if (!capexTree.hyperedges) {
                capexTree.hyperedges = [];
            }

            if (nodeIds.length < 2) {
                console.warn('Hyperedge requires at least 2 nodes');
                return null;
            }

            const hyperedge = {
                id: `hyperedge-${Date.now()}`,
                type: type,
                label: label,
                nodeIds: nodeIds,
                metadata: {
                    created: new Date().toISOString(),
                    ...metadata
                }
            };

            capexTree.hyperedges.push(hyperedge);
            console.log(`âœ… Created hyperedge: ${label} (${nodeIds.length} nodes)`);

            return hyperedge;
        }

        /**
         * Remove a hyperedge by ID
         * @param {string} hyperedgeId - The ID of the hyperedge to remove
         * @returns {boolean} True if removed, false if not found
         */
        function removeHyperedge(hyperedgeId) {
            if (!capexTree.hyperedges) {
                return false;
            }

            const initialLength = capexTree.hyperedges.length;
            capexTree.hyperedges = capexTree.hyperedges.filter(h => h.id !== hyperedgeId);

            const removed = capexTree.hyperedges.length < initialLength;
            if (removed) {
                console.log(`âœ… Removed hyperedge: ${hyperedgeId}`);
            }

            return removed;
        }

        /**
         * Global handler for deleting hyperedges from the info panel UI
         * @param {string} id - The hyperedge ID to delete
         */
        window.deleteHyperedge = function(id) {
            if (confirm('Delete this hyperedge group?')) {
                saveState('Delete Hyperedge');
                removeHyperedge(id);
                renderCanvas(); // Re-draw canvas to remove the visual blob
                showInfo(capexTree); // Refresh the info panel to update the list
            }
        }

        /**
         * Find all hyperedges containing a specific node
         * @param {string} nodeId - The node ID to search for
         * @returns {object[]} Array of hyperedges containing this node
         */
        function findHyperedgesForNode(nodeId) {
            if (!capexTree.hyperedges) {
                return [];
            }

            return capexTree.hyperedges.filter(h => h.nodeIds.includes(nodeId));
        }

        /**
         * Get a specific hyperedge by ID
         * @param {string} hyperedgeId - The hyperedge ID
         * @returns {object|null} The hyperedge or null if not found
         */
        function getHyperedgeById(hyperedgeId) {
            if (!capexTree.hyperedges) {
                return null;
            }

            return capexTree.hyperedges.find(h => h.id === hyperedgeId) || null;
        }

        /**
         * Get all hyperedges
         * @returns {object[]} Array of all hyperedges
         */
        function getAllHyperedges() {
            return capexTree.hyperedges || [];
        }

        /**
         * Helper: Get a node by its global ID (searches entire tree)
         * @param {string} nodeId - The node ID to find
         * @returns {object|null} The node or null if not found
         */
        function getNodeById(nodeId) {
            if (capexTree.id === nodeId) return capexTree;

            function searchNode(node) {
                if (node.id === nodeId) return node;

                // Search children (phases)
                if (node.children) {
                    for (const child of node.children) {
                        const found = searchNode(child);
                        if (found) return found;
                    }
                }

                // Search items
                if (node.items) {
                    for (const item of node.items) {
                        const found = searchNode(item);
                        if (found) return found;
                    }
                }

                // Search subItems
                if (node.subItems) {
                    for (const subItem of node.subItems) {
                        const found = searchNode(subItem);
                        if (found) return found;
                    }
                }

                return null;
            }

            return searchNode(capexTree);
        }

        // =============================================================================
        // END HYPEREDGE MANAGEMENT
        // =============================================================================

        // =============================================================================
        // COLLABORATION: Branch & Merge (Email-based async collaboration)
        // =============================================================================

        // Collaboration state
        let currentBranch = null;  // Set when editing a shared branch

        /**
         * Generate or retrieve a stable device fingerprint for contributor tracking
         * Uses canvas fingerprinting + localStorage persistence
         * @returns {string} Device fingerprint ID
         */
        function getDeviceFingerprint() {
            let fp = localStorage.getItem('treelisty-device-id');
            if (!fp) {
                // Generate fingerprint from canvas rendering (browser-specific)
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#6366f1';
                ctx.fillText('TreeListy-FP-2025', 10, 10);
                ctx.fillStyle = '#8b5cf6';
                ctx.fillRect(100, 20, 50, 20);

                // Extract hash from canvas data
                const dataURL = canvas.toDataURL();
                const hash = dataURL.slice(-24).replace(/[^a-zA-Z0-9]/g, '');

                fp = `device-${hash}-${Date.now().toString(36)}`;
                localStorage.setItem('treelisty-device-id', fp);
                console.log('ðŸ”‘ Generated new device fingerprint:', fp);
            }
            return fp;
        }

        /**
         * Get the ancestry path (breadcrumb) for a node
         * @param {string} nodeId - The node to find ancestry for
         * @returns {Array} Array of {id, name, type, icon} from root to parent
         */
        function getAncestryPath(nodeId) {
            const ancestry = [];

            function findPath(node, currentPath = []) {
                // Add this node to path
                const pathEntry = {
                    id: node.id,
                    name: node.name,
                    type: node.type,
                    icon: node.icon || 'ðŸ“„'
                };
                const newPath = [...currentPath, pathEntry];

                // Check if this is the target
                if (node.id === nodeId) {
                    // Return path WITHOUT the target node (just ancestors)
                    return currentPath;
                }

                // Search children (phases)
                if (node.children) {
                    for (const child of node.children) {
                        const found = findPath(child, newPath);
                        if (found) return found;
                    }
                }

                // Search items
                if (node.items) {
                    for (const item of node.items) {
                        const found = findPath(item, newPath);
                        if (found) return found;
                    }
                }

                // Search subItems
                if (node.subItems) {
                    for (const subItem of node.subItems) {
                        const found = findPath(subItem, newPath);
                        if (found) return found;
                    }
                }

                return null;
            }

            return findPath(capexTree) || [{ id: capexTree.id, name: capexTree.name, type: 'root', icon: capexTree.icon }];
        }

        /**
         * Count nodes in a subtree (for size estimation)
         * @param {object} node - Node to count from
         * @returns {number} Total node count including descendants
         */
        function countSubtreeNodes(node) {
            let count = 1;
            if (node.children) node.children.forEach(c => count += countSubtreeNodes(c));
            if (node.items) node.items.forEach(i => count += countSubtreeNodes(i));
            if (node.subItems) node.subItems.forEach(s => count += countSubtreeNodes(s));
            return count;
        }

        /**
         * Estimate compressed URL size for a branch
         * @param {object} branch - Branch token object
         * @returns {number} Estimated URL length in characters
         */
        function estimateBranchURLSize(branch) {
            const json = JSON.stringify(branch);
            // LZ-String typically achieves 30-50% compression
            // Add base URL length (~50 chars) + parameter name (~10 chars)
            const estimatedCompressed = Math.ceil(json.length * 0.6);
            return estimatedCompressed + 60;
        }

        // Maximum recommended URL length (safe for email clients, browsers)
        const MAX_BRANCH_URL_LENGTH = 8000;
        const WARN_BRANCH_URL_LENGTH = 4000;

        /**
         * Extract a subtree for sharing as a collaboration branch
         * @param {string[]} nodeIds - Array of node IDs to include
         * @param {string|null} hyperedgeId - Optional hyperedge ID if sharing a hyperedge
         * @returns {object} Branch token or error object
         */
        function extractSubtree(nodeIds, hyperedgeId = null) {
            if (!nodeIds || nodeIds.length === 0) {
                return { error: 'No nodes selected for sharing' };
            }

            // Get ancestry path from first node (they should share common ancestry)
            const ancestry = getAncestryPath(nodeIds[0]);

            // Deep clone selected nodes with all descendants
            const nodes = [];
            let totalNodeCount = 0;

            for (const id of nodeIds) {
                const node = getNodeById(id);
                if (node) {
                    console.log(`ðŸ“¦ Extracting node ${id}:`, node.name, '| description:', node.description?.substring(0, 50));
                    const cloned = JSON.parse(JSON.stringify(node));
                    nodes.push(cloned);
                    totalNodeCount += countSubtreeNodes(cloned);
                } else {
                    console.warn(`âš ï¸ Node ${id} not found, skipping`);
                }
            }

            if (nodes.length === 0) {
                return { error: 'No valid nodes found to share' };
            }

            // Build branch token
            const branch = {
                branchId: `branch-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                sourceProjectId: capexTree.id,
                sourceProjectName: capexTree.name,
                sourcePattern: currentPattern,
                createdAt: new Date().toISOString(),
                createdBy: getDeviceFingerprint(),
                ancestry,
                hyperedgeId,
                selectedNodeIds: nodeIds,
                nodes,
                schemaVersion: 2
            };

            // Size validation
            const estimatedSize = estimateBranchURLSize(branch);
            if (estimatedSize > MAX_BRANCH_URL_LENGTH) {
                return {
                    error: `Selection too large to share via URL (${totalNodeCount} nodes, ~${Math.round(estimatedSize/1000)}KB)`,
                    nodeCount: totalNodeCount,
                    estimatedSize,
                    suggestion: 'Try selecting fewer nodes or a smaller subtree'
                };
            }

            // Add size info for warnings
            branch._meta = {
                nodeCount: totalNodeCount,
                estimatedURLSize: estimatedSize,
                sizeWarning: estimatedSize > WARN_BRANCH_URL_LENGTH
            };

            console.log(`ðŸ“¦ Extracted branch: ${nodes.length} root nodes, ${totalNodeCount} total nodes, ~${estimatedSize} chars`);
            return branch;
        }

        /**
         * Generate a shareable URL for a branch
         * @param {object} branch - Branch token from extractSubtree
         * @returns {string} Shareable URL with ?branch= parameter
         */
        function generateBranchURL(branch) {
            // Remove internal meta before encoding
            const branchToEncode = { ...branch };
            delete branchToEncode._meta;

            const json = JSON.stringify(branchToEncode);
            const compressed = LZString.compressToEncodedURIComponent(json);
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?branch=${compressed}`;
        }

        /**
         * Check if currently in branch editing mode
         * @returns {boolean} True if editing a shared branch
         */
        function isBranchMode() {
            return currentBranch !== null;
        }

        // Temporary storage for current branch being shared
        let pendingShareBranch = null;

        /**
         * Show the Share Branch modal for collaboration
         * @param {string[]} nodeIds - Array of node IDs to share
         * @param {string|null} hyperedgeId - Optional hyperedge ID
         */
        function showShareBranchModal(nodeIds, hyperedgeId = null) {
            const modal = document.getElementById('share-branch-modal');
            const body = document.getElementById('share-branch-body');

            // Extract subtree with size validation
            const branch = extractSubtree(nodeIds, hyperedgeId);

            // Check for errors
            if (branch.error) {
                body.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                        <h3 style="color: #f59e0b; margin-bottom: 12px;">Cannot Share Selection</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 16px;">${branch.error}</p>
                        ${branch.suggestion ? `<p style="color: var(--text-secondary); font-size: 13px;">${branch.suggestion}</p>` : ''}
                    </div>
                `;
                modal.style.display = 'flex';
                return;
            }

            // Store for button handlers
            pendingShareBranch = branch;

            // Generate URL
            const shareURL = generateBranchURL(branch);
            const meta = branch._meta || {};

            // Build ancestry breadcrumb
            const breadcrumb = branch.ancestry.map(a =>
                `<span style="display: inline-flex; align-items: center; gap: 4px;">${a.icon || 'ðŸ“„'} ${a.name}</span>`
            ).join(' <span style="color: var(--text-secondary);">â€º</span> ');

            // Build node list
            const nodeList = branch.nodes.map(n => `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--card-bg); border-radius: 6px; margin-bottom: 6px;">
                    <span>${n.icon || 'ðŸ“„'}</span>
                    <span style="font-weight: 500;">${n.name}</span>
                    ${n.subItems && n.subItems.length > 0 ? `<span style="font-size: 11px; color: var(--text-secondary);">(+${countSubtreeNodes(n) - 1} children)</span>` : ''}
                </div>
            `).join('');

            body.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 12px; font-size: 14px;">
                        Share these nodes for collaboration. The recipient can edit and send back their changes.
                    </p>

                    <!-- Ancestry Breadcrumb -->
                    <div style="background: var(--card-bg-light); padding: 10px 14px; border-radius: 6px; margin-bottom: 16px; font-size: 13px; color: var(--text-secondary);">
                        <span style="font-weight: 600; margin-right: 8px;">ðŸ“ Location:</span>
                        ${breadcrumb}
                    </div>

                    <!-- Nodes being shared -->
                    <div style="margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            ðŸ“¦ Sharing ${branch.nodes.length} node${branch.nodes.length > 1 ? 's' : ''} (${meta.nodeCount} total with children):
                        </div>
                        <div style="max-height: 150px; overflow-y: auto; padding-right: 8px;">
                            ${nodeList}
                        </div>
                    </div>

                    <!-- Clickable Link Preview (hidden input for copying) -->
                    <input type="hidden" id="share-branch-url-input" value="${shareURL}">
                    <div style="background: var(--card-bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 12px;">
                        <div style="display: flex; gap: 12px; align-items: center; justify-content: space-between;">
                            <a href="${shareURL}" target="_blank" id="share-branch-link"
                               style="display: inline-flex; align-items: center; gap: 8px; background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 10px 16px; border-radius: 6px; text-decoration: none; font-weight: 600; font-size: 13px;">
                                ðŸ”— Click to Preview Shared Content
                            </a>
                            <span style="font-size: 12px; color: var(--text-secondary);">
                                ðŸ“Š ${meta.nodeCount} nodes â€¢ ðŸ“ ${Math.round(shareURL.length/1000)}KB
                                ${meta.sizeWarning ? ' â€¢ <span style="color: #f59e0b;">âš ï¸ Large</span>' : ''}
                            </span>
                        </div>
                    </div>

                    <!-- Workflow Instructions -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #10b981; margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 10px; display: flex; align-items: center; gap: 8px; color: #10b981;">
                            <span>ðŸ“‹</span> Collaboration Workflow
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 13px;">
                            <div style="background: var(--card-bg); padding: 12px; border-radius: 6px;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px;">ðŸ‘¤ You (Sender):</div>
                                <ol style="margin-left: 16px; color: var(--text-secondary); line-height: 1.6;">
                                    <li>Click <strong>"Open Email App"</strong> or <strong>"Copy Email"</strong></li>
                                    <li>Send the email to your collaborator</li>
                                    <li>Wait for their response email</li>
                                    <li>Use <strong>File â†’ Merge Branch</strong> to paste their link</li>
                                </ol>
                            </div>
                            <div style="background: var(--card-bg); padding: 12px; border-radius: 6px;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px;">ðŸ‘¥ Collaborator (Recipient):</div>
                                <ol style="margin-left: 16px; color: var(--text-secondary); line-height: 1.6;">
                                    <li>Click the link in your email</li>
                                    <li>Edit the shared nodes as needed</li>
                                    <li>Click <strong>"Share Back"</strong> button</li>
                                    <li>Send the new link back via email</li>
                                </ol>
                            </div>
                        </div>
                    </div>

                    <!-- Important Notes -->
                    <div style="background: rgba(99, 102, 241, 0.1); padding: 12px 15px; border-radius: 6px; border-left: 3px solid #6366f1; font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
                        <strong style="color: #6366f1;">ðŸ’¡ Tip:</strong> When you receive changes back, go to <strong>File â†’ Merge Branch</strong> and paste the URL from their email to integrate their edits into your project.
                    </div>
                    <div style="background: rgba(245, 158, 11, 0.1); padding: 12px 15px; border-radius: 6px; border-left: 3px solid #f59e0b; font-size: 13px; color: var(--text-secondary);">
                        <strong style="color: #f59e0b;">âš ï¸ Multiple collaborators:</strong> If sharing with multiple people, merge their responses <strong>one at a time</strong>. Each merge replaces the shared nodes entirely â€” later merges will overwrite earlier ones.
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Select URL for easy copying
            setTimeout(() => {
                const urlInput = document.getElementById('share-branch-url-input');
                if (urlInput) urlInput.select();
            }, 100);
        }

        /**
         * Generate mailto link for collaboration email
         * @param {object} branch - Branch token
         * @param {string} shareURL - Shareable URL
         * @returns {string} mailto: link
         */
        function generateCollaborationEmail(branch, shareURL) {
            const subject = encodeURIComponent(
                `TreeListy Collaboration: ${branch.sourceProjectName}`
            );
            // Clear instructions with numbered steps
            const body = encodeURIComponent(
                `Hi,\n\n` +
                `I'd like your input on part of my TreeListy project "${branch.sourceProjectName}".\n\n` +
                `WHAT TO DO:\n` +
                `1. Click this link to open the shared content:\n` +
                `   ${shareURL}\n\n` +
                `2. Make your edits to the nodes\n` +
                `3. Click the "Share Back" button (purple bar at top)\n` +
                `4. Send me the new link from your email\n\n` +
                `I'll merge your changes into my project.\n\n` +
                `Thanks!`
            );
            return `mailto:?subject=${subject}&body=${body}`;
        }

        /**
         * Copy rich HTML email to clipboard (for pasting into email clients)
         * @param {object} branch - Branch token
         * @param {string} shareURL - Shareable URL
         */
        async function copyRichEmailToClipboard(branch, shareURL) {
            const htmlContent = `
                <p>Hi,</p>
                <p>I'd like your input on part of my TreeListy project "<strong>${branch.sourceProjectName}</strong>".</p>
                <p>I'm sharing ${branch.nodes.length} node${branch.nodes.length > 1 ? 's' : ''} for you to review and edit.</p>
                <p style="margin: 20px 0;">
                    <a href="${shareURL}" style="display: inline-block; background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: bold;">
                        ðŸ¤ Click to View & Edit
                    </a>
                </p>
                <p><strong>What to do:</strong></p>
                <ol style="color: #666; line-height: 1.6;">
                    <li>Click the button above to open the shared content</li>
                    <li>Make your edits to the nodes</li>
                    <li>Click the <strong>"Share Back"</strong> button (purple bar at top)</li>
                    <li>Send me the new link from your email</li>
                </ol>
                <p>I'll merge your changes into my project. Thanks!</p>
            `;

            const plainText = `Hi,

I'd like your input on part of my TreeListy project "${branch.sourceProjectName}".

WHAT TO DO:
1. Click this link to open the shared content:
   ${shareURL}

2. Make your edits to the nodes
3. Click the "Share Back" button (purple bar at top)
4. Send me the new link from your email

I'll merge your changes into my project.

Thanks!`;

            try {
                // Try to copy as rich HTML (works in modern browsers)
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const plainBlob = new Blob([plainText], { type: 'text/plain' });

                await navigator.clipboard.write([
                    new ClipboardItem({
                        'text/html': blob,
                        'text/plain': plainBlob
                    })
                ]);
                return true;
            } catch (err) {
                console.log('Rich copy failed, falling back to plain text:', err);
                // Fallback to plain text
                try {
                    await navigator.clipboard.writeText(plainText);
                    return true;
                } catch (err2) {
                    console.error('Clipboard write failed:', err2);
                    return false;
                }
            }
        }

        // Storage for pending merge operation (must be declared before IIFE)
        let pendingMergeBranch = null;

        // Initialize Share Branch modal event handlers
        // Use immediate execution with DOM check for reliability
        (function initCollaborationHandlers() {
            // If DOM not ready, wait for it
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initCollaborationHandlers);
                return;
            }

            // Close button
            document.getElementById('share-branch-close')?.addEventListener('click', () => {
                document.getElementById('share-branch-modal').style.display = 'none';
                pendingShareBranch = null;
            });

            // Copy URL button
            document.getElementById('share-branch-copy')?.addEventListener('click', async () => {
                const urlInput = document.getElementById('share-branch-url-input');
                if (urlInput) {
                    try {
                        await navigator.clipboard.writeText(urlInput.value);

                        // Visual feedback
                        const btn = document.getElementById('share-branch-copy');
                        const originalText = btn.textContent;
                        btn.textContent = 'âœ… Copied!';
                        btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                        setTimeout(() => {
                            btn.textContent = originalText;
                            btn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy URL:', err);
                    }
                }
            });

            // Email button (opens email app)
            document.getElementById('share-branch-email')?.addEventListener('click', () => {
                if (pendingShareBranch) {
                    const shareURL = document.getElementById('share-branch-url-input')?.value;
                    const mailtoLink = generateCollaborationEmail(pendingShareBranch, shareURL);
                    window.location.href = mailtoLink;
                }
            });

            // Copy Email button (copies rich HTML email to clipboard)
            document.getElementById('share-branch-copy-email')?.addEventListener('click', async () => {
                if (pendingShareBranch) {
                    const shareURL = document.getElementById('share-branch-url-input')?.value;
                    const success = await copyRichEmailToClipboard(pendingShareBranch, shareURL);

                    const btn = document.getElementById('share-branch-copy-email');
                    if (success) {
                        const originalText = btn.textContent;
                        btn.textContent = 'âœ… Copied!';
                        btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                        setTimeout(() => {
                            btn.textContent = originalText;
                            btn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                        }, 2000);
                    } else {
                        btn.textContent = 'âŒ Failed';
                        setTimeout(() => {
                            btn.textContent = 'ðŸ“§ Copy Email';
                        }, 2000);
                    }
                }
            });

            // Close on backdrop click
            document.getElementById('share-branch-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'share-branch-modal') {
                    document.getElementById('share-branch-modal').style.display = 'none';
                    pendingShareBranch = null;
                }
            });

            // =========== MERGE MODAL HANDLERS ===========

            // Cancel merge
            document.getElementById('merge-branch-cancel')?.addEventListener('click', () => {
                document.getElementById('merge-branch-modal').style.display = 'none';
                pendingMergeBranch = null;
            });

            // Accept merge
            const acceptBtn = document.getElementById('merge-branch-accept');
            console.log('ðŸ”€ merge-branch-accept button found:', !!acceptBtn);
            if (acceptBtn) {
                acceptBtn.addEventListener('click', () => {
                    console.log('ðŸ”€ Accept merge clicked, pendingMergeBranch:', !!pendingMergeBranch);
                    if (pendingMergeBranch) {
                        performBranchMerge(pendingMergeBranch);
                    } else {
                        console.error('ðŸ”€ No pendingMergeBranch set!');
                    }
                });
            } else {
                console.error('ðŸ”€ merge-branch-accept button NOT FOUND in DOM!');
            }

            // Close on backdrop click
            document.getElementById('merge-branch-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'merge-branch-modal') {
                    document.getElementById('merge-branch-modal').style.display = 'none';
                    pendingMergeBranch = null;
                }
            });

            // =========== BRANCH EDIT BANNER HANDLERS ===========

            // Share Back button
            document.getElementById('branch-share-back-btn')?.addEventListener('click', () => {
                shareBackBranch();
            });

            // Exit branch editing mode
            document.getElementById('branch-exit-btn')?.addEventListener('click', () => {
                exitBranchEditMode();
            });

            // =========== PASTE BRANCH URL MODAL HANDLERS ===========

            // Open paste branch modal
            document.getElementById('merge-branch-btn')?.addEventListener('click', () => {
                document.getElementById('paste-branch-modal').style.display = 'flex';
                document.getElementById('paste-branch-url-input').value = '';
                document.getElementById('paste-branch-url-input').focus();
            });

            // Cancel paste branch
            document.getElementById('paste-branch-cancel')?.addEventListener('click', () => {
                document.getElementById('paste-branch-modal').style.display = 'none';
            });

            // Parse and merge pasted URL
            document.getElementById('paste-branch-merge')?.addEventListener('click', () => {
                const urlInput = document.getElementById('paste-branch-url-input');
                const url = urlInput.value.trim();

                if (!url) {
                    showToast('âŒ Please paste a URL first', 'error');
                    return;
                }

                // Extract branch parameter from URL
                let branchParam = null;
                try {
                    const urlObj = new URL(url);
                    branchParam = urlObj.searchParams.get('branch');
                } catch (e) {
                    // Maybe they just pasted the branch parameter directly
                    if (url.includes('branch=')) {
                        branchParam = url.split('branch=')[1].split('&')[0];
                    }
                }

                if (!branchParam) {
                    showToast('âŒ Invalid URL - no branch parameter found', 'error');
                    return;
                }

                // Close paste modal
                document.getElementById('paste-branch-modal').style.display = 'none';

                // Parse and show merge modal
                const branch = parseBranchFromURL(branchParam);
                if (!branch) {
                    showToast('âŒ Failed to parse branch data', 'error');
                    return;
                }

                // Show appropriate modal based on branch type
                if (branch.isResponse) {
                    showMergeBranchModal(branch);
                } else {
                    // Original share - ask if they want to edit or merge
                    if (isOriginalBranchCreator(branch)) {
                        showToast('â„¹ï¸ This is your own shared branch', 'warning');
                    } else {
                        enterBranchEditMode(branch);
                    }
                }
            });

            // Close paste modal on backdrop click
            document.getElementById('paste-branch-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'paste-branch-modal') {
                    document.getElementById('paste-branch-modal').style.display = 'none';
                }
            });

            console.log('ðŸ¤ Collaboration event handlers initialized');
        })();

        // =====================================================
        // WATCH MODE - Live Collaboration Sync
        // =====================================================
        (function initWatchMode() {
            let watchInterval = null;
            let lastFileHash = null;
            let changesDetected = 0;
            let watchCollaboratorName = '';
            let watchFilePath = '';

            // Calculate simple hash of tree for change detection
            function getTreeHash(tree) {
                const str = JSON.stringify(tree);
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash.toString(16);
            }

            // Note: Watch mode uses the global showToast() function defined elsewhere

            // Update the status panel
            function updateWatchStatus() {
                const lastCheckEl = document.getElementById('watch-last-check');
                const currentFileEl = document.getElementById('watch-current-file');
                const collaboratorEl = document.getElementById('watch-collaborator-display');
                const changesEl = document.getElementById('watch-changes-count');

                if (lastCheckEl) lastCheckEl.textContent = new Date().toLocaleTimeString();
                if (currentFileEl) currentFileEl.textContent = watchFilePath.length > 40 ? '...' + watchFilePath.slice(-40) : watchFilePath;
                if (collaboratorEl) collaboratorEl.textContent = watchCollaboratorName || 'Not set';
                if (changesEl) changesEl.textContent = changesDetected > 0 ? `âœ… ${changesDetected} change(s) synced` : '';
            }

            // Fetch and check for updates from the watched file
            async function checkForUpdates() {
                if (!watchFilePath) return;

                try {
                    // For local files, we need to use the File System Access API
                    // For URLs, we can fetch directly
                    let newTree = null;

                    if (watchFilePath.startsWith('http')) {
                        // URL-based file (e.g., raw GitHub, public JSON endpoint)
                        const response = await fetch(watchFilePath + '?t=' + Date.now(), {
                            cache: 'no-store'
                        });
                        if (!response.ok) throw new Error('Failed to fetch');
                        newTree = await response.json();
                    } else {
                        // Local file - try to read using stored file handle
                        if (window.watchFileHandle) {
                            const file = await window.watchFileHandle.getFile();
                            const text = await file.text();
                            newTree = JSON.parse(text);
                        } else {
                            // No file handle stored - need to re-select
                            console.log('âš ï¸ No file handle - need to re-select file');
                            return;
                        }
                    }

                    // Calculate hash of new tree
                    const newHash = getTreeHash(newTree);

                    // Check if tree changed
                    if (lastFileHash && newHash !== lastFileHash) {
                        console.log('ðŸ‘ï¸ Change detected! Old hash:', lastFileHash, 'New hash:', newHash);
                        changesDetected++;

                        // Find who made the change
                        const lastContributor = findLastContributor(newTree);

                        // Only apply if someone else made the change
                        if (lastContributor && lastContributor !== watchCollaboratorName) {
                            // Apply the update
                            capexTree = newTree;
                            render();
                            if (viewMode === 'canvas') renderCanvas();

                            showToast(`ðŸ‘¥ ${lastContributor} made changes - synced!`, 'success');

                            // Flash the watch button to indicate sync
                            const btn = document.getElementById('watch-mode-btn');
                            if (btn) {
                                btn.style.animation = 'none';
                                btn.offsetHeight; // Trigger reflow
                                btn.style.animation = 'watchSync 0.5s ease-in-out 3';
                            }
                        } else {
                            // Our own save - just update hash
                            console.log('ðŸ‘ï¸ Self-save detected, skipping reload');
                        }
                    }

                    lastFileHash = newHash;
                    updateWatchStatus();

                } catch (error) {
                    console.error('ðŸ‘ï¸ Watch mode error:', error);
                    // Don't spam toasts, just log
                }
            }

            // Find the most recent contributor in the tree
            function findLastContributor(tree) {
                let latestContributor = null;
                let latestTime = 0;

                function scanNode(node) {
                    if (node.contributorTimestamp) {
                        const time = new Date(node.contributorTimestamp).getTime();
                        if (time > latestTime) {
                            latestTime = time;
                            latestContributor = node.contributor;
                        }
                    }
                    if (node.children) node.children.forEach(scanNode);
                    if (node.items) node.items.forEach(scanNode);
                    if (node.subItems) node.subItems.forEach(scanNode);
                }

                scanNode(tree);
                return latestContributor;
            }

            // Start watching
            async function startWatching() {
                const nameInput = document.getElementById('watch-collaborator-name');
                const pathInput = document.getElementById('watch-file-path');
                const intervalSelect = document.getElementById('watch-interval');

                watchCollaboratorName = nameInput?.value?.trim() || 'Anonymous';
                watchFilePath = pathInput?.value?.trim() || '';
                const interval = parseInt(intervalSelect?.value) || 10000;

                if (!watchFilePath) {
                    // No path entered - open file picker for local file
                    try {
                        const [fileHandle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'JSON Files',
                                accept: { 'application/json': ['.json'] }
                            }]
                        });
                        window.watchFileHandle = fileHandle;
                        watchFilePath = fileHandle.name;
                        pathInput.value = fileHandle.name;
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            showToast('âŒ Could not open file picker', 'error');
                        }
                        return;
                    }
                }

                // Initialize hash from current tree
                lastFileHash = getTreeHash(capexTree);
                changesDetected = 0;

                // Start polling
                watchInterval = setInterval(checkForUpdates, interval);

                // Update UI
                document.getElementById('watch-status-panel').style.display = 'block';
                document.getElementById('watch-mode-start').style.display = 'none';
                document.getElementById('watch-mode-stop').style.display = 'inline-flex';

                // Update button appearance
                const btn = document.getElementById('watch-mode-btn');
                if (btn) {
                    btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                    btn.dataset.icon = 'ðŸ‘ï¸';
                }

                updateWatchStatus();
                showToast(`ðŸ‘ï¸ Watching as "${watchCollaboratorName}"`, 'success');

                console.log('ðŸ‘ï¸ Watch Mode started:', { collaborator: watchCollaboratorName, file: watchFilePath, interval });
            }

            // Stop watching
            function stopWatching() {
                if (watchInterval) {
                    clearInterval(watchInterval);
                    watchInterval = null;
                }

                window.watchFileHandle = null;
                lastFileHash = null;

                // Update UI
                document.getElementById('watch-status-panel').style.display = 'none';
                document.getElementById('watch-mode-start').style.display = 'inline-flex';
                document.getElementById('watch-mode-stop').style.display = 'none';

                // Reset button appearance
                const btn = document.getElementById('watch-mode-btn');
                if (btn) {
                    btn.style.background = '';
                }

                showToast('â¹ï¸ Watch Mode stopped', 'info');
                console.log('ðŸ‘ï¸ Watch Mode stopped');
            }

            // Event listeners
            document.getElementById('watch-mode-btn')?.addEventListener('click', () => {
                document.getElementById('watch-mode-modal').style.display = 'flex';
                // Build 262: Populate team member buttons
                populateWatchModeTeamButtons();
            });

            document.getElementById('watch-mode-close')?.addEventListener('click', () => {
                document.getElementById('watch-mode-modal').style.display = 'none';
            });

            document.getElementById('watch-mode-start')?.addEventListener('click', startWatching);
            document.getElementById('watch-mode-stop')?.addEventListener('click', stopWatching);

            // Close on backdrop click
            document.getElementById('watch-mode-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'watch-mode-modal') {
                    document.getElementById('watch-mode-modal').style.display = 'none';
                }
            });

            // Add sync animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes watchSync {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.1); box-shadow: 0 0 20px rgba(16, 185, 129, 0.5); }
                }
            `;
            document.head.appendChild(style);

            // Expose for auto-save integration
            window.watchModeActive = () => watchInterval !== null;
            window.notifyWatchSave = () => {
                // Update hash after local save so we don't trigger self-reload
                lastFileHash = getTreeHash(capexTree);
            };

            console.log('ðŸ‘ï¸ Watch Mode initialized');
        })();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LIVE COLLABORATION SESSION MANAGEMENT (Build 222)
        // Host can share API keys with collaborators securely
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        (function initLiveCollabSessions() {
            // Session state
            let activeHostSession = null; // { token, expiresAt }
            let activeGuestSession = null; // { token, hostName, expiresAt }
            let hostImportedGdriveId = null; // Google Drive file ID if host imported from there
            let sessionStatusInterval = null;

            // Expose session token for AI calls
            window.getCollabSessionToken = () => activeGuestSession?.token || null;
            window.getCollabHostName = () => activeGuestSession?.hostName || null;
            window.isCollabGuest = () => activeGuestSession !== null;

            // Start a host session
            window.startHostSession = async function() {
                // Support both old Watch Mode and new Live Sync modal element IDs
                const btn = document.getElementById('start-api-session-btn') || document.getElementById('start-host-session-btn');
                if (!btn) return;

                const originalText = btn.innerHTML;
                btn.innerHTML = 'â³ Creating session...';
                btn.disabled = true;

                try {
                    // Get current API keys from storage
                    const apiKeys = {};

                    const anthropicKey = localStorage.getItem('anthropicApiKey');
                    const geminiKey = localStorage.getItem('geminiApiKey');
                    const openaiKey = localStorage.getItem('openaiApiKey');

                    if (anthropicKey) apiKeys.anthropic = anthropicKey;
                    if (geminiKey) apiKeys.gemini = geminiKey;
                    if (openaiKey) apiKeys.openai = openaiKey;

                    if (Object.keys(apiKeys).length === 0) {
                        showToast('âŒ No API keys configured. Set up your keys first (ðŸ”‘ button).', 'error');
                        btn.innerHTML = originalText;
                        btn.disabled = false;
                        return;
                    }

                    // Get host name from team or default
                    const team = typeof getProjectTeam === 'function' ? getProjectTeam() : null;
                    const hostName = team?.host?.name || 'Host';

                    // Create session on server
                    const response = await fetch('/.netlify/functions/collab-session', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'create',
                            hostName: hostName,
                            apiKeys: apiKeys
                        })
                    });

                    const result = await response.json();

                    if (!response.ok) {
                        throw new Error(result.error || 'Failed to create session');
                    }

                    // Store session
                    activeHostSession = {
                        token: result.sessionToken,
                        expiresAt: result.expiresAt
                    };

                    // Generate shareable link - include room ID if we're in a Firebase sync room
                    // BUILD 266: Put room first, then session for cleaner URLs
                    let shareLink = `${window.location.origin}${window.location.pathname}`;
                    const params = [];

                    // Include Firebase room ID if active
                    if (window.firebaseSyncState?.roomId) {
                        params.push(`room=${window.firebaseSyncState.roomId}`);
                        console.log('ðŸ”¥ Firebase room ID included in session link:', window.firebaseSyncState.roomId);
                    }

                    // Add session token
                    params.push(`session=${result.sessionToken}`);
                    shareLink += '?' + params.join('&');

                    // BUILD 266: Update the MAIN invite link in the Live Sync modal
                    const mainInviteLink = document.getElementById('sync-invite-link');
                    if (mainInviteLink) {
                        mainInviteLink.value = shareLink;
                    }

                    // Also update legacy elements for backwards compat
                    const legacyShareLink = document.getElementById('api-session-share-link') || document.getElementById('session-share-link');
                    if (legacyShareLink) legacyShareLink.value = shareLink;

                    // Update UI - support both element ID schemes
                    const startSection = document.getElementById('api-session-start') || document.getElementById('host-session-start');
                    const activeSection = document.getElementById('api-session-active') || document.getElementById('host-session-active');
                    if (startSection) startSection.style.display = 'none';
                    if (activeSection) activeSection.style.display = 'block';

                    updateSessionStatus();

                    // Start status polling
                    sessionStatusInterval = setInterval(updateSessionStatus, 30000);

                    showToast(`ðŸ”‘ API keys enabled! Guests will use your keys.`, 'success');
                    console.log('ðŸ”‘ Host session created:', result.sessionToken.substring(0, 8) + '...');

                } catch (error) {
                    console.error('Failed to create session:', error);
                    showToast(`âŒ ${error.message}`, 'error');
                } finally {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
            };

            // End host session
            window.endHostSession = async function() {
                if (!activeHostSession) return;

                try {
                    await fetch('/.netlify/functions/collab-session', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'revoke',
                            sessionToken: activeHostSession.token
                        })
                    });
                } catch (error) {
                    console.error('Failed to revoke session:', error);
                }

                // Clear session
                if (sessionStatusInterval) {
                    clearInterval(sessionStatusInterval);
                    sessionStatusInterval = null;
                }

                activeHostSession = null;

                // BUILD 266: Restore invite link to room-only (no session token)
                // BUILD 414: Include view state
                if (window.firebaseSyncState?.roomId) {
                    const mainInviteLink = document.getElementById('sync-invite-link');
                    if (mainInviteLink) {
                        mainInviteLink.value = window.generateShareURL ?
                            window.generateShareURL({ room: window.firebaseSyncState.roomId }) :
                            `${window.location.origin}${window.location.pathname}?room=${window.firebaseSyncState.roomId}`;
                    }
                }

                // Update UI - support both element ID schemes
                const startSection = document.getElementById('api-session-start') || document.getElementById('host-session-start');
                const activeSection = document.getElementById('api-session-active') || document.getElementById('host-session-active');
                if (startSection) startSection.style.display = 'block';
                if (activeSection) activeSection.style.display = 'none';

                showToast('â¹ï¸ API key sharing disabled', 'info');
                console.log('ðŸ”‘ Host session ended');
            };

            // Update session status display
            async function updateSessionStatus() {
                if (!activeHostSession) return;

                try {
                    const response = await fetch('/.netlify/functions/collab-session', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'status',
                            sessionToken: activeHostSession.token
                        })
                    });

                    const result = await response.json();

                    if (!result.active) {
                        // Session expired
                        endHostSession();
                        showToast('â° API key session expired', 'info');
                        return;
                    }

                    // Update display - support both element ID schemes
                    const expiresAt = new Date(result.expiresAt);
                    const expiresEl = document.getElementById('api-session-expires-at') || document.getElementById('session-expires-at');
                    const guestCountEl = document.getElementById('api-session-guest-count') || document.getElementById('session-guest-count');
                    if (expiresEl) expiresEl.textContent = expiresAt.toLocaleTimeString();
                    if (guestCountEl) guestCountEl.textContent = result.guestCount || 0;

                } catch (error) {
                    console.error('Failed to get session status:', error);
                }
            }

            // Copy API session link (new Live Sync modal)
            window.copyApiSessionLink = function() {
                const linkInput = document.getElementById('api-session-share-link');
                if (linkInput) {
                    linkInput.select();
                    document.execCommand('copy');
                    showToast('ðŸ“‹ Link copied! Guests will join room + use your API keys.', 'success');
                }
            };

            // Copy session link (legacy Watch Mode)
            window.copySessionLink = function() {
                const linkInput = document.getElementById('session-share-link');
                if (linkInput) {
                    linkInput.select();
                    document.execCommand('copy');
                    showToast('ðŸ“‹ Session link copied!', 'success');
                }
            };

            // Join as guest (called from URL parameter)
            window.joinCollabSession = async function(sessionToken) {
                try {
                    const response = await fetch('/.netlify/functions/collab-session', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'validate',
                            sessionToken: sessionToken
                        })
                    });

                    const result = await response.json();

                    if (!response.ok) {
                        throw new Error(result.error || 'Invalid session');
                    }

                    // Store guest session
                    activeGuestSession = {
                        token: sessionToken,
                        hostName: result.hostName,
                        expiresAt: result.expiresAt
                    };

                    // Update UI - support both old Watch Mode and new Live Sync modal
                    // Hide host section, show guest section in Watch Mode modal
                    const hostSection = document.getElementById('host-session-section');
                    const guestSection = document.getElementById('guest-session-section');
                    if (hostSection) hostSection.style.display = 'none';
                    if (guestSection) {
                        guestSection.style.display = 'block';
                        document.getElementById('guest-session-host').textContent = result.hostName;
                        document.getElementById('guest-session-expires').textContent = new Date(result.expiresAt).toLocaleTimeString();
                    }

                    // Update Live Sync modal guest display
                    const apiStartSection = document.getElementById('api-session-start');
                    const apiGuestSection = document.getElementById('api-guest-session');
                    if (apiStartSection) apiStartSection.style.display = 'none';
                    if (apiGuestSection) {
                        apiGuestSection.style.display = 'block';
                        const hostNameEl = document.getElementById('api-guest-host-name');
                        const expiresEl = document.getElementById('api-guest-expires');
                        if (hostNameEl) hostNameEl.textContent = result.hostName;
                        if (expiresEl) expiresEl.textContent = new Date(result.expiresAt).toLocaleTimeString();
                    }

                    // Show indicator in main UI
                    showGuestSessionIndicator(result.hostName);

                    showToast(`ðŸŽŸï¸ Using ${result.hostName}'s API keys!`, 'success');
                    console.log('ðŸŽŸï¸ Joined session as guest, host:', result.hostName);

                    return true;

                } catch (error) {
                    console.error('Failed to join session:', error);
                    showToast(`âŒ ${error.message}`, 'error');
                    return false;
                }
            };

            // Show guest indicator in main UI
            function showGuestSessionIndicator(hostName) {
                // Add indicator near API key button
                let indicator = document.getElementById('guest-session-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'guest-session-indicator';
                    indicator.style.cssText = `
                        position: fixed;
                        top: 12px;
                        right: 200px;
                        background: linear-gradient(135deg, #6366f1, #8b5cf6);
                        color: white;
                        padding: 6px 12px;
                        border-radius: 20px;
                        font-size: 12px;
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        z-index: 1000;
                        box-shadow: 0 2px 10px rgba(99, 102, 241, 0.3);
                    `;
                    document.body.appendChild(indicator);
                }
                indicator.innerHTML = `ðŸŽŸï¸ Using ${hostName}'s keys`;
                indicator.style.display = 'flex';
            }

            // Check for session parameter on load
            const urlParams = new URLSearchParams(window.location.search);
            const sessionParam = urlParams.get('session');

            if (sessionParam) {
                // Join session after app is ready
                // Note: gdrive parameter is handled separately by existing Google Drive loader
                // which runs at the same time - no need to duplicate tree loading here
                setTimeout(() => {
                    joinCollabSession(sessionParam);
                }, 1500); // Slightly delayed to let gdrive load first
            }

            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                if (activeHostSession) {
                    // Note: This is best-effort, may not complete
                    navigator.sendBeacon('/.netlify/functions/collab-session', JSON.stringify({
                        action: 'revoke',
                        sessionToken: activeHostSession.token
                    }));
                }
            });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HOST IMPORT FROM URL - Load tree from Google Drive or any JSON URL
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            window.hostImportFromURL = async function() {
                const urlInput = document.getElementById('host-import-url');
                let url = urlInput?.value?.trim();

                if (!url) {
                    showToast('ðŸ“¥ Please paste a Google Drive or JSON URL', 'info');
                    return;
                }

                // Check if it's a Google Drive link
                let isGoogleDrive = false;
                let gdriveFileId = null;

                if (url.includes('drive.google.com')) {
                    isGoogleDrive = true;

                    // Format: /file/d/FILE_ID/view
                    const fileMatch = url.match(/\/file\/d\/([^\/]+)/);
                    if (fileMatch) gdriveFileId = fileMatch[1];

                    // Format: id=FILE_ID
                    const idMatch = url.match(/id=([^&]+)/);
                    if (idMatch) gdriveFileId = idMatch[1];

                    // Format: /open?id=FILE_ID
                    const openMatch = url.match(/open\?id=([^&]+)/);
                    if (openMatch) gdriveFileId = openMatch[1];

                    if (gdriveFileId) {
                        hostImportedGdriveId = gdriveFileId;
                        console.log('ðŸ“¥ Google Drive file ID:', gdriveFileId);
                    }
                }

                // Convert Dropbox share links to direct download
                if (url.includes('dropbox.com')) {
                    url = url.replace('www.dropbox.com', 'dl.dropboxusercontent.com')
                             .replace('?dl=0', '').replace('?dl=1', '');
                    console.log('ðŸ“¥ Converted Dropbox URL');
                }

                showToast('ðŸ“¥ Loading tree from URL...', 'info');

                try {
                    let treeData;

                    if (isGoogleDrive && gdriveFileId) {
                        // Use our proxy for Google Drive to avoid CORS
                        const proxyUrl = `/.netlify/functions/gdrive-proxy?id=${gdriveFileId}`;
                        const response = await fetch(proxyUrl);
                        const result = await response.json();

                        if (!response.ok || result.error) {
                            throw new Error(result.error || 'Failed to fetch from Google Drive');
                        }
                        treeData = result;
                    } else {
                        // Direct fetch for other URLs
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
                        }

                        const text = await response.text();
                        try {
                            treeData = JSON.parse(text);
                        } catch (parseError) {
                            throw new Error('Invalid JSON file. Please check the URL points to a valid TreeListy JSON.');
                        }
                    }

                    // Load the tree into TreeListy
                    if (typeof loadTree === 'function') {
                        loadTree(treeData);
                        showToast(`âœ… Loaded: ${treeData.name || 'Imported tree'}`, 'success');
                        console.log('ðŸ“¥ Tree loaded from URL:', treeData.name);

                        // Update the tree name display
                        const treeNameDisplay = document.getElementById('session-tree-name');
                        if (treeNameDisplay) {
                            treeNameDisplay.textContent = treeData.name || 'Imported tree';
                        }
                    } else {
                        // Fallback - set capexTree directly
                        capexTree = treeData;
                        renderTree();
                        showToast(`âœ… Loaded: ${treeData.name || 'Imported tree'}`, 'success');
                    }

                    // Clear the input
                    urlInput.value = '';

                } catch (error) {
                    console.error('Failed to import from URL:', error);
                    showToast(`âŒ Import failed: ${error.message}`, 'error');
                }
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // EMAIL INVITATION FUNCTIONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Generate invitation email content
            function generateInviteEmail() {
                const hostName = document.getElementById('watch-collaborator-name')?.value?.trim() || 'Your collaborator';
                const sessionLink = document.getElementById('session-share-link')?.value || '';
                const treeName = capexTree?.name || 'a TreeListy project';
                const expiresAt = document.getElementById('session-expires-at')?.textContent || '4 hours';
                const hasGdrive = hostImportedGdriveId !== null;

                const subject = `ðŸŒ³ Join my TreeListy collaboration session - ${treeName}`;

                let body = `Hi!

${hostName} has invited you to collaborate on "${treeName}" in TreeListy.

ðŸ”— Click here to join:
${sessionLink}

âœ¨ What you get:
â€¢ Full access to AI features (using ${hostName}'s API keys)
â€¢ The project "${treeName}" will load automatically
â€¢ No API key setup required on your end

â° Session expires at: ${expiresAt}

Just click the link above to join instantly!`;

                if (!hasGdrive) {
                    body += `

ðŸ“ Note: If the project doesn't load, ask ${hostName} to share the Google Drive link separately.`;
                }

                body += `

---
TreeListy - Universal Project Decomposition
https://treelisty.netlify.app`;

                return { subject, body };
            }

            // Copy email text to clipboard
            window.copySessionInviteEmail = function() {
                const { subject, body } = generateInviteEmail();
                const fullText = `Subject: ${subject}\n\n${body}`;

                navigator.clipboard.writeText(fullText).then(() => {
                    showToast('ðŸ“‹ Email text copied!', 'success');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    showToast('âŒ Failed to copy', 'error');
                });
            };

            // Open mailto link
            window.openMailtoInvite = function() {
                const { subject, body } = generateInviteEmail();
                const mailto = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                window.open(mailto, '_blank');
            };

            // Send invite via email input
            window.sendSessionInvite = function() {
                const emailInput = document.getElementById('invite-email-input');
                const email = emailInput?.value?.trim();

                if (!email || !email.includes('@')) {
                    showToast('ðŸ“§ Please enter a valid email address', 'error');
                    return;
                }

                const { subject, body } = generateInviteEmail();
                const mailto = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                window.open(mailto, '_blank');

                // Clear input and show success
                emailInput.value = '';
                showToast(`ðŸ“§ Opening email to ${email}...`, 'success');
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ASYNC SHARE FUNCTIONS - Share Google Drive link (no API keys)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            let asyncGdriveFileId = null;

            // Generate TreeListy link from Google Drive URL
            window.generateAsyncShareLink = function() {
                const urlInput = document.getElementById('async-gdrive-url');
                const url = urlInput?.value?.trim();

                if (!url) {
                    showToast('â˜ï¸ Please paste a Google Drive share link', 'info');
                    return;
                }

                // Extract file ID from Google Drive URL
                let fileId = null;

                // Format: /file/d/FILE_ID/view
                const fileMatch = url.match(/\/file\/d\/([^\/]+)/);
                if (fileMatch) fileId = fileMatch[1];

                // Format: id=FILE_ID
                const idMatch = url.match(/id=([^&]+)/);
                if (idMatch) fileId = idMatch[1];

                // Format: /open?id=FILE_ID
                const openMatch = url.match(/open\?id=([^&]+)/);
                if (openMatch) fileId = openMatch[1];

                if (!fileId) {
                    showToast('âŒ Could not find file ID in URL. Please use a Google Drive share link.', 'error');
                    return;
                }

                asyncGdriveFileId = fileId;

                // Generate TreeListy link
                const shareLink = `${window.location.origin}${window.location.pathname}?gdrive=${fileId}`;
                document.getElementById('async-share-link').value = shareLink;
                document.getElementById('async-share-result').style.display = 'block';

                showToast('ðŸ”— TreeListy link generated!', 'success');
                console.log('ðŸ“§ Async share link created for file:', fileId);
            };

            // Copy async share link
            window.copyAsyncShareLink = function() {
                const link = document.getElementById('async-share-link')?.value;
                if (link) {
                    navigator.clipboard.writeText(link).then(() => {
                        showToast('ðŸ“‹ Link copied!', 'success');
                    });
                }
            };

            // Generate async invite email content
            function generateAsyncInviteEmail() {
                const hostName = document.getElementById('watch-collaborator-name')?.value?.trim() || 'Your collaborator';
                const shareLink = document.getElementById('async-share-link')?.value || '';
                const treeName = capexTree?.name || 'a TreeListy project';

                const subject = `ðŸŒ³ Collaborate on "${treeName}" in TreeListy`;

                const body = `Hi!

${hostName} has shared "${treeName}" with you in TreeListy.

ðŸ”— Click here to open it:
${shareLink}

ðŸ“ How async collaboration works:
1. Click the link above to open the tree in TreeListy
2. Make your edits and save to your own Google Drive
3. Share your updated link back when ready

ðŸ’¡ You'll need your own API key for AI features, or ask ${hostName} to start a Live Session if they want to share their keys.

---
TreeListy - Universal Project Decomposition
https://treelisty.netlify.app`;

                return { subject, body };
            }

            // Send async invite email
            window.sendAsyncInviteEmail = function() {
                const { subject, body } = generateAsyncInviteEmail();
                const mailto = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                window.open(mailto, '_blank');
            };

            // Copy async invite email text
            window.copyAsyncInviteEmail = function() {
                const { subject, body } = generateAsyncInviteEmail();
                const fullText = `Subject: ${subject}\n\n${body}`;

                navigator.clipboard.writeText(fullText).then(() => {
                    showToast('ðŸ“‹ Email text copied!', 'success');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    showToast('âŒ Failed to copy', 'error');
                });
            };

            console.log('ðŸ”‘ Live Collab Sessions initialized');
            console.log('ðŸ“§ Async Share initialized');
        })();

        // =============================================================================
        // FIREBASE LIVE SYNC (Build 231)
        // =============================================================================
        (function() {
            'use strict';

            // Firebase sync state
            let firebaseSyncState = {
                isConnected: false,
                roomId: null,
                userId: null,
                unsubscribe: null,
                lastSyncTimestamp: null,
                isSyncing: false,
                ignoreNextUpdate: false,  // Prevent echo when we push our own changes
                // BUILD 256: Track collaborator names for undo history
                collaboratorNames: {},  // userId -> display name
                myDisplayName: null,    // This user's display name
                lastEditor: null        // Who made the last edit
            };

            // Generate a random room ID
            function generateRoomId() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // No confusing chars (0/O, 1/I/L)
                let id = '';
                for (let i = 0; i < 6; i++) {
                    id += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return id;
            }

            // Update UI based on sync state
            function updateSyncUI() {
                const startSection = document.getElementById('sync-start-section');
                const activeSection = document.getElementById('sync-active-section');
                const syncBtn = document.getElementById('live-sync-btn');

                // Build 265: Also update legacy hidden elements for backwards compat
                const statusIndicator = document.getElementById('sync-status-indicator');
                const statusText = document.getElementById('sync-status-text');
                const userIdSection = document.getElementById('sync-user-id');
                const userIdValue = document.getElementById('sync-user-id-value');

                if (firebaseSyncState.isConnected && firebaseSyncState.roomId) {
                    // Connected to a room
                    startSection.style.display = 'none';
                    activeSection.style.display = 'block';

                    // Update room ID displays
                    document.getElementById('active-room-id').value = firebaseSyncState.roomId;
                    const roomIdDisplay = document.getElementById('active-room-id-display');
                    if (roomIdDisplay) roomIdDisplay.textContent = firebaseSyncState.roomId;

                    // Update invite link
                    const inviteLinkEl = document.getElementById('sync-invite-link');
                    if (inviteLinkEl && !inviteLinkEl.value) {
                        inviteLinkEl.value = `${window.location.origin}${window.location.pathname}?room=${firebaseSyncState.roomId}`;
                    }

                    // Update header button style
                    syncBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                    syncBtn.title = 'ðŸ”¥ Live Session Active - ' + firebaseSyncState.roomId;

                    // Legacy elements
                    if (statusIndicator) statusIndicator.style.background = '#10b981';
                    if (statusText) { statusText.textContent = 'Connected'; statusText.style.color = '#10b981'; }
                    if (userIdSection) userIdSection.style.display = 'block';
                    if (userIdValue) userIdValue.textContent = firebaseSyncState.userId?.substring(0, 8) + '...';
                } else {
                    // Not connected
                    startSection.style.display = 'block';
                    activeSection.style.display = 'none';
                    syncBtn.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
                    syncBtn.title = 'ðŸ”„ Live Collaboration';

                    // Reset create button
                    const createBtn = document.getElementById('create-sync-room-btn');
                    if (createBtn) {
                        createBtn.innerHTML = 'ðŸš€ Start Live Session';
                        createBtn.disabled = false;
                    }

                    // Legacy elements
                    if (statusIndicator) statusIndicator.style.background = '#6b7280';
                    if (statusText) { statusText.textContent = 'Not Connected'; statusText.style.color = 'var(--text-secondary)'; }
                    if (userIdSection) userIdSection.style.display = 'none';
                }
            }

            // Initialize Firebase auth
            async function initFirebaseAuth() {
                console.log('ðŸ”¥ initFirebaseAuth called, firebaseReady:', window.firebaseReady);

                // Wait for Firebase to be ready
                let attempts = 0;
                while (!window.firebaseReady && attempts < 50) {
                    await new Promise(r => setTimeout(r, 100));
                    attempts++;
                    if (attempts % 10 === 0) {
                        console.log('ðŸ”¥ Waiting for Firebase...', attempts);
                    }
                }

                if (!window.firebaseReady) {
                    console.error('ðŸ”¥ Firebase not ready after 5 seconds');
                    showToast('âŒ Firebase failed to load. Check console.', 'error');
                    return false;
                }

                console.log('ðŸ”¥ Firebase ready, signing in anonymously...');
                console.log('ðŸ”¥ firebaseAuth:', window.firebaseAuth);
                console.log('ðŸ”¥ firebaseSignInAnonymously:', typeof window.firebaseSignInAnonymously);

                try {
                    // Sign in anonymously
                    const result = await window.firebaseSignInAnonymously(window.firebaseAuth);
                    firebaseSyncState.userId = result.user.uid;
                    console.log('ðŸ”¥ Firebase anonymous auth successful:', firebaseSyncState.userId);
                    updateSyncUI();
                    return true;
                } catch (error) {
                    console.error('ðŸ”¥ Firebase auth error:', error);
                    showToast('âŒ Firebase auth failed: ' + error.message, 'error');
                    return false;
                }
            }

            // Create a new sync room
            let isCreatingRoom = false; // BUILD 267: Prevent double creation
            async function createSyncRoom() {
                console.log('ðŸ”¥ createSyncRoom called');

                // BUILD 267: Prevent double-click creating multiple rooms
                if (isCreatingRoom) {
                    console.log('ðŸ”¥ Already creating room, ignoring duplicate call');
                    return;
                }
                if (firebaseSyncState.isConnected && firebaseSyncState.roomId) {
                    console.log('ðŸ”¥ Already connected to room:', firebaseSyncState.roomId);
                    return;
                }
                isCreatingRoom = true;

                const btn = document.getElementById('create-sync-room-btn');
                if (btn) {
                    btn.innerHTML = 'â³ Creating...';
                    btn.disabled = true;
                }

                // Check if Firebase is ready
                if (!window.firebaseReady) {
                    console.error('ðŸ”¥ Firebase not ready yet');
                    showToast('â³ Firebase loading, please try again...', 'warning');
                    if (btn) { btn.innerHTML = 'ðŸš€ Start Live Session'; btn.disabled = false; }
                    isCreatingRoom = false;
                    return;
                }

                if (!firebaseSyncState.userId) {
                    console.log('ðŸ”¥ No user ID, authenticating...');
                    const authed = await initFirebaseAuth();
                    if (!authed) {
                        console.error('ðŸ”¥ Auth failed');
                        if (btn) { btn.innerHTML = 'ðŸš€ Start Live Session'; btn.disabled = false; }
                        isCreatingRoom = false;
                        return;
                    }
                }

                const roomId = generateRoomId();
                firebaseSyncState.roomId = roomId;
                console.log('ðŸ”¥ Creating room:', roomId);

                try {
                    // Create the room document with current tree data
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', roomId);
                    console.log('ðŸ”¥ Got room ref, setting doc...');

                    // BUILD 270: Include host in connectedUsers from the start
                    const initialConnectedUsers = {};
                    initialConnectedUsers[firebaseSyncState.userId] = {
                        name: firebaseSyncState.myDisplayName || 'Host',
                        joinedAt: Date.now(),
                        isHost: true
                    };

                    await window.firebaseSetDoc(roomRef, {
                        createdBy: firebaseSyncState.userId,
                        createdAt: window.firebaseServerTimestamp(),
                        lastUpdatedBy: firebaseSyncState.userId,
                        lastUpdatedAt: window.firebaseServerTimestamp(),
                        treeData: JSON.stringify(capexTree),
                        pattern: currentPattern,
                        projectName: capexTree?.name || 'Untitled',
                        // Build 265: Add chat messages array
                        chatMessages: [],
                        // Build 270: Include host in connected users
                        connectedUsers: initialConnectedUsers
                    });

                    console.log('ðŸ”¥ Room created:', roomId);

                    // Subscribe to changes
                    subscribeToRoom(roomId);
                    firebaseSyncState.isConnected = true;

                    // BUILD 268: Mark as host for floating chat
                    floatingChatState.isHost = true;
                    floatingChatState.previousUserCount = 1; // Reset counter

                    // Generate invite link with view state (BUILD 414)
                    const inviteLink = window.generateShareURL ?
                        window.generateShareURL({ room: roomId }) :
                        `${window.location.origin}${window.location.pathname}?room=${roomId}`;
                    document.getElementById('sync-invite-link').value = inviteLink;
                    document.getElementById('active-room-id-display').textContent = roomId;
                    document.getElementById('active-room-id').value = roomId;

                    // Update UI
                    updateSyncUI();

                    // Copy link to clipboard automatically
                    try {
                        await navigator.clipboard.writeText(inviteLink);
                        showToast('ðŸ”¥ Session started! Invite link copied to clipboard.', 'success');
                    } catch (e) {
                        showToast('ðŸ”¥ Session started! Room: ' + roomId, 'success');
                    }

                } catch (error) {
                    console.error('ðŸ”¥ Failed to create room:', error);
                    showToast('âŒ Failed to create room: ' + error.message, 'error');
                    firebaseSyncState.roomId = null;
                    if (btn) { btn.innerHTML = 'ðŸš€ Start Live Session'; btn.disabled = false; }
                } finally {
                    isCreatingRoom = false; // BUILD 267: Reset flag
                }
            }

            // Join an existing room
            async function joinSyncRoom(roomId) {
                if (!firebaseSyncState.userId) {
                    const authed = await initFirebaseAuth();
                    if (!authed) return;
                }

                roomId = roomId.toUpperCase().trim();
                if (!roomId || roomId.length < 4) {
                    showToast('âŒ Invalid room ID', 'error');
                    return;
                }

                try {
                    // Check if room exists
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', roomId);
                    const roomSnap = await window.firebaseGetDoc(roomRef);

                    if (!roomSnap.exists()) {
                        showToast('âŒ Room not found: ' + roomId, 'error');
                        return;
                    }

                    const roomData = roomSnap.data();
                    console.log('ðŸ”¥ Joining room:', roomId, roomData);

                    // Load the tree data from the room
                    if (roomData.treeData) {
                        const treeData = JSON.parse(roomData.treeData);

                        // Store room ID before reload
                        localStorage.setItem('firebase-pending-room', roomId);
                        localStorage.setItem('firebase-pending-tree', roomData.treeData);
                        if (roomData.pattern) {
                            localStorage.setItem('firebase-pending-pattern', roomData.pattern);
                        }

                        // Reload to apply tree (simplest way to re-render)
                        window.location.href = window.location.pathname + '?room=' + roomId;
                        return;
                    }

                    firebaseSyncState.roomId = roomId;
                    firebaseSyncState.isConnected = true;

                    // Subscribe to changes
                    subscribeToRoom(roomId);
                    updateSyncUI();

                    showToast('ðŸ”¥ Joined room: ' + roomId, 'success');

                } catch (error) {
                    console.error('ðŸ”¥ Failed to join room:', error);
                    showToast('âŒ Failed to join room: ' + error.message, 'error');
                }
            }

            // Subscribe to real-time updates from a room
            function subscribeToRoom(roomId) {
                if (firebaseSyncState.unsubscribe) {
                    firebaseSyncState.unsubscribe();
                }

                const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', roomId);

                firebaseSyncState.unsubscribe = window.firebaseOnSnapshot(roomRef, (doc) => {
                    if (!doc.exists()) {
                        console.log('ðŸ”¥ Room deleted');
                        leaveSyncRoom();
                        showToast('âš ï¸ Room was deleted', 'warning');
                        return;
                    }

                    const data = doc.data();

                    // BUILD 273/279: ALWAYS process presence updates regardless of who triggered
                    // This fixes the bug where host doesn't see guest join because lastUpdatedBy was host
                    if (data.connectedUsers) {
                        updateCollaboratorsUI(data.connectedUsers);
                    }

                    // BUILD 274: ALWAYS process chat messages regardless of who triggered
                    // This fixes the bug where guest doesn't receive host messages
                    if (data.chatMessages && Array.isArray(data.chatMessages)) {
                        updateChatUI(data.chatMessages);
                    }

                    // Skip tree updates if we just pushed this update
                    if (firebaseSyncState.ignoreNextUpdate) {
                        firebaseSyncState.ignoreNextUpdate = false;
                        console.log('ðŸ”¥ Ignoring our own tree update');
                        return;
                    }

                    // Skip tree updates if it's our own update
                    if (data.lastUpdatedBy === firebaseSyncState.userId) {
                        console.log('ðŸ”¥ Skipping own tree update');
                        return;
                    }

                    // Update tree from remote
                    if (data.treeData) {
                        try {
                            // BUILD 327: If we have pending local changes, flush them first
                            // This prevents losing local edits when remote updates arrive
                            if (window.firebaseHasPendingLocalChanges && window.firebaseHasPendingLocalChanges()) {
                                console.log('ðŸ”¥ Pending local changes detected, flushing before accepting remote...');
                                // Skip this remote update - our push will trigger a new one
                                // The user's changes take priority
                                if (window.firebaseFlushPendingChanges) {
                                    window.firebaseFlushPendingChanges();
                                }
                                return; // Don't overwrite local changes
                            }

                            const newTree = JSON.parse(data.treeData);
                            const editorId = data.lastUpdatedBy?.substring(0, 8) || 'Unknown';
                            console.log('ðŸ”¥ Received tree update from', editorId);

                            // BUILD 256: Save state BEFORE applying remote changes (enables undo)
                            const editorName = firebaseSyncState.collaboratorNames[data.lastUpdatedBy] || `User ${editorId}`;
                            if (typeof saveState === 'function') {
                                saveState(`Remote sync from ${editorName}`);
                            }

                            // BUILD 256: Update last editor display
                            firebaseSyncState.lastEditor = data.lastUpdatedBy;
                            const lastEditorEl = document.getElementById('sync-last-editor');
                            const lastEditorRow = document.getElementById('sync-last-editor-row');
                            if (lastEditorEl && lastEditorRow) {
                                lastEditorEl.textContent = editorName;
                                lastEditorRow.style.display = 'block';
                            }

                            // Update global tree
                            window.capexTree = newTree;

                            // Update pattern if changed
                            if (data.pattern && window.PATTERNS && window.PATTERNS[data.pattern]) {
                                window.currentPattern = data.pattern;
                                const patternSelect = document.getElementById('pattern-select');
                                if (patternSelect) patternSelect.value = data.pattern;
                            }

                            // Update tree name display
                            const treeNameDisplay = document.getElementById('tree-name-display');
                            if (treeNameDisplay) {
                                treeNameDisplay.textContent = newTree.name || 'Synced Tree';
                            }

                            // Trigger tree container re-render via custom event
                            window.dispatchEvent(new CustomEvent('treelisty-sync-update', { detail: newTree }));

                            // Update last sync time
                            firebaseSyncState.lastSyncTimestamp = Date.now();
                            const syncLastUpdate = document.getElementById('sync-last-update');
                            if (syncLastUpdate) {
                                syncLastUpdate.textContent = new Date().toLocaleTimeString();
                            }

                            showToast('ðŸ”„ Tree synced from collaborator', 'info');

                            // BUILD 257: Auto-save JSON if enabled
                            if (firebaseSyncState.autoSaveJSON && window.saveCollabJSON) {
                                setTimeout(() => window.saveCollabJSON(), 500); // Small delay to ensure tree is updated
                            }

                        } catch (e) {
                            console.error('ðŸ”¥ Failed to parse tree update:', e);
                        }
                    }

                    // BUILD 274: Chat messages and connected users now handled at top of snapshot (before early returns)
                }, (error) => {
                    console.error('ðŸ”¥ Snapshot error:', error);
                    showToast('âŒ Sync error: ' + error.message, 'error');
                });

                // BUILD 265: Register ourselves as connected
                registerAsConnected(roomId);

                console.log('ðŸ”¥ Subscribed to room:', roomId);
            }

            // BUILD 279: Register user as connected to room
            // Uses updateDoc (not setDoc) with dot notation - setDoc merge was silently failing
            async function registerAsConnected(roomId) {
                if (!firebaseSyncState.userId) return;

                try {
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', roomId);

                    // Use dot notation to add user without overwriting others
                    const updateData = {};
                    updateData[`connectedUsers.${firebaseSyncState.userId}`] = {
                        name: firebaseSyncState.myDisplayName || 'User',
                        joinedAt: Date.now()
                    };

                    // BUILD 278/279: Use updateDoc instead of setDoc - setDoc with merge was silently failing
                    await window.firebaseUpdateDoc(roomRef, updateData);
                    console.log('ðŸ”¥ Registered as connected:', firebaseSyncState.userId.substring(0, 8));
                } catch (e) {
                    console.error('ðŸ”¥ Failed to register as connected:', e.message);
                }
            }

            // Push local changes to the room
            async function pushTreeToRoom() {
                if (!firebaseSyncState.isConnected || !firebaseSyncState.roomId) {
                    return;
                }

                if (firebaseSyncState.isSyncing) {
                    console.log('ðŸ”¥ Already syncing, skipping');
                    return;
                }

                firebaseSyncState.isSyncing = true;
                firebaseSyncState.ignoreNextUpdate = true;

                try {
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', firebaseSyncState.roomId);
                    await window.firebaseSetDoc(roomRef, {
                        lastUpdatedBy: firebaseSyncState.userId,
                        lastUpdatedAt: window.firebaseServerTimestamp(),
                        treeData: JSON.stringify(capexTree),
                        pattern: currentPattern,
                        projectName: capexTree?.name || 'Untitled'
                    }, { merge: true });

                    console.log('ðŸ”¥ Pushed tree update');
                    document.getElementById('sync-last-update').textContent = new Date().toLocaleTimeString();

                    // BUILD 256: Update last editor to show "You"
                    const lastEditorEl = document.getElementById('sync-last-editor');
                    const lastEditorRow = document.getElementById('sync-last-editor-row');
                    if (lastEditorEl && lastEditorRow) {
                        lastEditorEl.textContent = 'You';
                        lastEditorRow.style.display = 'block';
                    }

                } catch (error) {
                    console.error('ðŸ”¥ Failed to push tree:', error);
                    firebaseSyncState.ignoreNextUpdate = false;
                } finally {
                    firebaseSyncState.isSyncing = false;
                }
            }

            // Leave the current room
            function leaveSyncRoom() {
                if (firebaseSyncState.unsubscribe) {
                    firebaseSyncState.unsubscribe();
                    firebaseSyncState.unsubscribe = null;
                }

                firebaseSyncState.isConnected = false;
                firebaseSyncState.roomId = null;
                updateSyncUI();

                // BUILD 268: Hide floating chat and reset state
                hideFloatingChat();
                floatingChatState.isHost = false;
                floatingChatState.previousUserCount = 1;
                floatingChatState.unreadCount = 0;

                // BUILD 268: Clear session API keys if guest used shared keys
                if (sessionStorage.getItem('session_api_keys')) {
                    localStorage.removeItem('anthropic_api_key');
                    localStorage.removeItem('gemini_api_key');
                    localStorage.removeItem('openai_api_key');
                    sessionStorage.removeItem('session_api_keys');
                    showToast('ðŸ”‘ Session API keys cleared', 'info');
                }

                showToast('ðŸ‘‹ Left sync room', 'info');
            }

            // Copy room ID to clipboard
            function copyRoomId() {
                const roomId = firebaseSyncState.roomId;
                if (roomId) {
                    navigator.clipboard.writeText(roomId).then(() => {
                        showToast('ðŸ“‹ Room ID copied: ' + roomId, 'success');
                    });
                }
            }

            // BUILD 256: Set display name for this user
            function setMyDisplayName(name) {
                firebaseSyncState.myDisplayName = name;
                // Store own name in collaboratorNames too
                if (firebaseSyncState.userId) {
                    firebaseSyncState.collaboratorNames[firebaseSyncState.userId] = name;
                }
                localStorage.setItem('treelisty_display_name', name);
                showToast(`âœï¸ Display name set to: ${name}`, 'success');
            }

            // BUILD 256: Set name for a collaborator (by their short ID)
            function setCollaboratorName(shortId, name) {
                // Find full userId that starts with shortId
                const fullId = Object.keys(firebaseSyncState.collaboratorNames).find(id => id.startsWith(shortId)) ||
                               firebaseSyncState.lastEditor?.startsWith(shortId) ? firebaseSyncState.lastEditor : null;

                if (fullId) {
                    firebaseSyncState.collaboratorNames[fullId] = name;
                    // Update display if this was the last editor
                    const lastEditorEl = document.getElementById('sync-last-editor');
                    if (lastEditorEl && firebaseSyncState.lastEditor === fullId) {
                        lastEditorEl.textContent = name;
                    }
                    showToast(`âœï¸ Named collaborator ${shortId} as: ${name}`, 'success');
                } else {
                    // Store for future use
                    firebaseSyncState.collaboratorNames[shortId] = name;
                    showToast(`âœï¸ Will name collaborator ${shortId} as: ${name}`, 'info');
                }
            }

            // Expose functions globally
            window.firebaseSyncState = firebaseSyncState;
            window.createFirebaseSyncRoom = createSyncRoom;
            window.joinFirebaseSyncRoom = joinSyncRoom;
            window.leaveFirebaseSyncRoom = leaveSyncRoom;
            window.pushTreeToFirebase = pushTreeToRoom;
            window.copyFirebaseRoomId = copyRoomId;
            window.setMyDisplayName = setMyDisplayName;           // BUILD 256
            window.setCollaboratorName = setCollaboratorName;     // BUILD 256

            // BUILD 322: Jitsi Voice Chat Integration
            // BUILD 324: Skip prejoin modal, pass display name
            window.startVoiceChat = function() {
                if (!firebaseSyncState.isConnected || !firebaseSyncState.roomId) {
                    showToast('âŒ No active collaboration session', 'error');
                    return;
                }

                // Create Jitsi Meet room URL using the session ID
                const roomId = firebaseSyncState.roomId;
                const jitsiRoomName = `treelisty-${roomId}`;

                // Get display name from collaboration session or use default
                const displayName = firebaseSyncState.myDisplayName || 'TreeListy User';
                const encodedName = encodeURIComponent(displayName);

                // Skip prejoin page and pass display name via URL config
                // Also start audio-only (no video) for lighter bandwidth
                const jitsiUrl = `https://meet.jit.si/${jitsiRoomName}#userInfo.displayName="${encodedName}"&config.prejoinConfig.enabled=false&config.startWithVideoMuted=true`;

                // Open in popup window for better UX
                const width = 800;
                const height = 600;
                const left = (screen.width - width) / 2;
                const top = (screen.height - height) / 2;

                const popup = window.open(
                    jitsiUrl,
                    'TreeListy Voice Chat',
                    `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=no,status=no,menubar=no,toolbar=no`
                );

                if (popup) {
                    showToast('ðŸŽ™ï¸ Voice chat opened - invite others to join!', 'success');

                    // Also send a chat message so others know voice chat is available
                    if (typeof sendChatMessage === 'function') {
                        sendChatMessage(`ðŸŽ™ï¸ Started voice chat! Click the Voice button to join.`);
                    }
                } else {
                    // Popup blocked - fall back to new tab
                    window.open(jitsiUrl, '_blank');
                    showToast('ðŸŽ™ï¸ Voice chat opened in new tab', 'info');
                }

                console.log('ðŸŽ™ï¸ Voice chat started:', jitsiUrl);
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 325: Scheduled Meeting Link System
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Meeting state storage
            let meetingState = {
                currentMeetingId: null,
                isHost: false,
                meetingUnsubscribe: null,
                backupInterval: null,
                waitingStartTime: null
            };

            // Generate unique 8-char meeting ID (MEET + 4 alphanumeric)
            function generateMeetingId() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // No ambiguous chars
                let result = 'MEET';
                for (let i = 0; i < 4; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            // Create a scheduled meeting and store tree in Firebase
            async function createScheduledMeeting() {
                console.log('ðŸ“… Creating scheduled meeting...');

                // 1. Authenticate if needed
                if (!firebaseSyncState.userId) {
                    const authed = await initFirebaseAuth();
                    if (!authed) {
                        showToast('âŒ Authentication required', 'error');
                        return null;
                    }
                }

                // 2. Generate meeting ID
                const meetingId = generateMeetingId();

                // 3. Get form values
                const meetingNameInput = document.getElementById('meeting-name-input');
                const meetingTimeInput = document.getElementById('meeting-time-input');
                const allowGuestEdits = document.getElementById('meeting-allow-edits')?.checked ?? true;
                const autoVoicePrompt = document.getElementById('meeting-voice-prompt')?.checked ?? true;
                const autoBackup = document.getElementById('meeting-auto-backup')?.checked ?? true;

                const meetingName = meetingNameInput?.value || capexTree.name || 'Scheduled Meeting';
                const scheduledTime = meetingTimeInput?.value ? new Date(meetingTimeInput.value) : null;

                try {
                    // 4. Create meeting document in Firestore
                    const meetingRef = window.firebaseDoc(window.firebaseDb, 'scheduledMeetings', meetingId);

                    await window.firebaseSetDoc(meetingRef, {
                        meetingId: meetingId,
                        roomId: null, // Set when meeting goes active

                        // Scheduling
                        scheduledAt: scheduledTime || window.firebaseServerTimestamp(),
                        createdAt: window.firebaseServerTimestamp(),
                        expiresAt: new Date(Date.now() + 48 * 60 * 60 * 1000), // 48h from now

                        // Host identification
                        hostId: firebaseSyncState.userId,
                        hostName: firebaseSyncState.myDisplayName || 'Host',
                        hostDeviceFingerprint: getDeviceFingerprint(),

                        // Meeting state
                        state: 'SCHEDULED',
                        stateChangedAt: window.firebaseServerTimestamp(),

                        // Tree bundle (bypasses URL size limit!)
                        treeData: JSON.stringify(capexTree),
                        pattern: currentPattern,
                        projectName: meetingName,

                        // Participants (empty initially)
                        participants: {},

                        // Settings
                        settings: {
                            allowGuestEdits: allowGuestEdits,
                            autoVoicePrompt: autoVoicePrompt,
                            autoBackup: autoBackup,
                            waitingMessage: `Waiting for ${firebaseSyncState.myDisplayName || 'host'} to start...`
                        }
                    });

                    console.log('ðŸ“… Meeting created:', meetingId);

                    // 5. Generate and display link
                    const meetingUrl = `${window.location.origin}${window.location.pathname}?meeting=${meetingId}`;

                    // Update modal UI
                    const linkInput = document.getElementById('meeting-link-url');
                    const createSection = document.getElementById('meeting-create-section');
                    const generatedSection = document.getElementById('meeting-generated-section');

                    if (linkInput) linkInput.value = meetingUrl;
                    if (createSection) createSection.style.display = 'none';
                    if (generatedSection) generatedSection.style.display = 'block';

                    // 6. Copy to clipboard
                    try {
                        await navigator.clipboard.writeText(meetingUrl);
                        showToast('ðŸ“… Meeting link created and copied!', 'success');
                    } catch (e) {
                        showToast('ðŸ“… Meeting link created! Copy it from the modal.', 'success');
                    }

                    // 7. Store locally for host re-identification
                    localStorage.setItem('treelisty:hosted-meeting', meetingId);

                    // Store in meeting state
                    meetingState.currentMeetingId = meetingId;
                    meetingState.isHost = true;

                    return meetingId;

                } catch (error) {
                    console.error('ðŸ“… Failed to create meeting:', error);
                    showToast('âŒ Failed to create meeting: ' + error.message, 'error');
                    return null;
                }
            }

            // Check if current user is the host of a meeting
            function isHostOfMeeting(meeting) {
                // Check Firebase UID
                if (meeting.hostId === firebaseSyncState.userId) return true;

                // Check device fingerprint (for reconnection after auth change)
                if (meeting.hostDeviceFingerprint === getDeviceFingerprint()) return true;

                // Check localStorage (host created meeting on this device)
                if (localStorage.getItem('treelisty:hosted-meeting') === meeting.meetingId) return true;

                return false;
            }

            // Handle ?meeting= URL parameter
            async function handleMeetingURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const meetingId = urlParams.get('meeting');

                if (!meetingId) return false;

                console.log('ðŸ“… Meeting URL detected:', meetingId);

                try {
                    // 1. Authenticate
                    if (!firebaseSyncState.userId) {
                        await initFirebaseAuth();
                    }

                    // 2. Fetch meeting data from Firebase
                    const meetingRef = window.firebaseDoc(window.firebaseDb, 'scheduledMeetings', meetingId);
                    const meetingSnap = await window.firebaseGetDoc(meetingRef);

                    if (!meetingSnap.exists()) {
                        showToast('âŒ Meeting not found or has expired', 'error');
                        // Clean URL
                        window.history.replaceState({}, '', window.location.pathname);
                        return false;
                    }

                    const meeting = meetingSnap.data();
                    console.log('ðŸ“… Meeting data loaded:', meeting.projectName, 'state:', meeting.state);

                    // 3. Check if this is the host reconnecting
                    const isHost = isHostOfMeeting(meeting);
                    meetingState.isHost = isHost;
                    meetingState.currentMeetingId = meetingId;

                    // 4. Register as participant
                    await registerMeetingParticipant(meetingId, isHost);

                    // 5. Handle based on current meeting state
                    // IMPORTANT: If meeting is ACTIVE, get tree from sync room (latest version)
                    // Only load from meeting document if waiting for host (original tree)
                    if (meeting.state === 'ACTIVE' && meeting.roomId) {
                        // Meeting already active - join the sync room directly
                        // The sync room has the LATEST tree, so don't load from meeting doc
                        console.log('ðŸ“… Meeting active, joining room for latest tree:', meeting.roomId);
                        await joinSyncRoom(meeting.roomId);

                        // Start backup interval if enabled
                        if (meeting.settings?.autoBackup) {
                            startMeetingBackupInterval();
                        }

                    } else {
                        // Meeting NOT active yet - load tree from meeting document
                        // (This is the original tree stored when meeting was created)
                        if (meeting.treeData) {
                            try {
                                const loadedTree = JSON.parse(meeting.treeData);
                                window.capexTree = loadedTree;

                                // Update pattern if specified
                                if (meeting.pattern && window.PATTERNS && window.PATTERNS[meeting.pattern]) {
                                    window.currentPattern = meeting.pattern;
                                    const patternSelect = document.getElementById('pattern-select');
                                    if (patternSelect) patternSelect.value = meeting.pattern;
                                }

                                // Update tree name display
                                const treeNameDisplay = document.getElementById('tree-name-display');
                                if (treeNameDisplay) {
                                    treeNameDisplay.textContent = loadedTree.name || meeting.projectName || 'Meeting Tree';
                                }

                                console.log('ðŸ“… Tree loaded from meeting document:', loadedTree.name);
                            } catch (e) {
                                console.error('ðŸ“… Failed to parse meeting tree:', e);
                                showToast('âŒ Failed to load meeting tree', 'error');
                                return false;
                            }
                        }

                        if (isHost) {
                            // Host arriving - activate the meeting
                            console.log('ðŸ“… Host detected, activating meeting...');
                            await activateMeeting(meetingId);
                        } else {
                            // Guest arrived before host - show waiting room
                            console.log('ðŸ“… Guest waiting for host...');
                            showWaitingRoom(meeting);
                            subscribeMeetingState(meetingId);
                        }
                    }

                    // 7. Download initial backup if enabled
                    if (meeting.settings?.autoBackup) {
                        setTimeout(() => {
                            downloadMeetingBackup('meeting-join');
                        }, 2000);
                    }

                    // Trigger re-render
                    setTimeout(() => {
                        const treeRenderer = window.getTreeRenderer && window.getTreeRenderer();
                        const canvasRenderer = window.getCanvasRenderer && window.getCanvasRenderer();
                        if (treeRenderer) treeRenderer();
                        const canvasContainer = document.getElementById('canvas-container');
                        if (canvasContainer && canvasContainer.classList.contains('active') && canvasRenderer) {
                            canvasRenderer();
                        }
                    }, 300);

                    return true;

                } catch (error) {
                    console.error('ðŸ“… Meeting join error:', error);
                    showToast('âŒ Failed to join meeting: ' + error.message, 'error');
                    return false;
                }
            }

            // Register user as meeting participant
            async function registerMeetingParticipant(meetingId, isHost) {
                try {
                    const meetingRef = window.firebaseDoc(window.firebaseDb, 'scheduledMeetings', meetingId);
                    const updateData = {};
                    updateData[`participants.${firebaseSyncState.userId}`] = {
                        name: firebaseSyncState.myDisplayName || (isHost ? 'Host' : 'Guest'),
                        role: isHost ? 'host' : 'guest',
                        joinedAt: Date.now(),
                        lastActiveAt: Date.now()
                    };
                    await window.firebaseUpdateDoc(meetingRef, updateData);
                    console.log('ðŸ“… Registered as participant');
                } catch (error) {
                    console.error('ðŸ“… Failed to register participant:', error);
                }
            }

            // Host activates the meeting (creates sync room)
            async function activateMeeting(meetingId) {
                console.log('ðŸ“… Activating meeting:', meetingId);

                // 1. Create a sync room
                const roomId = generateRoomId();
                firebaseSyncState.roomId = roomId;

                try {
                    // 2. Create sync room document
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', roomId);
                    const initialConnectedUsers = {};
                    initialConnectedUsers[firebaseSyncState.userId] = {
                        name: firebaseSyncState.myDisplayName || 'Host',
                        joinedAt: Date.now(),
                        isHost: true
                    };

                    await window.firebaseSetDoc(roomRef, {
                        createdBy: firebaseSyncState.userId,
                        createdAt: window.firebaseServerTimestamp(),
                        lastUpdatedBy: firebaseSyncState.userId,
                        lastUpdatedAt: window.firebaseServerTimestamp(),
                        treeData: JSON.stringify(capexTree),
                        pattern: currentPattern,
                        projectName: capexTree?.name || 'Meeting',
                        chatMessages: [],
                        connectedUsers: initialConnectedUsers,
                        meetingId: meetingId,
                        meetingState: 'ACTIVE'
                    });

                    // 3. Update meeting document with room ID and state
                    const meetingRef = window.firebaseDoc(window.firebaseDb, 'scheduledMeetings', meetingId);
                    await window.firebaseUpdateDoc(meetingRef, {
                        roomId: roomId,
                        state: 'ACTIVE',
                        stateChangedAt: window.firebaseServerTimestamp()
                    });

                    // 4. Subscribe to room
                    subscribeToRoom(roomId);
                    firebaseSyncState.isConnected = true;
                    floatingChatState.isHost = true;

                    // 5. Update UI
                    updateSyncUI();
                    showFloatingChat();
                    hideWaitingRoom();

                    // 6. Start backup interval
                    const meetingSnap = await window.firebaseGetDoc(meetingRef);
                    if (meetingSnap.exists() && meetingSnap.data().settings?.autoBackup) {
                        startMeetingBackupInterval();
                    }

                    showToast('ðŸ“… Meeting started! Waiting participants will auto-join.', 'success');
                    console.log('ðŸ“… Meeting activated, room:', roomId);

                } catch (error) {
                    console.error('ðŸ“… Failed to activate meeting:', error);
                    showToast('âŒ Failed to start meeting: ' + error.message, 'error');
                }
            }

            // Subscribe to meeting state changes (for waiting guests)
            function subscribeMeetingState(meetingId) {
                console.log('ðŸ“… Subscribing to meeting state:', meetingId);

                const meetingRef = window.firebaseDoc(window.firebaseDb, 'scheduledMeetings', meetingId);

                meetingState.meetingUnsubscribe = window.firebaseOnSnapshot(meetingRef, async (doc) => {
                    if (!doc.exists()) {
                        showToast('âš ï¸ Meeting was cancelled', 'warning');
                        hideWaitingRoom();
                        return;
                    }

                    const meeting = doc.data();
                    console.log('ðŸ“… Meeting state update:', meeting.state);

                    if (meeting.state === 'ACTIVE' && meeting.roomId) {
                        // Host arrived! Join the sync room
                        hideWaitingRoom();

                        showToast('ðŸŽ‰ Host has joined! Connecting to live session...', 'success');

                        // Unsubscribe from meeting state (we'll use room subscription now)
                        if (meetingState.meetingUnsubscribe) {
                            meetingState.meetingUnsubscribe();
                            meetingState.meetingUnsubscribe = null;
                        }

                        // Join the sync room
                        await joinSyncRoom(meeting.roomId);

                        // Start backup interval if enabled
                        if (meeting.settings?.autoBackup) {
                            startMeetingBackupInterval();
                        }

                        // Prompt for voice if enabled
                        if (meeting.settings?.autoVoicePrompt) {
                            setTimeout(() => showVoicePrompt(), 2000);
                        }
                    }

                    if (meeting.state === 'ENDED') {
                        showToast('ðŸ“… Meeting has ended', 'info');
                        hideWaitingRoom();
                        stopMeetingBackupInterval();
                    }
                });
            }

            // Show waiting room UI
            function showWaitingRoom(meeting) {
                const banner = document.getElementById('waiting-room-banner');
                if (!banner) {
                    console.warn('ðŸ“… Waiting room banner not found');
                    return;
                }

                const statusEl = document.getElementById('waiting-status');
                const messageEl = document.getElementById('waiting-message');

                banner.style.display = 'flex';
                if (statusEl) {
                    statusEl.textContent = `â³ Waiting for ${meeting.hostName || 'host'} to start the meeting...`;
                }
                if (messageEl) {
                    const editMsg = meeting.settings?.allowGuestEdits
                        ? 'You can start editing - changes will sync when host arrives.'
                        : 'View only until host arrives.';
                    messageEl.textContent = editMsg;
                }

                meetingState.waitingStartTime = Date.now();

                // Update waiting timer periodically
                updateWaitingTimer();
            }

            function hideWaitingRoom() {
                const banner = document.getElementById('waiting-room-banner');
                if (banner) {
                    banner.style.display = 'none';
                }
                meetingState.waitingStartTime = null;
            }

            // Update waiting timer display
            function updateWaitingTimer() {
                if (!meetingState.waitingStartTime) return;

                const timerEl = document.getElementById('waiting-timer');
                if (!timerEl) return;

                const elapsed = Math.floor((Date.now() - meetingState.waitingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                timerEl.textContent = `(${minutes}:${seconds.toString().padStart(2, '0')})`;

                // Continue updating
                setTimeout(updateWaitingTimer, 1000);
            }

            // Show voice prompt toast
            function showVoicePrompt() {
                const prompt = document.getElementById('voice-prompt-toast');
                if (!prompt) return;

                prompt.style.display = 'flex';
                prompt.classList.add('slide-in');

                // Auto-dismiss after 15 seconds
                setTimeout(() => {
                    if (prompt.style.display !== 'none') {
                        dismissVoicePrompt();
                    }
                }, 15000);
            }

            function acceptVoicePrompt() {
                const prompt = document.getElementById('voice-prompt-toast');
                if (prompt) prompt.style.display = 'none';
                window.startVoiceChat();
            }

            function dismissVoicePrompt() {
                const prompt = document.getElementById('voice-prompt-toast');
                if (!prompt) return;

                prompt.classList.add('slide-out');
                setTimeout(() => {
                    prompt.style.display = 'none';
                    prompt.classList.remove('slide-out', 'slide-in');
                }, 300);
            }

            // Download JSON backup with meeting context
            function downloadMeetingBackup(trigger = 'manual') {
                if (typeof capexTree === 'undefined') return;

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const meetingId = meetingState.currentMeetingId || 'adhoc';
                const safeName = (capexTree.name || 'meeting-tree').replace(/[^a-z0-9]/gi, '-').toLowerCase();

                const filename = `treelisty-meeting-${meetingId}-${safeName}-${trigger}-${timestamp}.json`;

                // Add metadata to backup
                const backupData = {
                    ...capexTree,
                    _meetingBackup: {
                        meetingId: meetingId,
                        trigger: trigger,
                        timestamp: new Date().toISOString(),
                        participants: Object.keys(firebaseSyncState.collaboratorNames || {}),
                        isHost: meetingState.isHost
                    }
                };

                const dataStr = JSON.stringify(backupData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('ðŸ’¾ Meeting backup saved:', filename);
                showToast(`ðŸ’¾ Backup saved: ${filename.substring(0, 40)}...`, 'success');
            }

            // Start periodic backup interval (every 5 minutes)
            function startMeetingBackupInterval() {
                if (meetingState.backupInterval) return;

                console.log('ðŸ’¾ Starting periodic backup (every 5 min)');
                meetingState.backupInterval = setInterval(() => {
                    downloadMeetingBackup('periodic');
                }, 5 * 60 * 1000); // Every 5 minutes
            }

            // Stop periodic backup
            function stopMeetingBackupInterval() {
                if (meetingState.backupInterval) {
                    clearInterval(meetingState.backupInterval);
                    meetingState.backupInterval = null;
                    console.log('ðŸ’¾ Stopped periodic backup');
                }
            }

            // Show meeting link modal
            function showMeetingModal() {
                const modal = document.getElementById('meeting-link-modal');
                if (modal) {
                    modal.style.display = 'flex';
                    // Reset to create view
                    const createSection = document.getElementById('meeting-create-section');
                    const generatedSection = document.getElementById('meeting-generated-section');
                    if (createSection) createSection.style.display = 'block';
                    if (generatedSection) generatedSection.style.display = 'none';
                    // Pre-fill meeting name
                    const nameInput = document.getElementById('meeting-name-input');
                    if (nameInput) nameInput.value = capexTree.name || '';
                }
            }

            function closeMeetingModal() {
                const modal = document.getElementById('meeting-link-modal');
                if (modal) modal.style.display = 'none';
            }

            function copyMeetingLink() {
                const linkInput = document.getElementById('meeting-link-url');
                if (linkInput) {
                    navigator.clipboard.writeText(linkInput.value)
                        .then(() => showToast('ðŸ“‹ Meeting link copied!', 'success'))
                        .catch(() => {
                            linkInput.select();
                            document.execCommand('copy');
                            showToast('ðŸ“‹ Meeting link copied!', 'success');
                        });
                }
            }

            // Expose meeting functions globally
            window.createScheduledMeeting = createScheduledMeeting;
            window.handleMeetingURL = handleMeetingURL;
            window.showMeetingModal = showMeetingModal;
            window.closeMeetingModal = closeMeetingModal;
            window.copyMeetingLink = copyMeetingLink;
            window.downloadMeetingBackup = downloadMeetingBackup;
            window.acceptVoicePrompt = acceptVoicePrompt;
            window.dismissVoicePrompt = dismissVoicePrompt;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // END BUILD 325: Scheduled Meeting Link System
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // BUILD 257: Manual JSON save during collaboration
            window.saveCollabJSON = function() {
                if (typeof capexTree === 'undefined') {
                    showToast('âŒ No tree data to save', 'error');
                    return;
                }

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const safeName = (capexTree.name || 'collab-tree').replace(/[^a-z0-9]/gi, '-').toLowerCase();
                const filename = `treelisty-${currentPattern}-${safeName}-${timestamp}.json`;

                const dataStr = JSON.stringify(capexTree, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                showToast(`ðŸ’¾ Saved: ${filename}`, 'success');
            };

            // BUILD 257: Toggle auto-save JSON on every sync
            window.toggleCollabAutoSave = function(enabled) {
                firebaseSyncState.autoSaveJSON = enabled;
                localStorage.setItem('treelisty_collab_autosave', enabled ? 'true' : 'false');
                showToast(enabled ? 'âœ… Auto-save JSON enabled' : 'â¸ï¸ Auto-save JSON disabled', 'info');
            };

            // BUILD 257: Check auto-save setting and restore checkbox state
            firebaseSyncState.autoSaveJSON = localStorage.getItem('treelisty_collab_autosave') === 'true';

            // BUILD 265: Copy invite link
            window.copySyncInviteLink = async function() {
                const linkInput = document.getElementById('sync-invite-link');
                if (linkInput && linkInput.value) {
                    try {
                        await navigator.clipboard.writeText(linkInput.value);
                        showToast('ðŸ“‹ Invite link copied!', 'success');
                    } catch (e) {
                        linkInput.select();
                        document.execCommand('copy');
                        showToast('ðŸ“‹ Invite link copied!', 'success');
                    }
                }
            };

            // BUILD 351: Copy just the session code (easier to share verbally)
            window.copySessionCode = async function() {
                const roomId = firebaseSyncState.roomId || document.getElementById('active-room-id')?.value || '';
                if (roomId) {
                    try {
                        await navigator.clipboard.writeText(roomId);
                        showToast(`ðŸ“‹ Code copied: ${roomId}`, 'success');
                        // Brief visual feedback on the code display
                        const codeDisplay = document.getElementById('active-room-id-display');
                        if (codeDisplay) {
                            const originalBg = codeDisplay.style.background;
                            codeDisplay.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                            codeDisplay.style.color = 'white';
                            setTimeout(() => {
                                codeDisplay.style.background = originalBg || 'var(--bg)';
                                codeDisplay.style.color = 'var(--text-primary)';
                            }, 500);
                        }
                    } catch (e) {
                        // Fallback for older browsers
                        const tempInput = document.createElement('input');
                        tempInput.value = roomId;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);
                        showToast(`ðŸ“‹ Code copied: ${roomId}`, 'success');
                    }
                }
            };

            // BUILD 265: Email invite link
            window.emailSyncInvite = function() {
                const roomId = firebaseSyncState.roomId || '';
                const inviteLink = document.getElementById('sync-invite-link')?.value || '';
                const projectName = capexTree?.name || 'TreeListy Project';

                const subject = encodeURIComponent(`Join my TreeListy session: ${projectName}`);
                const body = encodeURIComponent(
                    `Hi!\n\n` +
                    `I'd like to collaborate with you on "${projectName}" in TreeListy.\n\n` +
                    `Click this link to join my live session:\n${inviteLink}\n\n` +
                    `Room Code: ${roomId}\n\n` +
                    `See you there!`
                );

                window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');
            };

            // BUILD 281: toggleApiKeySharing removed - guests enter keys manually

            // BUILD 265: Send chat message
            window.sendSyncChatMessage = async function() {
                const input = document.getElementById('sync-chat-input');
                const message = input?.value?.trim();
                if (!message || !firebaseSyncState.roomId) return;

                input.value = '';
                await window.sendSyncChatMessageText(message);
            };

            // BUILD 268: Send chat message with text directly (for floating chat and API key sharing)
            window.sendSyncChatMessageText = async function(message, metadata = null) {
                if (!message || !firebaseSyncState.roomId) return;

                const chatMsg = {
                    userId: firebaseSyncState.userId?.substring(0, 8) || 'anon',
                    name: firebaseSyncState.myDisplayName || 'User',
                    text: message,
                    timestamp: Date.now(),
                    ...(metadata && { metadata })
                };

                // Add to local display immediately (both modal and floating)
                addChatMessageToUI(chatMsg);

                // Push to Firebase (store in room doc)
                try {
                    const roomRef = window.firebaseDoc(window.firebaseDb, 'syncRooms', firebaseSyncState.roomId);
                    const roomSnap = await window.firebaseGetDoc(roomRef);
                    if (roomSnap.exists()) {
                        const data = roomSnap.data();
                        const messages = data.chatMessages || [];
                        messages.push(chatMsg);
                        // Keep only last 50 messages
                        if (messages.length > 50) messages.shift();
                        await window.firebaseSetDoc(roomRef, { chatMessages: messages }, { merge: true });
                    }
                } catch (e) {
                    console.error('ðŸ”¥ Failed to send chat message:', e);
                }
            };

            // BUILD 265: Add chat message to UI (modal)
            function addChatMessageToUI(msg) {
                const container = document.getElementById('sync-chat-messages');
                if (container) {
                    // Remove "no messages" placeholder
                    const placeholder = container.querySelector('div[style*="text-align: center"]');
                    if (placeholder) placeholder.remove();

                    const isMe = msg.userId === firebaseSyncState.userId?.substring(0, 8);
                    const msgEl = document.createElement('div');
                    msgEl.style.cssText = `margin-bottom: 6px; ${isMe ? 'text-align: right;' : ''}`;
                    msgEl.innerHTML = `
                        <span style="font-weight: 600; color: ${isMe ? '#10b981' : '#6366f1'};">${msg.name || 'User'}:</span>
                        <span style="color: var(--text-primary);">${msg.text}</span>
                    `;
                    container.appendChild(msgEl);
                    container.scrollTop = container.scrollHeight;
                }

                // BUILD 268: Also add to floating chat
                addMessageToFloatingChat(msg);
            }

            // BUILD 268: Track floating chat state
            let floatingChatState = {
                isExpanded: true,
                unreadCount: 0,
                lastMessageCount: 0,
                previousUserCount: 1,
                isHost: false,
                // BUILD 272: Draggable state
                isDragging: false,
                dragOffsetX: 0,
                dragOffsetY: 0
            };

            // BUILD 272: Make floating chat draggable
            function initFloatingChatDrag() {
                const chatBox = document.getElementById('floating-collab-chat');
                const header = document.getElementById('floating-chat-header');
                if (!chatBox || !header) return;

                header.style.cursor = 'move';

                let dragStartX = 0, dragStartY = 0;
                let hasMoved = false;

                header.addEventListener('mousedown', (e) => {
                    // Don't start drag if clicking on toggle arrow
                    if (e.target.id === 'floating-chat-toggle') {
                        return;
                    }
                    floatingChatState.isDragging = true;
                    hasMoved = false;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    const rect = chatBox.getBoundingClientRect();
                    floatingChatState.dragOffsetX = e.clientX - rect.left;
                    floatingChatState.dragOffsetY = e.clientY - rect.top;
                    chatBox.style.transition = 'none';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!floatingChatState.isDragging) return;
                    const chatBox = document.getElementById('floating-collab-chat');
                    if (!chatBox) return;

                    // Check if actually moved (more than 5px)
                    const dx = Math.abs(e.clientX - dragStartX);
                    const dy = Math.abs(e.clientY - dragStartY);
                    if (dx > 5 || dy > 5) {
                        hasMoved = true;
                    }

                    let newX = e.clientX - floatingChatState.dragOffsetX;
                    let newY = e.clientY - floatingChatState.dragOffsetY;

                    // Keep within viewport
                    const maxX = window.innerWidth - chatBox.offsetWidth;
                    const maxY = window.innerHeight - chatBox.offsetHeight;
                    newX = Math.max(0, Math.min(newX, maxX));
                    newY = Math.max(0, Math.min(newY, maxY));

                    // Switch from bottom/right positioning to top/left
                    chatBox.style.bottom = 'auto';
                    chatBox.style.right = 'auto';
                    chatBox.style.left = newX + 'px';
                    chatBox.style.top = newY + 'px';
                });

                document.addEventListener('mouseup', () => {
                    if (floatingChatState.isDragging) {
                        floatingChatState.isDragging = false;
                        const chatBox = document.getElementById('floating-collab-chat');
                        if (chatBox) chatBox.style.transition = '';

                        // If didn't actually move, allow the click to toggle
                        if (!hasMoved) {
                            window.toggleFloatingChat();
                        }
                    }
                });
            }

            // Initialize drag on DOM ready
            document.addEventListener('DOMContentLoaded', initFloatingChatDrag);

            // BUILD 268: Toggle floating chat expand/collapse
            // BUILD 272: Updated to prevent toggle during drag
            window.toggleFloatingChat = function() {
                // Don't toggle if we were just dragging
                if (floatingChatState.isDragging) return;

                const body = document.getElementById('floating-chat-body');
                const toggle = document.getElementById('floating-chat-toggle');
                if (!body || !toggle) return;

                floatingChatState.isExpanded = !floatingChatState.isExpanded;
                if (floatingChatState.isExpanded) {
                    body.style.maxHeight = '350px';
                    toggle.textContent = 'â–¼';
                    // Clear unread when expanded
                    floatingChatState.unreadCount = 0;
                    const badge = document.getElementById('floating-unread-badge');
                    if (badge) badge.style.display = 'none';
                } else {
                    body.style.maxHeight = '0';
                    toggle.textContent = 'â–²';
                }
            };

            // BUILD 279: Show floating chat box
            function showFloatingChat() {
                const chatBox = document.getElementById('floating-collab-chat');
                if (chatBox) {
                    chatBox.style.display = 'block';
                }
            }

            // BUILD 268: Hide floating chat box
            function hideFloatingChat() {
                const chatBox = document.getElementById('floating-collab-chat');
                if (chatBox) chatBox.style.display = 'none';
            }

            // BUILD 268: Send message from floating chat
            window.sendFloatingChatMessage = function() {
                const input = document.getElementById('floating-chat-input');
                if (!input || !input.value.trim()) return;

                // Reuse existing sendSyncChatMessage but with floating input
                const text = input.value.trim();
                input.value = '';

                // Call the existing chat send function
                if (window.sendSyncChatMessageText) {
                    window.sendSyncChatMessageText(text);
                } else {
                    // Fallback: set the modal input and send
                    const modalInput = document.getElementById('sync-chat-input');
                    if (modalInput) {
                        modalInput.value = text;
                        window.sendSyncChatMessage();
                    }
                }
            };

            // BUILD 281: shareApiKeysInChat removed - guests enter keys manually via chat

            // BUILD 268/281: Update floating chat with new message (API key special handling removed)
            function addMessageToFloatingChat(msg) {
                const container = document.getElementById('floating-chat-messages');
                if (!container) return;

                // Remove "no messages" placeholder
                const placeholder = container.querySelector('div[style*="text-align: center"]');
                if (placeholder) placeholder.remove();

                const isMe = msg.userId === firebaseSyncState.userId?.substring(0, 8);
                const msgEl = document.createElement('div');
                msgEl.style.cssText = `margin-bottom: 6px; ${isMe ? 'text-align: right;' : ''}`;

                msgEl.innerHTML = `
                    <span style="font-weight: 600; color: ${isMe ? '#10b981' : '#6366f1'}; font-size: 11px;">${msg.name || 'User'}:</span>
                    <span style="color: var(--text-primary); font-size: 11px;">${msg.text}</span>
                `;

                container.appendChild(msgEl);
                container.scrollTop = container.scrollHeight;

                // Update unread count if chat is collapsed
                if (!floatingChatState.isExpanded && !isMe) {
                    floatingChatState.unreadCount++;
                    const badge = document.getElementById('floating-unread-badge');
                    if (badge) {
                        badge.textContent = floatingChatState.unreadCount;
                        badge.style.display = 'inline';
                    }
                }
            }

            // BUILD 281: applySharedApiKeys removed - guests enter API keys manually

            // BUILD 268: Update floating chat collaborators list
            function updateFloatingCollabList(connectedUsers) {
                const listEl = document.getElementById('floating-collab-list');
                const countEl = document.getElementById('floating-user-count');
                if (!listEl) return;

                const users = Object.entries(connectedUsers || {});
                const count = users.length || 1;

                if (countEl) countEl.textContent = count;

                // Rebuild badges (compact version)
                listEl.innerHTML = '';

                // Add self first (smaller badge)
                const selfBadge = document.createElement('div');
                selfBadge.style.cssText = 'display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 12px; font-size: 10px; font-weight: 600; color: white;';
                selfBadge.innerHTML = `<span>ðŸ‘‘</span> You`;
                listEl.appendChild(selfBadge);

                // Add others
                users.forEach(([id, user]) => {
                    if (id === firebaseSyncState.userId) return;
                    const badge = document.createElement('div');
                    badge.style.cssText = 'display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; background: linear-gradient(135deg, #6366f1, #8b5cf6); border-radius: 12px; font-size: 10px; font-weight: 600; color: white;';
                    badge.innerHTML = `<span>ðŸ‘¤</span> ${user.name || id.substring(0, 6)}`;
                    listEl.appendChild(badge);
                });
            }

            // BUILD 265: Update collaborators list in UI
            function updateCollaboratorsUI(connectedUsers) {
                const listEl = document.getElementById('sync-collaborators-list');
                const countEl = document.getElementById('sync-user-count');
                if (!listEl) return;

                const users = Object.entries(connectedUsers || {});
                const count = users.length || 1;

                if (countEl) countEl.textContent = `${count} user${count !== 1 ? 's' : ''}`;

                // Rebuild collaborator badges
                listEl.innerHTML = '';

                // Add self first
                const selfBadge = document.createElement('div');
                selfBadge.className = 'collab-badge';
                selfBadge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 20px; font-size: 12px; font-weight: 600; color: white;';
                selfBadge.innerHTML = `<span>ðŸ‘‘</span> ${firebaseSyncState.myDisplayName || 'You'}`;
                listEl.appendChild(selfBadge);

                // Add others
                users.forEach(([id, user]) => {
                    if (id === firebaseSyncState.userId) return; // Skip self
                    const badge = document.createElement('div');
                    badge.className = 'collab-badge';
                    badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: linear-gradient(135deg, #6366f1, #8b5cf6); border-radius: 20px; font-size: 12px; font-weight: 600; color: white;';
                    badge.innerHTML = `<span>ðŸ‘¤</span> ${user.name || id.substring(0, 6)}`;
                    listEl.appendChild(badge);
                });

                // BUILD 268: Also update floating chat
                updateFloatingCollabList(connectedUsers);

                // BUILD 279: Auto-show floating chat when 2+ users in room (for BOTH host and guest)
                const otherUsers = users.filter(([id]) => id !== firebaseSyncState.userId);
                const chatBox = document.getElementById('floating-collab-chat');
                const isFloatingChatVisible = chatBox && chatBox.style.display !== 'none';

                // Auto-show floating chat when there are 2+ users (both host and guest)
                if (count >= 2) {
                    // Always ensure floating chat is shown (idempotent)
                    if (!isFloatingChatVisible) {
                        // Close the modal for host
                        if (floatingChatState.isHost) {
                            const modal = document.getElementById('live-sync-modal');
                            if (modal) modal.style.display = 'none';
                        }
                        showFloatingChat();
                    }

                    // Show toast for new arrivals (only once)
                    if (floatingChatState.previousUserCount < count && otherUsers.length > 0) {
                        const newUser = otherUsers[otherUsers.length - 1][1]?.name || 'A collaborator';
                        showToast(`ðŸ‘‹ ${newUser} joined the session!`, 'success');
                    }
                }

                // Track previous count for next update
                floatingChatState.previousUserCount = count;
            }

            // BUILD 274: Update chat UI (both modal and floating) - extracted for early processing
            function updateChatUI(chatMessages) {
                // Update modal chat (if element still exists - was removed in Build 272)
                const modalContainer = document.getElementById('sync-chat-messages');
                if (modalContainer) {
                    modalContainer.innerHTML = '';
                    if (chatMessages.length === 0) {
                        modalContainer.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 30px 0;">No messages yet</div>';
                    } else {
                        chatMessages.forEach(msg => {
                            const isMe = msg.userId === firebaseSyncState.userId?.substring(0, 8);
                            const msgEl = document.createElement('div');
                            msgEl.style.cssText = `margin-bottom: 6px; ${isMe ? 'text-align: right;' : ''}`;
                            msgEl.innerHTML = `
                                <span style="font-weight: 600; color: ${isMe ? '#10b981' : '#6366f1'};">${msg.name || 'User'}:</span>
                                <span style="color: var(--text-primary);">${msg.text}</span>
                            `;
                            modalContainer.appendChild(msgEl);
                        });
                        modalContainer.scrollTop = modalContainer.scrollHeight;
                    }
                }

                // Update floating chat
                const floatingContainer = document.getElementById('floating-chat-messages');
                if (floatingContainer) {
                    floatingContainer.innerHTML = '';
                    if (chatMessages.length === 0) {
                        floatingContainer.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 50px 0; font-size: 12px;">No messages yet</div>';
                    } else {
                        chatMessages.forEach(msg => addMessageToFloatingChat(msg));
                    }
                }
            }

            window.initFirebaseAuthIfNeeded = async function() {
                if (!firebaseSyncState.userId) {
                    await initFirebaseAuth();
                }
            };

            // Initialize on DOM ready
            document.addEventListener('DOMContentLoaded', () => {
                // Live Sync button
                document.getElementById('live-sync-btn')?.addEventListener('click', () => {
                    document.getElementById('live-sync-modal').style.display = 'flex';
                    // Auto-init auth when modal opens
                    if (!firebaseSyncState.userId) {
                        initFirebaseAuth();
                    }
                    // BUILD 257: Restore auto-save checkbox state
                    const autoSaveCheckbox = document.getElementById('collab-auto-save-json');
                    if (autoSaveCheckbox) {
                        autoSaveCheckbox.checked = firebaseSyncState.autoSaveJSON;
                    }
                });

                // Close button
                document.getElementById('live-sync-close')?.addEventListener('click', () => {
                    document.getElementById('live-sync-modal').style.display = 'none';
                });

                // Create room button
                document.getElementById('create-sync-room-btn')?.addEventListener('click', createSyncRoom);

                // Join room button
                document.getElementById('join-sync-room-btn')?.addEventListener('click', () => {
                    const roomId = document.getElementById('join-room-id')?.value;
                    joinSyncRoom(roomId);
                });

                // Leave room button
                document.getElementById('leave-sync-room-btn')?.addEventListener('click', leaveSyncRoom);

                // Copy room ID button
                document.getElementById('copy-room-id-btn')?.addEventListener('click', copyRoomId);

                // Close modal on outside click
                document.getElementById('live-sync-modal')?.addEventListener('click', (e) => {
                    if (e.target.id === 'live-sync-modal') {
                        document.getElementById('live-sync-modal').style.display = 'none';
                    }
                });

                // BUILD 329: Check for pending update restore FIRST (highest priority)
                const pendingUpdate = localStorage.getItem('treelisty:pending-update');
                if (pendingUpdate) {
                    console.log('ðŸ”„ Restoring tree state after update...');
                    try {
                        const updateState = JSON.parse(pendingUpdate);
                        localStorage.removeItem('treelisty:pending-update');

                        // Only restore if recent (within 30 seconds)
                        if (Date.now() - updateState.timestamp < 30000) {
                            setTimeout(() => {
                                try {
                                    // Restore tree
                                    window.capexTree = updateState.tree;

                                    // Restore pattern
                                    if (updateState.pattern && window.PATTERNS && window.PATTERNS[updateState.pattern]) {
                                        window.currentPattern = updateState.pattern;
                                        const patternSelect = document.getElementById('pattern-select');
                                        if (patternSelect) patternSelect.value = updateState.pattern;
                                    }

                                    // Update tree name display
                                    const treeNameDisplay = document.getElementById('tree-name-display');
                                    if (treeNameDisplay && updateState.tree.name) {
                                        treeNameDisplay.textContent = updateState.tree.name;
                                    }

                                    // Restore view state
                                    const vs = updateState.tree.viewState;
                                    if (vs) {
                                        // Restore view mode
                                        if (vs.viewMode && vs.viewMode !== viewMode) {
                                            const toggleBtn = document.getElementById('toggle-canvas-btn');
                                            if (toggleBtn && vs.viewMode === 'canvas' && viewMode === 'tree') {
                                                toggleBtn.click();
                                            } else if (toggleBtn && vs.viewMode === 'tree' && viewMode === 'canvas') {
                                                toggleBtn.click();
                                            }
                                        }
                                    }

                                    // Re-render
                                    const treeRenderer = window.getTreeRenderer && window.getTreeRenderer();
                                    if (treeRenderer) treeRenderer();

                                    // Reconnect to sync room if was in one
                                    if (updateState.roomId) {
                                        console.log('ðŸ”¥ Reconnecting to sync room:', updateState.roomId);
                                        initFirebaseAuth().then(() => {
                                            firebaseSyncState.roomId = updateState.roomId;
                                            firebaseSyncState.isConnected = true;
                                            subscribeToRoom(updateState.roomId);
                                            updateSyncUI();
                                            showFloatingChat();
                                        });
                                    }

                                    showToast('âœ… Updated to Build ' + (window.TREELISTY_VERSION?.build || 'latest') + ' - tree restored!', 'success');
                                    console.log('âœ… Tree state restored after update');
                                } catch (e) {
                                    console.error('âŒ Failed to restore tree after update:', e);
                                }
                            }, 500);
                            return; // Skip other initialization paths
                        }
                    } catch (e) {
                        console.warn('âš ï¸ Could not restore pending update:', e);
                        localStorage.removeItem('treelisty:pending-update');
                    }
                }

                // BUILD 325: Check for ?meeting= URL parameter FIRST (has priority)
                const urlParams = new URLSearchParams(window.location.search);
                const meetingParam = urlParams.get('meeting');
                if (meetingParam) {
                    console.log('ðŸ“… Meeting URL detected:', meetingParam);
                    // Wait for Firebase and app to initialize, then handle meeting
                    setTimeout(async () => {
                        await window.handleMeetingURL();
                    }, 1500);
                }

                // Check for ?room= URL parameter
                const roomParam = urlParams.get('room');
                if (roomParam && !meetingParam) {
                    console.log('ðŸ”¥ Room ID in URL:', roomParam);

                    // Check if we have pending tree data from a join
                    const pendingRoom = localStorage.getItem('firebase-pending-room');
                    const pendingTree = localStorage.getItem('firebase-pending-tree');

                    if (pendingRoom === roomParam && pendingTree) {
                        console.log('ðŸ”¥ Loading pending tree data...');
                        // Clear pending data
                        localStorage.removeItem('firebase-pending-room');
                        localStorage.removeItem('firebase-pending-tree');
                        const pendingPattern = localStorage.getItem('firebase-pending-pattern');
                        localStorage.removeItem('firebase-pending-pattern');

                        // Apply tree data to global capexTree (wait for app to initialize)
                        setTimeout(() => {
                            try {
                                const treeData = JSON.parse(pendingTree);
                                window.capexTree = treeData;

                                // Update pattern if present
                                if (pendingPattern && window.PATTERNS && window.PATTERNS[pendingPattern]) {
                                    window.currentPattern = pendingPattern;
                                    const patternSelect = document.getElementById('pattern-select');
                                    if (patternSelect) patternSelect.value = pendingPattern;
                                }

                                // Update tree name display
                                const treeNameDisplay = document.getElementById('tree-name-display');
                                if (treeNameDisplay) {
                                    treeNameDisplay.textContent = treeData.name || 'Synced Tree';
                                }

                                // Re-render the tree views using exposed getters
                                const treeRenderer = window.getTreeRenderer && window.getTreeRenderer();
                                const canvasRenderer = window.getCanvasRenderer && window.getCanvasRenderer();
                                if (treeRenderer) treeRenderer();
                                const canvasContainer = document.getElementById('canvas-container');
                                if (canvasContainer && canvasContainer.classList.contains('active') && canvasRenderer) {
                                    canvasRenderer();
                                }

                                // Mark as changed so it gets saved to localStorage
                                if (window.treeManager && window.treeManager.markAsChanged) {
                                    window.treeManager.markAsChanged();
                                    // Also do an immediate save
                                    window.treeManager.save(window.capexTree, { silent: true });
                                    console.log('ðŸ”¥ Synced tree saved to localStorage');
                                }

                                console.log('ðŸ”¥ Tree data applied and rendered, now subscribing...');
                                showToast('ðŸ”¥ Joined room: ' + roomParam, 'success');
                            } catch (e) {
                                console.error('ðŸ”¥ Failed to apply pending tree:', e);
                            }

                            // Now authenticate and subscribe
                            initFirebaseAuth().then(() => {
                                firebaseSyncState.roomId = roomParam;
                                firebaseSyncState.isConnected = true;
                                subscribeToRoom(roomParam);
                                updateSyncUI();

                                // BUILD 268: Show floating chat for guests (not host)
                                floatingChatState.isHost = false;
                                floatingChatState.previousUserCount = 1;
                                showFloatingChat();
                            });
                        }, 500);
                    } else {
                        // No pending data, do a fresh join
                        setTimeout(() => {
                            initFirebaseAuth().then(() => {
                                joinSyncRoom(roomParam);
                            });
                        }, 1000);
                    }
                }

                console.log('ðŸ”¥ Firebase Live Sync initialized');
            });

            // Hook into tree changes to auto-sync
            // We'll create a debounced sync function that watches the save indicator
            let syncDebounceTimer = null;
            let lastTreeHash = null;
            // BUILD 327: Track pending local changes to prevent loss during remote sync
            let hasPendingLocalChanges = false;

            // Expose hasPendingLocalChanges for snapshot handler
            window.firebaseHasPendingLocalChanges = () => hasPendingLocalChanges;
            window.firebaseFlushPendingChanges = async () => {
                if (hasPendingLocalChanges && syncDebounceTimer) {
                    clearTimeout(syncDebounceTimer);
                    syncDebounceTimer = null;
                    hasPendingLocalChanges = false;
                    console.log('ðŸ”¥ Flushing pending local changes before accepting remote...');
                    await pushTreeToRoom();
                }
            };

            // Simple hash function for tree comparison
            function simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash |= 0;
                }
                return hash;
            }

            // Check for tree changes periodically
            setInterval(() => {
                if (!firebaseSyncState.isConnected || !window.capexTree) return;

                const treeStr = JSON.stringify(window.capexTree);
                const currentHash = simpleHash(treeStr);

                if (lastTreeHash !== null && currentHash !== lastTreeHash) {
                    // Tree changed, debounce sync
                    clearTimeout(syncDebounceTimer);
                    hasPendingLocalChanges = true; // BUILD 327: Mark changes as pending
                    syncDebounceTimer = setTimeout(() => {
                        console.log('ðŸ”¥ Tree change detected, syncing...');
                        hasPendingLocalChanges = false; // BUILD 327: Clear pending flag after push
                        pushTreeToRoom();
                    }, 500);
                }

                lastTreeHash = currentHash;
            }, 2000); // Check every 2 seconds

        })();

        /**
         * Parse a branch from URL parameter
         * @param {string} compressedBranch - LZString compressed branch data
         * @returns {object|null} Parsed branch or null on error
         */
        function parseBranchFromURL(compressedBranch) {
            try {
                const decompressed = LZString.decompressFromEncodedURIComponent(compressedBranch);
                if (!decompressed) {
                    console.error('âŒ Failed to decompress branch data');
                    return null;
                }
                const branch = JSON.parse(decompressed);
                console.log('ðŸ“¦ Parsed branch:', {
                    branchId: branch.branchId,
                    sourceProject: branch.sourceProjectName,
                    nodeCount: branch.nodes?.length,
                    createdBy: branch.createdBy
                });
                return branch;
            } catch (error) {
                console.error('âŒ Failed to parse branch:', error);
                return null;
            }
        }

        /**
         * Check if the current device is the original branch creator
         * @param {object} branch - Branch to check
         * @returns {boolean} True if this device created the branch
         */
        function isOriginalBranchCreator(branch) {
            const myFingerprint = getDeviceFingerprint();
            return branch.createdBy === myFingerprint;
        }

        /**
         * Enter branch editing mode (for collaborators)
         * @param {object} branch - The branch being edited
         */
        function enterBranchEditMode(branch) {
            currentBranch = branch;

            // Create a temporary tree from the branch nodes
            const tempTree = {
                id: `branch-edit-${branch.branchId}`,
                name: `Editing: ${branch.nodes[0]?.name || 'Shared Branch'}`,
                type: 'root',
                icon: 'ðŸ¤',
                description: `Shared from "${branch.sourceProjectName}" for collaboration`,
                pattern: { key: branch.sourcePattern },
                children: []
            };

            // If single node, wrap appropriately
            if (branch.nodes.length === 1 && branch.nodes[0].type === 'phase') {
                tempTree.children = branch.nodes;
            } else {
                // Create a container phase for the shared items
                tempTree.children = [{
                    id: 'shared-phase',
                    name: 'Shared Content',
                    type: 'phase',
                    icon: 'ðŸ“¦',
                    phaseNumber: 0,
                    expanded: true,
                    items: branch.nodes.filter(n => n.type === 'item' || n.type === 'subtask'),
                    showInCanvas: true
                }];
                // Also add any phases directly
                const phases = branch.nodes.filter(n => n.type === 'phase');
                if (phases.length > 0) {
                    tempTree.children = phases;
                }
            }

            // Set pattern
            if (branch.sourcePattern && PATTERNS[branch.sourcePattern]) {
                currentPattern = branch.sourcePattern;
            }

            // Load the branch as the current tree
            capexTree = tempTree;

            // Show the editing banner
            const banner = document.getElementById('branch-edit-banner');
            const info = document.getElementById('branch-edit-info');
            if (banner && info) {
                info.textContent = `From: ${branch.sourceProjectName} â€¢ ${branch.nodes.length} node(s)`;
                banner.style.display = 'block';

                // Adjust tree container to account for banner
                const treeContainer = document.querySelector('.tree-view-container');
                if (treeContainer) {
                    treeContainer.style.marginTop = '50px';
                }
            }

            // Render
            render();
            if (viewMode === 'canvas') {
                renderCanvas();
            }

            console.log('ðŸ¤ Entered branch editing mode:', branch.branchId);
        }

        /**
         * Exit branch editing mode
         */
        function exitBranchEditMode() {
            if (!currentBranch) return;

            if (confirm('Exit editing mode? Any unsaved changes will be lost.\n\nTip: Use "Share Back" to send your changes before exiting.')) {
                currentBranch = null;

                // Hide banner
                const banner = document.getElementById('branch-edit-banner');
                if (banner) {
                    banner.style.display = 'none';
                }

                // Reset tree container margin
                const treeContainer = document.querySelector('.tree-view-container');
                if (treeContainer) {
                    treeContainer.style.marginTop = '0';
                }

                // Load default tree
                capexTree = JSON.parse(JSON.stringify(defaultCapexTree));
                render();
                if (viewMode === 'canvas') {
                    renderCanvas();
                }

                // Clear URL parameter
                window.history.replaceState({}, document.title, window.location.pathname);

                console.log('ðŸ‘‹ Exited branch editing mode');
            }
        }

        /**
         * Share back the edited branch to the original creator
         */
        function shareBackBranch() {
            if (!currentBranch) {
                console.error('âŒ No branch to share back');
                return;
            }

            // Extract the edited nodes from current tree
            const editedNodes = [];

            // Collect all items and subtasks from the current tree
            function collectNodes(node) {
                if (node.type === 'item' || node.type === 'subtask' || node.type === 'phase') {
                    editedNodes.push(JSON.parse(JSON.stringify(node)));
                }
                if (node.children) node.children.forEach(collectNodes);
                if (node.items) node.items.forEach(collectNodes);
                if (node.subItems) node.subItems.forEach(collectNodes);
            }

            capexTree.children?.forEach(collectNodes);

            // Create a response branch
            const responseBranch = {
                ...currentBranch,
                branchId: `response-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                editedBy: getDeviceFingerprint(),
                editedAt: new Date().toISOString(),
                originalBranchId: currentBranch.branchId,
                nodes: editedNodes.length > 0 ? editedNodes : capexTree.children || [],
                isResponse: true
            };

            // Generate URL
            const shareURL = generateBranchURL(responseBranch);

            // Show the share modal with response context
            showShareBackModal(responseBranch, shareURL);
        }

        /**
         * Show the Share Back modal
         * @param {object} branch - Response branch
         * @param {string} shareURL - Shareable URL
         */
        function showShareBackModal(branch, shareURL) {
            const modal = document.getElementById('share-branch-modal');
            const body = document.getElementById('share-branch-body');

            // Count edited nodes
            let totalNodes = 0;
            function countNodes(n) {
                totalNodes++;
                if (n.items) n.items.forEach(countNodes);
                if (n.subItems) n.subItems.forEach(countNodes);
                if (n.children) n.children.forEach(countNodes);
            }
            branch.nodes.forEach(countNodes);

            body.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #6366f1; margin-bottom: 20px;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #6366f1;">
                            <span>ðŸ“¤</span> Sending Back Your Edits
                        </div>
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 0;">
                            Send this link to the original author so they can merge your changes into their project.
                        </p>
                    </div>

                    <!-- Stats -->
                    <div style="display: flex; gap: 20px; font-size: 13px; color: var(--text-secondary); margin-bottom: 16px; padding: 12px; background: var(--card-bg); border-radius: 6px;">
                        <div>ðŸ“Š ${totalNodes} nodes</div>
                        <div>ðŸ“ ${shareURL.length.toLocaleString()} characters</div>
                        <div>ðŸ  Original: ${branch.sourceProjectName}</div>
                    </div>

                    <!-- URL Input -->
                    <div style="background: var(--card-bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 12px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="share-branch-url-input" readonly
                                   style="flex: 1; background: var(--card-bg); border: 1px solid var(--border); color: var(--text-primary); padding: 10px; border-radius: 6px; font-family: monospace; font-size: 11px; user-select: all;"
                                   value="${shareURL}">
                        </div>
                    </div>

                    <!-- Instructions -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #10b981;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #10b981;">
                            <span>âœ…</span> Next Steps
                        </div>
                        <ol style="margin-left: 20px; color: var(--text-secondary); font-size: 13px; line-height: 1.8;">
                            <li>Copy the URL or click "Open Email"</li>
                            <li>Send to the original author</li>
                            <li>They'll see your changes and can merge them</li>
                        </ol>
                    </div>
                </div>
            `;

            // Store for email button
            pendingShareBranch = branch;

            modal.style.display = 'flex';

            // Select URL
            setTimeout(() => {
                const urlInput = document.getElementById('share-branch-url-input');
                if (urlInput) urlInput.select();
            }, 100);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // IMAGEN 4 - AI IMAGE GENERATION (Build 218)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Image style presets for Imagen 4
        const IMAGEN_STYLES = {
            whiteboard: {
                name: 'ðŸ“ Whiteboard Sketch',
                prompt: 'Hand-drawn cartoon whiteboard sketch style, dry-erase markers on glossy white surface with slight smudges and imperfect lines. Stick-figure characters with expressive faces and speech bubbles. Chunky arrows in blue red and green marker connecting ideas. Key concepts inside wobbly rectangles or circled in red. Doodle icons like lightbulbs gears checkmarks scattered as visual punctuation. Visible marker cap in corner for authenticity. Left-to-right flow with numbered steps and branching paths. Handwritten-style lettering with uneven baselines and occasional ALL-CAPS emphasis. Friendly irreverent tone like a colleague sketching during a brainstorm.',
                description: 'Meeting whiteboard with markers and doodles'
            },
            meeting: {
                name: 'ðŸ¤ Meeting Sketch',
                prompt: 'Whiteboard surface with black marker flowchart boxes connected by curved arrows, bright yellow and pink sticky notes clustered around corners. Bold "START" lettering left side, green checkmark "DONE" right side. Red marker circles highlighting decision points. Simple stick figures drawn pointing upward. Faded coffee ring stain lower right, slightly smudged marker lines, warm fluorescent lighting casting subtle shadows.',
                description: 'Collaborative meeting room style'
            },
            infographic: {
                name: 'ðŸ“Š Infographic',
                prompt: 'Crisp vector graphics with navy blue, teal, and orange color scheme, clean white background with subtle grid lines, geometric bar charts and pie segments, minimalist sans-serif typography, balanced asymmetrical layout with generous white space, sharp edges and perfectly aligned elements, corporate presentation aesthetic',
                description: 'Professional data visualization'
            },
            cartoon: {
                name: 'ðŸŽ¨ Friendly Cartoon',
                prompt: 'Soft rounded characters with oversized friendly eyes and gentle smiles, painted in warm peach, mint green, and lavender pastels. Smooth brushstroke textures with subtle paper grain, diffused golden lighting creating gentle shadows. Slightly imperfect hand-drawn line quality with organic curves and asymmetrical charm typical of beloved children\'s storybooks.',
                description: 'Approachable cartoon style'
            },
            tech: {
                name: 'ðŸ’» Tech/Digital',
                prompt: 'Deep charcoal to midnight blue gradient background with subtle scan lines, electric cyan and violet neon light strips casting soft glows, sleek matte black surfaces with fingerprint smudges, floating holographic interface panels with slight transparency, cool LED reflections on brushed metal textures, atmospheric depth with gentle light bloom',
                description: 'Futuristic technology theme'
            },
            nature: {
                name: 'ðŸŒ¿ Nature/Organic',
                prompt: 'Soft watercolor washes bleeding into textured paper, warm ochre and sage green pigments, delicate botanical forms with visible brush strokes, gentle morning light filtering through leaves, subtle paper grain texture, hand-painted imperfections with organic edge bleeding, peaceful garden atmosphere with dappled shadows',
                description: 'Natural organic aesthetic'
            },
            minimal: {
                name: 'â¬œ Minimalist',
                prompt: 'Stark white background with vast empty space, single bold geometric shape in muted sage green or charcoal gray, crisp shadow casting subtle depth, pristine surfaces with barely visible texture, soft diffused lighting from above, perfectly aligned elements with breathing room, serene gallery-like atmosphere',
                description: 'Clean minimal design'
            },
            isometric: {
                name: 'ðŸ—ï¸ Isometric 3D',
                prompt: 'Crisp isometric 3D perspective at 30-degree angles, bold saturated colors with subtle gradients, clean geometric shapes casting soft drop shadows on white background, technical blueprint precision with rounded edges, smooth matte surfaces, organized grid composition, bright even lighting like modern mobile game interface',
                description: '3D isometric view'
            },
            academic: {
                name: 'ðŸ“š Academic/Scholarly',
                prompt: 'Detailed copper engraving with fine cross-hatching on aged cream paper, warm sepia and burnt umber tones, crisp black ink lines, subtle paper texture with faint foxing spots, classical diagram layout with numbered annotations, ornate serif typography, soft diffused lighting creating gentle shadows',
                description: 'Traditional scholarly look'
            }
        };

        /**
         * Show Imagen 4 modal for generating images from selected nodes
         * @param {Array} nodes - Array of nodes to generate image from
         */
        function showImagenModal(nodes) {
            // Check for Gemini API key
            const geminiKey = localStorage.getItem('gemini_api_key');
            if (!geminiKey) {
                alert('ðŸ”‘ Gemini API key required for image generation.\n\nGo to Settings (ðŸ”‘ button) and add your Gemini API key.');
                return;
            }

            // Get current pattern context
            const pattern = PATTERNS[currentPattern] || PATTERNS.generic;
            const patternName = pattern.name;

            // Generate rich context from nodes
            const nodeContext = nodes.map(n => {
                let text = `${n.icon || 'ðŸ“„'} ${n.name}`;
                if (n.description) text += `: ${n.description}`;
                return text;
            }).join('\n');

            // Build style selector HTML
            const styleOptions = Object.entries(IMAGEN_STYLES).map(([key, style]) =>
                `<button type="button" class="imagen-style-btn" data-style="${key}" title="${style.description}" style="padding: 8px 12px; border: 2px solid var(--border); border-radius: 8px; background: var(--card-bg); color: var(--text-primary); cursor: pointer; font-size: 12px; transition: all 0.2s;">${style.name}</button>`
            ).join('');

            // Remove existing modal
            const existing = document.getElementById('imagen-modal');
            if (existing) existing.remove();

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'imagen-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            modal.innerHTML = `
                <div style="background: var(--card-bg); border-radius: 16px; max-width: 750px; width: 95%; max-height: 90vh; overflow-y: auto; border: 2px solid var(--border); box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);">
                    <div style="padding: 20px 24px; border-bottom: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <h2 style="margin: 0; font-size: 18px; display: flex; align-items: center; gap: 10px;">
                                ðŸŒ Generate Image with Nano Banana
                            </h2>
                            <button id="imagen-close" style="background: transparent; border: none; color: var(--text-secondary); font-size: 24px; cursor: pointer; padding: 4px 8px;">&times;</button>
                        </div>
                    </div>

                    <div style="padding: 20px 24px;">
                        <!-- Node Context -->
                        <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08)); padding: 14px; border-radius: 10px; margin-bottom: 16px; border-left: 3px solid #6366f1;">
                            <div style="font-weight: 600; margin-bottom: 6px; color: #6366f1; font-size: 12px;">${pattern.icon} ${patternName} â€¢ ${nodes.length} node${nodes.length > 1 ? 's' : ''}</div>
                            <div style="font-size: 12px; color: var(--text-secondary); white-space: pre-line; max-height: 80px; overflow-y: auto; line-height: 1.5;">${nodeContext}</div>
                        </div>

                        <!-- Style Presets -->
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 10px; font-size: 13px;">ðŸŽ­ Visual Style</label>
                            <div id="imagen-styles" style="display: flex; flex-wrap: wrap; gap: 8px;">
                                ${styleOptions}
                            </div>
                        </div>

                        <!-- AI Enhance Button -->
                        <div style="margin-bottom: 16px;">
                            <button id="imagen-ai-enhance" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                                âœ¨ AI Craft Prompt (uses your selected style + node context)
                            </button>
                        </div>

                        <!-- Prompt Input -->
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 13px;">Image Prompt <span style="font-weight: normal; color: var(--text-secondary);">(15-25 words ideal)</span></label>
                            <textarea id="imagen-prompt" placeholder="Select a style and click 'AI Craft Prompt' for best results..." style="width: 100%; min-height: 80px; padding: 12px; border-radius: 8px; border: 2px solid var(--border); background: var(--card-bg); color: var(--text-primary); font-size: 13px; resize: vertical; line-height: 1.5;"></textarea>
                            <div style="display: flex; justify-content: space-between; margin-top: 6px; font-size: 11px; color: var(--text-secondary);">
                                <span id="imagen-word-count">0 words</span>
                                <span>ðŸ’¡ Tip: Subject first, then style, then lighting</span>
                            </div>
                        </div>

                        <!-- Options Row -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 12px;">ðŸ“ Aspect Ratio</label>
                                <select id="imagen-aspect" style="width: 100%; padding: 10px; border-radius: 8px; border: 2px solid var(--border); background: var(--card-bg); color: var(--text-primary); font-size: 13px;">
                                    <option value="16:9" selected>16:9 (Widescreen)</option>
                                    <option value="1:1">1:1 (Square)</option>
                                    <option value="4:3">4:3 (Standard)</option>
                                    <option value="3:4">3:4 (Portrait)</option>
                                    <option value="9:16">9:16 (Tall)</option>
                                </select>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 12px;">ðŸ–¼ï¸ Model</label>
                                <select id="imagen-model" style="width: 100%; padding: 10px; border-radius: 8px; border: 2px solid var(--border); background: var(--card-bg); color: var(--text-primary); font-size: 13px;">
                                    <option value="gemini-2.5-flash-preview-05-20" selected>ðŸŒ Nano Banana (Gemini 2.5 Flash)</option>
                                    <option value="gemini-2.5-pro-preview-05-06">ðŸŒ Nano Banana Pro (Gemini 2.5 Pro)</option>
                                    <option value="imagen-4.0-generate-001">ðŸŽ¨ Imagen 4 Standard</option>
                                    <option value="imagen-4.0-ultra-generate-001">âœ¨ Imagen 4 Ultra</option>
                                </select>
                            </div>
                        </div>

                        <!-- Resolution (for Nano Banana Pro) -->
                        <div id="imagen-resolution-row" style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 12px;">ðŸ“º Resolution</label>
                            <div style="display: flex; gap: 8px;">
                                <button type="button" class="imagen-res-btn" data-res="1K" style="flex: 1; padding: 8px; border: 2px solid var(--border); border-radius: 8px; background: var(--card-bg); color: var(--text-primary); cursor: pointer; font-size: 12px;">1K</button>
                                <button type="button" class="imagen-res-btn selected" data-res="2K" style="flex: 1; padding: 8px; border: 2px solid #6366f1; border-radius: 8px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2)); color: var(--text-primary); cursor: pointer; font-size: 12px;">2K</button>
                                <button type="button" class="imagen-res-btn" data-res="4K" style="flex: 1; padding: 8px; border: 2px solid var(--border); border-radius: 8px; background: var(--card-bg); color: var(--text-primary); cursor: pointer; font-size: 12px;">4K ($$$)</button>
                            </div>
                        </div>

                        <!-- Generate Button -->
                        <button id="imagen-generate" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 12px; font-size: 15px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ðŸŒ Generate with Nano Banana
                        </button>

                        <!-- Results Container -->
                        <div id="imagen-results" style="margin-top: 20px; display: none;">
                            <div style="font-weight: 600; margin-bottom: 12px; font-size: 14px;">Generated Images <span style="font-weight: normal; color: var(--text-secondary);">(click to preview)</span></div>
                            <div id="imagen-images" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;"></div>
                        </div>

                        <!-- Error Container -->
                        <div id="imagen-error" style="margin-top: 20px; display: none; background: rgba(239, 68, 68, 0.1); padding: 16px; border-radius: 8px; border-left: 3px solid #ef4444; color: #ef4444;"></div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Store selected nodes and style for AI enhance
            modal.dataset.nodeIds = JSON.stringify(nodes.map(n => n.id));
            modal.dataset.selectedStyle = 'whiteboard'; // default

            // Style button click handlers
            const styleButtons = modal.querySelectorAll('.imagen-style-btn');
            styleButtons.forEach(btn => {
                btn.onclick = () => {
                    // Remove selection from all
                    styleButtons.forEach(b => {
                        b.style.background = 'var(--card-bg)';
                        b.style.borderColor = 'var(--border)';
                    });
                    // Select this one
                    btn.style.background = 'linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2))';
                    btn.style.borderColor = '#6366f1';
                    modal.dataset.selectedStyle = btn.dataset.style;
                };
            });

            // Select first style by default
            if (styleButtons.length > 0) {
                styleButtons[0].click();
            }

            // Word count updater
            const promptTextarea = document.getElementById('imagen-prompt');
            const wordCountSpan = document.getElementById('imagen-word-count');
            promptTextarea.oninput = () => {
                const words = promptTextarea.value.trim().split(/\s+/).filter(w => w.length > 0).length;
                wordCountSpan.textContent = `${words} words`;
                wordCountSpan.style.color = words >= 15 && words <= 25 ? '#10b981' : 'var(--text-secondary)';
            };

            // AI Enhance button handler
            document.getElementById('imagen-ai-enhance').onclick = () => aiCraftImagenPrompt(nodes, modal.dataset.selectedStyle);

            // Resolution button handlers
            modal.dataset.selectedRes = '2K'; // default
            const resButtons = modal.querySelectorAll('.imagen-res-btn');
            resButtons.forEach(btn => {
                btn.onclick = () => {
                    resButtons.forEach(b => {
                        b.style.background = 'var(--card-bg)';
                        b.style.borderColor = 'var(--border)';
                    });
                    btn.style.background = 'linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2))';
                    btn.style.borderColor = '#6366f1';
                    modal.dataset.selectedRes = btn.dataset.res;
                };
            });

            // Model change handler - update button text (Build 261: Fixed Imagen 4 models)
            const modelSelect = document.getElementById('imagen-model');
            const generateBtn = document.getElementById('imagen-generate');
            const resolutionRow = document.getElementById('imagen-resolution-row');

            modelSelect.onchange = () => {
                const model = modelSelect.value;
                if (model.includes('gemini-2.5-pro')) {
                    generateBtn.textContent = 'ðŸŒ Generate with Nano Banana Pro';
                    generateBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                    resolutionRow.style.display = 'block'; // Pro supports 2K/4K
                } else if (model.includes('gemini-2.5-flash')) {
                    generateBtn.textContent = 'ðŸŒ Generate with Nano Banana';
                    generateBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                    resolutionRow.style.display = 'none';
                } else if (model.includes('ultra')) {
                    generateBtn.textContent = 'âœ¨ Generate with Imagen 4 Ultra';
                    generateBtn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
                    resolutionRow.style.display = 'none';
                } else {
                    generateBtn.textContent = 'ðŸŽ¨ Generate with Imagen 4';
                    generateBtn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
                    resolutionRow.style.display = 'none';
                }
            };
            // Hide resolution row by default (Nano Banana Flash selected)
            resolutionRow.style.display = 'none';

            // Close handlers
            document.getElementById('imagen-close').onclick = () => modal.remove();
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

            // Generate handler
            document.getElementById('imagen-generate').onclick = () => generateImagenImage(nodes);
        }

        /**
         * Use AI to craft an optimized Imagen 4 prompt
         * @param {Array} nodes - Selected nodes
         * @param {string} styleKey - Selected style key
         */
        async function aiCraftImagenPrompt(nodes, styleKey) {
            const style = IMAGEN_STYLES[styleKey] || IMAGEN_STYLES.whiteboard;
            const pattern = PATTERNS[currentPattern] || PATTERNS.generic;
            const enhanceBtn = document.getElementById('imagen-ai-enhance');
            const promptTextarea = document.getElementById('imagen-prompt');

            // Build node context
            const nodeContext = nodes.map(n => {
                let text = n.name;
                if (n.description) text += ` - ${n.description}`;
                if (n.itemType) text += ` (${n.itemType})`;
                return text;
            }).join('; ');

            // Show loading
            enhanceBtn.disabled = true;
            enhanceBtn.innerHTML = 'âœ¨ Crafting prompt...';

            try {
                // Use Gemini to craft the prompt
                const geminiKey = localStorage.getItem('gemini_api_key');
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${geminiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `You are an expert at writing prompts for Google's Imagen 4 image generation model.

Create a single, optimized image prompt (15-25 words) for visualizing this concept:

CONTEXT:
- Pattern: ${pattern.name} (${pattern.description || ''})
- Nodes: ${nodeContext}
- Visual Style: ${style.name} - ${style.prompt}

IMAGEN 4 BEST PRACTICES:
- Put the main subject FIRST
- Use specific visual descriptors (lighting, composition, mood)
- Include the style keywords naturally
- Keep it 15-25 words for best results
- Make it fun, approachable, and educational

Return ONLY the prompt text, nothing else. No quotes, no explanation.`
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.8,
                            maxOutputTokens: 100
                        }
                    })
                });

                const data = await response.json();
                const craftedPrompt = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

                if (craftedPrompt) {
                    promptTextarea.value = craftedPrompt;
                    promptTextarea.dispatchEvent(new Event('input')); // Update word count
                    showToast('âœ¨ AI crafted your prompt!');
                } else {
                    throw new Error('No prompt generated');
                }

            } catch (error) {
                console.error('AI prompt craft error:', error);
                // Fallback to a template-based prompt
                const subjects = nodes.map(n => n.name).join(' and ');
                promptTextarea.value = `${subjects} visualized as ${style.name.replace(/[ðŸ“ðŸ“ŠðŸŽ¨ðŸ’»ðŸŒ¿â¬œðŸ—ï¸ðŸ“š]/g, '').trim()}, ${style.prompt.split(',').slice(0, 3).join(', ')}`;
                promptTextarea.dispatchEvent(new Event('input'));
                showToast('Used template prompt (AI unavailable)');
            } finally {
                enhanceBtn.disabled = false;
                enhanceBtn.innerHTML = 'âœ¨ AI Craft Prompt (uses your selected style + node context)';
            }
        }

        /**
         * Call Nano Banana (Gemini) or Imagen 4 API to generate images
         * @param {Array} nodes - Nodes to potentially attach the image to
         */
        async function generateImagenImage(nodes) {
            const prompt = document.getElementById('imagen-prompt').value.trim();
            const aspectRatio = document.getElementById('imagen-aspect').value;
            const modelId = document.getElementById('imagen-model').value;
            const geminiKey = localStorage.getItem('gemini_api_key');
            const modal = document.getElementById('imagen-modal');
            const resolution = modal?.dataset?.selectedRes || '2K';

            if (!prompt) {
                alert('Please enter an image prompt');
                return;
            }

            const generateBtn = document.getElementById('imagen-generate');
            const resultsDiv = document.getElementById('imagen-results');
            const imagesDiv = document.getElementById('imagen-images');
            const errorDiv = document.getElementById('imagen-error');

            // Determine model type for loading message
            const isNanoBanana = modelId.includes('gemini-2.5');
            const loadingText = isNanoBanana ? 'Generating with Nano Banana...' : 'Generating with Imagen 4...';

            // Show loading state
            generateBtn.disabled = true;
            generateBtn.innerHTML = `<span class="spinner" style="border: 2px solid transparent; border-top: 2px solid white; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: inline-block;"></span> ${loadingText}`;
            resultsDiv.style.display = 'none';
            errorDiv.style.display = 'none';

            try {
                let images = [];

                if (isNanoBanana) {
                    // BUILD 317: Nano Banana uses Gemini generateContent endpoint
                    console.log(`ðŸŒ Using Nano Banana model: ${modelId}`);

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${geminiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: `Generate an image: ${prompt}`
                                }]
                            }],
                            generationConfig: {
                                responseModalities: ['TEXT', 'IMAGE']
                            }
                        })
                    });

                    const data = await response.json();
                    console.log('Nano Banana response:', data);

                    if (!response.ok) {
                        throw new Error(data.error?.message || `API error: ${response.status}`);
                    }

                    // Extract images from Gemini response (inline_data format)
                    if (data.candidates && data.candidates[0]?.content?.parts) {
                        data.candidates[0].content.parts.forEach(part => {
                            if (part.inlineData?.data) {
                                images.push(part.inlineData.data);
                            }
                        });
                    }

                    if (images.length === 0) {
                        throw new Error('No images generated. Nano Banana may have declined the prompt. Try a different description.');
                    }
                } else {
                    // Imagen 4 uses predict endpoint
                    console.log(`ðŸŽ¨ Using Imagen 4 model: ${modelId}`);

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:predict?key=${geminiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            instances: [{ prompt: prompt }],
                            parameters: {
                                sampleCount: 4,
                                aspectRatio: aspectRatio,
                                personGeneration: 'allow_adult'
                            }
                        })
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error?.message || `API error: ${response.status}`);
                    }

                    // Extract images from Imagen 4 response
                    if (!data.predictions || data.predictions.length === 0) {
                        throw new Error('No images generated. Try a different prompt.');
                    }

                    data.predictions.forEach(pred => {
                        if (pred.bytesBase64Encoded) {
                            images.push(pred.bytesBase64Encoded);
                        }
                    });
                }

                // Display images
                imagesDiv.innerHTML = '';
                images.forEach((base64, idx) => {
                    const imgContainer = document.createElement('div');
                    imgContainer.style.cssText = 'position: relative; border-radius: 12px; overflow: hidden; border: 2px solid var(--border); cursor: pointer;';

                    const img = document.createElement('img');
                    img.src = `data:image/png;base64,${base64}`;
                    img.style.cssText = 'width: 100%; height: auto; display: block;';
                    img.alt = `Generated image ${idx + 1}`;

                    // Click image to view full-size
                    img.onclick = (e) => {
                        e.stopPropagation();
                        showImagePreview(base64, prompt, nodes, idx + 1);
                    };

                    // Hover hint
                    const viewHint = document.createElement('div');
                    viewHint.textContent = 'ðŸ” Click to view full size';
                    viewHint.style.cssText = `
                        position: absolute;
                        top: 8px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0,0,0,0.7);
                        color: white;
                        padding: 4px 12px;
                        border-radius: 12px;
                        font-size: 11px;
                        opacity: 0;
                        transition: opacity 0.2s;
                        pointer-events: none;
                    `;

                    // Add "Attach to Node" button
                    const attachBtn = document.createElement('button');
                    attachBtn.textContent = 'ðŸ“Ž Attach';
                    attachBtn.style.cssText = `
                        position: absolute;
                        bottom: 8px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0,0,0,0.8);
                        color: white;
                        border: none;
                        padding: 6px 14px;
                        border-radius: 20px;
                        font-size: 11px;
                        cursor: pointer;
                        opacity: 0;
                        transition: opacity 0.2s;
                    `;
                    imgContainer.onmouseenter = () => {
                        attachBtn.style.opacity = '1';
                        viewHint.style.opacity = '1';
                    };
                    imgContainer.onmouseleave = () => {
                        attachBtn.style.opacity = '0';
                        viewHint.style.opacity = '0';
                    };

                    attachBtn.onclick = (e) => {
                        e.stopPropagation();
                        attachImageToNode(nodes[0], base64, prompt);
                        const modal = document.getElementById('imagen-modal');
                        if (modal) modal.remove();
                    };

                    imgContainer.appendChild(img);
                    imgContainer.appendChild(viewHint);
                    imgContainer.appendChild(attachBtn);
                    imagesDiv.appendChild(imgContainer);
                });

                resultsDiv.style.display = 'block';

            } catch (error) {
                console.error('Imagen error:', error);
                errorDiv.textContent = `Error: ${error.message}`;
                errorDiv.style.display = 'block';
            } finally {
                generateBtn.disabled = false;
                // Build 261: Restore button text based on selected Imagen 4 model
                const currentModel = document.getElementById('imagen-model').value;
                if (currentModel.includes('ultra')) {
                    generateBtn.innerHTML = 'âœ¨ Generate with Imagen 4 Ultra';
                } else if (currentModel.includes('fast')) {
                    generateBtn.innerHTML = 'âš¡ Generate with Imagen 4 Fast';
                } else {
                    generateBtn.innerHTML = 'ðŸŽ¨ Generate with Imagen 4';
                }
            }
        }

        /**
         * Attach generated image to a node
         * @param {object} node - The node to attach image to
         * @param {string} base64 - Base64 encoded image data
         * @param {string} prompt - The prompt used to generate the image
         */
        function attachImageToNode(node, base64, prompt) {
            const modelId = document.getElementById('imagen-model')?.value || 'unknown';
            const modelName = modelId.includes('gemini-3') ? 'Nano Banana Pro' :
                             modelId.includes('gemini-2') ? 'Nano Banana' : 'Imagen 4';
            // Store image data in node
            node.generatedImage = {
                data: base64,
                prompt: prompt,
                model: modelName,
                generatedAt: new Date().toISOString()
            };

            // Save state for undo
            if (typeof saveState === 'function') {
                saveState('Attach generated image');
            }

            // Re-render to show image
            if (typeof renderCanvas === 'function') {
                renderCanvas();
            }
            if (typeof renderTree === 'function') {
                renderTree();
            }

            // Show confirmation
            showToast(`ðŸŽ¨ Image attached to "${node.name}"`);
        }

        /**
         * Show full-size image preview with options to attach or download
         * @param {string} base64 - Base64 encoded image data
         * @param {string} prompt - The prompt used to generate the image
         * @param {Array} nodes - Nodes to potentially attach to
         * @param {number} imageNum - Image number (1-4)
         */
        function showImagePreview(base64, prompt, nodes, imageNum) {
            // Remove existing preview
            const existing = document.getElementById('imagen-preview');
            if (existing) existing.remove();

            const preview = document.createElement('div');
            preview.id = 'imagen-preview';
            preview.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.95);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 10002;
                padding: 20px;
                box-sizing: border-box;
            `;

            preview.innerHTML = `
                <div style="position: absolute; top: 20px; right: 20px; display: flex; gap: 12px;">
                    <button id="preview-download" style="background: #3b82f6; color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
                        ðŸ’¾ Download
                    </button>
                    <button id="preview-attach" style="background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
                        ðŸ“Ž Attach to Node
                    </button>
                    <button id="preview-close" style="background: #6b7280; color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 14px; cursor: pointer;">
                        âœ• Close
                    </button>
                </div>

                <div style="flex: 1; display: flex; align-items: center; justify-content: center; max-height: calc(100vh - 180px); width: 100%;">
                    <img src="data:image/png;base64,${base64}" style="max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 8px; box-shadow: 0 25px 50px rgba(0,0,0,0.5);" alt="Generated image ${imageNum}">
                </div>

                <div style="position: absolute; bottom: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.8); padding: 16px 20px; border-radius: 12px; max-width: 800px; margin: 0 auto;">
                    <div style="font-size: 12px; color: #9ca3af; margin-bottom: 4px;">Image ${imageNum} â€¢ Imagen 4 â€¢ Prompt:</div>
                    <div style="font-size: 13px; color: white; line-height: 1.5; max-height: 60px; overflow-y: auto;">${prompt}</div>
                </div>
            `;

            document.body.appendChild(preview);

            // Event handlers
            document.getElementById('preview-close').onclick = () => preview.remove();
            preview.onclick = (e) => { if (e.target === preview) preview.remove(); };

            document.getElementById('preview-download').onclick = () => {
                const link = document.createElement('a');
                link.href = `data:image/png;base64,${base64}`;
                link.download = `treelisty-imagen-${Date.now()}.png`;
                link.click();
                showToast('ðŸ’¾ Image downloaded');
            };

            document.getElementById('preview-attach').onclick = () => {
                attachImageToNode(nodes[0], base64, prompt);
                preview.remove();
                const modal = document.getElementById('imagen-modal');
                if (modal) modal.remove();
            };

            // Keyboard shortcuts
            const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                    preview.remove();
                    document.removeEventListener('keydown', handleKeydown);
                }
            };
            document.addEventListener('keydown', handleKeydown);
        }

        /**
         * Show a toast notification
         * @param {string} message - Message to display
         */
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: #10b981;
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10001;
                animation: fadeInUp 0.3s ease;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        /**
         * Show merge modal for incoming edited branch
         * @param {object} branch - The edited branch to potentially merge
         */
        function showMergeBranchModal(branch) {
            const modal = document.getElementById('merge-branch-modal');
            const body = document.getElementById('merge-branch-body');

            // Check if current project matches the source project
            const projectMismatch = capexTree.id !== branch.sourceProjectId &&
                                    capexTree.name !== branch.sourceProjectName;

            // Store branch for later (needed if user loads correct project)
            pendingMergeBranch = branch;

            // If project doesn't match, show warning modal instead
            if (projectMismatch) {
                body.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.1)); padding: 20px; border-radius: 8px; border-left: 3px solid #ef4444; margin-bottom: 20px;">
                            <div style="font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; color: #ef4444; font-size: 16px;">
                                <span>âš ï¸</span> Wrong Project Loaded
                            </div>
                            <p style="color: var(--text-secondary); font-size: 14px; margin: 0 0 12px 0;">
                                This collaboration response was created from a different project. You need to load the original project first.
                            </p>
                        </div>

                        <!-- Project Comparison -->
                        <div style="background: var(--card-bg); padding: 15px; border-radius: 8px; margin-bottom: 16px;">
                            <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 16px; font-size: 13px;">
                                <span style="color: var(--text-secondary);">Expected project:</span>
                                <span style="font-weight: 600; color: #10b981;">"${branch.sourceProjectName}"</span>

                                <span style="color: var(--text-secondary);">Currently loaded:</span>
                                <span style="font-weight: 600; color: #ef4444;">"${capexTree.name}"</span>
                            </div>
                        </div>

                        <!-- Instructions -->
                        <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #6366f1;">
                            <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #6366f1;">
                                <span>ðŸ“‹</span> How to Merge
                            </div>
                            <ol style="margin-left: 20px; color: var(--text-secondary); font-size: 13px; line-height: 1.8;">
                                <li>Close this modal</li>
                                <li>Load the project <strong>"${branch.sourceProjectName}"</strong> (File â†’ Open JSON)</li>
                                <li>Go to <strong>File â†’ Merge Branch</strong> and paste the URL from your email</li>
                                <li>The merge will proceed correctly</li>
                            </ol>
                        </div>

                        <!-- Alternative: Force merge anyway -->
                        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
                            <p style="color: var(--text-secondary); font-size: 12px; margin-bottom: 8px;">
                                <strong>Alternative:</strong> If you want to add these nodes to the current project anyway, you can force the merge.
                                The nodes will be added but may not replace the originals.
                            </p>
                        </div>
                    </div>
                `;

                // Update buttons for mismatch state
                const acceptBtn = document.getElementById('merge-branch-accept');
                if (acceptBtn) {
                    acceptBtn.textContent = 'âš¡ Force Merge Anyway';
                    acceptBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                }

                modal.style.display = 'flex';
                return;
            }

            // Count nodes
            let totalNodes = 0;
            function countNodes(n) {
                totalNodes++;
                if (n.items) n.items.forEach(countNodes);
                if (n.subItems) n.subItems.forEach(countNodes);
                if (n.children) n.children.forEach(countNodes);
            }
            branch.nodes.forEach(countNodes);

            // Build ancestry breadcrumb
            const breadcrumb = branch.ancestry?.map(a =>
                `<span style="display: inline-flex; align-items: center; gap: 4px;">${a.icon || 'ðŸ“„'} ${a.name}</span>`
            ).join(' <span style="color: var(--text-secondary);">â€º</span> ') || 'Root';

            // Build node preview
            const nodePreview = branch.nodes.slice(0, 5).map(n => `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--card-bg); border-radius: 6px; margin-bottom: 6px;">
                    <span>${n.icon || 'ðŸ“„'}</span>
                    <span style="font-weight: 500;">${n.name}</span>
                    <span style="font-size: 11px; color: var(--text-secondary);">(${n.type})</span>
                </div>
            `).join('');

            body.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(217, 119, 6, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #f59e0b; margin-bottom: 20px;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #f59e0b;">
                            <span>ðŸ”€</span> Incoming Collaboration Changes
                        </div>
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 0;">
                            A collaborator has edited your shared branch and sent back changes for you to merge.
                        </p>
                    </div>

                    <!-- Branch Info -->
                    <div style="background: var(--card-bg); padding: 15px; border-radius: 8px; margin-bottom: 16px;">
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 16px; font-size: 13px;">
                            <span style="color: var(--text-secondary);">Original Location:</span>
                            <span>${breadcrumb}</span>

                            <span style="color: var(--text-secondary);">Edited by:</span>
                            <span style="font-family: monospace; font-size: 11px;">${branch.editedBy || 'Unknown'}</span>

                            <span style="color: var(--text-secondary);">Edited at:</span>
                            <span>${branch.editedAt ? new Date(branch.editedAt).toLocaleString() : 'Unknown'}</span>

                            <span style="color: var(--text-secondary);">Nodes:</span>
                            <span>${totalNodes} total</span>
                        </div>
                    </div>

                    <!-- Node Preview -->
                    <div style="margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                            ðŸ“¦ Changed Nodes (preview):
                        </div>
                        <div style="max-height: 200px; overflow-y: auto; padding-right: 8px;">
                            ${nodePreview}
                            ${branch.nodes.length > 5 ? `<div style="color: var(--text-secondary); font-size: 12px; padding: 8px;">...and ${branch.nodes.length - 5} more</div>` : ''}
                        </div>
                    </div>

                    <!-- Warning -->
                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.1)); padding: 15px; border-radius: 8px; border-left: 3px solid #ef4444;">
                        <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; color: #ef4444;">
                            <span>âš ï¸</span> Merge Warning
                        </div>
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 0;">
                            Merging will <strong>replace</strong> the original nodes at the specified location with the edited versions.
                            This action can be undone using Ctrl+Z.
                        </p>
                    </div>
                </div>
            `;

            // Reset button state (in case previous modal showed mismatch warning)
            const acceptBtn = document.getElementById('merge-branch-accept');
            if (acceptBtn) {
                acceptBtn.textContent = 'âœ… Accept & Merge Changes';
                acceptBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
            }

            modal.style.display = 'flex';
        }

        /**
         * Perform the actual merge of a branch into the tree
         * @param {object} branch - The branch to merge
         */
        function performBranchMerge(branch) {
            if (!branch || !branch.nodes || branch.nodes.length === 0) {
                console.error('âŒ Invalid branch for merge');
                return;
            }

            console.log('ðŸ”€ Starting merge with branch:', branch.branchId);
            console.log('ðŸ”€ Branch nodes:', branch.nodes.map(n => ({ id: n.id, name: n.name, desc: n.description?.substring(0, 30) })));

            // Save undo state
            saveState('Merge collaboration branch');

            // Find the insertion point using ancestry
            const ancestry = branch.ancestry || [];
            let insertionParent = capexTree;

            // Navigate to the parent location
            for (const ancestor of ancestry) {
                if (ancestor.id === capexTree.id) continue; // Skip root

                const found = findNodeInTree(insertionParent, ancestor.id);
                if (found) {
                    insertionParent = found;
                } else {
                    console.warn(`âš ï¸ Could not find ancestor ${ancestor.id}, merging at current level`);
                    break;
                }
            }

            // For each node in the branch, find and replace or add
            for (const incomingNode of branch.nodes) {
                const existingNode = findNodeInTree(capexTree, incomingNode.id);
                console.log('ðŸ”€ Processing:', incomingNode.id, '| existing:', !!existingNode);

                if (existingNode) {
                    console.log('ðŸ”€ Before merge - existing:', existingNode.name, '| desc:', existingNode.description?.substring(0, 30));
                    console.log('ðŸ”€ Incoming:', incomingNode.name, '| desc:', incomingNode.description?.substring(0, 30));

                    // Deep merge: replace all properties from incoming node
                    // This preserves the object reference but updates all content
                    for (const key of Object.keys(existingNode)) {
                        if (key !== 'id') { // Never change ID
                            delete existingNode[key];
                        }
                    }
                    for (const key of Object.keys(incomingNode)) {
                        existingNode[key] = JSON.parse(JSON.stringify(incomingNode[key]));
                    }
                    console.log('ðŸ”€ After merge:', existingNode.name, '| desc:', existingNode.description?.substring(0, 30));
                    console.log(`âœ… Updated existing node: ${incomingNode.name}`);
                } else {
                    // Add as new node to insertion parent
                    if (incomingNode.type === 'phase') {
                        insertionParent.children = insertionParent.children || [];
                        insertionParent.children.push(incomingNode);
                    } else if (incomingNode.type === 'item') {
                        // Find appropriate phase or add to first phase
                        const targetPhase = insertionParent.children?.[0] || insertionParent;
                        targetPhase.items = targetPhase.items || [];
                        targetPhase.items.push(incomingNode);
                    } else {
                        // Subtask - find parent item
                        const parentItem = findParentForSubtask(capexTree, branch.selectedNodeIds);
                        if (parentItem) {
                            parentItem.subItems = parentItem.subItems || [];
                            parentItem.subItems.push(incomingNode);
                        }
                    }
                    console.log(`âž• Added new node: ${incomingNode.name}`);
                }
            }

            // Close modal
            document.getElementById('merge-branch-modal').style.display = 'none';
            pendingMergeBranch = null;

            // Clear URL parameter
            window.history.replaceState({}, document.title, window.location.pathname);

            // Re-render
            render();
            if (viewMode === 'canvas') {
                renderCanvas();
            }

            // Show success toast
            showToast('âœ… Changes merged successfully!', 'success');

            console.log('ðŸ”€ Branch merge completed:', branch.branchId);
        }

        /**
         * Find a node in the tree by ID
         * @param {object} node - Starting node
         * @param {string} id - ID to find
         * @returns {object|null} Found node or null
         */
        function findNodeInTree(node, id) {
            if (node.id === id) return node;

            if (node.children) {
                for (const child of node.children) {
                    const found = findNodeInTree(child, id);
                    if (found) return found;
                }
            }
            if (node.items) {
                for (const item of node.items) {
                    const found = findNodeInTree(item, id);
                    if (found) return found;
                }
            }
            if (node.subItems) {
                for (const subItem of node.subItems) {
                    const found = findNodeInTree(subItem, id);
                    if (found) return found;
                }
            }

            return null;
        }

        /**
         * Find parent item for a subtask
         * @param {object} tree - Tree to search
         * @param {string[]} nodeIds - Original node IDs
         * @returns {object|null} Parent item or null
         */
        function findParentForSubtask(tree, nodeIds) {
            // Try to find based on original selection
            // For now, return first item in tree
            if (tree.children?.[0]?.items?.[0]) {
                return tree.children[0].items[0];
            }
            return null;
        }

        /**
         * Show a toast notification
         * @param {string} message - Message to show
         * @param {string} type - 'success', 'error', 'warning'
         */
        function showToast(message, type = 'success') {
            const colors = {
                success: 'linear-gradient(135deg, #10b981, #059669)',
                error: 'linear-gradient(135deg, #ef4444, #dc2626)',
                warning: 'linear-gradient(135deg, #f59e0b, #d97706)'
            };

            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: ${colors[type] || colors.success};
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10001;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            document.body.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        /**
         * Handle branch URL on page load
         * Called from the main URL loading function
         */
        function handleBranchURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const branchParam = urlParams.get('branch');

            if (!branchParam) return false;

            console.log('ðŸ”— Branch URL detected, parsing...');

            const branch = parseBranchFromURL(branchParam);
            if (!branch) {
                showToast('âŒ Invalid branch URL', 'error');
                return false;
            }

            // Determine if this is a response (edited branch) or original share
            if (branch.isResponse) {
                // This is an edited branch being sent back - show merge dialog
                console.log('ðŸ“¥ Received edited branch for merge');
                showMergeBranchModal(branch);
            } else if (isOriginalBranchCreator(branch)) {
                // Creator opened their own branch link - just show info
                showToast('â„¹ï¸ This is your own shared branch', 'warning');
            } else {
                // Collaborator opening branch to edit
                console.log('ðŸ¤ Collaborator opening branch for editing');
                enterBranchEditMode(branch);
            }

            return true;
        }

        // =============================================================================
        // END COLLABORATION
        // =============================================================================

        // Update tree preview - copy working tree to main tree and render in real-time
        function updateWizardPreview() {
            // Copy working tree to main tree
            capexTree = JSON.parse(JSON.stringify(wizardState.workingTree));

            // Render to show real-time updates on the left
            render();

            console.log('âœ… Tree updated in real-time:', {
                name: capexTree.name,
                phases: capexTree.children?.length || 0,
                items: capexTree.children?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0
            });

            return;

            const preview = document.getElementById('wizard-tree-preview');
            const tree = wizardState.workingTree;

            let html = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 10px; color: var(--treeplex-primary); border-bottom: 2px solid var(--treeplex-primary); padding-bottom: 8px;">
                ${tree.icon || 'ðŸŒ³'} ${tree.name || 'Untitled Project'}
            </div>`;

            if (tree.description) {
                html += `<div style="color: var(--text-secondary); margin-bottom: 20px; font-size: 13px; font-style: italic;">
                    ${tree.description}
                </div>`;
            }

            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    // Phase header with background
                    html += `<div style="margin-bottom: 20px; border-left: 3px solid var(--treeplex-primary); padding-left: 12px;">
                        <div style="font-weight: 600; font-size: 14px; color: var(--treeplex-primary); margin-bottom: 8px;">
                            ${phase.icon || 'ðŸ“‹'} ${phase.name}
                            ${phase.subtitle ? `<div style="color: var(--text-secondary); font-weight: 400; font-size: 12px; margin-top: 2px;">${phase.subtitle}</div>` : ''}
                        </div>`;

                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            // Item
                            html += `<div style="margin-left: 15px; margin-bottom: 10px; padding: 8px; background: var(--card-bg-light); border-radius: 6px;">
                                <div style="color: var(--text-primary); font-weight: 500; font-size: 13px;">
                                    ${item.icon || 'ðŸ“„'} ${item.name}
                                </div>`;

                            // Item description
                            if (item.description) {
                                html += `<div style="color: var(--text-secondary); font-size: 11px; margin-top: 4px; margin-left: 20px;">
                                    ${item.description}
                                </div>`;
                            }

                            // Dependencies (if present - for backward compatibility)
                            if (item.dependencies) {
                                // Handle both array and string formats
                                const depText = Array.isArray(item.dependencies)
                                    ? item.dependencies.join(', ')
                                    : item.dependencies;
                                if (depText && depText.length > 0) {
                                    html += `<div style="color: #f59e0b; font-size: 11px; margin-top: 4px; margin-left: 20px;">
                                        âš ï¸ Depends on: ${depText}
                                    </div>`;
                                }
                            }

                            // Subtasks
                            if (item.subtasks && item.subtasks.length > 0) {
                                html += `<div style="margin-left: 20px; margin-top: 6px;">`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    html += `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 3px;">
                                        â–¸ ${subtask.name}${subtask.description ? ': ' + subtask.description : ''}
                                    </div>`;
                                });
                                html += `</div>`;
                            }

                            html += `</div>`; // End item
                        });
                    }

                    html += `</div>`; // End phase
                });
            } else {
                html += `<div style="color: var(--text-secondary); text-align: center; margin-top: 40px; padding: 40px 20px; border: 2px dashed var(--border); border-radius: 8px;">
                    <div style="font-size: 24px; margin-bottom: 10px;">ðŸŒ±</div>
                    <div>Waiting for conversation to start building the tree...</div>
                </div>`;
            }

            preview.innerHTML = html;
        }

        // Finish wizard (old modal button - still kept for compatibility)
        document.getElementById('wizard-done').addEventListener('click', () => {
            // Save state for undo
            saveState('AI Wizard: Apply changes');

            // Apply working tree to main tree (deep copy to prevent reference issues)
            capexTree = JSON.parse(JSON.stringify(wizardState.workingTree));
            currentPattern = wizardState.patternKey;

            // Close modal
            document.getElementById('wizard-modal').style.display = 'none';

            // BUILD 408: Also close Tree Agent if open
            if (typeof closeTreeAgent === 'function') {
                closeTreeAgent(true);
            }

            // Restore chat bubble
            const chatBubbleRestore = document.getElementById('chat-assistant-bubble');
            if (chatBubbleRestore) chatBubbleRestore.style.display = 'flex';

            // Render updated tree
            render();

            console.log('ðŸª„ Wizard complete! Tree applied.');
        });

        // Cancel wizard (old modal button - still kept for compatibility)
        document.getElementById('wizard-cancel').addEventListener('click', () => {
            if (confirm('Are you sure? Your progress will be lost.')) {
                document.getElementById('wizard-modal').style.display = 'none';

                // BUILD 408: Also close Tree Agent if open
                if (typeof closeTreeAgent === 'function') {
                    closeTreeAgent(true);
                }

                // Restore chat bubble
                const chatBubble = document.getElementById('chat-assistant-bubble');
                if (chatBubble) chatBubble.style.display = 'flex';
            }
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 405: LIVE TREE AGENT (Chat Builder Redesign)
        // Floating frame with real-time tree building visualization
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Tree Agent State
        window.treeAgentState = {
            open: false,
            minimized: false,
            position: { x: 20, y: 80 } // Default top-left
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 406: NODE CHANGE TRACKING (Visual Highlighting)
        // Track recently changed nodes for visual feedback in tree view
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Map of nodeId â†’ { type: 'new'|'modified', timestamp: Date.now() }
        window.recentlyChangedNodes = new Map();

        // Track a node as changed
        function trackNodeChange(nodeId, changeType = 'new') {
            if (!nodeId) return;
            window.recentlyChangedNodes.set(nodeId, {
                type: changeType,
                timestamp: Date.now()
            });
            console.log(`âœ¨ Node tracked: ${nodeId} (${changeType})`);
        }
        window.trackNodeChange = trackNodeChange;

        // Check if a node has recent changes (within last 5 seconds)
        function hasRecentChange(nodeId) {
            const change = window.recentlyChangedNodes.get(nodeId);
            if (!change) return null;
            if (Date.now() - change.timestamp > 5000) {
                window.recentlyChangedNodes.delete(nodeId);
                return null;
            }
            return change;
        }
        window.hasRecentChange = hasRecentChange;

        // Clear all tracked changes
        function clearTrackedChanges() {
            window.recentlyChangedNodes.clear();
        }
        window.clearTrackedChanges = clearTrackedChanges;

        // Auto-cleanup old changes every 3 seconds
        setInterval(() => {
            const now = Date.now();
            for (const [nodeId, change] of window.recentlyChangedNodes) {
                if (now - change.timestamp > 5000) {
                    window.recentlyChangedNodes.delete(nodeId);
                }
            }
        }, 3000);

        // Open the Tree Agent frame
        function openTreeAgent(title = 'Building Tree...') {
            const frame = document.getElementById('tree-agent-frame');
            if (!frame) return;

            // Set title
            document.getElementById('agent-title').textContent = title;

            // Reset progress
            document.getElementById('agent-progress-fill').style.width = '0%';
            document.getElementById('agent-progress-text').textContent = '0%';

            // Clear messages
            document.getElementById('agent-messages').innerHTML = '';

            // Show frame
            frame.classList.add('open');
            frame.classList.remove('minimized');
            treeAgentState.open = true;
            treeAgentState.minimized = false;

            // Hide chat bubble to prevent overlap
            const chatBubble = document.getElementById('chat-assistant-bubble');
            if (chatBubble) chatBubble.style.display = 'none';

            console.log('ðŸ¤– Tree Agent opened');
        }
        window.openTreeAgent = openTreeAgent;

        // Close the Tree Agent frame
        function closeTreeAgent(forceClose = false) {
            const frame = document.getElementById('tree-agent-frame');
            if (!frame) return;

            // If active session, confirm close
            if (!forceClose && wizardState?.active && !wizardState?.conversation?.length === 0) {
                if (!confirm('Close the Tree Agent? Your conversation will be preserved.')) {
                    return;
                }
            }

            frame.classList.remove('open', 'minimized');
            treeAgentState.open = false;
            treeAgentState.minimized = false;

            // Restore chat bubble
            const chatBubble = document.getElementById('chat-assistant-bubble');
            if (chatBubble) chatBubble.style.display = 'flex';

            console.log('ðŸ¤– Tree Agent closed');
        }
        window.closeTreeAgent = closeTreeAgent;

        // Toggle minimize state
        function toggleTreeAgentMinimize() {
            const frame = document.getElementById('tree-agent-frame');
            if (!frame || !treeAgentState.open) return;

            treeAgentState.minimized = !treeAgentState.minimized;
            frame.classList.toggle('minimized', treeAgentState.minimized);

            console.log('ðŸ¤– Tree Agent', treeAgentState.minimized ? 'minimized' : 'expanded');
        }
        window.toggleTreeAgentMinimize = toggleTreeAgentMinimize;

        // Add a message to the Tree Agent chat
        function addAgentMessage(role, content, choices = null) {
            const messagesDiv = document.getElementById('agent-messages');
            if (!messagesDiv) return;

            const msgDiv = document.createElement('div');
            msgDiv.className = `agent-message ${role}`;

            // Parse content for [CHOICE:] markers
            let displayContent = content;
            const choiceMatches = content.match(/\[CHOICE:([^\]]+)\]/g);

            if (choiceMatches) {
                displayContent = content.replace(/\[CHOICE:[^\]]+\]/g, '').trim();
            }

            msgDiv.innerHTML = displayContent.replace(/\n/g, '<br>');
            messagesDiv.appendChild(msgDiv);

            // Add choice buttons if present
            if (choiceMatches && choiceMatches.length > 0) {
                // Remove any existing choices
                const existingChoices = messagesDiv.parentElement.querySelector('.agent-choices');
                if (existingChoices) existingChoices.innerHTML = '';

                // Create choice container if it doesn't exist
                let choicesDiv = messagesDiv.parentElement.querySelector('.agent-choices');
                if (!choicesDiv) {
                    choicesDiv = document.createElement('div');
                    choicesDiv.className = 'agent-choices';
                    messagesDiv.parentElement.insertBefore(choicesDiv, messagesDiv.nextSibling);
                }

                choiceMatches.forEach(match => {
                    const label = match.replace('[CHOICE:', '').replace(']', '');
                    const btn = document.createElement('button');
                    btn.className = 'agent-choice-btn';
                    btn.textContent = label;
                    btn.addEventListener('click', () => {
                        // Handle choice selection
                        handleAgentChoice(label);
                    });
                    choicesDiv.appendChild(btn);
                });
            }

            // Auto-scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        window.addAgentMessage = addAgentMessage;

        // Handle choice selection in Tree Agent
        function handleAgentChoice(choice) {
            // Add user message showing the choice
            addAgentMessage('user', choice);

            // Clear choice buttons
            const choicesDiv = document.querySelector('#tree-agent-frame .agent-choices');
            if (choicesDiv) choicesDiv.innerHTML = '';

            // Forward to wizard handler if active
            if (wizardState?.active) {
                handleWizardChoice(choice);
            }
        }
        window.handleAgentChoice = handleAgentChoice;

        // Update Tree Agent progress
        function updateAgentProgress(percent, text = null) {
            const fill = document.getElementById('agent-progress-fill');
            const textEl = document.getElementById('agent-progress-text');
            if (fill) fill.style.width = `${percent}%`;
            if (textEl) textEl.textContent = text || `${Math.round(percent)}%`;
        }
        window.updateAgentProgress = updateAgentProgress;

        // Tree Agent event listeners
        document.getElementById('agent-minimize-btn')?.addEventListener('click', toggleTreeAgentMinimize);
        document.getElementById('agent-close-btn')?.addEventListener('click', () => closeTreeAgent(false));

        document.getElementById('agent-cancel-btn')?.addEventListener('click', () => {
            if (confirm('Cancel the current session? Your progress will be lost.')) {
                closeTreeAgent(true);
                // Reset wizard state
                if (wizardState) wizardState.active = false;
            }
        });

        document.getElementById('agent-finish-btn')?.addEventListener('click', () => {
            if (wizardState?.workingTree) {
                // Save state for undo
                saveState('Tree Agent: Apply changes');

                // Apply working tree to main tree
                capexTree = JSON.parse(JSON.stringify(wizardState.workingTree));
                currentPattern = wizardState.patternKey || currentPattern;

                // Close agent
                closeTreeAgent(true);

                // Reset wizard state
                if (wizardState) wizardState.active = false;

                // Render updated tree
                render();

                showToast('âœ… Tree changes applied!', 'success');
                console.log('ðŸ¤– Tree Agent: Changes applied');
            } else {
                closeTreeAgent(true);
            }
        });

        // Send button handler
        document.getElementById('agent-send-btn')?.addEventListener('click', () => {
            const input = document.getElementById('agent-input');
            if (input && input.value.trim()) {
                const text = input.value.trim();
                input.value = '';

                // Add user message
                addAgentMessage('user', text);

                // Forward to wizard if active
                if (wizardState?.active) {
                    handleWizardChoice(text);
                }
            }
        });

        // Enter key handler
        document.getElementById('agent-input')?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                document.getElementById('agent-send-btn')?.click();
            }
        });

        // Voice input button (placeholder for future implementation)
        document.getElementById('agent-voice-btn')?.addEventListener('click', () => {
            showToast('ðŸŽ¤ Voice input coming soon!', 'info');
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 407: DRAGGABLE AGENT FRAME + POSITION PERSISTENCE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Load saved position from localStorage
        function loadAgentPosition() {
            try {
                const saved = localStorage.getItem('treeAgentPosition');
                if (saved) {
                    const pos = JSON.parse(saved);
                    treeAgentState.position = pos;
                    const frame = document.getElementById('tree-agent-frame');
                    if (frame) {
                        frame.style.left = `${pos.x}px`;
                        frame.style.top = `${pos.y}px`;
                    }
                }
            } catch (e) {
                console.log('Could not load agent position:', e);
            }
        }

        // Save position to localStorage
        function saveAgentPosition() {
            try {
                localStorage.setItem('treeAgentPosition', JSON.stringify(treeAgentState.position));
            } catch (e) {
                console.log('Could not save agent position:', e);
            }
        }

        // Reset position to default
        function resetAgentPosition() {
            treeAgentState.position = { x: 20, y: 80 };
            const frame = document.getElementById('tree-agent-frame');
            if (frame) {
                frame.style.left = '20px';
                frame.style.top = '80px';
            }
            saveAgentPosition();
            showToast('ðŸ“ Position reset', 'info');
        }
        window.resetAgentPosition = resetAgentPosition;

        // Make the agent frame draggable
        (function initAgentDrag() {
            const frame = document.getElementById('tree-agent-frame');
            const header = frame?.querySelector('.agent-header');
            if (!frame || !header) return;

            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            header.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on buttons
                if (e.target.closest('.agent-btn')) return;

                isDragging = true;
                dragOffset.x = e.clientX - frame.offsetLeft;
                dragOffset.y = e.clientY - frame.offsetTop;
                frame.style.transition = 'none';
                header.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const newX = Math.max(0, Math.min(window.innerWidth - frame.offsetWidth, e.clientX - dragOffset.x));
                const newY = Math.max(0, Math.min(window.innerHeight - frame.offsetHeight, e.clientY - dragOffset.y));

                frame.style.left = `${newX}px`;
                frame.style.top = `${newY}px`;
                treeAgentState.position = { x: newX, y: newY };
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    frame.style.transition = '';
                    header.style.cursor = 'grab';
                    saveAgentPosition();
                }
            });

            // Double-click to reset position
            header.addEventListener('dblclick', (e) => {
                if (e.target.closest('.agent-btn')) return;
                resetAgentPosition();
            });

            // Touch support for mobile
            header.addEventListener('touchstart', (e) => {
                if (e.target.closest('.agent-btn')) return;
                const touch = e.touches[0];
                isDragging = true;
                dragOffset.x = touch.clientX - frame.offsetLeft;
                dragOffset.y = touch.clientY - frame.offsetTop;
                frame.style.transition = 'none';
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const newX = Math.max(0, Math.min(window.innerWidth - frame.offsetWidth, touch.clientX - dragOffset.x));
                const newY = Math.max(0, Math.min(window.innerHeight - frame.offsetHeight, touch.clientY - dragOffset.y));
                frame.style.left = `${newX}px`;
                frame.style.top = `${newY}px`;
                treeAgentState.position = { x: newX, y: newY };
            }, { passive: true });

            document.addEventListener('touchend', () => {
                if (isDragging) {
                    isDragging = false;
                    frame.style.transition = '';
                    saveAgentPosition();
                }
            });

            // Load saved position on init
            loadAgentPosition();

            console.log('ðŸ¤– BUILD 407: Draggable agent frame initialized');
        })();

        console.log('ðŸ¤– BUILD 405-407: Tree Agent fully initialized');

        // Auto-Enhance: Run AI Review then enhance tree automatically
        async function runAutoEnhance() {
            // Check if tree has content
            if (!hasExistingContent()) {
                alert('âš ï¸ Your tree is empty.\n\nPlease add some content first, then use Auto-Enhance.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            try {
                // Open wizard modal first
                document.getElementById('wizard-modal').style.display = 'flex';

                // Hide chat bubble to prevent overlap with modal buttons
                const chatBubble = document.getElementById('chat-assistant-bubble');
                if (chatBubble) chatBubble.style.display = 'none';

                // Show loading state in wizard
                const chatHistory = document.getElementById('wizard-chat-history');
                chatHistory.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">ðŸ” Step 1/2: Analyzing your tree for improvements...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Using your preferred AI model for review</p>
                    </div>
                `;

                // Step 1: Run AI Review to get suggestions
                const pattern = PATTERNS[currentPattern];
                const tree = capexTree;
                const reviewPrompt = buildReviewPrompt(tree, pattern);

                // Get current AI mode (respect user's choice of Gemini or ChatGPT)
                const currentAIMode = document.getElementById('unified-ai-mode-select').value;

                // Use user's selected model for review
                const reviewExperts = {
                    philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments. Review for logical validity, premise strength, and dialectical completeness.',
                    sales: 'You are a sales strategist with 20 years of enterprise B2B experience. Review for pipeline health, deal qualification, and revenue optimization.',
                    thesis: 'You are an academic advisor helping graduate students structure rigorous research. Review for argument progression, citation quality, and scholarly standards.',
                    roadmap: 'You are a product manager experienced in agile development and feature prioritization. Review for execution readiness, story completeness, and technical feasibility.',
                    prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude, GPT-4, and other LLMs. Review for prompt clarity, few-shot example quality, output format specification, and edge case handling.',
                    book: 'You are a professional fiction editor and writing coach. Review for narrative flow, character development, and pacing.',
                    film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway). Review for visual storytelling, shot composition, and production feasibility.',
                    course: 'You are an instructional designer with expertise in curriculum development. Review for learning progression, assessment alignment, and instructional scaffolding.',
                    dialogue: 'You are a debate coach and rhetoric expert specializing in argumentation theory, logical fallacies, and persuasive communication. Review for argument strength, rhetorical effectiveness, fallacy identification, and evidence quality.',
                    generic: `You are an expert ${pattern.name} analyst. Review the provided tree structure for completeness, redundancies, logical flow, and alignment with ${pattern.name} best practices.`
                };

                const expertPersona = reviewExperts[currentPattern] || reviewExperts.generic;

                console.log(`ðŸ”„ Auto-Enhance: Running AI Review with ${currentAIMode}...`);

                const reviewResponse = await callClaudeAPI(
                    reviewPrompt,
                    expertPersona + ' Provide specific, actionable suggestions.',
                    4096,
                    false // No extended thinking for faster review
                );

                // Extract improvements section
                const improvements = extractSection(reviewResponse, 'IMPROVEMENTS');

                if (!improvements) {
                    alert('âŒ No improvements were suggested.\n\nYour tree appears complete!');
                    document.getElementById('wizard-modal').style.display = 'none';
                    // Restore chat bubble
                    const chatBubble = document.getElementById('chat-assistant-bubble');
                    if (chatBubble) chatBubble.style.display = 'flex';
                    return;
                }

                console.log('âœ… Got improvements:', improvements.substring(0, 200) + '...');

                // Step 2: Start wizard in enhance mode with improvements
                chatHistory.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary);">âœ¨ Step 2/2: Starting enhancement wizard...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Using Sonnet for high-quality enhancements</p>
                    </div>
                `;

                // Force Sonnet for wizard enhancements (better quality)
                const originalAIMode = currentAIMode;
                document.getElementById('unified-ai-mode-select').value = 'server-sonnet';

                // Start wizard in enhance mode
                await startWizard(true); // true = enhance mode

                // Restore original AI mode selection
                document.getElementById('unified-ai-mode-select').value = originalAIMode;

                // Automatically send improvements as first message
                setTimeout(() => {
                    const userInput = document.getElementById('wizard-user-input');
                    const sendBtn = document.getElementById('wizard-send');

                    userInput.value = improvements;
                    sendBtn.click();
                }, 500);

                console.log('ðŸ”„ Auto-Enhance workflow started successfully!');

            } catch (error) {
                console.error('âŒ Auto-Enhance error:', error);
                alert(`âŒ Auto-Enhance failed:\n\n${error.message}`);

                // Clear loading state and close modal
                document.getElementById('wizard-chat-history').innerHTML = '';
                document.getElementById('wizard-modal').style.display = 'none';
                // Restore chat bubble
                const chatBubble = document.getElementById('chat-assistant-bubble');
                if (chatBubble) chatBubble.style.display = 'flex';
            }
        }

        // Toolbar button handler
        document.getElementById('auto-enhance-btn').addEventListener('click', runAutoEnhance);

        // Wizard footer button handler
        document.getElementById('wizard-auto-enhance').addEventListener('click', runAutoEnhance);

        // =============================================================================
        // GENERATE PROMPT SYSTEM
        // =============================================================================

        // Generate Prompt button
        document.getElementById('generate-prompt-btn').addEventListener('click', () => {
            const promptText = generatePromptFromTree();

            // Some patterns (like film) handle display asynchronously via style selectors
            // and return null - don't show modal in that case
            if (promptText !== null && promptText !== undefined) {
                document.getElementById('generated-prompt-text').value = promptText;
                document.getElementById('generate-prompt-modal').style.display = 'flex';
            }
            // If null, the pattern is handling its own display logic (e.g., style selector first)
        });

        // Close prompt modal
        document.getElementById('close-prompt-modal').addEventListener('click', () => {
            document.getElementById('generate-prompt-modal').style.display = 'none';
        });

        // Copy prompt to clipboard
        document.getElementById('copy-prompt-btn').addEventListener('click', async () => {
            const textArea = document.getElementById('generated-prompt-text');
            try {
                await navigator.clipboard.writeText(textArea.value);
                const successMsg = document.getElementById('copy-success-message');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                textArea.select();
                document.execCommand('copy');
                const successMsg = document.getElementById('copy-success-message');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            }
        });

        // Generate prompt from tree structure
        function generatePromptFromTree() {
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;
            const tree = capexTree;

            let prompt = '';

            // Header based on pattern
            if (currentPattern === 'prompting') {
                prompt += generateAIPromptDesignPrompt(tree, pattern);
            } else {
                prompt += generateGenericPrompt(tree, pattern);
            }

            return prompt;
        }

        // Generate EXECUTABLE AI Prompt (not meta-description)
        // Synthesizes tree into ONE complete, copy-paste ready prompt
        function generateAIPromptDesignPrompt(tree, pattern) {
            // Collect all items to synthesize into one unified prompt
            const allItems = [];
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach(item => {
                            allItems.push({ ...item, phaseName: phase.name });
                        });
                    }
                });
            }

            if (allItems.length === 0) {
                return `*No prompts defined yet. Add items to your tree.*\n`;
            }

            // Extract components from first item (primary prompt)
            const firstItem = allItems[0];
            const systemPrompts = allItems.map(item => item.systemPrompt).filter(sp => sp && sp.length > 0);
            const userTemplates = allItems.map(item => item.userPromptTemplate).filter(ut => ut && ut.length > 0);
            const exampleItems = allItems.filter(item => item.fewShotExamples && item.fewShotExamples.length > 0);
            const formatItems = allItems.filter(item => item.outputFormat && item.outputFormat.length > 0);
            const cotItems = allItems.filter(item => item.chainOfThought && item.chainOfThought.length > 0);
            const structuralItems = allItems.filter(item => item.structuralTags && item.structuralTags.length > 0);

            // Build CLEAN EXECUTABLE prompt (no meta-instructions, just the raw prompt)
            let actualPrompt = '';

            // Add system context at the top (like a system message)
            if (systemPrompts.length > 0) {
                actualPrompt += `${systemPrompts[0]}\n\n---\n\n`;
            }

            // Add the main user instruction
            if (userTemplates.length > 0) {
                actualPrompt += userTemplates[0];
            } else {
                actualPrompt += `${tree.description || tree.name}`;
            }

            // Add few-shot examples inline if present
            if (exampleItems.length > 0) {
                actualPrompt += `\n\nHere are examples of the expected behavior:\n\n`;
                actualPrompt += exampleItems[0].fewShotExamples;
            }

            // Add output format specification
            if (formatItems.length > 0) {
                actualPrompt += `\n\n${formatItems[0].outputFormat}`;
            }

            // Add chain-of-thought instructions
            if (cotItems.length > 0) {
                actualPrompt += `\n\n${cotItems[0].chainOfThought}`;
            }

            // Add structural tags if present (Anthropic XML patterns)
            if (structuralItems.length > 0) {
                actualPrompt += `\n\n${structuralItems[0].structuralTags}`;
            }

            // RETURN CLEAN PROMPT - Ready to paste directly into AI chat
            // No markdown, no explanations, no meta-instructions
            return actualPrompt;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 122: TWO-STYLE VIDEO PROMPT GENERATOR
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Feature: Generate AI video prompts in two styles:
        //   1. Explainer/Documentary - Clean, educational, logical
        //   2. Narrative/Story - Character-driven, emotional, hero's journey
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function generateAIVideoPrompts(tree, pattern, style = null) {
            // If no style specified, show style selector and return
            if (!style) {
                showVideoStyleSelector((selectedStyle) => {
                    const prompt = generateAIVideoPrompts(tree, pattern, selectedStyle);
                    // Show the prompt in the modal (consistent with other patterns)
                    document.getElementById('generated-prompt-text').value = prompt;
                    document.getElementById('generate-prompt-modal').style.display = 'flex';
                });
                return null; // Will be called again with style
            }

            // 1. Determine the 'Hero' of the story (for Narrative mode)
            const hero = findProjectHero(tree);

            let output = `# ${tree.icon || 'ðŸŽ¬'} ${tree.name || 'Video Production'}\n\n`;
            output += `**Style:** ${style === 'narrative' ? 'ðŸŽ­ Narrative / Story Mode' : 'ðŸ“Š Explainer / Documentary Mode'}\n`;
            output += `**Format:** Copy-paste ready for Sora / Veo / Runway\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Hero info for narrative mode
            if (style === 'narrative') {
                output += `**Hero:** ${hero}\n`;
                output += `**Story Arc:** Three-act structure following the project completion journey\n\n`;
            }

            output += `---\n\n`;

            // Process Phases/Acts
            if (tree.children && tree.children.length > 0) {
                let previousScene = null;

                tree.children.forEach((phase, phaseIdx) => {
                    // Map Phase to Story Act (for narrative)
                    const actLabel = getStoryActLabel(phaseIdx, tree.children.length);

                    output += `## ${phase.name}`;
                    if (style === 'narrative') {
                        output += ` (${actLabel})`;
                    } else {
                        output += ` (Phase ${phaseIdx + 1})`;
                    }
                    output += `\n\n`;

                    if (phase.subtitle || phase.description) {
                        output += `*${phase.subtitle || phase.description}*\n\n`;
                    }

                    // Process Items/Scenes
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            const sceneNumber = `${phaseIdx + 1}.${itemIdx + 1}`;

                            // Generate the prompt based on style
                            const promptText = style === 'narrative'
                                ? synthesizeNarrativePrompt(item, hero, actLabel, previousScene)
                                : synthesizeExplainerPrompt(item);

                            output += `### Scene ${sceneNumber}: ${item.name}\n\n`;
                            output += `**Platform:** ${item.aiPlatform || 'Sora (OpenAI)'}\n\n`;
                            output += `**Prompt:**\n\`\`\`\n${promptText}\n\`\`\`\n\n`;

                            // Technical specs
                            const specs = [];
                            if (item.duration) specs.push(`Duration: ${item.duration}`);
                            if (item.aspectRatio) specs.push(`Aspect: ${item.aspectRatio}`);
                            if (item.visualStyle) specs.push(`Style: ${item.visualStyle}`);
                            if (specs.length > 0) {
                                output += `**Tech:** ${specs.join(' â€¢ ')}\n\n`;
                            }

                            output += `---\n\n`;

                            // Store for continuity
                            previousScene = item;
                        });
                    }
                });
            }

            // Usage instructions
            output += `\n## ðŸ“‹ Usage Instructions\n\n`;
            output += `1. Copy the prompt text (inside the code block)\n`;
            output += `2. Paste into your AI video platform:\n`;
            output += `   - **Sora** (OpenAI): Best for photorealistic, cinematic shots\n`;
            output += `   - **Veo 3** (Google): Great for consistent styles, longer clips\n`;
            output += `   - **Runway Gen-3**: Fast iteration, good for prototyping\n`;
            output += `   - **Pika 2.0**: Stylized, artistic effects\n`;
            output += `3. Adjust technical settings (duration, aspect ratio) as specified\n`;
            output += `4. Generate and review results\n`;
            output += `5. Iterate: Use the Notes section to refine prompts\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ Pro Tip:** ${style === 'narrative'
                ? 'Narrative videos work best for marketing, storytelling, and emotional connection. Consider adding background music and voiceover narration!'
                : 'Explainer videos work best for investor presentations, team onboarding, and educational content. Keep pacing consistent and visuals clean!'
            }\n`;

            return output;
        }

        // Helper: Find the Hero (Main Character)
        function findProjectHero(tree) {
            // Strategy 1: Find most frequently assigned person
            const assignees = {};

            function traverseTree(node) {
                if (node.pmAssignee && node.pmAssignee !== 'Unassigned') {
                    assignees[node.pmAssignee] = (assignees[node.pmAssignee] || 0) + 1;
                }
                if (node.children) {
                    node.children.forEach(child => traverseTree(child));
                }
                if (node.items) {
                    node.items.forEach(item => traverseTree(item));
                }
                if (node.subItems || node.subtasks) {
                    (node.subItems || node.subtasks).forEach(sub => traverseTree(sub));
                }
            }

            traverseTree(tree);

            // Return most frequent assignee
            const sorted = Object.entries(assignees).sort((a, b) => b[1] - a[1]);
            if (sorted.length > 0) return sorted[0][0];

            // Strategy 2: Extract name from descriptions
            function getAllText(node) {
                let text = (node.name || '') + ' ' + (node.description || '');
                if (node.children) {
                    node.children.forEach(child => text += ' ' + getAllText(child));
                }
                if (node.items) {
                    node.items.forEach(item => text += ' ' + getAllText(item));
                }
                return text;
            }

            const allText = getAllText(tree);
            const nameMatch = allText.match(/\b([A-Z][a-z]+ [A-Z][a-z]+)\b/);
            if (nameMatch) return nameMatch[1];

            // Strategy 3: Use tree owner or default
            return tree.owner || tree.createdBy || "The Project Lead";
        }

        // Helper: Map Phases to Story Acts
        function getStoryActLabel(index, total) {
            if (total <= 1) return "The Journey";
            const position = index / (total - 1);
            if (position < 0.4) return "Act I: The Challenge";
            if (position < 0.75) return "Act II: The Struggle";
            return "Act III: The Triumph";
        }

        // Style 1: Explainer / Documentary
        function synthesizeExplainerPrompt(item) {
            const visualSubject = item.name;
            const details = item.description || "Project details";

            // Financial context
            let financialGraphic = "";
            if (item.cost) {
                const costM = (item.cost / 1000000).toFixed(1);
                financialGraphic = `Budget graphic showing $${costM}M overlaid on screen.`;
            } else if (item.dealValue) {
                const valueM = (item.dealValue / 1000000).toFixed(1);
                financialGraphic = `Deal value of $${valueM}M displayed as infographic.`;
            } else if (item.investment) {
                const investM = (item.investment / 1000000).toFixed(1);
                financialGraphic = `Investment: $${investM}M shown in clean typography.`;
            }

            // Timeline context
            let timelineGraphic = "";
            if (item.leadTime) {
                timelineGraphic = `Timeline graphic animating: ${item.leadTime}.`;
            } else if (item.engineeringEstimate) {
                timelineGraphic = `Duration overlay: ${item.engineeringEstimate}.`;
            } else if (item.duration) {
                timelineGraphic = `Timeline: ${item.duration}.`;
            }

            // Location/Setting
            let setting = "Modern office environment or construction site";
            if (item.location) {
                setting = item.location;
            } else if (details.toLowerCase().includes('office')) {
                setting = "Modern glass office with city view";
            } else if (details.toLowerCase().includes('site') || details.toLowerCase().includes('land')) {
                setting = "Construction site or development location";
            } else if (details.toLowerCase().includes('lab') || details.toLowerCase().includes('research')) {
                setting = "Clean research laboratory";
            }

            return `Style: High-end Corporate Documentary. Photorealistic. 8k resolution.
Shot: Slow tracking shot or aerial drone view establishing the scope.
Subject: ${visualSubject}.
Action: ${details}. The visualization builds itself on screen with clean architectural lines.
Overlay Graphics: ${financialGraphic} ${timelineGraphic}
Setting: ${setting}.
Lighting: Bright, clean, clinical, "Apple store" aesthetic with soft shadows.
Mood: Competent, organized, futuristic, inspiring confidence.
Camera: Steady, professional gimbal movement. Wide to medium shots.`;
        }

        // Style 2: Narrative / Story
        function synthesizeNarrativePrompt(item, hero, act, previousScene) {
            const action = item.description || "working on the task";

            // Get dynamic mood based on context
            const moodData = getNarrativeMood(item, act);
            const mood = moodData.mood;
            const lighting = moodData.lighting;

            // Get appropriate setting
            const setting = getNarrativeSetting(item, act);

            // Emotional stakes
            const stakes = getEmotionalStakes(item);

            // Continuity from previous scene
            let continuity = "";
            if (previousScene) {
                continuity = `\nContinuity: Previous scene: "${previousScene.name}". This scene shows the consequence/progress of that action.`;
            }

            // Character details
            const characterDesc = `${hero} (30s-40s, professional, determined expression)`;

            return `Style: Cinematic Movie Scene. Anamorphic lens. Film grain.
Character: ${characterDesc}
Setting: ${setting}
Action: ${hero} is ${action}. ${mood}. ${stakes}${continuity}
Detail: Close-up on ${hero}'s face showing ${getEmotionalExpression(mood)}. Show determination and professionalism.
Lighting: ${lighting}. Cinematic contrast with dramatic shadows.
Mood: ${mood}. High stakes atmosphere.
Camera: Dynamic - Start wide, dolly in to close-up, or handheld for intensity.`;
        }

        // Helper: Dynamic Mood Detection
        function getNarrativeMood(item, act) {
            let mood = "Determined and focused";
            let lighting = "Natural daylight through windows";

            // Act-based default
            if (act.includes("Challenge")) {
                mood = "Optimistic but focused, ready to take on the world";
                lighting = "Morning sun streaming through windows, golden and hopeful";
            } else if (act.includes("Struggle")) {
                mood = "Stressed, high stakes, late night problem-solving";
                lighting = "Dark office, blue screen glow, single desk lamp, shadows";
            } else if (act.includes("Triumph")) {
                mood = "Relieved, celebratory, breakthrough moment";
                lighting = "Golden hour, warm sunset, victorious warm tones";
            }

            // Override with cost/value signals (high stakes)
            const monetaryValue = item.cost || item.dealValue || item.investment || 0;
            if (monetaryValue > 10000000) {
                mood = "Extreme pressure, multi-million dollar stakes, intense focus";
                lighting = "Dramatic boardroom lighting, spotlight effect, high contrast";
            } else if (monetaryValue > 5000000) {
                mood = "High pressure, massive responsibility, calculated decisions";
                lighting = "Serious office lighting, professional intensity";
            }

            // Override with status signals (crisis)
            if (item.pmStatus === 'Blocked' || item.pmBlockingIssue) {
                mood = "Crisis mode, urgent problem-solving, racing against time";
                lighting = "Harsh fluorescent, emergency meeting, red alert tones";
            }

            // Override with risk signals
            if (item.technicalRisk === 'High' || item.riskLevel === 'high') {
                mood = "Cautious, careful analysis, aware of dangers";
                lighting = "Moody, dramatic shadows, tension in the frame";
            }

            // Dependencies = coordination stress
            if (item.dependencies && item.dependencies.length > 3) {
                mood = "Coordination stress, juggling multiple priorities, multitasking energy";
            }

            return { mood, lighting };
        }

        // Helper: Setting Detection
        function getNarrativeSetting(item, act) {
            // Check if explicit setting exists
            if (item.location) return item.location;
            if (item.sceneSetting) return item.sceneSetting;

            // Infer from description
            const desc = (item.name + ' ' + (item.description || '')).toLowerCase();

            if (desc.includes('site') || desc.includes('construction') || desc.includes('land')) {
                return "Active construction site, equipment in background, dirt and machinery";
            }
            if (desc.includes('office') || desc.includes('meeting')) {
                return "Modern glass office, city skyline visible, professional environment";
            }
            if (desc.includes('lab') || desc.includes('research')) {
                return "Clean research laboratory, high-tech equipment, sterile environment";
            }
            if (desc.includes('field') || desc.includes('outdoor')) {
                return "Outdoor location, natural environment, sky visible";
            }

            // Default based on act
            if (act.includes("Challenge")) {
                return "Modern office conference room, early morning, project plans visible";
            } else if (act.includes("Struggle")) {
                return "Office late at night, desks cluttered with documents, pressure visible";
            } else if (act.includes("Triumph")) {
                return "Office or construction site, celebrating success, relieved atmosphere";
            }

            return "Professional office or work environment";
        }

        // Helper: Emotional Stakes
        function getEmotionalStakes(item) {
            const monetaryValue = item.cost || item.dealValue || item.investment || 0;
            const timeline = item.leadTime || item.engineeringEstimate || item.duration || "";

            if (monetaryValue > 5000000) {
                return `Career-defining moment. Millions on the line.`;
            }
            if (monetaryValue > 1000000) {
                return `Major project milestone. Success matters.`;
            }
            if (timeline.includes('month') && parseInt(timeline) < 6) {
                return `Tight deadline. Time pressure evident.`;
            }
            if (item.dependencies && item.dependencies.length > 2) {
                return `Complex dependencies. Everything must align.`;
            }

            return `Professional commitment. Doing this right matters.`;
        }

        // Helper: Emotional Expression
        function getEmotionalExpression(mood) {
            if (mood.includes("Optimistic")) return "hope mixed with determination";
            if (mood.includes("Stressed") || mood.includes("Crisis")) return "stress and urgent focus";
            if (mood.includes("Relieved") || mood.includes("celebratory")) return "relief and satisfaction";
            if (mood.includes("pressure")) return "intense concentration under pressure";
            if (mood.includes("Cautious")) return "careful calculation and wariness";
            return "professional determination and focus";
        }

        // UI: Style Selector Modal
        function showVideoStyleSelector(callback) {
            // Remove any existing modal
            const existingModal = document.querySelector('.video-style-modal');
            if (existingModal) existingModal.remove();

            const modalHTML = `
                <div class="modal-overlay video-style-modal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.85);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                ">
                    <div class="modal-content" style="
                        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                        border-radius: 16px;
                        padding: 32px;
                        max-width: 800px;
                        width: 90%;
                        color: #e4e4e7;
                        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
                    ">
                        <h2 style="
                            font-size: 28px;
                            margin-bottom: 8px;
                            background: linear-gradient(135deg, #60a5fa, #a78bfa);
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                            background-clip: text;
                        ">ðŸŽ¬ Choose Video Style</h2>

                        <p style="color: #9ca3af; margin-bottom: 24px; font-size: 14px;">
                            Generate AI video prompts in two different styles. Same project data, different storytelling approaches.
                        </p>

                        <div class="style-options" style="
                            display: grid;
                            grid-template-columns: 1fr 1fr;
                            gap: 20px;
                            margin-bottom: 24px;
                        ">
                            <div class="style-card" data-style="explainer" style="
                                background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                                border-radius: 12px;
                                padding: 24px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                border: 2px solid transparent;
                            ">
                                <div class="style-icon" style="font-size: 48px; margin-bottom: 12px;">ðŸ“Š</div>
                                <h3 style="font-size: 18px; margin-bottom: 12px; color: #fff;">Explainer / Documentary</h3>
                                <p style="font-size: 13px; margin-bottom: 16px; color: #dbeafe; line-height: 1.5;">
                                    Clean, professional, educational. Shows the project plan logically step-by-step.
                                </p>
                                <ul style="font-size: 12px; color: #dbeafe; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 6px;">âœ… Investor presentations</li>
                                    <li style="margin-bottom: 6px;">âœ… Team onboarding</li>
                                    <li style="margin-bottom: 6px;">âœ… Status updates</li>
                                    <li>âœ… Educational content</li>
                                </ul>
                            </div>

                            <div class="style-card" data-style="narrative" style="
                                background: linear-gradient(135deg, #8b5cf6, #6d28d9);
                                border-radius: 12px;
                                padding: 24px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                border: 2px solid transparent;
                            ">
                                <div class="style-icon" style="font-size: 48px; margin-bottom: 12px;">ðŸŽ­</div>
                                <h3 style="font-size: 18px; margin-bottom: 12px; color: #fff;">Narrative / Story</h3>
                                <p style="font-size: 13px; margin-bottom: 16px; color: #ede9fe; line-height: 1.5;">
                                    Character-driven drama. Shows someone completing the project successfully with emotional stakes.
                                </p>
                                <ul style="font-size: 12px; color: #ede9fe; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 6px;">âœ… Marketing videos</li>
                                    <li style="margin-bottom: 6px;">âœ… Hero's journey arc</li>
                                    <li style="margin-bottom: 6px;">âœ… Emotional storytelling</li>
                                    <li>âœ… Brand building</li>
                                </ul>
                            </div>
                        </div>

                        <p style="
                            text-align: center;
                            color: #60a5fa;
                            font-size: 13px;
                            margin-bottom: 16px;
                        ">ðŸ’¡ Tip: Both styles use the same project data</p>

                        <button class="modal-cancel" style="
                            width: 100%;
                            padding: 12px;
                            background: #374151;
                            color: #e4e4e7;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            transition: all 0.2s;
                        ">Cancel</button>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // Add hover effects
            const styleCards = document.querySelectorAll('.style-card');
            styleCards.forEach(card => {
                card.addEventListener('mouseenter', () => {
                    card.style.transform = 'scale(1.05)';
                    card.style.borderColor = '#60a5fa';
                    card.style.boxShadow = '0 10px 30px rgba(96, 165, 250, 0.3)';
                });
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'scale(1)';
                    card.style.borderColor = 'transparent';
                    card.style.boxShadow = 'none';
                });

                // Click handler
                card.addEventListener('click', () => {
                    const style = card.dataset.style;
                    document.querySelector('.video-style-modal').remove();
                    callback(style);
                });
            });

            // Cancel button
            document.querySelector('.modal-cancel').addEventListener('click', () => {
                document.querySelector('.video-style-modal').remove();
            });

            // Click outside to close
            document.querySelector('.video-style-modal').addEventListener('click', (e) => {
                if (e.target.classList.contains('video-style-modal')) {
                    document.querySelector('.video-style-modal').remove();
                }
            });
        }

        // UI: Display Generated Prompt
        function displayGeneratedPrompt(prompt, title) {
            // Copy to clipboard
            navigator.clipboard.writeText(prompt).then(() => {
                showNotification(`âœ… ${title} - Prompt copied to clipboard!`);
            }).catch(() => {
                // Fallback: show in console if clipboard fails
                console.log('=== GENERATED PROMPT ===');
                console.log(prompt);
                showNotification(`âœ… ${title} - See console for prompt`);
            });
        }

        // Synthesize all video fields into one cohesive professional prompt
        // Based on Sora/Veo3 best practices: comprehensive, detailed, cinematographic
        function synthesizeVideoPrompt(item) {
            let sections = [];

            // SECTION 1: CORE SCENE DESCRIPTION
            let sceneDesc = '';
            if (item.videoPrompt) {
                sceneDesc = item.videoPrompt;
            } else if (item.description) {
                sceneDesc = item.description;
            } else {
                sceneDesc = item.name;
            }
            sections.push(sceneDesc);

            // SECTION 2: CAMERA SPECIFICATIONS
            const cameraSpecs = [];

            // Camera movement (critical for Sora/Veo3)
            if (item.cameraMovement && item.cameraMovement !== 'Static') {
                const movement = item.cameraMovement.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(movement)) {
                    cameraSpecs.push(`${movement} camera`);
                }
            } else if (!sceneDesc.toLowerCase().includes('camera')) {
                cameraSpecs.push('static camera');
            }

            // Motion intensity affects pacing
            if (item.motionIntensity) {
                const intensity = item.motionIntensity.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(intensity) && !sceneDesc.toLowerCase().includes('motion')) {
                    cameraSpecs.push(`${intensity} motion`);
                }
            }

            if (cameraSpecs.length > 0) {
                sections.push(cameraSpecs.join(', '));
            }

            // SECTION 3: LIGHTING & ATMOSPHERE
            const lightingDetails = [];

            if (item.lightingMood) {
                const mood = item.lightingMood.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(mood) && !sceneDesc.toLowerCase().includes('light')) {
                    lightingDetails.push(`${mood} lighting`);
                }
            }

            // Visual style affects overall aesthetic
            if (item.visualStyle && item.visualStyle !== 'Photorealistic') {
                const style = item.visualStyle.toLowerCase();
                if (!sceneDesc.toLowerCase().includes(style)) {
                    lightingDetails.push(`${style} aesthetic`);
                }
            }

            if (lightingDetails.length > 0) {
                sections.push(lightingDetails.join(', '));
            }

            // SECTION 4: TECHNICAL FORMAT (professional cinematography language)
            const technicalDetails = [];

            // Aspect ratio implies framing
            if (item.aspectRatio) {
                const ratio = item.aspectRatio;
                if (ratio.includes('16:9')) {
                    if (!sceneDesc.toLowerCase().includes('widescreen') && !sceneDesc.toLowerCase().includes('cinematic')) {
                        technicalDetails.push('widescreen composition');
                    }
                } else if (ratio.includes('9:16')) {
                    if (!sceneDesc.toLowerCase().includes('vertical')) {
                        technicalDetails.push('vertical framing');
                    }
                } else if (ratio.includes('2.39')) {
                    if (!sceneDesc.toLowerCase().includes('cinematic')) {
                        technicalDetails.push('anamorphic widescreen');
                    }
                }
            }

            if (technicalDetails.length > 0) {
                sections.push(technicalDetails.join(', '));
            }

            // SYNTHESIZE: Build comprehensive prompt
            let finalPrompt = sections.filter(s => s && s.length > 0).join('. ');

            // Ensure professional formatting
            if (!finalPrompt.endsWith('.') && !finalPrompt.endsWith('!') && !finalPrompt.endsWith('?')) {
                finalPrompt += '.';
            }

            // QUALITY CHECK: Professional prompts should be detailed (100+ chars minimum)
            // If still too short, add generic cinematography guidance
            if (finalPrompt.length < 100) {
                const defaultEnhancements = [];

                if (!finalPrompt.toLowerCase().includes('focus')) {
                    defaultEnhancements.push('sharp focus on subject');
                }

                if (!finalPrompt.toLowerCase().includes('detail')) {
                    defaultEnhancements.push('high attention to detail');
                }

                if (item.duration && item.duration.includes('seconds')) {
                    const seconds = item.duration.match(/\d+/)?.[0];
                    if (seconds) {
                        defaultEnhancements.push(`${seconds}-second clip`);
                    }
                }

                if (defaultEnhancements.length > 0) {
                    finalPrompt += ` ${defaultEnhancements.join(', ')}.`;
                }
            }

            return finalPrompt;
        }

        // Generate Product Roadmap prompt (sprint-ready, execution-focused)
        function generateRoadmapPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸš€'} ${tree.name || 'Product Roadmap'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate roadmap metrics
            let totalStoryPoints = 0;
            let highImpactFeatures = 0;
            let highRiskFeatures = 0;
            let totalFeatures = 0;
            const quarterMetrics = [];

            if (tree.children) {
                tree.children.forEach(quarter => {
                    if (quarter.type === 'phase' && quarter.items) {
                        let quarterPoints = 0;
                        let quarterHighImpact = 0;
                        let quarterHighRisk = 0;

                        quarter.items.forEach(feature => {
                            quarterPoints += feature.storyPoints || 0;
                            if (feature.userImpact === 'High' || feature.userImpact === 'Critical') {
                                quarterHighImpact++;
                            }
                            if (feature.technicalRisk === 'High') {
                                quarterHighRisk++;
                            }
                        });

                        quarterMetrics.push({
                            name: quarter.name || `Quarter ${quarter.phase + 1}`,
                            subtitle: quarter.subtitle,
                            features: quarter.items.length,
                            points: quarterPoints,
                            highImpact: quarterHighImpact,
                            highRisk: quarterHighRisk
                        });

                        totalStoryPoints += quarterPoints;
                        totalFeatures += quarter.items.length;
                        highImpactFeatures += quarterHighImpact;
                        highRiskFeatures += quarterHighRisk;
                    }
                });
            }

            // Roadmap Summary
            output += `## ðŸ“Š Roadmap Summary\n\n`;
            output += `**Delivery Capacity:**\n`;
            output += `- Total Features: ${totalFeatures}\n`;
            output += `- Total Story Points: ${totalStoryPoints}\n`;
            output += `- Average Feature Size: ${Math.round(totalStoryPoints / totalFeatures)} points\n`;
            output += `- High-Impact Features: ${highImpactFeatures} (${Math.round(highImpactFeatures / totalFeatures * 100)}%)\n`;
            output += `- High-Risk Features: ${highRiskFeatures} (${Math.round(highRiskFeatures / totalFeatures * 100)}%)\n\n`;

            // Quarterly Planning
            output += `## ðŸ“… Quarterly Planning\n\n`;
            quarterMetrics.forEach((q, idx) => {
                output += `### ${q.name}${q.subtitle ? ` â€” ${q.subtitle}` : ''}\n`;
                output += `- Features: ${q.features} (${q.points} story points)\n`;
                output += `- Velocity Target: ${Math.round(q.points / 6)} points/sprint (6 sprints)\n`;
                output += `- High Impact: ${q.highImpact} features\n`;
                output += `- High Risk: ${q.highRisk} features (${q.highRisk > 0 ? 'requires spike work' : 'low risk quarter'})\n\n`;
            });

            // Feature Details
            output += `---\n\n## ðŸš€ Feature Specifications\n\n`;

            if (tree.children) {
                tree.children.forEach((quarter, qIdx) => {
                    if (quarter.type === 'phase' && quarter.items && quarter.items.length > 0) {
                        output += `### ${quarter.name || `Quarter ${qIdx + 1}`}\n\n`;

                        quarter.items.forEach((feature, fIdx) => {
                            const storyPoints = feature.storyPoints || 0;
                            const userImpact = feature.userImpact || 'Medium';
                            const techRisk = feature.technicalRisk || 'Medium';

                            // Impact/Risk emoji indicators
                            const impactEmoji = userImpact === 'Critical' ? 'ðŸ”¥' : userImpact === 'High' ? 'âš¡' : userImpact === 'Medium' ? 'ðŸ“Š' : 'ðŸ“‰';
                            const riskEmoji = techRisk === 'High' ? 'âš ï¸' : techRisk === 'Medium' ? 'âš¡' : 'âœ…';

                            output += `#### ${fIdx + 1}. ${feature.name}\n\n`;

                            // Feature card
                            output += `**Feature Overview:**\n`;
                            output += `- ${impactEmoji} User Impact: ${userImpact}\n`;
                            output += `- ${riskEmoji} Technical Risk: ${techRisk}\n`;
                            output += `- ðŸ“ Story Points: ${storyPoints} (${Math.ceil(storyPoints / 3)} sprints)\n`;
                            if (feature.engineeringEstimate) {
                                output += `- â±ï¸ Engineering Estimate: ${feature.engineeringEstimate}\n`;
                            }
                            if (feature.featureFlag) {
                                output += `- ðŸš© Feature Flag: \`${feature.featureFlag}\`\n`;
                            }
                            output += `\n`;

                            if (feature.description) {
                                output += `**What it does:**\n${feature.description}\n\n`;
                            }

                            // Implementation tasks
                            if (feature.children && feature.children.length > 0) {
                                output += `**Implementation Tasks:**\n`;
                                feature.children.forEach((task, tIdx) => {
                                    output += `${tIdx + 1}. ${task.name}`;
                                    if (task.storyPoints) {
                                        output += ` (${task.storyPoints} pts)`;
                                    }
                                    output += `\n`;
                                    if (task.description) {
                                        output += `   ${task.description}\n`;
                                    }
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (feature.dependencies && feature.dependencies.length > 0) {
                                output += `**âš ï¸ Blocking Dependencies:** ${feature.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Execution Recommendations
            output += `## âš¡ Execution Recommendations\n\n`;
            output += `**Sprint Planning:**\n`;
            const avgVelocity = Math.round(totalStoryPoints / (quarterMetrics.length * 6)); // Assume 6 sprints per quarter
            output += `- Target Velocity: ${avgVelocity} story points per sprint\n`;
            output += `- High-risk features: Start with spike/POC stories (1-2 sprints)\n`;
            output += `- Critical user impact: Prioritize for early quarters\n`;
            output += `- Feature flags: Use for all features >5 story points\n\n`;

            output += `**Risk Mitigation:**\n`;
            output += `1. Technical Spikes: Create 2-point spike stories for high-risk features\n`;
            output += `2. Dependency Management: Resolve blocking dependencies 1 sprint ahead\n`;
            output += `3. Incremental Delivery: Break large features (>8 points) into smaller releases\n`;
            output += `4. User Validation: Beta test high-impact features before GA\n`;
            output += `5. Monitoring: Set up dashboards and alerts for each feature flag\n\n`;

            output += `**Release Strategy:**\n`;
            output += `- Feature Flags: All features behind flags for safe rollout\n`;
            output += `- Phased Rollout: 10% â†’ 50% â†’ 100% over 2 weeks\n`;
            output += `- Rollback Plan: Document rollback procedures in each PR\n`;
            output += `- Success Metrics: Define KPIs before development starts\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ AI Prompt Usage - Actionable Deliverables:**\n`;
            output += `\n`;
            output += `**For Product Managers:**\n`;
            output += `- "Generate PRD (Product Requirements Document) for [feature name]"\n`;
            output += `- "Create user stories with acceptance criteria for [feature]"\n`;
            output += `- "Write launch email announcing [feature] to customers"\n`;
            output += `- "Design A/B test plan to validate [feature] impact"\n\n`;
            output += `**For Engineering:**\n`;
            output += `- "Create technical design doc for [feature] with architecture diagrams"\n`;
            output += `- "Write API specification (OpenAPI/Swagger) for [feature] endpoints"\n`;
            output += `- "Generate test plan covering happy path, edge cases, and error scenarios"\n`;
            output += `- "Draft database migration script for [feature] schema changes"\n\n`;
            output += `**For Research:**\n`;
            output += `- "Find 3 competitor implementations of [feature] with screenshots"\n`;
            output += `- "Research best practices for [feature type] in SaaS applications"\n`;
            output += `- "Identify potential technical challenges for [feature] implementation"\n\n`;

            return output;
        }

        // Generate Book/Novel prompt (manuscript-ready, narrative-focused)
        function generateBookPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸ“š'} ${tree.name || 'Book Manuscript'}\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Calculate manuscript metrics
            let totalWordCount = 0;
            let targetWordCount = 0;
            let totalChapters = 0;
            const chapterMetrics = [];

            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.type === 'phase' && chapter.items) {
                        let chapterWords = 0;
                        let chapterTarget = 0;
                        let sceneCount = chapter.items.length;

                        chapter.items.forEach(scene => {
                            chapterWords += scene.wordCount || 0;
                            chapterTarget += scene.targetWordCount || 0;
                        });

                        chapterMetrics.push({
                            name: chapter.name || `Chapter ${chapter.phase + 1}`,
                            subtitle: chapter.subtitle,
                            current: chapterWords,
                            target: chapterTarget,
                            scenes: sceneCount,
                            progress: chapterTarget > 0 ? Math.round((chapterWords / chapterTarget) * 100) : 0
                        });

                        totalWordCount += chapterWords;
                        targetWordCount += chapterTarget;
                        totalChapters++;
                    }
                });
            }

            const overallProgress = targetWordCount > 0 ? Math.round((totalWordCount / targetWordCount) * 100) : 0;

            // Manuscript Overview
            output += `## ðŸ“– Manuscript Overview\n\n`;
            output += `**Writing Progress:**\n`;
            output += `- Current Length: ${totalWordCount.toLocaleString()} words\n`;
            output += `- Target Length: ${targetWordCount.toLocaleString()} words\n`;
            output += `- Completion: ${overallProgress}% ${overallProgress < 50 ? '(First Draft)' : overallProgress < 80 ? '(Revision Stage)' : '(Near Final)'}\n`;
            output += `- Structure: ${totalChapters} chapters\n`;
            output += `- Average Chapter: ${Math.round(totalWordCount / totalChapters).toLocaleString()} words\n\n`;

            // Story Arc Analysis
            output += `## ðŸŽ­ Story Arc Structure\n\n`;
            chapterMetrics.forEach((ch, idx) => {
                const position = idx / (totalChapters - 1);
                let arcStage = '';
                if (position < 0.25) arcStage = 'ðŸ“ Setup/Exposition';
                else if (position < 0.5) arcStage = 'â¬†ï¸ Rising Action';
                else if (position < 0.75) arcStage = 'ðŸ”¥ Climax/Conflict';
                else arcStage = 'â¬‡ï¸ Falling Action/Resolution';

                const progressBar = 'â–ˆ'.repeat(Math.floor(ch.progress / 10)) + 'â–‘'.repeat(10 - Math.floor(ch.progress / 10));
                output += `### ${ch.name} ${arcStage}\n`;
                output += `- Progress: [${progressBar}] ${ch.progress}%\n`;
                output += `- Word Count: ${ch.current.toLocaleString()} / ${ch.target.toLocaleString()} words\n`;
                output += `- Scenes: ${ch.scenes}\n\n`;
            });

            // Scene Breakdown
            output += `---\n\n## ðŸ“ Scene-by-Scene Breakdown\n\n`;

            if (tree.children) {
                tree.children.forEach((chapter, chIdx) => {
                    if (chapter.type === 'phase' && chapter.items && chapter.items.length > 0) {
                        output += `### ${chapter.name || `Chapter ${chIdx + 1}`}${chapter.subtitle ? ` â€” ${chapter.subtitle}` : ''}\n\n`;

                        chapter.items.forEach((scene, sIdx) => {
                            output += `#### Scene ${sIdx + 1}: ${scene.name}\n\n`;

                            // Scene metadata
                            const sceneMetadata = [];
                            if (scene.povCharacter) sceneMetadata.push(`**POV:** ${scene.povCharacter}`);
                            if (scene.sceneSetting) sceneMetadata.push(`**Setting:** ${scene.sceneSetting}`);
                            if (scene.plotFunction) sceneMetadata.push(`**Plot Function:** ${scene.plotFunction}`);

                            if (sceneMetadata.length > 0) {
                                output += sceneMetadata.join(' â€¢ ') + '\n\n';
                            }

                            // Scene description
                            if (scene.description) {
                                output += `**What Happens:**\n${scene.description}\n\n`;
                            }

                            // Writing progress
                            if (scene.wordCount !== undefined || scene.targetWordCount) {
                                const sceneProgress = scene.targetWordCount > 0 ? Math.round((scene.wordCount || 0) / scene.targetWordCount * 100) : 0;
                                output += `**Writing Status:** ${scene.wordCount || 0} words (${sceneProgress}% of ${scene.targetWordCount || '?'} target)`;
                                if (scene.draftStatus) {
                                    output += ` â€” ${scene.draftStatus}`;
                                }
                                output += `\n\n`;
                            }

                            // Beats/moments within scene
                            if (scene.children && scene.children.length > 0) {
                                output += `**Story Beats:**\n`;
                                scene.children.forEach((beat, bIdx) => {
                                    output += `${bIdx + 1}. ${beat.name}`;
                                    if (beat.description) {
                                        output += ` â€” ${beat.description}`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Writing Recommendations
            output += `## âœï¸ Writing Strategy & Next Steps\n\n`;
            output += `**Manuscript Status:**\n`;
            if (overallProgress < 50) {
                output += `- Stage: First Draft â€” focus on completing story structure\n`;
                output += `- Priority: Write forward, don't revise yet\n`;
                output += `- Goal: Reach "The End" before editing\n\n`;
            } else if (overallProgress < 80) {
                output += `- Stage: Revision â€” deepen character arcs and pacing\n`;
                output += `- Priority: Address plot holes and character motivation\n`;
                output += `- Goal: Complete second draft with all scenes polished\n\n`;
            } else {
                output += `- Stage: Final Polish â€” line edits and beta feedback\n`;
                output += `- Priority: Professional editing and proofreading\n`;
                output += `- Goal: Query-ready or publish-ready manuscript\n\n`;
            }

            output += `**Story Development Checklist:**\n`;
            output += `1. Character Arcs: Do all major characters change/grow?\n`;
            output += `2. Plot Coherence: Are there any unresolved threads?\n`;
            output += `3. Pacing: Does each scene advance plot or deepen character?\n`;
            output += `4. Setting: Is the world vivid and consistent?\n`;
            output += `5. Theme: Are thematic elements woven throughout?\n\n`;

            output += `**Scene-Level Quality:**\n`;
            output += `- Each scene should have: Goal, Conflict, Disaster (or Resolution)\n`;
            output += `- POV consistency within chapters\n`;
            output += `- Vary scene length for pacing (long for tension, short for action)\n`;
            output += `- End chapters with hooks to keep readers engaged\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ AI Prompt Usage - Manuscript Deliverables:**\n`;
            output += `\n`;
            output += `**For Drafting:**\n`;
            output += `- "Write a 1000-word opening scene for [chapter] from [POV character]'s perspective"\n`;
            output += `- "Expand [scene name] with more sensory details and emotional depth"\n`;
            output += `- "Draft dialogue between [character A] and [character B] about [conflict]"\n`;
            output += `- "Write the climax scene where [key plot event] happens"\n\n`;
            output += `**For Revision:**\n`;
            output += `- "Analyze character arc for [protagonist] - identify weak character development"\n`;
            output += `- "Find pacing issues in Act 2 - which scenes drag or feel rushed?"\n`;
            output += `- "Suggest ways to increase tension in [chapter name]"\n`;
            output += `- "Identify plot holes or inconsistencies in the manuscript"\n\n`;
            output += `**For Publishing:**\n`;
            output += `- "Write a compelling 300-word book blurb for marketing"\n`;
            output += `- "Generate 20 comp titles (comparable books) with explanation"\n`;
            output += `- "Draft query letter to literary agents highlighting unique elements"\n`;
            output += `- "Create chapter summaries for submission synopsis (1-2 sentences each)"\n\n`;

            return output;
        }

        // Generate Course/Training prompt (curriculum-ready, learning-focused)
        function generateCoursePrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸ“–'} ${tree.name || 'Course Curriculum'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate course metrics
            let totalDuration = 0;
            let totalLessons = 0;
            let assessmentCount = 0;
            const moduleMetrics = [];

            if (tree.children) {
                tree.children.forEach(module => {
                    if (module.type === 'phase' && module.items) {
                        let moduleDuration = 0;
                        let lessonCount = module.items.length;

                        module.items.forEach(lesson => {
                            // Parse duration (e.g., "2 hours", "45 minutes")
                            if (lesson.duration) {
                                const match = lesson.duration.match(/(\d+)\s*(hour|minute|min)/i);
                                if (match) {
                                    const value = parseInt(match[1]);
                                    const unit = match[2].toLowerCase();
                                    moduleDuration += unit.startsWith('hour') ? value * 60 : value;
                                }
                            }
                            if (lesson.assessmentType && lesson.assessmentType !== 'None') {
                                assessmentCount++;
                            }
                        });

                        moduleMetrics.push({
                            name: module.name || `Module ${module.phase + 1}`,
                            subtitle: module.subtitle,
                            duration: moduleDuration,
                            lessons: lessonCount
                        });

                        totalDuration += moduleDuration;
                        totalLessons += lessonCount;
                    }
                });
            }

            const totalHours = Math.floor(totalDuration / 60);
            const totalMinutes = totalDuration % 60;

            // Course Overview
            output += `## ðŸŽ“ Course Overview\n\n`;
            output += `**Course Specifications:**\n`;
            output += `- Total Duration: ${totalHours}h ${totalMinutes}m\n`;
            output += `- Total Modules: ${moduleMetrics.length}\n`;
            output += `- Total Lessons: ${totalLessons}\n`;
            output += `- Assessments: ${assessmentCount}\n`;
            output += `- Average Lesson: ${Math.round(totalDuration / totalLessons)} minutes\n\n`;

            // Learning Path
            output += `## ðŸ›¤ï¸ Learning Path Structure\n\n`;
            moduleMetrics.forEach((mod, idx) => {
                const modHours = Math.floor(mod.duration / 60);
                const modMinutes = mod.duration % 60;
                output += `### Module ${idx + 1}: ${mod.name}${mod.subtitle ? ` â€” ${mod.subtitle}` : ''}\n`;
                output += `- Duration: ${modHours}h ${modMinutes}m\n`;
                output += `- Lessons: ${mod.lessons}\n`;
                output += `- Average Lesson: ${Math.round(mod.duration / mod.lessons)} minutes\n\n`;
            });

            // Detailed Curriculum
            output += `---\n\n## ðŸ“š Detailed Curriculum\n\n`;

            if (tree.children) {
                tree.children.forEach((module, modIdx) => {
                    if (module.type === 'phase' && module.items && module.items.length > 0) {
                        output += `### Module ${modIdx + 1}: ${module.name || `Module ${modIdx + 1}`}\n\n`;
                        if (module.subtitle) {
                            output += `*${module.subtitle}*\n\n`;
                        }

                        module.items.forEach((lesson, lesIdx) => {
                            output += `#### Lesson ${modIdx + 1}.${lesIdx + 1}: ${lesson.name}\n\n`;

                            // Lesson metadata
                            const metadata = [];
                            if (lesson.duration) metadata.push(`â±ï¸ ${lesson.duration}`);
                            if (lesson.difficultyLevel) metadata.push(`ðŸ“Š ${lesson.difficultyLevel}`);
                            if (lesson.assessmentType && lesson.assessmentType !== 'None') metadata.push(`âœ… ${lesson.assessmentType}`);

                            if (metadata.length > 0) {
                                output += metadata.join(' â€¢ ') + '\n\n';
                            }

                            // Learning objectives
                            if (lesson.learningObjectives) {
                                output += `**Learning Objectives:**\n${lesson.learningObjectives}\n\n`;
                            }

                            // Lesson description
                            if (lesson.description) {
                                output += `**Lesson Content:**\n${lesson.description}\n\n`;
                            }

                            // Prerequisites
                            if (lesson.prerequisites) {
                                output += `**Prerequisites:** ${lesson.prerequisites}\n\n`;
                            }

                            // Resources
                            if (lesson.resourcesNeeded) {
                                output += `**Resources Needed:** ${lesson.resourcesNeeded}\n\n`;
                            }

                            // Activities/exercises
                            if (lesson.children && lesson.children.length > 0) {
                                output += `**Activities & Exercises:**\n`;
                                lesson.children.forEach((activity, aIdx) => {
                                    output += `${aIdx + 1}. ${activity.name}`;
                                    if (activity.duration) {
                                        output += ` (${activity.duration})`;
                                    }
                                    if (activity.description) {
                                        output += `\n   ${activity.description}`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (lesson.dependencies && lesson.dependencies.length > 0) {
                                output += `**âš ï¸ Requires Completion Of:** ${lesson.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Course Development Recommendations
            output += `## ðŸŽ¯ Course Development Strategy\n\n`;
            output += `**Instructional Design Checklist:**\n`;
            output += `1. Learning Objectives: Each lesson has clear, measurable outcomes\n`;
            output += `2. Scaffolding: Concepts build progressively from simple to complex\n`;
            output += `3. Active Learning: Mix of theory, practice, and assessment\n`;
            output += `4. Engagement: Vary content types (video, text, interactive, projects)\n`;
            output += `5. Assessment: Regular checkpoints to verify understanding\n\n`;

            output += `**Course Quality Standards:**\n`;
            output += `- Lesson Length: Keep videos 10-20 minutes for optimal retention\n`;
            output += `- Practice Ratio: 70% practice, 30% theory for skill-based courses\n`;
            output += `- Assessment Frequency: Quiz or exercise every 3-4 lessons\n`;
            output += `- Resource Quality: Provide downloadable templates, cheat sheets, references\n`;
            output += `- Community: Discussion forums or peer review for social learning\n\n`;

            output += `**Production Planning:**\n`;
            const avgLessonTime = Math.round(totalDuration / totalLessons);
            const videoHours = Math.ceil(totalHours * 2); // 2:1 production ratio
            output += `- Video Production Time: ~${videoHours} hours (2:1 ratio for recording/editing)\n`;
            output += `- Script Writing: ~2 hours per lesson (${totalLessons * 2} hours total)\n`;
            output += `- Assessment Creation: ~1 hour per quiz/exercise\n`;
            output += `- Platform Setup: LMS configuration, student enrollment, progress tracking\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ AI Prompt Usage - Course Deliverables:**\n`;
            output += `\n`;
            output += `**For Content Creation:**\n`;
            output += `- "Write a detailed lesson script for [lesson name] covering [learning objectives]"\n`;
            output += `- "Create 10 multiple-choice quiz questions for [module] with explanations"\n`;
            output += `- "Design a hands-on project assignment for [topic] with rubric"\n`;
            output += `- "Generate practice exercises with solutions for [concept]"\n\n`;
            output += `**For Course Materials:**\n`;
            output += `- "Create a 1-page cheat sheet summarizing [module] key concepts"\n`;
            output += `- "Write downloadable PDF guide for [technical skill] with examples"\n`;
            output += `- "Design flashcards for memorizing [terminology/concepts]"\n`;
            output += `- "Generate code templates/starter files for [programming lesson]"\n\n`;
            output += `**For Marketing & Launch:**\n`;
            output += `- "Write compelling course description highlighting unique value (300 words)"\n`;
            output += `- "Create course landing page copy with benefits, outcomes, testimonials"\n`;
            output += `- "Generate lesson previews and free samples to attract students"\n`;
            output += `- "Draft email sequence for course launch (5 emails over 2 weeks)"\n\n`;
            output += `**For Student Support:**\n`;
            output += `- "Create FAQ document answering common student questions"\n`;
            output += `- "Write discussion prompts for community engagement in forums"\n`;
            output += `- "Generate personalized feedback templates for assignment reviews"\n\n`;

            return output;
        }

        // Generate Academic Thesis prompt (manuscript-ready, scholarly)
        function generateThesisPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸŽ“'} ${tree.name || 'Thesis'}\n\n`;

            if (tree.description) {
                output += `> ${tree.description}\n\n`;
            }

            // Calculate manuscript metrics
            let totalWordCount = 0;
            let targetWordCount = 0;
            let totalChapters = 0;
            const chapterMetrics = [];

            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.type === 'phase' && chapter.items) {
                        let chapterWords = 0;
                        let chapterTarget = 0;
                        let sectionCount = chapter.items.length;

                        chapter.items.forEach(section => {
                            chapterWords += section.wordCount || 0;
                            chapterTarget += section.targetWordCount || 0;
                        });

                        chapterMetrics.push({
                            name: chapter.name || `Chapter ${chapter.phase + 1}`,
                            subtitle: chapter.subtitle,
                            current: chapterWords,
                            target: chapterTarget,
                            sections: sectionCount,
                            progress: chapterTarget > 0 ? Math.round((chapterWords / chapterTarget) * 100) : 0
                        });

                        totalWordCount += chapterWords;
                        targetWordCount += chapterTarget;
                        totalChapters++;
                    }
                });
            }

            const overallProgress = targetWordCount > 0 ? Math.round((totalWordCount / targetWordCount) * 100) : 0;

            // Document Metadata
            output += `## ðŸ“„ Document Metadata\n\n`;
            output += `**Manuscript Status:**\n`;
            output += `- Current Length: ${totalWordCount.toLocaleString()} words\n`;
            output += `- Target Length: ${targetWordCount.toLocaleString()} words\n`;
            output += `- Completion: ${overallProgress}% (${totalWordCount}/${targetWordCount})\n`;
            output += `- Structure: ${totalChapters} chapters across ${pattern.levels.phase}\n`;
            output += `- Average Chapter: ${Math.round(totalWordCount / totalChapters).toLocaleString()} words\n\n`;

            // Chapter Breakdown with Progress
            output += `## ðŸ“š Chapter Structure\n\n`;
            chapterMetrics.forEach((ch, idx) => {
                const progressBar = 'â–ˆ'.repeat(Math.floor(ch.progress / 10)) + 'â–‘'.repeat(10 - Math.floor(ch.progress / 10));
                output += `### ${ch.name}${ch.subtitle ? ` â€” ${ch.subtitle}` : ''}\n`;
                output += `- Progress: [${progressBar}] ${ch.progress}%\n`;
                output += `- Word Count: ${ch.current.toLocaleString()} / ${ch.target.toLocaleString()} words\n`;
                output += `- Sections: ${ch.sections}\n\n`;
            });

            // Chapter Details
            output += `---\n\n## ðŸ“– Detailed Chapter Content\n\n`;

            if (tree.children) {
                tree.children.forEach((chapter, chIdx) => {
                    if (chapter.type === 'phase' && chapter.items && chapter.items.length > 0) {
                        output += `### ${chapter.name || `Chapter ${chIdx + 1}`}${chapter.subtitle ? ` â€” ${chapter.subtitle}` : ''}\n\n`;

                        chapter.items.forEach((section, sIdx) => {
                            output += `#### ${sIdx + 1}. ${section.name}\n\n`;

                            // Section metadata
                            if (section.keyArgument) {
                                output += `**Central Argument:**\n`;
                                output += `${section.keyArgument}\n\n`;
                            }

                            if (section.description) {
                                output += `**Section Overview:**\n`;
                                output += `${section.description}\n\n`;
                            }

                            // Evidence & Methodology
                            const hasMethodology = section.evidenceType || section.citations;
                            if (hasMethodology) {
                                output += `**Evidence & Methods:**\n`;
                                if (section.evidenceType) {
                                    output += `- Evidence Type: ${section.evidenceType}\n`;
                                }
                                if (section.citations) {
                                    output += `- Key Citations: ${section.citations}\n`;
                                }
                                output += `\n`;
                            }

                            // Writing Progress
                            if (section.wordCount !== undefined || section.targetWordCount) {
                                const sectionProgress = section.targetWordCount > 0 ? Math.round((section.wordCount || 0) / section.targetWordCount * 100) : 0;
                                output += `**Writing Progress:**\n`;
                                output += `- Current: ${section.wordCount || 0} words\n`;
                                output += `- Target: ${section.targetWordCount || 'TBD'} words\n`;
                                output += `- Status: ${sectionProgress}% complete`;
                                if (section.draftStatus) {
                                    output += ` (${section.draftStatus})`;
                                }
                                output += `\n\n`;
                            }

                            // Subsections/Arguments
                            if (section.children && section.children.length > 0) {
                                output += `**Sub-arguments:**\n`;
                                section.children.forEach((sub, subIdx) => {
                                    output += `${subIdx + 1}. ${sub.name}`;
                                    if (sub.keyArgument) {
                                        output += ` â€” ${sub.keyArgument}`;
                                    }
                                    if (sub.citations) {
                                        output += ` [${sub.citations}]`;
                                    }
                                    output += `\n`;
                                });
                                output += `\n`;
                            }

                            // Dependencies
                            if (section.dependencies && section.dependencies.length > 0) {
                                output += `**âš ï¸ Dependencies:** This section builds on: ${section.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Writing Recommendations
            output += `## âœï¸ Writing Recommendations\n\n`;
            output += `**Manuscript Completeness:**\n`;
            output += `- Overall Progress: ${overallProgress}% complete\n`;
            if (overallProgress < 50) {
                output += `- Status: Early draft stage â€” focus on completing first drafts of all chapters\n`;
            } else if (overallProgress < 80) {
                output += `- Status: Mid-stage â€” focus on deepening arguments and adding evidence\n`;
            } else {
                output += `- Status: Late stage â€” focus on revision, citations, and cohesion\n`;
            }
            output += `- Remaining: ${(targetWordCount - totalWordCount).toLocaleString()} words to target length\n\n`;

            output += `**Chapter Balance:**\n`;
            const chapterLengths = chapterMetrics.map(ch => ch.current);
            const avgChapter = chapterLengths.reduce((a, b) => a + b, 0) / chapterLengths.length;
            const imbalanced = chapterLengths.filter(len => len < avgChapter * 0.5 || len > avgChapter * 1.5);
            if (imbalanced.length > 0) {
                output += `- âš ï¸ ${imbalanced.length} chapter(s) significantly differ from average length\n`;
                output += `- Consider redistributing content or adjusting targets\n`;
            } else {
                output += `- âœ“ Chapters are relatively balanced in length\n`;
            }
            output += `\n`;

            output += `**Academic Quality Checks:**\n`;
            output += `1. Citation Coverage: Ensure each major claim has 2-3 supporting citations\n`;
            output += `2. Argument Coherence: Check logical flow within and between chapters\n`;
            output += `3. Evidence Types: Balance theoretical, empirical, and case study evidence\n`;
            output += `4. Literature Gaps: Identify missing perspectives or counter-arguments\n`;
            output += `5. Methodological Rigor: Document methods, limitations, and validity\n\n`;

            output += `**Next Steps:**\n`;
            const incompleteSections = [];
            if (tree.children) {
                tree.children.forEach(chapter => {
                    if (chapter.items) {
                        chapter.items.forEach(section => {
                            if (!section.wordCount || section.wordCount < (section.targetWordCount || 0) * 0.5) {
                                incompleteSections.push(section.name);
                            }
                        });
                    }
                });
            }
            if (incompleteSections.length > 0) {
                output += `- Priority: Complete ${incompleteSections.length} under-developed section(s)\n`;
                output += `- Focus areas: ${incompleteSections.slice(0, 3).join(', ')}${incompleteSections.length > 3 ? '...' : ''}\n`;
            }
            output += `- Review: Get feedback from advisors on completed chapters\n`;
            output += `- Citations: Update and complete bibliography\n`;
            output += `- Editing: Professional copyediting for polished sections\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ AI Prompt Usage:** This academic manuscript can be used to:\n`;
            output += `- Ask AI to critique arguments and suggest counter-arguments\n`;
            output += `- Generate literature review summaries for each chapter\n`;
            output += `- Draft section transitions and chapter conclusions\n`;
            output += `- Suggest additional citations based on argument types\n`;
            output += `- Create visual abstracts and conference presentations\n`;
            output += `- Identify methodological weaknesses and suggest improvements\n`;
            output += `- Generate research questions for future studies\n\n`;

            return output;
        }

        // Generate Sales Pipeline prompt (executive-ready, action-oriented)
        function generateSalesPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸ’¼'} ${tree.name || 'Sales Pipeline'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            // Calculate pipeline metrics
            let totalPipelineValue = 0;
            let weightedPipelineValue = 0;
            let totalDeals = 0;
            const quarterMetrics = [];

            if (tree.children) {
                tree.children.forEach(quarter => {
                    if (quarter.type === 'phase' && quarter.items) {
                        let quarterTotal = 0;
                        let quarterWeighted = 0;
                        let quarterDeals = quarter.items.length;

                        quarter.items.forEach(deal => {
                            const dealValue = deal.dealValue || 0;
                            const probability = deal.stageProbability || deal.probability || 0;

                            quarterTotal += dealValue;
                            quarterWeighted += (dealValue * probability / 100);
                        });

                        quarterMetrics.push({
                            name: quarter.name || `Quarter ${quarter.phase + 1}`,
                            subtitle: quarter.subtitle,
                            total: quarterTotal,
                            weighted: quarterWeighted,
                            deals: quarterDeals
                        });

                        totalPipelineValue += quarterTotal;
                        weightedPipelineValue += quarterWeighted;
                        totalDeals += quarterDeals;
                    }
                });
            }

            // Executive Summary
            output += `## ðŸ“Š Executive Summary\n\n`;
            output += `**Pipeline Health:**\n`;
            output += `- Total Pipeline Value: $${totalPipelineValue.toLocaleString()}\n`;
            output += `- Weighted Pipeline (Probability Adjusted): $${Math.round(weightedPipelineValue).toLocaleString()}\n`;
            output += `- Total Active Deals: ${totalDeals}\n`;
            output += `- Average Deal Size: $${Math.round(totalPipelineValue / totalDeals).toLocaleString()}\n`;
            output += `- Weighted Close Rate: ${Math.round(weightedPipelineValue / totalPipelineValue * 100)}%\n\n`;

            // Quarterly Breakdown
            output += `## ðŸ“… Quarterly Breakdown\n\n`;
            quarterMetrics.forEach((q, idx) => {
                output += `### ${q.name}${q.subtitle ? ` - ${q.subtitle}` : ''}\n`;
                output += `- Pipeline: $${q.total.toLocaleString()} (${q.deals} deals)\n`;
                output += `- Expected Revenue: $${Math.round(q.weighted).toLocaleString()}\n`;
                output += `- Conversion Confidence: ${Math.round(q.weighted / q.total * 100)}%\n\n`;
            });

            // Deal Details by Quarter
            output += `---\n\n## ðŸ’¼ Deal Pipeline\n\n`;

            if (tree.children) {
                tree.children.forEach((quarter, qIdx) => {
                    if (quarter.type === 'phase' && quarter.items && quarter.items.length > 0) {
                        output += `### ${quarter.name || `Quarter ${qIdx + 1}`}\n\n`;

                        quarter.items.forEach((deal, dIdx) => {
                            const dealValue = deal.dealValue || 0;
                            const probability = deal.stageProbability || deal.probability || 0;
                            const expectedRevenue = Math.round(dealValue * probability / 100);

                            output += `#### ${dIdx + 1}. ${deal.name}\n\n`;

                            // Deal metrics bar
                            output += `**Deal Snapshot:**\n`;
                            output += `- ðŸ’° Value: $${dealValue.toLocaleString()}\n`;
                            output += `- ðŸ“Š Probability: ${probability}%\n`;
                            output += `- ðŸ’µ Expected Revenue: $${expectedRevenue.toLocaleString()}\n`;
                            if (deal.expectedCloseDate || deal.expectedClose) {
                                output += `- ðŸ“… Target Close: ${deal.expectedCloseDate || deal.expectedClose}\n`;
                            }
                            if (deal.accountExecutive) {
                                output += `- ðŸ‘¤ Account Executive: ${deal.accountExecutive}\n`;
                            }
                            if (deal.itemType) {
                                const typeLabel = pattern.types.find(t => t.value === deal.itemType)?.label || deal.itemType;
                                output += `- ðŸ·ï¸ Deal Type: ${typeLabel}\n`;
                            }
                            if (deal.status) {
                                output += `- ðŸ“ Status: ${deal.status}\n`;
                            }
                            if (deal.leadTime) {
                                output += `- â±ï¸ Sales Cycle: ${deal.leadTime}\n`;
                            }
                            output += `\n`;

                            if (deal.description) {
                                output += `**Overview:**\n${deal.description}\n\n`;
                            }

                            // Action items / Next steps
                            if (deal.children && deal.children.length > 0) {
                                output += `**Action Items:**\n`;
                                deal.children.forEach((action, aIdx) => {
                                    output += `${aIdx + 1}. **${action.name}**\n`;
                                    if (action.description) {
                                        output += `   ${action.description}\n`;
                                    }
                                    if (action.expectedClose || action.expectedCloseDate) {
                                        output += `   _Due: ${action.expectedClose || action.expectedCloseDate}_\n`;
                                    }
                                    if (action.dependencies && action.dependencies.length > 0) {
                                        output += `   _Depends on: ${action.dependencies.join(', ')}_\n`;
                                    }
                                    output += `\n`;
                                });
                            }

                            // Competitive intelligence
                            if (deal.competitorInfo) {
                                output += `**ðŸŽ¯ Competitive Landscape:**\n${deal.competitorInfo}\n\n`;
                            }

                            // Dependencies/blockers
                            if (deal.dependencies && deal.dependencies.length > 0) {
                                output += `**âš ï¸ Dependencies:** This deal depends on: ${deal.dependencies.join(', ')}\n\n`;
                            }

                            output += `---\n\n`;
                        });
                    }
                });
            }

            // Risk Analysis & Recommendations
            output += `## âš ï¸ Risk Analysis & Recommendations\n\n`;
            output += `**Pipeline Coverage:**\n`;
            const averageCloseRate = Math.round(weightedPipelineValue / totalPipelineValue * 100);
            output += `- Current weighted close rate: ${averageCloseRate}%\n`;
            output += `- To hit 100% of targets, maintain ${Math.round(100 / averageCloseRate)}x pipeline coverage\n`;
            output += `- Low-probability deals (<50%): Focus on advancing or disqualifying quickly\n`;
            output += `- High-value deals (>$500K): Ensure executive sponsorship and multi-threading\n\n`;

            output += `**Key Actions:**\n`;
            output += `1. Accelerate deals in late stages (>70% probability) to close within quarter\n`;
            output += `2. Qualify out deals stuck in discovery for >2 months\n`;
            output += `3. Build relationships with economic buyers, not just champions\n`;
            output += `4. Document competitive wins and losses for pattern analysis\n`;
            output += `5. Request customer references from recent wins for social proof\n\n`;

            output += `---\n\n`;
            output += `**ðŸ’¡ AI Prompt Usage:** This sales pipeline can be used to:\n`;
            output += `- Ask AI to analyze deal health and suggest next best actions\n`;
            output += `- Generate sales enablement materials (case studies, proposals, ROI calculators)\n`;
            output += `- Forecast quarterly revenue with Monte Carlo simulations\n`;
            output += `- Identify at-risk deals based on activity patterns\n`;
            output += `- Draft personalized executive emails for each stakeholder\n`;
            output += `- Create competitive battlecards from competitorInfo fields\n\n`;

            return output;
        }

        // Generate Philosophy prompts (executable, professional)
        function generatePhilosophyPrompt(tree, pattern) {
            let output = `# ${tree.icon || 'ðŸ¤”'} ${tree.name || 'Philosophical Argument'}\n\n`;

            if (tree.description) {
                output += `${tree.description}\n\n`;
            }

            output += `**Professional Philosophy Prompt** - Copy-paste ready for Claude/GPT-4\n\n`;
            output += `---\n\n`;

            // Collect all arguments
            const allArguments = [];
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach(item => {
                            allArguments.push({
                                ...item,
                                phaseName: phase.name,
                                phaseSubtitle: phase.subtitle
                            });
                        });
                    }
                });
            }

            if (allArguments.length === 0) {
                output += `*No arguments defined yet. Add items to your tree.*\n`;
                return output;
            }

            // Detect speakers and dialogue partners
            const speakers = [...new Set(allArguments.map(a => a.speaker).filter(s => s))];
            const primarySpeaker = speakers[0] || 'The Philosopher';
            const isDialogue = speakers.length > 1;

            // SYNTHESIZE: Create professional philosophical prompt

            // 1. CONTEXT & ROLE
            output += `## ðŸ“š Context\n\n`;
            output += `This is a ${isDialogue ? 'philosophical dialogue' : 'structured argument'} `;
            if (speakers.length > 0) {
                output += `featuring ${speakers.join(', ')}. `;
            }
            output += `The argument progresses through ${tree.children.length} major movements with ${allArguments.length} distinct claims.\n\n`;

            // 2. MAIN PROMPT
            output += `## ðŸ’­ Your Task\n\n`;
            output += `You are a philosophy professor preparing a comprehensive critical analysis. Write a 2500-word essay that:\n\n`;

            output += `**1. Reconstructs the Argument**\n`;
            output += `- Present each major claim in logical order\n`;
            output += `- Identify premises, inferences, and conclusions\n`;
            output += `- Map the dependency structure (which claims build on others)\n\n`;

            output += `**2. Evaluates Logical Validity**\n`;
            output += `- Are the inferences sound?\n`;
            output += `- Do the conclusions follow from the premises?\n`;
            output += `- What hidden assumptions are made?\n`;
            output += `- Are there logical fallacies?\n\n`;

            output += `**3. Engages Philosophically**\n`;
            output += `- What are the strongest objections to this view?\n`;
            output += `- How might the author respond?\n`;
            output += `- What implications does this have for ethics, epistemology, or metaphysics?\n`;
            output += `- How does this compare to contemporary philosophical positions?\n\n`;

            output += `**4. Applies to Modern Context**\n`;
            output += `- What modern issues does this illuminate?\n`;
            output += `- How would this argument address current debates?\n`;
            output += `- Is this view still defensible today? Why or why not?\n\n`;

            // 3. THE ARGUMENT STRUCTURE (as reference)
            output += `---\n\n`;
            output += `## ðŸ“– The Argument Structure\n\n`;
            output += `Use this as your reference material for the analysis above:\n\n`;

            tree.children.forEach((phase, phaseIdx) => {
                output += `### ${phase.name}\n`;
                if (phase.subtitle) {
                    output += `*${phase.subtitle}*\n`;
                }
                output += `\n`;

                if (phase.items && phase.items.length > 0) {
                    phase.items.forEach((item, itemIdx) => {
                        output += `**Argument ${phaseIdx + 1}.${itemIdx + 1}: ${item.name}**\n\n`;

                        if (item.description) {
                            output += `${item.description}\n\n`;
                        }

                        // Build structured argument info
                        const argDetails = [];

                        if (item.speaker) argDetails.push(`*Speaker*: ${item.speaker}`);
                        if (item.argumentType) argDetails.push(`*Type*: ${item.argumentType}`);
                        if (item.keyTerms) argDetails.push(`*Key Terms*: ${item.keyTerms}`);

                        if (argDetails.length > 0) {
                            output += argDetails.join(' â€¢ ') + '\n\n';
                        }

                        // Premises and conclusion in structured format
                        if (item.premise1 || item.premise2 || item.conclusion) {
                            output += `<argument>\n`;
                            if (item.premise1) output += `**P1**: ${item.premise1}\n\n`;
                            if (item.premise2) output += `**P2**: ${item.premise2}\n\n`;
                            if (item.premise3) output += `**P3**: ${item.premise3}\n\n`;
                            if (item.conclusion) output += `**âˆ´**: ${item.conclusion}\n`;
                            output += `</argument>\n\n`;
                        }

                        // Dependencies
                        if (item.dependencies && item.dependencies.length > 0) {
                            output += `*Builds on*: ${item.dependencies.join(', ')}\n\n`;
                        }

                        // Subtasks as supporting points
                        if (item.subtasks && item.subtasks.length > 0) {
                            output += `*Supporting points*:\n`;
                            item.subtasks.forEach(sub => {
                                output += `- ${sub.name}`;
                                if (sub.description) output += `: ${sub.description}`;
                                output += `\n`;
                            });
                            output += `\n`;
                        }
                    });
                }
            });

            // 4. OUTPUT STRUCTURE
            output += `---\n\n`;
            output += `## âœï¸ Essay Structure\n\n`;
            output += `Your 2500-word analysis should follow this structure:\n\n`;
            output += `**Introduction (300 words)**\n`;
            output += `- Introduce the philosophical problem\n`;
            output += `- State the main thesis being examined\n`;
            output += `- Preview your analytical approach\n\n`;

            output += `**Part I: Argument Reconstruction (600 words)**\n`;
            output += `- Present the argument structure clearly\n`;
            output += `- Identify all major premises and conclusions\n`;
            output += `- Map the logical flow and dependencies\n\n`;

            output += `**Part II: Logical Analysis (500 words)**\n`;
            output += `- Evaluate validity and soundness\n`;
            output += `- Identify hidden assumptions\n`;
            output += `- Note any fallacies or weak inferences\n\n`;

            output += `**Part III: Philosophical Engagement (600 words)**\n`;
            output += `- Present strongest objections\n`;
            output += `- Consider author's possible responses\n`;
            output += `- Discuss broader philosophical implications\n\n`;

            output += `**Part IV: Modern Application (400 words)**\n`;
            output += `- Connect to contemporary issues\n`;
            output += `- Assess relevance and defensibility today\n`;
            output += `- Suggest modifications or extensions\n\n`;

            output += `**Conclusion (100 words)**\n`;
            output += `- Summarize your analysis\n`;
            output += `- State your final evaluation of the argument\n\n`;

            // 5. EVALUATION CRITERIA
            output += `---\n\n`;
            output += `## âœ“ Success Criteria\n\n`;
            output += `Your essay should demonstrate:\n`;
            output += `- âœ… Accurate reconstruction of all ${allArguments.length} arguments\n`;
            output += `- âœ… Rigorous logical analysis using formal/informal logic\n`;
            output += `- âœ… Engagement with key philosophical concepts: ${getKeyTerms(allArguments)}\n`;
            output += `- âœ… Awareness of relevant philosophical traditions and debates\n`;
            output += `- âœ… Clear, precise philosophical writing (avoid vagueness)\n`;
            output += `- âœ… Fair-minded treatment (steel man, not straw man objections)\n`;
            output += `- âœ… Creative application to modern contexts\n`;
            output += `- âœ… Original insights, not mere summary\n\n`;

            // 6. ALTERNATIVE PROMPT MODES
            output += `---\n\n`;
            output += `## ðŸ”„ Alternative Prompt Modes\n\n`;

            if (isDialogue) {
                output += `**Mode 1: Continue the Dialogue**\n`;
                output += `\`\`\`\n`;
                output += `You are responding to ${primarySpeaker}'s arguments. Write a philosophical `;
                output += `dialogue where you (as an interlocutor) raise 3 sophisticated objections, `;
                output += `then have ${primarySpeaker} respond to each. Use the Socratic method `;
                output += `of questioning to probe deeper.\n`;
                output += `\`\`\`\n\n`;
            }

            output += `**Mode 2: Compare to Another Philosopher**\n`;
            output += `\`\`\`\n`;
            output += `Compare this argument to [Kant/Nietzsche/Rawls/Singer]. How would [philosopher] `;
            output += `respond to these claims? Where would they agree/disagree and why? What synthesis `;
            output += `might be possible between the two views?\n`;
            output += `\`\`\`\n\n`;

            output += `**Mode 3: Logical Formalization**\n`;
            output += `\`\`\`\n`;
            output += `Formalize this argument using predicate logic. Translate each premise and `;
            output += `conclusion into logical notation (âˆ€, âˆƒ, â†’, â†”, Â¬, âˆ§, âˆ¨). Prove validity using `;
            output += `natural deduction or truth tables. Identify which premises, if any, are dubious.\n`;
            output += `\`\`\`\n\n`;

            output += `**Mode 4: Teaching Guide**\n`;
            output += `\`\`\`\n`;
            output += `Create a teaching guide for undergraduate philosophy students. Include: `;
            output += `(1) Pre-reading questions, (2) Key concepts glossary, (3) Discussion prompts, `;
            output += `(4) Thought experiments to test understanding, (5) Essay topics.\n`;
            output += `\`\`\`\n\n`;

            // 7. PHILOSOPHICAL CONTEXT
            if (allArguments.some(a => a.argumentType)) {
                output += `---\n\n`;
                output += `## ðŸŽ“ Philosophical Methods Used\n\n`;
                const argTypes = [...new Set(allArguments.map(a => a.argumentType).filter(t => t))];
                argTypes.forEach(type => {
                    const count = allArguments.filter(a => a.argumentType === type).length;
                    output += `- **${type}** (${count} argument${count > 1 ? 's' : ''})\n`;
                });
                output += `\n`;
            }

            return output;
        }

        // Helper: Extract key terms for Philosophy prompt
        function getKeyTerms(arguments) {
            const allTerms = arguments
                .map(a => a.keyTerms)
                .filter(t => t)
                .join(', ')
                .split(',')
                .map(t => t.trim())
                .filter(t => t.length > 0);

            // Get unique terms, limit to top 8
            const uniqueTerms = [...new Set(allTerms)].slice(0, 8);
            return uniqueTerms.join(', ');
        }

        // Generate generic prompt format
        function generateGenericPrompt(tree, pattern) {
            // SPECIAL CASE: AI Video Production uses different format
            if (currentPattern === 'film') {
                return generateAIVideoPrompts(tree, pattern);
            }

            // SPECIAL CASE: Philosophy uses different format
            if (currentPattern === 'philosophy') {
                return generatePhilosophyPrompt(tree, pattern);
            }

            // SPECIAL CASE: Sales Pipeline uses different format
            if (currentPattern === 'sales') {
                return generateSalesPrompt(tree, pattern);
            }

            // SPECIAL CASE: Thesis/Academic uses different format
            if (currentPattern === 'thesis') {
                return generateThesisPrompt(tree, pattern);
            }

            // SPECIAL CASE: Product Roadmap uses different format
            if (currentPattern === 'roadmap') {
                return generateRoadmapPrompt(tree, pattern);
            }

            // SPECIAL CASE: Book/Novel uses different format
            if (currentPattern === 'book') {
                return generateBookPrompt(tree, pattern);
            }

            // SPECIAL CASE: Course/Training uses different format
            if (currentPattern === 'course') {
                return generateCoursePrompt(tree, pattern);
            }

            let prompt = `# ${tree.icon || 'ðŸ“‹'} ${tree.name || 'Project'}\n\n`;

            if (tree.description) {
                prompt += `${tree.description}\n\n`;
            }

            prompt += `---\n\n`;

            // Introduction based on pattern
            const patternIntros = {
                'sales': `You are a sales analyst. Follow this structured sales pipeline analysis:`,
                'thesis': `You are an academic advisor. Follow this thesis structure:`,
                'roadmap': `You are a product manager. Follow this product roadmap:`,
                'book': `You are a writing coach. Follow this book structure:`,
                'event': `You are an event planner. Follow this event plan:`,
                'fitness': `You are a fitness coach. Follow this training program:`,
                'strategy': `You are a business strategist. Follow this strategic plan:`,
                'course': `You are an educator. Follow this course structure:`,
                'philosophy': `You are a philosophy scholar. Follow this philosophical argument:`,
                'familytree': `You are a genealogist. Follow this family tree structure:`,
                'generic': `Follow this structured workflow:`
            };

            prompt += `${patternIntros[currentPattern] || patternIntros['generic']}\n\n`;

            // Process each phase
            if (tree.children && tree.children.length > 0) {
                tree.children.forEach((phase, phaseIdx) => {
                    prompt += `## ${pattern.levels.phase} ${phaseIdx + 1}: ${phase.name}\n`;
                    if (phase.subtitle) {
                        prompt += `*${phase.subtitle}*\n`;
                    }
                    prompt += `\n`;

                    // Add items
                    if (phase.items && phase.items.length > 0) {
                        phase.items.forEach((item, itemIdx) => {
                            prompt += `### ${itemIdx + 1}. ${item.name}\n`;

                            if (item.description) {
                                prompt += `${item.description}\n`;
                            }

                            // Add ALL pattern-specific fields dynamically
                            prompt += `\n`;
                            if (pattern.fields) {
                                Object.keys(pattern.fields).forEach(fieldKey => {
                                    const fieldConfig = pattern.fields[fieldKey];

                                    // Skip non-field properties
                                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                                        return;
                                    }

                                    const value = item[fieldKey];
                                    if (value !== undefined && value !== null && value !== '') {
                                        let displayValue = value;

                                        // Format based on field type
                                        if (fieldConfig.type === 'number') {
                                            if (fieldKey === 'cost' || fieldKey === 'dealValue') {
                                                displayValue = formatCost(value);
                                            } else {
                                                displayValue = value;
                                            }
                                        } else if (fieldConfig.type === 'date') {
                                            displayValue = new Date(value).toLocaleDateString();
                                        }

                                        prompt += `- **${fieldConfig.label}**: ${displayValue}\n`;
                                    }
                                });
                            }

                            // Add dependencies
                            if (item.dependencies && item.dependencies.length > 0) {
                                const deps = Array.isArray(item.dependencies) ? item.dependencies.join(', ') : item.dependencies;
                                prompt += `- **Dependencies**: ${deps}\n`;
                            }

                            // Add PM tracking fields if present
                            if (item.pmStatus) prompt += `- **Status**: ${item.pmStatus}\n`;
                            if (item.pmAssignee) prompt += `- **Assignee**: ${item.pmAssignee}\n`;
                            if (item.pmProgress !== undefined) prompt += `- **Progress**: ${item.pmProgress}%\n`;
                            if (item.pmPriority) prompt += `- **Priority**: ${item.pmPriority}\n`;
                            if (item.pmDueDate) prompt += `- **Due Date**: ${new Date(item.pmDueDate).toLocaleDateString()}\n`;

                            // Add subtasks
                            if (item.subtasks && item.subtasks.length > 0) {
                                prompt += `\nAction steps:\n`;
                                item.subtasks.forEach((subtask, subIdx) => {
                                    prompt += `${subIdx + 1}. ${subtask.name}`;
                                    if (subtask.description) {
                                        prompt += `: ${subtask.description}`;
                                    }
                                    // Add subtask PM tracking if present
                                    const pmInfo = [];
                                    if (subtask.pmStatus) pmInfo.push(`Status: ${subtask.pmStatus}`);
                                    if (subtask.pmAssignee) pmInfo.push(`Assignee: ${subtask.pmAssignee}`);
                                    if (subtask.pmProgress !== undefined) pmInfo.push(`${subtask.pmProgress}%`);
                                    if (pmInfo.length > 0) {
                                        prompt += ` [${pmInfo.join(', ')}]`;
                                    }
                                    prompt += `\n`;
                                });
                            }

                            prompt += `\n`;
                        });
                    }

                    prompt += `\n`;
                });
            }

            // Footer
            prompt += `---\n\n`;
            prompt += `Provide a comprehensive response following this structure, addressing each ${pattern.levels.phase.toLowerCase()} and ${pattern.levels.item.toLowerCase()} systematically.\n`;

            return prompt;
        }

        // AI Modal - Overall Project Analysis (Dynamic AI-Generated)
        document.getElementById('ai-btn').addEventListener('click', async () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            const pattern = PATTERNS[currentPattern];
            const levels = pattern.levels;

            document.getElementById('modal-title').textContent = `âœ¨ ${pattern.name} Analysis`;

            // Count items by phase
            function countItems(node, counts = {p0: 0, p1: 0, p2: 0}) {
                if (node.items && node.phase !== undefined) {
                    counts[`p${node.phase}`] += node.items.length;
                }
                if (node.children) {
                    node.children.forEach(child => countItems(child, counts));
                }
                return counts;
            }

            const itemCounts = countItems(capexTree);

            // Pattern-aware summary cards
            let summaryHTML = '';

            // For financial patterns (generic, sales, roadmap, strategy)
            if (pattern.fields && pattern.fields.cost) {
                const totalCost = calculateTotal(capexTree);
                const getPhaseCost = (phaseId) => {
                    const phase = findNode(phaseId);
                    return phase ? calculatePhaseTotal(phase) : 0;
                };

                const phase0Cost = getPhaseCost('phase-0');
                const phase1Cost = getPhaseCost('phase-1');
                const phase2Cost = getPhaseCost('phase-2');

                summaryHTML = `
                    <div style="background: linear-gradient(135deg, var(--treeplex-primary), #009977); color: white; padding: 24px; border-radius: 12px; margin-bottom: 24px;">
                        <h2 style="margin-bottom: 8px; font-size: 32px;">${formatCost(totalCost)}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Total Project Investment</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-0);">
                            <div style="font-size: 11px; font-weight: 600; color: #2e7d32; margin-bottom: 4px;">${levels.phase.toUpperCase()} 1</div>
                            <div style="font-size: 20px; font-weight: 700; color: #1b5e20; margin-bottom: 4px;">${formatCost(phase0Cost)}</div>
                            <div style="font-size: 12px; color: #2e7d32;">${itemCounts.p0} ${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-1);">
                            <div style="font-size: 11px; font-weight: 600; color: #1565c0; margin-bottom: 4px;">${levels.phase.toUpperCase()} 2</div>
                            <div style="font-size: 20px; font-weight: 700; color: #0d47a1; margin-bottom: 4px;">${formatCost(phase1Cost)}</div>
                            <div style="font-size: 12px; color: #1565c0;">${itemCounts.p1} ${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #fff3e0; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-2);">
                            <div style="font-size: 11px; font-weight: 600; color: #e65100; margin-bottom: 4px;">${levels.phase.toUpperCase()} 3</div>
                            <div style="font-size: 20px; font-weight: 700; color: #bf360c; margin-bottom: 4px;">${formatCost(phase2Cost)}</div>
                            <div style="font-size: 12px; color: #e65100;">${itemCounts.p2} ${levels.item.toLowerCase()}s</div>
                        </div>
                    </div>`;
            } else {
                // For non-financial patterns (AI Prompt Design, Philosophy, etc.)
                const totalItems = itemCounts.p0 + itemCounts.p1 + itemCounts.p2;
                const totalSubtasks = capexTree.children?.reduce((acc, phase) => {
                    return acc + (phase.items?.reduce((itemAcc, item) => {
                        return itemAcc + (item.subtasks?.length || 0);
                    }, 0) || 0);
                }, 0) || 0;

                summaryHTML = `
                    <div style="background: linear-gradient(135deg, var(--treeplex-primary), #8b5cf6); color: white; padding: 24px; border-radius: 12px; margin-bottom: 24px;">
                        <h2 style="margin-bottom: 8px; font-size: 32px;">${pattern.icon} ${capexTree.name || pattern.levels.root}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">${capexTree.children?.length || 0} ${levels.phase}s â€¢ ${totalItems} ${levels.item}s â€¢ ${totalSubtasks} ${levels.subtask}s</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-0);">
                            <div style="font-size: 11px; font-weight: 600; color: #2e7d32; margin-bottom: 4px;">${levels.phase.toUpperCase()} 1</div>
                            <div style="font-size: 20px; font-weight: 700; color: #1b5e20; margin-bottom: 4px;">${itemCounts.p0}</div>
                            <div style="font-size: 12px; color: #2e7d32;">${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-1);">
                            <div style="font-size: 11px; font-weight: 600; color: #1565c0; margin-bottom: 4px;">${levels.phase.toUpperCase()} 2</div>
                            <div style="font-size: 20px; font-weight: 700; color: #0d47a1; margin-bottom: 4px;">${itemCounts.p1}</div>
                            <div style="font-size: 12px; color: #1565c0;">${levels.item.toLowerCase()}s</div>
                        </div>
                        <div style="background: #fff3e0; padding: 16px; border-radius: 8px; border-left: 4px solid var(--phase-2);">
                            <div style="font-size: 11px; font-weight: 600; color: #e65100; margin-bottom: 4px;">${levels.phase.toUpperCase()} 3</div>
                            <div style="font-size: 20px; font-weight: 700; color: #bf360c; margin-bottom: 4px;">${itemCounts.p2}</div>
                            <div style="font-size: 12px; color: #e65100;">${levels.item.toLowerCase()}s</div>
                        </div>
                    </div>`;
            }

            // Show summary + loading state for AI analysis
            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    ${summaryHTML}

                    <div id="ai-analysis-loading" style="padding: 40px; text-align: center; background: var(--card-bg); border-radius: 12px; margin-top: 20px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: var(--text-secondary); font-size: 14px;">AI is analyzing your ${pattern.name.toLowerCase()}...</p>
                        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Generating insights and recommendations</p>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">Powered by Claude Sonnet</p>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Call AI to generate the analysis sections dynamically
            console.log('ðŸ¤– Calling AI analysis at:', AI_CONFIG.apiEndpoint);
            try {
                const aiResponse = await generateAIAnalysis(capexTree, 'project');

                // Replace loading with AI-generated content
                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                        <div style="margin-bottom: 20px;">
                            <div id="ai-generated-content" style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                                <div style="white-space: pre-wrap; font-size: 14px; line-height: 1.8; color: var(--text-primary);">${aiResponse}</div>
                            </div>
                            <div style="margin-top: 16px; padding: 12px; background: rgba(0, 166, 125, 0.1); border-radius: 6px; text-align: center;">
                                <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                    ðŸ¤– Analysis powered by Claude Sonnet â€¢ Cost: ~$0.02
                                </p>
                            </div>
                        </div>
                    `;
                }

            } catch (error) {
                // Fallback to static analysis when AI is unavailable
                console.warn('AI Analysis unavailable, using static fallback:', error.message);

                const loadingEl = document.getElementById('ai-analysis-loading');
                if (loadingEl) {
                    loadingEl.outerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="background: var(--card-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border);">
                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">CRITICAL PATH ANALYSIS</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    â€¢ <strong>Land acquisition</strong> is the primary gating factor for Phase 1 execution<br>
                                    â€¢ <strong>Turbine PO deposit</strong> (${formatCost(2000000)}) secures manufacturing capacity for Phase 2<br>
                                    â€¢ <strong>Pipeline FEED</strong> and permitting run in parallel to optimize timeline<br>
                                    â€¢ Phase 2 equipment procurement has 12-18 month lead times requiring early commitment
                                </p>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">RISK ASSESSMENT</h4>
                                <p style="font-size: 14px; line-height: 1.6; color: var(--text-primary);">
                                    <strong style="color: #d32f2f;">High Risk:</strong> Phase 2 represents ${((phase2Cost/totalCost)*100).toFixed(0)}% of total budget concentrated in equipment and infrastructure.<br>
                                    <strong style="color: #f57c00;">Medium Risk:</strong> Regulatory approvals for land, pipeline, and permitting on critical path.<br>
                                    <strong style="color: #388e3c;">Low Risk:</strong> Phase 0 has manageable capital exposure with assignable land options.
                                </p>
                            </div>

                            <div style="background: linear-gradient(135deg, rgba(0, 166, 125, 0.15), rgba(0, 166, 125, 0.05)); padding: 20px; border-radius: 8px; border-left: 3px solid var(--treeplex-primary);">
                                <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--treeplex-primary); text-transform: uppercase; letter-spacing: 0.5px;">STRATEGIC RECOMMENDATIONS</h4>
                                <ul style="font-size: 14px; line-height: 2; margin: 0; padding-left: 20px; color: var(--text-primary);">
                                    <li>Secure Phase 0 land option immediately to unlock downstream activities</li>
                                    <li>Negotiate payment milestones tied to regulatory approvals</li>
                                    <li>Consider project financing for Phase 2 to preserve equity</li>
                                    <li>Establish vendor relationships early for long-lead equipment items</li>
                                    <li>Build 10-15% contingency buffer beyond stated ${formatCost(310000)} reserves</li>
                                </ul>
                            </div>
                        </div>
                        <div style="margin-top: 16px; padding: 12px; background: rgba(255, 152, 0, 0.1); border-radius: 6px; text-align: center; border: 1px solid rgba(255, 152, 0, 0.3);">
                            <p style="font-size: 11px; color: var(--text-secondary); margin: 0;">
                                â„¹ï¸ AI Analysis unavailable â€¢ Showing static analysis â€¢ Deploy to Netlify for dynamic AI insights
                            </p>
                        </div>
                    </div>
                `;
                }
            }
        });

        document.getElementById('modal-close').addEventListener('click', () => {
            document.getElementById('modal').style.display = 'none';
        });

        // =============================================================================
        // API KEY CONFIGURATION
        // =============================================================================

        // Show/hide API keys toggle
        document.getElementById('api-key-show').addEventListener('change', (e) => {
            const claudeInput = document.getElementById('claude-api-key-input');
            const geminiInput = document.getElementById('gemini-api-key-input');
            const openaiInput = document.getElementById('openai-api-key-input');
            const inputType = e.target.checked ? 'text' : 'password';
            claudeInput.type = inputType;
            geminiInput.type = inputType;
            openaiInput.type = inputType;
        });

        // Clear all API keys
        document.getElementById('api-key-clear').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all saved API keys? This action cannot be undone.')) {
                clearLocalAPIKey('anthropic');
                clearLocalAPIKey('gemini');
                clearLocalAPIKey('openai');
                document.getElementById('claude-api-key-input').value = '';
                document.getElementById('gemini-api-key-input').value = '';
                document.getElementById('openai-api-key-input').value = '';
                updateKeyStatusBadges();
                console.log('ðŸ—‘ï¸ All API keys cleared');
                alert('All API keys have been cleared.');
            }
        });

        // Cancel API key modal
        document.getElementById('api-key-cancel').addEventListener('click', () => {
            document.getElementById('api-key-modal').style.display = 'none';
        });

        document.getElementById('api-key-btn').addEventListener('click', () => {
            showApiKeyModal(true);
        });

        // Unified AI Mode selector
        document.getElementById('unified-ai-mode-select').addEventListener('change', (e) => {
            const newMode = e.target.value;
            const parsed = parseUnifiedMode(newMode);

            // Check if this mode requires an API key
            if (parsed.requiresKey) {
                const provider = parsed.provider;
                const hasKey = getLocalAPIKey(provider);

                if (!hasKey) {
                    // Show helpful message about needing API key
                    const providerName = provider === 'anthropic' ? 'Claude' :
                                       provider === 'gemini' ? 'Gemini' : 'OpenAI';

                    alert(`ðŸ”‘ This mode requires your ${providerName} API key.\n\nPlease click the ðŸ”‘ API Key button to configure your key, then try again.`);

                    // Revert to previous mode
                    const currentMode = getUnifiedAIMode();
                    e.target.value = currentMode;
                    return;
                }
            }

            // Save the new mode
            setUnifiedAIMode(newMode);

            // Show informational message
            console.log(`âœ… AI Mode: ${parsed.description}`);

            // Show user-friendly toast
            if (parsed.enabled) {
                const modeLabel = e.target.options[e.target.selectedIndex].text;
                showToast(`âœ… AI Mode: ${modeLabel}`);
            } else {
                showToast('âŒ AI features disabled');
            }
        });

        // Initialize unified AI mode selector on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Attach Canvas view toggle
            const toggleBtn = document.getElementById('toggle-view-mode');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleViewMode);
            }

            // Attach Canvas export button
            const exportCanvasBtn = document.getElementById('export-canvas-btn');
            if (exportCanvasBtn) {
                exportCanvasBtn.addEventListener('click', exportCanvasAsImage);
            }

            // Initialize canvas event listeners
            initializeCanvasEvents();

            // Rebind expand/collapse buttons to use progressive collapse/expand
            // Wait a bit for TreeListy to finish its initialization
            setTimeout(() => {
                const expandBtn = document.getElementById('expand-btn');
                const collapseBtn = document.getElementById('collapse-btn');

                if (expandBtn) {
                    // Remove all existing listeners by cloning the button
                    const newExpandBtn = expandBtn.cloneNode(true);
                    expandBtn.parentNode.replaceChild(newExpandBtn, expandBtn);

                    // Add new listener with progressive expand
                    newExpandBtn.addEventListener('click', () => {
                        console.log('â¬‡ï¸ Progressive Expand clicked');
                        if (typeof canvasExpandOneLevel === 'function') {
                            canvasExpandOneLevel();
                        }
                    });
                }

                if (collapseBtn) {
                    // Remove all existing listeners by cloning the button
                    const newCollapseBtn = collapseBtn.cloneNode(true);
                    collapseBtn.parentNode.replaceChild(newCollapseBtn, collapseBtn);

                    // Add new listener with progressive collapse
                    newCollapseBtn.addEventListener('click', () => {
                        console.log('â¬†ï¸ Progressive Collapse clicked');
                        if (typeof canvasCollapseOneLevel === 'function') {
                            canvasCollapseOneLevel();
                        }
                    });
                }
            }, 500);

            // Bind Canvas toolbar buttons
            const autoLayoutSelect = document.getElementById('auto-layout-select');
            const gridToggleBtn = document.getElementById('grid-toggle');
            const resetViewBtn = document.getElementById('reset-view');
            const fitViewBtn = document.getElementById('fit-view');
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');

            if (autoLayoutSelect) {
                autoLayoutSelect.addEventListener('change', (e) => {
                    if (e.target.value) {
                        applyAutoLayout(e.target.value);
                        e.target.value = '';  // Reset to default
                    }
                });
            }

            // Cluster-by selector event listener
            const clusterBySelect = document.getElementById('cluster-by-select');
            if (clusterBySelect) {
                // Populate on load
                updateClusterByOptions();

                clusterBySelect.addEventListener('change', (e) => {
                    clusterByField = e.target.value;
                    if (clusterByField) {
                        console.log(`Clustering enabled by: ${clusterByField}`);

                        // Auto-sync: update sort to match cluster field if linked
                        if (sortClusterLinked) {
                            const sortSelect = document.getElementById('pattern-sort-select');
                            if (sortSelect) {
                                // Try to find matching sort option by field
                                const matchingOption = Array.from(sortSelect.options).find(
                                    opt => opt.dataset && opt.dataset.field === clusterByField
                                );
                                if (matchingOption) {
                                    sortSelect.value = matchingOption.value;
                                    // Trigger sort
                                    const sortConfig = {
                                        value: matchingOption.value,
                                        field: matchingOption.dataset.field,
                                        order: matchingOption.dataset.order,
                                        type: matchingOption.dataset.type
                                    };
                                    sortTree(sortConfig);
                                    const resetSortBtn = document.getElementById('reset-sort-btn');
                                    if (resetSortBtn) resetSortBtn.style.display = 'inline-block';
                                    console.log(`ðŸ”— Auto-synced Sort to: ${clusterByField}`);
                                }
                            }
                        }

                        // Re-apply force-directed layout if currently in canvas mode
                        if (viewMode === 'canvas') {
                            applyForceDirectedLayout();
                            renderCanvas();
                        }

                        const linkedMsg = sortClusterLinked ? ' (Tree synced)' : '';
                        showToast(`Clustered by: ${e.target.options[e.target.selectedIndex].textContent}${linkedMsg}`, 'success', 2000);
                    } else {
                        console.log('Clustering disabled');

                        // Auto-sync: reset sort too if linked
                        if (sortClusterLinked) {
                            const sortSelect = document.getElementById('pattern-sort-select');
                            const resetSortBtn = document.getElementById('reset-sort-btn');
                            if (sortSelect) {
                                sortSelect.value = '';
                                currentSortConfig = null;
                                sortTree(null);
                                if (resetSortBtn) resetSortBtn.style.display = 'none';
                            }
                        }
                    }
                });
            }

            if (gridToggleBtn) {
                gridToggleBtn.addEventListener('click', toggleGrid);
            }

            if (resetViewBtn) {
                resetViewBtn.addEventListener('click', resetView);
            }

            if (fitViewBtn) {
                fitViewBtn.addEventListener('click', fitToView);
            }

            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    canvasZoom = Math.min(5, canvasZoom * 1.2);
                    updateCanvasTransform();
                });
            }

            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    canvasZoom = Math.max(0.1, canvasZoom / 1.2);
                    updateCanvasTransform();
                });
            }

            const savedMode = getUnifiedAIMode();
            const select = document.getElementById('unified-ai-mode-select');
            if (select) {
                select.value = savedMode;
            }
        });

        // Save API key(s)
        document.getElementById('api-key-save').addEventListener('click', () => {
            const claudeKey = document.getElementById('claude-api-key-input').value.trim();
            const geminiKey = document.getElementById('gemini-api-key-input').value.trim();
            const openaiKey = document.getElementById('openai-api-key-input').value.trim();
            const selectedProvider = document.getElementById('provider-select').value;

            // Validate keys if provided
            if (claudeKey && !claudeKey.startsWith('sk-ant-')) {
                alert('Invalid Claude API key format. Anthropic API keys start with "sk-ant-"');
                return;
            }

            if (geminiKey && !geminiKey.startsWith('AIza')) {
                alert('Invalid Gemini API key format. Google API keys typically start with "AIza"');
                return;
            }

            if (openaiKey && !openaiKey.startsWith('sk-')) {
                alert('Invalid OpenAI API key format. OpenAI API keys start with "sk-"');
                return;
            }

            // Check if selected provider has a key
            if (selectedProvider === 'anthropic' && !claudeKey && !getLocalAPIKey('anthropic')) {
                alert('Please enter a Claude API key, or switch to another provider.');
                return;
            }

            if (selectedProvider === 'gemini' && !geminiKey && !getLocalAPIKey('gemini')) {
                alert('Please enter a Gemini API key, or switch to another provider.');
                return;
            }

            if (selectedProvider === 'openai' && !openaiKey && !getLocalAPIKey('openai')) {
                alert('Please enter an OpenAI API key, or switch to another provider.');
                return;
            }

            // Save keys if provided (preserves existing keys if not changed)
            if (claudeKey) {
                setLocalAPIKey(claudeKey, 'anthropic');
                console.log('âœ… Claude API key saved');
            }

            if (geminiKey) {
                setLocalAPIKey(geminiKey, 'gemini');
                console.log('âœ… Gemini API key saved');
            }

            if (openaiKey) {
                setLocalAPIKey(openaiKey, 'openai');
                console.log('âœ… OpenAI API key saved');
            }

            // Save provider preference
            setAIProvider(selectedProvider);
            console.log(`âœ… Primary AI provider set to: ${selectedProvider}`);

            // Close modal
            document.getElementById('api-key-modal').style.display = 'none';

            // If we came from Analysis Mode, reopen it
            if (window.pendingAnalysisMode) {
                window.pendingAnalysisMode = false;
                document.getElementById('analyze-text-btn').click();
            }
        });

        // Function to check if API key is configured
        function checkAPIKeyConfigured(options = {}) {
            const { forcePrompt = false } = options;
            const localKey = getLocalAPIKey();
            if (localKey) {
                return true;
            }

            if (!forcePrompt && canUseServerlessAI()) {
                console.log('ðŸŒ No local API key found. Using Netlify serverless function for AI calls.');
                return true;
            }

            // No local key and serverless unavailable (or prompt requested) - show modal
            showApiKeyModal(false);
            return false;
        }

        // =============================================================================
        // AI REVIEW & ENHANCE SYSTEM
        // =============================================================================

        // Open AI Review modal and analyze tree
        document.getElementById('ai-review-btn').addEventListener('click', async () => {
            // Check if AI is enabled
            const aiMode = getGlobalAIMode();
            if (aiMode === 'off') {
                alert('âŒ AI features are currently disabled.\n\nPlease enable AI mode in the header (ðŸ¤– AI dropdown) to use AI Review.');
                return;
            }

            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                return;
            }

            // Check if tree has content
            if (!hasExistingContent()) {
                alert('âš ï¸ Your tree is empty.\n\nPlease add some content first, then use AI Review to get suggestions for improvements.');
                return;
            }

            // Open modal and start analysis
            document.getElementById('ai-review-modal').style.display = 'flex';
            document.getElementById('ai-review-status').style.display = 'block';
            document.getElementById('ai-review-results').style.display = 'none';

            await performAIReview();
        });

        // Close AI Review modal
        document.getElementById('close-ai-review-modal').addEventListener('click', () => {
            document.getElementById('ai-review-modal').style.display = 'none';
        });

        // Re-analyze button
        document.getElementById('ai-review-again').addEventListener('click', async () => {
            document.getElementById('ai-review-status').style.display = 'block';
            document.getElementById('ai-review-results').style.display = 'none';
            await performAIReview();
        });

        // Perform AI Review of the tree
        async function performAIReview() {
            const pattern = PATTERNS[currentPattern];
            const tree = capexTree;

            try {
                // Build pattern-specific review prompt
                const reviewPrompt = buildReviewPrompt(tree, pattern);

                console.log('ðŸ”¬ Starting AI Review...');
                console.log('Pattern:', currentPattern);
                console.log('Tree:', tree.name);

                // Call AI with extended thinking for deep analysis
                const aiMode = getGlobalAIMode();
                const useExtendedThinking = aiMode === 'deep';

                // Extended thinking has budget_tokens = 5000, so maxTokens must be > 5000
                // Using 8000 to give 3000 tokens for actual response content
                const maxTokensForReview = useExtendedThinking ? 8000 : 4096;

                // Pattern-specific expert personas for AI Review
                const reviewExperts = {
                    philosophy: 'You are a philosophy professor specializing in classical and contemporary philosophical arguments. Review for logical validity, premise strength, and dialectical completeness.',
                    sales: 'You are a sales strategist with 20 years of enterprise B2B experience. Review for pipeline health, deal qualification, and revenue optimization.',
                    thesis: 'You are an academic advisor helping graduate students structure rigorous research. Review for argument progression, citation quality, and scholarly standards.',
                    roadmap: 'You are a product manager experienced in agile development and feature prioritization. Review for execution readiness, story completeness, and technical feasibility.',
                    prompting: 'You are an AI/ML engineer expert in prompt engineering for Claude, GPT-4, and other LLMs. Review for prompt clarity, few-shot example quality, output format specification, and edge case handling.',
                    book: 'You are a professional fiction editor and writing coach. Review for narrative flow, character development, and pacing.',
                    film: 'You are a cinematographer and AI video generation expert (Sora, Veo, Runway). Review for visual storytelling, shot composition, and production feasibility.',
                    course: 'You are an instructional designer with expertise in curriculum development. Review for learning progression, assessment alignment, and instructional scaffolding.',
                    dialogue: 'You are a debate coach and rhetoric expert specializing in argumentation theory, logical fallacies, and persuasive communication. Review for argument strength, rhetorical effectiveness, fallacy identification, and evidence quality.',
                    filesystem: 'You are LibrarianAI, a filesystem organization expert. Review for folder structure clarity, file naming consistency, redundancy reduction, data quality, and organizational best practices. Focus on metadata enrichment opportunities and safe, non-destructive improvements.',
                    generic: `You are an expert ${pattern.name} analyst. Review the provided tree structure for completeness, redundancies, logical flow, and alignment with ${pattern.name} best practices.`
                };

                const expertPersona = reviewExperts[currentPattern] || reviewExperts.generic;

                const content = await callClaudeAPI(
                    reviewPrompt,
                    expertPersona + ' Provide specific, actionable suggestions.',
                    maxTokensForReview,
                    useExtendedThinking
                );

                // Parse the AI response and display results
                displayReviewResults(content);

            } catch (error) {
                console.error('âŒ AI Review error:', error);
                document.getElementById('ai-review-status').innerHTML = `
                    <div style="padding: 15px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">âŒ Error during analysis</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            ${error.message}
                        </div>
                    </div>
                `;
            }
        }

        // Build pattern-specific review prompt
        function buildReviewPrompt(tree, pattern) {
            const levels = pattern.levels;
            let prompt = `# ${pattern.name} Tree Review\n\n`;
            prompt += `**Project:** ${tree.name}\n`;
            prompt += `**Pattern:** ${pattern.name}\n\n`;

            // Count items
            const itemCounts = {
                phases: tree.children ? tree.children.length : 0,
                items: 0,
                subtasks: 0
            };

            if (tree.children) {
                tree.children.forEach(phase => {
                    // Support both 'items' (standard) and 'children' (filesystem pattern)
                    const nodeList = phase.items || phase.children || [];
                    if (nodeList.length > 0) {
                        itemCounts.items += nodeList.length;
                        nodeList.forEach(item => {
                            if (item.subtasks || item.children) {
                                itemCounts.subtasks += (item.subtasks || item.children || []).length;
                            }
                        });
                    }
                });
            }

            prompt += `**Current Structure:**\n`;
            prompt += `- ${itemCounts.phases} ${levels.phase}(s)\n`;
            prompt += `- ${itemCounts.items} ${levels.item}(s)\n`;
            prompt += `- ${itemCounts.subtasks} ${levels.subtask}(s)\n\n`;

            // Add tree content
            prompt += `## Tree Structure\n\n`;
            if (tree.children) {
                tree.children.forEach((phase, pIdx) => {
                    prompt += `### ${pIdx + 1}. ${phase.name}\n\n`;
                    if (phase.description) {
                        prompt += `${phase.description}\n\n`;
                    }

                    // Support both 'items' (standard) and 'children' (filesystem pattern)
                    const nodeList = phase.items || phase.children || [];
                    if (nodeList.length > 0) {
                        nodeList.forEach((item, iIdx) => {
                            prompt += `  **${iIdx + 1}. ${item.name}**\n`;
                            if (item.description) {
                                prompt += `  ${item.description}\n`;
                            }

                            // Add pattern-specific fields
                            const fields = Object.keys(item).filter(k =>
                                !['id', 'name', 'icon', 'type', 'description', 'subtasks', 'children', 'dependencies'].includes(k)
                            );

                            if (fields.length > 0) {
                                prompt += `  Fields: ${fields.join(', ')}\n`;
                            }
                            prompt += `\n`;
                        });
                    }
                    prompt += `\n`;
                });
            }

            // Pattern-specific review criteria
            prompt += `\n## Review Criteria\n\n`;
            prompt += `Please analyze this ${pattern.name} tree and provide:\n\n`;

            prompt += `1. **Completeness Check:**\n`;
            prompt += `   - Are all necessary ${levels.item.toLowerCase()}s present?\n`;
            prompt += `   - Are there obvious gaps in the ${levels.phase.toLowerCase()} coverage?\n`;
            prompt += `   - Are critical fields missing values?\n\n`;

            prompt += `2. **Redundancy Analysis:**\n`;
            prompt += `   - Are there duplicate or overlapping ${levels.item.toLowerCase()}s?\n`;
            prompt += `   - Can any ${levels.item.toLowerCase()}s be merged or consolidated?\n\n`;

            prompt += `3. **Logical Flow:**\n`;
            prompt += `   - Do the ${levels.phase.toLowerCase()}s follow a logical sequence?\n`;
            prompt += `   - Are dependencies properly structured?\n`;
            prompt += `   - Does the tree structure make sense for this ${pattern.name}?\n\n`;

            prompt += `4. **Pattern Alignment:**\n`;
            prompt += `   - Does this follow ${pattern.name} best practices?\n`;
            prompt += `   - Are pattern-specific fields used appropriately?\n`;
            prompt += `   - What could improve alignment with ${pattern.name} standards?\n\n`;

            // Pattern-specific additions
            if (currentPattern === 'philosophy') {
                prompt += `5. **Philosophical Rigor:**\n`;
                prompt += `   - Are premises logically valid?\n`;
                prompt += `   - Are objections comprehensive?\n`;
                prompt += `   - Are textual references adequate?\n\n`;
            } else if (currentPattern === 'sales') {
                prompt += `5. **Pipeline Health:**\n`;
                prompt += `   - Are all pipeline stages represented?\n`;
                prompt += `   - Are deal values and probabilities realistic?\n`;
                prompt += `   - Are key competitors identified?\n\n`;
            } else if (currentPattern === 'thesis') {
                prompt += `5. **Academic Standards:**\n`;
                prompt += `   - Is the argument progression clear?\n`;
                prompt += `   - Are citations sufficient?\n`;
                prompt += `   - Is chapter balance appropriate?\n\n`;
            } else if (currentPattern === 'roadmap') {
                prompt += `5. **Execution Readiness:**\n`;
                prompt += `   - Are user stories well-defined?\n`;
                prompt += `   - Are story points assigned?\n`;
                prompt += `   - Are technical risks identified?\n\n`;
            } else if (currentPattern === 'book') {
                prompt += `5. **Narrative Structure:**\n`;
                prompt += `   - Does the story arc flow naturally?\n`;
                prompt += `   - Are character arcs developed?\n`;
                prompt += `   - Is pacing appropriate?\n\n`;
            } else if (currentPattern === 'course') {
                prompt += `5. **Instructional Design:**\n`;
                prompt += `   - Is learning progression scaffolded?\n`;
                prompt += `   - Are assessments aligned with objectives?\n`;
                prompt += `   - Is content appropriately chunked?\n\n`;
            } else if (currentPattern === 'prompting') {
                prompt += `5. **Prompt Engineering Quality:**\n`;
                prompt += `   - Are system prompts clear and specific?\n`;
                prompt += `   - Do few-shot examples cover edge cases?\n`;
                prompt += `   - Are output formats well-defined?\n`;
                prompt += `   - Are chain-of-thought instructions effective?\n`;
                prompt += `   - Are test cases comprehensive?\n\n`;
            }

            prompt += `## Output Format\n\n`;
            prompt += `Provide your analysis in the following format:\n\n`;
            prompt += `**SUMMARY:** (2-3 sentences overview of tree quality)\n\n`;
            prompt += `**STRENGTHS:** (Bullet list of what's working well)\n\n`;
            prompt += `**GAPS:** (Specific missing items or fields)\n\n`;
            prompt += `**REDUNDANCIES:** (Items that could be merged)\n\n`;
            prompt += `**IMPROVEMENTS:** (Actionable suggestions to enhance the tree)\n\n`;

            return prompt;
        }

        // Display AI review results
        function displayReviewResults(response) {
            // Hide status, show results
            document.getElementById('ai-review-status').style.display = 'none';
            document.getElementById('ai-review-results').style.display = 'block';

            // Parse response sections
            const sections = {
                summary: extractSection(response, 'SUMMARY'),
                strengths: extractSection(response, 'STRENGTHS'),
                gaps: extractSection(response, 'GAPS'),
                redundancies: extractSection(response, 'REDUNDANCIES'),
                improvements: extractSection(response, 'IMPROVEMENTS')
            };

            // Build summary HTML
            const summaryHTML = `
                <div style="padding: 16px; background: var(--card-bg); border-radius: 8px; margin-bottom: 16px;">
                    ${sections.summary || 'Analysis complete.'}
                </div>

                ${sections.strengths ? `
                <div style="padding: 16px; background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #10b981; font-size: 14px;">âœ… Strengths</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.strengths)}</div>
                </div>
                ` : ''}

                ${sections.gaps ? `
                <div style="padding: 16px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #ef4444; font-size: 14px;">âš ï¸ Gaps</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.gaps)}</div>
                </div>
                ` : ''}

                ${sections.redundancies ? `
                <div style="padding: 16px; background: rgba(245, 158, 11, 0.1); border-left: 3px solid #f59e0b; border-radius: 6px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #f59e0b; font-size: 14px;">ðŸ”„ Redundancies</h4>
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.redundancies)}</div>
                </div>
                ` : ''}
            `;

            document.getElementById('ai-review-summary').innerHTML = summaryHTML;

            // Build suggestions HTML
            const suggestionsHTML = sections.improvements ? `
                <div style="padding: 16px; background: rgba(99, 102, 241, 0.1); border-left: 3px solid #6366f1; border-radius: 6px;">
                    <div style="font-size: 13px; line-height: 1.6;">${formatMarkdown(sections.improvements)}</div>
                </div>
            ` : '<div style="color: var(--text-secondary);">No specific improvements suggested.</div>';

            document.getElementById('ai-review-suggestions').innerHTML = suggestionsHTML;

            console.log('âœ… AI Review complete');
        }

        // Extract section from AI response
        function extractSection(text, sectionName) {
            const regex = new RegExp(`\\*\\*${sectionName}:\\*\\*\\s*([\\s\\S]*?)(?=\\n\\*\\*[A-Z]+:|$)`, 'i');
            const match = text.match(regex);
            return match ? match[1].trim() : '';
        }

        // Format markdown to HTML (simple version)
        function formatMarkdown(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
                .replace(/^- (.+)$/gm, '<li>$1</li>') // List items
                .replace(/(<li>.*<\/li>)/s, '<ul style="margin: 8px 0; padding-left: 20px;">$1</ul>') // Wrap in ul
                .replace(/\n\n/g, '<br><br>'); // Paragraphs
        }

        // =============================================================================
        // ANALYSIS MODE - TEXT TO TREE CONVERSION
        // =============================================================================

        let analysisText = '';
        let analysisFileName = '';

        // Open Analysis Modal
        // Track analysis mode (fresh or append)
        let analysisAppendMode = false;

        document.getElementById('analyze-text-btn').addEventListener('click', () => {
            // Check if API key is configured
            if (!checkAPIKeyConfigured()) {
                window.pendingAnalysisMode = true;
                return;
            }

            // If tree has content, ask user if they want to append or start fresh
            if (hasExistingContent()) {
                showAnalysisModeChoice();
            } else {
                openAnalysisModal(false); // false = start fresh
            }
        });

        // Header Import Text button - same as sidebar analyze-text-btn
        document.getElementById('import-text-header-btn')?.addEventListener('click', () => {
            document.getElementById('analyze-text-btn').click();
        });

        // Empty state CTA buttons
        document.getElementById('empty-state-import-btn')?.addEventListener('click', () => {
            document.getElementById('analyze-text-btn').click();
        });

        document.getElementById('empty-state-chat-btn')?.addEventListener('click', () => {
            document.getElementById('wizard-btn').click();
        });

        // Show modal to choose analysis mode
        function showAnalysisModeChoice() {
            const pattern = PATTERNS[currentPattern];
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ” Analyze Text Mode';

            // Count existing items
            const itemCount = capexTree.children?.reduce((sum, phase) =>
                sum + (phase.items?.length || 0), 0) || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 24px;">
                        Your tree already has <strong style="color: var(--treeplex-primary);">${itemCount} ${pattern.levels.item.toLowerCase()}(s)</strong>.
                        How would you like to proceed?
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="analysis-mode-append" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">âž•</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Append to Existing
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Analyze the text and add the results to your current tree. Great for combining multiple documents.
                            </div>
                        </div>

                        <div id="analysis-mode-fresh" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--treeplex-primary)'" onmouseout="this.style.borderColor='var(--border)'">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">ðŸ”„</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Replace Tree
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Clear the current tree and replace it with the analysis results. Starts from scratch.
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 16px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                        ðŸ’¡ <strong>Tip:</strong> Append mode lets you analyze multiple documents and combine them into one comprehensive tree.
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Add click handlers
            document.getElementById('analysis-mode-append').onclick = () => {
                modal.style.display = 'none';
                openAnalysisModal(true); // true = append mode
            };

            document.getElementById('analysis-mode-fresh').onclick = () => {
                modal.style.display = 'none';
                openAnalysisModal(false); // false = start fresh
            };
        }

        // Open the analysis modal
        function openAnalysisModal(appendMode) {
            analysisAppendMode = appendMode;

            const modal = document.getElementById('analysis-modal');
            modal.style.display = 'flex';

            // Reset form
            document.getElementById('analysis-text-input').value = '';
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            document.getElementById('char-count').textContent = '0 characters';
            document.getElementById('analysis-warning').style.display = 'none';
            analysisText = '';
            analysisFileName = '';

            // Update the AI mode display to show current global mode
            updateAnalysisModeDisplay();
        }

        // Update the AI mode display in Analyze Text modal
        function updateAnalysisModeDisplay() {
            const mode = getGlobalAIMode();
            const label = document.getElementById('analyze-mode-label');
            const description = document.getElementById('analyze-mode-description');

            if (mode === 'off') {
                label.textContent = 'âŒ Off';
                description.textContent = 'AI features are disabled. Enable AI mode in the header to use this feature.';
                description.style.color = '#EF4444';
            } else if (mode === 'quick') {
                label.textContent = 'âš¡ Quick';
                description.textContent = 'Fast pattern detection + basic structure. Recommended for most uses. Uses server API key (rate limited).';
                description.style.color = 'var(--text-secondary)';
            } else if (mode === 'deep') {
                label.textContent = 'ðŸ”¬ Deep';
                description.textContent = 'Comprehensive parsing with extended thinking (8192 tokens). Handles 3x more text. Requires your API key. No timeouts.';
                description.style.color = 'var(--text-secondary)';
            }
        }

        // Close Analysis Modal
        document.getElementById('analysis-cancel').addEventListener('click', () => {
            document.getElementById('analysis-modal').style.display = 'none';
        });

        // File Drop Zone - Click to browse
        const fileDropZone = document.getElementById('file-drop-zone');
        const fileInput = document.getElementById('analysis-file-input');

        fileDropZone.addEventListener('click', () => {
            fileInput.click();
        });

        // File selected via browse
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Drag and Drop handlers
        fileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--treeplex-primary)';
            fileDropZone.style.background = 'rgba(99, 102, 241, 0.05)';
        });

        fileDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';
        });

        fileDropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            fileDropZone.style.borderColor = 'var(--border)';
            fileDropZone.style.background = 'var(--bg-secondary)';

            const file = e.dataTransfer.files[0];
            if (file) {
                await handleAnalysisFile(file);
            }
        });

        // Handle file upload
        async function handleAnalysisFile(file) {
            // Check file type
            const validTypes = ['.txt', '.md'];
            const fileName = file.name.toLowerCase();
            const isValid = validTypes.some(type => fileName.endsWith(type));

            if (!isValid) {
                alert('Please upload a .txt or .md file only.');
                return;
            }

            // Show file name
            document.getElementById('selected-file-name').textContent = file.name;
            document.getElementById('file-name-display').style.display = 'block';
            analysisFileName = file.name;

            // Read file content
            const reader = new FileReader();
            reader.onload = (e) => {
                analysisText = e.target.result;

                // Clear text area since we're using file
                document.getElementById('analysis-text-input').value = '';

                // Update character count
                updateCharCount(analysisText.length);

                // Check file size and show warning if needed
                checkFileSize(analysisText.length);
            };
            reader.readAsText(file);
        }

        // Clear file button
        document.getElementById('clear-file-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('analysis-file-input').value = '';
            document.getElementById('file-name-display').style.display = 'none';
            analysisText = '';
            analysisFileName = '';
            updateCharCount(0);
            document.getElementById('analysis-warning').style.display = 'none';
        });

        // Text area character count
        const textInput = document.getElementById('analysis-text-input');
        textInput.addEventListener('input', (e) => {
            analysisText = e.target.value;
            updateCharCount(analysisText.length);
            checkFileSize(analysisText.length);

            // Clear file if typing in text area
            if (analysisText.length > 0 && analysisFileName) {
                document.getElementById('analysis-file-input').value = '';
                document.getElementById('file-name-display').style.display = 'none';
                analysisFileName = '';
            }
        });

        function updateCharCount(count) {
            const charCountEl = document.getElementById('char-count');
            const words = count > 0 ? analysisText.trim().split(/\s+/).length : 0;
            charCountEl.textContent = `${count.toLocaleString()} characters (~${words} words)`;

            if (count > 50000) {
                charCountEl.style.color = '#ff9f43';
            } else {
                charCountEl.style.color = 'var(--text-secondary)';
            }
        }

        function checkFileSize(charCount) {
            const warningEl = document.getElementById('analysis-warning');
            const warningText = document.getElementById('analysis-warning-text');

            // Rough token estimate: 1 token â‰ˆ 4 characters
            const estimatedTokens = Math.ceil(charCount / 4);
            const estimatedWords = Math.ceil(charCount / 5);

            if (charCount > 100000) { // Will be truncated
                warningEl.style.display = 'block';
                warningText.textContent = `âš ï¸ Text is ${charCount.toLocaleString()} characters (~${estimatedWords.toLocaleString()} words). Will be automatically truncated to 100,000 characters (~25,000 words) to prevent timeouts. Consider pasting a shorter excerpt for best results.`;
            } else if (charCount > 75000) { // Large but ok
                warningEl.style.display = 'block';
                warningText.textContent = `Very large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis may take 15-25 seconds. Quick Mode strongly recommended.`;
            } else if (charCount > 50000) { // Large
                warningEl.style.display = 'block';
                warningText.textContent = `Large text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Deep Mode will provide richer analysis but may take 20-30 seconds.`;
            } else if (charCount > 5000) {
                warningEl.style.display = 'block';
                warningText.textContent = `Medium text (${charCount.toLocaleString()} characters, ~${estimatedWords.toLocaleString()} words). Analysis should take 15-30 seconds.`;
            } else {
                warningEl.style.display = 'none';
            }
        }

        // =============================================================================
        // AI PATTERN DETECTION & TEXT-TO-TREE CONVERSION
        // =============================================================================

        // Pattern detection function
        async function detectPattern(text) {
            const prompt = `Analyze the following text and determine the 3 most appropriate TreeListy patterns for organizing it.

AVAILABLE PATTERNS:
1. Generic Project - Universal structure for any project (Project â†’ Phase â†’ Item â†’ Task)
2. Sales Pipeline - Deal tracking across quarters (Pipeline â†’ Quarter â†’ Deal â†’ Action)
3. Academic Writing - Thesis/research paper structure (Thesis â†’ Chapter â†’ Section â†’ Point)
4. Product Roadmap - Feature development timeline (Product â†’ Quarter â†’ Feature â†’ Story)
5. Book Writing - Narrative structure (Book â†’ Part â†’ Chapter â†’ Scene)
6. Event Planning - Event organization and logistics (Event â†’ Stage â†’ Activity â†’ Task)
7. Fitness Program - Workout programs and exercises (Program â†’ Phase â†’ Workout â†’ Exercise)
8. Strategic Plan - Business initiatives and metrics (Strategy â†’ Pillar â†’ Initiative â†’ Action)
9. Course Design - Educational curriculum structure (Course â†’ Unit â†’ Lesson â†’ Exercise)
10. Film Production - Film/video production workflow (Film â†’ Phase â†’ Scene â†’ Shot)
11. Veo3 (Google) - Google Veo 3 AI video generation (Project â†’ Sequence â†’ Scene â†’ Shot/Frame)
12. Sora2 (OpenAI) - OpenAI Sora 2 AI video generation (Project â†’ Sequence â†’ Beat â†’ Shot/Remix)
13. Philosophy - Philosophical arguments and treatises (Treatise â†’ Book â†’ Argument â†’ Premise)
14. Prompt Engineering - AI prompts and testing (Library â†’ Category â†’ Prompt â†’ Test Case)
15. Family Tree - Genealogical documentation (Family â†’ Generation â†’ Person â†’ Event)
16. Dialogue & Rhetoric - Analyze debates, conversations, and arguments (Conversation â†’ Speaker â†’ Statement â†’ Point)
17. CAPEX / Angel Pitch - Investor-ready capital expenditure for startups (Project â†’ Funding Phase â†’ Investment â†’ Deliverable)
18. File System - File and folder organization (Root â†’ Directory â†’ Subdirectory â†’ File)

TEXT TO ANALYZE:
${text.substring(0, 5000)}${text.length > 5000 ? '\n\n[... truncated for analysis ...]' : ''}

DETECTION HINTS:
- If text contains prompt-related terms like "system prompt", "user prompt", "few-shot examples", "chain-of-thought", "temperature", "max tokens" â†’ Prompt Engineering
- If text looks like AI instructions or discusses prompt design â†’ Prompt Engineering
- If text mentions AI models (Claude, GPT, Anthropic, OpenAI) in context of prompting â†’ Prompt Engineering
- If text contains debate/dialogue terms like "speaker", "argument", "rhetoric", "fallacy", "premise", "counterargument", "rebuttal", "debate", "conversation" â†’ Dialogue & Rhetoric
- If text is a transcript of a conversation, political debate, or online discussion â†’ Dialogue & Rhetoric
- If text analyzes persuasion, argumentation, or rhetorical techniques â†’ Dialogue & Rhetoric
- If text contains startup/investment terms like "seed round", "series A/B", "CAPEX", "funding", "investors", "valuation", "angel", "VC", "runway", "burn rate", "ROI", "IRR" â†’ CAPEX / Angel Pitch
- If text describes capital expenditure, startup fundraising, or investor pitch materials â†’ CAPEX / Angel Pitch
- If text is about file/folder organization, directory structure, or filesystem hierarchy â†’ File System

Respond with ONLY a valid JSON object in this exact format:
{
  "recommendations": [
    {
      "pattern": "pattern-key",
      "patternName": "Pattern Display Name",
      "confidence": 9,
      "reasoning": "Brief explanation of why this pattern fits"
    }
  ]
}

Provide exactly 3 recommendations, ranked by confidence (1-10). Use these pattern keys: generic, sales, thesis, roadmap, book, event, fitness, strategy, course, film, philosophy, prompting, familytree, dialogue, capex, filesystem`;

            const response = await callClaudeAPI(prompt);

            try {
                // Extract JSON from response
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    return result.recommendations;
                }
            } catch (e) {
                console.error('Failed to parse pattern detection response:', e);
            }

            // Fallback to generic
            return [{
                pattern: 'generic',
                patternName: 'Generic Project',
                confidence: 5,
                reasoning: 'Default fallback pattern'
            }];
        }

        // Helper function to fix common JSON issues
        function repairJSON(jsonText) {
            // SIMPLE APPROACH: Replace all problematic characters with spaces or escaped versions
            // This is more reliable than complex regex matching

            // Replace literal newlines, carriage returns, and tabs with spaces
            // These shouldn't be in JSON strings - Claude should use \n instead
            jsonText = jsonText.replace(/\r\n/g, ' ');
            jsonText = jsonText.replace(/\r/g, ' ');
            jsonText = jsonText.replace(/\n/g, ' ');
            jsonText = jsonText.replace(/\t/g, ' ');

            // Remove other control characters (ASCII 0-31 except space)
            jsonText = jsonText.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');

            // Remove trailing commas before closing brackets/braces (run multiple times to catch nested cases)
            let previousText;
            do {
                previousText = jsonText;
                jsonText = jsonText.replace(/,(\s*[}\]])/g, '$1');
            } while (jsonText !== previousText);

            // Remove comments (// and /* */)
            jsonText = jsonText.replace(/\/\/.*$/gm, '');
            jsonText = jsonText.replace(/\/\*[\s\S]*?\*\//g, '');

            return jsonText;
        }

        // PROMPT IMPROVEMENT: Special handler for Prompt Engineering pattern
        // Takes a basic prompt and generates comprehensive improved version with best practices
        async function improvePromptWithAI(basicPrompt, mode = 'quick') {
            console.log(`ðŸ§  Improving prompt using ${mode} mode...`);

            // BUILD 173: "Super Hybrid" meta-prompt combining best traits from A/B winners
            // - Iterative Refinement (80.2%): Self-critique loop, "junior engineer test"
            // - Hybrid V2 (78.4%): Expert panel synthesis, agent contracts
            // - Direct+Concrete (74.2%): Maximum specificity, concrete personas
            const systemPrompt = `You are a world-class prompt engineer. Generate, critique, and refine a production-ready prompt.

## Phase 1: Draft Generation
Create an initial prompt. Apply expert perspectives:
- Anthropic: XML tags, explicit constraints, safety considerations
- OpenAI: JSON mode, function calling patterns, system message optimization
- Production: Token efficiency, error handling, latency considerations

## Phase 2: Self-Critique (Internal - Don't output this)
Score your draft against these criteria:
â–¡ Would a junior engineer understand exactly what to do?
â–¡ Are there ANY ambiguous instructions?
â–¡ Would this produce correct output on the FIRST try?
â–¡ Is the persona SPECIFIC (not "expert" but "senior engineer at Stripe with 8 years in payment systems")?
â–¡ Are examples CONCRETE with actual inputâ†’output pairs?
â–¡ For multi-agent: Are contracts between agents crystal clear with exact JSON schemas?

## Phase 3: Refined Output
Apply your critique. Fix every issue. Output the IMPROVED prompt.

## Output Requirements
Your generated prompt MUST include:
- <system> with SPECIFIC persona (domain, years experience, company context)
- <task> with precise instructions and success criteria
- <format> with exact output structure (JSON schema if structured)
- <examples> with 2+ CONCRETE inputâ†’output examples
- <constraints> with boundaries and error handling
- For workflows: <agent_contracts> with INPUT/OUTPUT contracts per agent

CRITICAL: Return ONLY valid JSON. No explanations. No meta-commentary.`;

            const userPrompt = `Transform this input into a production-ready prompt:

INPUT: "${basicPrompt}"

You are a PROMPT ARCHITECT. Your output is a prompt that CONFIGURES another AI.
- If input is a topic â†’ CREATE a prompt for an AI to handle that topic
- If input is a draft prompt â†’ IMPROVE it to production quality

CRITICAL: Your output must INSTRUCT the AI, not answer a question.
BAD: "Help me with skin care"
GOOD: "You are a dermatologist with 15 years experience at Mayo Clinic. When providing skin care: 1) Ask about skin type 2) Provide routine with ingredients 3) Return as JSON. Help me create a routine."

Return ONLY this JSON structure:
{
  "projectName": "Descriptive name",
  "description": "1-sentence description",
  "phases": [{
    "name": "Production Prompt",
    "subtitle": "Ready to use",
    "items": [{
      "name": "Refined: [Use Case Name]",
      "description": "Production-ready prompt",
      "itemType": "task-instruction",
      "systemPrompt": "<system>\\nYou are a [SPECIFIC ROLE: e.g., senior ML engineer at Google with 10 years in NLP].\\n[Context]\\n[Constraints]\\n</system>",
      "userPromptTemplate": "<task>\\n[Precise instructions with success criteria]\\n</task>\\n<format>\\n[Exact output structure/JSON schema]\\n</format>\\n<constraints>\\n[What NOT to do, error handling]\\n</constraints>",
      "fewShotExamples": "<examples>\\n<example>\\nInput: [concrete input 1]\\nOutput: [concrete output 1]\\n</example>\\n<example>\\nInput: [concrete input 2]\\nOutput: [concrete output 2]\\n</example>\\n</examples>",
      "chainOfThought": "Think step by step: 1) [step], 2) [step], 3) [step]",
      "outputFormat": "Return JSON: {\\"field1\\": \\"type\\", \\"field2\\": \\"type\\"}",
      "structuralTags": "<thinking>\\nReasoning\\n</thinking>\\n<answer>\\nFinal response\\n</answer>",
      "assistantPrefill": "Here is my analysis:",
      "modelTarget": "Claude Sonnet 4",
      "temperature": 0.7,
      "maxTokens": 2000
    }]
  }]
}

RULES:
- systemPrompt: SPECIFIC persona (role + years + company context), not generic "expert"
- userPromptTemplate: Must INSTRUCT the AI, not ask a question
- fewShotExamples: CONCRETE inputâ†’output pairs, not placeholders
- NO {{variables}} - make it work immediately when pasted
- NO trailing commas in JSON
- Escape quotes inside strings`;

            // Deep mode uses extended thinking (budget_tokens = 5000)
            // So maxTokens must be > 5000. Using 8000 to give 3000 tokens for actual response.
            const maxTokens = mode === 'deep' ? 8000 : 2048;
            const useThinking = mode === 'deep';

            const response = await callClaudeAPI(userPrompt, systemPrompt, maxTokens, useThinking);

            try {
                // Extract JSON from response
                let jsonText = response.trim();
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                const firstBrace = jsonText.indexOf('{');
                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ðŸ§  Skipping text before JSON:', jsonText.substring(0, firstBrace));
                    jsonText = jsonText.substring(firstBrace);
                }

                // Find matching closing brace
                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = 0; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Could not find matching closing brace in JSON');
                }

                jsonText = jsonText.substring(0, endPos + 1);

                const parsed = JSON.parse(jsonText);
                console.log('âœ… Prompt improved successfully:', parsed.projectName);
                return parsed;

            } catch (e) {
                console.error('âŒ JSON parsing error:', e);
                console.error('Response:', response);
                throw new Error(`Failed to improve prompt. AI response was not valid JSON: ${e.message}`);
            }
        }

        // Quick Mode: Basic structure conversion with semantic chunking
        async function convertTextToTreeQuick(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            // SPECIAL CASE: Prompt Engineering pattern - improve the prompt instead of extracting
            if (pattern === 'prompting') {
                return await improvePromptWithAI(text, 'quick');
            }

            // =========================================================================
            // SEMANTIC CHUNKING PREPROCESSING
            // =========================================================================
            console.log('ðŸ§  Starting semantic chunking preprocessing...');
            const chunker = new SemanticChunker();
            let chunks;

            // Show chunking status in UI
            const modalBody = document.getElementById('modal-body');
            if (modalBody) {
                modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">ðŸ§  Analyzing text structure...</p>';
            }

            // Tier 2: Scientific approach (if embedding provider available)
            if (EmbeddingManager.hasProvider()) {
                console.log('âœ… Embedding provider detected - using scientific semantic chunking');
                try {
                    chunks = await chunker.chunkByEmbedding(text);
                } catch (error) {
                    console.warn('âš ï¸ Semantic chunking failed, falling back to structural split:', error);
                    chunks = chunker.structuralSplit(text);
                }
            } else {
                // Tier 1: Structural fallback
                console.log('ðŸ“ No embedding provider - using structural split');
                chunks = chunker.structuralSplit(text);
            }

            console.log(`âœ… Text split into ${chunks.length} semantic chunks`);

            // Show chunk visualization
            if (modalBody && chunks.length > 1) {
                const chunkLengths = chunks.map(c => c.text.length);
                const maxLength = Math.max(...chunkLengths);
                const bars = chunks.map((chunk, i) => {
                    const width = (chunk.text.length / maxLength) * 100;
                    return `<div style="background: linear-gradient(90deg, rgba(99, 102, 241, 0.6), rgba(139, 92, 246, 0.6)); height: 8px; width: ${width}%; border-radius: 4px; margin: 2px 0;" title="Chunk ${i + 1}: ${chunk.text.length} chars"></div>`;
                }).join('');

                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div class="spinner"></div>
                            <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600;">
                                ðŸ§  Detected ${chunks.length} Semantic Sections
                            </p>
                            <p style="color: var(--text-secondary); font-size: 13px; margin-top: 4px;">
                                Processing each section with ${patternConfig.name} pattern...
                            </p>
                        </div>
                        <div style="padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3);">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Chunk size distribution:</div>
                            ${bars}
                        </div>
                    </div>
                `;
            }

            // Generate quick field hints (top 5 most important fields)
            let quickFieldHints = '';
            const importantFields = [];

            Object.keys(fields).forEach(fieldKey => {
                const fieldConfig = fields[fieldKey];
                // Skip non-field properties
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }
                if (fieldConfig.label) {
                    let hint = `- ${fieldKey}: ${fieldConfig.label}`;
                    if (fieldConfig.type === 'number') {
                        hint += ` (number)`;
                    } else if (fieldConfig.type === 'date') {
                        hint += ` (YYYY-MM-DD)`;
                    } else if (fieldConfig.type === 'select' && fieldConfig.options) {
                        hint += ` (${fieldConfig.options.slice(0, 3).join('/')})`;
                    }
                    importantFields.push(hint);
                }
            });

            if (importantFields.length > 0) {
                quickFieldHints = `\n\nKEY FIELDS TO EXTRACT (if mentioned in text):\n${importantFields.slice(0, 6).join('\n')}\n`;
            }

            // Add item types if available
            let itemTypeHints = '';
            if (patternConfig.types && patternConfig.types.length > 0) {
                const typesList = patternConfig.types.slice(0, 8).map(t => t.value).join(', ');
                itemTypeHints = `\n\nITEM TYPES: Use these specific types: ${typesList}\n`;
            }

            // Pattern-specific subtask guidance
            // BUILD 320: Added CAPEX subtask guidance
            function getPatternSubtaskGuidance(pattern) {
                const guidance = {
                    capex: `For ${levels.item}s (line items), add ${levels.subtask}s like: components, delivery milestones, installation steps, verification tasks. Include cost breakdowns if available.`,
                    philosophy: `For ${levels.item}s (Claims), REQUIRED 1-3 ${levels.subtask}s (Supports): premises, objections, supporting evidence, textual references. NEVER skip subItems.`,
                    sales: `For ${levels.item}s (deals), add ${levels.subtask}s like: follow-up actions, next steps, activities to close`,
                    thesis: `For ${levels.item}s (arguments), add ${levels.subtask}s like: supporting evidence, citations, counter-arguments`,
                    roadmap: `For ${levels.item}s (features), add ${levels.subtask}s like: implementation steps, technical tasks, acceptance criteria`,
                    book: `For ${levels.item}s (chapters), add ${levels.subtask}s like: scenes, key moments, character developments`,
                    course: `For ${levels.item}s (modules), add ${levels.subtask}s like: lessons, activities, assessments, practice exercises`,
                    film: `For ${levels.item}s (scenes), add ${levels.subtask}s like: specific shots, camera movements, lighting changes`,
                    prompting: `For ${levels.item}s (prompts), add ${levels.subtask}s like: test cases, variations, edge cases to handle`,
                    generic: `For ${levels.item}s, add ${levels.subtask}s like: steps, components, or sub-elements needed`
                };
                return guidance[pattern] || guidance.generic;
            }

            // Pattern-specific instructions for Quick Mode
            // BUILD 321: Enhanced CAPEX prompts with transcript analysis + research request detection
            let patternSpecialInstructions = '';
            if (pattern === 'capex') {
                // BUILD 321: Detect if text looks like a meeting transcript
                const isTranscript = /\[\d{1,2}:\d{2}\]|transcript|meeting notes|discussed|mentioned|can you research|look into|we should check/i.test(text);

                const transcriptExtras = isTranscript ? `

## MEETING TRANSCRIPT MODE (Detected)
This appears to be a meeting transcript. In addition to extracting CAPEX items:

### EXTRACT CONTACTS
For any person mentioned with a company/role, add to extractedContacts array:
- name: Person's full name
- role: Their title/role if mentioned
- company: Their company/organization
- context: How they relate to the project (vendor contact, consultant, etc.)

### DETECT RESEARCH REQUESTS
Look for phrases like "research this", "look into", "can you check", "we should investigate", "find out about".
Add these to researchRequests array with:
- topic: What needs to be researched
- context: Why it was requested
- priority: high/medium/low based on urgency indicators

### UPDATE SIGNALS
If transcript mentions updates to existing items (new pricing, changed timelines, etc.):
- Include itemUpdates array with: itemName, field, oldValue (if mentioned), newValue
` : '';

                patternSpecialInstructions = `

âš ï¸ CAPEX PATTERN REQUIREMENTS (Financial Rigor):

## COST EXTRACTION (CRITICAL)
1. **EXTRACT ALL DOLLAR AMOUNTS**: Every cost, budget, price mentioned MUST be captured
2. **PRESERVE EXACT VALUES**: "$1.2M" â†’ cost: 1200000, NOT rounded or estimated
3. **TRACK VENDORS**: Any company/supplier names go in alternateSource field
4. **DEPENDENCIES**: Equipment that relies on other items â†’ dependencies array

## HIERARCHY STRUCTURE
- Phase = Project phase (Planning, Procurement, Installation, Testing, etc.)
- Item = Capital expense line item (equipment, infrastructure, service)
- SubItem = Component, delivery milestone, or installation step

## REQUIRED FIELDS PER ITEM
- name: Equipment/expense name (be specific: "Dell PowerEdge R750 Servers" not "servers")
- cost: Numeric value in base currency (no symbols, no commas)
- itemType: equipment/infrastructure/labor/contingency/software/consulting
- leadTime: Delivery/implementation time if mentioned ("6-8 weeks")
- alternateSource: Vendor/supplier name

## ITEM TYPES (Use precisely)
- equipment: Physical hardware, machinery, devices
- infrastructure: Facilities, power, cooling, networking
- labor: Installation, configuration, training services
- software: Licenses, subscriptions, development
- consulting: Professional services, design, project management
- contingency: Risk reserves, buffer allocations
${transcriptExtras}
âš ï¸ KEY: NEVER skip cost values. If a range is given ($100K-$150K), use midpoint.
`;
            } else if (pattern === 'philosophy') {
                patternSpecialInstructions = `

âš ï¸ PHILOSOPHY PATTERN REQUIREMENTS (Academic Standard):

## SCHOLARLY REQUIREMENTS
Your output must include:
1. **NAMED SECONDARY SOURCES**: Cite at least 2-3 specific scholars who have written on this text (e.g., "Vlastos (1991)", "Williams (1978)")
2. **STANDARD OBJECTIONS**: Name specific objections with their associated philosophers (e.g., "Lichtenberg's objection", "Cartesian Circle")
3. **TRADITION PLACEMENT**: Identify the specific philosophical school (Platonic, Rationalist, Empiricist, etc.)

## STRUCTURE
1. Create 3-5 movements (phases) following the text's argumentative structure
2. EVERY claim MUST have 1-3 subItems (supporting premises, evidence, or reasoning)
3. Include IMPLICIT premises (unstated assumptions required for validity)

## ITEM TYPES (Use precisely)
- question: Interrogative moves that drive inquiry forward
- premise: Explicit foundational claims
- implicit-premise: Unstated assumptions required for validity
- definition: Attempts to characterize a concept
- distinction: Conceptual clarification separating ideas
- thought-experiment: Hypothetical scenario testing intuitions
- refutation: Counter-arguments that challenge positions
- objection: Standard criticism from the literature
- conclusion: Claims derived from prior reasoning

## METADATA (Required)
Include in root metadata: tradition, method, keyTerms, interlocutors, secondarySources, standardObjections

âš ï¸ KEY: Name SPECIFIC scholars and objections. Do not use generic placeholders.
`;
            } else if (pattern === 'film') {
                patternSpecialInstructions = `\n\nâš ï¸ AI VIDEO: Create ACTUAL SCENES (not workflows about making videos). Each item = one shot. Include videoPrompt, cameraMovement, visualStyle, duration.\n`;
            }

            // =========================================================================
            // CHUNK PROCESSING LOOP
            // =========================================================================
            const allPhasesCollected = [];
            let projectName = '';
            // BUILD 321: Transcript analysis aggregation
            const allExtractedContacts = [];
            const allResearchRequests = [];
            const allItemUpdates = [];

            for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                const chunk = chunks[chunkIndex];
                console.log(`ðŸ”„ Processing chunk ${chunkIndex + 1}/${chunks.length} (${chunk.text.length} chars)`);

                // BUILD 321: Detect transcript mode for CAPEX
                const isTranscript = pattern === 'capex' && /\[\d{1,2}:\d{2}\]|transcript|meeting notes|discussed|mentioned|can you research|look into|we should check/i.test(text);

                // BUILD 321: Additional JSON fields for transcript mode
                const transcriptJsonFields = isTranscript ? `,
  "extractedContacts": [
    { "name": "Person Name", "role": "Title", "company": "Company", "context": "Vendor contact" }
  ],
  "researchRequests": [
    { "topic": "What to research", "context": "Why it matters", "priority": "high/medium/low" }
  ],
  "itemUpdates": [
    { "itemName": "Existing item", "field": "cost", "newValue": "Updated value" }
  ]` : '';

                // Pattern-aware context for this specific chunk
                // BUILD 353: Prepend Smart Import Context if available
                const smartContext = window.smartImportContext || '';
                const chunkPrompt = `${smartContext}Extract items for the ${patternConfig.name} pattern from this SPECIFIC SECTION of a larger document (Section ${chunkIndex + 1}/${chunks.length}).

PATTERN HIERARCHY:
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}
${itemTypeHints}${quickFieldHints}${patternSpecialInstructions}

SECTION TEXT:
${chunk.text}

INSTRUCTIONS (BE CONCISE TO AVOID TIMEOUT):
1. Identify hierarchical structure in THIS SECTION ONLY
2. Create 1-2 phases (${levels.phase}s) for content in this section
3. For each phase, create 2-4 items (${levels.item}s)
4. Add 2-3 ${levels.subtask}s to items that need them
   â†’ ${getPatternSubtaskGuidance(pattern)}
5. Keep descriptions SHORT (under 100 characters)
6. Extract key fields if mentioned
7. ONLY extract content from this section - don't infer content from other sections

JSON FORMATTING RULES (CRITICAL):
- NO trailing commas
- ONLY plain JSON - no markdown, no explanations
- Start response with { and end with }

Respond with ONLY valid JSON:
{
  "projectName": "Section ${chunkIndex + 1} or inferred name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle",
      "icon": "ðŸ“‹",
      "items": [
        {
          "name": "Item name",
          "description": "Brief description",
          "itemType": "type",
          "subItems": [
            { "name": "${levels.subtask} 1", "description": "Detail" }
          ]
        }
      ]
    }
  ]${transcriptJsonFields}
}`;

                // BUILD 319: Use optimized model selection based on pattern
                // A/B testing showed +13.9% improvement with pattern-specific models
                const response = await callOptimizedImportAPI(chunkPrompt, '', 2000, pattern);

                // Parse JSON response from this chunk
                try {
                    let jsonText = response.trim();

                    // Remove markdown code blocks if present
                    jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    // Find the FIRST complete JSON object using proper brace matching
                    const firstBrace = jsonText.indexOf('{');

                    if (firstBrace === -1) {
                        console.warn(`âš ï¸ Chunk ${chunkIndex + 1}: No JSON found, skipping`);
                        continue;
                    }

                    if (firstBrace > 0) {
                        console.log(`ðŸª„ Chunk ${chunkIndex + 1}: Skipping text before JSON`);
                    }

                    let depth = 0;
                    let endPos = -1;
                    let inString = false;
                    let escapeNext = false;

                    for (let i = firstBrace; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            inString = !inString;
                            continue;
                        }

                        if (!inString) {
                            if (char === '{') depth++;
                            else if (char === '}') {
                                depth--;
                                if (depth === 0) {
                                    endPos = i + 1;
                                    break;
                                }
                            }
                        }
                    }

                    if (endPos === -1) {
                        console.warn(`âš ï¸ Chunk ${chunkIndex + 1}: Incomplete JSON, skipping`);
                        continue;
                    }

                    jsonText = jsonText.substring(firstBrace, endPos);

                    // Parse JSON
                    let parsed;
                    try {
                        parsed = JSON.parse(jsonText);
                    } catch (firstError) {
                        console.warn(`ðŸª„ Chunk ${chunkIndex + 1}: JSON parse failed, attempting sanitization...`, firstError.message);

                        // Sanitize JSON: Fix control characters in string values
                        let sanitized = '';
                        let inString = false;
                        let escapeNext = false;

                        for (let i = 0; i < jsonText.length; i++) {
                            const char = jsonText[i];

                            if (escapeNext) {
                                sanitized += char;
                                escapeNext = false;
                                continue;
                            }

                            if (char === '\\') {
                                sanitized += char;
                                escapeNext = true;
                                continue;
                            }

                            if (char === '"') {
                                sanitized += char;
                                inString = !inString;
                                continue;
                            }

                            // If we're inside a string value, escape control characters
                            if (inString) {
                                if (char === '\n') {
                                    sanitized += '\\n';
                                } else if (char === '\r') {
                                    sanitized += '\\r';
                                } else if (char === '\t') {
                                    sanitized += '\\t';
                                } else if (char.charCodeAt(0) < 32) {
                                    sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                                } else {
                                    sanitized += char;
                                }
                            } else {
                                sanitized += char;
                            }
                        }

                        jsonText = sanitized;
                        console.log(`âœ… Chunk ${chunkIndex + 1}: JSON sanitized successfully`);
                        parsed = JSON.parse(jsonText);
                    }

                    // Aggregate results from this chunk
                    if (!projectName && parsed.projectName) {
                        projectName = parsed.projectName;
                        console.log(`ðŸ“ Project name extracted from chunk ${chunkIndex + 1}: ${projectName}`);
                    }

                    if (parsed.phases && parsed.phases.length > 0) {
                        console.log(`âœ… Chunk ${chunkIndex + 1}: Extracted ${parsed.phases.length} phases`);
                        allPhasesCollected.push(...parsed.phases);
                    }

                    // BUILD 321: Aggregate transcript analysis fields
                    if (parsed.extractedContacts && parsed.extractedContacts.length > 0) {
                        console.log(`ðŸ“‡ Chunk ${chunkIndex + 1}: Found ${parsed.extractedContacts.length} contacts`);
                        allExtractedContacts.push(...parsed.extractedContacts);
                    }
                    if (parsed.researchRequests && parsed.researchRequests.length > 0) {
                        console.log(`ðŸ” Chunk ${chunkIndex + 1}: Found ${parsed.researchRequests.length} research requests`);
                        allResearchRequests.push(...parsed.researchRequests);
                    }
                    if (parsed.itemUpdates && parsed.itemUpdates.length > 0) {
                        console.log(`ðŸ“ Chunk ${chunkIndex + 1}: Found ${parsed.itemUpdates.length} item updates`);
                        allItemUpdates.push(...parsed.itemUpdates);
                    }

                } catch (e) {
                    console.error(`âŒ Chunk ${chunkIndex + 1} failed to parse:`, e);
                    console.error('Response (first 500 chars):', response.substring(0, 500));
                    // Continue to next chunk instead of failing entirely
                }
            }

            // =========================================================================
            // MERGE DUPLICATE PHASES AND RETURN AGGREGATED RESULT
            // =========================================================================
            console.log(`âœ… All chunks processed. Total phases collected: ${allPhasesCollected.length}`);

            // Merge phases with the same name
            const phaseMap = new Map();
            allPhasesCollected.forEach(phase => {
                const phaseName = phase.name;
                if (phaseMap.has(phaseName)) {
                    // Merge items into existing phase
                    const existingPhase = phaseMap.get(phaseName);
                    if (phase.items && phase.items.length > 0) {
                        existingPhase.items.push(...phase.items);
                    }
                } else {
                    // Add new phase
                    phaseMap.set(phaseName, { ...phase });
                }
            });

            const mergedPhases = Array.from(phaseMap.values());
            console.log(`âœ… After merging duplicates: ${mergedPhases.length} unique phases`);

            // Use a generic project name if none was extracted
            if (!projectName) {
                projectName = `${patternConfig.name} Project`;
            }

            // BUILD 321: Include transcript analysis data if available
            const result = {
                projectName: projectName,
                phases: mergedPhases
            };

            // Add transcript analysis fields if any were detected
            if (allExtractedContacts.length > 0) {
                result.extractedContacts = allExtractedContacts;
                console.log(`ðŸ“‡ Total contacts extracted: ${allExtractedContacts.length}`);
            }
            if (allResearchRequests.length > 0) {
                result.researchRequests = allResearchRequests;
                console.log(`ðŸ” Total research requests: ${allResearchRequests.length}`);
            }
            if (allItemUpdates.length > 0) {
                result.itemUpdates = allItemUpdates;
                console.log(`ðŸ“ Total item updates: ${allItemUpdates.length}`);
            }

            return result;
        }

        // =========================================================================
        // BUILD 355: VERIFICATION PASS - Validate & Auto-Fix Generated Trees
        // =========================================================================
        // Generator â†’ Critic â†’ Revise pipeline to catch errors before user sees them

        /**
         * Verify generated tree data and attempt fixes if issues found
         * @param {Object} treeData - The generated tree data
         * @param {string} pattern - The pattern used
         * @param {string} originalText - Original input text (for context in fixes)
         * @returns {Object} - Verified/fixed tree data
         */
        async function verifyAndFixTreeData(treeData, pattern, originalText) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;

            console.log('ðŸ” BUILD 355: Starting verification pass...');

            // Collect issues
            const issues = [];

            // Check 1: Has phases?
            if (!treeData.phases || !Array.isArray(treeData.phases) || treeData.phases.length === 0) {
                issues.push({
                    severity: 'critical',
                    message: `No ${levels.phase}s found in generated tree`,
                    type: 'missing_phases'
                });
            }

            // Check 2: Project name exists?
            if (!treeData.projectName || treeData.projectName.trim() === '') {
                issues.push({
                    severity: 'minor',
                    message: 'Missing project name',
                    type: 'missing_project_name'
                });
                // Quick fix - don't need AI for this
                treeData.projectName = `${patternConfig.name} Project`;
            }

            // Check 3: Validate each phase
            let totalItems = 0;
            let itemsWithDescription = 0;
            let itemsWithSubtasks = 0;

            if (treeData.phases && Array.isArray(treeData.phases)) {
                treeData.phases.forEach((phase, pIdx) => {
                    // Phase needs a name
                    if (!phase.name || phase.name.trim() === '') {
                        issues.push({
                            severity: 'warning',
                            message: `${levels.phase} ${pIdx + 1} has no name`,
                            type: 'missing_phase_name',
                            location: `phase[${pIdx}]`
                        });
                    }

                    // Phase should have items
                    if (!phase.items || !Array.isArray(phase.items) || phase.items.length === 0) {
                        issues.push({
                            severity: 'warning',
                            message: `${levels.phase} "${phase.name || pIdx + 1}" has no ${levels.item}s`,
                            type: 'empty_phase',
                            location: `phase[${pIdx}]`
                        });
                    } else {
                        // Check each item
                        phase.items.forEach((item, iIdx) => {
                            totalItems++;

                            if (!item.name || item.name.trim() === '') {
                                issues.push({
                                    severity: 'warning',
                                    message: `${levels.item} at ${levels.phase} "${phase.name}" position ${iIdx + 1} has no name`,
                                    type: 'missing_item_name',
                                    location: `phase[${pIdx}].items[${iIdx}]`
                                });
                            }

                            if (item.description && item.description.trim() !== '') {
                                itemsWithDescription++;
                            }

                            if (item.subtasks && Array.isArray(item.subtasks) && item.subtasks.length > 0) {
                                itemsWithSubtasks++;
                            } else if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                                // Some patterns use subItems instead of subtasks
                                itemsWithSubtasks++;
                            }
                        });
                    }
                });
            }

            // Check 4: Description coverage (warn if <50% have descriptions)
            if (totalItems > 0) {
                const descCoverage = (itemsWithDescription / totalItems) * 100;
                if (descCoverage < 50) {
                    issues.push({
                        severity: 'quality',
                        message: `Only ${Math.round(descCoverage)}% of ${levels.item}s have descriptions`,
                        type: 'low_description_coverage',
                        stats: { total: totalItems, withDesc: itemsWithDescription }
                    });
                }
            }

            // Check 5: Subtask coverage for deep patterns (philosophy, thesis, course)
            const deepPatterns = ['philosophy', 'thesis', 'course', 'book', 'film'];
            if (deepPatterns.includes(pattern) && totalItems > 0) {
                const subtaskCoverage = (itemsWithSubtasks / totalItems) * 100;
                if (subtaskCoverage < 30) {
                    issues.push({
                        severity: 'quality',
                        message: `Only ${Math.round(subtaskCoverage)}% of ${levels.item}s have ${levels.subtask}s (${pattern} pattern expects more depth)`,
                        type: 'low_subtask_coverage',
                        stats: { total: totalItems, withSubtasks: itemsWithSubtasks }
                    });
                }
            }

            // Log issues found
            const criticalIssues = issues.filter(i => i.severity === 'critical');
            const warningIssues = issues.filter(i => i.severity === 'warning');
            const qualityIssues = issues.filter(i => i.severity === 'quality');

            console.log(`ðŸ” Verification complete: ${criticalIssues.length} critical, ${warningIssues.length} warnings, ${qualityIssues.length} quality suggestions`);

            // If critical issues or multiple warnings, attempt AI fix
            if (criticalIssues.length > 0 || warningIssues.length >= 3) {
                console.log('âš ï¸ Issues require AI correction. Attempting fix...');

                try {
                    const fixedTree = await attemptAITreeFix(treeData, issues, pattern, originalText);
                    if (fixedTree) {
                        console.log('âœ… AI fix successful');
                        // Add verification metadata
                        fixedTree._verificationPassed = true;
                        fixedTree._fixApplied = true;
                        fixedTree._issuesFixed = issues.length;
                        return fixedTree;
                    }
                } catch (error) {
                    console.warn('âš ï¸ AI fix failed, returning original with warnings:', error.message);
                }
            }

            // Add verification metadata
            treeData._verificationPassed = issues.filter(i => i.severity !== 'quality').length === 0;
            treeData._qualityIssues = qualityIssues.length;

            return treeData;
        }

        /**
         * Call AI to fix issues in generated tree
         */
        async function attemptAITreeFix(treeData, issues, pattern, originalText) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;

            // Build feedback prompt
            const issuesList = issues.map(i => `- ${i.message}`).join('\n');

            const fixPrompt = `You previously generated a tree structure but it has these issues:

${issuesList}

Here is the ORIGINAL TEXT that needs to be analyzed:
---
${originalText.substring(0, 3000)}${originalText.length > 3000 ? '...(truncated)' : ''}
---

Here is the FLAWED TREE you generated:
${JSON.stringify(treeData, null, 2).substring(0, 2000)}

Please regenerate the tree, fixing all the issues above. The pattern is "${patternConfig.name}" with these levels:
- ${levels.root} (root)
- ${levels.phase} (phases/major sections)
- ${levels.item} (items within each phase)
- ${levels.subtask} (subtasks/sub-items for depth)

IMPORTANT:
1. Every ${levels.phase} must have a meaningful name
2. Every ${levels.phase} must have at least 1-2 ${levels.item}s
3. ${levels.item}s should have descriptions that capture key information
4. For ${pattern} pattern, include ${levels.subtask}s where the content supports them

Return ONLY valid JSON in this exact format:
{
  "projectName": "...",
  "phases": [
    {
      "name": "...",
      "items": [
        {
          "name": "...",
          "description": "...",
          "subtasks": [{ "name": "..." }]
        }
      ]
    }
  ]
}`;

            // Get current AI provider
            const provider = localStorage.getItem('aiProvider') || 'claude';
            let response;

            // Show fixing status
            const modalBody = document.getElementById('modal-body');
            if (modalBody) {
                modalBody.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div class="spinner"></div>
                        <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600;">
                            ðŸ”§ Fixing ${issues.length} issue${issues.length > 1 ? 's' : ''}...
                        </p>
                        <p style="color: var(--text-secondary); font-size: 13px; margin-top: 8px;">
                            TreeBeard is reviewing and improving the structure
                        </p>
                    </div>
                `;
            }

            try {
                if (provider === 'claude') {
                    response = await callClaudeAPI(fixPrompt);
                } else if (provider === 'gemini') {
                    response = await callGeminiAPI(fixPrompt);
                } else if (provider === 'openai') {
                    response = await callOpenAIAPI(fixPrompt);
                } else {
                    throw new Error('Unknown AI provider');
                }

                // Extract JSON from response
                let jsonText = response.trim();
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                const firstBrace = jsonText.indexOf('{');
                if (firstBrace === -1) throw new Error('No JSON in fix response');

                // Find matching closing brace
                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonText.length; i++) {
                    const char = jsonText[i];
                    if (escapeNext) { escapeNext = false; continue; }
                    if (char === '\\') { escapeNext = true; continue; }
                    if (char === '"') { inString = !inString; continue; }
                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) { endPos = i + 1; break; }
                        }
                    }
                }

                if (endPos === -1) throw new Error('Incomplete JSON in fix response');

                jsonText = jsonText.substring(firstBrace, endPos);
                const fixed = JSON.parse(jsonText);

                // Validate the fix actually improved things
                if (!fixed.phases || fixed.phases.length === 0) {
                    throw new Error('Fix produced empty tree');
                }

                // Preserve any transcript analysis data from original
                if (treeData.extractedContacts) fixed.extractedContacts = treeData.extractedContacts;
                if (treeData.researchRequests) fixed.researchRequests = treeData.researchRequests;
                if (treeData.itemUpdates) fixed.itemUpdates = treeData.itemUpdates;

                return fixed;

            } catch (error) {
                console.error('âŒ AI fix attempt failed:', error);
                throw error;
            }
        }

        // OLD SINGLE-CHUNK FALLBACK (DEPRECATED - keeping for reference)
        async function convertTextToTreeQuick_LEGACY(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the FIRST complete JSON object using proper brace matching
                const firstBrace = jsonText.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ðŸª„ [Quick] Skipping text before JSON:', jsonText.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Incomplete JSON object in AI response (no closing brace found).');
                }

                if (endPos < jsonText.length) {
                    console.log('ðŸª„ [Quick] Skipping text after JSON:', jsonText.substring(endPos, Math.min(endPos + 100, jsonText.length)));
                }

                jsonText = jsonText.substring(firstBrace, endPos);

                console.log('ðŸª„ [Quick] Extracted JSON length:', jsonText.length);

                // Sanitize JSON: Fix control characters in string values (same as wizard)
                let parsed;
                try {
                    parsed = JSON.parse(jsonText);
                } catch (firstError) {
                    console.warn('ðŸª„ [Quick] JSON parse failed, attempting sanitization...', firstError.message);

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonText = sanitized;
                    console.log('âœ… [Quick] JSON sanitized successfully');
                    parsed = JSON.parse(jsonText);
                }

                return parsed;
            } catch (e) {
                console.error('Failed to parse quick conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('ðŸ”§ Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('âœ… JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('âŒ Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Deep Mode: Detailed parsing with field extraction
        async function convertTextToTreeDeep(text, pattern) {
            const patternConfig = PATTERNS[pattern];
            const levels = patternConfig.levels;
            const fields = patternConfig.fields || {};

            // SPECIAL CASE: Prompt Engineering pattern - improve the prompt instead of extracting
            if (pattern === 'prompting') {
                return await improvePromptWithAI(text, 'deep');
            }

            // =========================================================================
            // SEMANTIC CHUNKING PREPROCESSING (Deep Mode)
            // =========================================================================
            console.log('ðŸ§  [Deep] Starting semantic chunking preprocessing...');
            const chunker = new SemanticChunker();
            let chunks;

            // Show chunking status in UI
            const modalBody = document.getElementById('modal-body');
            if (modalBody) {
                modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">ðŸ§  Analyzing text structure (Deep Mode)...</p>';
            }

            // Tier 2: Scientific approach (if embedding provider available)
            if (EmbeddingManager.hasProvider()) {
                console.log('âœ… [Deep] Embedding provider detected - using scientific semantic chunking');
                try {
                    chunks = await chunker.chunkByEmbedding(text);
                } catch (error) {
                    console.warn('âš ï¸ [Deep] Semantic chunking failed, falling back to structural split:', error);
                    chunks = chunker.structuralSplit(text);
                }
            } else {
                // Tier 1: Structural fallback
                console.log('ðŸ“ [Deep] No embedding provider - using structural split');
                chunks = chunker.structuralSplit(text);
            }

            console.log(`âœ… [Deep] Text split into ${chunks.length} semantic chunks`);

            // Show chunk visualization
            if (modalBody && chunks.length > 1) {
                const chunkLengths = chunks.map(c => c.text.length);
                const maxLength = Math.max(...chunkLengths);
                const bars = chunks.map((chunk, i) => {
                    const width = (chunk.text.length / maxLength) * 100;
                    return `<div style="background: linear-gradient(90deg, rgba(244, 63, 94, 0.6), rgba(251, 146, 60, 0.6)); height: 10px; width: ${width}%; border-radius: 4px; margin: 2px 0;" title="Chunk ${i + 1}: ${chunk.text.length} chars"></div>`;
                }).join('');

                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div class="spinner"></div>
                            <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600;">
                                ðŸ§  Deep Mode: ${chunks.length} Semantic Sections Detected
                            </p>
                            <p style="color: var(--text-secondary); font-size: 13px; margin-top: 4px;">
                                Performing comprehensive extraction on each section...
                            </p>
                        </div>
                        <div style="padding: 12px; background: rgba(244, 63, 94, 0.1); border-radius: 8px; border: 1px solid rgba(244, 63, 94, 0.3);">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Chunk size distribution:</div>
                            ${bars}
                        </div>
                    </div>
                `;
            }

            // Generate dynamic field extraction guide from pattern.fields
            function generateFieldExtractionGuide(pattern) {
                const patternDef = PATTERNS[pattern];
                const fields = patternDef.fields || {};

                let guide = `\n${patternDef.name.toUpperCase()} PATTERN - EXTRACT THESE FIELDS FOR EVERY ITEM:\n`;

                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];

                    // Skip non-field properties
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    if (fieldConfig.label) {
                        guide += `- ${fieldKey}: ${fieldConfig.label}`;

                        // Add extraction hints based on field type
                        if (fieldConfig.type === 'number') {
                            guide += ` (extract numeric value`;
                            if (fieldConfig.min !== undefined || fieldConfig.max !== undefined) {
                                guide += `, valid range ${fieldConfig.min || 0}-${fieldConfig.max || 'âˆž'}`;
                            }
                            if (fieldConfig.step !== undefined) {
                                guide += `, use increments of ${fieldConfig.step}`;
                            }
                            guide += `)`;
                        } else if (fieldConfig.type === 'date') {
                            guide += ` (extract date, format as YYYY-MM-DD)`;
                        } else if (fieldConfig.type === 'select' && fieldConfig.options) {
                            guide += ` (choose from: ${fieldConfig.options.join(', ')})`;
                        } else if (fieldConfig.type === 'textarea') {
                            guide += ` (detailed text, 100-300 characters)`;
                        } else if (fieldConfig.type === 'text' && fieldConfig.placeholder) {
                            guide += ` (e.g., "${fieldConfig.placeholder}")`;
                        }

                        if (fieldConfig.helpText) {
                            guide += ` - ${fieldConfig.helpText}`;
                        }

                        guide += `\n`;
                    }
                });

                // Add item types
                if (patternDef.types && patternDef.types.length > 0) {
                    guide += `\nITEM TYPES FOR ${patternDef.name.toUpperCase()}: Use specific types from this list:\n`;
                    const typesList = patternDef.types.map(t => t.value).join(', ');
                    guide += typesList + '\n';
                    guide += `(NOT generic types - use the specific types above to categorize each item)\n`;
                }

                // Add PM tracking fields if pattern supports it
                if (fields.includeTracking && patternDef.fields.trackingFor) {
                    guide += `\nPM TRACKING FIELDS (for ${patternDef.fields.trackingFor.join('/')}s):\n`;
                    guide += `- pmStatus: Task status (choose from: To Do, In Progress, Blocked, Done)\n`;
                    guide += `- pmAssignee: Person responsible (if mentioned in text)\n`;
                    guide += `- pmProgress: Completion percentage (0-100)\n`;
                    guide += `- pmPriority: Priority level (Low, Medium, High, Critical)\n`;
                    guide += `- pmDueDate: Deadline (format YYYY-MM-DD if mentioned)\n`;
                    guide += `- pmStartDate: Start date (format YYYY-MM-DD if mentioned)\n`;
                }

                // Add dependencies hint
                if (fields.includeDependencies) {
                    guide += `\nDEPENDENCIES:\n`;
                    guide += `- Identify which ${levels.item}s depend on others\n`;
                    guide += `- Look for: "depends on", "requires", "after", "builds on", "assumes"\n`;
                    guide += `- Format as array of item IDs: ["item-0-1", "item-0-2"]\n`;
                }

                return guide;
            }

            const patternFieldGuide = generateFieldExtractionGuide(pattern);

            // Pattern-specific subtask guidance for Deep Mode
            // BUILD 320: Added CAPEX subtask guidance
            function getDeepModeSubtaskGuidance(pattern) {
                const guidance = {
                    capex: `CAPEX: ${levels.subtask}s = components, delivery milestones, installation steps, vendor deliverables, verification tasks. Include cost breakdowns where available.`,
                    philosophy: `Philosophy: ${levels.subtask}s = premises, objections, supporting evidence, citations. REQUIRED: 1-3 subItems per claim. NEVER skip subItems.`,
                    sales: `Sales: ${levels.subtask}s = follow-up actions, meeting notes, deliverables, next steps to advance the deal`,
                    thesis: `Academic: ${levels.subtask}s = supporting arguments, citations, evidence, counter-arguments to address`,
                    roadmap: `Engineering: ${levels.subtask}s = implementation tasks, technical specs, acceptance criteria, testing steps`,
                    book: `Narrative: ${levels.subtask}s = individual scenes, character moments, plot developments, transitions`,
                    course: `Education: ${levels.subtask}s = lessons, activities, assessments, practice exercises, readings`,
                    film: `Film: ${levels.subtask}s = specific shots, camera angles, lighting changes, actor blocking, technical details`,
                    prompting: `Prompting: ${levels.subtask}s = test cases, edge cases, variations to handle, example inputs/outputs`,
                    generic: `${levels.subtask}s = steps, components, or sub-elements needed to complete the ${levels.item}`
                };
                return guidance[pattern] || guidance.generic;
            }

            // Pattern-specific extraction instructions
            // BUILD 320: Added CAPEX pattern instructions based on A/B testing
            function getPatternSpecificInstructions(pattern) {
                const instructions = {
                    capex: `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ CAPEX PATTERN - FINANCIAL RIGOR REQUIRED
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ’° COST EXTRACTION (CRITICAL - DO NOT SKIP):
Every dollar amount in the source text MUST be captured:
- "$1.2M" â†’ cost: 1200000 (raw number, no symbols)
- "$500K-$750K" â†’ cost: 625000 (use midpoint)
- "approximately $2 million" â†’ cost: 2000000
- NEVER omit or round costs arbitrarily

ðŸ“Š PROJECT HIERARCHY:
- Phase = Project phase (Planning, Procurement, Installation, Commissioning, etc.)
- Item = Individual capital expense line item (equipment, infrastructure, service)
- SubItem = Component, delivery milestone, installation step, or verification task

ðŸ·ï¸ ITEM TYPES (Assign precisely):
- equipment: Physical hardware, servers, machinery, devices
- infrastructure: Facilities, power distribution, cooling, networking, cabling
- labor: Installation services, configuration, training, deployment
- software: Licenses, subscriptions, development, integration
- consulting: Professional services, architecture, design, project management
- contingency: Risk reserves, buffer allocations, variance pools

ðŸ“‹ REQUIRED FIELDS FOR EVERY ITEM:
- name: SPECIFIC equipment name (e.g., "Dell PowerEdge R750 Servers (96 units)" NOT just "servers")
- cost: Numeric value ONLY (no $ or commas)
- itemType: One of the types above
- description: Technical specifications or scope details
- leadTime: Delivery/implementation time if mentioned ("6-8 weeks", "Q3 2025")
- alternateSource: Vendor/supplier name (Cisco, Dell, contractor name)
- dependencies: Array of item IDs this depends on ["item-0-1", "item-1-2"]

ðŸ”— DEPENDENCY TRACKING:
Look for sequencing language:
- "after installation of..." â†’ add dependency
- "requires..." â†’ add dependency
- "cannot proceed until..." â†’ add dependency
- Format: dependencies: ["item-X-Y"] referencing other items

âš ï¸ COMMON MISTAKES TO AVOID:
- Omitting cost values (NEVER skip a dollar amount)
- Generic names like "Equipment" (be specific)
- Missing vendor/supplier names
- Ignoring contingency/risk reserves
- Skipping lead time information
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`,
                    philosophy: `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ PHILOSOPHY PATTERN - CRITICAL REQUIREMENTS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“œ ARGUMENTATIVE STRUCTURE (3-5 PHASES):
Follow the text's own argumentative flow. Common patterns include:
- Problem/Question â†’ Method â†’ Analysis â†’ Conclusion
- Thesis â†’ Antithesis â†’ Synthesis
- Doubt â†’ Investigation â†’ Discovery â†’ Implications

ðŸ“‹ SUBITEMS REQUIREMENT:
- EVERY claim MUST have 1-3 subItems
- SubItems = premises, evidence, textual references, supporting reasoning
- NEVER create claims without supporting subItems

ðŸ·ï¸ ARGUMENT TYPES (Use correctly):
- question: Interrogative moves that drive the inquiry forward
- premise: Foundational claims or assumptions supporting later arguments
- definition: Explicit attempts to define or characterize concepts
- refutation: Counter-arguments that challenge or disprove prior claims
  âš ï¸ Includes: analogies, thought experiments, reductio arguments used to COUNTER a position
- conclusion: Claims derived from prior reasoning

âš ï¸ KEY DISTINCTION:
When an analogy or thought experiment is used to CHALLENGE or DISPROVE a claim,
it is a REFUTATION, not a question or premise. Look for the argumentative function.

âœ… CORRECT TYPING:
- "If a deceiver deceives me, I must exist to be deceived" â†’ refutation (self-refuting doubt)
- "What is the nature of X?" â†’ question
- "X is defined as Y" â†’ definition
- "Therefore, X must be true" â†’ conclusion
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`,
                    film: `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ AI VIDEO PRODUCTION - CRITICAL INSTRUCTIONS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

YOU ARE CREATING ACTUAL VIDEO SCENES, NOT META-WORKFLOWS!

ðŸŽ¬ WHAT TO CREATE:
- Each item = ONE SPECIFIC SHOT/SCENE
- Describe WHAT APPEARS IN THE FRAME
- Include: subject, action, camera movement, lighting, mood

âŒ DO NOT CREATE:
- Workflows about "creating prompts"
- Meta-tasks like "Generate a prompt for..."
- Process steps like "Use Sora to..."
- Planning tasks like "Write description of..."

âœ… CORRECT EXAMPLE (user says "drone flight over data center"):
{
  "phases": [{
    "name": "Establishing Sequence",
    "items": [
      {
        "name": "Wide aerial establishing shot",
        "description": "Camera starts at 500 feet showing vast data center campus in Saskatchewan plains",
        "videoPrompt": "Aerial drone shot ascending from ground level, revealing massive data center facility surrounded by snow-covered farmland. Wide establishing shot showing geometric rows of server buildings with steam rising from cooling towers. Camera rises smoothly from 50 feet to 200 feet over 10 seconds. Golden hour lighting with long shadows across white landscape. Cinematic widescreen aesthetic.",
        "aiPlatform": "Veo 3 (Google)",
        "visualStyle": "Cinematic",
        "duration": "10 seconds",
        "aspectRatio": "16:9 (Widescreen)",
        "cameraMovement": "Crane Up",
        "motionIntensity": "Moderate",
        "lightingMood": "Golden Hour"
      },
      {
        "name": "Dolly shot of server building exterior",
        "description": "Close-up tracking shot along reflective glass facade",
        "videoPrompt": "Slow dolly right along mirrored glass exterior of data center building. Reflections of winter sky and clouds move across glass surface. Camera tracks steadily at 6 feet height, revealing geometric patterns of windows and air vents. Overcast lighting with soft shadows. Modern architectural aesthetic. 6-second clip.",
        "cameraMovement": "Tracking Shot",
        "duration": "6 seconds"
      }
    ]
  }]
}

âŒ WRONG EXAMPLE (meta-workflow - DO NOT DO THIS):
{
  "phases": [{
    "name": "Content Creation",
    "items": [
      {
        "name": "Introduction Prompt",
        "description": "Create a natural language prompt for an introductory segment"  âŒ NO!
      },
      {
        "name": "Generate Drone Tour",
        "description": "Use Sora to produce drone footage"  âŒ NO!
      }
    ]
  }]
}

ðŸŽ¥ FOR EACH SCENE ITEM:
1. **name**: Short description of the shot (e.g., "Aerial reveal of campus")
2. **description**: What happens in the scene (action, subjects, context)
3. **videoPrompt**: DETAILED 100-300 character prompt describing:
   - What appears in frame
   - Camera movement and framing
   - Lighting and mood
   - Visual style
   - Duration
4. **aiPlatform**: Which AI to use (Sora, Veo 3, Runway, Pika)
5. **cameraMovement**: How camera moves (Dolly In, Crane Up, Tracking Shot, etc.)
6. **visualStyle**: Cinematic, Documentary, Photorealistic, etc.
7. **lightingMood**: Golden Hour, Dramatic, Soft Natural, etc.
8. **duration**: How long (2s, 4s, 6s, 10s, 20s)
9. **aspectRatio**: 16:9, 9:16, 2.39:1, etc.

REMEMBER: You are a cinematographer, not a project planner!
Describe the ACTUAL SHOTS, not the process of creating them.
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`
                };

                return instructions[pattern] || '';
            }

            const patternSpecificInstructions = getPatternSpecificInstructions(pattern);

            // =========================================================================
            // CHUNK PROCESSING LOOP (Deep Mode)
            // =========================================================================
            const allPhasesCollected = [];
            let projectName = '';

            for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                const chunk = chunks[chunkIndex];
                console.log(`ðŸ”„ [Deep] Processing chunk ${chunkIndex + 1}/${chunks.length} (${chunk.text.length} chars)`);

                // Update UI with chunk progress feedback
                const percent = Math.round(((chunkIndex + 1) / chunks.length) * 100);
                const modalBody = document.getElementById('modal-body');
                if (modalBody && chunks.length > 1) {
                    const progressBars = chunks.map((c, i) => {
                        const isProcessed = i < chunkIndex;
                        const isProcessing = i === chunkIndex;
                        const barColor = isProcessed ? 'rgba(16, 185, 129, 0.8)' : isProcessing ? 'rgba(251, 146, 60, 0.8)' : 'rgba(100, 100, 100, 0.3)';
                        return `<div style="flex: 1; height: 8px; background: ${barColor}; border-radius: 4px; transition: background 0.3s;"></div>`;
                    }).join('');

                    modalBody.innerHTML = `
                        <div style="padding: 20px;">
                            <div style="text-align: center; margin-bottom: 16px;">
                                <div class="spinner"></div>
                                <p style="margin-top: 16px; color: var(--text-primary); font-weight: 600; font-size: 16px;">
                                    ðŸ§  Analyzing Section ${chunkIndex + 1} of ${chunks.length}
                                </p>
                                <p style="color: var(--text-secondary); font-size: 14px; margin-top: 4px;">
                                    ${percent}% complete â€¢ ${chunk.text.length.toLocaleString()} characters
                                </p>
                            </div>
                            <div style="display: flex; gap: 4px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                                ${progressBars}
                            </div>
                            <div style="text-align: center; margin-top: 12px; font-size: 12px; color: var(--text-secondary);">
                                Deep Mode extracts comprehensive details from each section
                            </div>
                        </div>
                    `;
                }

                // BUILD 353: Prepend Smart Import Context if available
                const smartContextDeep = window.smartImportContext || '';
                const chunkPrompt = `${smartContextDeep}Convert this SPECIFIC SECTION of a larger document into a detailed hierarchical structure using the "${patternConfig.name}" pattern (Section ${chunkIndex + 1}/${chunks.length}).

PATTERN HIERARCHY (4 LEVELS):
- Root: ${levels.root}
- Phase (Level 1): ${levels.phase}
- Item (Level 2): ${levels.item}
- Subtask (Level 3): ${levels.subtask}
${patternFieldGuide}
${patternSpecificInstructions}

SECTION TEXT (Section ${chunkIndex + 1}/${chunks.length}):
${chunk.text}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
DEEP MODE INSTRUCTIONS - COMPREHENSIVE EXTRACTION (SECTION ${chunkIndex + 1}/${chunks.length})
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âš ï¸ CRITICAL REQUIREMENTS - YOU MUST MEET THESE MINIMUMS FOR THIS SECTION:

1. PHASES: Create 1-3 phases (${levels.phase}s) for THIS SECTION ONLY
   â†’ Do NOT summarize - extract actual phases present in this section
   â†’ Each major subsection/movement/chapter in THIS SECTION = separate phase

2. ITEMS PER PHASE: REQUIRED MINIMUM 3-8 items (${levels.item}s) per phase
   â†’ Do NOT create just 1 item per phase
   â†’ Extract ALL significant claims/arguments/features/sections
   â†’ Each distinct idea/component/argument = separate item

3. SUBTASKS: Add 2-5 ${levels.subtask}s to items that need decomposition
   â†’ ${levels.subtask}s are pattern-specific breakdowns of each ${levels.item}
   â†’ ${getDeepModeSubtaskGuidance(pattern)}
   â†’ Only skip ${levels.subtask}s for truly atomic items that cannot be decomposed

4. DEPTH: Go 3-4 levels deep in the hierarchy
   â†’ Phase â†’ Item â†’ Subtask â†’ (nested subtask if needed)
   â†’ Do NOT stop at 2 levels

5. FIELD POPULATION: Extract ALL pattern-specific field values listed above
   â†’ Populate EVERY field mentioned in the "${patternConfig.name.toUpperCase()}" pattern section
   â†’ Do NOT leave fields empty if information is available in the text
   â†’ If exact value not in text, make intelligent estimates (for word counts, story points, etc.)
   â†’ For dates, use YYYY-MM-DD format

6. DEPENDENCIES: Identify ALL logical prerequisites
   â†’ Look for: "depends on", "requires", "builds on", "follows from", "assumes", "after"
   â†’ Format: ["item-X-Y", "item-Z-W"]
   â†’ Map both intra-phase and inter-phase dependencies

7. NODE TYPES: Use specific types from the "${patternConfig.name.toUpperCase()}" item type list above
   â†’ Use the EXACT type values provided (not generic categories)
   â†’ Different items should have different types based on their function
   â†’ Do NOT use the same type for every item

8. DESCRIPTIONS: Write detailed descriptions (100-250 characters)
   â†’ Capture nuance, context, and significance
   â†’ NOT just repetition of title

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
EXAMPLE OF PROPER DEPTH (Philosophy Pattern)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

If text contains: "Socrates asks: What is justice? Callias replies it is giving each what they are owed. Socrates refutes this with the mad debtor example."

WRONG (too shallow):
{
  "phases": [{
    "name": "Movement 1",
    "items": [{"name": "Discussion of justice"}]
  }]
}

CORRECT (proper depth):
{
  "phases": [{
    "name": "Movement 1",
    "subtitle": "The Initial Inquiry",
    "items": [
      {
        "name": "Opening Question: What is Justice?",
        "itemType": "question",
        "speaker": "Socrates",
        "description": "Socrates initiates inquiry by asking Callias to define justice",
        "keyTerms": "justice, definition",
        "dependencies": []
      },
      {
        "name": "First Definition: Justice as Giving What is Owed",
        "itemType": "definition",
        "speaker": "Callias",
        "description": "Callias proposes justice means giving each person what they are owed",
        "keyTerms": "justice, debt, obligation",
        "dependencies": []
      },
      {
        "name": "Refutation via Mad Debtor Counterexample",
        "itemType": "refutation",
        "speaker": "Socrates",
        "argumentType": "Socratic Elenchus",
        "description": "Socrates refutes Callias's definition using case of returning sword to madman",
        "dependencies": ["item-0-1"],
        "subItems": [
          {
            "name": "Premise: Returning sword to madman is dangerous",
            "itemType": "premise",
            "premise1": "The madman is owed the sword (per Callias's definition)",
            "conclusion": "But returning it would be unjust (harmful)",
            "description": "Creates contradiction in Callias's definition"
          },
          {
            "name": "Conclusion: Definition is insufficient",
            "itemType": "conclusion",
            "description": "Justice cannot be merely giving what is owed, circumstances matter",
            "dependencies": ["subtask-0-2-0"]
          }
        ]
      }
    ]
  }]
}

See the difference? The CORRECT version:
âœ“ Has 3 items (not 1)
âœ“ Uses specific item types (question, definition, refutation)
âœ“ Populates fields (speaker, argumentType, keyTerms, premises)
âœ“ Has subtasks with proper nesting
âœ“ Maps dependencies between nodes

THIS IS THE LEVEL OF DETAIL REQUIRED IN DEEP MODE.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
FINAL REMINDER
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Deep Mode = COMPREHENSIVE EXTRACTION, not summarization
Extract EVERYTHING with maximum granularity and detail
Aim for 25-40 total nodes for complex texts (Haiku's 4096 token limit)

JSON FORMATTING RULES (CRITICAL - FOLLOW EXACTLY):
- NO trailing commas after the last element in arrays or objects
- NO line breaks or tabs inside string values - use spaces instead
- NO unescaped quotes inside strings
- ONLY plain JSON - no markdown code blocks, no backticks, no explanations
- Start response with { and end with }

CORRECT EXAMPLE (note: NO trailing comma after last item):
{"phases": [{"name": "Test", "items": [{"name": "Item"}]}]}

WRONG (trailing comma):
{"phases": [{"name": "Test", "items": [{"name": "Item"},]}]}

Respond with ONLY valid, parseable JSON:
{
  "projectName": "Extracted or inferred project name",
  "phases": [
    {
      "name": "Phase name",
      "subtitle": "Phase subtitle",
      "icon": "ðŸ“‹",
      "items": [
        {
          "name": "Item name",
          "description": "Detailed description",
          "itemType": "category",
          "cost": 1000,
          "dependencies": ["item-0-1", "item-1-2"],
          "subtasks": [
            {
              "name": "Subtask name",
              "description": "What needs to be done",
              "dependencies": []
            }
          ],
          "... other pattern-specific fields ...": "values"
        }
      ]
    }
  ]
}`;

                // BUILD 319: Deep Mode uses optimized model selection + higher token limits
                // Pattern-specific models (e.g., Opus for Philosophy) with extended output
                const response = await callOptimizedImportAPI(chunkPrompt, '', 8192, pattern);

                // Parse JSON response from this chunk
                try {
                    let jsonText = response.trim();

                    // Remove markdown code blocks if present
                    jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    // Find the FIRST complete JSON object using proper brace matching
                    const firstBrace = jsonText.indexOf('{');

                    if (firstBrace === -1) {
                        console.warn(`âš ï¸ [Deep] Chunk ${chunkIndex + 1}: No JSON found, skipping`);
                        continue;
                    }

                    if (firstBrace > 0) {
                        console.log(`ðŸª„ [Deep] Chunk ${chunkIndex + 1}: Skipping text before JSON`);
                    }

                    let depth = 0;
                    let endPos = -1;
                    let inString = false;
                    let escapeNext = false;

                    for (let i = firstBrace; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            inString = !inString;
                            continue;
                        }

                        if (!inString) {
                            if (char === '{') depth++;
                            else if (char === '}') {
                                depth--;
                                if (depth === 0) {
                                    endPos = i + 1;
                                    break;
                                }
                            }
                        }
                    }

                    if (endPos === -1) {
                        console.warn(`âš ï¸ [Deep] Chunk ${chunkIndex + 1}: Incomplete JSON, skipping`);
                        continue;
                    }

                    jsonText = jsonText.substring(firstBrace, endPos);

                    // Parse JSON
                    let parsed;
                    try {
                        parsed = JSON.parse(jsonText);
                    } catch (firstError) {
                        console.warn(`ðŸª„ [Deep] Chunk ${chunkIndex + 1}: JSON parse failed, attempting sanitization...`, firstError.message);

                        // Sanitize JSON: Fix control characters in string values
                        let sanitized = '';
                        let inString = false;
                        let escapeNext = false;

                        for (let i = 0; i < jsonText.length; i++) {
                            const char = jsonText[i];

                            if (escapeNext) {
                                sanitized += char;
                                escapeNext = false;
                                continue;
                            }

                            if (char === '\\') {
                                sanitized += char;
                                escapeNext = true;
                                continue;
                            }

                            if (char === '"') {
                                sanitized += char;
                                inString = !inString;
                                continue;
                            }

                            // If we're inside a string value, escape control characters
                            if (inString) {
                                if (char === '\n') {
                                    sanitized += '\\n';
                                } else if (char === '\r') {
                                    sanitized += '\\r';
                                } else if (char === '\t') {
                                    sanitized += '\\t';
                                } else if (char.charCodeAt(0) < 32) {
                                    sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                                } else {
                                    sanitized += char;
                                }
                            } else {
                                sanitized += char;
                            }
                        }

                        jsonText = sanitized;
                        console.log(`âœ… [Deep] Chunk ${chunkIndex + 1}: JSON sanitized successfully`);
                        parsed = JSON.parse(jsonText);
                    }

                    // Aggregate results from this chunk
                    if (!projectName && parsed.projectName) {
                        projectName = parsed.projectName;
                        console.log(`ðŸ“ [Deep] Project name extracted from chunk ${chunkIndex + 1}: ${projectName}`);
                    }

                    if (parsed.phases && parsed.phases.length > 0) {
                        console.log(`âœ… [Deep] Chunk ${chunkIndex + 1}: Extracted ${parsed.phases.length} phases with comprehensive detail`);
                        allPhasesCollected.push(...parsed.phases);
                    }

                } catch (e) {
                    console.error(`âŒ [Deep] Chunk ${chunkIndex + 1} failed to parse:`, e);
                    console.error('Response (first 500 chars):', response.substring(0, 500));
                    // Continue to next chunk instead of failing entirely
                }
            }

            // =========================================================================
            // MERGE DUPLICATE PHASES AND RETURN AGGREGATED RESULT (Deep Mode)
            // =========================================================================
            console.log(`âœ… [Deep] All chunks processed. Total phases collected: ${allPhasesCollected.length}`);

            // Merge phases with the same name
            const phaseMap = new Map();
            allPhasesCollected.forEach(phase => {
                const phaseName = phase.name;
                if (phaseMap.has(phaseName)) {
                    // Merge items into existing phase
                    const existingPhase = phaseMap.get(phaseName);
                    if (phase.items && phase.items.length > 0) {
                        existingPhase.items.push(...phase.items);
                    }
                } else {
                    // Add new phase
                    phaseMap.set(phaseName, { ...phase });
                }
            });

            const mergedPhases = Array.from(phaseMap.values());
            console.log(`âœ… [Deep] After merging duplicates: ${mergedPhases.length} unique phases`);

            // Use a generic project name if none was extracted
            if (!projectName) {
                projectName = `${patternConfig.name} Project`;
            }

            return {
                projectName: projectName,
                phases: mergedPhases
            };
        }

        // OLD SINGLE-CHUNK DEEP MODE (DEPRECATED - keeping for reference)
        async function convertTextToTreeDeep_LEGACY(text, pattern) {
            const response = 'DEPRECATED'; // Legacy function - semantic chunking is now standard

            try {
                // Try to extract JSON from response
                let jsonText = response.trim();

                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                // Find the FIRST complete JSON object using proper brace matching
                const firstBrace = jsonText.indexOf('{');

                if (firstBrace === -1) {
                    throw new Error('No JSON object found in AI response.');
                }

                if (firstBrace > 0) {
                    console.log('ðŸª„ [Deep] Skipping text before JSON:', jsonText.substring(0, firstBrace));
                }

                let depth = 0;
                let endPos = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = firstBrace; i < jsonText.length; i++) {
                    const char = jsonText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }

                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }

                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }

                    if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                endPos = i + 1;
                                break;
                            }
                        }
                    }
                }

                if (endPos === -1) {
                    throw new Error('Incomplete JSON object in AI response (no closing brace found).');
                }

                if (endPos < jsonText.length) {
                    console.log('ðŸª„ [Deep] Skipping text after JSON:', jsonText.substring(endPos, Math.min(endPos + 100, jsonText.length)));
                }

                jsonText = jsonText.substring(firstBrace, endPos);

                console.log('ðŸª„ [Deep] Extracted JSON length:', jsonText.length);

                // Sanitize JSON: Fix control characters in string values (same as wizard)
                let parsed;
                try {
                    parsed = JSON.parse(jsonText);
                } catch (firstError) {
                    console.warn('ðŸª„ [Deep] JSON parse failed, attempting sanitization...', firstError.message);

                    let sanitized = '';
                    let inString = false;
                    let escapeNext = false;

                    for (let i = 0; i < jsonText.length; i++) {
                        const char = jsonText[i];

                        if (escapeNext) {
                            sanitized += char;
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\') {
                            sanitized += char;
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            sanitized += char;
                            inString = !inString;
                            continue;
                        }

                        // If we're inside a string value, escape control characters
                        if (inString) {
                            if (char === '\n') {
                                sanitized += '\\n';
                            } else if (char === '\r') {
                                sanitized += '\\r';
                            } else if (char === '\t') {
                                sanitized += '\\t';
                            } else if (char.charCodeAt(0) < 32) {
                                sanitized += '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
                            } else {
                                sanitized += char;
                            }
                        } else {
                            sanitized += char;
                        }
                    }

                    jsonText = sanitized;
                    console.log('âœ… [Deep] JSON sanitized successfully');
                    parsed = JSON.parse(jsonText);
                }

                return parsed;
            } catch (e) {
                console.error('Failed to parse deep conversion response:', e);
                console.error('AI Response (first 1000 chars):', response.substring(0, 1000));
                console.error('Extracted JSON (first 1000 chars):', jsonText.substring(0, 1000));

                // Try to show the problematic area if we have position info
                const posMatch = e.message.match(/position (\d+)/);
                if (posMatch) {
                    const errorPos = parseInt(posMatch[1]);
                    const contextStart = Math.max(0, errorPos - 200);
                    const contextEnd = Math.min(jsonText.length, errorPos + 200);
                    console.error(`JSON around error position ${errorPos}:`, jsonText.substring(contextStart, contextEnd));
                }

                // Auto-heal: Ask Claude to fix the malformed JSON
                console.log('ðŸ”§ Attempting to auto-fix malformed JSON...');
                try {
                    const fixPrompt = `The following JSON is malformed and caused this error: ${e.message}

Fix this JSON to make it valid. Return ONLY the fixed JSON, nothing else:

${jsonText}`;

                    const fixedResponse = await callClaudeAPI(fixPrompt, 'You are a JSON repair expert. Fix malformed JSON to make it valid.', 4096);

                    let fixedJson = fixedResponse.trim();
                    fixedJson = fixedJson.replace(/```json\s*/g, '').replace(/```\s*/g, '');

                    const firstBrace = fixedJson.indexOf('{');
                    const lastBrace = fixedJson.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1) {
                        fixedJson = fixedJson.substring(firstBrace, lastBrace + 1);
                    }

                    console.log('âœ… JSON auto-fixed successfully');
                    return JSON.parse(fixedJson);
                } catch (fixError) {
                    console.error('âŒ Auto-fix failed:', fixError);
                    throw new Error(`Failed to convert text to tree structure. JSON parsing error: ${e.message}`);
                }
            }
        }

        // Main Analyze button handler
        document.getElementById('analysis-start-btn').addEventListener('click', async () => {
            // Get text from file or textarea
            const textFromTextarea = document.getElementById('analysis-text-input').value.trim();
            let finalText = analysisText || textFromTextarea;

            if (!finalText) {
                alert('Please upload a file or paste text to analyze.');
                return;
            }

            // Get global AI mode
            const mode = getGlobalAIMode();

            // Check if AI is disabled
            if (mode === 'off') {
                alert('âŒ AI features are currently disabled.\n\nPlease enable AI mode in the header (ðŸ¤– AI Mode dropdown) to use text analysis.');
                return;
            }

            // Auto-truncate very long texts to prevent timeouts
            // Different limits for Quick vs Deep Mode
            const MAX_CHARS_QUICK = 100000; // ~25,000 words for Quick Mode
            const MAX_CHARS_DEEP = 300000;  // ~75,000 words for Deep Mode (with user API key, no timeout)
            const MAX_CHARS = mode === 'deep' ? MAX_CHARS_DEEP : MAX_CHARS_QUICK;

            let wasTruncated = false;
            if (finalText.length > MAX_CHARS) {
                wasTruncated = true;
                finalText = finalText.substring(0, MAX_CHARS);
                console.warn(`âš ï¸ Text truncated from ${analysisText.length} to ${MAX_CHARS} characters for ${mode} mode`);
            }

            // Check if Deep Mode requires user's own API key
            if (mode === 'deep') {
                const userApiKey = getLocalAPIKey();
                if (!userApiKey) {
                    alert('ðŸ”¬ Deep Mode requires your own Anthropic API key.\n\nWhy?\nâ€¢ Deep Mode uses more tokens and takes longer\nâ€¢ Prevents timeout on Netlify free tier (10s limit)\nâ€¢ You only pay for what you use\n\nPlease:\n1. Click the ðŸ”‘ API Key button\n2. Enter your Anthropic API key\n3. Try Deep Mode again\n\nQuick Mode is available without an API key.');
                    return;
                }
                console.log('âœ… Deep Mode: Using your API key (bypasses rate limits and timeouts)');
            }

            // Warn if text was truncated
            if (wasTruncated) {
                const proceed = confirm(`âš ï¸ Your text is very long and has been automatically truncated to ${MAX_CHARS} characters (~${Math.floor(MAX_CHARS/4)} words) to prevent timeouts.\n\nOnly the first portion will be analyzed.\n\nDo you want to continue?`);
                if (!proceed) {
                    return;
                }
            }

            // BUILD 353: Launch Smart Import Wizard for text analysis
            const textAnalysis = analyzeTextContent(finalText, analysisFileName || 'Pasted Text');

            // Close analysis modal before showing wizard
            document.getElementById('analysis-modal').style.display = 'none';

            // BUILD 354: Pass original text for multi-tree slice detection
            showSmartImportWizard(textAnalysis, analysisAppendMode, async (userAnswers) => {
                // After wizard completes, proceed with the actual analysis
                // BUILD 354: Handle multi-tree mode
                if (userAnswers.multiTreeMode && userAnswers.multiTreeContexts) {
                    await proceedWithMultiTreeTextAnalysis(finalText, mode, userAnswers.multiTreeContexts);
                } else {
                    await proceedWithTextAnalysis(finalText, mode, analysisAppendMode);
                }
            }, { text: finalText });
        });

        // BUILD 353: Extracted analysis logic to separate function for wizard callback
        async function proceedWithTextAnalysis(finalText, mode, appendMode) {
            // Close any modal and show loading modal
            document.getElementById('modal').style.display = 'none';
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = 'ðŸ” Analyzing Text...';
            modal.style.display = 'flex';

            // Check if user pre-selected a specific pattern
            const preSelectedPattern = document.getElementById('analysis-pattern-select').value;

            try {
                let selectedPattern;

                // If user chose a specific pattern, skip detection and use that pattern directly
                if (preSelectedPattern && preSelectedPattern !== 'auto') {
                    selectedPattern = preSelectedPattern;
                    console.log(`âœ… Using pre-selected pattern: ${selectedPattern}`);

                    // Step 2: Convert text to tree (skip pattern detection)
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 1/2: Converting text to tree structure...</p>';

                    let treeData;
                    if (mode === 'quick') {
                        treeData = await convertTextToTreeQuick(finalText, selectedPattern);
                    } else {
                        treeData = await convertTextToTreeDeep(finalText, selectedPattern);
                    }

                    // BUILD 355: Verification pass
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 2/2: Verifying structure...</p>';
                    treeData = await verifyAndFixTreeData(treeData, selectedPattern, finalText);

                    // Step 3: Preview and import
                    showAnalysisPreview(treeData, selectedPattern, analysisAppendMode);
                    return; // Exit early - we're done!
                }

                // Otherwise, proceed with auto-detection
                modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 1/3: Detecting optimal pattern...</p>';

                // Step 1: Detect pattern
                const recommendations = await detectPattern(finalText);

                // Show pattern selection
                modalBody.innerHTML = `
                    <div style="padding: 20px;">
                        <h3 style="margin-bottom: 16px; color: var(--text-primary);">ðŸ“Š Recommended Patterns</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px; font-size: 14px;">
                            AI analyzed your text and recommends these patterns. Select one to continue:
                        </p>
                        <div id="pattern-recommendations" style="display: flex; flex-direction: column; gap: 12px;">
                            ${recommendations.map((rec, index) => `
                                <label style="display: flex; align-items: flex-start; padding: 16px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s; background: var(--card-bg);" class="pattern-rec-option" data-pattern="${rec.pattern}">
                                    <input type="radio" name="selected-pattern" value="${rec.pattern}" ${index === 0 ? 'checked' : ''} style="margin-top: 4px; margin-right: 12px;" />
                                    <div style="flex: 1;">
                                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                            <span style="font-weight: 600; color: var(--text-primary); font-size: 15px;">${rec.patternName}</span>
                                            <span style="background: ${rec.confidence >= 8 ? '#4caf50' : rec.confidence >= 6 ? '#ff9f43' : '#666'}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">
                                                ${rec.confidence}/10 confidence
                                            </span>
                                        </div>
                                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                            ${rec.reasoning}
                                        </div>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                        <div style="margin-top: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">
                                Analysis Mode: ${mode === 'quick' ? 'âš¡ Quick Mode' : 'ðŸ”¬ Deep Mode'}
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary);">
                                ${mode === 'quick' ? 'Fast analysis with basic structure extraction.' : 'Detailed analysis with field extraction and dependencies.'}
                            </div>
                        </div>
                    </div>
                `;

                // Add hover effects to pattern options
                document.querySelectorAll('.pattern-rec-option').forEach(option => {
                    option.addEventListener('mouseenter', () => {
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                    option.addEventListener('mouseleave', () => {
                        const radio = option.querySelector('input[type="radio"]');
                        if (!radio.checked) {
                            option.style.borderColor = 'var(--border)';
                            option.style.background = 'var(--card-bg)';
                        }
                    });
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.pattern-rec-option').forEach(opt => {
                            opt.style.borderColor = 'var(--border)';
                            opt.style.background = 'var(--card-bg)';
                        });
                        option.style.borderColor = 'var(--treeplex-primary)';
                        option.style.background = 'rgba(99, 102, 241, 0.05)';
                    });
                });

                // Update modal footer with continue button
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="pattern-select-cancel">Cancel</button>
                    <button class="btn btn-primary" id="pattern-select-continue" style="background: linear-gradient(135deg, #6366f1, #8b5cf6);">Continue â†’</button>
                `;

                document.getElementById('pattern-select-cancel').addEventListener('click', () => {
                    modal.style.display = 'none';
                });

                document.getElementById('pattern-select-continue').addEventListener('click', async () => {
                    const selectedPattern = document.querySelector('input[name="selected-pattern"]:checked').value;

                    // Step 2: Convert text to tree
                    modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 2/3: Converting text to tree structure...</p>';
                    document.querySelector('#modal .modal-footer').innerHTML = '';

                    try {
                        let treeData;
                        if (mode === 'quick') {
                            treeData = await convertTextToTreeQuick(finalText, selectedPattern);
                        } else {
                            treeData = await convertTextToTreeDeep(finalText, selectedPattern);
                        }

                        // BUILD 355: Verification pass
                        modalBody.innerHTML = '<div class="spinner"></div><p style="text-align: center; margin-top: 16px; color: var(--text-secondary);">Step 3/3: Verifying structure...</p>';
                        treeData = await verifyAndFixTreeData(treeData, selectedPattern, finalText);

                        // Step 4: Preview and import
                        showAnalysisPreview(treeData, selectedPattern, analysisAppendMode);

                    } catch (error) {
                        modalBody.innerHTML = `
                            <div style="padding: 20px; text-align: center;">
                                <div style="font-size: 48px; margin-bottom: 16px;">âŒ</div>
                                <h3 style="color: #f44336; margin-bottom: 12px;">Analysis Failed</h3>
                                <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                            </div>
                        `;
                        document.querySelector('#modal .modal-footer').innerHTML = `
                            <button class="btn" id="error-close">Close</button>
                            <button class="btn btn-primary" id="error-retry">Try Again</button>
                        `;

                        document.getElementById('error-close').addEventListener('click', () => {
                            modal.style.display = 'none';
                        });

                        document.getElementById('error-retry').addEventListener('click', () => {
                            modal.style.display = 'none';
                            document.getElementById('analyze-text-btn').click();
                        });
                    }
                });

            } catch (error) {
                modalBody.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">âŒ</div>
                        <h3 style="color: #f44336; margin-bottom: 12px;">Pattern Detection Failed</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">${error.message}</p>
                    </div>
                `;
                document.querySelector('#modal .modal-footer').innerHTML = `
                    <button class="btn" id="error-close">Close</button>
                `;

                document.getElementById('error-close').addEventListener('click', () => {
                    modal.style.display = 'none';
                });
            }
        }

        // Show preview before importing
        function showAnalysisPreview(treeData, selectedPattern, appendMode = false) {
            const modal = document.getElementById('modal');
            const modalBody = document.getElementById('modal-body');

            document.getElementById('modal-title').textContent = 'âœ… Analysis Complete - Preview';

            // Count phases and items
            const phaseCount = treeData.phases?.length || 0;
            const itemCount = treeData.phases?.reduce((sum, phase) => sum + (phase.items?.length || 0), 0) || 0;

            // BUILD 321: Check for transcript analysis data
            const hasTranscriptData = treeData.extractedContacts?.length > 0 ||
                                      treeData.researchRequests?.length > 0 ||
                                      treeData.itemUpdates?.length > 0;

            // BUILD 321: Generate transcript analysis section HTML
            let transcriptSection = '';
            if (hasTranscriptData) {
                transcriptSection = `
                    <div style="margin-top: 20px; border: 2px solid #6366f1; border-radius: 8px; overflow: hidden;">
                        <div style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; padding: 12px 16px; font-weight: 600;">
                            ðŸ“‹ Transcript Analysis
                        </div>
                        <div style="padding: 16px; background: var(--bg-secondary);">
                            ${treeData.extractedContacts?.length > 0 ? `
                                <div style="margin-bottom: 16px;">
                                    <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                        <span style="background: #10b981; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">${treeData.extractedContacts.length}</span>
                                        ðŸ“‡ Contacts Detected
                                    </div>
                                    <div style="font-size: 13px; color: var(--text-secondary); margin-left: 8px;">
                                        ${treeData.extractedContacts.slice(0, 4).map(c => `â€¢ <strong>${c.name}</strong>${c.role ? ` (${c.role})` : ''}${c.company ? ` - ${c.company}` : ''}`).join('<br>')}
                                        ${treeData.extractedContacts.length > 4 ? `<br><em>... and ${treeData.extractedContacts.length - 4} more</em>` : ''}
                                    </div>
                                </div>
                            ` : ''}
                            ${treeData.researchRequests?.length > 0 ? `
                                <div style="margin-bottom: 16px;">
                                    <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                        <span style="background: #f59e0b; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">${treeData.researchRequests.length}</span>
                                        ðŸ” Research Requests
                                    </div>
                                    <div style="font-size: 13px; color: var(--text-secondary); margin-left: 8px;">
                                        ${treeData.researchRequests.map(r => `â€¢ <strong>${r.topic}</strong>${r.priority === 'high' ? ' <span style="color: #ef4444; font-size: 11px;">HIGH</span>' : ''}`).join('<br>')}
                                    </div>
                                </div>
                            ` : ''}
                            ${treeData.itemUpdates?.length > 0 ? `
                                <div>
                                    <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                        <span style="background: #3b82f6; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">${treeData.itemUpdates.length}</span>
                                        ðŸ“ Item Updates
                                    </div>
                                    <div style="font-size: 13px; color: var(--text-secondary); margin-left: 8px;">
                                        ${treeData.itemUpdates.slice(0, 3).map(u => `â€¢ <strong>${u.itemName}</strong>: ${u.field} â†’ ${u.newValue}`).join('<br>')}
                                        ${treeData.itemUpdates.length > 3 ? `<br><em>... and ${treeData.itemUpdates.length - 3} more</em>` : ''}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, #4caf50, #00a67d); color: white; padding: 20px; border-radius: 12px; margin-bottom: 24px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 8px;">âœ¨</div>
                        <h2 style="margin-bottom: 8px; font-size: 24px;">${treeData.projectName || 'Analyzed Project'}</h2>
                        <p style="opacity: 0.9; font-size: 14px;">Pattern: ${PATTERNS[selectedPattern].name}${hasTranscriptData ? ' â€¢ ðŸ“‹ Transcript Mode' : ''}</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 24px;">
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${phaseCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Phases Detected</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 16px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 32px; font-weight: 700; color: var(--treeplex-primary); margin-bottom: 4px;">${itemCount}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">Items Created</div>
                        </div>
                    </div>

                    <div style="max-height: ${hasTranscriptData ? '200px' : '300px'}; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; padding: 16px; background: var(--bg-secondary);">
                        <h4 style="margin-bottom: 12px; color: var(--text-primary);">Structure Preview:</h4>
                        ${treeData.phases?.map((phase, i) => `
                            <div style="margin-bottom: 16px;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 6px;">
                                    ${phase.icon || 'ðŸ“‹'} ${phase.name}
                                </div>
                                <div style="margin-left: 20px; font-size: 13px; color: var(--text-secondary);">
                                    ${phase.items?.slice(0, 3).map(item => `â€¢ ${item.name}`).join('<br>')}
                                    ${phase.items?.length > 3 ? `<br>... and ${phase.items.length - 3} more items` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    ${transcriptSection}

                    <div style="margin-top: 20px; padding: 12px 16px; background: rgba(${appendMode ? '76, 175, 80' : '255, 159, 67'}, 0.1); border: 1px solid rgba(${appendMode ? '76, 175, 80' : '255, 159, 67'}, 0.3); border-radius: 6px;">
                        <div style="color: ${appendMode ? '#4caf50' : '#ff9f43'}; font-weight: 600; margin-bottom: 4px;">${appendMode ? 'âž• Append Mode' : 'âš ï¸ Replace Mode'}</div>
                        <div style="color: var(--text-secondary); font-size: 13px;">
                            ${appendMode ?
                                'This will add the analyzed content to your existing tree. Phases will be merged or added.' :
                                'Importing will replace your current project. Your current project will be saved as a backup first.'}
                        </div>
                    </div>
                </div>
            `;

            // Create buttons directly with event listeners attached
            const modalFooter = document.querySelector('#modal .modal-footer');
            if (!modalFooter) {
                console.error('âŒ Modal footer not found!');
                alert('Error: Modal footer not found. Please refresh the page.');
                return;
            }

            // Clear existing content
            modalFooter.innerHTML = '';

            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => {
                console.log('ðŸš« Import cancelled');
                modal.style.display = 'none';
            };

            // Create import button
            const importBtn = document.createElement('button');
            importBtn.className = 'btn btn-primary';
            importBtn.style.cssText = 'background: linear-gradient(135deg, #4caf50, #00a67d);';
            importBtn.textContent = appendMode ? 'âž• Append to Tree' : 'ðŸ“¥ Import to TreeListy';
            importBtn.onclick = () => {
                console.log('ðŸ”„ Import button clicked!', { hasTreeData: !!treeData, hasPattern: !!selectedPattern, appendMode });
                try {
                    importAnalyzedTree(treeData, selectedPattern, appendMode);
                    modal.style.display = 'none';
                } catch (error) {
                    console.error('âŒ Import failed:', error);
                    alert('Import failed: ' + error.message);
                }
            };

            // Add buttons to footer
            modalFooter.appendChild(cancelBtn);
            modalFooter.appendChild(importBtn);

            console.log('âœ… Preview modal ready with import button');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 319: SEMANTIC DEDUPLICATION FOR APPEND MODE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Calculate semantic similarity between two items
         * Uses word overlap with TF-IDF-like weighting
         * @returns {number} Similarity score 0-1
         */
        function calculateItemSimilarity(existingItem, newItem) {
            // Combine name and description for comparison
            const existingText = `${existingItem.name || ''} ${existingItem.description || ''}`.toLowerCase();
            const newText = `${newItem.name || ''} ${newItem.description || ''}`.toLowerCase();

            // Tokenize and remove stopwords
            const stopwords = new Set(['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
                'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might',
                'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by', 'from', 'as', 'into', 'through', 'during',
                'and', 'or', 'but', 'if', 'then', 'else', 'when', 'where', 'why', 'how', 'all', 'each', 'every',
                'this', 'that', 'these', 'those', 'it', 'its', 'they', 'them', 'their', 'we', 'us', 'our']);

            const tokenize = (text) => text.split(/\W+/).filter(w => w.length > 2 && !stopwords.has(w));

            const existingTokens = new Set(tokenize(existingText));
            const newTokens = new Set(tokenize(newText));

            if (existingTokens.size === 0 || newTokens.size === 0) return 0;

            // Calculate Jaccard similarity
            const intersection = [...newTokens].filter(t => existingTokens.has(t)).length;
            const union = new Set([...existingTokens, ...newTokens]).size;

            return union > 0 ? intersection / union : 0;
        }

        /**
         * Find semantic duplicates in existing items
         * @param {Array} existingItems - Items already in the tree
         * @param {Object} newItem - New item to check
         * @param {number} threshold - Similarity threshold (default 0.6)
         * @returns {Object|null} Matching item if found, null otherwise
         */
        function findSemanticDuplicate(existingItems, newItem, threshold = 0.6) {
            if (!existingItems || existingItems.length === 0) return null;

            let bestMatch = null;
            let bestScore = 0;

            for (const existing of existingItems) {
                const similarity = calculateItemSimilarity(existing, newItem);
                if (similarity > threshold && similarity > bestScore) {
                    bestMatch = existing;
                    bestScore = similarity;
                }
            }

            if (bestMatch) {
                console.log(`ðŸ” Semantic match found: "${newItem.name}" â‰ˆ "${bestMatch.name}" (${(bestScore * 100).toFixed(0)}% similar)`);
            }

            return bestMatch;
        }

        /**
         * Merge new item data into existing item (update, don't duplicate)
         * @param {Object} existing - Existing item to update
         * @param {Object} incoming - New item with potential updates
         */
        function mergeItemUpdates(existing, incoming) {
            // Update description if incoming has more content
            if (incoming.description && incoming.description.length > (existing.description?.length || 0)) {
                existing.description = incoming.description;
            }

            // Merge subtasks/children
            if (incoming.children && incoming.children.length > 0) {
                existing.children = existing.children || [];
                for (const newChild of incoming.children) {
                    const duplicate = findSemanticDuplicate(existing.children, newChild, 0.7);
                    if (!duplicate) {
                        // Add new subtask with proper ID
                        const newId = `subtask-${existing.id}-${existing.children.length}`;
                        existing.children.push({ ...newChild, id: newId });
                    }
                }
            }

            // Update numeric fields if incoming has values
            if (incoming.cost && incoming.cost > 0) existing.cost = incoming.cost;
            if (incoming.dealValue && incoming.dealValue > 0) existing.dealValue = incoming.dealValue;
            if (incoming.storyPoints && incoming.storyPoints > 0) existing.storyPoints = incoming.storyPoints;

            // Mark as updated
            existing.provenance = {
                ...existing.provenance,
                lastUpdated: new Date().toISOString(),
                updateSource: 'append-merge'
            };

            console.log(`âœï¸ Updated existing item: ${existing.name}`);
        }

        // Import analyzed tree into TreeListy
        function importAnalyzedTree(treeData, selectedPattern, appendMode = false) {
            console.log('ðŸ“¥ Starting import...', { treeData, selectedPattern, appendMode });

            // Save state for undo
            saveState(appendMode ? 'Analyze Text: Append' : 'Analyze Text: Import');

            // Backup current project first
            const backup = JSON.stringify(capexTree, null, 2);
            const backupName = `treelisty_backup_${Date.now()}.json`;
            console.log('ðŸ’¾ Current project backed up as:', backupName);

            // Switch to selected pattern (only if not appending)
            if (!appendMode) {
                currentPattern = selectedPattern;
                document.getElementById('pattern-select').value = selectedPattern;
            }

            // Convert analyzed data to TreeListy format
            const newTree = {
                type: 'root',
                id: 'root',
                name: treeData.projectName || 'Analyzed Project',
                icon: 'ðŸŒ²',
                expanded: true,
                hyperedges: [], // Initialize empty hyperedges array to prevent data loss
                children: treeData.phases?.map((phase, phaseIndex) => ({
                    type: 'phase',
                    id: `phase-${phaseIndex}`,
                    phase: phaseIndex,
                    name: phase.name,
                    subtitle: phase.subtitle || PATTERNS[selectedPattern].phaseSubtitles?.[phaseIndex] || '',
                    icon: phase.icon || 'ðŸ“‹',
                    expanded: true,
                    cost: 0,
                    provenance: {
                        source: 'ai-import',
                        timestamp: new Date().toISOString(),
                        modelId: null
                    },
                    items: phase.items?.map((item, itemIndex) => {
                        const itemId = `item-${phaseIndex}-${itemIndex}`;

                        // Build item object with all required fields
                        const itemObj = {
                            type: 'item',
                            id: itemId,
                            name: item.name,
                            description: item.description || '',
                            itemType: item.itemType || '',
                            icon: item.icon || 'ðŸ“„',
                            cost: item.cost || 0,
                            dependencies: item.dependencies || [],
                            notes: item.notes || '',
                            leadTime: item.leadTime || '',
                            alternateSource: item.alternateSource || '',
                            expanded: false,
                            // Pattern-specific fields
                            dealValue: item.dealValue || 0,
                            wordCount: item.wordCount || 0,
                            storyPoints: item.storyPoints || 0,
                            // Provenance stamping (Cognitive Citadel)
                            provenance: {
                                source: 'ai-import',
                                timestamp: new Date().toISOString(),
                                modelId: null
                            },
                            // Add any other fields from AI
                            ...item
                        };

                        // Add subtasks if they exist (3rd level hierarchy)
                        if (item.subtasks && item.subtasks.length > 0) {
                            itemObj.children = item.subtasks.map((subtask, subtaskIndex) => ({
                                type: 'subtask',
                                id: `subtask-${phaseIndex}-${itemIndex}-${subtaskIndex}`,
                                name: subtask.name || subtask,
                                description: subtask.description || '',
                                icon: subtask.icon || 'ðŸ“Œ',
                                notes: subtask.notes || '',
                                dependencies: subtask.dependencies || [],
                                // Provenance stamping (Cognitive Citadel)
                                provenance: {
                                    source: 'ai-import',
                                    timestamp: new Date().toISOString(),
                                    modelId: null
                                },
                                // Pattern-specific fields
                                ...subtask
                            }));
                        }

                        return itemObj;
                    }) || []
                })) || []
            };

            if (appendMode) {
                // Append mode: merge phases and items
                console.log('âž• Append mode: merging trees...');

                // Keep existing project name if different
                if (capexTree.name !== newTree.name && capexTree.name !== 'My Project') {
                    // User has a custom name, keep it
                } else {
                    capexTree.name = newTree.name;
                }

                // BUILD 319: Track deduplication stats across all phases
                let totalAdded = 0;
                let totalUpdated = 0;
                let newPhasesAdded = 0;

                // Merge phases
                newTree.children.forEach((newPhase, newPhaseIndex) => {
                    // Find matching phase in existing tree by index or name
                    const existingPhase = capexTree.children?.[newPhaseIndex];

                    if (existingPhase) {
                        // Phase exists - append items to it
                        console.log(`Appending ${newPhase.items?.length || 0} items to existing phase: ${existingPhase.name}`);

                        // Update phase name if it was generic
                        if (existingPhase.name === `Phase ${newPhaseIndex}` && newPhase.name !== `Phase ${newPhaseIndex}`) {
                            existingPhase.name = newPhase.name;
                        }

                        // BUILD 319: Semantic deduplication for append mode
                        // Instead of blindly appending, check for duplicates and merge updates
                        if (newPhase.items && newPhase.items.length > 0) {
                            let addedCount = 0;
                            let updatedCount = 0;

                            for (const newItem of newPhase.items) {
                                // Check for semantic duplicate
                                const duplicate = findSemanticDuplicate(existingPhase.items, newItem, 0.6);

                                if (duplicate) {
                                    // Merge updates into existing item
                                    mergeItemUpdates(duplicate, newItem);
                                    updatedCount++;
                                    totalUpdated++;
                                } else {
                                    // Truly new item - add with proper ID
                                    const currentItemCount = existingPhase.items?.length || 0;
                                    const newId = `item-${newPhaseIndex}-${currentItemCount}`;
                                    const reIdedItem = { ...newItem, id: newId };

                                    existingPhase.items = existingPhase.items || [];
                                    existingPhase.items.push(reIdedItem);
                                    addedCount++;
                                    totalAdded++;
                                }
                            }

                            console.log(`ðŸ“Š Phase "${existingPhase.name}": ${addedCount} added, ${updatedCount} updated`);
                        }
                    } else {
                        // Phase doesn't exist - add it as new
                        console.log(`Adding new phase: ${newPhase.name}`);
                        if (!capexTree.children) capexTree.children = [];

                        // Re-ID the phase
                        newPhase.id = `phase-${capexTree.children.length}`;
                        newPhase.phase = capexTree.children.length;

                        capexTree.children.push(newPhase);
                        newPhasesAdded++;
                        totalAdded += newPhase.items?.length || 0;
                    }
                });

                // BUILD 321: Store transcript analysis data in tree metadata
                if (treeData.extractedContacts?.length > 0) {
                    capexTree.extractedContacts = capexTree.extractedContacts || [];
                    capexTree.extractedContacts.push(...treeData.extractedContacts);
                    console.log(`ðŸ“‡ Stored ${treeData.extractedContacts.length} contacts in tree metadata`);
                }
                if (treeData.researchRequests?.length > 0) {
                    capexTree.researchRequests = capexTree.researchRequests || [];
                    capexTree.researchRequests.push(...treeData.researchRequests);
                    console.log(`ðŸ” Stored ${treeData.researchRequests.length} research requests in tree metadata`);
                }

                // Show success message for append with deduplication stats
                let message = 'âœ… Smart Append Complete!\n\n';
                if (totalAdded > 0) {
                    message += `ðŸ“ ${totalAdded} new items added\n`;
                }
                if (totalUpdated > 0) {
                    message += `ðŸ”„ ${totalUpdated} existing items updated (duplicates merged)\n`;
                }
                if (newPhasesAdded > 0) {
                    message += `ðŸ“ ${newPhasesAdded} new phases created\n`;
                }
                // BUILD 321: Add transcript analysis summary to message
                if (treeData.extractedContacts?.length > 0) {
                    message += `ðŸ“‡ ${treeData.extractedContacts.length} contacts detected\n`;
                }
                if (treeData.researchRequests?.length > 0) {
                    message += `ðŸ” ${treeData.researchRequests.length} research requests captured\n`;
                }
                if (totalAdded === 0 && totalUpdated === 0 && !treeData.extractedContacts?.length && !treeData.researchRequests?.length) {
                    message += 'No new content to add - all items already exist in your tree.';
                }

                alert(message);

            } else {
                // Replace mode: completely replace tree
                console.log('ðŸ”„ Replace mode: replacing tree...');
                capexTree = newTree;

                // Show success message for replace
                const totalItems = treeData.phases?.reduce((sum, p) => sum + (p.items?.length || 0), 0) || 0;
                const totalSubtasks = treeData.phases?.reduce((sum, p) =>
                    sum + (p.items?.reduce((subSum, item) => subSum + (item.subtasks?.length || 0), 0) || 0), 0) || 0;

                let message = `âœ… Successfully imported!\n\n${treeData.phases?.length || 0} phases and ${totalItems} items`;
                if (totalSubtasks > 0) {
                    message += ` and ${totalSubtasks} subtasks`;
                }
                message += ` have been created.\n\nPattern: ${PATTERNS[selectedPattern].name}`;
                alert(message);
            }

            // Render
            render();

            // Auto-select first item to show detail panel
            // Find the first item in the tree
            let firstItem = null;
            if (capexTree.children && capexTree.children.length > 0) {
                for (const phase of capexTree.children) {
                    if (phase.items && phase.items.length > 0) {
                        firstItem = phase.items[0];
                        break;
                    }
                }
            }

            // Show detail panel for first item if found
            if (firstItem) {
                console.log('ðŸ“‹ Auto-selecting first item for detail panel:', firstItem.name);
                showInfo(firstItem);
            }
        }

        // How to Use button
        document.getElementById('how-to-btn').addEventListener('click', () => {
            const modal = document.getElementById('modal');
            document.getElementById('modal-title').textContent = 'ðŸ“– How to Use TreeListy';
            document.getElementById('modal-body').innerHTML = `
                <div style="padding: 20px; line-height: 1.8;">
                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">ðŸ’¡ What is TreeListy?</h3>
                    <p style="margin-bottom: 20px; font-size: 14px;">
                        <strong>TreeListy</strong> is a universal tool for breaking down any complex project, problem, or process into manageable parts.
                        Structure your work into phases, track dependencies between components, and analyze your entire plan at a glance.
                        Use it for software projects, sales pipelines, academic writing, product roadmaps, AI prompt design, or anything else that benefits from structured thinking! ðŸŒ³âœ¨ðŸŽ¯
                    </p>

                    <h3 style="color: var(--phase-1); margin-bottom: 16px; font-size: 20px;">ðŸš€ Quick Start</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-1);">
                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>1. Choose Your Pattern</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ Use the Pattern dropdown (top) to select your project type:</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">ðŸ“‹ Generic Project, ðŸ’¼ Sales Pipeline, ðŸŽ“ Academic Writing, ðŸš€ Product Roadmap</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">ðŸ“š Book Writing, ðŸ§  AI Prompt Design, ðŸ›ï¸ Philosophy, ðŸ’¡ Strategic Planning</p>
                        <p style="font-size: 12px; margin-bottom: 4px; padding-left: 16px;">ðŸŽ¬ Film Production, ðŸ“§ Email Workflow <em>(NEW!)</em>, ðŸ’¾ File System</p>
                        <p style="font-size: 12px; margin-bottom: 12px; padding-left: 16px;">...and more! (19 specialized patterns total)</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>2. Build Your Tree (3 Ways)</strong></p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">ðŸ§™ AI Wizard (Easiest!)</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Click "ðŸ§™ AI Wizard" button in toolbar</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Describe your project in plain language</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ AI asks strategic questions and builds your tree</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">â€¢ Works for new trees or enhancing existing ones!</p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">ðŸ“„ Analyze Text</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Click "ðŸ“„ Analyze Text" button</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Paste any document (plans, specs, articles)</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Choose Quick Mode (fast) or Deep Mode (thorough)</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">â€¢ Can append to existing trees or replace completely</p>

                        <p style="font-size: 13px; margin-bottom: 8px; font-weight: 600;">âœ‹ Manual Creation</p>
                        <p style="font-size: 13px; margin-bottom: 4px; padding-left: 16px;">â€¢ Right-click on any Phase â†’ "Add Item"</p>
                        <p style="font-size: 13px; margin-bottom: 12px; padding-left: 16px;">â€¢ Fill in fields manually with full control</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>3. Use Smart Features</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>AI Review ðŸ”¬</strong> - Click "ðŸ”¬ AI Review" for comprehensive tree analysis</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Smart Suggest ðŸ’¡</strong> - Right-click any field â†’ Choose "âœ¨ AI Suggest" or "ðŸ’¡ Quick Suggest"</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Dependencies</strong> - Edit an item â†’ Check boxes in Dependencies section</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>AI Analysis ðŸ¤–</strong> - Click any item â†’ "AI Analysis" for insights</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Undo</strong> - Click "â†©ï¸ Undo" or press Ctrl+Z (Cmd+Z on Mac)</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>4. Navigate & View</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Expand/Collapse</strong> - Click "â¬‡ï¸ Expand" or "â¬†ï¸ Collapse" buttons</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Click nodes</strong> to expand/collapse individually or view details</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Pan/Zoom</strong> - Use mouse wheel or pan controls</p>

                        <p style="font-size: 14px; margin-bottom: 12px;"><strong>5. Export & Share</strong></p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ðŸ“ Generate Prompt</strong> - Export as AI-ready prompt (for Claude, GPT, etc.)</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ðŸ“Š Export Excel</strong> - Professional multi-sheet workbook</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ðŸ“¥ Import Excel</strong> - Import Excel files back into TreeListy</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>ðŸ’¾ Save/Load</strong> - Save as JSON and reload anytime</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>ðŸ”— Share</strong> - Generate shareable URL</p>
                    </div>

                    <h3 style="color: var(--phase-2); margin-bottom: 16px; font-size: 20px;">ðŸ¤– AI-Powered Features</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-2);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ§™ AI Wizard</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Interactive project building</strong> - AI asks strategic questions<br>
                            â€¢ <strong>Conversational interface</strong> - Just describe what you need<br>
                            â€¢ <strong>Enhance mode</strong> - Add to existing trees without starting over<br>
                            â€¢ <strong>Real-time preview</strong> - Watch your tree build in the side panel<br>
                            â€¢ <strong>Smart Merge protection</strong> - Never loses your existing data<br>
                            â€¢ <strong>Auto-recovery</strong> - Handles errors gracefully
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ“„ Analyze Text + ðŸ§  Semantic Chunking (NEW!)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>ðŸ§  Semantic Chunking</strong> - Auto-segments large documents (5000+ words) using NLP<br>
                            â€¢ <strong>Prevents Hallucinations</strong> - Processes chunks independently instead of all at once<br>
                            â€¢ <strong>Visual Feedback</strong> - Shows chunk distribution with bar chart during analysis<br>
                            â€¢ <strong>Embedding-Based</strong> - Uses OpenAI/Gemini embeddings to detect semantic boundaries<br>
                            â€¢ <strong>Auto-Fallback</strong> - Structural parser (Markdown â†’ paragraphs) if no embedding API<br>
                            â€¢ <strong>Quick Mode</strong> - Fast analysis (1500 tokens per chunk) for straightforward documents<br>
                            â€¢ <strong>Deep Mode</strong> - Extended thinking (8192 tokens per chunk) for complex analysis<br>
                            â€¢ <strong>Append Mode</strong> - Combine multiple document analyses<br>
                            â€¢ <strong>Pattern-specific extraction</strong> - Philosophy extracts premises, Sales extracts deals, etc.<br>
                            â€¢ <strong>Prompt improvement</strong> - AI Prompt pattern turns basic prompts into comprehensive ones
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ”¬ AI Review & Enhance</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Comprehensive tree analysis</strong> - Reviews entire tree for completeness, logic, and flow<br>
                            â€¢ <strong>Pattern-aware review</strong> - Checks alignment with pattern best practices<br>
                            â€¢ <strong>Actionable suggestions</strong> - Get specific recommendations for improvements<br>
                            â€¢ <strong>Gap identification</strong> - Finds missing phases, items, or subtasks<br>
                            â€¢ <strong>Quality assessment</strong> - Identifies redundancies and structural issues
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ’¡ Smart Suggest (Dual Modes)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>âœ¨ AI Suggest</strong> - Context-aware suggestions with pattern expertise (Philosophy prof, Sales strategist, etc.)<br>
                            â€¢ <strong>ðŸ’¡ Quick Suggest</strong> - Instant static templates for common fields<br>
                            â€¢ <strong>Pattern intelligence</strong> - Philosophy gets premises/objections, Sales gets follow-ups, Film gets Sora/Veo prompts<br>
                            â€¢ <strong>Right-click any field</strong> - Choose your mode and watch AI fill in intelligent suggestions<br>
                            â€¢ <strong>Fallback protection</strong> - Auto-switches to Quick mode if AI fails
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ“ Generate Prompt</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Export as AI prompt</strong> - Use with Claude, GPT-4, or any LLM<br>
                            â€¢ <strong>Pattern-aware formatting</strong> - Adapts to your project type<br>
                            â€¢ <strong>Executable prompts</strong> - AI Prompt pattern creates paste-ready prompts (not meta-docs)<br>
                            â€¢ <strong>Copy to clipboard</strong> - One-click copy for easy sharing<br>
                            â€¢ <strong>Complete context</strong> - Includes all phases, items, and subtasks
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ¤– AI Analysis (Per Item)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Risk assessments</strong> - Identify potential issues<br>
                            â€¢ <strong>Cost optimization</strong> - Compare with similar items<br>
                            â€¢ <strong>Strategic insights</strong> - Powered by your chosen AI model<br>
                            â€¢ <strong>Pattern-specific analysis</strong> - Tailored to your project type
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŒ² TreeBeard Chat (AI Assistant)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Context-aware assistant</strong> - Click ðŸŒ² button in sidebar<br>
                            â€¢ <strong>Wiser mode</strong> - Toggle for full tree context in responses<br>
                            â€¢ <strong>Ask anything</strong> - Questions about your tree, pattern guidance, analysis<br>
                            â€¢ <strong>Quick actions</strong> - Get suggestions, explore related concepts
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ“Ž Smart Append & Deduplication</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Meeting transcripts</strong> - Auto-detect transcript format, extract contacts/research<br>
                            â€¢ <strong>Semantic deduplication</strong> - 60% Jaccard threshold prevents duplicates<br>
                            â€¢ <strong>Smart merge</strong> - Additive updates only, never loses your data<br>
                            â€¢ <strong>Multi-document append</strong> - Build trees from multiple sources
                        </p>
                    </div>

                    <h3 style="color: var(--phase-1); margin-bottom: 16px; font-size: 20px;">ðŸ”‘ AI Providers & API Keys</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-1);">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy supports multiple AI providers!</strong> Choose the model that fits your needs.
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ¤– Available Providers</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Anthropic Claude</strong> - Haiku 3/3.5 (fast, cheap) & Sonnet 4 (powerful, extended thinking)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Google Gemini</strong> - Flash 2.0 (fast) & Pro 2.5 (thorough)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>OpenAI ChatGPT</strong> - GPT-4o mini (fast) & GPT-4o (powerful)</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ” API Key Setup</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Click <strong>ðŸ”‘ Set API Key</strong> button in header</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Enter your API key from Anthropic, Google, or OpenAI</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Keys are stored in <strong>localStorage</strong> (persist across sessions)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ Get keys at: console.anthropic.com, aistudio.google.com, or platform.openai.com</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">âš¡ Rate Limits & Costs</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Server API key (default)</strong> - 200 requests/hour, 8192 max tokens per request</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Your API key</strong> - Unlimited requests (you pay for usage)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Extended Thinking</strong> - Deep Mode uses 5000 token thinking budget + response (Sonnet 4 only)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Tip</strong> - Use your own key to bypass rate limits and get faster responses</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ§  Extended Thinking Mode</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Available when using <strong>Sonnet 4</strong> in <strong>Deep Mode</strong><br>
                            â€¢ AI thinks for up to 5000 tokens before responding<br>
                            â€¢ Better reasoning, fewer errors, more comprehensive analysis<br>
                            â€¢ Ideal for complex trees, AI Review, and prompt improvement<br>
                            â€¢ Costs more but delivers significantly higher quality
                        </p>
                    </div>

                    <h3 style="color: var(--phase-3); margin-bottom: 16px; font-size: 20px;">ðŸ“Š Presentations & Sharing</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--phase-3);">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy is perfect for investor meetings and stakeholder presentations!</strong>
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ¯ Visual Impact</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Use "â¬‡ï¸ Expand" button to show complete roadmap<br>
                            â€¢ Dependency arrows show critical path in real-time<br>
                            â€¢ Phase colors guide audience through timeline<br>
                            â€¢ Click individual nodes to drill down into details
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ“Š Excel Import & Export</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Export:</strong> Professional 4-sheet workbook (Executive Summary, Details, Dependencies, PM Tracking)<br>
                            â€¢ <strong>Import:</strong> Load Excel files back into TreeListy - edit in Excel, import changes<br>
                            â€¢ <strong>Append Mode:</strong> Import multiple Excel files into one tree<br>
                            â€¢ <strong>Pattern Detection:</strong> Automatically detects project type from Excel structure<br>
                            â€¢ Perfect for board meetings, investor due diligence, and team collaboration
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ’¼ Pattern-Based Presentations</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Sales Pipeline</strong> - Show deal flow and revenue forecast<br>
                            â€¢ <strong>Product Roadmap</strong> - Display feature timeline and engineering estimates<br>
                            â€¢ <strong>AI Prompt Design</strong> - Present prompt engineering workflows<br>
                            â€¢ <strong>Strategic Planning</strong> - Show KPIs and strategic initiatives
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ¤ Pro Tips</p>
                        <p style="font-size: 13px; margin-bottom: 8px; font-style: italic; color: var(--treeplex-primary);">
                            â€¢ <strong>Excel Workflow:</strong> Export â†’ Edit in Excel with team â†’ Import back to TreeListy<br>
                            â€¢ Use AI Wizard before meetings to quickly build comprehensive plans<br>
                            â€¢ Generate Prompt to share project structure with AI assistants<br>
                            â€¢ Import multiple Excel files using Append Mode to combine analyses<br>
                            â€¢ Use Undo (Ctrl+Z) to safely experiment during live demos
                        </p>
                    </div>

                    <h3 style="color: #10b981; margin-bottom: 16px; font-size: 20px;">ðŸ‘¥ Collaboration ("Chess by Mail")</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid #10b981;">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>Collaborate with others asynchronously or in real-time!</strong> Perfect for team projects, debates, or teaching.
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ’¬ Collaboration Comments</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Edit any node â†’ Find "Collaboration" section<br>
                            â€¢ Leave notes for collaborators (e.g., "@Alex - what do you think?")<br>
                            â€¢ ðŸ’¬ icon appears on nodes with comments<br>
                            â€¢ Hover to preview the comment
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ‘¤ Contributor Tags</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Tag who made each edit (click team member badge or type custom name)<br>
                            â€¢ Quick-select buttons for common collaborators<br>
                            â€¢ ðŸ‘¤ badge shows on nodes in Tree and Canvas views<br>
                            â€¢ Timestamps automatically tracked
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ‘ï¸ Watch Mode (Live Sync)</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Click "ðŸ‘ï¸ Watch Mode" in sidebar<br>
                            â€¢ Enter your name and select a shared file<br>
                            â€¢ Choose poll interval (5s for active collab, 30s for async)<br>
                            â€¢ See changes from collaborators automatically!<br>
                            â€¢ Your saves are detected and won't reload
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">â˜ï¸ Google Drive Links</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Save tree to Google Drive â†’ Get shareable link<br>
                            â€¢ Email: <code>https://treelisty.netlify.app?gdrive=FILE_ID</code><br>
                            â€¢ Recipient clicks â†’ TreeListy opens with your tree!<br>
                            â€¢ Use <code>?watch=URL</code> to auto-open Watch Mode
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ”„ Async Workflow</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            1. Save to shared folder (OneDrive, Google Drive, Dropbox)<br>
                            2. Email the link to your collaborator<br>
                            3. They edit, set their contributor name, save<br>
                            4. You reload â†’ see their badges and comments<br>
                            5. Like chess by mail, but for ideas!
                        </p>
                    </div>

                    <h3 style="color: var(--treeplex-primary); margin-bottom: 16px; font-size: 20px;">âŒ¨ï¸ Keyboard Shortcuts & Tips</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid var(--treeplex-primary);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Keyboard Shortcuts</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Ctrl+Z / Cmd+Z</strong> - Undo last action (keeps 50 states in history)<br>
                            â€¢ <strong>Ctrl+/ / Cmd+/</strong> - Toggle TreeBeard chat panel<br>
                            â€¢ Works everywhere except when typing in text fields
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Navigation</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ <strong>Click nodes</strong> to expand/collapse or view details<br>
                            â€¢ <strong>Right-click anywhere</strong> for context menus<br>
                            â€¢ <strong>â¬‡ï¸ Expand / â¬†ï¸ Collapse buttons</strong> - Control all phases at once<br>
                            â€¢ <strong>Mouse wheel</strong> - Zoom in/out<br>
                            â€¢ <strong>Pan controls</strong> - Navigate large trees
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">Visual Cues</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">
                            â€¢ <strong>Indented items</strong> - Depend on items above them<br>
                            â€¢ <strong>Dependency arrows</strong> - Show cross-phase relationships<br>
                            â€¢ <strong>Phase colors</strong> - Guide through timeline (green â†’ blue â†’ orange â†’ purple)<br>
                            â€¢ <strong>Hover effects</strong> - 3D pop effects on items<br>
                            â€¢ <strong>Green pulse</strong> - Newly added nodes (during Chat Builder)<br>
                            â€¢ <strong>Yellow pulse</strong> - Modified nodes (during Chat Builder)
                        </p>
                    </div>

                    <h3 style="color: #f59e0b; margin-bottom: 16px; font-size: 20px;">ðŸ–±ï¸ View Controls (Tree, Canvas, 3D)</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid #f59e0b;">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>TreeListy has three views:</strong> Tree View (hierarchical list), Canvas View (node diagram), and 3D View (spatial navigator). Each has different mouse controls!
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŒ² Tree View (Default)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Left Click</strong> - Expand/collapse node, or select to view details</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Right Click</strong> - Context menu (Add, Edit, Delete, AI options)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Mouse Wheel</strong> - Scroll up/down through the tree</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Drag & Drop</strong> - Not supported (use Edit to move items)</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ¨ Canvas View (Diagram)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Left Click</strong> - Select node (shows details in right panel)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Left Drag on Node</strong> - Move the node around the canvas</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Right Click</strong> - Context menu (Edit, Share Branch, AI Analysis)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Mouse Wheel</strong> - Zoom in/out</p>
                            <p style="font-size: 13px; margin-bottom: 4px; color: #f59e0b;"><strong>â­ Space + Drag</strong> - Pan the entire canvas (Mac-friendly!)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Middle Mouse + Drag</strong> - Pan (alternative for mice with scroll wheel click)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Ctrl/Cmd + Click</strong> - Multi-select nodes</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Left Drag on Empty Space</strong> - Box select multiple nodes</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŒ 3D View (Spatial Navigator)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Left Drag</strong> - Orbit/rotate the view</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Mouse Wheel</strong> - Zoom in/out</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Right Drag</strong> - Pan the camera</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Hover Nodes</strong> - Highlight and see labels</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Click Node</strong> - Select and view details</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ”„ Switching Views</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">
                            â€¢ Click the <strong>view toggle buttons</strong> (ðŸŒ²/ðŸŽ¨/ðŸŒ) in the toolbar<br>
                            â€¢ <strong>Tree</strong> - Best for detailed editing and reading<br>
                            â€¢ <strong>Canvas</strong> - Best for seeing relationships and node diagrams<br>
                            â€¢ <strong>3D</strong> - Best for exploring large trees spatially
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ’¡ Canvas Tips</p>
                        <p style="font-size: 13px; margin-bottom: 12px; font-style: italic; color: #f59e0b;">
                            â€¢ <strong>No middle mouse?</strong> Hold <strong>Space</strong> + drag to pan (like Photoshop/Figma!)<br>
                            â€¢ <strong>Lost on a big canvas?</strong> Click "Fit" button to see all nodes<br>
                            â€¢ <strong>Create hyperedges:</strong> Select multiple nodes â†’ Click "Edges" â†’ Name your connection
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ”— Smart Hyperedges (NEW!)</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Auto-Suggestions</strong> - Open Hyperedges panel to see suggested groupings</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Query Builder</strong> - Click ðŸ” Query to create hyperedges by filter</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Live Aggregates</strong> - See totals ($2.3M â€¢ 67% â€¢ 4 nodes) on each hyperedge</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>TreeBeard Queries</strong> - Ask "show items over $500K" to find matches</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Pattern-Aware</strong> - CAPEX shows cost tiers, Philosophy shows philosophers</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ Mac Users & Trackpads</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 0;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Cmd</strong> works everywhere <strong>Ctrl</strong> is mentioned (Cmd+Z undo, Cmd+Click multi-select)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Space + Drag</strong> - Pan canvas without a middle mouse button</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Two-finger scroll</strong> - Zoom in/out on canvas</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Two-finger tap</strong> - Right-click context menu</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Pinch gesture</strong> - Works for zoom in Canvas and 3D views</p>
                        </div>
                    </div>

                    <h3 style="color: #f97316; margin-bottom: 16px; font-size: 20px;">ðŸ”¥ Firebase Live Sync + Voice Chat</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid #f97316;">
                        <p style="font-size: 14px; margin-bottom: 12px;">
                            <strong>Real-time collaboration</strong> - Multiple users can edit the same tree simultaneously!
                        </p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸš€ How to Start</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">1. Click the <strong>ðŸ”„ Live Sync</strong> button (orange, in toolbar)</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">2. Click <strong>"Create Live Sync Room"</strong> to start a session</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">3. Share the <strong>6-character Room ID</strong> with collaborators</p>
                            <p style="font-size: 13px; margin-bottom: 0;">4. They enter the Room ID and click <strong>"Join"</strong></p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">âœ¨ Features</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>No sign-in required</strong> - Anonymous authentication</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Instant sync</strong> - All changes sync immediately</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Delete sync</strong> - Deletions sync to all collaborators instantly</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Nested subtasks</strong> - Full support for deeply nested structures</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ <strong>Auto-save</strong> - Synced changes are saved to localStorage</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ™ï¸ Voice Chat</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Click the <strong>ðŸŽ™ï¸ Voice</strong> button in the chat panel</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ Opens <strong>Jitsi Meet</strong> in a popup window</p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>No account required</strong> - just click and talk!</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ Hands-free collaboration while building your tree</p>
                        </div>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ‘¥ Presence & Chat</p>
                        <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ See who's online with <strong>presence badges</strong></p>
                            <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Floating chat box</strong> - draggable, minimizable</p>
                            <p style="font-size: 13px; margin-bottom: 0;">â€¢ Real-time messaging during collaboration</p>
                        </div>

                        <p style="font-size: 13px; font-style: italic; color: #f97316;">
                            ðŸ’¡ Tip: Works alongside Google Drive sharing for async collaboration!
                        </p>
                    </div>

                    <h3 style="color: var(--phase-4); margin-bottom: 16px; font-size: 20px;">ðŸ”§ Advanced Features</h3>
                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; border-left: 3px solid var(--phase-4);">
                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ­ Pattern System (19 Built-in + Custom)</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Generic Project</strong> - Universal template for any project</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Sales Pipeline</strong> - Deals, contacts, follow-ups, close dates</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Academic Writing</strong> - Thesis, arguments, citations, evidence</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Product Roadmap</strong> - Features, story points, user impact, technical specs</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Book Writing</strong> - Chapters, scenes, character arcs, plot points</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Event Planning</strong> - Budget, vendors, deadlines, guest counts</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Fitness Program</strong> - Sets, reps, intensity, form cues</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Strategic Plan</strong> - Pillars, initiatives, KPIs, risk levels</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Course Design</strong> - Modules, lessons, activities, assessments</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Film/Video Production</strong> - Sora/Veo prompts, camera angles, lighting</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Philosophy</strong> - Arguments, premises, objections, textual references</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Prompt Engineering</strong> - System prompts, few-shot examples, chain-of-thought</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Family Tree</strong> - Genealogy, birth/death dates, DNA info</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Dialogue & Rhetoric</strong> - Rhetorical devices, fallacies, counterarguments</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>File System</strong> - Files, folders, sizes, dates, permissions</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Email Workflow</strong> - Gmail threads, recipients, labels, analysis</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Free Speech</strong> - Constitutional analysis, legal precedent, public interest</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸ›¡ï¸ Smart Merge Data Protection</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Never loses your data</strong> - AI updates preserve all existing content</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Fuzzy name matching</strong> - Finds related items even if names differ slightly</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Additive updates only</strong> - AI can add or update, but never deletes</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Transparent logging</strong> - Console shows exactly what was merged, added, or preserved</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Safe experimentation</strong> - Try AI features without fear of data loss</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">ðŸŽ¯ Pattern-Specific AI Behavior</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">Each pattern has specialized AI intelligence:</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Philosophy</strong> - AI suggests premises, objections, supporting evidence, textual citations</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Sales</strong> - AI suggests follow-up actions, next steps, competitive positioning, deal strategies</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Film</strong> - AI generates production-ready Sora/Veo prompts with camera angles, lighting, blocking</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>AI Prompt</strong> - AI transforms basic prompts into comprehensive prompts with system/user/examples</p>
                        <p style="font-size: 13px; margin-bottom: 4px;">â€¢ <strong>Roadmap</strong> - AI suggests implementation tasks, technical specs, acceptance criteria, story points</p>
                        <p style="font-size: 13px; margin-bottom: 12px;">â€¢ <strong>Book</strong> - AI suggests scenes, character moments, plot developments, narrative arcs</p>

                        <p style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">âš™ï¸ Other Advanced Features</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Dependencies</strong> - Track relationships between items across phases with visual arrows</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>PM Tracking</strong> - Status, assignees, dates, progress, priorities, blocking issues</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Context Notes</strong> - Add project background for better AI suggestions and team alignment</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Shareable URLs</strong> - Compress and share entire projects via URL (base64 encoding)</p>
                        <p style="font-size: 13px; margin-bottom: 8px;">â€¢ <strong>Auto-save</strong> - Your work is preserved in browser localStorage automatically</p>
                        <p style="font-size: 13px;">â€¢ <strong>Custom Patterns</strong> - Create your own pattern with custom fields, labels, and hierarchies</p>
                    </div>

                    <div style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, rgba(0, 166, 125, 0.1), rgba(59, 143, 204, 0.1)); border-radius: 8px; text-align: center;">
                        <p style="font-size: 14px; font-weight: 600; color: var(--treeplex-primary); margin-bottom: 8px;">
                            ðŸš€ Ready to build something amazing?
                        </p>
                        <p style="font-size: 13px; opacity: 0.9; margin-bottom: 12px;">
                            Start with the AI Wizard for instant guidance, or choose a pattern and dive in!
                        </p>
                        <p style="font-size: 12px; opacity: 0.7;">
                            ðŸ§™ Pro tip: Try "ðŸ§™ AI Wizard" â†’ describe your project â†’ watch the magic happen
                        </p>
                    </div>

                    <!-- BUILD 358: Check for Updates button -->
                    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 12px; opacity: 0.6;">
                            v${window.TREELISTY_VERSION?.major || '2.17.0'} â€¢ Build ${window.TREELISTY_VERSION?.build || '???'}
                        </span>
                        <button onclick="window.checkForUpdates(); this.textContent='Checking...'; this.disabled=true; setTimeout(() => { this.textContent='ðŸ”„ Check for Updates'; this.disabled=false; }, 3000);" style="
                            padding: 8px 16px;
                            background: var(--bg);
                            border: 1px solid var(--border);
                            border-radius: 6px;
                            color: var(--text-primary);
                            font-size: 12px;
                            cursor: pointer;
                            transition: all 0.2s;
                        " onmouseover="this.style.background='var(--treeplex-primary)'; this.style.color='white';" onmouseout="this.style.background='var(--bg)'; this.style.color='var(--text-primary)';">
                            ðŸ”„ Check for Updates
                        </button>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
        });

        // =============================================================================
        // EXCEL EXPORT - Professional Multi-Sheet Workbook for Investors
        // =============================================================================

        function exportToExcel() {
            // Create a new workbook
            const wb = XLSX.utils.book_new();

            // Collect all items AND subtasks from the tree (proper phase structure)
            const allItems = [];
            const allTasks = []; // Subtasks for separate PM sheet (recursive)

            // RECURSIVE function to collect nested subtasks from multiple data shapes
            function collectSubtasks(parentItem, parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel = 0) {
                const subtaskCandidates = [];
                const seenIds = new Set();

                if (Array.isArray(parentItem.subItems) && parentItem.subItems.length > 0) {
                    parentItem.subItems.forEach((subtask, index) => {
                        const id = subtask.id || `${parentItem.id || 'item'}-sub-${index}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            subtaskCandidates.push({ ...subtask, id });
                        }
                    });
                }

                if (Array.isArray(parentItem.children) && parentItem.children.length > 0) {
                    parentItem.children
                        .filter(child => child.type === 'subtask')
                        .forEach((child, index) => {
                            const id = child.id || `${parentItem.id || 'item'}-child-${index}`;
                            if (!seenIds.has(id)) {
                                seenIds.add(id);
                                subtaskCandidates.push({ ...child, id });
                            }
                        });
                }

                if (Array.isArray(parentItem.subtasks) && parentItem.subtasks.length > 0) {
                    parentItem.subtasks.forEach((entry, index) => {
                        const normalized = typeof entry === 'string'
                            ? { name: entry }
                            : { ...entry };
                        const id = normalized.id || `${parentItem.id || 'item'}-simple-${index}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            subtaskCandidates.push({
                                type: normalized.type || 'subtask',
                                ...normalized,
                                id
                            });
                        }
                    });
                }

                if (subtaskCandidates.length === 0) {
                    return;
                }

                subtaskCandidates.forEach(subtask => {
                    const indent = '  '.repeat(nestLevel); // Indentation for hierarchy
                    allTasks.push({
                        ...subtask,
                        parentItem: parentName,
                        parentItemId: parentItem.id,
                        phaseName: phaseName,
                        phaseSubtitle: phaseSubtitle,
                        phaseNumber: phaseNumber,
                        nestLevel: nestLevel,
                        taskName: indent + (subtask.name || 'Subtask')
                    });

                    // RECURSIVELY collect nested subtasks
                    collectSubtasks(subtask, subtask.name || parentName, phaseName, phaseSubtitle, phaseNumber, nestLevel + 1);
                });
            }

            function collectItems(node) {
                // Collect items from this phase node
                if (node.items && Array.isArray(node.items)) {
                    node.items.forEach(item => {
                        allItems.push({
                            ...item,
                            phaseName: node.name || 'Unknown Phase',
                            phaseSubtitle: node.subtitle || '',
                            phaseNumber: node.phase || '0'
                        });

                        // Collect subtasks recursively for PM tracking
                        collectSubtasks(item, item.name, node.name || 'Unknown Phase', node.subtitle || '', node.phase || '0', 0);
                    });
                }

                // Recursively collect from child phases
                if (node.children && Array.isArray(node.children)) {
                    node.children.forEach(child => {
                        collectItems(child);
                    });
                }
            }
            collectItems(capexTree);

            // Calculate totals
            const totalCost = allItems.reduce((sum, item) => sum + (item.cost || 0), 0);

            // Group by phase dynamically
            const phaseBreakdown = {};
            allItems.forEach(item => {
                const phaseKey = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;
                if (!phaseBreakdown[phaseKey]) {
                    phaseBreakdown[phaseKey] = { total: 0, count: 0, phaseNumber: item.phaseNumber };
                }
                phaseBreakdown[phaseKey].total += (item.cost || 0);
                phaseBreakdown[phaseKey].count++;
            });

            // =================================================================
            // SHEET 1: EXECUTIVE SUMMARY
            // =================================================================
            const resolvePatternName = () => {
                if (capexTree.pattern) {
                    const patternKey = getPatternKey(capexTree.pattern);
                    if (patternKey) {
                        if (patternKey === 'custom') {
                            const labels = capexTree.pattern.labels || {};
                            return labels.root ? `Custom (${labels.root})` : 'Custom Pattern';
                        }
                        if (PATTERNS[patternKey]) {
                            return PATTERNS[patternKey].name;
                        }
                    }
                }
                if (PATTERNS[currentPattern]) {
                    return PATTERNS[currentPattern].name;
                }
                return 'Generic Project';
            };

            const patternNameForSummary = resolvePatternName();

            const summaryData = [
                ['TREEPLEXITY - PROJECT SUMMARY'],
                ['by geej', '', '', ''],
                [],
                ['Project:', capexTree.name || 'Project Plan'],
                ['Pattern:', patternNameForSummary],
                ['Total Cost:', `$${(totalCost / 1000000).toFixed(2)}M`],
                ['Items Count:', allItems.length],
                ['Report Date:', new Date().toLocaleDateString()],
                [],
                ['INVESTMENT BREAKDOWN BY PHASE'],
                [],
                ['Phase', 'Investment', 'Percentage', 'Items']
            ];

            // Add phase rows dynamically (sorted by phase number)
            Object.entries(phaseBreakdown)
                .sort((a, b) => (a[1].phaseNumber || 0) - (b[1].phaseNumber || 0))
                .forEach(([phaseName, data]) => {
                    const phasePercentage = totalCost > 0 ? `${((data.total / totalCost) * 100).toFixed(1)}%` : '0%';
                    summaryData.push([
                        phaseName,
                        `$${(data.total / 1000000).toFixed(2)}M`,
                        phasePercentage,
                        data.count
                    ]);
                });

            // Add total row
            summaryData.push(['TOTAL', `$${(totalCost / 1000000).toFixed(2)}M`, totalCost > 0 ? '100.0%' : '0%', allItems.length]);

            // Add key metrics
            summaryData.push([]);
            summaryData.push(['KEY METRICS']);
            summaryData.push([]);
            summaryData.push(['Metric', 'Value']);
            summaryData.push(['Average Item Cost', allItems.length > 0 ? `$${(totalCost / allItems.length / 1000).toFixed(0)}K` : '$0']);
            summaryData.push(['Largest Single Item', allItems.length > 0 ? `$${(Math.max(...allItems.map(i => i.cost || 0)) / 1000000).toFixed(2)}M` : '$0']);
            summaryData.push(['Items with Dependencies', allItems.filter(i => i.dependencies && i.dependencies.length > 0).length]);
            summaryData.push(['Items with Alternate Sources', allItems.filter(i => i.alternateSource).length]);

            const ws_summary = XLSX.utils.aoa_to_sheet(summaryData);

            // Set column widths
            ws_summary['!cols'] = [
                { wch: 30 },  // Column A
                { wch: 20 },  // Column B
                { wch: 15 },  // Column C
                { wch: 15 }   // Column D
            ];

            // Add to workbook
            XLSX.utils.book_append_sheet(wb, ws_summary, 'ðŸ“Š Executive Summary');

            // =================================================================
            // SHEET 2: DETAILED ITEMS (PATTERN-AWARE)
            // =================================================================

            // Get current pattern for dynamic columns
            const currentPatternDef = PATTERNS[currentPattern];
            const patternFields = currentPatternDef.fields || {};

            // Build dynamic column headers
            const baseColumns = ['Item Name', 'Phase', 'Type', 'Description'];
            const patternColumns = [];
            const patternFieldKeys = []; // Track field keys for data extraction

            // Add all pattern-specific fields dynamically
            Object.keys(patternFields).forEach(fieldKey => {
                const fieldConfig = patternFields[fieldKey];
                // Skip non-field properties
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }
                if (fieldConfig.label) {
                    patternColumns.push(fieldConfig.label);
                    patternFieldKeys.push(fieldKey);
                }
            });

            const endColumns = ['Dependencies', 'Notes'];
            const allColumns = [...baseColumns, ...patternColumns, ...endColumns];

            // Build column widths dynamically
            const columnWidths = [
                { wch: 30 },  // Item Name
                { wch: 25 },  // Phase
                { wch: 20 },  // Type
                { wch: 40 }   // Description
            ];

            // Add widths for pattern columns
            patternColumns.forEach(col => {
                // Determine width based on field type
                if (col.includes('Date')) {
                    columnWidths.push({ wch: 12 });
                } else if (col.includes('$') || col.includes('Cost') || col.includes('Value')) {
                    columnWidths.push({ wch: 15 });
                } else if (col.includes('%') || col.includes('Points')) {
                    columnWidths.push({ wch: 10 });
                } else if (col.length > 20) {
                    columnWidths.push({ wch: 35 }); // Long labels get more space
                } else {
                    columnWidths.push({ wch: 20 }); // Default width
                }
            });

            columnWidths.push({ wch: 30 }); // Dependencies
            columnWidths.push({ wch: 40 }); // Notes

            const itemsData = [
                [`DETAILED PROJECT ITEMS - ${currentPatternDef.name}`],
                [],
                allColumns
            ];

            // Add item rows with dynamic pattern fields
            allItems.forEach(item => {
                const phaseDisplay = `${item.phaseName}${item.phaseSubtitle ? ' (' + item.phaseSubtitle + ')' : ''}`;

                const rowData = [
                    item.name || '',
                    phaseDisplay,
                    item.itemType || '',
                    item.description || ''
                ];

                // Add pattern-specific field values
                patternFieldKeys.forEach(fieldKey => {
                    const fieldConfig = patternFields[fieldKey];
                    let value = item[fieldKey];

                    if (value === undefined || value === null || value === '') {
                        rowData.push('');
                        return;
                    }

                    // Format based on field type
                    if (fieldConfig.type === 'number') {
                        // Special handling for cost (convert to millions)
                        if (fieldKey === 'cost' && fieldConfig.label.includes('($M)')) {
                            value = (value / 1000000).toFixed(2);
                        } else if (fieldKey === 'dealValue') {
                            value = (value / 1000).toFixed(0); // Thousands
                        } else {
                            value = value.toString();
                        }
                    } else if (fieldConfig.type === 'date') {
                        value = value; // Keep as-is (Excel will format)
                    } else if (fieldConfig.type === 'textarea') {
                        value = value.replace(/\n/g, ' '); // Remove newlines for Excel
                    }

                    rowData.push(value);
                });

                // Add dependencies and notes
                rowData.push((item.dependencies || []).length > 0 ? item.dependencies.join(', ') : 'None');
                rowData.push(item.notes || '');

                itemsData.push(rowData);
            });

            // Add total row (only for patterns with cost field)
            itemsData.push([]);
            if (patternFields.cost || patternFields.dealValue) {
                const totalRow = ['TOTAL', '', '', ''];

                // Find the cost column index
                const costFieldKey = patternFields.cost ? 'cost' : 'dealValue';
                const costIndex = patternFieldKeys.indexOf(costFieldKey);

                // Fill blanks up to cost column
                for (let i = 0; i < patternFieldKeys.length; i++) {
                    if (i === costIndex) {
                        if (costFieldKey === 'cost') {
                            totalRow.push((totalCost / 1000000).toFixed(2));
                        } else {
                            // Sum dealValue for sales pipeline
                            const totalDealValue = allItems.reduce((sum, item) => sum + (item.dealValue || 0), 0);
                            totalRow.push((totalDealValue / 1000).toFixed(0));
                        }
                    } else {
                        totalRow.push('');
                    }
                }

                totalRow.push('', ''); // Dependencies, Notes
                itemsData.push(totalRow);
            }

            const ws_items = XLSX.utils.aoa_to_sheet(itemsData);
            ws_items['!cols'] = columnWidths;

            XLSX.utils.book_append_sheet(wb, ws_items, 'ðŸ“‹ Detailed Items');

            // =================================================================
            // SHEET 3: DEPENDENCIES MATRIX
            // =================================================================
            const depsData = [
                ['DEPENDENCY MATRIX'],
                [],
                ['Item', 'Depends On', 'Count', 'Critical Path?']
            ];

            allItems.forEach(item => {
                if (item.dependencies && item.dependencies.length > 0) {
                    depsData.push([
                        item.name || '',
                        item.dependencies.join(', '),
                        item.dependencies.length,
                        item.dependencies.length > 2 ? 'Yes' : 'No'
                    ]);
                }
            });

            if (depsData.length === 3) {
                depsData.push(['No dependencies defined yet', '', '', '']);
            }

            const ws_deps = XLSX.utils.aoa_to_sheet(depsData);

            ws_deps['!cols'] = [
                { wch: 35 },
                { wch: 50 },
                { wch: 10 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_deps, 'ðŸ”— Dependencies');

            // =================================================================
            // SHEET 4: COST ANALYSIS BY TYPE
            // =================================================================
            const typeBreakdown = {};
            allItems.forEach(item => {
                const type = item.itemType || 'Uncategorized';
                if (!typeBreakdown[type]) {
                    typeBreakdown[type] = { count: 0, total: 0 };
                }
                typeBreakdown[type].count++;
                typeBreakdown[type].total += (item.cost || 0);
            });

            const analysisData = [
                ['COST ANALYSIS BY TYPE'],
                [],
                ['Item Type', 'Count', 'Total Cost ($M)', '% of Total', 'Avg Cost ($K)']
            ];

            Object.entries(typeBreakdown)
                .sort((a, b) => b[1].total - a[1].total)
                .forEach(([type, data]) => {
                    analysisData.push([
                        type,
                        data.count,
                        (data.total / 1000000).toFixed(2),
                        ((data.total / totalCost) * 100).toFixed(1) + '%',
                        (data.total / data.count / 1000).toFixed(0)
                    ]);
                });

            analysisData.push([]);
            analysisData.push(['TOTAL', allItems.length, (totalCost / 1000000).toFixed(2), '100.0%', (totalCost / allItems.length / 1000).toFixed(0)]);

            const ws_analysis = XLSX.utils.aoa_to_sheet(analysisData);

            ws_analysis['!cols'] = [
                { wch: 30 },
                { wch: 10 },
                { wch: 18 },
                { wch: 12 },
                { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws_analysis, 'ðŸ“ˆ Cost Analysis');

            // =================================================================
            // SHEET 5: PROJECT TASKS (PM TRACKING)
            // =================================================================
            const tasksData = [
                ['PROJECT TASKS - EXECUTION TRACKING (HIERARCHICAL)'],
                ['Professional Project Management Dashboard', '', '', '', '', '', '', '', '', '', '', ''],
                [],
                ['Task Name', 'Level', 'Parent Item', 'Phase', 'Status', 'Assignee', 'Progress %', 'Priority', 'Start Date', 'Due Date', 'Blocking Issue', 'Next Steps', 'Latest Updates']
            ];

            // Add task rows
            if (allTasks.length > 0) {
                allTasks.forEach(task => {
                    const phaseDisplay = `${task.phaseName}${task.phaseSubtitle ? ' (' + task.phaseSubtitle + ')' : ''}`;

                    // Format updates as timestamped entries
                    let updatesText = '';
                    if (task.pmUpdates && Array.isArray(task.pmUpdates) && task.pmUpdates.length > 0) {
                        updatesText = task.pmUpdates
                            .map(u => `[${new Date(u.timestamp).toLocaleDateString()}] ${u.text}`)
                            .join(' | ');
                    }

                    tasksData.push([
                        task.taskName || task.name || '',  // Use indented taskName for hierarchy
                        task.nestLevel || 0,
                        task.parentItem || '',
                        phaseDisplay,
                        task.pmStatus || 'To Do',
                        task.pmAssignee || 'Unassigned',
                        task.pmProgress || 0,
                        task.pmPriority || 'Medium',
                        task.pmStartDate || '',
                        task.pmDueDate || '',
                        task.pmBlockingIssue || '',
                        task.pmNextSteps || '',
                        updatesText
                    ]);
                });
            } else {
                tasksData.push(['No tasks created yet', '', '', '', '', '', '', '', '', '', '', '', '']);
            }

            // Add summary metrics
            tasksData.push([]);
            tasksData.push(['TASK SUMMARY METRICS']);
            tasksData.push([]);

            const completedTasks = allTasks.filter(t => t.pmStatus === 'Done').length;
            const inProgressTasks = allTasks.filter(t => t.pmStatus === 'In Progress').length;
            const blockedTasks = allTasks.filter(t => t.pmStatus === 'Blocked').length;
            const avgProgress = allTasks.length > 0 ? (allTasks.reduce((sum, t) => sum + (t.pmProgress || 0), 0) / allTasks.length).toFixed(1) : 0;

            tasksData.push(['Total Tasks', allTasks.length]);
            tasksData.push(['Completed', completedTasks, `${allTasks.length > 0 ? ((completedTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['In Progress', inProgressTasks, `${allTasks.length > 0 ? ((inProgressTasks/allTasks.length)*100).toFixed(1) : 0}%`]);
            tasksData.push(['Blocked', blockedTasks, blockedTasks > 0 ? 'âš ï¸ ATTENTION REQUIRED' : '']);
            tasksData.push(['Average Progress', `${avgProgress}%`]);
            tasksData.push([]);
            tasksData.push(['Status Distribution']);

            // Status breakdown
            const statusCounts = {};
            allTasks.forEach(t => {
                const status = t.pmStatus || 'To Do';
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });

            Object.entries(statusCounts)
                .sort((a, b) => b[1] - a[1])
                .forEach(([status, count]) => {
                    tasksData.push([status, count, `${((count/allTasks.length)*100).toFixed(1)}%`]);
                });

            const ws_tasks = XLSX.utils.aoa_to_sheet(tasksData);

            // Set column widths for professional presentation
            ws_tasks['!cols'] = [
                { wch: 40 },  // Task Name (with indentation)
                { wch: 8 },   // Level
                { wch: 30 },  // Parent Item
                { wch: 25 },  // Phase
                { wch: 15 },  // Status
                { wch: 20 },  // Assignee
                { wch: 12 },  // Progress %
                { wch: 12 },  // Priority
                { wch: 15 },  // Start Date
                { wch: 15 },  // Due Date
                { wch: 35 },  // Blocking Issue
                { wch: 40 },  // Next Steps
                { wch: 60 }   // Latest Updates
            ];

            XLSX.utils.book_append_sheet(wb, ws_tasks, 'âœ… Project Tasks');

            // =================================================================
            // GENERATE AND DOWNLOAD FILE
            // =================================================================
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `TreeListy-${timestamp}.xlsx`;

            XLSX.writeFile(wb, filename);

            // Show success message
            alert(`âœ… Excel export successful!\n\nFile: ${filename}\n\nIncludes:\nâ€¢ Executive Summary\nâ€¢ Detailed Items (${allItems.length} items)\nâ€¢ Dependencies Matrix\nâ€¢ Cost Analysis by Type\nâ€¢ Project Tasks (${allTasks.length} tasks with PM tracking)\n\nProfessionally formatted and ready for investor presentations! ðŸ“Š`);
        }

        // Excel Export button handler
        document.getElementById('excel-export-btn').addEventListener('click', exportToExcel);

        // =============================================================================
        // BUILD 353: SMART IMPORT WIZARD
        // Pre-import Q&A for better AI analysis of Excel/Text
        // =============================================================================

        // Smart Import Wizard State
        let smartImportState = {
            active: false,
            contentAnalysis: null,
            userAnswers: {},
            currentStep: 0,
            questions: [],
            appendMode: false,
            sourceType: null, // 'excel' or 'text'
            onComplete: null,  // Callback when wizard completes
            // BUILD 354: Multi-tree output
            multiTreeMode: false,
            selectedSlices: [],
            detectedSlices: [],
            originalData: null  // Store original workbook/text for multi-tree processing
        };

        // Global context that gets prepended to AI prompts
        window.smartImportContext = '';

        // BUILD 354: Multi-tree contexts for generating multiple trees
        window.multiTreeContexts = [];

        // =============================================================================
        // CONTENT ANALYSIS ENGINE (client-side, no AI)
        // =============================================================================

        /**
         * Analyze Excel workbook structure
         */
        function analyzeExcelContent(workbook, fileName) {
            const analysis = {
                sourceType: 'excel',
                fileName: fileName,
                sheets: [],
                relationships: [],
                domain: { detected: 'generic', confidence: 0, keywords: [] },
                financials: { hasCapex: false, hasOpex: false, hasRevenue: false, hasCashflow: false, metrics: [], currencyColumns: [] },
                timeline: { detected: false, range: { start: null, end: null }, granularity: null, milestones: [] },
                validationInfo: { detected: false, stats: { validated: 0, notValidated: 0 } },
                totalRows: 0,
                totalCols: 0
            };

            // Domain keywords for detection
            const domainKeywords = {
                capex: ['capex', 'capital', 'turbine', 'mw', 'megawatt', 'infrastructure', 'construction', 'equipment', 'irr', 'npv', 'payback', 'data center', 'datacenter'],
                philosophy: ['argument', 'premise', 'conclusion', 'dialectic', 'thesis', 'antithesis', 'socratic', 'philosopher', 'epistemology', 'ontology'],
                sales: ['deal', 'pipeline', 'revenue', 'prospect', 'lead', 'close date', 'probability', 'competitor', 'quota', 'commission'],
                legal: ['contract', 'clause', 'party', 'obligation', 'liability', 'indemnity', 'term', 'amendment'],
                technical: ['api', 'database', 'server', 'deployment', 'architecture', 'microservice', 'endpoint', 'integration']
            };

            // Financial keywords
            const financialKeywords = {
                capex: ['capex', 'capital cost', 'capital expenditure', 'equipment cost', 'purchase', 'investment'],
                opex: ['opex', 'operating', 'maintenance', 'wages', 'salary', 'fuel', 'utilities'],
                revenue: ['revenue', 'income', 'sales', 'gross', 'billing'],
                metrics: ['irr', 'npv', 'roi', 'payback', 'margin', 'ebitda']
            };

            // Validation column keywords
            const validationKeywords = ['validated', 'approved', 'confirmed', 'verified', 'status', 'complete', 'done', 'yes/no'];

            // Timeline patterns
            const yearPattern = /\b(20[2-3]\d)\b/g;
            const quarterPattern = /Q[1-4]\s*20[2-3]\d|20[2-3]\d\s*Q[1-4]/gi;

            let allText = '';
            let detectedYears = new Set();
            let detectedMilestones = [];

            // Analyze each sheet
            workbook.SheetNames.forEach((sheetName, sheetIndex) => {
                const sheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                if (data.length === 0) return;

                const sheetInfo = {
                    name: sheetName,
                    index: sheetIndex,
                    rowCount: data.length,
                    colCount: data[0]?.length || 0,
                    headers: [],
                    sampleData: data.slice(0, 5),
                    dataTypes: {},
                    hasValidationColumn: false,
                    validationColIndex: -1,
                    validationStats: { validated: 0, notValidated: 0 },
                    hasCurrencyData: false,
                    hasDateData: false,
                    summary: ''
                };

                analysis.totalRows += data.length;
                analysis.totalCols = Math.max(analysis.totalCols, sheetInfo.colCount);

                // Find headers (first non-empty row with multiple values)
                for (let i = 0; i < Math.min(5, data.length); i++) {
                    const row = data[i];
                    if (row && row.filter(c => c !== null && c !== undefined && c !== '').length >= 2) {
                        sheetInfo.headers = row.map(h => String(h || '').trim());
                        break;
                    }
                }

                // Analyze content
                data.forEach((row, rowIndex) => {
                    if (!row) return;
                    row.forEach((cell, colIndex) => {
                        if (cell === null || cell === undefined) return;
                        const cellStr = String(cell).toLowerCase();
                        allText += ' ' + cellStr;

                        // Detect validation columns
                        if (rowIndex < 3) { // Header area
                            validationKeywords.forEach(kw => {
                                if (cellStr.includes(kw)) {
                                    sheetInfo.hasValidationColumn = true;
                                    sheetInfo.validationColIndex = colIndex;
                                }
                            });
                        }

                        // Count validation values
                        if (sheetInfo.hasValidationColumn && colIndex === sheetInfo.validationColIndex && rowIndex > 0) {
                            if (cellStr === 'yes' || cellStr === 'true' || cellStr === 'done' || cellStr === 'validated' || cellStr === 'approved') {
                                sheetInfo.validationStats.validated++;
                            } else if (cellStr === 'no' || cellStr === 'false' || cellStr === 'pending' || cellStr === 'tbd') {
                                sheetInfo.validationStats.notValidated++;
                            }
                        }

                        // Detect currency (numbers with $ or large numbers)
                        if (typeof cell === 'number' && cell > 10000) {
                            sheetInfo.hasCurrencyData = true;
                        }
                        if (cellStr.includes('$') || cellStr.includes('cost') || cellStr.includes('price')) {
                            sheetInfo.hasCurrencyData = true;
                        }

                        // Detect years and milestones
                        const yearMatches = cellStr.match(yearPattern);
                        if (yearMatches) {
                            yearMatches.forEach(y => detectedYears.add(parseInt(y)));
                        }
                        const quarterMatches = cellStr.match(quarterPattern);
                        if (quarterMatches) {
                            quarterMatches.forEach(q => {
                                if (!detectedMilestones.includes(q)) {
                                    detectedMilestones.push(q);
                                }
                            });
                        }

                        // Detect milestone keywords
                        if (cellStr.includes('milestone') || cellStr.includes('in-service') || cellStr.includes('commission') || cellStr.includes('complete')) {
                            const context = String(cell).substring(0, 100);
                            if (!detectedMilestones.some(m => m.includes(context.substring(0, 20)))) {
                                detectedMilestones.push(context);
                            }
                        }
                    });
                });

                // Generate sheet summary
                const summaryParts = [];
                if (sheetInfo.hasCurrencyData) summaryParts.push('financial data');
                if (sheetInfo.hasValidationColumn) summaryParts.push('validation status');
                if (sheetInfo.hasDateData) summaryParts.push('dates');
                sheetInfo.summary = summaryParts.length > 0 ? summaryParts.join(', ') : 'general data';

                // Aggregate validation stats
                if (sheetInfo.hasValidationColumn) {
                    analysis.validationInfo.detected = true;
                    analysis.validationInfo.stats.validated += sheetInfo.validationStats.validated;
                    analysis.validationInfo.stats.notValidated += sheetInfo.validationStats.notValidated;
                }

                analysis.sheets.push(sheetInfo);
            });

            // Domain detection
            const textLower = allText.toLowerCase();
            let maxScore = 0;
            let detectedDomain = 'generic';
            const foundKeywords = [];

            Object.entries(domainKeywords).forEach(([domain, keywords]) => {
                let score = 0;
                keywords.forEach(kw => {
                    const matches = (textLower.match(new RegExp(kw, 'g')) || []).length;
                    if (matches > 0) {
                        score += matches;
                        if (!foundKeywords.includes(kw) && foundKeywords.length < 8) {
                            foundKeywords.push(kw);
                        }
                    }
                });
                if (score > maxScore) {
                    maxScore = score;
                    detectedDomain = domain;
                }
            });

            analysis.domain = {
                detected: detectedDomain,
                confidence: Math.min(0.95, maxScore / 20),
                keywords: foundKeywords,
                suggestedPattern: detectedDomain === 'capex' ? 'generic' : detectedDomain
            };

            // Financial structure detection
            Object.entries(financialKeywords).forEach(([type, keywords]) => {
                keywords.forEach(kw => {
                    if (textLower.includes(kw)) {
                        if (type === 'capex') analysis.financials.hasCapex = true;
                        if (type === 'opex') analysis.financials.hasOpex = true;
                        if (type === 'revenue') analysis.financials.hasRevenue = true;
                        if (type === 'metrics' && !analysis.financials.metrics.includes(kw.toUpperCase())) {
                            analysis.financials.metrics.push(kw.toUpperCase());
                        }
                    }
                });
            });
            if (textLower.includes('cashflow') || textLower.includes('cash flow')) {
                analysis.financials.hasCashflow = true;
            }

            // Timeline detection
            if (detectedYears.size > 0) {
                const years = Array.from(detectedYears).sort();
                analysis.timeline = {
                    detected: true,
                    range: { start: years[0], end: years[years.length - 1] },
                    granularity: detectedMilestones.length > 4 ? 'quarterly' : 'yearly',
                    milestones: detectedMilestones.slice(0, 10)
                };
            }

            // Detect cross-sheet relationships (simple heuristic: shared keywords in sheet names)
            const sheetKeywords = analysis.sheets.map(s => ({
                name: s.name,
                keywords: s.name.toLowerCase().split(/[\s_-]+/)
            }));

            for (let i = 0; i < sheetKeywords.length; i++) {
                for (let j = i + 1; j < sheetKeywords.length; j++) {
                    const shared = sheetKeywords[i].keywords.filter(k =>
                        k.length > 2 && sheetKeywords[j].keywords.includes(k)
                    );
                    if (shared.length > 0) {
                        analysis.relationships.push({
                            from: sheetKeywords[i].name,
                            to: sheetKeywords[j].name,
                            sharedKeywords: shared,
                            type: 'related'
                        });
                    }
                }
            }

            console.log('ðŸ“Š Content analysis complete:', analysis);
            return analysis;
        }

        /**
         * Analyze text content structure
         */
        function analyzeTextContent(text, fileName = 'Pasted Text') {
            const analysis = {
                sourceType: 'text',
                fileName: fileName,
                sheets: [], // Not applicable for text
                relationships: [],
                domain: { detected: 'generic', confidence: 0, keywords: [] },
                financials: { hasCapex: false, hasOpex: false, hasRevenue: false, hasCashflow: false, metrics: [] },
                timeline: { detected: false, range: { start: null, end: null }, granularity: null, milestones: [] },
                validationInfo: { detected: false, stats: { validated: 0, notValidated: 0 } },
                textStats: {
                    charCount: text.length,
                    wordCount: text.split(/\s+/).filter(w => w.length > 0).length,
                    lineCount: text.split('\n').length,
                    hasHeaders: false,
                    hasBullets: false,
                    hasNumbers: false
                }
            };

            const textLower = text.toLowerCase();

            // Domain keywords (same as Excel)
            const domainKeywords = {
                capex: ['capex', 'capital', 'turbine', 'mw', 'infrastructure', 'equipment', 'irr', 'npv'],
                philosophy: ['argument', 'premise', 'conclusion', 'dialectic', 'thesis', 'philosopher'],
                sales: ['deal', 'pipeline', 'revenue', 'prospect', 'lead', 'probability'],
                legal: ['contract', 'clause', 'party', 'obligation', 'liability'],
                technical: ['api', 'database', 'server', 'deployment', 'architecture']
            };

            // Detect domain
            let maxScore = 0;
            let detectedDomain = 'generic';
            const foundKeywords = [];

            Object.entries(domainKeywords).forEach(([domain, keywords]) => {
                let score = 0;
                keywords.forEach(kw => {
                    const matches = (textLower.match(new RegExp(kw, 'g')) || []).length;
                    if (matches > 0) {
                        score += matches;
                        if (!foundKeywords.includes(kw)) foundKeywords.push(kw);
                    }
                });
                if (score > maxScore) {
                    maxScore = score;
                    detectedDomain = domain;
                }
            });

            analysis.domain = {
                detected: detectedDomain,
                confidence: Math.min(0.95, maxScore / 10),
                keywords: foundKeywords.slice(0, 6)
            };

            // Detect timeline
            const yearPattern = /\b(20[2-3]\d)\b/g;
            const years = [...new Set((text.match(yearPattern) || []).map(y => parseInt(y)))].sort();
            if (years.length > 0) {
                analysis.timeline = {
                    detected: true,
                    range: { start: years[0], end: years[years.length - 1] },
                    granularity: 'yearly',
                    milestones: []
                };
            }

            // Text structure detection
            analysis.textStats.hasHeaders = /^#+\s|^[A-Z][A-Z\s]+:|\n[A-Z][A-Z\s]+\n/m.test(text);
            analysis.textStats.hasBullets = /^[\s]*[-â€¢*]\s|^\s*\d+[.)]\s/m.test(text);
            analysis.textStats.hasNumbers = /\$[\d,]+|\d+%|\d+\s*(MW|kW|GJ|MWh)/i.test(text);

            // Financial detection
            if (/capex|capital\s*(cost|expenditure)/i.test(text)) analysis.financials.hasCapex = true;
            if (/opex|operating\s*(cost|expense)/i.test(text)) analysis.financials.hasOpex = true;
            if (/revenue|income|sales/i.test(text)) analysis.financials.hasRevenue = true;

            console.log('ðŸ“„ Text analysis complete:', analysis);
            return analysis;
        }

        // =============================================================================
        // BUILD 354: MULTI-TREE SLICE DETECTION
        // Detect potential ways to split data into multiple trees
        // =============================================================================

        /**
         * Detect potential slices for multi-tree output
         * Returns array of slice objects with id, name, description, and filter context
         */
        function detectPotentialSlices(analysis, workbook = null, text = null) {
            const slices = [];
            const isExcel = analysis.sourceType === 'excel';

            // 1. STAKEHOLDER/AUDIENCE SLICES
            // Look for business model indicators
            const stakeholderKeywords = {
                'btc-mining': {
                    keywords: ['btc', 'bitcoin', 'mining', 'hash', 'crypto'],
                    name: 'BTC Mining Focus',
                    desc: 'Crypto investors, mining operations',
                    icon: 'â‚¿',
                    audience: 'Crypto investors, power generation partners'
                },
                'enterprise-dc': {
                    keywords: ['enterprise', 'tier 3', 'tier 4', 'datacenter', 'data center', 'colocation', 'colo', 'ai training', 'hyperscale'],
                    name: 'Enterprise Data Center',
                    desc: 'Enterprise customers, AI/cloud investors',
                    icon: 'ðŸ¢',
                    audience: 'Enterprise customers, AI/cloud investors, ESG stakeholders'
                },
                'investor': {
                    keywords: ['irr', 'npv', 'roi', 'investor', 'returns', 'payback', 'payout'],
                    name: 'Investor Summary',
                    desc: 'Financial metrics and returns',
                    icon: 'ðŸ“ˆ',
                    audience: 'Investors, financial stakeholders, board members'
                },
                'operations': {
                    keywords: ['operations', 'maintenance', 'staff', 'wages', 'daily', 'uptime'],
                    name: 'Operations Focus',
                    desc: 'Day-to-day operational data',
                    icon: 'âš™ï¸',
                    audience: 'Operations team, facility managers'
                },
                'esg-carbon': {
                    keywords: ['carbon', 'esg', 'solar', 'renewable', 'emissions', 'neutral', 'sustainable'],
                    name: 'ESG & Carbon Neutral',
                    desc: 'Sustainability and environmental focus',
                    icon: 'ðŸŒ±',
                    audience: 'ESG committees, sustainability officers, green investors'
                }
            };

            // Check content for stakeholder indicators
            let contentText = '';
            if (isExcel && workbook) {
                workbook.SheetNames.forEach(name => {
                    const sheet = workbook.Sheets[name];
                    if (sheet) {
                        const json = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                        json.forEach(row => {
                            contentText += ' ' + row.map(c => String(c || '')).join(' ');
                        });
                    }
                });
            } else if (text) {
                contentText = text;
            }
            const contentLower = contentText.toLowerCase();

            Object.entries(stakeholderKeywords).forEach(([id, config]) => {
                const matchCount = config.keywords.reduce((count, kw) => {
                    const matches = (contentLower.match(new RegExp(kw, 'gi')) || []).length;
                    return count + matches;
                }, 0);

                if (matchCount >= 2) {
                    slices.push({
                        id: id,
                        type: 'stakeholder',
                        name: config.name,
                        desc: config.desc,
                        icon: config.icon,
                        matchScore: matchCount,
                        context: `TARGET AUDIENCE: ${config.audience}\nFOCUS: Filter and emphasize content relevant to ${config.name.toLowerCase()}. Exclude items not relevant to this audience.`
                    });
                }
            });

            // 2. TIMELINE SLICES (if multi-year data)
            if (analysis.timeline.detected && analysis.timeline.range.end - analysis.timeline.range.start >= 2) {
                // Suggest phase-based splits
                slices.push({
                    id: 'phase-early',
                    type: 'timeline',
                    name: `Early Phase (${analysis.timeline.range.start}-${analysis.timeline.range.start + 1})`,
                    desc: 'Initial development and setup',
                    icon: '1ï¸âƒ£',
                    context: `TIMELINE FILTER: Focus only on activities, costs, and milestones from ${analysis.timeline.range.start} to ${analysis.timeline.range.start + 1}. This is the early development phase.`
                });

                if (analysis.timeline.range.end - analysis.timeline.range.start >= 3) {
                    const midStart = analysis.timeline.range.start + 2;
                    const midEnd = analysis.timeline.range.end - 1;
                    slices.push({
                        id: 'phase-growth',
                        type: 'timeline',
                        name: `Growth Phase (${midStart}-${midEnd})`,
                        desc: 'Expansion and scaling',
                        icon: 'ðŸ“ˆ',
                        context: `TIMELINE FILTER: Focus only on activities, costs, and milestones from ${midStart} to ${midEnd}. This is the growth and expansion phase.`
                    });
                }

                slices.push({
                    id: 'phase-mature',
                    type: 'timeline',
                    name: `Mature Phase (${analysis.timeline.range.end}+)`,
                    desc: 'Full operations and optimization',
                    icon: 'âœ…',
                    context: `TIMELINE FILTER: Focus only on activities, costs, and milestones from ${analysis.timeline.range.end} onwards. This is the mature operations phase.`
                });
            }

            // 3. FINANCIAL STRUCTURE SLICES
            if (analysis.financials.hasCapex && analysis.financials.hasRevenue) {
                slices.push({
                    id: 'capex-only',
                    type: 'financial',
                    name: 'Capital Expenditures',
                    desc: 'Investment and infrastructure costs',
                    icon: 'ðŸ’µ',
                    context: 'FINANCIAL FILTER: Focus ONLY on capital expenditures (CAPEX) - equipment, infrastructure, land, construction. Exclude operating costs and revenue projections.'
                });

                slices.push({
                    id: 'revenue-model',
                    type: 'financial',
                    name: 'Revenue & Operations',
                    desc: 'Operating economics and returns',
                    icon: 'ðŸ’°',
                    context: 'FINANCIAL FILTER: Focus ONLY on revenue generation, operating costs (OPEX), profit margins, and ROI calculations. Minimize CAPEX details.'
                });
            }

            // 4. DOMAIN-SPECIFIC SLICES (if mixed content detected)
            if (analysis.domain.keywords.length > 4) {
                // Mixed content - suggest domain splits
                if (analysis.domain.detected === 'capex') {
                    slices.push({
                        id: 'power-infrastructure',
                        type: 'domain',
                        name: 'Power Infrastructure',
                        desc: 'Turbines, solar, grid connection',
                        icon: 'âš¡',
                        context: 'DOMAIN FILTER: Focus ONLY on power generation infrastructure - turbines, solar arrays, grid connections, electrical systems, energy storage.'
                    });

                    slices.push({
                        id: 'facility-infrastructure',
                        type: 'domain',
                        name: 'Facility & Utilities',
                        desc: 'Buildings, cooling, water, connectivity',
                        icon: 'ðŸ—ï¸',
                        context: 'DOMAIN FILTER: Focus ONLY on facility infrastructure - buildings, cooling systems, water treatment, fiber connectivity, site development.'
                    });
                }
            }

            // Sort by match score (stakeholder slices) then by type
            slices.sort((a, b) => {
                if (a.type === 'stakeholder' && b.type === 'stakeholder') {
                    return (b.matchScore || 0) - (a.matchScore || 0);
                }
                return a.type.localeCompare(b.type);
            });

            console.log('ðŸŒ³ Detected potential slices:', slices);
            return slices;
        }

        // =============================================================================
        // QUESTION POOL - Dynamic questions based on content analysis
        // =============================================================================

        const smartImportQuestions = {
            organization: {
                id: 'organization',
                condition: () => true, // Always ask
                question: "How should I organize this?",
                getOptions: (analysis) => {
                    const options = [
                        { id: 'category', label: 'By Category', desc: 'Group by domain/type' }
                    ];
                    if (analysis.timeline.detected) {
                        const range = `${analysis.timeline.range.start} â†’ ${analysis.timeline.range.end}`;
                        options.unshift({ id: 'timeline', label: 'By Timeline', desc: range });
                        options.push({
                            id: 'milestone',
                            label: 'By Milestone',
                            desc: `${analysis.timeline.milestones.length || 'Key'} milestones`,
                            recommended: analysis.timeline.milestones.length > 2
                        });
                    }
                    if (analysis.financials.hasCapex || analysis.financials.hasRevenue) {
                        options.push({ id: 'financial', label: 'By Financial Structure', desc: 'CAPEX â†’ OPEX â†’ Revenue' });
                    }
                    // Mark first as recommended if none marked
                    if (!options.some(o => o.recommended)) {
                        options[0].recommended = true;
                    }
                    return options;
                }
            },

            detailLevel: {
                id: 'detailLevel',
                condition: () => true, // Always ask
                question: "What level of detail?",
                getOptions: () => [
                    { id: 'capital-only', label: 'Key Items Only', desc: 'Main deliverables and costs' },
                    { id: 'capital-milestones', label: 'Items + Milestones', desc: 'Deliverables, infrastructure, key dates', recommended: true },
                    { id: 'everything', label: 'Everything', desc: 'All data as items/subtasks' }
                ]
            },

            financials: {
                id: 'financials',
                condition: (a) => a.financials.hasCapex || a.financials.hasRevenue || a.financials.hasOpex,
                question: "Where should financial data appear?",
                getOptions: () => [
                    { id: 'items', label: 'On Items Only', desc: 'Each item shows its cost' },
                    { id: 'summaries', label: 'Phase Summaries Only', desc: 'Totals per phase' },
                    { id: 'both', label: 'Both', desc: 'Item costs + phase summaries', recommended: true }
                ]
            },

            validation: {
                id: 'validation',
                condition: (a) => a.validationInfo.detected,
                question: "I found validation status. How should I track it?",
                getOptions: (analysis) => {
                    const stats = analysis.validationInfo.stats;
                    return [
                        { id: 'pm-status', label: 'PM Tracking', desc: `Done/To Do (${stats.validated} validated, ${stats.notValidated} pending)`, recommended: true },
                        { id: 'description', label: 'In Description', desc: 'Add [VALIDATED] tag' },
                        { id: 'ignore', label: 'Ignore', desc: "Don't import status" }
                    ];
                }
            },

            appendTarget: {
                id: 'appendTarget',
                condition: (a) => a.appendMode,
                question: "Where should new content go?",
                getOptions: (analysis) => {
                    const options = [
                        { id: 'smart-match', label: 'Smart Match', desc: 'AI matches to existing phases', recommended: true },
                        { id: 'new-phases', label: 'Add New Phases', desc: 'Create separate phases' }
                    ];
                    // Add existing phases as options
                    if (window.capexTree && window.capexTree.children) {
                        window.capexTree.children.forEach(phase => {
                            options.push({
                                id: `phase-${phase.id}`,
                                label: `Under: ${phase.name}`,
                                desc: `${phase.items?.length || 0} existing items`
                            });
                        });
                    }
                    return options;
                }
            },

            duplicateHandling: {
                id: 'duplicateHandling',
                condition: (a) => a.appendMode,
                question: "How should I handle duplicates?",
                getOptions: () => [
                    { id: 'smart-dedupe', label: 'Smart Deduplication', desc: 'Merge similar items (60% match)', recommended: true },
                    { id: 'update', label: 'Update Existing', desc: 'Overwrite matching items' },
                    { id: 'add-all', label: 'Add Everything', desc: 'No deduplication' }
                ]
            },

            // BUILD 354: Multi-tree output option
            outputMode: {
                id: 'outputMode',
                condition: (a) => !a.appendMode && a.detectedSlices && a.detectedSlices.length >= 2,
                question: "I can create multiple trees for different audiences. Interested?",
                getOptions: (analysis) => {
                    const options = [
                        { id: 'single', label: 'Single Tree', desc: 'One comprehensive tree (standard)', recommended: true }
                    ];

                    if (analysis.detectedSlices && analysis.detectedSlices.length >= 2) {
                        options.push({
                            id: 'multi-select',
                            label: 'Multiple Trees',
                            desc: `Choose from ${analysis.detectedSlices.length} detected variations`,
                            icon: 'ðŸŒ³'
                        });

                        // Add quick option for top 2 stakeholder slices
                        const stakeholderSlices = analysis.detectedSlices.filter(s => s.type === 'stakeholder');
                        if (stakeholderSlices.length >= 2) {
                            const top2 = stakeholderSlices.slice(0, 2);
                            options.push({
                                id: 'quick-dual',
                                label: `Quick: ${top2[0].name} + ${top2[1].name}`,
                                desc: 'Generate two targeted trees',
                                quickSlices: top2.map(s => s.id)
                            });
                        }
                    }

                    return options;
                }
            }
        };

        /**
         * Generate questions based on content analysis
         */
        function generateSmartQuestions(analysis) {
            const questions = [];
            Object.values(smartImportQuestions).forEach(q => {
                // Check if appendMode is set in analysis for append-specific questions
                // BUILD 354: Include detectedSlices in analysis for outputMode question
                const checkAnalysis = {
                    ...analysis,
                    appendMode: smartImportState.appendMode,
                    detectedSlices: smartImportState.detectedSlices || []
                };
                if (q.condition(checkAnalysis)) {
                    questions.push({
                        ...q,
                        options: q.getOptions(checkAnalysis)
                    });
                }
            });
            return questions;
        }

        // =============================================================================
        // SEMANTIC ICON MAPPING
        // =============================================================================

        const semanticIconMap = {
            // Energy & Power
            turbine: 'âš¡', generator: 'âš¡', power: 'âš¡', electricity: 'âš¡', 'mw': 'âš¡', megawatt: 'âš¡',
            solar: 'â˜€ï¸', photovoltaic: 'â˜€ï¸', pv: 'â˜€ï¸',
            battery: 'ðŸ”‹', bess: 'ðŸ”‹', storage: 'ðŸ”‹',
            gas: 'ðŸ”¥', fuel: 'ðŸ”¥', natural: 'ðŸ”¥',

            // Infrastructure
            water: 'ðŸ’§', cooling: 'â„ï¸', hvac: 'â„ï¸',
            fiber: 'ðŸŒ', network: 'ðŸŒ', internet: 'ðŸŒ', connectivity: 'ðŸŒ',
            building: 'ðŸ—ï¸', shell: 'ðŸ—ï¸', construction: 'ðŸ—ï¸', facility: 'ðŸ—ï¸',
            site: 'ðŸš§', civil: 'ðŸš§', grading: 'ðŸš§',
            land: 'ðŸžï¸', acre: 'ðŸžï¸', property: 'ðŸžï¸',

            // Business
            btc: 'â‚¿', bitcoin: 'â‚¿', crypto: 'â‚¿', mining: 'â‚¿',
            enterprise: 'ðŸ¢', datacenter: 'ðŸ¢', 'data center': 'ðŸ¢', tier: 'ðŸ¢',
            revenue: 'ðŸ’°', income: 'ðŸ’°', profit: 'ðŸ’°', economics: 'ðŸ’°',
            cost: 'ðŸ’µ', capex: 'ðŸ’µ', expense: 'ðŸ’µ',

            // Status & Milestones
            milestone: 'ðŸŽ¯', target: 'ðŸŽ¯', deadline: 'ðŸŽ¯',
            complete: 'âœ…', done: 'âœ…', validated: 'âœ…',
            pending: 'â³', progress: 'â³',

            // Equipment
            switchgear: 'ðŸ”Œ', cable: 'ðŸ”Œ', electrical: 'ðŸ”Œ',
            diesel: 'ðŸ›¢ï¸', backup: 'ðŸ›¡ï¸', redundancy: 'ðŸ›¡ï¸',

            // Environment
            carbon: 'ðŸŒ±', co2: 'ðŸŒ±', emission: 'ðŸŒ±', green: 'ðŸŒ±',

            // Security & Compliance
            security: 'ðŸ”’', fence: 'ðŸ”’', permit: 'ðŸ“‹', approval: 'ðŸ“‹',
            engineering: 'ðŸ“', design: 'ðŸ“'
        };

        /**
         * Get semantic icon for an item name
         */
        function getSemanticIcon(itemName) {
            const nameLower = itemName.toLowerCase();
            for (const [keyword, icon] of Object.entries(semanticIconMap)) {
                if (nameLower.includes(keyword)) {
                    return icon;
                }
            }
            return 'ðŸ“¦'; // Default
        }

        // =============================================================================
        // BUILD SMART IMPORT CONTEXT (prepended to existing prompts)
        // =============================================================================

        /**
         * Build context string that gets prepended to existing AI prompts
         * This is ADDITIVE - existing prompts are not modified
         */
        function buildSmartImportContext(analysis, answers) {
            if (!analysis || Object.keys(answers).length === 0) {
                return '';
            }

            let context = `
=== SMART IMPORT CONTEXT ===
Source: ${analysis.fileName} (${analysis.sourceType})
`;

            // Organization preference
            if (answers.organization) {
                context += `\nORGANIZATION: ${answers.organization}`;
                if (answers.organization === 'timeline' && analysis.timeline.detected) {
                    context += ` (${analysis.timeline.range.start}-${analysis.timeline.range.end})`;
                } else if (answers.organization === 'milestone' && analysis.timeline.milestones.length > 0) {
                    context += `\nMilestones to use: ${analysis.timeline.milestones.slice(0, 5).join(', ')}`;
                }
            }

            // Detail level
            if (answers.detailLevel) {
                context += `\nDETAIL LEVEL: ${answers.detailLevel}`;
                if (answers.detailLevel === 'capital-only') {
                    context += ' - Focus on main deliverables and costs only';
                } else if (answers.detailLevel === 'everything') {
                    context += ' - Include all available data as items/subtasks';
                }
            }

            // Financial handling
            if (answers.financials) {
                context += `\nFINANCIALS: ${answers.financials}`;
                if (answers.financials === 'both') {
                    context += ' - Add costs to items AND create "Economics Summary" item per phase';
                }
            }

            // Validation mapping
            if (answers.validation === 'pm-status') {
                context += `\nVALIDATION â†’ PM STATUS: Map Yes/Validated/Approved â†’ pmStatus:"Done", pmProgress:100; Map No/Pending/TBD â†’ pmStatus:"To Do", pmProgress:0`;
            }

            // Append mode specifics
            if (answers.appendTarget) {
                context += `\nAPPEND TARGET: ${answers.appendTarget}`;
            }
            if (answers.duplicateHandling) {
                context += `\nDUPLICATE HANDLING: ${answers.duplicateHandling}`;
            }

            // Domain context
            if (analysis.domain.detected !== 'generic' && analysis.domain.confidence > 0.3) {
                context += `\nDOMAIN CONTEXT: This is ${analysis.domain.detected} data. Keywords: ${analysis.domain.keywords.join(', ')}`;
            }

            // Cross-sheet relationships
            if (analysis.relationships && analysis.relationships.length > 0) {
                context += `\nCROSS-REFERENCES: ${analysis.relationships.map(r => `${r.from}â†”${r.to}`).join(', ')}`;
            }

            // Source traceability instruction
            context += `\nSOURCE TRACEABILITY: Include source reference in item descriptions where helpful`;

            // Semantic icons instruction
            context += `\nICONS: Use semantic icons (âš¡ power, ðŸ’° financial, ðŸ—ï¸ building, ðŸŽ¯ milestone, etc.)`;

            context += `\n=== END SMART IMPORT CONTEXT ===\n\n`;

            return context;
        }

        // =============================================================================
        // SMART IMPORT WIZARD UI
        // =============================================================================

        /**
         * Show the Smart Import Wizard modal
         * BUILD 354: Added workbook/text params for multi-tree slice detection
         */
        function showSmartImportWizard(analysis, appendMode, onComplete, originalData = null) {
            // BUILD 354: Detect potential slices for multi-tree output
            const detectedSlices = !appendMode ? detectPotentialSlices(
                analysis,
                originalData?.workbook || null,
                originalData?.text || null
            ) : [];

            smartImportState = {
                active: true,
                contentAnalysis: analysis,
                userAnswers: {},
                currentStep: 0,
                questions: [], // Will be generated after detectedSlices is set
                appendMode: appendMode,
                sourceType: analysis.sourceType,
                onComplete: onComplete,
                // BUILD 354: Multi-tree state
                multiTreeMode: false,
                detectedSlices: detectedSlices,
                selectedSlices: [],
                originalData: originalData
            };

            // Generate questions now that detectedSlices is set
            smartImportState.questions = generateSmartQuestions(analysis);

            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ” Smart Import Wizard';

            // Show Step 1: Content Preview
            showWizardStep1(modalBody, analysis);
            modal.style.display = 'flex';
        }

        /**
         * Step 1: Content Preview
         */
        function showWizardStep1(container, analysis) {
            const isExcel = analysis.sourceType === 'excel';

            let sheetsHtml = '';
            if (isExcel && analysis.sheets.length > 0) {
                sheetsHtml = `
                    <div style="margin-top: 16px; border-top: 1px solid var(--border); padding-top: 16px;">
                        <div style="font-weight: 600; margin-bottom: 8px; cursor: pointer;" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">
                            ðŸ“‘ Sheets Overview (${analysis.sheets.length}) â–¾
                        </div>
                        <div style="display: none; max-height: 150px; overflow-y: auto;">
                            ${analysis.sheets.map(s => `
                                <div style="padding: 4px 0; font-size: 13px; color: var(--text-secondary);">
                                    â€¢ ${s.name} (${s.rowCount} rows) - ${s.summary || 'data'}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            let textStatsHtml = '';
            if (!isExcel && analysis.textStats) {
                textStatsHtml = `
                    <div style="padding: 8px 12px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 12px;">
                        ðŸ“„ ${analysis.textStats.wordCount.toLocaleString()} words â€¢ ${analysis.textStats.lineCount} lines
                        ${analysis.textStats.hasHeaders ? ' â€¢ Has headers' : ''}
                        ${analysis.textStats.hasBullets ? ' â€¢ Has bullet points' : ''}
                    </div>
                `;
            }

            container.innerHTML = `
                <div style="padding: 20px; max-width: 600px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 12px; color: var(--text-secondary);">Step 1 of ${smartImportState.questions.length + 1}</span>
                        <span style="font-size: 12px; color: var(--text-secondary);">${smartImportState.appendMode ? 'âž• Append Mode' : 'ðŸ“¥ Import Mode'}</span>
                    </div>

                    <div style="padding: 12px 16px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 4px;">
                            ${isExcel ? 'ðŸ“Š' : 'ðŸ“„'} ${analysis.fileName}
                        </div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            ${isExcel ? `${analysis.sheets.length} sheets â€¢ ${analysis.totalRows.toLocaleString()} total rows` : ''}
                        </div>
                    </div>

                    ${textStatsHtml}

                    <div style="font-weight: 600; margin-bottom: 12px;">What I Detected:</div>

                    <div style="display: grid; gap: 8px;">
                        ${analysis.domain.detected !== 'generic' ? `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: rgba(99, 102, 241, 0.1); border-radius: 6px;">
                                <span>ðŸ¢</span>
                                <div>
                                    <div style="font-weight: 500;">Domain: ${analysis.domain.detected.toUpperCase()}</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">Keywords: ${analysis.domain.keywords.slice(0, 5).join(', ')}</div>
                                </div>
                            </div>
                        ` : ''}

                        ${analysis.timeline.detected ? `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: rgba(34, 197, 94, 0.1); border-radius: 6px;">
                                <span>ðŸ“…</span>
                                <div>
                                    <div style="font-weight: 500;">Timeline: ${analysis.timeline.range.start} â†’ ${analysis.timeline.range.end}</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">${analysis.timeline.milestones.length || 'Multiple'} milestones detected</div>
                                </div>
                            </div>
                        ` : ''}

                        ${analysis.financials.hasCapex || analysis.financials.hasRevenue ? `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: rgba(245, 158, 11, 0.1); border-radius: 6px;">
                                <span>ðŸ’°</span>
                                <div>
                                    <div style="font-weight: 500;">Financial Model Detected</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">
                                        ${[
                                            analysis.financials.hasCapex ? 'CAPEX' : '',
                                            analysis.financials.hasOpex ? 'OPEX' : '',
                                            analysis.financials.hasRevenue ? 'Revenue' : ''
                                        ].filter(Boolean).join(' â€¢ ')}
                                        ${analysis.financials.metrics.length > 0 ? ` â€¢ Metrics: ${analysis.financials.metrics.join(', ')}` : ''}
                                    </div>
                                </div>
                            </div>
                        ` : ''}

                        ${analysis.validationInfo.detected ? `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: rgba(16, 185, 129, 0.1); border-radius: 6px;">
                                <span>âœ…</span>
                                <div>
                                    <div style="font-weight: 500;">Validation Column Found</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">${analysis.validationInfo.stats.validated} validated â€¢ ${analysis.validationInfo.stats.notValidated} pending</div>
                                </div>
                            </div>
                        ` : ''}

                        ${analysis.relationships && analysis.relationships.length > 0 ? `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: rgba(139, 92, 246, 0.1); border-radius: 6px;">
                                <span>ðŸ”—</span>
                                <div>
                                    <div style="font-weight: 500;">Cross-References</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">${analysis.relationships.slice(0, 3).map(r => `${r.from} â†” ${r.to}`).join(', ')}</div>
                                </div>
                            </div>
                        ` : ''}
                    </div>

                    ${sheetsHtml}

                    <div style="display: flex; justify-content: space-between; margin-top: 24px;">
                        <button onclick="closeSmartImportWizard()" class="btn" style="padding: 8px 16px;">
                            Cancel
                        </button>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="skipSmartImportWizard()" class="btn" style="padding: 8px 16px; opacity: 0.7;">
                                Skip Wizard â†’
                            </button>
                            <button onclick="nextWizardStep()" class="btn btn-primary" style="padding: 8px 20px;">
                                Continue â†’
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * Show question step
         */
        function showWizardQuestionStep(container, questionIndex) {
            const question = smartImportState.questions[questionIndex];
            if (!question) {
                finishSmartImportWizard();
                return;
            }

            const stepNum = questionIndex + 2; // +2 because Step 1 is preview
            const totalSteps = smartImportState.questions.length + 1;

            // Find recommended option
            const recommendedOption = question.options.find(o => o.recommended);

            container.innerHTML = `
                <div style="padding: 20px; max-width: 550px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <span style="font-size: 12px; color: var(--text-secondary);">Step ${stepNum} of ${totalSteps}</span>
                        <span style="font-size: 12px; color: var(--text-secondary);">${smartImportState.appendMode ? 'âž• Append Mode' : 'ðŸ“¥ Import Mode'}</span>
                    </div>

                    <div style="font-size: 18px; font-weight: 600; margin-bottom: 20px;">
                        ${question.question}
                    </div>

                    <div style="display: grid; gap: 10px; margin-bottom: 20px;">
                        ${question.options.map((opt, idx) => `
                            <label style="display: flex; align-items: flex-start; gap: 12px; padding: 12px 16px; border: 2px solid ${opt.recommended ? 'var(--treeplex-primary)' : 'var(--border)'}; border-radius: 8px; cursor: pointer; transition: all 0.15s; background: ${opt.recommended ? 'rgba(0, 166, 125, 0.05)' : 'transparent'};"
                                   onmouseenter="this.style.borderColor='var(--treeplex-primary)'"
                                   onmouseleave="this.style.borderColor='${opt.recommended ? 'var(--treeplex-primary)' : 'var(--border)'}'">
                                <input type="radio" name="wizard-q-${question.id}" value="${opt.id}"
                                       ${opt.recommended ? 'checked' : ''}
                                       style="margin-top: 2px;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 500; display: flex; align-items: center; gap: 8px;">
                                        ${opt.label}
                                        ${opt.recommended ? '<span style="font-size: 11px; padding: 2px 6px; background: var(--treeplex-primary); color: white; border-radius: 4px;">Recommended</span>' : ''}
                                    </div>
                                    <div style="font-size: 13px; color: var(--text-secondary); margin-top: 2px;">${opt.desc}</div>
                                </div>
                            </label>
                        `).join('')}
                    </div>

                    ${recommendedOption ? `
                        <div style="padding: 10px 14px; background: rgba(99, 102, 241, 0.1); border-radius: 6px; margin-bottom: 20px;">
                            <div style="font-size: 13px; color: var(--text-secondary);">
                                ðŸ’¡ <strong>${recommendedOption.label}</strong> is recommended based on your data structure.
                            </div>
                        </div>
                    ` : ''}

                    <div style="display: flex; justify-content: space-between;">
                        <button onclick="prevWizardStep()" class="btn" style="padding: 8px 16px;">
                            â† Back
                        </button>
                        <button onclick="nextWizardStep()" class="btn btn-primary" style="padding: 8px 20px;">
                            ${questionIndex === smartImportState.questions.length - 1 ? 'Finish â†’' : 'Next â†’'}
                        </button>
                    </div>
                </div>
            `;
        }

        /**
         * Navigate to next step
         */
        function nextWizardStep() {
            const container = document.getElementById('modal-body');

            // Save answer from current question if on a question step
            if (smartImportState.currentStep > 0) {
                const questionIndex = smartImportState.currentStep - 1;
                const question = smartImportState.questions[questionIndex];
                if (question) {
                    const selected = document.querySelector(`input[name="wizard-q-${question.id}"]:checked`);
                    if (selected) {
                        smartImportState.userAnswers[question.id] = selected.value;

                        // BUILD 354: Handle outputMode answer
                        if (question.id === 'outputMode') {
                            if (selected.value === 'multi-select') {
                                // Show multi-tree selection step
                                smartImportState.multiTreeMode = true;
                                showMultiTreeSelectionStep(container);
                                return;
                            } else if (selected.value === 'quick-dual') {
                                // Use the quick dual slices
                                const option = question.options.find(o => o.id === 'quick-dual');
                                if (option && option.quickSlices) {
                                    smartImportState.multiTreeMode = true;
                                    smartImportState.selectedSlices = option.quickSlices;
                                }
                            }
                        }
                    }
                }
            }

            smartImportState.currentStep++;

            if (smartImportState.currentStep > smartImportState.questions.length) {
                finishSmartImportWizard();
            } else {
                showWizardQuestionStep(container, smartImportState.currentStep - 1);
            }
        }

        /**
         * BUILD 354: Show multi-tree slice selection step
         */
        function showMultiTreeSelectionStep(container) {
            const slices = smartImportState.detectedSlices;

            // Group slices by type
            const byType = {};
            slices.forEach(s => {
                if (!byType[s.type]) byType[s.type] = [];
                byType[s.type].push(s);
            });

            const typeLabels = {
                stakeholder: 'ðŸ‘¥ Audience/Stakeholder',
                timeline: 'ðŸ“… Timeline Phase',
                financial: 'ðŸ’° Financial Focus',
                domain: 'ðŸ¢ Domain/Technology'
            };

            container.innerHTML = `
                <div style="padding: 20px; max-width: 600px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 12px; color: var(--text-secondary);">ðŸŒ³ Multi-Tree Selection</span>
                    </div>

                    <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">
                        Select the trees you want to generate
                    </div>
                    <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 20px;">
                        Each selection will create a separate tree file optimized for that audience.
                    </div>

                    <div style="max-height: 350px; overflow-y: auto; margin-bottom: 20px;">
                        ${Object.entries(byType).map(([type, typeSlices]) => `
                            <div style="margin-bottom: 16px;">
                                <div style="font-weight: 600; color: var(--text-secondary); font-size: 12px; margin-bottom: 8px; text-transform: uppercase;">
                                    ${typeLabels[type] || type}
                                </div>
                                <div style="display: grid; gap: 8px;">
                                    ${typeSlices.map(slice => `
                                        <label style="display: flex; align-items: flex-start; gap: 12px; padding: 10px 14px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.15s;"
                                               onmouseenter="this.style.borderColor='var(--treeplex-primary)'"
                                               onmouseleave="if(!this.querySelector('input').checked) this.style.borderColor='var(--border)'">
                                            <input type="checkbox" name="multi-tree-slice" value="${slice.id}"
                                                   style="margin-top: 3px;"
                                                   onchange="updateSliceSelection(this)">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 500; display: flex; align-items: center; gap: 6px;">
                                                    <span>${slice.icon}</span>
                                                    ${slice.name}
                                                </div>
                                                <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">${slice.desc}</div>
                                            </div>
                                        </label>
                                    `).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div id="multi-tree-summary" style="padding: 10px 14px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 20px;">
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            Select at least 2 tree variations to generate
                        </div>
                    </div>

                    <div style="display: flex; justify-content: space-between;">
                        <button onclick="cancelMultiTreeSelection()" class="btn" style="padding: 8px 16px;">
                            â† Back to Single Tree
                        </button>
                        <button id="multi-tree-continue" onclick="confirmMultiTreeSelection()" class="btn btn-primary" style="padding: 8px 20px; opacity: 0.5;" disabled>
                            Generate Trees â†’
                        </button>
                    </div>
                </div>
            `;
        }

        /**
         * BUILD 354: Update slice selection state
         */
        function updateSliceSelection(checkbox) {
            const selected = document.querySelectorAll('input[name="multi-tree-slice"]:checked');
            const selectedIds = Array.from(selected).map(c => c.value);

            smartImportState.selectedSlices = selectedIds;

            // Update visual styling
            document.querySelectorAll('input[name="multi-tree-slice"]').forEach(cb => {
                const label = cb.closest('label');
                if (cb.checked) {
                    label.style.borderColor = 'var(--treeplex-primary)';
                    label.style.background = 'rgba(0, 166, 125, 0.05)';
                } else {
                    label.style.borderColor = 'var(--border)';
                    label.style.background = 'transparent';
                }
            });

            // Update summary
            const summary = document.getElementById('multi-tree-summary');
            const continueBtn = document.getElementById('multi-tree-continue');

            if (selectedIds.length >= 2) {
                const sliceNames = selectedIds.map(id => {
                    const slice = smartImportState.detectedSlices.find(s => s.id === id);
                    return slice ? `${slice.icon} ${slice.name}` : id;
                });
                summary.innerHTML = `
                    <div style="font-size: 13px;">
                        <strong>ðŸŒ³ ${selectedIds.length} trees to generate:</strong><br>
                        ${sliceNames.join(' â€¢ ')}
                    </div>
                `;
                continueBtn.disabled = false;
                continueBtn.style.opacity = '1';
            } else {
                summary.innerHTML = `
                    <div style="font-size: 13px; color: var(--text-secondary);">
                        Select at least 2 tree variations to generate
                    </div>
                `;
                continueBtn.disabled = true;
                continueBtn.style.opacity = '0.5';
            }
        }

        /**
         * BUILD 354: Cancel multi-tree and go back to single tree mode
         */
        function cancelMultiTreeSelection() {
            smartImportState.multiTreeMode = false;
            smartImportState.selectedSlices = [];
            smartImportState.userAnswers.outputMode = 'single';

            // Continue to next step or finish
            smartImportState.currentStep++;
            const container = document.getElementById('modal-body');

            if (smartImportState.currentStep > smartImportState.questions.length) {
                finishSmartImportWizard();
            } else {
                showWizardQuestionStep(container, smartImportState.currentStep - 1);
            }
        }

        /**
         * BUILD 354: Confirm multi-tree selection and finish wizard
         */
        function confirmMultiTreeSelection() {
            if (smartImportState.selectedSlices.length < 2) {
                showToast('Please select at least 2 tree variations', 'error');
                return;
            }

            // Continue with remaining questions if any, then finish
            smartImportState.currentStep++;
            const container = document.getElementById('modal-body');

            if (smartImportState.currentStep > smartImportState.questions.length) {
                finishSmartImportWizard();
            } else {
                showWizardQuestionStep(container, smartImportState.currentStep - 1);
            }
        }

        /**
         * Navigate to previous step
         */
        function prevWizardStep() {
            const container = document.getElementById('modal-body');
            smartImportState.currentStep--;

            if (smartImportState.currentStep <= 0) {
                smartImportState.currentStep = 0;
                showWizardStep1(container, smartImportState.contentAnalysis);
            } else {
                showWizardQuestionStep(container, smartImportState.currentStep - 1);
            }
        }

        /**
         * Skip wizard and use defaults
         */
        function skipSmartImportWizard() {
            // Use recommended defaults
            smartImportState.questions.forEach(q => {
                const recommended = q.options.find(o => o.recommended);
                if (recommended) {
                    smartImportState.userAnswers[q.id] = recommended.id;
                } else if (q.options.length > 0) {
                    smartImportState.userAnswers[q.id] = q.options[0].id;
                }
            });
            finishSmartImportWizard();
        }

        /**
         * Complete wizard and build context
         */
        function finishSmartImportWizard() {
            // BUILD 354: Handle multi-tree mode
            if (smartImportState.multiTreeMode && smartImportState.selectedSlices.length >= 2) {
                // Build contexts for each selected slice
                window.multiTreeContexts = smartImportState.selectedSlices.map(sliceId => {
                    const slice = smartImportState.detectedSlices.find(s => s.id === sliceId);
                    if (!slice) return null;

                    // Build base context from user answers
                    const baseContext = buildSmartImportContext(
                        smartImportState.contentAnalysis,
                        smartImportState.userAnswers
                    );

                    // Add slice-specific context
                    const sliceContext = `
=== MULTI-TREE SLICE CONTEXT ===
${slice.context}
TREE NAME SUFFIX: ${slice.name}
TREE ICON: ${slice.icon}
=== END SLICE CONTEXT ===

${baseContext}`;

                    return {
                        sliceId: slice.id,
                        sliceName: slice.name,
                        sliceIcon: slice.icon,
                        context: sliceContext
                    };
                }).filter(Boolean);

                // Use first slice context as the primary context
                window.smartImportContext = window.multiTreeContexts[0]?.context || '';

                console.log('ðŸŒ³ Multi-tree mode: Generating', window.multiTreeContexts.length, 'trees');
                console.log('ðŸ“‹ Slice contexts:', window.multiTreeContexts);

                // Close modal and call completion callback with multi-tree info
                document.getElementById('modal').style.display = 'none';

                if (smartImportState.onComplete) {
                    smartImportState.onComplete({
                        ...smartImportState.userAnswers,
                        multiTreeMode: true,
                        multiTreeContexts: window.multiTreeContexts
                    });
                }

                smartImportState.active = false;
                return;
            }

            // Standard single-tree mode
            // Build the context that will be prepended to AI prompts
            window.smartImportContext = buildSmartImportContext(
                smartImportState.contentAnalysis,
                smartImportState.userAnswers
            );

            console.log('ðŸ” Smart Import Wizard complete');
            console.log('ðŸ“‹ User answers:', smartImportState.userAnswers);
            console.log('ðŸ“ Context to prepend:', window.smartImportContext);

            // Close modal
            document.getElementById('modal').style.display = 'none';

            // Call the completion callback
            if (smartImportState.onComplete) {
                smartImportState.onComplete(smartImportState.userAnswers);
            }

            // Reset state
            smartImportState.active = false;
        }

        /**
         * Close wizard without completing
         */
        function closeSmartImportWizard() {
            document.getElementById('modal').style.display = 'none';
            smartImportState.active = false;
            window.smartImportContext = '';
        }

        // =============================================================================
        // BUILD 354: MULTI-TREE GENERATION
        // Process multiple tree variants sequentially
        // =============================================================================

        /**
         * Process Excel import in multi-tree mode
         * Generates multiple trees and downloads each as JSON
         */
        async function proceedWithMultiTreeExcelImport(workbook, multiTreeContexts) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸŒ³ Generating Multiple Trees';

            const generatedTrees = [];
            const totalTrees = multiTreeContexts.length;

            // Show progress UI
            modalBody.innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px;">ðŸŒ³</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 12px;">
                        Generating ${totalTrees} tree variations...
                    </div>
                    <div id="multi-tree-progress" style="font-size: 14px; color: var(--text-secondary); margin-bottom: 20px;">
                        Preparing first tree...
                    </div>
                    <div style="width: 100%; background: var(--bg-secondary); border-radius: 8px; height: 8px; overflow: hidden;">
                        <div id="multi-tree-progress-bar" style="width: 0%; height: 100%; background: var(--treeplex-primary); transition: width 0.3s;"></div>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';

            // Process each tree variant
            for (let i = 0; i < multiTreeContexts.length; i++) {
                const ctx = multiTreeContexts[i];

                // Update progress
                document.getElementById('multi-tree-progress').textContent =
                    `Generating ${ctx.sliceIcon} ${ctx.sliceName} (${i + 1}/${totalTrees})...`;
                document.getElementById('multi-tree-progress-bar').style.width =
                    `${((i + 0.5) / totalTrees) * 100}%`;

                // Set context for this tree
                window.smartImportContext = ctx.context;

                try {
                    // Use flexible import but capture the result instead of loading it
                    // For now, we'll process the first sheet with AI analysis
                    const sheetData = await extractExcelDataForMultiTree(workbook);
                    const treeResult = await generateTreeWithAI(sheetData, ctx);

                    if (treeResult) {
                        generatedTrees.push({
                            sliceId: ctx.sliceId,
                            sliceName: ctx.sliceName,
                            sliceIcon: ctx.sliceIcon,
                            tree: treeResult
                        });
                    }
                } catch (err) {
                    console.error(`Error generating tree for ${ctx.sliceName}:`, err);
                }

                // Update progress
                document.getElementById('multi-tree-progress-bar').style.width =
                    `${((i + 1) / totalTrees) * 100}%`;
            }

            // Reset context
            window.smartImportContext = '';

            // Show completion and offer downloads
            showMultiTreeCompletion(generatedTrees);
        }

        /**
         * Extract data from Excel for multi-tree processing
         */
        async function extractExcelDataForMultiTree(workbook) {
            // Combine all sheets into a single data blob for AI processing
            let combinedData = '';

            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                if (!sheet) return;

                const json = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
                if (json.length === 0) return;

                combinedData += `\n=== Sheet: ${sheetName} ===\n`;
                json.slice(0, 100).forEach(row => { // Limit to first 100 rows per sheet
                    const rowStr = row.map(cell => String(cell || '')).join(' | ');
                    if (rowStr.trim()) {
                        combinedData += rowStr + '\n';
                    }
                });
            });

            return combinedData;
        }

        /**
         * Generate a tree using AI with slice-specific context
         */
        async function generateTreeWithAI(sheetData, sliceContext) {
            try {
                // Build prompt with slice context
                const prompt = `${sliceContext.context}

Analyze the following data and create a hierarchical tree structure in JSON format.
The tree should follow this structure:
{
    "id": "root",
    "name": "[Project Name based on ${sliceContext.sliceName}]",
    "type": "root",
    "icon": "${sliceContext.sliceIcon}",
    "description": "[Summary focused on ${sliceContext.sliceName}]",
    "expanded": true,
    "children": [
        {
            "id": "phase-0",
            "name": "[Phase Name]",
            "type": "phase",
            "phase": 0,
            "icon": "1ï¸âƒ£",
            "expanded": true,
            "items": [
                {
                    "id": "item-0-0",
                    "name": "[Item Name]",
                    "description": "[Details]",
                    "icon": "[emoji]",
                    "type": "item",
                    "cost": [number if applicable],
                    "subtasks": []
                }
            ],
            "children": []
        }
    ],
    "pattern": { "key": "generic", "labels": { "root": "Project", "phase": "Phase", "item": "Item", "subtask": "Subtask" } }
}

DATA TO ANALYZE:
${sheetData.substring(0, 8000)}

Return ONLY valid JSON, no explanation.`;

                // Get current AI provider
                const provider = currentAIProvider || 'claude';
                let tree;

                if (provider === 'claude') {
                    tree = await callClaudeForMultiTree(prompt);
                } else if (provider === 'gemini') {
                    tree = await callGeminiForMultiTree(prompt);
                } else {
                    tree = await callOpenAIForMultiTree(prompt);
                }

                // BUILD 355: Lightweight validation for multi-tree output
                if (tree && tree.children && tree.children.length > 0) {
                    console.log(`âœ… Multi-tree verified: ${tree.children.length} phases for ${sliceContext.sliceName}`);
                    return tree;
                } else if (tree) {
                    console.warn(`âš ï¸ Multi-tree for ${sliceContext.sliceName} has issues, returning anyway`);
                    return tree;
                }

                return null;
            } catch (err) {
                console.error('AI tree generation failed:', err);
                return null;
            }
        }

        /**
         * Call Claude for multi-tree generation
         */
        async function callClaudeForMultiTree(prompt) {
            const response = await fetch('/.netlify/functions/claude-proxy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 8000,
                    messages: [{ role: 'user', content: prompt }]
                })
            });

            const data = await response.json();
            if (data.content?.[0]?.text) {
                return extractJSONFromResponse(data.content[0].text);
            }
            return null;
        }

        /**
         * Call Gemini for multi-tree generation
         */
        async function callGeminiForMultiTree(prompt) {
            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) return null;

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { maxOutputTokens: 8000 }
                })
            });

            const data = await response.json();
            if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                return extractJSONFromResponse(data.candidates[0].content.parts[0].text);
            }
            return null;
        }

        /**
         * Call OpenAI for multi-tree generation
         */
        async function callOpenAIForMultiTree(prompt) {
            const apiKey = localStorage.getItem('openai_api_key');
            if (!apiKey) return null;

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4-turbo-preview',
                    messages: [{ role: 'user', content: prompt }],
                    max_tokens: 8000
                })
            });

            const data = await response.json();
            if (data.choices?.[0]?.message?.content) {
                return extractJSONFromResponse(data.choices[0].message.content);
            }
            return null;
        }

        /**
         * Extract JSON from AI response
         */
        function extractJSONFromResponse(text) {
            try {
                // Try direct parse first
                return JSON.parse(text);
            } catch (e) {
                // Try to extract from code block
                const jsonMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
                if (jsonMatch) {
                    try {
                        return JSON.parse(jsonMatch[1]);
                    } catch (e2) {}
                }
                // Try to find JSON object in text
                const objMatch = text.match(/\{[\s\S]*\}/);
                if (objMatch) {
                    try {
                        return JSON.parse(objMatch[0]);
                    } catch (e3) {}
                }
            }
            return null;
        }

        /**
         * Show multi-tree completion UI with download options
         */
        function showMultiTreeCompletion(generatedTrees) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸŒ³ Trees Generated!';

            const successCount = generatedTrees.length;

            modalBody.innerHTML = `
                <div style="padding: 20px; max-width: 500px;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 48px; margin-bottom: 12px;">âœ…</div>
                        <div style="font-size: 16px; font-weight: 600;">
                            ${successCount} tree${successCount > 1 ? 's' : ''} generated successfully!
                        </div>
                    </div>

                    <div style="margin-bottom: 24px;">
                        <div style="font-weight: 600; margin-bottom: 12px;">Generated Trees:</div>
                        <div style="display: grid; gap: 8px;">
                            ${generatedTrees.map((t, idx) => `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--bg-secondary); border-radius: 8px;">
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <span style="font-size: 20px;">${t.sliceIcon}</span>
                                        <div>
                                            <div style="font-weight: 500;">${t.sliceName}</div>
                                            <div style="font-size: 12px; color: var(--text-secondary);">
                                                ${t.tree?.children?.length || 0} phases â€¢ ${countItems(t.tree)} items
                                            </div>
                                        </div>
                                    </div>
                                    <button onclick="downloadSingleTree(${idx})" class="btn" style="padding: 6px 12px; font-size: 12px;">
                                        ðŸ“¥ Download
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div style="display: flex; gap: 12px;">
                        <button onclick="downloadAllTrees()" class="btn btn-primary" style="flex: 1; padding: 10px 16px;">
                            ðŸ“¦ Download All (ZIP)
                        </button>
                        <button onclick="loadFirstTree()" class="btn" style="flex: 1; padding: 10px 16px;">
                            ðŸ“‚ Load First Tree
                        </button>
                    </div>

                    <div style="margin-top: 16px; text-align: center;">
                        <button onclick="closeModal()" class="btn" style="padding: 8px 16px; opacity: 0.7;">
                            Close
                        </button>
                    </div>
                </div>
            `;

            // Store generated trees for download
            window.generatedMultiTrees = generatedTrees;
            modal.style.display = 'flex';
        }

        /**
         * Count total items in a tree
         */
        function countItems(tree) {
            if (!tree || !tree.children) return 0;
            return tree.children.reduce((sum, phase) => {
                return sum + (phase.items?.length || 0);
            }, 0);
        }

        /**
         * Download a single tree from the generated set
         */
        function downloadSingleTree(index) {
            const trees = window.generatedMultiTrees;
            if (!trees || !trees[index]) return;

            const tree = trees[index];
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const safeName = tree.sliceName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
            const filename = `treelisty-${safeName}-${timestamp}.json`;

            const blob = new Blob([JSON.stringify(tree.tree, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            showToast(`Downloaded: ${tree.sliceName}`, 'success');
        }

        /**
         * Download all generated trees as individual JSON files
         */
        function downloadAllTrees() {
            const trees = window.generatedMultiTrees;
            if (!trees || trees.length === 0) return;

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

            trees.forEach((tree, idx) => {
                setTimeout(() => {
                    const safeName = tree.sliceName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                    const filename = `treelisty-${safeName}-${timestamp}.json`;

                    const blob = new Blob([JSON.stringify(tree.tree, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                }, idx * 500); // Stagger downloads
            });

            showToast(`Downloading ${trees.length} trees...`, 'success');
        }

        /**
         * Load the first generated tree into TreeListy
         */
        function loadFirstTree() {
            const trees = window.generatedMultiTrees;
            if (!trees || trees.length === 0) return;

            const firstTree = trees[0].tree;
            if (firstTree) {
                loadTreeData(firstTree);
                document.getElementById('modal').style.display = 'none';
                showToast(`Loaded: ${trees[0].sliceName}`, 'success');
            }
        }

        /**
         * Process text analysis in multi-tree mode
         */
        async function proceedWithMultiTreeTextAnalysis(text, mode, multiTreeContexts) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸŒ³ Generating Multiple Trees';

            const generatedTrees = [];
            const totalTrees = multiTreeContexts.length;

            // Show progress UI
            modalBody.innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px;">ðŸŒ³</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 12px;">
                        Generating ${totalTrees} tree variations...
                    </div>
                    <div id="multi-tree-progress" style="font-size: 14px; color: var(--text-secondary); margin-bottom: 20px;">
                        Preparing first tree...
                    </div>
                    <div style="width: 100%; background: var(--bg-secondary); border-radius: 8px; height: 8px; overflow: hidden;">
                        <div id="multi-tree-progress-bar" style="width: 0%; height: 100%; background: var(--treeplex-primary); transition: width 0.3s;"></div>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';

            // Process each tree variant
            for (let i = 0; i < multiTreeContexts.length; i++) {
                const ctx = multiTreeContexts[i];

                // Update progress
                document.getElementById('multi-tree-progress').textContent =
                    `Generating ${ctx.sliceIcon} ${ctx.sliceName} (${i + 1}/${totalTrees})...`;
                document.getElementById('multi-tree-progress-bar').style.width =
                    `${((i + 0.5) / totalTrees) * 100}%`;

                // Set context for this tree
                window.smartImportContext = ctx.context;

                try {
                    const treeResult = await generateTreeWithAI(text.substring(0, 8000), ctx);

                    if (treeResult) {
                        generatedTrees.push({
                            sliceId: ctx.sliceId,
                            sliceName: ctx.sliceName,
                            sliceIcon: ctx.sliceIcon,
                            tree: treeResult
                        });
                    }
                } catch (err) {
                    console.error(`Error generating tree for ${ctx.sliceName}:`, err);
                }

                // Update progress
                document.getElementById('multi-tree-progress-bar').style.width =
                    `${((i + 1) / totalTrees) * 100}%`;
            }

            // Reset context
            window.smartImportContext = '';

            // Show completion and offer downloads
            showMultiTreeCompletion(generatedTrees);
        }

        // =============================================================================
        // EXCEL IMPORT - Import from Excel back to TreeListy
        // =============================================================================

        // =============================================================================
        // FLEXIBLE EXCEL IMPORT - Import ANY Excel file with column mapping
        // =============================================================================

        let excelImportState = {
            workbook: null,
            file: null,
            selectedSheet: null,
            headers: [],
            sampleData: [],
            columnMapping: {},
            hierarchyConfig: {},
            pattern: null,
            aiAnalysis: null,  // NEW: Store AI analysis results
            aiAnalysisInProgress: false
        };

        // =============================================================================
        // AI-POWERED EXCEL ANALYSIS (Build 241)
        // =============================================================================

        async function aiAnalyzeExcelStructure(headers, sampleRows) {
            console.log('ðŸ¤– Starting AI analysis of Excel structure...');

            // Build pattern descriptions for the AI
            const patternDescriptions = Object.entries(PATTERNS).map(([key, p]) => {
                const fieldNames = Object.keys(p.fields || {}).filter(f =>
                    !['includeDependencies', 'includeTracking', 'trackingFor'].includes(f)
                ).slice(0, 8).join(', ');
                return `â€¢ ${key}: ${p.name} (fields: ${fieldNames || 'basic'})`;
            }).join('\n');

            const systemPrompt = `You are an expert data analyst helping import Excel spreadsheets into TreeListy, a hierarchical project management tool.

TreeListy organizes data into: Root â†’ Phases â†’ Items â†’ Subtasks
Each item can have pattern-specific fields like cost, dates, descriptions, etc.

Available patterns:
${patternDescriptions}

PATTERN DETECTION HINTS:
- capex: Look for Budget/Actual/Variance columns, CAPEX/OPEX terminology, Cost/Investment/ROI fields, Funding Phase/Seed/Series terms, Risk/Mitigation columns, WBS codes, project financial tracking
- sales: Look for Deal Value, Close Date, Pipeline, Quarter columns, Probability/Stage fields
- philosophy: Look for philosophical concepts, arguments, objections, sources, thinkers
- thesis: Look for chapters, sections, word counts, citations, academic structure
- roadmap: Look for Features, Story Points, Sprints, Quarters, technical terms
- generic: Use when data has project phases but doesn't clearly match other patterns

Your job: Analyze the Excel structure and suggest the best import configuration.`;

            const userPrompt = `Analyze this Excel data and suggest how to import it into TreeListy.

COLUMN HEADERS:
${headers.map((h, i) => `${i}: "${h}"`).join('\n')}

SAMPLE DATA (first ${sampleRows.length} rows):
${sampleRows.map((row, i) => `Row ${i + 1}: ${JSON.stringify(row.slice(0, headers.length))}`).join('\n')}

Respond with ONLY valid JSON (no markdown, no explanation):
{
  "recommendedPattern": "pattern_key (e.g., generic, capex, sales, philosophy, roadmap)",
  "patternConfidence": 0.85,
  "patternReason": "Brief explanation why this pattern fits",
  "columnMappings": {
    "itemName": {"column": 0, "confidence": 0.95, "reason": "Contains task/item names"},
    "phaseName": {"column": 2, "confidence": 0.80, "reason": "Groups items by category"},
    "description": {"column": null, "confidence": 0, "reason": "No description column found"}
  },
  "hierarchyDetection": {
    "hasPhases": true,
    "phaseColumn": 2,
    "estimatedPhaseCount": 4,
    "note": "Detected quarterly grouping"
  },
  "dataQuality": {
    "totalRows": ${sampleRows.length},
    "issues": ["Column X has 20% empty values"]
  }
}

IMPORTANT:
- Column numbers are 0-indexed
- Only map columns that clearly match - use null for uncertain mappings
- Focus on: itemName (required), phaseName, description, and pattern-specific fields
- Pattern-specific fields to look for based on detected pattern`;

            try {
                const response = await callClaudeAPI(userPrompt, systemPrompt, 1024, false);

                // Parse JSON from response (handle potential markdown wrapping)
                let jsonStr = response.trim();
                if (jsonStr.startsWith('```')) {
                    jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                }

                const analysis = JSON.parse(jsonStr);
                console.log('ðŸ¤– AI Analysis complete:', analysis);
                return analysis;
            } catch (error) {
                console.error('âŒ AI Excel analysis failed:', error);
                return null;
            }
        }

        function applyAIAnalysisToMapping(aiAnalysis, headers) {
            if (!aiAnalysis || !aiAnalysis.columnMappings) return null;

            const mapping = {
                itemName: null,
                phaseName: null,
                description: null,
                itemType: null,
                dependencies: null
            };

            // Apply AI-suggested mappings
            Object.entries(aiAnalysis.columnMappings).forEach(([fieldKey, fieldData]) => {
                if (fieldData && fieldData.column !== null && fieldData.confidence >= 0.5) {
                    mapping[fieldKey] = fieldData.column;
                }
            });

            return mapping;
        }

        function importFromExcel(file) {
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });

                    console.log('ðŸ“¥ Excel workbook loaded:', workbook.SheetNames);

                    excelImportState.workbook = workbook;
                    excelImportState.file = file.name;

                    // Check if this is a TreeListy export (fast automatic import)
                    if (workbook.SheetNames.includes('ðŸ“‹ Detailed Items')) {
                        console.log('âœ… TreeListy export detected - importing automatically');
                        importTreeListyExcel(workbook);
                        return;
                    }

                    // BUILD 353: Launch Smart Import Wizard for non-TreeListy Excel files
                    console.log('ðŸ“‹ Generic Excel file - launching Smart Import Wizard');
                    const analysis = analyzeExcelContent(workbook, file.name);

                    // BUILD 354: Pass workbook for multi-tree slice detection
                    showSmartImportWizard(analysis, false, (userAnswers) => {
                        // BUILD 354: Handle multi-tree mode
                        if (userAnswers.multiTreeMode && userAnswers.multiTreeContexts) {
                            console.log('ðŸŒ³ Multi-tree mode: generating', userAnswers.multiTreeContexts.length, 'trees');
                            proceedWithMultiTreeExcelImport(workbook, userAnswers.multiTreeContexts);
                        } else {
                            // After wizard completes, proceed to flexible import with context set
                            console.log('ðŸ” Smart Import Wizard complete, proceeding to import');
                            startFlexibleImportWizard(workbook);
                        }
                    }, { workbook: workbook });

                } catch (err) {
                    console.error('âŒ Excel import error:', err);
                    alert('âŒ Failed to read Excel file!\n\n' + err.message);
                }
            };

            reader.readAsArrayBuffer(file);
        }

        function showImportModeChoice(workbook) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ“¥ Excel Import Mode';

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <p style="color: var(--text-secondary); margin-bottom: 24px;">
                        This appears to be a TreeListy export. Choose how to import:
                    </p>

                    <div style="display: flex; gap: 16px; margin-bottom: 20px;">
                        <div id="import-mode-fast" style="flex: 1; padding: 20px; border: 2px solid var(--treeplex-primary); border-radius: 12px; cursor: pointer; transition: all 0.2s; background: rgba(0, 166, 125, 0.05);">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">âš¡</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Fast Import
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Automatically import using TreeListy format. Perfect fidelity, instant import.
                            </div>
                        </div>

                        <div id="import-mode-custom" style="flex: 1; padding: 20px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.2s;">
                            <div style="font-size: 32px; margin-bottom: 12px; text-align: center;">ðŸŽ¯</div>
                            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 8px; text-align: center;">
                                Custom Mapping
                            </div>
                            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                                Map columns manually, customize field mappings, handle custom formats.
                            </div>
                        </div>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Hover effects
            ['import-mode-fast', 'import-mode-custom'].forEach(id => {
                const elem = document.getElementById(id);
                elem.addEventListener('mouseenter', () => {
                    elem.style.transform = 'translateY(-2px)';
                    elem.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
                });
                elem.addEventListener('mouseleave', () => {
                    elem.style.transform = 'translateY(0)';
                    elem.style.boxShadow = 'none';
                });
            });

            // Fast import handler
            document.getElementById('import-mode-fast').addEventListener('click', () => {
                modal.style.display = 'none';
                importTreeListyExcel(workbook);
            });

            // Custom import handler
            document.getElementById('import-mode-custom').addEventListener('click', () => {
                modal.style.display = 'none';
                startFlexibleImportWizard(workbook);
            });
        }

        function importTreeListyExcel(workbook) {
            try {

                    // Parse the "ðŸ“‹ Detailed Items" sheet
                    const itemsSheet = workbook.Sheets['ðŸ“‹ Detailed Items'];
                    const itemsData = XLSX.utils.sheet_to_json(itemsSheet, { header: 1 });

                    console.log('ðŸ“‹ Parsed items data:', itemsData.length, 'rows');

                    // Find the header row (contains "Item Name")
                    let headerRowIndex = -1;
                    for (let i = 0; i < itemsData.length; i++) {
                        if (itemsData[i][0] === 'Item Name') {
                            headerRowIndex = i;
                            break;
                        }
                    }

                    if (headerRowIndex === -1) {
                        alert('âŒ Invalid Excel format!\n\nCould not find the "Item Name" header row.');
                        return;
                    }

                    const headers = itemsData[headerRowIndex];
                    console.log('ðŸ“‹ Headers:', headers);

                    // Parse items (skip header and empty rows)
                    const items = [];
                    for (let i = headerRowIndex + 1; i < itemsData.length; i++) {
                        const row = itemsData[i];

                        // Skip empty rows or total row
                        if (!row[0] || row[0] === 'TOTAL') continue;

                        const item = {};
                        headers.forEach((header, index) => {
                            if (header && row[index] !== undefined && row[index] !== '') {
                                item[header] = row[index];
                            }
                        });

                        items.push(item);
                    }

                    console.log('âœ… Parsed', items.length, 'items from Excel');

                    // Detect pattern from the data structure
                    const detectedPattern = detectPatternFromExcel(items, headers);
                    console.log('ðŸŽ¨ Detected pattern:', detectedPattern);

                    // Convert items to tree structure
                    const newTree = convertExcelToTree(items, detectedPattern);

                    // Auto-import TreeListy exports (simple confirmation only)
                    const confirmMsg = `Import ${items.length} items from Excel?\n\nThis will replace your current tree.`;
                    if (confirm(confirmMsg)) {
                        saveState('Excel Import');
                        capexTree = newTree;
                        currentPattern = detectedPattern;
                        document.getElementById('pattern-select').value = detectedPattern;
                        render();
                        showToast(`âœ… Excel imported! ${items.length} items loaded`);
                        console.log('âœ… TreeListy export auto-imported');
                    }

            } catch (err) {
                console.error('âŒ Excel import error:', err);
                alert('âŒ Failed to import Excel file!\n\n' + err.message + '\n\nPlease ensure this is a valid TreeListy Excel export.');
            }
        }

        function detectPatternFromExcel(items, headers) {
            // Check for pattern-specific columns
            if (headers.includes('Deal Value ($)') || headers.includes('Stage Probability (%)')) {
                return 'sales';
            } else if (headers.includes('Word Count') || headers.includes('Draft Status')) {
                return 'thesis';
            } else if (headers.includes('Story Points') || headers.includes('Engineering Estimate')) {
                return 'roadmap';
            } else if (headers.includes('Use Case') || headers.includes('Target Model')) {
                return 'prompt';
            } else if (headers.includes('Chapter Number') || headers.includes('Section Type')) {
                return 'book';
            } else if (headers.includes('Argument Type') || headers.includes('Philosophical School')) {
                return 'philosophy';
            } else if (headers.includes('KPI') || headers.includes('Strategic Priority')) {
                return 'strategy';
            } else if (headers.includes('Cost ($M)') && headers.includes('Lead Time')) {
                return 'generic';
            }

            // Default to current pattern
            return currentPattern;
        }

        function convertExcelToTree(items, pattern) {
            const patternDef = PATTERNS[pattern];
            const levels = patternDef.levels;

            // Group items by phase
            const phaseMap = {};

            items.forEach(item => {
                const phaseName = item.Phase || item[levels.phase];

                if (!phaseName) return;

                // Extract phase number and subtitle if present
                const phaseMatch = phaseName.match(/^(.+?)\s*\((.*?)\)$/);
                const basePhaseName = phaseMatch ? phaseMatch[1].trim() : phaseName;
                const phaseSubtitle = phaseMatch ? phaseMatch[2].trim() : '';

                if (!phaseMap[basePhaseName]) {
                    phaseMap[basePhaseName] = {
                        name: basePhaseName,
                        subtitle: phaseSubtitle,
                        items: []
                    };
                }

                // Convert item data back to tree format
                const treeItem = {
                    name: item['Item Name'] || item.name || 'Unnamed Item',
                    description: item.Description || item.description || '',
                    type: 'item',
                    icon: 'ðŸ“¦'
                };

                // Map pattern-specific fields dynamically
                const fields = patternDef.fields;
                if (fields) {
                    Object.keys(fields).forEach(fieldKey => {
                        const fieldConfig = fields[fieldKey];

                        // Skip non-field properties
                        if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                            return;
                        }

                        const excelColumnName = fieldConfig.label;

                        if (item[excelColumnName] !== undefined && item[excelColumnName] !== '' && item[excelColumnName] !== null) {
                            let value = item[excelColumnName];

                            // Convert numeric fields
                            if (fieldConfig.type === 'number') {
                                // Handle cost (exported in millions, import back to raw)
                                if (fieldKey === 'cost' && fieldConfig.label.includes('($M)')) {
                                    value = parseFloat(value) * 1000000;
                                } else if (fieldKey === 'dealValue') {
                                    // dealValue exported in thousands, import back to raw
                                    value = parseFloat(value) * 1000;
                                } else {
                                    value = parseFloat(value);
                                }
                            } else if (fieldConfig.type === 'date') {
                                // Keep dates as-is (Excel format)
                                value = value;
                            } else if (fieldConfig.type === 'select') {
                                // Ensure select value is string
                                value = value.toString();
                            } else if (fieldConfig.type === 'textarea') {
                                // Textarea values are already strings
                                value = value.toString();
                            } else {
                                // Text fields
                                value = value.toString();
                            }

                            treeItem[fieldKey] = value;
                        }
                    });
                }

                // Handle dependencies
                if (item.Dependencies && item.Dependencies !== 'None') {
                    treeItem.dependencies = item.Dependencies.split(', ').map(d => d.trim());
                }

                // Handle item type
                if (item.Type) {
                    treeItem.itemType = item.Type;
                }

                phaseMap[basePhaseName].items.push(treeItem);
            });

            // Convert phase map to tree structure
            const phases = Object.values(phaseMap).map((phase, index) => {
                return {
                    id: `phase-${index}`,
                    type: 'phase',
                    phase: index,
                    name: phase.name,
                    subtitle: phase.subtitle,
                    icon: `${index + 1}ï¸âƒ£`,
                    expanded: false,
                    items: phase.items.map((item, itemIndex) => ({
                        ...item,
                        id: `item-${index}-${itemIndex}`
                    }))
                };
            });

            // Create new tree
            const newTree = {
                id: 'root',
                type: 'root',
                name: items[0]?.Project || capexTree.name || 'Imported Project',
                icon: 'ðŸŒ³',
                expanded: true,
                children: phases,
                pattern: {
                    key: pattern,
                    labels: levels
                }
            };

            return newTree;
        }

        function showImportConfirmation(newTree, itemCount, pattern) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ“¥ Import from Excel';

            const patternInfo = PATTERNS[pattern];
            const phaseCount = newTree.children?.length || 0;

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 20px; border-radius: 12px; margin-bottom: 24px;">
                        <h3 style="margin: 0 0 12px 0; color: var(--treeplex-primary);">ðŸ“Š Import Summary</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 14px;">
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">Pattern Detected</div>
                                <div style="font-weight: 600;">${patternInfo.icon} ${patternInfo.levels.root}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">${patternInfo.levels.phase}s</div>
                                <div style="font-weight: 600;">${phaseCount}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">${patternInfo.levels.item}s</div>
                                <div style="font-weight: 600;">${itemCount}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 12px;">Project Name</div>
                                <div style="font-weight: 600;">${newTree.name}</div>
                            </div>
                        </div>
                    </div>

                    <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin-bottom: 24px; border-left: 3px solid var(--treeplex-primary);">
                        <p style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600;">Import Mode</p>
                        <p style="margin: 0 0 16px 0; font-size: 13px; color: var(--text-secondary);">
                            How would you like to import this Excel file?
                        </p>

                        <div style="display: flex; gap: 12px;">
                            <button id="import-replace-btn" class="btn" style="flex: 1; background: linear-gradient(135deg, #f59e0b, #d97706); padding: 12px;">
                                ðŸ”„ Replace Current Tree
                            </button>
                            <button id="import-append-btn" class="btn" style="flex: 1; background: linear-gradient(135deg, var(--treeplex-primary), #059669); padding: 12px;">
                                âž• Append to Current Tree
                            </button>
                        </div>
                    </div>

                    <div style="background: rgba(239, 68, 68, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #ef4444;">
                        <p style="margin: 0; font-size: 12px; color: var(--text-secondary);">
                            âš ï¸ <strong>Replace</strong> will overwrite your current project. <strong>Append</strong> will add items to existing phases.
                        </p>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Handle replace
            document.getElementById('import-replace-btn').addEventListener('click', () => {
                saveState('Excel Import: Replace');

                // Replace tree
                capexTree = newTree;
                currentPattern = pattern;
                document.getElementById('pattern-select').value = pattern;

                render();
                modal.style.display = 'none';

                showToast(`âœ… Excel imported! ${itemCount} items loaded`);
                console.log('âœ… Excel import complete (replace mode)');
            });

            // Handle append
            document.getElementById('import-append-btn').addEventListener('click', () => {
                saveState('Excel Import: Append');

                // Append phases and items
                newTree.children.forEach((newPhase, newPhaseIndex) => {
                    const existingPhase = capexTree.children?.[newPhaseIndex];

                    if (existingPhase) {
                        // Phase exists - append items
                        if (newPhase.items && newPhase.items.length > 0) {
                            const currentItemCount = existingPhase.items?.length || 0;

                            // Re-ID items
                            const reIdedItems = newPhase.items.map((item, idx) => ({
                                ...item,
                                id: `item-${newPhaseIndex}-${currentItemCount + idx}`
                            }));

                            existingPhase.items = [...(existingPhase.items || []), ...reIdedItems];
                        }
                    } else {
                        // Phase doesn't exist - add it
                        if (!capexTree.children) capexTree.children = [];
                        newPhase.id = `phase-${capexTree.children.length}`;
                        newPhase.phase = capexTree.children.length;
                        capexTree.children.push(newPhase);
                    }
                });

                render();
                modal.style.display = 'none';

                showToast(`âœ… Excel imported! ${itemCount} items added`);
                console.log('âœ… Excel import complete (append mode)');
            });
        }

        // =============================================================================
        // FLEXIBLE EXCEL IMPORT WIZARD - Import any Excel file with column mapping
        // =============================================================================

        function startFlexibleImportWizard(workbook) {
            console.log('ðŸ§™ Starting flexible import wizard...');

            excelImportState.workbook = workbook;
            excelImportState.multiSheetAnalysis = null;

            // If only one sheet, skip to column mapping
            if (workbook.SheetNames.length === 1) {
                analyzeSheetStructure(workbook.SheetNames[0]);
                return;
            }

            // Multiple sheets - check if AI is available
            const aiMode = document.getElementById('unified-ai-mode-select')?.value || '';
            const aiAvailable = aiMode && aiMode !== 'off';

            if (aiAvailable) {
                // AI analyzes all sheets and suggests how to combine
                analyzeMultipleSheetsWithAI(workbook);
            } else {
                // Fallback to manual sheet selection
                showSheetSelection(workbook);
            }
        }

        async function analyzeMultipleSheetsWithAI(workbook) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ¤– AI Analyzing Workbook...';
            modalBody.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <div class="spinner" style="margin: 0 auto 20px;"></div>
                    <p style="color: var(--text-secondary); font-size: 14px;">
                        AI is analyzing ${workbook.SheetNames.length} sheets to suggest the best import strategy...
                    </p>
                </div>
            `;
            modal.style.display = 'flex';

            // Gather info about each sheet
            const sheetsInfo = workbook.SheetNames.map(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                const headers = data[0]?.filter(h => h !== '' && h !== null && h !== undefined) || [];
                const sampleRows = data.slice(1, 4);
                const rowCount = data.length - 1;

                return {
                    name: sheetName,
                    headers,
                    sampleRows,
                    rowCount,
                    colCount: headers.length
                };
            });

            // Build AI prompt
            const systemPrompt = `You are an expert data analyst helping import a multi-sheet Excel workbook into TreeListy.

TreeListy organizes data hierarchically: Root â†’ Phases â†’ Items â†’ Subtasks
You need to analyze multiple sheets and recommend how to combine them.`;

            const userPrompt = `Analyze this Excel workbook with ${sheetsInfo.length} sheets and suggest how to import:

${sheetsInfo.map((s, i) => `
SHEET ${i + 1}: "${s.name}"
- Columns: ${s.headers.join(', ')}
- Rows: ${s.rowCount}
- Sample: ${JSON.stringify(s.sampleRows[0]?.slice(0, 6) || [])}
`).join('\n')}

Respond with ONLY valid JSON:
{
  "strategy": "combine_similar|separate_phases|single_primary|skip_some",
  "strategyReason": "Brief explanation of recommended approach",
  "sheets": [
    {
      "name": "Sheet1",
      "action": "import_as_phase|combine_with|skip|primary",
      "combineWith": null,
      "phaseNameSuggestion": "Suggested phase name",
      "importance": "primary|secondary|reference|skip",
      "reason": "Why this action"
    }
  ],
  "recommendedPattern": "generic|sales|philosophy|etc",
  "patternConfidence": 0.85,
  "warnings": ["Any issues or notes"]
}

STRATEGIES:
- combine_similar: Sheets with same structure merge into one phase
- separate_phases: Each sheet becomes its own phase
- single_primary: One main sheet, others are reference/skip
- skip_some: Some sheets aren't useful for import`;

            try {
                const response = await callClaudeAPI(userPrompt, systemPrompt, 1500, false);

                let jsonStr = response.trim();
                if (jsonStr.startsWith('```')) {
                    jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                }

                const analysis = JSON.parse(jsonStr);
                console.log('ðŸ¤– Multi-sheet analysis:', analysis);

                excelImportState.multiSheetAnalysis = analysis;
                showMultiSheetStrategyUI(workbook, analysis, sheetsInfo);

            } catch (error) {
                console.error('âŒ Multi-sheet AI analysis failed:', error);
                // Fall back to manual selection
                showSheetSelection(workbook);
            }
        }

        function showMultiSheetStrategyUI(workbook, analysis, sheetsInfo) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ¤– AI Import Strategy';

            const strategyLabels = {
                'combine_similar': 'ðŸ”— Combine Similar Sheets',
                'separate_phases': 'ðŸ“ Each Sheet â†’ Phase',
                'single_primary': 'â­ Focus on Primary Sheet',
                'skip_some': 'ðŸŽ¯ Selective Import'
            };

            const actionIcons = {
                'import_as_phase': 'ðŸ“',
                'combine_with': 'ðŸ”—',
                'skip': 'â­ï¸',
                'primary': 'â­'
            };

            const importanceColors = {
                'primary': '#10b981',
                'secondary': '#6366f1',
                'reference': '#f59e0b',
                'skip': '#6b7280'
            };

            // Build sheet cards
            let sheetsHTML = '';
            analysis.sheets.forEach((sheetAnalysis, idx) => {
                const sheetInfo = sheetsInfo.find(s => s.name === sheetAnalysis.name) || sheetsInfo[idx];
                const icon = actionIcons[sheetAnalysis.action] || 'ðŸ“„';
                const color = importanceColors[sheetAnalysis.importance] || '#6b7280';
                const isIncluded = sheetAnalysis.action !== 'skip';

                sheetsHTML += `
                    <div class="multi-sheet-card" data-sheet="${sheetAnalysis.name}" style="
                        padding: 12px 16px;
                        background: ${isIncluded ? 'rgba(16, 185, 129, 0.05)' : 'rgba(107, 114, 128, 0.05)'};
                        border: 1px solid ${isIncluded ? 'rgba(16, 185, 129, 0.2)' : 'rgba(107, 114, 128, 0.2)'};
                        border-radius: 8px;
                        margin-bottom: 8px;
                        opacity: ${isIncluded ? '1' : '0.6'};
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 18px;">${icon}</span>
                                <div>
                                    <div style="font-weight: 600; color: var(--text-primary);">${sheetAnalysis.name}</div>
                                    <div style="font-size: 11px; color: var(--text-secondary);">
                                        ${sheetInfo?.rowCount || '?'} rows â€¢ ${sheetInfo?.colCount || '?'} columns
                                    </div>
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 12px; color: ${color}; font-weight: 600;">
                                    ${sheetAnalysis.importance.toUpperCase()}
                                </div>
                                ${sheetAnalysis.phaseNameSuggestion ?
                                    `<div style="font-size: 11px; color: var(--text-secondary);">â†’ ${sheetAnalysis.phaseNameSuggestion}</div>` :
                                    ''}
                            </div>
                        </div>
                        <div style="font-size: 11px; color: var(--text-secondary); margin-top: 6px;">
                            ${sheetAnalysis.reason}
                        </div>
                    </div>
                `;
            });

            // Count what will be imported
            const importCount = analysis.sheets.filter(s => s.action !== 'skip').length;
            const totalRows = analysis.sheets
                .filter(s => s.action !== 'skip')
                .reduce((sum, s) => {
                    const info = sheetsInfo.find(si => si.name === s.name);
                    return sum + (info?.rowCount || 0);
                }, 0);

            // Warnings
            let warningsHTML = '';
            if (analysis.warnings?.length > 0) {
                warningsHTML = `
                    <div style="margin-top: 16px; padding: 12px; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 8px;">
                        <div style="font-size: 12px; font-weight: 600; color: #f59e0b; margin-bottom: 6px;">âš ï¸ Notes:</div>
                        ${analysis.warnings.map(w => `<div style="font-size: 12px; color: var(--text-secondary);">â€¢ ${w}</div>`).join('')}
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div style="padding: 20px; max-height: 75vh; overflow-y: auto;">
                    <!-- Strategy Banner -->
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 16px; border-radius: 12px; margin-bottom: 20px; border: 1px solid rgba(99, 102, 241, 0.2);">
                        <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">
                            ${strategyLabels[analysis.strategy] || analysis.strategy}
                        </div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            ${analysis.strategyReason}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
                            ðŸ“Š Importing ${importCount} of ${analysis.sheets.length} sheets â€¢ ~${totalRows} total rows
                            ${analysis.recommendedPattern ? ` â€¢ Pattern: <strong>${PATTERNS[analysis.recommendedPattern]?.name || analysis.recommendedPattern}</strong>` : ''}
                        </div>
                    </div>

                    <!-- Sheet Cards -->
                    <div style="margin-bottom: 16px;">
                        ${sheetsHTML}
                    </div>

                    ${warningsHTML}

                    <!-- Action Buttons -->
                    <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between;">
                        <button id="multi-sheet-manual-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                            ðŸ“‹ Pick Sheets Manually
                        </button>
                        <div style="display: flex; gap: 12px;">
                            <button id="multi-sheet-cancel-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                                Cancel
                            </button>
                            <button id="multi-sheet-proceed-btn" style="padding: 10px 24px; border: none; border-radius: 8px; background: linear-gradient(135deg, #10b981, #059669); color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                                âœ“ Proceed with AI Strategy
                            </button>
                        </div>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Event handlers
            document.getElementById('multi-sheet-cancel-btn').addEventListener('click', () => {
                modal.style.display = 'none';
            });

            document.getElementById('multi-sheet-manual-btn').addEventListener('click', () => {
                showSheetSelection(workbook);
            });

            document.getElementById('multi-sheet-proceed-btn').addEventListener('click', () => {
                executeMultiSheetImport(workbook, analysis, sheetsInfo);
            });
        }

        async function executeMultiSheetImport(workbook, analysis, sheetsInfo) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            // Apply recommended pattern
            if (analysis.recommendedPattern && PATTERNS[analysis.recommendedPattern]) {
                document.getElementById('pattern-select').value = analysis.recommendedPattern;
                currentPattern = analysis.recommendedPattern;
            }

            // Get sheets to import
            const sheetsToImport = analysis.sheets.filter(s => s.action !== 'skip');

            if (sheetsToImport.length === 0) {
                alert('No sheets selected for import');
                return;
            }

            // If only one sheet to import, use standard flow
            if (sheetsToImport.length === 1) {
                analyzeSheetStructure(sheetsToImport[0].name);
                return;
            }

            // Multiple sheets - show progress and import each
            modalTitle.textContent = 'ðŸ¤– Importing Multiple Sheets...';
            modalBody.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <div class="spinner" style="margin: 0 auto 20px;"></div>
                    <p style="color: var(--text-secondary); font-size: 14px;">
                        Processing ${sheetsToImport.length} sheets...
                    </p>
                    <div id="multi-import-progress" style="margin-top: 16px; font-size: 13px; color: var(--text-secondary);"></div>
                </div>
            `;

            const progressEl = document.getElementById('multi-import-progress');
            const allItems = [];
            const phaseMap = {};

            for (let i = 0; i < sheetsToImport.length; i++) {
                const sheetConfig = sheetsToImport[i];
                const sheetName = sheetConfig.name;
                progressEl.textContent = `Analyzing: ${sheetName} (${i + 1}/${sheetsToImport.length})`;

                const sheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

                // Find headers
                let headerRowIndex = 0;
                for (let j = 0; j < data.length; j++) {
                    if (data[j] && data[j].some(cell => cell !== '' && cell !== null && cell !== undefined)) {
                        headerRowIndex = j;
                        break;
                    }
                }

                const headers = data[headerRowIndex].filter(h => h !== '' && h !== null && h !== undefined);
                const rows = data.slice(headerRowIndex + 1);

                // Quick AI analysis for column mapping
                const sampleRows = rows.slice(0, 5);

                try {
                    const aiAnalysis = await aiAnalyzeExcelStructure(headers, sampleRows);

                    if (aiAnalysis?.columnMappings) {
                        const mapping = applyAIAnalysisToMapping(aiAnalysis, headers);

                        // Determine phase name
                        const phaseName = sheetConfig.phaseNameSuggestion || sheetName;

                        // Extract items
                        rows.forEach(row => {
                            if (!row || row.every(cell => !cell)) return;

                            const itemName = mapping.itemName !== null ? row[mapping.itemName] : null;
                            if (!itemName) return;

                            const item = {
                                name: String(itemName),
                                description: mapping.description !== null ? String(row[mapping.description] || '') : '',
                                type: mapping.itemType !== null ? String(row[mapping.itemType] || '') : '',
                                sourceSheet: sheetName
                            };

                            // Add pattern-specific fields
                            Object.keys(mapping).forEach(key => {
                                if (!['itemName', 'phaseName', 'description', 'itemType', 'dependencies'].includes(key)) {
                                    if (mapping[key] !== null && row[mapping[key]]) {
                                        item[key] = row[mapping[key]];
                                    }
                                }
                            });

                            if (!phaseMap[phaseName]) phaseMap[phaseName] = [];
                            phaseMap[phaseName].push(item);
                            allItems.push(item);
                        });
                    }
                } catch (error) {
                    console.warn(`âš ï¸ Failed to analyze sheet ${sheetName}:`, error);
                }
            }

            // Build final tree
            progressEl.textContent = 'Building tree structure...';

            const patternDef = PATTERNS[currentPattern];
            const phases = Object.keys(phaseMap).map((phaseName, phaseIndex) => ({
                id: `phase-${phaseIndex}`,
                type: 'phase',
                phase: phaseIndex,
                name: phaseName,
                subtitle: `${phaseMap[phaseName].length} items`,
                icon: `${phaseIndex + 1}ï¸âƒ£`,
                expanded: false,
                items: phaseMap[phaseName].map((item, itemIndex) => ({
                    ...item,
                    id: `item-${phaseIndex}-${itemIndex}`,
                    type: 'item'
                }))
            }));

            saveState('Multi-sheet Excel Import');

            capexTree = {
                id: 'root',
                type: 'root',
                name: `Imported from ${excelImportState.file}`,
                icon: 'ðŸŒ³',
                expanded: true,
                hyperedges: [],
                children: phases,
                pattern: {
                    key: currentPattern,
                    labels: patternDef.levels
                }
            };

            render();
            modal.style.display = 'none';

            showToast(`âœ… Imported ${allItems.length} items from ${sheetsToImport.length} sheets into ${phases.length} phases`);
        }

        function showSheetSelection(workbook) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ“‘ Select Sheet to Import';

            let sheetsHTML = '';
            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                const rowCount = data.length;
                const colCount = data[0]?.length || 0;

                // Preview first 3 rows
                const preview = data.slice(0, 3)
                    .map(row => row.slice(0, 5).join(', '))
                    .join('<br>');

                sheetsHTML += `
                    <div class="sheet-option" data-sheet="${sheetName}" style="border: 2px solid var(--border); padding: 16px; margin-bottom: 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 8px;">${sheetName}</div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                            ${rowCount} rows Ã— ${colCount} columns
                        </div>
                        <div style="font-size: 11px; font-family: monospace; color: var(--text-secondary); max-height: 60px; overflow: hidden;">
                            ${preview}
                        </div>
                    </div>
                `;
            });

            modalBody.innerHTML = `<div style="padding: 20px;">${sheetsHTML}</div>`;
            modal.style.display = 'flex';

            // Add click handlers
            document.querySelectorAll('.sheet-option').forEach(elem => {
                elem.addEventListener('click', () => {
                    const sheetName = elem.dataset.sheet;
                    analyzeSheetStructure(sheetName);
                });

                // Hover effect
                elem.addEventListener('mouseenter', () => {
                    elem.style.borderColor = 'var(--treeplex-primary)';
                    elem.style.background = 'rgba(0, 166, 125, 0.05)';
                });
                elem.addEventListener('mouseleave', () => {
                    elem.style.borderColor = 'var(--border)';
                    elem.style.background = 'transparent';
                });
            });
        }

        async function analyzeSheetStructure(sheetName) {
            const sheet = excelImportState.workbook.Sheets[sheetName];
            const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            console.log('ðŸ“Š Analyzing sheet:', sheetName);

            // Find header row (first non-empty row)
            let headerRowIndex = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] && data[i].some(cell => cell !== '' && cell !== null && cell !== undefined)) {
                    headerRowIndex = i;
                    break;
                }
            }

            const headers = data[headerRowIndex].filter(h => h !== '' && h !== null && h !== undefined);
            const sampleData = data.slice(headerRowIndex + 1, headerRowIndex + 11); // 10 sample rows for AI

            console.log('ðŸ“‹ Found headers:', headers);
            console.log('ðŸ“‹ Sample data rows:', sampleData.length);

            excelImportState.selectedSheet = sheetName;
            excelImportState.headers = headers;
            excelImportState.sampleData = sampleData;
            excelImportState.aiAnalysis = null;

            // Check if AI is available (any provider configured)
            const aiMode = document.getElementById('unified-ai-mode-select')?.value || '';
            const aiAvailable = aiMode && aiMode !== 'off';

            if (aiAvailable) {
                // Show loading state
                showAIAnalysisLoading();

                try {
                    // Call AI to analyze structure
                    const aiAnalysis = await aiAnalyzeExcelStructure(headers, sampleData);
                    excelImportState.aiAnalysis = aiAnalysis;

                    if (aiAnalysis) {
                        // Apply AI-suggested mappings
                        const aiMappings = applyAIAnalysisToMapping(aiAnalysis, headers);
                        if (aiMappings) {
                            excelImportState.columnMapping = aiMappings;
                        }

                        // If AI recommends a different pattern, offer to switch
                        if (aiAnalysis.recommendedPattern && aiAnalysis.patternConfidence >= 0.7) {
                            const recommendedKey = aiAnalysis.recommendedPattern.toLowerCase().replace(/[^a-z]/g, '');
                            if (PATTERNS[recommendedKey] && recommendedKey !== currentPattern) {
                                console.log(`ðŸ¤– AI recommends pattern: ${recommendedKey} (${(aiAnalysis.patternConfidence * 100).toFixed(0)}% confidence)`);
                            }
                        }

                        // Show AI-enhanced mapping UI
                        showAIEnhancedMappingUI();
                        return;
                    }
                } catch (error) {
                    console.warn('âš ï¸ AI analysis failed, falling back to keyword matching:', error);
                }
            }

            // Fallback: Use keyword-based auto-suggest
            const suggestedMappings = autoSuggestColumnMappings(headers);
            excelImportState.columnMapping = suggestedMappings;

            console.log('ðŸŽ¯ Suggested mappings (keyword-based):', suggestedMappings);

            // Show standard column mapping UI
            showColumnMappingUI();
        }

        function showAIAnalysisLoading() {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ¤– AI Analyzing Excel Structure...';
            modalBody.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <div class="spinner" style="margin: 0 auto 20px;"></div>
                    <p style="color: var(--text-secondary); font-size: 14px;">
                        AI is analyzing your spreadsheet to suggest the best import configuration...
                    </p>
                    <p style="color: var(--text-secondary); font-size: 12px; margin-top: 12px; opacity: 0.7;">
                        Detecting patterns, mapping columns, identifying hierarchy...
                    </p>
                </div>
            `;
            modal.style.display = 'flex';
        }

        function showAIEnhancedMappingUI() {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            const aiAnalysis = excelImportState.aiAnalysis;
            const headers = excelImportState.headers;
            const mapping = excelImportState.columnMapping;

            modalTitle.textContent = 'ðŸ¤– AI-Detected Import Configuration';

            // Build confidence badge
            const confidence = aiAnalysis?.patternConfidence || 0;
            const confidenceColor = confidence >= 0.8 ? '#10b981' : confidence >= 0.6 ? '#f59e0b' : '#ef4444';
            const confidencePercent = (confidence * 100).toFixed(0);

            // Build pattern recommendation
            const recommendedPattern = aiAnalysis?.recommendedPattern || currentPattern;
            const patternDef = PATTERNS[recommendedPattern] || PATTERNS[currentPattern];
            const patternReason = aiAnalysis?.patternReason || '';

            // Build mapping cards
            let mappingCardsHTML = '';
            const coreMappings = [
                { key: 'itemName', label: 'Item Name', required: true, icon: 'ðŸ“' },
                { key: 'phaseName', label: 'Phase/Category', required: false, icon: 'ðŸ“' },
                { key: 'description', label: 'Description', required: false, icon: 'ðŸ“„' }
            ];

            coreMappings.forEach(({ key, label, required, icon }) => {
                const colIndex = mapping[key];
                const colName = colIndex !== null ? headers[colIndex] : null;
                const aiData = aiAnalysis?.columnMappings?.[key];
                const confidence = aiData?.confidence || 0;
                const reason = aiData?.reason || '';

                const isMapped = colIndex !== null;
                const bgColor = isMapped ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)';
                const borderColor = isMapped ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)';

                mappingCardsHTML += `
                    <div class="ai-mapping-card" data-field="${key}" style="padding: 12px 16px; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 16px; margin-right: 8px;">${icon}</span>
                                <strong style="color: var(--text-primary);">${label}</strong>
                                ${required ? '<span style="color: #ef4444; margin-left: 4px;">*</span>' : ''}
                            </div>
                            <div style="text-align: right;">
                                ${isMapped ?
                                    `<span style="color: #10b981; font-weight: 600;">"${colName}"</span>
                                     <span style="color: var(--text-secondary); font-size: 11px; margin-left: 8px;">${(confidence * 100).toFixed(0)}%</span>` :
                                    `<span style="color: #ef4444;">Not mapped</span>`
                                }
                            </div>
                        </div>
                        ${reason ? `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px; padding-left: 28px;">${reason}</div>` : ''}
                    </div>
                `;
            });

            // Add pattern-specific field mappings
            const fields = patternDef.fields || {};
            const mappedPatternFields = Object.entries(fields)
                .filter(([key]) => !['includeDependencies', 'includeTracking', 'trackingFor'].includes(key))
                .filter(([key]) => mapping[key] !== null && mapping[key] !== undefined)
                .slice(0, 5);

            if (mappedPatternFields.length > 0) {
                mappingCardsHTML += `<div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border);">
                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Pattern-specific fields detected:</div>`;

                mappedPatternFields.forEach(([key, fieldConfig]) => {
                    const colIndex = mapping[key];
                    const colName = headers[colIndex];
                    mappingCardsHTML += `
                        <div style="display: flex; justify-content: space-between; padding: 6px 0; font-size: 13px;">
                            <span style="color: var(--text-secondary);">${fieldConfig.label || key}</span>
                            <span style="color: #10b981;">"${colName}"</span>
                        </div>
                    `;
                });

                mappingCardsHTML += `</div>`;
            }

            // Data quality notes
            let qualityHTML = '';
            if (aiAnalysis?.dataQuality?.issues?.length > 0) {
                qualityHTML = `
                    <div style="margin-top: 16px; padding: 12px; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 8px;">
                        <div style="font-size: 12px; font-weight: 600; color: #f59e0b; margin-bottom: 6px;">âš ï¸ Data Quality Notes:</div>
                        ${aiAnalysis.dataQuality.issues.map(issue => `<div style="font-size: 12px; color: var(--text-secondary);">â€¢ ${issue}</div>`).join('')}
                    </div>
                `;
            }

            // Total row count
            const totalRows = XLSX.utils.sheet_to_json(excelImportState.workbook.Sheets[excelImportState.selectedSheet], { header: 1 }).length - 1;

            modalBody.innerHTML = `
                <div style="padding: 20px; max-height: 75vh; overflow-y: auto;">
                    <!-- AI Confidence Banner -->
                    <div style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1)); padding: 16px; border-radius: 12px; margin-bottom: 20px; border: 1px solid rgba(99, 102, 241, 0.2);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div style="font-weight: 600; color: var(--text-primary);">
                                ðŸ¤– AI Detected: <span style="color: #8b5cf6;">${patternDef.name}</span>
                            </div>
                            <div style="background: ${confidenceColor}; color: white; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600;">
                                ${confidencePercent}% confidence
                            </div>
                        </div>
                        ${patternReason ? `<div style="font-size: 13px; color: var(--text-secondary);">${patternReason}</div>` : ''}
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
                            ðŸ“Š Sheet: <strong>${excelImportState.selectedSheet}</strong> â€¢ ${totalRows} rows
                        </div>
                    </div>

                    <!-- Column Mappings -->
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 12px;">
                            Column Mappings <span style="font-weight: 400; color: var(--text-secondary); font-size: 12px;">(click to adjust)</span>
                        </div>
                        ${mappingCardsHTML}
                    </div>

                    ${qualityHTML}

                    <!-- Action Buttons -->
                    <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between;">
                        <button id="ai-import-adjust-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                            âš™ï¸ Adjust Mappings
                        </button>
                        <div style="display: flex; gap: 12px;">
                            <button id="ai-import-cancel-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                                Cancel
                            </button>
                            <button id="ai-import-confirm-btn" style="padding: 10px 24px; border: none; border-radius: 8px; background: linear-gradient(135deg, #10b981, #059669); color: white; cursor: pointer; font-size: 14px; font-weight: 600;" ${mapping.itemName === null ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                                âœ“ Import ${totalRows} Items
                            </button>
                        </div>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Event handlers
            document.getElementById('ai-import-cancel-btn').addEventListener('click', () => {
                modal.style.display = 'none';
            });

            document.getElementById('ai-import-adjust-btn').addEventListener('click', () => {
                showColumnMappingUI(); // Fall back to detailed mapping UI
            });

            document.getElementById('ai-import-confirm-btn').addEventListener('click', () => {
                if (mapping.itemName === null) {
                    alert('âŒ Item Name mapping is required');
                    return;
                }
                // Apply recommended pattern if different
                if (aiAnalysis?.recommendedPattern) {
                    const recKey = aiAnalysis.recommendedPattern.toLowerCase().replace(/[^a-z]/g, '');
                    if (PATTERNS[recKey]) {
                        document.getElementById('pattern-select').value = recKey;
                        currentPattern = recKey;
                    }
                }
                previewFlexibleImport();
            });

            // Make mapping cards clickable to adjust individual mappings
            document.querySelectorAll('.ai-mapping-card').forEach(card => {
                card.addEventListener('click', () => {
                    const fieldKey = card.dataset.field;
                    showQuickFieldMapping(fieldKey);
                });
            });
        }

        function showQuickFieldMapping(fieldKey) {
            const headers = excelImportState.headers;
            const currentMapping = excelImportState.columnMapping[fieldKey];

            const fieldLabels = {
                itemName: 'Item Name',
                phaseName: 'Phase/Category',
                description: 'Description',
                itemType: 'Item Type',
                dependencies: 'Dependencies'
            };

            const options = headers.map((h, i) =>
                `<option value="${i}" ${currentMapping === i ? 'selected' : ''}>${h}</option>`
            ).join('');

            const popup = document.createElement('div');
            popup.id = 'quick-mapping-popup';
            popup.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--card-bg); padding: 24px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); z-index: 10001; min-width: 300px;';
            popup.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 16px; color: var(--text-primary);">
                    Map: ${fieldLabels[fieldKey] || fieldKey}
                </div>
                <select id="quick-mapping-select" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); color: var(--text-primary); font-size: 14px; margin-bottom: 16px;">
                    <option value="">-- Skip this field --</option>
                    ${options}
                </select>
                <div style="display: flex; gap: 8px; justify-content: flex-end;">
                    <button id="quick-mapping-cancel" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; background: transparent; color: var(--text-primary); cursor: pointer;">Cancel</button>
                    <button id="quick-mapping-apply" style="padding: 8px 16px; border: none; border-radius: 6px; background: var(--treeplex-primary); color: white; cursor: pointer; font-weight: 600;">Apply</button>
                </div>
            `;

            // Add overlay
            const overlay = document.createElement('div');
            overlay.id = 'quick-mapping-overlay';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000;';

            document.body.appendChild(overlay);
            document.body.appendChild(popup);

            overlay.addEventListener('click', () => {
                popup.remove();
                overlay.remove();
            });

            document.getElementById('quick-mapping-cancel').addEventListener('click', () => {
                popup.remove();
                overlay.remove();
            });

            document.getElementById('quick-mapping-apply').addEventListener('click', () => {
                const select = document.getElementById('quick-mapping-select');
                const value = select.value === '' ? null : parseInt(select.value);
                excelImportState.columnMapping[fieldKey] = value;
                popup.remove();
                overlay.remove();
                showAIEnhancedMappingUI(); // Refresh the UI
            });
        }

        function autoSuggestColumnMappings(headers) {
            const mapping = {
                itemName: null,
                phaseName: null,
                description: null,
                itemType: null,
                dependencies: null
            };

            // Get current pattern for field suggestions
            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};

            // Try to match each header to a TreeListy field
            headers.forEach((header, index) => {
                const headerLower = header.toLowerCase().trim();

                // Match core fields
                if (headerLower.includes('name') || headerLower.includes('title') || headerLower.includes('item')) {
                    if (!mapping.itemName) mapping.itemName = index;
                } else if (headerLower.includes('phase') || headerLower.includes('quarter') || headerLower.includes('stage') || headerLower.includes('chapter') || headerLower.includes('category')) {
                    if (!mapping.phaseName) mapping.phaseName = index;
                } else if (headerLower.includes('description') || headerLower.includes('notes') || headerLower.includes('details')) {
                    if (!mapping.description) mapping.description = index;
                } else if (headerLower.includes('type') || headerLower.includes('status')) {
                    if (!mapping.itemType) mapping.itemType = index;
                } else if (headerLower.includes('depend') || headerLower.includes('prerequisite')) {
                    if (!mapping.dependencies) mapping.dependencies = index;
                }

                // Try to match pattern-specific fields
                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    if (!mapping[fieldKey] && fieldConfig.label) {
                        const fieldLabelLower = fieldConfig.label.toLowerCase().replace(/[^a-z0-9]/g, '');
                        const headerSimplified = headerLower.replace(/[^a-z0-9]/g, '');

                        // Check for similarity
                        if (fieldLabelLower === headerSimplified ||
                            fieldLabelLower.includes(headerSimplified) ||
                            headerSimplified.includes(fieldLabelLower)) {
                            mapping[fieldKey] = index;
                        }
                    }
                });
            });

            console.log('ðŸ” Auto-detected mappings:', mapping);
            return mapping;
        }

        function showColumnMappingUI() {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸŽ¯ Map Excel Columns to TreeListy Fields';

            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};
            const headers = excelImportState.headers;
            const sampleData = excelImportState.sampleData;
            const mapping = excelImportState.columnMapping;

            // Build mapping rows
            let mappingRowsHTML = '';

            // Core fields
            mappingRowsHTML += createMappingRow('Item Name', 'itemName', 'REQUIRED: Name of each item/task', mapping.itemName, true);
            mappingRowsHTML += createMappingRow('Phase/Category', 'phaseName', 'Group items by phase (optional)', mapping.phaseName, false);
            mappingRowsHTML += createMappingRow('Description', 'description', 'Item description', mapping.description, false);
            mappingRowsHTML += createMappingRow('Item Type', 'itemType', 'Type/category of item', mapping.itemType, false);

            // Pattern-specific fields
            Object.keys(fields).forEach(fieldKey => {
                const fieldConfig = fields[fieldKey];
                if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                    return;
                }

                if (fieldConfig.label) {
                    const helpText = fieldConfig.helpText || `${fieldConfig.label} field`;
                    mappingRowsHTML += createMappingRow(
                        fieldConfig.label,
                        fieldKey,
                        helpText,
                        mapping[fieldKey],
                        false
                    );
                }
            });

            // Dependencies
            mappingRowsHTML += createMappingRow('Dependencies', 'dependencies', 'Comma-separated list of dependencies', mapping.dependencies, false);

            modalBody.innerHTML = `
                <div style="padding: 20px; max-height: 70vh; overflow-y: auto;">
                    <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 16px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.6;">
                            ðŸ“‹ <strong>Sheet:</strong> ${excelImportState.selectedSheet}<br>
                            ðŸŽ¨ <strong>Pattern:</strong> ${patternDef.name}<br>
                            ðŸ“Š <strong>Rows:</strong> ${excelImportState.sampleData.length + ' (preview) / ' + (XLSX.utils.sheet_to_json(excelImportState.workbook.Sheets[excelImportState.selectedSheet], { header: 1 }).length - 1) + ' (total)'}
                        </div>
                    </div>

                    <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                        Map your Excel columns to TreeListy fields. We've pre-selected likely matches.
                    </p>

                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border);">
                                <th style="text-align: left; padding: 8px; font-size: 13px; color: var(--text-secondary);">TreeListy Field</th>
                                <th style="text-align: left; padding: 8px; font-size: 13px; color: var(--text-secondary);">Excel Column</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${mappingRowsHTML}
                        </tbody>
                    </table>

                    <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: flex-end;">
                        <button id="cancel-mapping-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                            Cancel
                        </button>
                        <button id="preview-import-btn" style="padding: 10px 20px; border: none; border-radius: 8px; background: var(--treeplex-primary); color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Preview Import â†’
                        </button>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Update mapping when dropdowns change
            document.querySelectorAll('.column-mapping-select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const fieldKey = e.target.dataset.field;
                    const columnIndex = e.target.value === '' ? null : parseInt(e.target.value);
                    excelImportState.columnMapping[fieldKey] = columnIndex;
                    console.log('ðŸ”„ Updated mapping:', fieldKey, 'â†’', columnIndex);
                });
            });

            // Cancel button
            document.getElementById('cancel-mapping-btn').addEventListener('click', () => {
                modal.style.display = 'none';
            });

            // Preview button
            document.getElementById('preview-import-btn').addEventListener('click', () => {
                // Validate required fields
                if (excelImportState.columnMapping.itemName === null) {
                    alert('âŒ Required Field Missing\n\nYou must map the "Item Name" field to import.');
                    return;
                }

                previewFlexibleImport();
            });
        }

        function createMappingRow(label, fieldKey, helpText, selectedValue, required) {
            const requiredBadge = required ? '<span style="color: var(--error); margin-left: 4px;">*</span>' : '';

            // Build options with proper selected attribute
            const headers = excelImportState.headers;
            const sampleData = excelImportState.sampleData;

            let options = '<option value="">-- Skip this column --</option>';
            headers.forEach((h, i) => {
                const isSelected = (selectedValue !== null && selectedValue !== undefined && selectedValue === i) ? 'selected' : '';
                options += `<option value="${i}" ${isSelected}>${h} (sample: ${sampleData[0]?.[i] || 'N/A'})</option>`;
            });

            return `
                <tr style="border-bottom: 1px solid var(--border);">
                    <td style="padding: 12px 8px;">
                        <div style="font-weight: 500; font-size: 14px;">
                            ${label}${requiredBadge}
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">
                            ${helpText}
                        </div>
                    </td>
                    <td style="padding: 12px 8px;">
                        <select class="column-mapping-select" data-field="${fieldKey}" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px;">
                            ${options}
                        </select>
                    </td>
                </tr>
            `;
        }

        function previewFlexibleImport() {
            console.log('ðŸ‘€ Generating preview...');

            const sheet = excelImportState.workbook.Sheets[excelImportState.selectedSheet];
            const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            // Find header row
            let headerRowIndex = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] && data[i].some(cell => cell !== '' && cell !== null && cell !== undefined)) {
                    headerRowIndex = i;
                    break;
                }
            }

            const rows = data.slice(headerRowIndex + 1).filter(row => row && row.length > 0);
            const mapping = excelImportState.columnMapping;
            const patternDef = PATTERNS[currentPattern];
            const fields = patternDef.fields || {};

            // Extract items
            const importedItems = [];
            const phaseMap = {};

            rows.forEach((row, rowIndex) => {
                // Skip empty rows
                if (!row[mapping.itemName] || row[mapping.itemName] === '') {
                    return;
                }

                const item = {
                    name: row[mapping.itemName] || `Item ${rowIndex + 1}`,
                    description: mapping.description !== null ? (row[mapping.description] || '') : '',
                    itemType: mapping.itemType !== null ? (row[mapping.itemType] || '') : '',
                    type: 'item',
                    icon: 'ðŸ“¦'
                };

                // Map pattern-specific fields
                Object.keys(fields).forEach(fieldKey => {
                    const fieldConfig = fields[fieldKey];
                    if (fieldKey === 'includeDependencies' || fieldKey === 'includeTracking' || fieldKey === 'trackingFor') {
                        return;
                    }

                    const columnIndex = mapping[fieldKey];
                    if (columnIndex !== null && columnIndex !== undefined && row[columnIndex] !== undefined && row[columnIndex] !== '') {
                        let value = row[columnIndex];

                        // Type conversion
                        if (fieldConfig.type === 'number') {
                            value = parseFloat(value) || 0;
                            // Handle special scaling
                            if (fieldKey === 'cost' && fieldConfig.label && fieldConfig.label.includes('($M)')) {
                                value = value * 1000000;
                            } else if (fieldKey === 'dealValue') {
                                value = value * 1000;
                            }
                        }

                        item[fieldKey] = value;
                    }
                });

                // Handle dependencies
                if (mapping.dependencies !== null && row[mapping.dependencies]) {
                    const depString = String(row[mapping.dependencies]);
                    if (depString !== '' && depString.toLowerCase() !== 'none') {
                        item.dependencies = depString.split(/[,;|]/).map(d => d.trim()).filter(d => d);
                    }
                }

                // Determine phase
                const phaseName = mapping.phaseName !== null && row[mapping.phaseName]
                    ? String(row[mapping.phaseName])
                    : 'Default Phase';

                if (!phaseMap[phaseName]) {
                    phaseMap[phaseName] = [];
                }

                phaseMap[phaseName].push(item);
                importedItems.push(item);
            });

            // Generate preview HTML
            let previewHTML = '<div style="padding: 20px; max-height: 70vh; overflow-y: auto;">';

            previewHTML += `
                <div style="background: linear-gradient(135deg, rgba(29, 111, 66, 0.1), rgba(0, 166, 125, 0.1)); padding: 16px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 12px 0; color: var(--treeplex-primary);">ðŸ“Š Import Preview</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; font-size: 14px;">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Pattern</div>
                            <div style="font-weight: 600;">${patternDef.icon} ${patternDef.name}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Phases</div>
                            <div style="font-weight: 600;">${Object.keys(phaseMap).length}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 12px;">Items</div>
                            <div style="font-weight: 600;">${importedItems.length}</div>
                        </div>
                    </div>
                </div>
            `;

            // Show preview of first 10 items
            previewHTML += '<div style="font-weight: 600; margin-bottom: 12px;">Preview (first 10 items):</div>';
            previewHTML += '<div style="font-family: monospace; font-size: 12px; background: var(--bg-secondary); padding: 16px; border-radius: 8px; line-height: 1.8;">';

            let itemCount = 0;
            Object.keys(phaseMap).forEach((phaseName, phaseIndex) => {
                if (itemCount >= 10) return;

                previewHTML += `<div style="color: var(--treeplex-primary); font-weight: 600; margin-top: ${phaseIndex > 0 ? '12px' : '0'};">${phaseName}</div>`;

                phaseMap[phaseName].forEach((item, itemIndex) => {
                    if (itemCount >= 10) return;
                    itemCount++;

                    previewHTML += `<div style="margin-left: 20px; color: var(--text-primary);">â”œâ”€ ${item.name}`;
                    if (item.itemType) previewHTML += ` [${item.itemType}]`;
                    if (item.dependencies && item.dependencies.length > 0) {
                        previewHTML += ` <span style="color: var(--text-secondary);">â†’ Depends on: ${item.dependencies.join(', ')}</span>`;
                    }
                    previewHTML += `</div>`;
                });
            });

            if (importedItems.length > 10) {
                previewHTML += `<div style="color: var(--text-secondary); margin-top: 8px;">... and ${importedItems.length - 10} more items</div>`;
            }

            previewHTML += '</div>';

            // Action buttons
            previewHTML += `
                <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: space-between;">
                    <button id="back-to-mapping-btn" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 14px;">
                        â† Back to Mapping
                    </button>
                    <div style="display: flex; gap: 12px;">
                        <button id="execute-import-replace-btn" style="padding: 10px 20px; border: none; border-radius: 8px; background: var(--treeplex-primary); color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Replace Current Tree
                        </button>
                        <button id="execute-import-append-btn" style="padding: 10px 20px; border: 1px solid var(--treeplex-primary); border-radius: 8px; background: transparent; color: var(--treeplex-primary); cursor: pointer; font-size: 14px; font-weight: 600;">
                            Append to Tree
                        </button>
                    </div>
                </div>
            `;

            previewHTML += '</div>';

            // Show modal
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ‘€ Preview Import';
            modalBody.innerHTML = previewHTML;
            modal.style.display = 'flex';

            // Store preview data
            excelImportState.previewData = { phaseMap, importedItems };

            // Button handlers
            document.getElementById('back-to-mapping-btn').addEventListener('click', () => {
                showColumnMappingUI();
            });

            document.getElementById('execute-import-replace-btn').addEventListener('click', () => {
                executeFlexibleImport('replace');
            });

            document.getElementById('execute-import-append-btn').addEventListener('click', () => {
                executeFlexibleImport('append');
            });
        }

        function executeFlexibleImport(mode) {
            console.log('ðŸš€ Executing import in', mode, 'mode...');

            const { phaseMap, importedItems } = excelImportState.previewData;
            const patternDef = PATTERNS[currentPattern];

            saveState(`Excel Import: ${mode === 'replace' ? 'Replace' : 'Append'}`);

            if (mode === 'replace') {
                // Create new tree from scratch
                const phases = Object.keys(phaseMap).map((phaseName, phaseIndex) => {
                    return {
                        id: `phase-${phaseIndex}`,
                        type: 'phase',
                        phase: phaseIndex,
                        name: phaseName,
                        subtitle: '',
                        icon: `${phaseIndex + 1}ï¸âƒ£`,
                        expanded: false,
                        items: phaseMap[phaseName].map((item, itemIndex) => ({
                            ...item,
                            id: `item-${phaseIndex}-${itemIndex}`
                        }))
                    };
                });

                capexTree = {
                    id: 'root',
                    type: 'root',
                    name: `Imported from ${excelImportState.file}`,
                    icon: 'ðŸŒ³',
                    expanded: true,
                    hyperedges: [], // Initialize empty hyperedges array to prevent data loss
                    children: phases,
                    pattern: {
                        key: currentPattern,
                        labels: patternDef.levels
                    }
                };

            } else {
                // Append mode
                if (!capexTree.children) capexTree.children = [];

                Object.keys(phaseMap).forEach((phaseName) => {
                    // Try to find existing phase
                    let existingPhase = capexTree.children.find(p => p.name === phaseName);

                    if (existingPhase) {
                        // Append items to existing phase
                        const currentItemCount = existingPhase.items?.length || 0;
                        const phaseIndex = capexTree.children.indexOf(existingPhase);

                        const newItems = phaseMap[phaseName].map((item, idx) => ({
                            ...item,
                            id: `item-${phaseIndex}-${currentItemCount + idx}`
                        }));

                        existingPhase.items = [...(existingPhase.items || []), ...newItems];
                    } else {
                        // Create new phase
                        const phaseIndex = capexTree.children.length;
                        const newPhase = {
                            id: `phase-${phaseIndex}`,
                            type: 'phase',
                            phase: phaseIndex,
                            name: phaseName,
                            subtitle: '',
                            icon: `${phaseIndex + 1}ï¸âƒ£`,
                            expanded: false,
                            items: phaseMap[phaseName].map((item, itemIndex) => ({
                                ...item,
                                id: `item-${phaseIndex}-${itemIndex}`
                            }))
                        };

                        capexTree.children.push(newPhase);
                    }
                });
            }

            // Update UI
            render();
            document.getElementById('modal').style.display = 'none';

            showToast(`âœ… Excel imported! ${importedItems.length} items ${mode === 'replace' ? 'loaded' : 'added'}`);
            console.log('âœ… Flexible import complete');
        }

        // Excel Import button handler
        document.getElementById('excel-import-btn').addEventListener('click', () => {
            document.getElementById('excel-upload-input').click();
        });

        // ============================================
        // LOAD FROM GOOGLE DRIVE MODAL
        // ============================================

        const RECENT_GDRIVE_KEY = 'treelisty-recent-gdrive';
        const MAX_RECENT_FILES = 8;

        // Get recent Google Drive files from localStorage
        function getRecentGdriveFiles() {
            try {
                return JSON.parse(localStorage.getItem(RECENT_GDRIVE_KEY) || '[]');
            } catch {
                return [];
            }
        }

        // Add a file to recent list
        function addToRecentGdrive(fileId, projectName, pattern) {
            const recent = getRecentGdriveFiles();
            // Remove if already exists
            const filtered = recent.filter(f => f.fileId !== fileId);
            // Add to front
            filtered.unshift({
                fileId,
                projectName: projectName || 'Untitled Project',
                pattern: pattern || 'generic',
                loadedAt: new Date().toISOString()
            });
            // Keep only max
            const trimmed = filtered.slice(0, MAX_RECENT_FILES);
            localStorage.setItem(RECENT_GDRIVE_KEY, JSON.stringify(trimmed));
            return trimmed;
        }

        // Render recent files list
        function renderRecentGdriveList() {
            const section = document.getElementById('recent-gdrive-section');
            const list = document.getElementById('recent-gdrive-list');
            const recent = getRecentGdriveFiles();

            if (recent.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            list.innerHTML = recent.map((file, idx) => {
                const date = new Date(file.loadedAt);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const patternEmoji = {
                    philosophy: 'ðŸ›ï¸', sales: 'ðŸ’¼', film: 'ðŸŽ¬', capex: 'ðŸ’°',
                    generic: 'ðŸ“‹', academic: 'ðŸŽ“', product: 'ðŸš€', book: 'ðŸ“š'
                }[file.pattern] || 'ðŸ“„';

                return `
                    <div class="recent-gdrive-item" data-file-id="${file.fileId}"
                        style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--card-bg); border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s; border: 1px solid var(--border);"
                        onmouseover="this.style.borderColor='#4285f4'; this.style.transform='translateX(4px)'"
                        onmouseout="this.style.borderColor='var(--border)'; this.style.transform='none'">
                        <div style="font-size: 24px;">${patternEmoji}</div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 600; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${file.projectName}
                            </div>
                            <div style="font-size: 11px; color: var(--text-secondary);">
                                ${dateStr}
                            </div>
                        </div>
                        <div style="font-size: 16px; color: var(--text-secondary);">â†’</div>
                    </div>
                `;
            }).join('');

            // Add click handlers
            list.querySelectorAll('.recent-gdrive-item').forEach(item => {
                item.addEventListener('click', () => {
                    const fileId = item.dataset.fileId;
                    loadFromGoogleDrive(fileId);
                });
            });
        }

        // Load tree from Google Drive file ID
        async function loadFromGoogleDrive(fileId) {
            const modal = document.getElementById('load-gdrive-modal');
            const loadBtn = document.getElementById('gdrive-load-btn');
            const originalText = loadBtn.textContent;

            try {
                loadBtn.textContent = 'â³ Loading...';
                loadBtn.disabled = true;

                showToast('â˜ï¸ Loading from Google Drive...', 'info');

                const proxyUrl = `/.netlify/functions/gdrive-proxy?id=${fileId}`;
                const response = await fetch(proxyUrl);
                const result = await response.json();

                if (!response.ok || result.error) {
                    throw new Error(result.error || 'Failed to fetch from Google Drive');
                }

                // Load the tree data
                capexTree = result;

                // Update pattern if present
                if (result.pattern) {
                    const patternKey = getPatternKey(result.pattern);
                    if (patternKey) {
                        currentPattern = patternKey;
                        const patternSelect = document.getElementById('pattern-select');
                        if (patternSelect) patternSelect.value = currentPattern;
                        if (currentPattern === 'custom' && result.pattern.labels) {
                            customPatternNames = result.pattern.labels;
                        }
                        if (typeof updateSortDropdown === 'function') updateSortDropdown();
                        if (typeof updateAIButtonLabel === 'function') updateAIButtonLabel();
                    }
                }

                // Add to recent files
                addToRecentGdrive(fileId, result.name || result.projectName || 'Untitled', currentPattern);

                // Close modal
                modal.style.display = 'none';

                // Render
                render();
                if (viewMode === 'canvas') renderCanvas();

                showToast('âœ… Loaded from Google Drive!', 'success');
                console.log('â˜ï¸ Loaded from Google Drive:', fileId);

            } catch (error) {
                console.error('âŒ Failed to load from Google Drive:', error);
                showToast('âŒ ' + (error.message || 'Failed to load. Check the link is publicly shared.'), 'error');
            } finally {
                loadBtn.textContent = originalText;
                loadBtn.disabled = false;
            }
        }

        // Extract file ID from various Google Drive URL formats
        function extractGdriveFileId(input) {
            if (!input) return null;

            // Already just an ID
            if (/^[a-zA-Z0-9_-]{20,}$/.test(input.trim())) {
                return input.trim();
            }

            // /d/FILE_ID format
            const dMatch = input.match(/\/d\/([a-zA-Z0-9_-]+)/);
            if (dMatch) return dMatch[1];

            // ?id=FILE_ID format
            const idMatch = input.match(/[?&]id=([a-zA-Z0-9_-]+)/);
            if (idMatch) return idMatch[1];

            // /open?id=FILE_ID format
            const openMatch = input.match(/\/open\?id=([a-zA-Z0-9_-]+)/);
            if (openMatch) return openMatch[1];

            return null;
        }

        // Initialize Load from Google Drive modal
        document.getElementById('load-gdrive-btn').addEventListener('click', () => {
            const modal = document.getElementById('load-gdrive-modal');
            modal.style.display = 'flex';
            document.getElementById('gdrive-url-input').value = '';
            document.getElementById('gdrive-url-input').focus();
            renderRecentGdriveList();
        });

        document.getElementById('load-gdrive-close').addEventListener('click', () => {
            document.getElementById('load-gdrive-modal').style.display = 'none';
        });

        document.getElementById('gdrive-load-btn').addEventListener('click', () => {
            const input = document.getElementById('gdrive-url-input').value.trim();
            const fileId = extractGdriveFileId(input);
            if (fileId) {
                loadFromGoogleDrive(fileId);
            } else {
                showToast('âŒ Could not parse Google Drive URL. Try pasting the share link.', 'error');
            }
        });

        // Allow Enter key to submit
        document.getElementById('gdrive-url-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('gdrive-load-btn').click();
            }
        });

        // Clear recent files
        document.getElementById('clear-recent-gdrive').addEventListener('click', () => {
            localStorage.removeItem(RECENT_GDRIVE_KEY);
            renderRecentGdriveList();
            showToast('Recent files cleared', 'info');
        });

        // Close modal on backdrop click
        document.getElementById('load-gdrive-modal').addEventListener('click', (e) => {
            if (e.target.id === 'load-gdrive-modal') {
                e.target.style.display = 'none';
            }
        });

        // Google Drive Refresh button handler
        document.getElementById('refresh-drive-btn').addEventListener('click', async () => {
            const btn = document.getElementById('refresh-drive-btn');
            const originalText = btn.textContent;

            try {
                // Check if current tree has source metadata
                const hasSourceMetadata = capexTree?.source?.type === 'google-drive';

                if (!hasSourceMetadata) {
                    // No source metadata - inform user
                    const proceed = confirm(
                        'âš ï¸ No Google Drive source detected!\n\n' +
                        'This will scan your entire Google Drive.\n\n' +
                        'Tip: Load a Google Drive JSON first, then click Refresh to update only that tree.\n\n' +
                        'Continue with full scan?'
                    );
                    if (!proceed) return;
                }

                // Show loading state
                btn.textContent = 'â³ Refreshing...';
                btn.disabled = true;
                btn.style.opacity = '0.6';

                console.log('â˜ï¸ Refreshing from Google Drive...');
                if (hasSourceMetadata) {
                    console.log('ðŸ“‹ Using source metadata from loaded tree:', capexTree.source);
                }

                // Prepare request body with source metadata (if available)
                const requestBody = hasSourceMetadata ? {
                    source: capexTree.source
                } : {};

                // Call local server to trigger export and get data
                const response = await fetch('http://localhost:5000/refresh-google-drive', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Server request failed');
                }

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'Unknown error');
                }

                console.log('âœ… Received data from server:', result.filename);

                // Auto-import the data
                const treeData = result.data;

                // Detect pattern
                const detectedPattern = treeData.pattern?.key || 'filesystem';
                console.log(`ðŸ“‹ Pattern detected: ${detectedPattern}`);

                // Load directly without preview modal
                if (PATTERNS[detectedPattern]) {
                    currentPattern = detectedPattern;
                    capexTree = treeData;

                    // Update pattern dropdown
                    const patternSelect = document.getElementById('pattern-select');
                    if (patternSelect) {
                        patternSelect.value = detectedPattern;
                    }

                    // Re-render the tree
                    render();

                    // Update sort dropdown options for the loaded pattern
                    updateSortDropdown();

                    // Apply default sort for filesystem pattern (folders first + alphabetical)
                    if (detectedPattern === 'filesystem') {
                        sortTree(null); // This will trigger the default filesystem sort
                    }

                    // Build success message with source info
                    let successMessage = `âœ… Google Drive refreshed successfully!\n\n`;
                    successMessage += `File: ${result.filename}\n`;
                    successMessage += `Size: ${(result.fileSize / 1024).toFixed(1)} KB\n`;
                    successMessage += `Pattern: ${PATTERNS[detectedPattern].name}\n`;

                    if (treeData.source) {
                        successMessage += `\nðŸ“‹ Source Info:\n`;
                        successMessage += `Type: ${treeData.source.type}\n`;
                        successMessage += `Folder: ${treeData.source.folderName}\n`;
                        successMessage += `Depth: ${treeData.source.syncDepth} levels\n`;

                        if (treeData.source.lastSync) {
                            const syncDate = new Date(treeData.source.lastSync);
                            successMessage += `Last Synced: ${syncDate.toLocaleString()}`;
                        }
                    }

                    alert(successMessage);

                    console.log('âœ… Google Drive data loaded successfully');
                } else {
                    throw new Error(`Unknown pattern: ${detectedPattern}`);
                }

            } catch (error) {
                console.error('âŒ Refresh failed:', error);

                // Check if server is running
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    alert('âŒ Cannot connect to local server!\n\nPlease start the server first:\n\n1. Open a terminal\n2. Run: python treelisty_server.py\n3. Keep it running\n4. Try again');
                } else {
                    alert(`âŒ Refresh failed:\n\n${error.message}`);
                }
            } finally {
                // Restore button state
                btn.textContent = originalText;
                btn.disabled = false;
                btn.style.opacity = '1';
            }
        });

        // Excel file upload handler
        document.getElementById('excel-upload-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                console.log('ðŸ“¥ Excel file selected:', file.name);
                importFromExcel(file);
            }
            // Reset input
            e.target.value = '';
        });

        // =============================================================================
        // MS PROJECT XML IMPORT - Import from MS Project XML export
        // =============================================================================

        /**
         * Parse MS Project XML (MSPDI format) and convert to TreeListy format
         * Users export from MS Project via: File â†’ Save As â†’ XML Format
         */
        function parseMSProjectXML(xmlString) {
            console.log('ðŸ“… Parsing MS Project XML...');
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');

            // Check for parsing errors
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                throw new Error('Invalid XML file: ' + parseError.textContent);
            }

            // Check if this is MS Project XML (MSPDI format)
            const projectNode = xmlDoc.querySelector('Project');
            if (!projectNode) {
                throw new Error('This does not appear to be an MS Project XML file. Please export from MS Project using File â†’ Save As â†’ XML Format.');
            }

            // Extract project metadata
            const projectName = xmlDoc.querySelector('Project > Name')?.textContent ||
                               xmlDoc.querySelector('Project > Title')?.textContent ||
                               'Imported MS Project';
            const projectStart = xmlDoc.querySelector('Project > StartDate')?.textContent;
            const projectFinish = xmlDoc.querySelector('Project > FinishDate')?.textContent;

            console.log('ðŸ“… Project:', projectName);

            // Build resource map (UID â†’ Name)
            const resourceMap = new Map();
            const resources = xmlDoc.querySelectorAll('Resources > Resource');
            resources.forEach(resource => {
                const uid = resource.querySelector('UID')?.textContent;
                const name = resource.querySelector('Name')?.textContent;
                if (uid && name) {
                    resourceMap.set(uid, name);
                }
            });
            console.log('ðŸ‘¥ Resources found:', resourceMap.size);

            // Build assignment map (TaskUID â†’ ResourceNames)
            const assignmentMap = new Map();
            const assignments = xmlDoc.querySelectorAll('Assignments > Assignment');
            assignments.forEach(assignment => {
                const taskUID = assignment.querySelector('TaskUID')?.textContent;
                const resourceUID = assignment.querySelector('ResourceUID')?.textContent;
                if (taskUID && resourceUID && resourceMap.has(resourceUID)) {
                    const existing = assignmentMap.get(taskUID) || [];
                    existing.push(resourceMap.get(resourceUID));
                    assignmentMap.set(taskUID, existing);
                }
            });

            // Parse all tasks
            const tasks = xmlDoc.querySelectorAll('Tasks > Task');
            const taskList = [];
            const taskUIDMap = new Map(); // UID â†’ task data for dependency resolution

            tasks.forEach(task => {
                const uid = task.querySelector('UID')?.textContent;
                const id = task.querySelector('ID')?.textContent;
                const name = task.querySelector('Name')?.textContent;
                const outlineLevel = parseInt(task.querySelector('OutlineLevel')?.textContent || '0');
                const wbs = task.querySelector('WBS')?.textContent || '';
                const isSummary = task.querySelector('Summary')?.textContent === '1';
                const notes = task.querySelector('Notes')?.textContent || '';

                // Skip the root project task (outline level 0, usually ID 0)
                if (outlineLevel === 0 && id === '0') return;

                // Dates (convert from MS Project format)
                const startDate = task.querySelector('Start')?.textContent;
                const finishDate = task.querySelector('Finish')?.textContent;

                // Duration (PT format: PT8H0M0S = 8 hours)
                const durationRaw = task.querySelector('Duration')?.textContent || '';
                const duration = parseMSProjectDuration(durationRaw);

                // Progress
                const percentComplete = parseInt(task.querySelector('PercentComplete')?.textContent || '0');

                // Cost
                const cost = parseFloat(task.querySelector('Cost')?.textContent || '0');

                // Priority (MS Project uses 0-1000, 500 is normal)
                const priorityRaw = parseInt(task.querySelector('Priority')?.textContent || '500');
                const priority = mapMSProjectPriority(priorityRaw);

                // Status based on percent complete
                const status = percentComplete === 0 ? 'To Do' :
                              percentComplete === 100 ? 'Done' : 'In Progress';

                // Get assigned resources
                const assignees = assignmentMap.get(uid) || [];

                // Parse predecessor links (dependencies)
                const predecessorUIDs = [];
                const predecessorLinks = task.querySelectorAll('PredecessorLink');
                predecessorLinks.forEach(link => {
                    const predUID = link.querySelector('PredecessorUID')?.textContent;
                    if (predUID) predecessorUIDs.push(predUID);
                });

                const taskData = {
                    uid,
                    id,
                    name: name || 'Unnamed Task',
                    outlineLevel,
                    wbs,
                    isSummary,
                    description: notes,
                    startDate: formatMSProjectDate(startDate),
                    finishDate: formatMSProjectDate(finishDate),
                    duration,
                    percentComplete,
                    cost,
                    priority,
                    status,
                    assignees,
                    predecessorUIDs
                };

                taskList.push(taskData);
                taskUIDMap.set(uid, taskData);
            });

            console.log('ðŸ“‹ Tasks parsed:', taskList.length);

            // Convert flat task list to hierarchical TreeListy structure
            const treeData = convertMSProjectToTreeListy(taskList, taskUIDMap, projectName);

            return treeData;
        }

        /**
         * Parse MS Project duration format (PT8H0M0S) to readable string
         */
        function parseMSProjectDuration(ptDuration) {
            if (!ptDuration) return '';

            // Match PT[n]H[n]M[n]S pattern
            const match = ptDuration.match(/PT(\d+)H(\d+)M(\d+)S/);
            if (!match) return ptDuration;

            const hours = parseInt(match[1]);
            const minutes = parseInt(match[2]);

            if (hours >= 8) {
                const days = Math.floor(hours / 8);
                const remainingHours = hours % 8;
                if (days > 0 && remainingHours === 0) {
                    return days === 1 ? '1 day' : `${days} days`;
                } else if (days > 0) {
                    return `${days}d ${remainingHours}h`;
                }
            }

            if (hours > 0 && minutes > 0) {
                return `${hours}h ${minutes}m`;
            } else if (hours > 0) {
                return `${hours} hours`;
            } else if (minutes > 0) {
                return `${minutes} minutes`;
            }

            return '';
        }

        /**
         * Map MS Project priority (0-1000) to TreeListy priority
         */
        function mapMSProjectPriority(msPriority) {
            if (msPriority <= 300) return 'Low';
            if (msPriority <= 700) return 'Medium';
            return 'High';
        }

        /**
         * Format MS Project date to YYYY-MM-DD
         */
        function formatMSProjectDate(dateStr) {
            if (!dateStr) return '';
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return '';
                return date.toISOString().split('T')[0];
            } catch {
                return '';
            }
        }

        /**
         * Convert flat MS Project task list to TreeListy hierarchical structure
         */
        function convertMSProjectToTreeListy(taskList, taskUIDMap, projectName) {
            // Group tasks by outline level to build hierarchy
            // OutlineLevel 1 = Phases (Summary tasks)
            // OutlineLevel 2 = Items
            // OutlineLevel 3+ = Subtasks

            // Check if this is a flat task list (all tasks at level 1, no deeper hierarchy)
            const maxLevel = Math.max(...taskList.map(t => t.outlineLevel));
            const isFlatList = maxLevel <= 1;

            if (isFlatList) {
                console.log('ðŸ“‹ Flat task list detected - grouping tasks as items under project phases');
                return convertFlatMSProjectToTreeListy(taskList, taskUIDMap, projectName);
            }

            const phases = [];
            let currentPhase = null;
            let currentItem = null;

            // Build UID to TreeListy ID mapping for dependencies
            const uidToIdMap = new Map();
            let phaseIndex = 0;
            let itemIndex = 0;
            let subtaskIndex = 0;

            taskList.forEach((task, index) => {
                if (task.outlineLevel === 1 || (task.isSummary && task.outlineLevel <= 1)) {
                    // This is a phase (top-level summary task)
                    itemIndex = 0;
                    const phaseId = `phase-${phaseIndex}`;
                    uidToIdMap.set(task.uid, phaseId);

                    currentPhase = {
                        name: task.name,
                        subtitle: task.wbs || '',
                        icon: 'ðŸ“',
                        items: []
                    };
                    phases.push(currentPhase);
                    currentItem = null;
                    phaseIndex++;
                } else if (task.outlineLevel === 2 || (task.isSummary && task.outlineLevel === 2)) {
                    // This is an item
                    if (!currentPhase) {
                        // Create default phase if none exists
                        currentPhase = {
                            name: 'Tasks',
                            subtitle: '',
                            icon: 'ðŸ“',
                            items: []
                        };
                        phases.push(currentPhase);
                    }

                    subtaskIndex = 0;
                    const itemId = `item-${phaseIndex > 0 ? phaseIndex - 1 : 0}-${itemIndex}`;
                    uidToIdMap.set(task.uid, itemId);

                    currentItem = {
                        name: task.name,
                        description: task.description || (task.wbs ? `WBS: ${task.wbs}` : ''),
                        cost: task.cost || 0,
                        leadTime: task.duration || '',
                        pmStatus: task.status,
                        pmProgress: task.percentComplete,
                        pmAssignee: task.assignees.join(', ') || 'Unassigned',
                        pmPriority: task.priority,
                        pmStartDate: task.startDate,
                        pmDueDate: task.finishDate,
                        pmNotes: '',
                        dependencies: [], // Will be resolved later
                        _predecessorUIDs: task.predecessorUIDs,
                        subtasks: []
                    };
                    currentPhase.items.push(currentItem);
                    itemIndex++;
                } else if (task.outlineLevel >= 3) {
                    // This is a subtask
                    if (!currentItem) {
                        // Create default item if none exists
                        if (!currentPhase) {
                            currentPhase = {
                                name: 'Tasks',
                                subtitle: '',
                                icon: 'ðŸ“',
                                items: []
                            };
                            phases.push(currentPhase);
                        }
                        currentItem = {
                            name: 'Tasks',
                            description: '',
                            cost: 0,
                            leadTime: '',
                            pmStatus: 'To Do',
                            pmProgress: 0,
                            pmAssignee: 'Unassigned',
                            pmPriority: 'Medium',
                            pmStartDate: '',
                            pmDueDate: '',
                            pmNotes: '',
                            dependencies: [],
                            _predecessorUIDs: [],
                            subtasks: []
                        };
                        currentPhase.items.push(currentItem);
                    }

                    const subtaskId = `subtask-${phaseIndex > 0 ? phaseIndex - 1 : 0}-${itemIndex > 0 ? itemIndex - 1 : 0}-${subtaskIndex}`;
                    uidToIdMap.set(task.uid, subtaskId);

                    const subtask = {
                        name: task.name,
                        description: task.description || '',
                        pmStatus: task.status,
                        pmProgress: task.percentComplete,
                        pmAssignee: task.assignees.join(', ') || 'Unassigned',
                        pmPriority: task.priority,
                        pmStartDate: task.startDate,
                        pmDueDate: task.finishDate,
                        cost: task.cost || 0,
                        dependencies: [],
                        _predecessorUIDs: task.predecessorUIDs
                    };
                    currentItem.subtasks.push(subtask);
                    subtaskIndex++;
                } else {
                    // OutlineLevel 0 or unknown - treat as item in default phase
                    if (!currentPhase) {
                        currentPhase = {
                            name: 'Project Tasks',
                            subtitle: '',
                            icon: 'ðŸ“',
                            items: []
                        };
                        phases.push(currentPhase);
                    }

                    const itemId = `item-0-${itemIndex}`;
                    uidToIdMap.set(task.uid, itemId);

                    currentItem = {
                        name: task.name,
                        description: task.description || '',
                        cost: task.cost || 0,
                        leadTime: task.duration || '',
                        pmStatus: task.status,
                        pmProgress: task.percentComplete,
                        pmAssignee: task.assignees.join(', ') || 'Unassigned',
                        pmPriority: task.priority,
                        pmStartDate: task.startDate,
                        pmDueDate: task.finishDate,
                        pmNotes: '',
                        dependencies: [],
                        _predecessorUIDs: task.predecessorUIDs,
                        subtasks: []
                    };
                    currentPhase.items.push(currentItem);
                    itemIndex++;
                }
            });

            // Resolve dependencies using UID map
            phases.forEach(phase => {
                phase.items.forEach(item => {
                    if (item._predecessorUIDs && item._predecessorUIDs.length > 0) {
                        item.dependencies = item._predecessorUIDs
                            .map(uid => uidToIdMap.get(uid))
                            .filter(id => id);
                    }
                    delete item._predecessorUIDs;

                    // Resolve subtask dependencies too
                    if (item.subtasks) {
                        item.subtasks.forEach(subtask => {
                            if (subtask._predecessorUIDs && subtask._predecessorUIDs.length > 0) {
                                subtask.dependencies = subtask._predecessorUIDs
                                    .map(uid => uidToIdMap.get(uid))
                                    .filter(id => id);
                            }
                            delete subtask._predecessorUIDs;
                        });
                    }
                });
            });

            // If no phases were created, create one default phase with all tasks as items
            if (phases.length === 0) {
                phases.push({
                    name: 'Project Tasks',
                    subtitle: '',
                    icon: 'ðŸ“',
                    items: taskList.map((task, i) => ({
                        name: task.name,
                        description: task.description || '',
                        cost: task.cost || 0,
                        leadTime: task.duration || '',
                        pmStatus: task.status,
                        pmProgress: task.percentComplete,
                        pmAssignee: task.assignees.join(', ') || 'Unassigned',
                        pmPriority: task.priority,
                        pmStartDate: task.startDate,
                        pmDueDate: task.finishDate,
                        dependencies: [],
                        subtasks: []
                    }))
                });
            }

            const totalItems = phases.reduce((sum, p) => sum + p.items.length, 0);
            const totalSubtasks = phases.reduce((sum, p) =>
                sum + p.items.reduce((s, i) => s + (i.subtasks?.length || 0), 0), 0);

            console.log(`ðŸ“Š Converted: ${phases.length} phases, ${totalItems} items, ${totalSubtasks} subtasks`);

            return {
                projectName,
                phases
            };
        }

        /**
         * Convert flat MS Project task list (all at level 1) to TreeListy
         * Groups tasks by year/quarter or creates logical phases
         */
        function convertFlatMSProjectToTreeListy(taskList, taskUIDMap, projectName) {
            const uidToIdMap = new Map();

            // Group tasks by year based on start date
            const tasksByYear = new Map();

            taskList.forEach(task => {
                if (task.outlineLevel === 0) return; // Skip root

                let year = 'Tasks';
                if (task.startDate) {
                    const date = new Date(task.startDate);
                    if (!isNaN(date.getTime())) {
                        year = `${date.getFullYear()}`;
                    }
                }

                if (!tasksByYear.has(year)) {
                    tasksByYear.set(year, []);
                }
                tasksByYear.get(year).push(task);
            });

            // If all tasks in same year, try grouping by quarter
            if (tasksByYear.size === 1) {
                const allTasks = [...tasksByYear.values()][0];
                const tasksByQuarter = new Map();

                allTasks.forEach(task => {
                    let quarter = 'Tasks';
                    if (task.startDate) {
                        const date = new Date(task.startDate);
                        if (!isNaN(date.getTime())) {
                            const q = Math.ceil((date.getMonth() + 1) / 3);
                            quarter = `Q${q} ${date.getFullYear()}`;
                        }
                    }

                    if (!tasksByQuarter.has(quarter)) {
                        tasksByQuarter.set(quarter, []);
                    }
                    tasksByQuarter.get(quarter).push(task);
                });

                // Use quarters if we have more than 1
                if (tasksByQuarter.size > 1) {
                    tasksByYear.clear();
                    tasksByQuarter.forEach((tasks, quarter) => {
                        tasksByYear.set(quarter, tasks);
                    });
                }
            }

            // Convert to phases
            const phases = [];
            let phaseIndex = 0;

            // Sort keys chronologically
            const sortedKeys = [...tasksByYear.keys()].sort();

            sortedKeys.forEach(key => {
                const phaseTasks = tasksByYear.get(key);

                const phase = {
                    name: key,
                    subtitle: `${phaseTasks.length} tasks`,
                    icon: 'ðŸ“…',
                    items: phaseTasks.map((task, itemIndex) => {
                        const itemId = `item-${phaseIndex}-${itemIndex}`;
                        uidToIdMap.set(task.uid, itemId);

                        return {
                            name: task.name,
                            description: task.description || (task.wbs ? `WBS: ${task.wbs}` : ''),
                            cost: task.cost || 0,
                            leadTime: task.duration || '',
                            pmStatus: task.status,
                            pmProgress: task.percentComplete,
                            pmAssignee: task.assignees.join(', ') || 'Unassigned',
                            pmPriority: task.priority,
                            pmStartDate: task.startDate,
                            pmDueDate: task.finishDate,
                            pmNotes: '',
                            dependencies: [],
                            _predecessorUIDs: task.predecessorUIDs,
                            subtasks: []
                        };
                    })
                };

                phases.push(phase);
                phaseIndex++;
            });

            // Resolve dependencies
            phases.forEach(phase => {
                phase.items.forEach(item => {
                    if (item._predecessorUIDs && item._predecessorUIDs.length > 0) {
                        item.dependencies = item._predecessorUIDs
                            .map(uid => uidToIdMap.get(uid))
                            .filter(id => id);
                    }
                    delete item._predecessorUIDs;
                });
            });

            const totalItems = phases.reduce((sum, p) => sum + p.items.length, 0);
            console.log(`ðŸ“Š Flat list converted: ${phases.length} phases, ${totalItems} items`);

            return {
                projectName,
                phases
            };
        }

        /**
         * Handle MS Project XML file import
         */
        function importFromMSProject(file) {
            console.log('ðŸ“… MS Project file selected:', file.name);

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const xmlString = e.target.result;
                    const treeData = parseMSProjectXML(xmlString);

                    // Count items for confirmation
                    const itemCount = treeData.phases.reduce((sum, p) =>
                        sum + p.items.length + p.items.reduce((s, i) => s + (i.subtasks?.length || 0), 0), 0);

                    // Show confirmation modal
                    showMSProjectImportConfirmation(treeData, itemCount);

                } catch (error) {
                    console.error('âŒ MS Project import error:', error);
                    alert('âŒ Failed to import MS Project file!\n\n' + error.message);
                }
            };
            reader.readAsText(file);
        }

        /**
         * Show confirmation modal before importing MS Project data
         */
        function showMSProjectImportConfirmation(treeData, itemCount) {
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            modalTitle.textContent = 'ðŸ“… Import from MS Project';

            const phaseCount = treeData.phases.length;
            const subtaskCount = treeData.phases.reduce((sum, p) =>
                sum + p.items.reduce((s, i) => s + (i.subtasks?.length || 0), 0), 0);

            modalBody.innerHTML = `
                <div style="padding: 20px;">
                    <div style="background: var(--bg-secondary); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <h3 style="margin: 0 0 16px 0; color: var(--text-primary);">ðŸ“Š ${treeData.projectName}</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                            <div style="text-align: center;">
                                <div style="font-size: 28px; font-weight: 700; color: var(--treeplex-primary);">${phaseCount}</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">Phases</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 28px; font-weight: 700; color: var(--treeplex-primary);">${itemCount - subtaskCount}</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">Tasks</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 28px; font-weight: 700; color: var(--treeplex-primary);">${subtaskCount}</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">Subtasks</div>
                            </div>
                        </div>
                    </div>

                    <div style="background: rgba(0, 166, 125, 0.1); border: 1px solid var(--treeplex-primary); border-radius: 8px; padding: 12px; margin-bottom: 20px;">
                        <div style="font-weight: 600; color: var(--treeplex-primary); margin-bottom: 8px;">âœ… Fields Imported:</div>
                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.6;">
                            Task hierarchy â€¢ Start/End dates â€¢ Duration â€¢ Progress % â€¢
                            Resources â†’ Assignees â€¢ Dependencies â€¢ Costs â€¢ Priority â€¢ Notes
                        </div>
                    </div>

                    <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 20px;">
                        This will <strong>replace</strong> your current project. Continue?
                    </p>

                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button class="btn" onclick="document.getElementById('modal').style.display='none';" style="padding: 10px 20px;">
                            Cancel
                        </button>
                        <button class="btn" id="msproject-import-confirm" style="background: var(--treeplex-primary); padding: 10px 24px; font-weight: 600;">
                            ðŸ“¥ Import Project
                        </button>
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Handle import confirmation
            document.getElementById('msproject-import-confirm').addEventListener('click', () => {
                modal.style.display = 'none';

                // Use the existing importAnalyzedTree function
                // Default to capex pattern for MS Project imports (infrastructure/CAPEX projects)
                importAnalyzedTree(treeData, 'capex', false);

                showToast(`âœ… Imported ${itemCount} tasks from MS Project!`, 'success');
                console.log('ðŸ“… MS Project import complete:', treeData.projectName);
            });
        }

        // MS Project XML file upload handler
        document.getElementById('msproject-upload-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                importFromMSProject(file);
            }
            // Reset input
            e.target.value = '';
        });

        // MS Project import button click handler
        document.getElementById('msproject-import-btn').addEventListener('click', () => {
            document.getElementById('msproject-upload-input').click();
        });

        // =============================================================================
        // MS PROJECT XML EXPORT - Export TreeListy to MS Project XML format
        // =============================================================================

        /**
         * Export current TreeListy project to MS Project XML (MSPDI) format
         */
        function exportToMSProjectXML() {
            console.log('ðŸ“… Exporting to MS Project XML...');

            const projectName = capexTree.name || 'TreeListy Project';
            const now = new Date().toISOString();

            // Collect all tasks with their hierarchy info
            const tasks = [];
            const resources = new Map(); // name â†’ UID
            let taskUID = 1;
            let resourceUID = 1;

            // Add root project task (UID 0)
            tasks.push({
                UID: 0,
                ID: 0,
                Name: projectName,
                OutlineLevel: 0,
                Summary: true,
                WBS: '0'
            });

            // Process phases, items, and subtasks
            let taskID = 1;

            capexTree.children?.forEach((phase, phaseIndex) => {
                const phaseWBS = `${phaseIndex + 1}`;

                // Add phase as summary task
                tasks.push({
                    UID: taskUID,
                    ID: taskID,
                    Name: phase.name || `Phase ${phaseIndex + 1}`,
                    OutlineLevel: 1,
                    Summary: true,
                    WBS: phaseWBS,
                    Notes: phase.subtitle || ''
                });
                const phaseTaskUID = taskUID;
                taskUID++;
                taskID++;

                // Process items in phase
                phase.items?.forEach((item, itemIndex) => {
                    const itemWBS = `${phaseWBS}.${itemIndex + 1}`;
                    const hasSubtasks = item.children && item.children.length > 0;

                    // Collect resource
                    if (item.pmAssignee && item.pmAssignee !== 'Unassigned') {
                        if (!resources.has(item.pmAssignee)) {
                            resources.set(item.pmAssignee, resourceUID++);
                        }
                    }

                    tasks.push({
                        UID: taskUID,
                        ID: taskID,
                        Name: item.name || 'Unnamed Task',
                        OutlineLevel: 2,
                        Summary: hasSubtasks,
                        WBS: itemWBS,
                        Notes: item.description || '',
                        Start: item.pmStartDate ? formatDateForMSProject(item.pmStartDate) : now,
                        Finish: item.pmDueDate ? formatDateForMSProject(item.pmDueDate) : now,
                        Duration: formatDurationForMSProject(item.leadTime),
                        PercentComplete: item.pmProgress || 0,
                        Cost: item.cost || 0,
                        Priority: mapPriorityToMSProject(item.pmPriority),
                        Assignee: item.pmAssignee,
                        Dependencies: item.dependencies || []
                    });
                    const itemTaskUID = taskUID;
                    taskUID++;
                    taskID++;

                    // Process subtasks
                    item.children?.forEach((subtask, subtaskIndex) => {
                        const subtaskWBS = `${itemWBS}.${subtaskIndex + 1}`;

                        // Collect resource
                        if (subtask.pmAssignee && subtask.pmAssignee !== 'Unassigned') {
                            if (!resources.has(subtask.pmAssignee)) {
                                resources.set(subtask.pmAssignee, resourceUID++);
                            }
                        }

                        tasks.push({
                            UID: taskUID,
                            ID: taskID,
                            Name: subtask.name || 'Unnamed Subtask',
                            OutlineLevel: 3,
                            Summary: false,
                            WBS: subtaskWBS,
                            Notes: subtask.description || '',
                            Start: subtask.pmStartDate ? formatDateForMSProject(subtask.pmStartDate) : now,
                            Finish: subtask.pmDueDate ? formatDateForMSProject(subtask.pmDueDate) : now,
                            Duration: formatDurationForMSProject(subtask.leadTime || '1 day'),
                            PercentComplete: subtask.pmProgress || 0,
                            Cost: subtask.cost || 0,
                            Priority: mapPriorityToMSProject(subtask.pmPriority),
                            Assignee: subtask.pmAssignee,
                            Dependencies: subtask.dependencies || []
                        });
                        taskUID++;
                        taskID++;
                    });
                });
            });

            // Build XML document
            const xml = buildMSProjectXML(projectName, tasks, resources, now);

            // Download the file
            const blob = new Blob([xml], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${projectName.replace(/[^a-zA-Z0-9]/g, '_')}_MSProject.xml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast(`ðŸ“… Exported to MS Project XML (${tasks.length - 1} tasks)`, 'success');
            console.log('ðŸ“… MS Project XML export complete');
        }

        /**
         * Build MS Project XML (MSPDI format) document
         */
        function buildMSProjectXML(projectName, tasks, resources, timestamp) {
            // Build task ID map for dependency resolution
            const taskIdMap = new Map();
            tasks.forEach(t => {
                // Try to map TreeListy IDs to task UIDs
                if (t.WBS) {
                    taskIdMap.set(t.WBS, t.UID);
                }
            });

            let xml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Project xmlns="http://schemas.microsoft.com/project">
    <Name>${escapeXML(projectName)}</Name>
    <Title>${escapeXML(projectName)}</Title>
    <CreationDate>${timestamp}</CreationDate>
    <LastSaved>${timestamp}</LastSaved>
    <ScheduleFromStart>1</ScheduleFromStart>
    <StartDate>${timestamp}</StartDate>
    <CalendarUID>1</CalendarUID>
    <DefaultStartTime>08:00:00</DefaultStartTime>
    <DefaultFinishTime>17:00:00</DefaultFinishTime>
    <MinutesPerDay>480</MinutesPerDay>
    <MinutesPerWeek>2400</MinutesPerWeek>
    <DaysPerMonth>20</DaysPerMonth>
    <CurrencySymbol>$</CurrencySymbol>
    <CurrencyPosition>0</CurrencyPosition>
    <CurrencyDigits>2</CurrencyDigits>

    <Calendars>
        <Calendar>
            <UID>1</UID>
            <Name>Standard</Name>
            <IsBaseCalendar>1</IsBaseCalendar>
            <WeekDays>
                <WeekDay><DayType>1</DayType><DayWorking>0</DayWorking></WeekDay>
                <WeekDay><DayType>2</DayType><DayWorking>1</DayWorking></WeekDay>
                <WeekDay><DayType>3</DayType><DayWorking>1</DayWorking></WeekDay>
                <WeekDay><DayType>4</DayType><DayWorking>1</DayWorking></WeekDay>
                <WeekDay><DayType>5</DayType><DayWorking>1</DayWorking></WeekDay>
                <WeekDay><DayType>6</DayType><DayWorking>1</DayWorking></WeekDay>
                <WeekDay><DayType>7</DayType><DayWorking>0</DayWorking></WeekDay>
            </WeekDays>
        </Calendar>
    </Calendars>

    <Tasks>
`;

            // Add tasks
            tasks.forEach(task => {
                xml += `        <Task>
            <UID>${task.UID}</UID>
            <ID>${task.ID}</ID>
            <Name>${escapeXML(task.Name)}</Name>
            <WBS>${escapeXML(task.WBS || '')}</WBS>
            <OutlineLevel>${task.OutlineLevel}</OutlineLevel>
            <Summary>${task.Summary ? '1' : '0'}</Summary>
            <Start>${task.Start || timestamp}</Start>
            <Finish>${task.Finish || timestamp}</Finish>
            <Duration>${task.Duration || 'PT8H0M0S'}</Duration>
            <PercentComplete>${task.PercentComplete || 0}</PercentComplete>
            <Cost>${task.Cost || 0}</Cost>
            <Priority>${task.Priority || 500}</Priority>
            <Notes>${escapeXML(task.Notes || '')}</Notes>
`;

                // Add predecessor links (dependencies)
                if (task.Dependencies && task.Dependencies.length > 0) {
                    task.Dependencies.forEach(depId => {
                        // Try to find the UID for this dependency
                        // Dependencies in TreeListy are stored as item IDs like "item-0-1"
                        const depUID = findTaskUIDByTreeListyId(tasks, depId);
                        if (depUID !== null) {
                            xml += `            <PredecessorLink>
                <PredecessorUID>${depUID}</PredecessorUID>
                <Type>1</Type>
            </PredecessorLink>
`;
                        }
                    });
                }

                xml += `        </Task>
`;
            });

            xml += `    </Tasks>

    <Resources>
`;

            // Add resources
            resources.forEach((uid, name) => {
                xml += `        <Resource>
            <UID>${uid}</UID>
            <ID>${uid}</ID>
            <Name>${escapeXML(name)}</Name>
            <Type>1</Type>
        </Resource>
`;
            });

            xml += `    </Resources>

    <Assignments>
`;

            // Add assignments
            let assignmentUID = 1;
            tasks.forEach(task => {
                if (task.Assignee && task.Assignee !== 'Unassigned' && resources.has(task.Assignee)) {
                    xml += `        <Assignment>
            <UID>${assignmentUID}</UID>
            <TaskUID>${task.UID}</TaskUID>
            <ResourceUID>${resources.get(task.Assignee)}</ResourceUID>
        </Assignment>
`;
                    assignmentUID++;
                }
            });

            xml += `    </Assignments>
</Project>`;

            return xml;
        }

        /**
         * Find task UID by TreeListy ID (e.g., "item-0-1", "phase-2")
         */
        function findTaskUIDByTreeListyId(tasks, treelistyId) {
            if (!treelistyId) return null;

            // Parse TreeListy ID format: "item-{phase}-{item}" or "phase-{phase}"
            const itemMatch = treelistyId.match(/item-(\d+)-(\d+)/);
            if (itemMatch) {
                const phaseIdx = parseInt(itemMatch[1]);
                const itemIdx = parseInt(itemMatch[2]);
                // WBS would be "{phase+1}.{item+1}"
                const wbs = `${phaseIdx + 1}.${itemIdx + 1}`;
                const task = tasks.find(t => t.WBS === wbs);
                return task ? task.UID : null;
            }

            const phaseMatch = treelistyId.match(/phase-(\d+)/);
            if (phaseMatch) {
                const phaseIdx = parseInt(phaseMatch[1]);
                const wbs = `${phaseIdx + 1}`;
                const task = tasks.find(t => t.WBS === wbs);
                return task ? task.UID : null;
            }

            return null;
        }

        /**
         * Format date for MS Project XML
         */
        function formatDateForMSProject(dateStr) {
            if (!dateStr) return new Date().toISOString();
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return new Date().toISOString();
                return date.toISOString();
            } catch {
                return new Date().toISOString();
            }
        }

        /**
         * Format duration for MS Project XML (PT format)
         */
        function formatDurationForMSProject(durationStr) {
            if (!durationStr) return 'PT8H0M0S'; // Default 1 day

            const lower = durationStr.toLowerCase();

            // Parse common formats
            const dayMatch = lower.match(/(\d+)\s*d/);
            const hourMatch = lower.match(/(\d+)\s*h/);
            const weekMatch = lower.match(/(\d+)\s*w/);
            const monthMatch = lower.match(/(\d+)\s*m(?:onth)?/);

            let hours = 0;

            if (weekMatch) {
                hours = parseInt(weekMatch[1]) * 40; // 5 days * 8 hours
            } else if (monthMatch) {
                hours = parseInt(monthMatch[1]) * 160; // 20 days * 8 hours
            } else if (dayMatch) {
                hours = parseInt(dayMatch[1]) * 8;
            } else if (hourMatch) {
                hours = parseInt(hourMatch[1]);
            } else {
                // Try to parse "X days", "X weeks", etc.
                const numMatch = lower.match(/(\d+)/);
                if (numMatch) {
                    const num = parseInt(numMatch[1]);
                    if (lower.includes('week')) {
                        hours = num * 40;
                    } else if (lower.includes('month')) {
                        hours = num * 160;
                    } else if (lower.includes('day')) {
                        hours = num * 8;
                    } else {
                        hours = num * 8; // Default to days
                    }
                } else {
                    hours = 8; // Default 1 day
                }
            }

            return `PT${hours}H0M0S`;
        }

        /**
         * Map TreeListy priority to MS Project priority (0-1000)
         */
        function mapPriorityToMSProject(priority) {
            if (!priority) return 500;
            const p = priority.toLowerCase();
            if (p === 'low') return 200;
            if (p === 'high') return 800;
            return 500; // Medium
        }

        /**
         * Escape special XML characters
         */
        function escapeXML(str) {
            if (!str) return '';
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        // MS Project export button click handler
        document.getElementById('msproject-export-btn').addEventListener('click', () => {
            exportToMSProjectXML();
        });

        // Redraw lines on scroll or resize
        const treeContainer = document.getElementById('tree-container');
        treeContainer.addEventListener('scroll', drawDependencyLines);
        window.addEventListener('resize', drawDependencyLines);

        // Load from shared URL if present - returns true if branch URL handled (skip initial render)
        const branchURLHandled = (function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);

            // Check for collaboration branch URL first - handle SYNCHRONOUSLY to prevent flash of default tree
            if (urlParams.has('branch')) {
                console.log('ðŸ¤ Branch URL detected - handling synchronously...');
                const success = handleBranchURL();
                if (success) {
                    console.log('âœ… Branch URL processed successfully');
                    return true; // Skip default render
                }
                // Fall through if branch handling failed
            }

            const compressedData = urlParams.get('p');

            if (compressedData) {
                try {
                    console.log('Loading shared project from URL...');
                    const decompressed = LZString.decompressFromEncodedURIComponent(compressedData);

                    // DEBUG: Log first 500 chars of decompressed JSON
                    console.log('Decompressed JSON (first 500 chars):', decompressed.substring(0, 500));

                    const loadedTree = JSON.parse(decompressed);

                    // DEBUG: Check cost values in loaded tree
                    if (loadedTree.children && loadedTree.children[0] && loadedTree.children[0].items && loadedTree.children[0].items[0]) {
                        console.log('First item cost in loaded JSON:', loadedTree.children[0].items[0].cost);
                    }

                    // Replace capexTree with loaded data
                    capexTree = loadedTree;

                    // Update currentPattern if it's in the loaded data
                    if (capexTree.pattern) {
                        const patternKey = getPatternKey(capexTree.pattern);
                        if (patternKey) {
                            currentPattern = patternKey;
                        }
                    }

                    console.log('âœ… Shared project loaded successfully!');
                    console.log('Project:', capexTree.name || capexTree.title);
                    console.log('Pattern:', currentPattern);

                    // Simple success toast (no modal)
                    setTimeout(() => {
                        const toast = document.createElement('div');
                        toast.textContent = 'âœ… Project loaded!';
                        toast.style.cssText = `
                            position: fixed;
                            top: 80px;
                            right: 20px;
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            padding: 15px 25px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-weight: 600;
                        `;
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 2000);
                    }, 500);

                } catch (error) {
                    console.error('âŒ Failed to load shared project:', error);
                    alert('Failed to load shared project. The URL may be corrupted or invalid.');
                }
            }

            // Check for Google Drive file ID (?gdrive=FILE_ID or ?gdrive=SHARING_URL)
            // Also supports ?watch=URL for Watch Mode auto-start
            const gdriveParam = urlParams.get('gdrive');
            const watchParam = urlParams.get('watch');

            if (gdriveParam || watchParam) {
                const fileSource = gdriveParam || watchParam;
                console.log('â˜ï¸ Google Drive/Watch URL detected:', fileSource);

                // Extract file ID from various Google Drive URL formats
                let fileId = null;

                if (fileSource.includes('drive.google.com')) {
                    // Full Google Drive URL - extract file ID
                    const match = fileSource.match(/\/d\/([a-zA-Z0-9_-]+)/);
                    if (match) {
                        fileId = match[1];
                    }
                    // Also try ?id= format
                    const idMatch = fileSource.match(/[?&]id=([a-zA-Z0-9_-]+)/);
                    if (idMatch) {
                        fileId = idMatch[1];
                    }
                } else if (fileSource.match(/^[a-zA-Z0-9_-]{20,}$/)) {
                    // Just a file ID
                    fileId = fileSource;
                }

                if (fileId) {
                    // Use our proxy to avoid CORS issues
                    const proxyUrl = `/.netlify/functions/gdrive-proxy?id=${fileId}`;

                    // Fetch and load the file
                    setTimeout(async () => {
                        try {
                            showToast('â˜ï¸ Loading from Google Drive...', 'info');

                            const response = await fetch(proxyUrl);
                            const result = await response.json();

                            if (!response.ok || result.error) {
                                throw new Error(result.error || 'Failed to fetch');
                            }

                            const treeData = result;
                            capexTree = treeData;

                            // Update pattern if present in loaded data
                            if (treeData.pattern) {
                                const patternKey = getPatternKey(treeData.pattern);
                                if (patternKey) {
                                    currentPattern = patternKey;
                                    // Update pattern selector UI
                                    const patternSelect = document.getElementById('pattern-select');
                                    if (patternSelect) {
                                        patternSelect.value = currentPattern;
                                    }
                                    // Handle custom pattern labels
                                    if (currentPattern === 'custom' && treeData.pattern.labels) {
                                        customPatternNames = treeData.pattern.labels;
                                    }
                                    // Update related UI elements
                                    if (typeof updateSortDropdown === 'function') updateSortDropdown();
                                    if (typeof updateAIButtonLabel === 'function') updateAIButtonLabel();
                                    console.log('â˜ï¸ Pattern detected from Google Drive:', currentPattern);
                                }
                            }

                            // Add to recent files list
                            if (typeof addToRecentGdrive === 'function') {
                                addToRecentGdrive(fileId, treeData.name || treeData.projectName || 'Shared Project', currentPattern);
                            }

                            render();
                            if (viewMode === 'canvas') renderCanvas();

                            showToast('âœ… Loaded from Google Drive!', 'success');

                            // If this was a ?watch= parameter, auto-start Watch Mode
                            if (watchParam) {
                                // Pre-fill watch mode with this URL
                                const pathInput = document.getElementById('watch-file-path');
                                if (pathInput) pathInput.value = gdriveUrl;

                                // Show Watch Mode modal for user to enter name and start
                                setTimeout(() => {
                                    document.getElementById('watch-mode-modal').style.display = 'flex';
                                    showToast('ðŸ‘ï¸ Enter your name and click Start to sync!', 'info');
                                }, 1000);
                            }

                        } catch (error) {
                            console.error('âŒ Failed to load from Google Drive:', error);
                            showToast('âŒ Failed to load from Google Drive. Check the file is publicly shared.', 'error');
                        }
                    }, 100);
                }
            }

            return false;
        })();

        // =============================================================================
        // PWA & FILE HANDLING SYSTEM
        // =============================================================================

        // PWA install prompt event
        let deferredInstallPrompt = null;

        // Register service worker (only on http:// or https://, not file://)
        if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
            navigator.serviceWorker.register('./service-worker.js')
                .then(registration => {
                    console.log('âœ… Service Worker registered:', registration.scope);
                })
                .catch(error => {
                    console.error('âŒ Service Worker registration failed:', error);
                    console.error('Error details:', error.message, error.stack);
                });
        } else if (window.location.protocol === 'file:') {
            console.log('â„¹ï¸ Service Worker skipped (file:// protocol - not supported)');
        }

        if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {

            // Listen for file launches from service worker
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data.type === 'FILE_OPENED' && event.data.files) {
                    console.log('ðŸ“‚ File opened via file association:', event.data.files);
                    event.data.files.forEach(file => {
                        try {
                            const treeData = JSON.parse(file.content);
                            capexTree = treeData;
                            if (treeData.pattern) {
                                const patternKey = getPatternKey(treeData.pattern);
                                if (patternKey) {
                                    currentPattern = patternKey;
                                }
                            }
                            render();
                            console.log(`âœ… Loaded ${file.name}`);
                        } catch (error) {
                            console.error(`âŒ Failed to load ${file.name}:`, error);
                            alert(`Failed to load ${file.name}: Invalid JSON format`);
                        }
                    });
                }
            });
        }

        // Capture PWA install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('ðŸ’¾ PWA install prompt available - Button will trigger automatic install');
            e.preventDefault();
            deferredInstallPrompt = e;
        });

        // Debug: Check PWA install readiness
        console.log('ðŸ” PWA Debug Info:');
        console.log('- Service Worker supported:', 'serviceWorker' in navigator);
        console.log('- beforeinstallprompt listener added');
        console.log('- Manifest URL:', document.querySelector('link[rel="manifest"]')?.href);
        console.log('- Current URL:', window.location.href);
        console.log('- HTTPS:', window.location.protocol === 'https:');

        // Show PWA onboarding modal
        function showPWAOnboardingModal() {
            const modal = document.getElementById('pwa-onboarding-modal');
            modal.style.display = 'flex';
            // Button is always visible now - no need to check for prompt
        }

        // Install PWA button - Universal handler
        document.getElementById('pwa-install-btn').addEventListener('click', async () => {
            const instructionsDiv = document.getElementById('pwa-manual-instructions');

            if (deferredInstallPrompt) {
                // Automatic install available - trigger it
                try {
                    deferredInstallPrompt.prompt();

                    const { outcome } = await deferredInstallPrompt.userChoice;
                    console.log(`PWA install outcome: ${outcome}`);

                    if (outcome === 'accepted') {
                        console.log('âœ… User accepted PWA installation');

                        // Mark onboarding as completed
                        localStorage.setItem('treelisty-onboarding-seen', 'true');

                        // Close modal
                        document.getElementById('pwa-onboarding-modal').style.display = 'none';

                        // Show success message
                        const toast = document.createElement('div');
                        toast.textContent = 'âœ… TreeListy installed! You can now open .treelisty files by double-clicking them.';
                        toast.style.cssText = `
                            position: fixed;
                            top: 80px;
                            right: 20px;
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            padding: 15px 25px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-weight: 600;
                            max-width: 400px;
                        `;
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 5000);
                    } else {
                        console.log('âŒ User declined PWA installation');
                    }

                    deferredInstallPrompt = null;
                } catch (error) {
                    console.error('Install prompt error:', error);
                    // Fallback to manual instructions if prompt fails
                    instructionsDiv.style.display = 'block';
                }
            } else {
                // No automatic install - show manual instructions
                console.log('ðŸ“ Showing manual install instructions');
                instructionsDiv.style.display = 'block';

                // Change button text to indicate instructions are shown
                const btn = document.getElementById('pwa-install-btn');
                btn.textContent = 'âœ… See Instructions Below';
                btn.style.background = 'var(--card-bg)';
                btn.style.color = 'var(--text-secondary)';
                btn.disabled = true;
            }
        });

        // Skip onboarding button
        document.getElementById('pwa-skip-btn').addEventListener('click', () => {
            localStorage.setItem('treelisty-onboarding-seen', 'true');
            document.getElementById('pwa-onboarding-modal').style.display = 'none';
        });

        // Handle launchQueue for file opens (File Handling API)
        if ('launchQueue' in window) {
            window.launchQueue.setConsumer(async (launchParams) => {
                console.log('ðŸ“‚ File launch detected via File Handling API');

                if (launchParams.files && launchParams.files.length > 0) {
                    for (const fileHandle of launchParams.files) {
                        try {
                            const file = await fileHandle.getFile();
                            const content = await file.text();
                            const treeData = JSON.parse(content);

                            // Load the tree
                            capexTree = treeData;
                            if (treeData.pattern) {
                                const patternKey = getPatternKey(treeData.pattern);
                                if (patternKey) {
                                    currentPattern = patternKey;
                                }
                            }
                            render();

                            console.log(`âœ… Loaded ${file.name} via file association`);

                            // Show success toast
                            const toast = document.createElement('div');
                            toast.textContent = `âœ… Opened ${file.name}`;
                            toast.style.cssText = `
                                position: fixed;
                                top: 80px;
                                right: 20px;
                                background: linear-gradient(135deg, #10b981, #059669);
                                color: white;
                                padding: 15px 25px;
                                border-radius: 8px;
                                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                                z-index: 10000;
                                font-weight: 600;
                            `;
                            document.body.appendChild(toast);
                            setTimeout(() => toast.remove(), 3000);
                        } catch (error) {
                            console.error('âŒ Failed to load file:', error);
                            alert(`Failed to load file: ${error.message}`);
                        }
                    }
                }
            });
        } else {
            console.log('â„¹ï¸ File Handling API not supported in this browser');
        }

        // Initial render - skip if branch URL was handled (it already rendered)
        if (!branchURLHandled) {
            render();
        }

        // Update AI button label for initial pattern
        updateAIButtonLabel();

        // Initialize pattern selector
        const patternSelect = document.getElementById('pattern-select');
        console.log('Pattern selector found:', patternSelect);
        if (patternSelect) {
            // Load saved pattern from data
            if (capexTree.pattern && getPatternKey(capexTree.pattern)) {
                currentPattern = getPatternKey(capexTree.pattern);
                patternSelect.value = currentPattern;
                console.log('Loaded saved pattern:', currentPattern);
                if (currentPattern === 'custom' && capexTree.pattern.labels) {
                    customPatternNames = capexTree.pattern.labels;
                }
                // Apply pattern labels to existing nodes on load - skip if branch mode
                if (!branchURLHandled) {
                    const labels = currentPattern === 'custom' && customPatternNames ? customPatternNames : PATTERNS[currentPattern].levels;
                    renameNodesForPattern(capexTree, labels);
                    console.log('Initial nodes renamed to match saved pattern');
                    render(); // Re-render with renamed nodes
                }

                // Update sort dropdown for the loaded pattern
                updateSortDropdown();

                // Update AI button label for the loaded pattern
                updateAIButtonLabel();
            }
            // Handle pattern selection
            patternSelect.addEventListener('change', function() {
                console.log('Pattern selector changed to:', this.value);
                applyPattern(this.value);
            });
            console.log('Pattern selector event listener attached');
        } else {
            console.error('Pattern selector NOT found!');
        }

        // Initialize Theme Switcher
        const themeSelect = document.getElementById('theme-select');
        if (themeSelect) {
            // Load saved theme from localStorage
            const savedTheme = localStorage.getItem('treelisty-theme') || 'default';
            document.documentElement.setAttribute('data-theme', savedTheme);
            themeSelect.value = savedTheme;
            console.log('Theme loaded:', savedTheme);

            // Handle theme selection
            themeSelect.addEventListener('change', function() {
                const selectedTheme = this.value;
                console.log('Theme changed to:', selectedTheme);

                // Apply theme
                document.documentElement.setAttribute('data-theme', selectedTheme);

                // Save to localStorage
                localStorage.setItem('treelisty-theme', selectedTheme);

                // Show toast notification
                const themeNames = {
                    'default': 'ðŸŒ™ Default',
                    'steampunk': 'âš™ï¸ Steampunk',
                    'powerpuff': 'ðŸ’— Powerpuff',
                    'tron': 'ðŸ’  Tron'
                };
                const toast = document.createElement('div');
                toast.textContent = `Theme: ${themeNames[selectedTheme]}`;
                toast.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    right: 20px;
                    padding: 12px 24px;
                    background: var(--card-bg);
                    border: 2px solid var(--border);
                    border-radius: 12px;
                    color: var(--text-primary);
                    font-weight: 600;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: var(--shadow-lg);
                `;
                document.body.appendChild(toast);

                setTimeout(() => toast.remove(), 2000);
            });

            console.log('Theme switcher initialized');
        }

        // ============================================
        // SORTING SYSTEM
        // ============================================

        // Parse lead time string to days for comparison
        function parseLeadTimeToDays(leadTimeStr) {
            if (!leadTimeStr || leadTimeStr === 'N/A' || leadTimeStr === '') return 999999;

            const str = leadTimeStr.toLowerCase();
            let days = 0;

            // Match patterns like "12-18 months", "3-6 weeks", "2 days", etc.
            const monthsMatch = str.match(/(\d+)(?:-(\d+))?\s*months?/);
            const weeksMatch = str.match(/(\d+)(?:-(\d+))?\s*weeks?/);
            const daysMatch = str.match(/(\d+)(?:-(\d+))?\s*days?/);

            if (monthsMatch) {
                // Take average if range, otherwise use single value
                const avg = monthsMatch[2] ? (parseInt(monthsMatch[1]) + parseInt(monthsMatch[2])) / 2 : parseInt(monthsMatch[1]);
                days = avg * 30; // Approximate months to days
            } else if (weeksMatch) {
                const avg = weeksMatch[2] ? (parseInt(weeksMatch[1]) + parseInt(weeksMatch[2])) / 2 : parseInt(weeksMatch[1]);
                days = avg * 7;
            } else if (daysMatch) {
                const avg = daysMatch[2] ? (parseInt(daysMatch[1]) + parseInt(daysMatch[2])) / 2 : parseInt(daysMatch[1]);
                days = avg;
            }

            return days || 999999; // Return large number if unparseable
        }

        // Compare two values based on type
        function compareValues(a, b, type, order) {
            let valA, valB;

            switch(type) {
                case 'number':
                    valA = parseFloat(a) || 0;
                    valB = parseFloat(b) || 0;
                    break;

                case 'leadtime':
                    valA = parseLeadTimeToDays(a);
                    valB = parseLeadTimeToDays(b);
                    break;

                case 'date':
                    valA = a ? new Date(a).getTime() : 0;
                    valB = b ? new Date(b).getTime() : 0;
                    break;

                case 'text':
                default:
                    valA = (a || '').toString().toLowerCase();
                    valB = (b || '').toString().toLowerCase();
                    if (order === 'asc') return valA.localeCompare(valB);
                    return valB.localeCompare(valA);
            }

            if (order === 'asc') return valA - valB;
            return valB - valA;
        }

        // Recursively sort items array and all nested levels
        function sortItemsArray(items, sortConfig) {
            if (!items || !Array.isArray(items) || items.length === 0) return items;
            if (!sortConfig) return items;

            const { field, order, type } = sortConfig;

            // Special handling for "folders first" sorting in filesystem pattern
            if (currentPattern === 'filesystem' && field === 'isFolder') {
                items.sort((a, b) => {
                    // Folders always come before files when sorting by type
                    const aIsFolder = a.isFolder || false;
                    const bIsFolder = b.isFolder || false;

                    if (aIsFolder && !bIsFolder) return order === 'desc' ? -1 : 1;
                    if (!aIsFolder && bIsFolder) return order === 'desc' ? 1 : -1;

                    // If both are folders or both are files, sort by name as secondary
                    return (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase());
                });
            } else {
                // Standard sorting for all other fields
                items.sort((a, b) => {
                    return compareValues(a[field], b[field], type, order);
                });
            }

            // Recursively sort nested arrays (items, subItems, and children for all patterns)
            items.forEach(item => {
                // Sort standard items array (4-level patterns)
                if (item.items && Array.isArray(item.items) && item.items.length > 0) {
                    sortItemsArray(item.items, sortConfig);
                }

                // Sort subItems array (flexible depth patterns like filesystem)
                if (item.subItems && Array.isArray(item.subItems) && item.subItems.length > 0) {
                    sortItemsArray(item.subItems, sortConfig);
                }

                // Sort children array (filesystem pattern uses this for nested folders)
                if (item.children && Array.isArray(item.children) && item.children.length > 0) {
                    sortItemsArray(item.children, sortConfig);
                }
            });

            return items;
        }

        // Sort the entire tree - applies to all nodes at all depths
        function sortTree(sortConfig) {
            if (!sortConfig) {
                // For filesystem pattern, apply default "folders first + alphabetical" sort
                if (currentPattern === 'filesystem') {
                    sortConfig = {
                        value: 'default-filesystem',
                        field: 'isFolder',
                        order: 'desc',
                        type: 'boolean'
                    };
                    currentSortConfig = sortConfig;
                } else {
                    // Reset to original order for other patterns
                    currentSortConfig = null;
                    render();
                    return;
                }
            } else {
                currentSortConfig = sortConfig;
            }

            // Sort phases (drives for filesystem pattern)
            if (capexTree.phases && capexTree.phases.length > 0) {
                sortItemsArray(capexTree.phases, sortConfig);

                // Sort all items within each phase recursively
                capexTree.phases.forEach(phase => {
                    if (phase.items && phase.items.length > 0) {
                        sortItemsArray(phase.items, sortConfig);
                    }
                });
            }

            // Sort children array (for root level if exists)
            if (capexTree.children && capexTree.children.length > 0) {
                sortItemsArray(capexTree.children, sortConfig);
            }

            // Re-render to show sorted tree with new visual order
            // Check if 3D view is active (it's an overlay, not a viewMode value)
            const view3D = document.getElementById('view-3d');
            const is3DActive = view3D && view3D.classList.contains('active');

            if (is3DActive) {
                // Refresh 3D view with new sort-based layout
                if (typeof window.refresh3DData === 'function') {
                    window.refresh3DData();
                    console.log('3D sorted by:', sortConfig, '- 3D layout transformed');
                }
            } else if (viewMode === 'canvas') {
                // Clear canvas coordinates to force re-positioning in new sorted order
                capexTree.children.forEach(phase => {
                    const nodeList = phase.items || phase.children || [];
                    nodeList.forEach(node => clearCanvasCoordinates(node));
                });

                // Migrate coordinates based on new sorted order
                migrateToCanvasCoordinates();

                renderCanvas();
                console.log('Canvas sorted by:', sortConfig, '- Canvas layout updated and repositioned');
            } else {
                render();
                console.log('Tree sorted by:', sortConfig, '- Visual layout updated');
            }
        }

        // Initialize Sort System
        const sortSelect = document.getElementById('pattern-sort-select');
        const resetSortBtn = document.getElementById('reset-sort-btn');

        if (sortSelect) {
            // Handle sort selection
            sortSelect.addEventListener('change', function() {
                const selectedOption = this.options[this.selectedIndex];

                if (!this.value || this.value === '') {
                    // Reset to default order
                    currentSortConfig = null;
                    sortTree(null);
                    if (resetSortBtn) resetSortBtn.style.display = 'none';
                    console.log('Sort reset to default order');

                    // Auto-sync: reset cluster too if linked
                    if (sortClusterLinked) {
                        const clusterSelect = document.getElementById('cluster-by-select');
                        if (clusterSelect) {
                            clusterSelect.value = '';
                            clusterByField = '';
                            if (viewMode === 'canvas') {
                                applyForceDirectedLayout();
                                renderCanvas();
                            }
                        }
                    }
                } else {
                    // Apply sort
                    const sortConfig = {
                        value: this.value,
                        field: selectedOption.dataset.field,
                        order: selectedOption.dataset.order,
                        type: selectedOption.dataset.type
                    };

                    sortTree(sortConfig);
                    if (resetSortBtn) resetSortBtn.style.display = 'inline-block';

                    // Auto-sync: update cluster to match sort field if linked
                    if (sortClusterLinked && sortConfig.field) {
                        const clusterSelect = document.getElementById('cluster-by-select');
                        if (clusterSelect) {
                            // Try to find matching cluster option
                            const matchingOption = Array.from(clusterSelect.options).find(
                                opt => opt.value === sortConfig.field
                            );
                            if (matchingOption) {
                                clusterSelect.value = sortConfig.field;
                                clusterByField = sortConfig.field;
                                if (viewMode === 'canvas') {
                                    applyForceDirectedLayout();
                                    renderCanvas();
                                }
                                console.log(`ðŸ”— Auto-synced Cluster to: ${sortConfig.field}`);
                            }
                        }
                    }

                    // Show toast notification
                    const linkedMsg = sortClusterLinked ? ' (Canvas synced)' : '';
                    showToast(`Sorted: ${selectedOption.textContent}${linkedMsg}`, 'success', 2000);
                }
            });

            console.log('Sort dropdown event listener attached');
        }

        if (resetSortBtn) {
            resetSortBtn.addEventListener('click', function() {
                currentSortConfig = null;
                sortTree(null);
                sortSelect.value = '';
                this.style.display = 'none';

                // Show toast notification
                const toast = document.createElement('div');
                toast.textContent = 'Sort Reset';
                toast.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    right: 20px;
                    padding: 12px 24px;
                    background: var(--card-bg);
                    border: 2px solid var(--border);
                    border-radius: 12px;
                    color: var(--text-primary);
                    font-weight: 600;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: var(--shadow-lg);
                `;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2000);
            });
        }

        // Update sort dropdown on initial load
        updateSortDropdown();

        // Sort-Cluster link toggle button
        const linkBtn = document.getElementById('sort-cluster-link-btn');
        if (linkBtn) {
            linkBtn.addEventListener('click', function() {
                sortClusterLinked = !sortClusterLinked;
                this.textContent = sortClusterLinked ? 'ðŸ”—' : 'ðŸ”“';
                this.title = sortClusterLinked
                    ? 'Click to unlink Sort from Canvas Cluster. When linked, changing Sort also changes Canvas clustering.'
                    : 'Click to link Sort with Canvas Cluster. Currently independent.';
                this.style.opacity = sortClusterLinked ? '0.8' : '0.5';
                showToast(sortClusterLinked ? 'ðŸ”— Sort & Cluster linked' : 'ðŸ”“ Sort & Cluster independent', 'info', 2000);
            });
        }

        console.log('Sorting system initialized');

        // ============================================
        // AI TOOLS SIDEBAR SYNC
        // ============================================
        // Note: AI Tools sidebar is always visible and auto-expands on hover (no toggle needed)

        const aiModeSelectHeader = document.getElementById('unified-ai-mode-select');
        const aiModeSelectPanel = document.getElementById('unified-ai-mode-select-panel');

        // Sync AI Model selectors (header <-> panel)
        if (aiModeSelectHeader && aiModeSelectPanel) {
            // Sync panel -> header
            aiModeSelectPanel.addEventListener('change', function() {
                aiModeSelectHeader.value = this.value;
                console.log('AI mode synced from panel to header:', this.value);
            });

            // Sync header -> panel
            aiModeSelectHeader.addEventListener('change', function() {
                aiModeSelectPanel.value = this.value;
                console.log('AI mode synced from header to panel:', this.value);
            });

            // Initial sync
            aiModeSelectPanel.value = aiModeSelectHeader.value;
        }

        console.log('AI Tools panel initialized');

        // Initialize pan/zoom controls
        initPanZoom();

        // Splash screen auto-dismiss
        setTimeout(() => {
            const splashScreen = document.getElementById('splash-screen');
            if (splashScreen) {
                splashScreen.classList.add('fade-out');
                // Remove from DOM after fade-out animation completes
                setTimeout(() => {
                    splashScreen.remove();
                }, 500); // Match fade-out animation duration
            }
        }, 2000); // Show splash for 2 seconds (matches loader animation)

        // ============================================================================
        // FREE SPEECH - Stream of Consciousness Voice Capture (Build 240)
        // ============================================================================

        // Free Speech Session State
        const freeSpeechSession = {
            // State machine: IDLE -> WARMUP -> RECORDING -> PROCESSING -> REVEAL
            state: 'IDLE',

            // Web Speech API
            recognition: null,

            // Transcript (EPHEMERAL - never persisted, deleted after analysis)
            transcript: [],

            // Nudge system
            nudgeTimer: null,
            lastSpeechTime: null,
            currentNudgeIndex: 0,

            // Gamification metrics
            metrics: {
                totalDuration: 0,
                silenceCount: 0,
                nudgeCount: 0,
                wordCount: 0,
                uniqueWords: new Set(),
                fillerWords: 0,
                hedgeCount: 0,
                restartCount: 0,
                longestUninterruptedFlow: 0,
                currentFlowDuration: 0,
                startTime: null
            }
        };

        // Nudge prompts - gentle, non-judgmental momentum maintainers
        const NUDGES = [
            { text: '...', delay: 5000 },          // Soft ellipsis after 5s
            { text: 'mmhmm...', delay: 8000 },     // Acknowledgment after 8s
            { text: 'and...?', delay: 12000 },     // Continuation prompt
            { text: 'keep going...', delay: 16000 },
            { text: 'what else...?', delay: 20000 },
            { text: 'take your time...', delay: 25000 }
        ];

        // Filler words to detect
        const FILLER_WORDS = ['um', 'uh', 'like', 'you know', 'basically', 'actually', 'literally', 'sort of', 'kind of'];

        // Hedge words (self-editing indicators)
        const HEDGE_WORDS = ['i think', 'maybe', 'probably', 'i guess', 'i mean', 'sort of', 'kind of', 'i suppose'];

        // Restart indicators
        const RESTART_PHRASES = ['no wait', 'let me start over', 'actually no', 'i mean', 'scratch that', 'no no'];

        // Open Free Speech modal
        function openFreeSpeechModal() {
            const modal = document.getElementById('freespeech-modal');
            if (modal) {
                modal.style.display = 'flex';
                resetFreeSpeechModal();
            }
        }

        // Close Free Speech modal
        function closeFreeSpeechModal() {
            const modal = document.getElementById('freespeech-modal');
            if (modal) {
                modal.style.display = 'none';
                stopFreeSpeechRecording();
            }
        }

        // Reset modal to idle state
        function resetFreeSpeechModal() {
            freeSpeechSession.state = 'IDLE';
            freeSpeechSession.transcript = [];
            freeSpeechSession.currentNudgeIndex = 0;

            // Reset metrics
            freeSpeechSession.metrics = {
                totalDuration: 0,
                silenceCount: 0,
                nudgeCount: 0,
                wordCount: 0,
                uniqueWords: new Set(),
                fillerWords: 0,
                hedgeCount: 0,
                restartCount: 0,
                longestUninterruptedFlow: 0,
                currentFlowDuration: 0,
                startTime: null
            };

            // Show/hide appropriate sections
            document.getElementById('freespeech-idle').style.display = 'block';
            document.getElementById('freespeech-warmup').style.display = 'none';
            document.getElementById('freespeech-recording').style.display = 'none';
            document.getElementById('freespeech-processing').style.display = 'none';
            document.getElementById('freespeech-error').style.display = 'none';
            document.getElementById('freespeech-nudge').textContent = '';
        }

        // Start warmup countdown
        function startFreeSpeechWarmup() {
            // Check for Web Speech API support
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showFreeSpeechError('Speech recognition is not supported in this browser. Please use Chrome, Edge, or Safari.');
                return;
            }

            freeSpeechSession.state = 'WARMUP';
            document.getElementById('freespeech-idle').style.display = 'none';
            document.getElementById('freespeech-warmup').style.display = 'block';

            // Countdown animation
            const countdownEl = document.getElementById('freespeech-countdown');
            let count = 3;
            countdownEl.textContent = count;

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.textContent = count;
                } else {
                    clearInterval(countdownInterval);
                    startFreeSpeechRecording();
                }
            }, 1000);
        }

        // Start actual recording
        function startFreeSpeechRecording() {
            freeSpeechSession.state = 'RECORDING';
            document.getElementById('freespeech-warmup').style.display = 'none';
            document.getElementById('freespeech-recording').style.display = 'block';

            // Initialize Web Speech API
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            freeSpeechSession.recognition = new SpeechRecognition();

            const recognition = freeSpeechSession.recognition;
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            // Track timing
            freeSpeechSession.metrics.startTime = Date.now();
            freeSpeechSession.lastSpeechTime = Date.now();

            // Handle speech results
            recognition.onresult = (event) => {
                const now = Date.now();

                // Calculate flow duration
                const timeSinceLastSpeech = now - freeSpeechSession.lastSpeechTime;
                if (timeSinceLastSpeech < 2000) {
                    freeSpeechSession.metrics.currentFlowDuration += timeSinceLastSpeech;
                } else {
                    // Flow broken, check if it was longest
                    if (freeSpeechSession.metrics.currentFlowDuration > freeSpeechSession.metrics.longestUninterruptedFlow) {
                        freeSpeechSession.metrics.longestUninterruptedFlow = freeSpeechSession.metrics.currentFlowDuration;
                    }
                    freeSpeechSession.metrics.currentFlowDuration = 0;
                }
                freeSpeechSession.lastSpeechTime = now;

                // Process results
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    const text = result[0].transcript.trim();

                    if (result.isFinal) {
                        if (text) {
                            freeSpeechSession.transcript.push({
                                text: text,
                                timestamp: now - freeSpeechSession.metrics.startTime,
                                confidence: result[0].confidence
                            });
                            console.log('Captured:', text);

                            // Analyze for metrics
                            analyzeTranscriptSegment(text);
                        }
                        // Clear the "hearing" indicator
                        document.getElementById('freespeech-nudge').textContent = '';
                    } else {
                        // Show interim results so user knows mic is working
                        // (but don't show the actual words - just indicate hearing)
                        const wordCount = text.split(/\s+/).length;
                        if (wordCount > 0) {
                            document.getElementById('freespeech-nudge').innerHTML = '<span style="color: #10b981;">ðŸŽ§ hearing you...</span>';
                        }
                    }
                }

                // Clear nudge when user speaks
                freeSpeechSession.currentNudgeIndex = 0;
                resetNudgeTimer();
            };

            recognition.onerror = (event) => {
                console.log('Speech recognition event:', event.error);
                // These errors are normal and should not stop recording
                if (event.error === 'no-speech' || event.error === 'aborted' || event.error === 'network') {
                    console.log('Non-fatal speech error, continuing...');
                    return;
                }
                // Only show error for real problems
                if (event.error === 'not-allowed') {
                    showFreeSpeechError('Microphone access denied. Please allow microphone permission and try again.');
                } else if (event.error === 'audio-capture') {
                    showFreeSpeechError('No microphone found. Please connect a microphone and try again.');
                } else {
                    showFreeSpeechError(`Speech recognition error: ${event.error}`);
                }
            };

            recognition.onstart = () => {
                console.log('Speech recognition started successfully');
            };

            recognition.onaudiostart = () => {
                console.log('Audio capture started - microphone is active');
            };

            recognition.onend = () => {
                console.log('Speech recognition ended, state:', freeSpeechSession.state);
                // Restart if still recording (continuous mode workaround for Chrome)
                if (freeSpeechSession.state === 'RECORDING') {
                    console.log('Restarting recognition...');
                    setTimeout(() => {
                        if (freeSpeechSession.state === 'RECORDING') {
                            try {
                                recognition.start();
                            } catch (e) {
                                console.log('Recognition restart blocked:', e);
                            }
                        }
                    }, 100); // Small delay before restart
                }
            };

            // Start recognition
            try {
                console.log('Starting speech recognition...');
                recognition.start();
                startNudgeTimer();
                console.log('Recognition start() called');
            } catch (e) {
                console.error('Failed to start:', e);
                showFreeSpeechError('Failed to start speech recognition. Please try again.');
            }
        }

        // Analyze a transcript segment for metrics
        function analyzeTranscriptSegment(text) {
            const words = text.toLowerCase().split(/\s+/);
            freeSpeechSession.metrics.wordCount += words.length;

            words.forEach(word => {
                freeSpeechSession.metrics.uniqueWords.add(word.replace(/[^a-z]/g, ''));
            });

            // Check for filler words
            const lowerText = text.toLowerCase();
            FILLER_WORDS.forEach(filler => {
                const regex = new RegExp(`\\b${filler}\\b`, 'gi');
                const matches = lowerText.match(regex);
                if (matches) {
                    freeSpeechSession.metrics.fillerWords += matches.length;
                }
            });

            // Check for hedges
            HEDGE_WORDS.forEach(hedge => {
                if (lowerText.includes(hedge)) {
                    freeSpeechSession.metrics.hedgeCount++;
                }
            });

            // Check for restarts
            RESTART_PHRASES.forEach(restart => {
                if (lowerText.includes(restart)) {
                    freeSpeechSession.metrics.restartCount++;
                }
            });
        }

        // Nudge timer management
        function startNudgeTimer() {
            clearNudgeTimer();
            freeSpeechSession.nudgeTimer = setInterval(() => {
                if (freeSpeechSession.state !== 'RECORDING') {
                    clearNudgeTimer();
                    return;
                }

                const timeSinceLastSpeech = Date.now() - freeSpeechSession.lastSpeechTime;

                // Find appropriate nudge based on silence duration
                for (let i = NUDGES.length - 1; i >= 0; i--) {
                    if (timeSinceLastSpeech >= NUDGES[i].delay) {
                        if (i > freeSpeechSession.currentNudgeIndex - 1) {
                            document.getElementById('freespeech-nudge').textContent = NUDGES[i].text;
                            freeSpeechSession.currentNudgeIndex = i + 1;
                            freeSpeechSession.metrics.nudgeCount++;
                            freeSpeechSession.metrics.silenceCount++;
                        }
                        break;
                    }
                }
            }, 1000);
        }

        function resetNudgeTimer() {
            freeSpeechSession.currentNudgeIndex = 0;
        }

        function clearNudgeTimer() {
            if (freeSpeechSession.nudgeTimer) {
                clearInterval(freeSpeechSession.nudgeTimer);
                freeSpeechSession.nudgeTimer = null;
            }
        }

        // Stop recording and process
        function stopFreeSpeechRecording() {
            if (freeSpeechSession.recognition) {
                freeSpeechSession.recognition.stop();
                freeSpeechSession.recognition = null;
            }
            clearNudgeTimer();

            if (freeSpeechSession.state === 'RECORDING') {
                // Calculate final duration
                if (freeSpeechSession.metrics.startTime) {
                    freeSpeechSession.metrics.totalDuration = (Date.now() - freeSpeechSession.metrics.startTime) / 1000;
                }

                // Check final flow
                if (freeSpeechSession.metrics.currentFlowDuration > freeSpeechSession.metrics.longestUninterruptedFlow) {
                    freeSpeechSession.metrics.longestUninterruptedFlow = freeSpeechSession.metrics.currentFlowDuration;
                }

                // Process transcript
                processFreeSpeechTranscript();
            }
        }

        // Process transcript with AI
        async function processFreeSpeechTranscript() {
            freeSpeechSession.state = 'PROCESSING';
            document.getElementById('freespeech-recording').style.display = 'none';
            document.getElementById('freespeech-processing').style.display = 'block';

            // Check if we have any transcript
            if (freeSpeechSession.transcript.length === 0) {
                showFreeSpeechError('No speech was detected. Please try again and speak clearly.');
                return;
            }

            // Combine transcript
            const fullTranscript = freeSpeechSession.transcript.map(t => t.text).join(' ');

            // Show progress
            const progressEl = document.getElementById('freespeech-progress');
            progressEl.style.width = '20%';

            try {
                // Call AI to analyze
                const tree = await analyzeFreeSpeechTranscript(fullTranscript, freeSpeechSession.metrics);
                progressEl.style.width = '100%';

                // Small delay for visual feedback
                await new Promise(resolve => setTimeout(resolve, 500));

                // Load the tree and close modal
                if (tree) {
                    // Set the pattern
                    currentPattern = 'freespeech';

                    // Load tree data
                    capexTree = tree;

                    // Render
                    render();

                    // Close modal
                    closeFreeSpeechModal();

                    // Show success notification
                    if (typeof showNotification === 'function') {
                        showNotification('Free Speech session analyzed! Explore your psychological patterns.', 'success');
                    }
                }
            } catch (error) {
                console.error('Free Speech analysis error:', error);
                showFreeSpeechError('Failed to analyze your speech. Please try again.');
            } finally {
                // PRIVACY: Delete transcript immediately after analysis
                freeSpeechSession.transcript = [];
            }
        }

        // AI Analysis function
        async function analyzeFreeSpeechTranscript(transcript, metrics) {
            const systemPrompt = `You are a psychological pattern analyst examining stream-of-consciousness speech.
The speaker was encouraged to talk freely without self-editing.

DO NOT summarize what they said.
DO NOT organize their explicit points.
DO NOT judge or evaluate their thoughts.

Your task is to find SURPRISING PATTERNS that reveal psychological topology:

1. REPETITION - Words/phrases/themes appearing 3+ times
   (Repetition = importance, even if speaker doesn't realize it)

2. EMOTIONAL WEIGHT - Where language intensifies
   (Stronger adjectives, qualifiers like "really", "actually", "honestly")

3. NAMED ENTITIES - Who/what mentioned, frequency, context
   (Frequency reveals actual vs stated priorities)

4. CONTRADICTIONS - Opposing statements or logical inconsistencies
   (Windows into internal conflict or ambivalence)

5. AVOIDANCE - Logical topics that SHOULD have appeared but DIDN'T
   (Negative space is data - what wasn't said matters)

6. IMPLICIT BELIEFS - Unstated assumptions underlying statements
   ("I just need to work harder" assumes effort = results)

7. SENTENCE STRUCTURES - Patterns like "I should..." vs "I want..." vs "I have to..."
   (Grammar reveals agency patterns and relationship to desires)

Output a TreeListy-compatible JSON tree that REVEALS rather than ORGANIZES.

The tree should have this structure:
{
  "id": "session-[timestamp]",
  "name": "[Create a poetic/insightful session title based on themes]",
  "type": "session",
  "pattern": "freespeech",
  "children": [
    {
      "id": "theme-1",
      "name": "[Theme Name]",
      "type": "phase",
      "items": [
        {
          "id": "pattern-1",
          "name": "[Pattern Name]",
          "type": "item",
          "itemType": "[one of: repetition, emotional, contradiction, avoidance, implicit, entity, structure]",
          "frequency": [number],
          "emotionalIntensity": "[Low/Medium/High/Peak]",
          "quotedText": "[exact words from transcript]",
          "insight": "[what this pattern reveals]",
          "subItems": [
            {
              "id": "evidence-1",
              "name": "[Evidence summary]",
              "type": "subtask",
              "quotedText": "[supporting quote]"
            }
          ]
        }
      ]
    }
  ]
}

Session Metrics (for context):
- Duration: ${Math.round(metrics.totalDuration)} seconds
- Word count: ${metrics.wordCount}
- Unique words: ${metrics.uniqueWords.size}
- Filler words: ${metrics.fillerWords}
- Self-editing hedges: ${metrics.hedgeCount}
- Restarts: ${metrics.restartCount}
- Nudges needed: ${metrics.nudgeCount}
- Longest uninterrupted flow: ${Math.round(metrics.longestUninterruptedFlow / 1000)} seconds`;

            const userPrompt = `Analyze this stream-of-consciousness transcript and return ONLY valid JSON (no markdown, no explanation):

TRANSCRIPT:
${transcript}`;

            try {
                // Use the existing AI call infrastructure
                const response = await callClaudeAPI(systemPrompt, userPrompt);

                // Parse the JSON response
                let tree;
                try {
                    // Try to extract JSON from response
                    const jsonMatch = response.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        tree = JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('No JSON found in response');
                    }
                } catch (parseError) {
                    console.error('JSON parse error:', parseError);
                    // Create a minimal fallback tree
                    tree = {
                        id: `session-${Date.now()}`,
                        name: 'Free Speech Session',
                        type: 'session',
                        pattern: 'freespeech',
                        children: [{
                            id: 'theme-1',
                            name: 'Raw Transcript',
                            type: 'phase',
                            items: [{
                                id: 'pattern-1',
                                name: 'Full Recording',
                                type: 'item',
                                itemType: 'repetition',
                                frequency: 1,
                                emotionalIntensity: 'Medium',
                                quotedText: transcript.substring(0, 500) + (transcript.length > 500 ? '...' : ''),
                                insight: 'Analysis could not be parsed. Raw transcript preserved.',
                                subItems: []
                            }]
                        }]
                    };
                }

                return tree;
            } catch (error) {
                console.error('AI call error:', error);
                throw error;
            }
        }

        // Show error state
        function showFreeSpeechError(message) {
            freeSpeechSession.state = 'ERROR';
            document.getElementById('freespeech-idle').style.display = 'none';
            document.getElementById('freespeech-warmup').style.display = 'none';
            document.getElementById('freespeech-recording').style.display = 'none';
            document.getElementById('freespeech-processing').style.display = 'none';
            document.getElementById('freespeech-error').style.display = 'block';
            document.getElementById('freespeech-error-message').textContent = message;
        }

        // Expose functions globally
        window.openFreeSpeechModal = openFreeSpeechModal;
        window.closeFreeSpeechModal = closeFreeSpeechModal;
        window.startFreeSpeechWarmup = startFreeSpeechWarmup;
        window.stopFreeSpeechRecording = stopFreeSpeechRecording;
        window.resetFreeSpeechModal = resetFreeSpeechModal;

        console.log('Free Speech module initialized (Build 240)');

    </script>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         CHAT ASSISTANT MODULE (Build 248)
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script>
    (function() {
        'use strict';

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHAT ASSISTANT STATE
        // BUILD 355: Added conversation memory persistence (last 5 exchanges)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const chatState = {
            isOpen: false,
            isProcessing: false,
            conversationHistory: [],
            voiceRecognition: null,
            isRecording: false,
            // Playground Mode (Build 255)
            playgroundMode: false,
            playgroundSystemPrompt: '',
            playgroundModel: 'claude-sonnet',
            playgroundHistory: [],
            // BUILD 366: LifeTree Biographer Mode
            biographerMode: null, // null, 'guided', 'listening', 'scaffolding', 'artifact'
            // BUILD 368: Conversation Mode - Full AI intelligence
            conversationMode: false, // When true, uses full AI conversation instead of command mode
            lastConversationContext: null, // Stores context for action extraction
            // BUILD 393: New Command Frame UI
            commandFrameMinimized: false
        };

        // BUILD 393: Feature flag for new Command Frame UI
        // Users can toggle via settings - stored in localStorage
        window.useNewChatUI = false; // Classic panel for TreeBeard // Default: true (new UI)

        // BUILD 355: Load conversation memory from localStorage
        (function loadConversationMemory() {
            try {
                const saved = localStorage.getItem('treebeardConversation');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Only keep last 5 exchanges (10 messages: 5 user + 5 assistant)
                    chatState.conversationHistory = parsed.slice(-10);
                    console.log(`ðŸŒ³ TreeBeard memory loaded: ${chatState.conversationHistory.length} messages`);
                }
            } catch (e) {
                console.warn('Could not load TreeBeard conversation memory:', e);
            }
        })();

        // BUILD 355: Save conversation memory to localStorage
        function saveConversationMemory() {
            try {
                // Keep only last 10 messages (5 exchanges)
                const toSave = chatState.conversationHistory.slice(-10);
                localStorage.setItem('treebeardConversation', JSON.stringify(toSave));
            } catch (e) {
                console.warn('Could not save TreeBeard conversation memory:', e);
            }
        }

        // BUILD 355: Restore conversation UI from memory
        function restoreConversationUI() {
            if (chatState.conversationHistory.length === 0) return;

            const messagesContainer = document.getElementById('chat-assistant-messages');
            if (!messagesContainer) return;

            // Clear the default welcome message
            messagesContainer.innerHTML = '';

            // Show a context indicator
            const contextDiv = document.createElement('div');
            contextDiv.className = 'chat-message assistant';
            contextDiv.style.opacity = '0.7';
            contextDiv.style.fontSize = '12px';
            contextDiv.innerHTML = `<em>ðŸ“œ Continuing from last session (${Math.ceil(chatState.conversationHistory.length / 2)} exchanges)</em>`;
            messagesContainer.appendChild(contextDiv);

            // Restore each message
            chatState.conversationHistory.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${msg.role}`;

                // Format content
                let formattedContent = msg.content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\n/g, '<br>');

                messageDiv.innerHTML = formattedContent;
                messagesContainer.appendChild(messageDiv);
            });

            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            console.log('ðŸŒ³ TreeBeard conversation UI restored');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMMAND REGISTRY - Maps intents to TreeListy functions
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const COMMAND_REGISTRY = {
            // View commands
            'switch_to_canvas': () => {
                const container = document.getElementById('canvas-container');
                if (container && !container.classList.contains('active')) {
                    document.getElementById('toggle-view-mode')?.click();
                }
                return 'ðŸŽ¨ Switched to Canvas view!';
            },
            'switch_to_tree': () => {
                const container = document.getElementById('canvas-container');
                if (container && container.classList.contains('active')) {
                    document.getElementById('toggle-view-mode')?.click();
                }
                return 'ðŸŒ³ Switched to Tree view!';
            },
            'toggle_view': () => {
                document.getElementById('toggle-view-mode')?.click();
                return 'ðŸ”„ View toggled!';
            },

            // Theme commands
            'set_theme_dark': () => {
                document.getElementById('theme-select').value = 'default';
                document.getElementById('theme-select').dispatchEvent(new Event('change'));
                return 'ðŸŒ™ Dark theme applied!';
            },
            'set_theme_steampunk': () => {
                document.getElementById('theme-select').value = 'steampunk';
                document.getElementById('theme-select').dispatchEvent(new Event('change'));
                return 'âš™ï¸ Steampunk theme applied!';
            },
            'set_theme_tron': () => {
                document.getElementById('theme-select').value = 'tron';
                document.getElementById('theme-select').dispatchEvent(new Event('change'));
                return 'ðŸ’  Tron theme applied!';
            },

            // Pattern commands
            'list_patterns': () => {
                const patterns = ['Generic', 'Philosophy', 'Sales', 'CAPEX', 'Thesis', 'Roadmap', 'Book', 'Film', 'Course', 'Fitness', 'Event', 'Strategy', 'Family Tree', 'Dialogue', 'File System'];
                return 'ðŸ“‹ Available patterns:\nâ€¢ ' + patterns.join('\nâ€¢ ');
            },
            'switch_pattern': (patternName) => {
                const select = document.getElementById('pattern-select');
                if (select) {
                    const options = Array.from(select.options);
                    const match = options.find(o => o.text.toLowerCase().includes(patternName.toLowerCase()));
                    if (match) {
                        select.value = match.value;
                        select.dispatchEvent(new Event('change'));
                        return `âœ… Switched to ${match.text} pattern!`;
                    }
                }
                return `âŒ Pattern "${patternName}" not found. Try "list patterns" to see options.`;
            },

            // Export commands
            'export_json': () => {
                document.getElementById('save-btn')?.click();
                return 'ðŸ’¾ JSON file downloaded!';
            },
            'export_excel': () => {
                document.getElementById('excel-export-btn')?.click();
                return 'ðŸ“Š Excel file downloaded!';
            },
            'export_canvas_image': () => {
                if (typeof exportCanvasAsImage === 'function') {
                    exportCanvasAsImage();
                    return 'ðŸ“· Canvas exported as PNG!';
                }
                return 'âŒ Please switch to Canvas view first.';
            },

            // Tree manipulation
            'add_phase': () => {
                document.getElementById('add-phase-btn')?.click();
                return 'âž• New phase added! You can rename it by clicking on it.';
            },
            'expand_all': () => {
                document.getElementById('expand-btn')?.click();
                return 'â¬‡ï¸ Expanded one level!';
            },
            'collapse_all': () => {
                document.getElementById('collapse-btn')?.click();
                return 'â¬†ï¸ Collapsed one level!';
            },
            'undo': () => {
                document.getElementById('undo-btn')?.click();
                return 'â†©ï¸ Undo complete!';
            },
            'redo': () => {
                document.getElementById('redo-btn')?.click();
                return 'â†ªï¸ Redo complete!';
            },

            // AI operations
            'enhance_selected': async () => {
                const selectedNodes = window.selectedCanvasNodes || [];
                if (selectedNodes.length === 0) {
                    return 'âš ï¸ No nodes selected. Select some items first!';
                }
                // Trigger enhance on selected
                if (typeof enhanceWithAI === 'function') {
                    await enhanceWithAI(selectedNodes);
                    return `âœ¨ Enhancing ${selectedNodes.length} selected item(s)...`;
                }
                return 'âŒ AI enhancement not available.';
            },

            // Help
            'show_help': () => {
                document.getElementById('how-to-btn')?.click();
                return 'ðŸ“– Opening help modal...';
            },

            // Project operations
            'new_project': () => {
                document.getElementById('new-project-btn')?.click();
                return 'ðŸ†• New project dialog opened!';
            },
            'open_wizard': () => {
                document.getElementById('wizard-btn')?.click();
                return 'ðŸ§™ Build Wizard opened!';
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ADDITIONAL COMMANDS (Build 249)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // File operations
            'import_text': () => {
                document.getElementById('import-text-header-btn')?.click();
                return 'ðŸ“¥ Text import modal opened! Paste any text and AI will structure it.';
            },
            'load_json': () => {
                document.getElementById('load-json-btn')?.click();
                return 'ðŸ“‚ File picker opened! Select a TreeListy JSON file.';
            },
            'import_excel': () => {
                document.getElementById('excel-import-btn')?.click();
                return 'ðŸ“Š Excel import started! Select an Excel file to analyze.';
            },
            'share_url': () => {
                document.getElementById('share-btn')?.click();
                return 'ðŸ“¤ Generating shareable URL...';
            },
            'live_sync': () => {
                document.getElementById('live-sync-btn')?.click();
                return 'ðŸ”„ Firebase Live Sync modal opened!';
            },
            'refresh_drive': () => {
                document.getElementById('refresh-drive-btn')?.click();
                return 'â˜ï¸ Refreshing from Google Drive...';
            },

            // Search
            'search': () => {
                document.getElementById('search-btn')?.click();
                return 'ðŸ” Search modal opened! Type to search all fields.';
            },

            // Settings
            'open_settings': () => {
                document.getElementById('api-key-btn')?.click();
                return 'ðŸ”‘ API settings opened! Configure your AI provider keys.';
            },

            // AI operations
            'generate_image': () => {
                // Need to trigger Imagen modal - check if nodes selected
                const selectedNodes = window.selectedCanvasNodes || [];
                if (selectedNodes.length === 0) {
                    return 'âš ï¸ Select some nodes first, then ask me to generate an image!';
                }
                if (typeof showImagenModal === 'function') {
                    showImagenModal(selectedNodes);
                    return 'ðŸŽ¨ Imagen modal opened! Choose a style and generate.';
                }
                return 'âŒ Image generation not available.';
            },
            'deep_dive': () => {
                const selectedNodes = window.selectedCanvasNodes || [];
                if (selectedNodes.length === 0) {
                    return 'âš ï¸ Select some nodes first for deep dive analysis!';
                }
                if (typeof performDeepDive === 'function') {
                    performDeepDive(selectedNodes);
                    return `ðŸ”¬ Running deep dive on ${selectedNodes.length} item(s)...`;
                }
                return 'âŒ Deep dive not available.';
            },

            // Missing theme
            'set_theme_powerpuff': () => {
                document.getElementById('theme-select').value = 'powerpuff';
                document.getElementById('theme-select').dispatchEvent(new Event('change'));
                return 'ðŸ’— Powerpuff theme applied!';
            },

            // Redo (was missing proper implementation)
            'redo': () => {
                if (typeof redo === 'function') {
                    redo();
                    return 'â†ªï¸ Redo complete!';
                }
                return 'âŒ Nothing to redo.';
            },

            // Layout commands for Canvas
            'layout_hierarchical': () => {
                const select = document.getElementById('auto-layout-select');
                if (select) {
                    select.value = 'hierarchical';
                    select.dispatchEvent(new Event('change'));
                    return 'ðŸŒ³ Hierarchical layout applied!';
                }
                return 'âŒ Switch to Canvas view first.';
            },
            'layout_timeline': () => {
                const select = document.getElementById('auto-layout-select');
                if (select) {
                    select.value = 'timeline';
                    select.dispatchEvent(new Event('change'));
                    return 'ðŸ“… Timeline layout applied!';
                }
                return 'âŒ Switch to Canvas view first.';
            },
            'layout_force': () => {
                const select = document.getElementById('auto-layout-select');
                if (select) {
                    select.value = 'force';
                    select.dispatchEvent(new Event('change'));
                    return 'ðŸŒ€ Force-directed layout applied!';
                }
                return 'âŒ Switch to Canvas view first.';
            },

            // Selection helpers
            'select_all': () => {
                if (typeof selectAllNodes === 'function') {
                    selectAllNodes();
                    return 'âœ… All nodes selected!';
                }
                return 'âŒ Switch to Canvas view first.';
            },
            'clear_selection': () => {
                if (typeof clearCanvasSelection === 'function') {
                    clearCanvasSelection();
                    return 'ðŸ”² Selection cleared!';
                }
                window.selectedCanvasNodes = [];
                return 'ðŸ”² Selection cleared!';
            },

            // Project info
            'project_info': () => {
                const name = typeof capexTree !== 'undefined' ? capexTree.name : 'Unknown';
                const pattern = typeof currentPattern !== 'undefined' ? currentPattern : 'generic';
                const phaseList = typeof capexTree !== 'undefined' ? (capexTree.children || capexTree.phases || []) : [];
                const phases = phaseList.length;
                const items = phaseList.reduce((sum, p) => sum + (p.items || p.children || []).length, 0);
                return `ðŸ“‹ **Project:** ${name}\n**Pattern:** ${pattern}\n**Phases:** ${phases}\n**Items:** ${items}`;
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 250: NAVIGATION & FOCUS COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Find node by name/text and select it
            'find_node': (query) => {
                if (!query) return 'âš ï¸ Please specify what to search for. Example: "find Becoming"';

                // BUILD 376: Normalize search term for flexible matching
                const normalizeForSearch = (text) => {
                    if (!text) return '';
                    let normalized = text.toLowerCase();
                    // Handle decade variations: "60's", "60s", "the 60s" -> matches "1960s"
                    normalized = normalized.replace(/[''`]/g, ''); // Remove apostrophes
                    normalized = normalized.replace(/^the\s+/i, ''); // Remove leading "the"
                    // Extract decade pattern: "60s" -> "1960s", "70s" -> "1970s"
                    const decadeMatch = normalized.match(/^(\d{2})s?$/);
                    if (decadeMatch) {
                        const decade = parseInt(decadeMatch[1]);
                        // Assume 20th century for 20-99, 21st for 00-19
                        const century = decade >= 20 ? 1900 : 2000;
                        normalized = (century + decade) + 's';
                    }
                    return normalized;
                };

                const searchNormalized = normalizeForSearch(query);

                const results = [];
                function searchTree(node, path = []) {
                    const nodeName = normalizeForSearch(node.name);
                    const nodeTitle = normalizeForSearch(node.title);
                    const nodeDesc = normalizeForSearch(node.description);

                    const nameMatch = nodeName.includes(searchNormalized) || (node.name && node.name.toLowerCase().includes(query.toLowerCase()));
                    const titleMatch = nodeTitle.includes(searchNormalized) || (node.title && node.title.toLowerCase().includes(query.toLowerCase()));
                    const descMatch = nodeDesc.includes(searchNormalized) || (node.description && node.description.toLowerCase().includes(query.toLowerCase()));

                    if (nameMatch || titleMatch || descMatch) {
                        results.push({ node, path: [...path], matchField: nameMatch ? 'name' : titleMatch ? 'title' : 'description' });
                    }

                    // Search children
                    (node.children || node.items || node.subItems || []).forEach((child, i) => {
                        searchTree(child, [...path, { name: node.name || node.id, index: i }]);
                    });
                }
                searchTree(capexTree);

                if (results.length === 0) {
                    return `âŒ No nodes found matching "${query}"`;
                }

                // Select the first match
                const firstMatch = results[0].node;
                window.chatFocusedNode = firstMatch;
                window.selectedCanvasNodes = [firstMatch];

                // Scroll to node in canvas if visible
                const nodeEl = document.querySelector(`.canvas-node[data-id="${firstMatch.id}"]`);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                // BUILD 395: Visual feedback for found node
                if (window.visualFeedback) {
                    window.visualFeedback.highlight(firstMatch.id, 'found', 4000);
                }

                const matchList = results.slice(0, 5).map((r, i) =>
                    `${i + 1}. "${r.node.name || r.node.title}" (${r.matchField})`
                ).join('\n');

                return `ðŸ” Found ${results.length} match${results.length > 1 ? 'es' : ''} for "${query}":\n${matchList}\n\nâœ… Selected: "${firstMatch.name || firstMatch.title}"`;
            },

            // Focus on a specific node by ID
            'focus_node': (nodeId) => {
                if (!nodeId) return 'âš ï¸ Please specify a node ID';

                const node = typeof getNodeById === 'function' ? getNodeById(nodeId) : null;
                if (!node) {
                    return `âŒ Node with ID "${nodeId}" not found`;
                }

                window.chatFocusedNode = node;
                window.selectedCanvasNodes = [node];

                const nodeEl = document.querySelector(`.canvas-node[data-id="${nodeId}"]`);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                return `ðŸŽ¯ Focused on: "${node.name || node.title || nodeId}"`;
            },

            // Expand focused node
            'expand_node': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                node.expanded = true;
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                const childCount = (node.children || node.items || node.subItems || []).length;
                return `â¬‡ï¸ Expanded "${node.name || node.title}" (${childCount} children)`;
            },

            // Collapse focused node
            'collapse_node': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                node.expanded = false;
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `â¬†ï¸ Collapsed "${node.name || node.title}"`;
            },

            // BUILD 394: Edit focused node
            'edit_node': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ No node selected. Click a node or use "find [name]" first.';

                // Open the edit modal for this node
                if (typeof showEditModal === 'function') {
                    showEditModal(node);
                    return `âœï¸ Opening editor for "${node.name || 'node'}"...`;
                } else if (typeof openNodeEditor === 'function') {
                    openNodeEditor(node);
                    return `âœï¸ Opening editor for "${node.name || 'node'}"...`;
                }

                // Fallback: trigger edit on the node element
                const nodeEl = document.querySelector(`[data-node-id="${node.id}"]`);
                if (nodeEl) {
                    const nameEl = nodeEl.querySelector('.node-name, .item-name, .phase-name');
                    if (nameEl) {
                        nameEl.click();
                        return `âœï¸ Click on the node name to edit it.`;
                    }
                }

                return 'âš ï¸ Unable to open editor. Try clicking directly on the node.';
            },

            // BUILD 394: Quick insight on focused node
            'quick_insight': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ No node selected. Click a node or use "find [name]" first.';

                // Build a quick summary
                const info = [];
                info.push(`ðŸ“ **${node.name || 'Unnamed Node'}**`);
                info.push(`Type: ${node.type || 'unknown'}`);

                if (node.description) info.push(`Description: ${node.description}`);
                if (node.status) info.push(`Status: ${node.status}`);
                if (node.cost) info.push(`Cost: ${node.cost}`);
                if (node.eventDate) info.push(`Date: ${node.eventDate}`);
                if (node.age) info.push(`Age: ${node.age}`);
                if (node.location) info.push(`Location: ${node.location}`);

                const children = node.children || node.items || node.subtasks || [];
                if (children.length > 0) {
                    info.push(`Children: ${children.length}`);
                }

                return info.join('\n');
            },

            // BUILD 394: Compare selected nodes
            'compare_nodes': async () => {
                const nodes = selectedNodes || [];
                if (nodes.length < 2) return 'âš ï¸ Select 2+ nodes to compare (Ctrl+click).';

                const comparison = nodes.map(n => `â€¢ **${n.name}**: ${n.description || n.status || 'No description'}`).join('\n');
                return `ðŸ”¬ Comparing ${nodes.length} nodes:\n${comparison}`;
            },

            // BUILD 394: Pattern-specific placeholders
            'refute_thesis': async () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select a thesis or argument node first.';
                return `âš”ï¸ Refutation analysis for "${node.name}":\nTo refute this thesis, consider:\nâ€¢ Counter-examples\nâ€¢ Logical inconsistencies\nâ€¢ Alternative explanations\n\nUse "enhance" for AI-powered refutation.`;
            },

            'generate_dialogue': async () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select a node to generate dialogue about.';
                return `ðŸ’¬ To generate Socratic dialogue about "${node.name}", use the AI enhancement feature with prompt: "Create a Socratic dialogue exploring this concept"`;
            },

            'analyze_argument': async () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select an argument node first.';
                return `ðŸ” Argument structure for "${node.name}":\nâ€¢ Premises: [Click to add]\nâ€¢ Conclusion: ${node.description || '[Not specified]'}\nâ€¢ Type: [Deductive/Inductive/Abductive]\n\nUse "deep dive" for detailed analysis.`;
            },

            'birthday_method': () => {
                if (typeof window.startBirthdayMethod === 'function') {
                    window.startBirthdayMethod();
                    return 'ðŸŽ‚ Starting Birthday Memory Method...';
                }
                return 'ðŸŽ‚ Birthday Method: Start from a birthday memory and expand outward. What birthday do you remember most vividly?';
            },

            'generate_followup': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select a lead or deal to generate follow-up for.';
                return `ðŸ“ž Follow-up suggestions for "${node.name}":\nâ€¢ Schedule check-in call\nâ€¢ Send relevant case study\nâ€¢ Propose next steps meeting`;
            },

            'qualify_lead': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select a lead to qualify.';
                return `ðŸ’° Lead qualification for "${node.name}":\nâ€¢ Budget: [TBD]\nâ€¢ Authority: [TBD]\nâ€¢ Need: [TBD]\nâ€¢ Timeline: [TBD]\n\nUpdate the node fields to track qualification.`;
            },

            'show_pipeline': () => {
                return 'ðŸ“ˆ Pipeline view: Switch to Canvas view for visual pipeline representation.';
            },

            'calculate_roi': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select a CAPEX item to calculate ROI.';
                const cost = node.cost || node.totalCost || 'Unknown';
                return `ðŸ’µ ROI Analysis for "${node.name}":\nâ€¢ Investment: ${cost}\nâ€¢ Expected Return: [TBD]\nâ€¢ Payback Period: [TBD]\n\nAdd financial details to the node for accurate calculations.`;
            },

            'show_budget': () => {
                return 'ðŸ“Š Budget Overview: Check the summary panel for total CAPEX allocation.';
            },

            'analyze_risks': () => {
                const node = window.chatFocusedNode || activeNode;
                if (!node) return 'âš ï¸ Select an item to analyze risks.';
                return `âš ï¸ Risk analysis for "${node.name}":\nâ€¢ Technical Risks: [TBD]\nâ€¢ Schedule Risks: [TBD]\nâ€¢ Resource Risks: [TBD]\nâ€¢ Mitigation: [TBD]`;
            },

            // Navigate to first child
            'first_child': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                const children = node.children || node.items || node.subItems || [];
                if (children.length === 0) {
                    return `âŒ "${node.name || node.title}" has no children`;
                }

                const child = children[0];
                window.chatFocusedNode = child;
                window.selectedCanvasNodes = [child];

                return `ðŸ‘¶ Moved to first child: "${child.name || child.title}"`;
            },

            // Navigate to parent
            'parent_node': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                // Find parent by searching tree
                let parent = null;
                function findParent(current, target) {
                    const children = current.children || current.items || current.subItems || [];
                    for (const child of children) {
                        if (child.id === target.id) {
                            parent = current;
                            return true;
                        }
                        if (findParent(child, target)) return true;
                    }
                    return false;
                }
                findParent(capexTree, node);

                if (!parent) {
                    return `âŒ "${node.name || node.title}" has no parent (it's the root)`;
                }

                window.chatFocusedNode = parent;
                window.selectedCanvasNodes = [parent];

                return `â¬†ï¸ Moved to parent: "${parent.name || parent.title}"`;
            },

            // Navigate to next sibling
            'next_sibling': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                // Find sibling
                let sibling = null;
                function findSibling(parent) {
                    const children = parent.children || parent.items || parent.subItems || [];
                    const idx = children.findIndex(c => c.id === node.id);
                    if (idx >= 0 && idx < children.length - 1) {
                        sibling = children[idx + 1];
                        return true;
                    }
                    for (const child of children) {
                        if (findSibling(child)) return true;
                    }
                    return false;
                }
                findSibling(capexTree);

                if (!sibling) {
                    return `âŒ "${node.name || node.title}" has no next sibling`;
                }

                window.chatFocusedNode = sibling;
                window.selectedCanvasNodes = [sibling];

                return `âž¡ï¸ Moved to next sibling: "${sibling.name || sibling.title}"`;
            },

            // Navigate to previous sibling
            'prev_sibling': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                let sibling = null;
                function findSibling(parent) {
                    const children = parent.children || parent.items || parent.subItems || [];
                    const idx = children.findIndex(c => c.id === node.id);
                    if (idx > 0) {
                        sibling = children[idx - 1];
                        return true;
                    }
                    for (const child of children) {
                        if (findSibling(child)) return true;
                    }
                    return false;
                }
                findSibling(capexTree);

                if (!sibling) {
                    return `âŒ "${node.name || node.title}" has no previous sibling`;
                }

                window.chatFocusedNode = sibling;
                window.selectedCanvasNodes = [sibling];

                return `â¬…ï¸ Moved to previous sibling: "${sibling.name || sibling.title}"`;
            },

            // List children of focused node
            'list_children': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                const children = node.children || node.items || node.subItems || [];
                if (children.length === 0) {
                    return `ðŸ“­ "${node.name || node.title}" has no children`;
                }

                const list = children.map((c, i) => `${i + 1}. ${c.name || c.title || c.id}`).join('\n');
                return `ðŸ“‹ Children of "${node.name || node.title}" (${children.length}):\n${list}`;
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // VIEW CONTROL COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'zoom_in': () => {
                if (typeof canvasZoom !== 'undefined') {
                    canvasZoom = Math.min(3, canvasZoom * 1.2);
                    if (typeof updateCanvasTransform === 'function') updateCanvasTransform();
                    return `ðŸ” Zoomed in to ${Math.round(canvasZoom * 100)}%`;
                }
                return 'âŒ Switch to Canvas view first';
            },

            'zoom_out': () => {
                if (typeof canvasZoom !== 'undefined') {
                    canvasZoom = Math.max(0.2, canvasZoom / 1.2);
                    if (typeof updateCanvasTransform === 'function') updateCanvasTransform();
                    return `ðŸ” Zoomed out to ${Math.round(canvasZoom * 100)}%`;
                }
                return 'âŒ Switch to Canvas view first';
            },

            'zoom_fit': () => {
                if (typeof fitToView === 'function') {
                    fitToView();
                    return 'ðŸ“ Fit all nodes to view';
                }
                return 'âŒ Switch to Canvas view first';
            },

            'zoom_reset': () => {
                if (typeof resetView === 'function') {
                    resetView();
                    return 'ðŸ”„ View reset to 100%';
                }
                return 'âŒ Switch to Canvas view first';
            },

            'scroll_to_node': (nodeId) => {
                const id = nodeId || (window.chatFocusedNode?.id);
                if (!id) return 'âš ï¸ No node to scroll to. Use "find [name]" first.';

                const nodeEl = document.querySelector(`.canvas-node[data-id="${id}"]`);
                if (nodeEl) {
                    nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    return `ðŸ“ Scrolled to node`;
                }
                return 'âŒ Node not visible in current view';
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIELD EDITING COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'set_title': (newTitle) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!newTitle) return 'âš ï¸ Please provide a new title';

                const oldTitle = node.name || node.title;
                if (node.name !== undefined) node.name = newTitle;
                if (node.title !== undefined) node.title = newTitle;

                if (typeof saveState === 'function') saveState('Chat: Set title');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `âœï¸ Title changed: "${oldTitle}" â†’ "${newTitle}"`;
            },

            'set_description': (newDesc) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!newDesc) return 'âš ï¸ Please provide a description';

                node.description = newDesc;

                if (typeof saveState === 'function') saveState('Chat: Set description');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `ðŸ“ Description updated for "${node.name || node.title}"`;
            },

            'set_field': (fieldAndValue) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!fieldAndValue) return 'âš ï¸ Usage: set_field:fieldName:value';

                const parts = fieldAndValue.split(':');
                if (parts.length < 2) return 'âš ï¸ Usage: set_field:fieldName:value';

                const field = parts[0];
                const value = parts.slice(1).join(':'); // Allow colons in value

                node[field] = value;

                if (typeof saveState === 'function') saveState(`Chat: Set ${field}`);
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `âœ… Set ${field} = "${value}" on "${node.name || node.title}"`;
            },

            'get_field': (field) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!field) return 'âš ï¸ Please specify a field name';

                const value = node[field];
                if (value === undefined) {
                    return `âŒ Field "${field}" not found on this node. Available fields: ${Object.keys(node).join(', ')}`;
                }

                return `ðŸ“– ${field}: "${value}"`;
            },

            'list_fields': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                const fields = Object.entries(node)
                    .filter(([k, v]) => !['children', 'items', 'subItems', 'canvasX', 'canvasY'].includes(k) && v !== null && v !== undefined)
                    .map(([k, v]) => {
                        const val = typeof v === 'string' ? (v.length > 50 ? v.substring(0, 50) + '...' : v) : v;
                        return `â€¢ ${k}: ${val}`;
                    });

                return `ðŸ“‹ Fields on "${node.name || node.title}":\n${fields.join('\n')}`;
            },

            // AI enhance specific field
            'ai_enhance_field': async (field) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!field) return 'âš ï¸ Please specify a field to enhance (e.g., description, thesis)';

                const currentValue = node[field] || '';

                // Use the proxy to enhance
                try {
                    const response = await fetch('/.netlify/functions/claude-proxy', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 500,
                            messages: [{
                                role: 'user',
                                content: `Improve this ${field} for a node titled "${node.name || node.title}" in a ${typeof currentPattern !== 'undefined' ? currentPattern : 'generic'} project tree. Keep it concise but make it more specific and actionable.\n\nCurrent ${field}: ${currentValue || '(empty)'}\n\nReturn ONLY the improved text, no explanations.`
                            }]
                        })
                    });

                    const data = await response.json();
                    const enhanced = data.content?.[0]?.text || data.choices?.[0]?.message?.content;

                    if (enhanced) {
                        node[field] = enhanced.trim();
                        if (typeof saveState === 'function') saveState(`Chat: AI enhanced ${field}`);
                        if (typeof render === 'function') render();
                        if (typeof renderCanvas === 'function') renderCanvas();
                        return `âœ¨ AI enhanced ${field}:\n"${enhanced.trim()}"`;
                    }
                    return 'âŒ AI enhancement failed - no response';
                } catch (err) {
                    return `âŒ AI enhancement failed: ${err.message}`;
                }
            },

            // Add a child node - BUILD 382: Enhanced to accept rich JSON data
            'add_child': (childData) => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (!childData) return 'âš ï¸ Please provide a name for the new child';

                let newChild;

                // BUILD 384: Support rich JSON data OR simple string with validation
                const trimmedData = childData.trim();
                console.log('ðŸ”§ add_child raw input:', childData);
                console.log('ðŸ”§ add_child trimmed:', trimmedData);

                if (trimmedData.startsWith('{')) {
                    try {
                        const parsed = JSON.parse(trimmedData);
                        console.log('ðŸ”§ add_child parsed:', parsed);

                        // BUILD 384: Extract name from multiple sources, validate it exists
                        let nodeName = parsed.name || parsed.title;
                        console.log('ðŸ”§ add_child nodeName extracted:', nodeName);

                        // If no name, try to extract from description
                        if (!nodeName && parsed.description) {
                            // Take first sentence or first 50 chars of description
                            nodeName = parsed.description.split(/[.!?]/)[0].trim().substring(0, 50);
                        }

                        // If still no name, try location + eventDate combo
                        if (!nodeName && (parsed.location || parsed.eventDate)) {
                            nodeName = [parsed.eventDate, parsed.location].filter(Boolean).join(' - ');
                        }

                        // Final validation - reject undefined/empty names
                        if (!nodeName || nodeName === 'undefined' || nodeName.trim() === '') {
                            return 'âš ï¸ Cannot create node without a name. Please include "name" in the JSON.';
                        }

                        newChild = {
                            id: 'chat_' + Date.now(),
                            name: nodeName,
                            expanded: true,
                            // LifeTree fields
                            eventDate: parsed.eventDate || parsed.when || parsed.date || '',
                            location: parsed.location || parsed.where || parsed.place || '',
                            people: parsed.people || parsed.who || '',
                            emotion: parsed.emotion || parsed.feeling || '',
                            source: parsed.source || parsed.rememberedBy || 'Subject',
                            confidence: parsed.confidence || 'Exact',
                            description: parsed.description || parsed.details || '',
                            historicalContext: parsed.historicalContext || '',
                            // Standard fields
                            type: parsed.type || 'memory'
                        };
                        // Clean out empty fields
                        Object.keys(newChild).forEach(k => {
                            if (newChild[k] === '' || newChild[k] === null || newChild[k] === undefined) {
                                if (!['id', 'name', 'expanded'].includes(k)) delete newChild[k];
                            }
                        });
                    } catch (e) {
                        // Fallback to simple string - but validate it's not undefined
                        if (childData === 'undefined' || childData.trim() === '') {
                            return 'âš ï¸ Cannot create node with empty name.';
                        }
                        newChild = {
                            id: 'chat_' + Date.now(),
                            name: childData,
                            expanded: true
                        };
                    }
                } else {
                    // Simple string format - validate
                    if (childData === 'undefined' || childData.trim() === '') {
                        return 'âš ï¸ Cannot create node with empty name.';
                    }
                    newChild = {
                        id: 'chat_' + Date.now(),
                        name: childData,
                        expanded: true
                    };
                }

                // Determine which array to use
                if (node.subItems) {
                    node.subItems.push(newChild);
                } else if (node.items) {
                    node.items.push(newChild);
                } else if (node.children) {
                    node.children.push(newChild);
                } else {
                    node.subItems = [newChild];
                }

                if (typeof saveState === 'function') saveState('Chat: Added child');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                // Focus the new child
                window.chatFocusedNode = newChild;

                // BUILD 382: Show what fields were captured
                const fieldsAdded = Object.keys(newChild).filter(k =>
                    !['id', 'name', 'expanded'].includes(k) && newChild[k]
                );
                const fieldsSummary = fieldsAdded.length > 0
                    ? ` (${fieldsAdded.join(', ')})`
                    : '';

                return `âž• Added child "${newChild.name}" to "${node.name || node.title}"${fieldsSummary}`;
            },

            // Delete focused node
            'delete_node': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';
                if (node.id === capexTree.id) return 'âŒ Cannot delete the root node';

                // Find and remove from parent
                function removeFromParent(parent) {
                    const arrays = ['children', 'items', 'subItems'];
                    for (const arr of arrays) {
                        if (parent[arr]) {
                            const idx = parent[arr].findIndex(c => c.id === node.id);
                            if (idx >= 0) {
                                parent[arr].splice(idx, 1);
                                return true;
                            }
                            for (const child of parent[arr]) {
                                if (removeFromParent(child)) return true;
                            }
                        }
                    }
                    return false;
                }

                const name = node.name || node.title;
                removeFromParent(capexTree);
                window.chatFocusedNode = null;

                if (typeof saveState === 'function') saveState('Chat: Deleted node');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `ðŸ—‘ï¸ Deleted "${name}"`;
            },

            // BUILD 392: Delete phase by ID (for health check integration)
            'delete_phase': (phaseId) => {
                if (!phaseId) return 'âš ï¸ No phase ID provided.';

                const phases = capexTree?.children || [];
                const phaseIndex = phases.findIndex(p => p.id === phaseId);

                if (phaseIndex < 0) {
                    return `âš ï¸ Phase not found: ${phaseId}`;
                }

                const phase = phases[phaseIndex];
                const itemCount = (phase.items || phase.children || []).length;

                if (typeof saveState === 'function') {
                    saveState(`Delete phase: ${phase.name}`);
                }

                capexTree.children.splice(phaseIndex, 1);

                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `ðŸ—‘ï¸ Deleted phase "${phase.name}"${itemCount > 0 ? ` (including ${itemCount} items)` : ''}`;
            },

            // Show focused node info
            'node_info': () => {
                const node = window.chatFocusedNode;
                if (!node) return 'âš ï¸ No node focused. Use "find [name]" first.';

                const children = (node.children || node.items || node.subItems || []).length;
                const fields = Object.keys(node).filter(k => !['children', 'items', 'subItems', 'canvasX', 'canvasY', 'id'].includes(k));

                return `ðŸ“ **Focused Node:**\nâ€¢ Name: ${node.name || node.title || 'Untitled'}\nâ€¢ ID: ${node.id}\nâ€¢ Children: ${children}\nâ€¢ Fields: ${fields.join(', ')}`;
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 384: REPAIR TREE - Find and fix bad nodes
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'repair_tree': () => {
                const issues = [];

                // Helper: Calculate string similarity (Jaccard-ish)
                function similarity(a, b) {
                    if (!a || !b) return 0;
                    const setA = new Set(a.toLowerCase().split(/\s+/));
                    const setB = new Set(b.toLowerCase().split(/\s+/));
                    const intersection = [...setA].filter(x => setB.has(x)).length;
                    const union = new Set([...setA, ...setB]).size;
                    return union > 0 ? intersection / union : 0;
                }

                // Helper: Generate smart name suggestion from children
                function suggestName(node) {
                    const children = node.children || node.items || node.subItems || [];
                    if (children.length === 0) return 'Unnamed memory';

                    const firstChild = children[0];
                    const childName = firstChild.name || firstChild.title || '';
                    const location = firstChild.location || '';
                    const eventDate = firstChild.eventDate || '';

                    // Try to create a descriptive name
                    if (location) {
                        return `${location} memories`;
                    } else if (eventDate) {
                        return `${eventDate} - ${childName.substring(0, 30)}`;
                    } else if (childName) {
                        // Shorten if too long
                        return childName.length > 40 ? childName.substring(0, 37) + '...' : childName;
                    }
                    return 'Memory group';
                }

                // Helper: Get parent path for context
                function getNodePath(targetNode, current = capexTree, path = []) {
                    if (current.id === targetNode.id) return path;
                    const children = current.children || current.items || current.subItems || [];
                    for (const child of children) {
                        const result = getNodePath(targetNode, child, [...path, current.name || current.title || '?']);
                        if (result) return result;
                    }
                    return null;
                }

                // Recursive scan for issues
                function scanNode(node, parent = null, phase = null) {
                    const nodeName = node.name || node.title || '';
                    const nodeId = node.id || '';

                    // Check 1: Undefined/empty names
                    if (!nodeName || nodeName === 'undefined' || nodeName.trim() === '') {
                        issues.push({
                            type: 'undefined',
                            node: node,
                            parent: parent,
                            phase: phase,
                            suggestion: suggestName(node)
                        });
                    }

                    // Check 2: Malformed data - missing ID
                    if (!nodeId) {
                        issues.push({
                            type: 'missing_id',
                            node: node,
                            parent: parent,
                            phase: phase
                        });
                    }

                    // Recurse into children
                    const children = node.children || node.items || node.subItems || [];
                    const currentPhase = node.type === 'phase' ? node : phase;
                    children.forEach(child => scanNode(child, node, currentPhase));
                }

                // Start scan from root
                scanNode(capexTree);

                // Check 3: Duplicates within same phase
                const phases = capexTree.children || capexTree.phases || [];
                phases.forEach(phase => {
                    const items = phase.items || phase.children || [];
                    for (let i = 0; i < items.length; i++) {
                        for (let j = i + 1; j < items.length; j++) {
                            const nameA = (items[i].name || items[i].title || '').toLowerCase();
                            const nameB = (items[j].name || items[j].title || '').toLowerCase();

                            // Skip if either is already flagged as undefined
                            if (!nameA || nameA === 'undefined' || !nameB || nameB === 'undefined') continue;

                            // Exact match or high similarity
                            if (nameA === nameB || similarity(nameA, nameB) >= 0.8) {
                                // Check if we already flagged this pair
                                const alreadyFlagged = issues.some(iss =>
                                    iss.type === 'duplicate' &&
                                    ((iss.node.id === items[i].id && iss.duplicate.id === items[j].id) ||
                                     (iss.node.id === items[j].id && iss.duplicate.id === items[i].id))
                                );
                                if (!alreadyFlagged) {
                                    issues.push({
                                        type: 'duplicate',
                                        node: items[i],
                                        duplicate: items[j],
                                        phase: phase,
                                        similarity: nameA === nameB ? 1.0 : similarity(nameA, nameB)
                                    });
                                }
                            }
                        }
                    }
                });

                // Store issues for interactive repair
                window.repairQueue = issues;
                window.repairIndex = 0;

                if (issues.length === 0) {
                    return 'âœ… **Tree health check complete!** No issues found. Your tree is clean.';
                }

                // Count by type
                const undefinedCount = issues.filter(i => i.type === 'undefined').length;
                const duplicateCount = issues.filter(i => i.type === 'duplicate').length;
                const malformedCount = issues.filter(i => i.type === 'missing_id').length;

                let summary = `ðŸ”§ **Found ${issues.length} issue${issues.length > 1 ? 's' : ''}:**\n`;
                if (undefinedCount > 0) summary += `â€¢ ${undefinedCount} undefined/empty name${undefinedCount > 1 ? 's' : ''}\n`;
                if (duplicateCount > 0) summary += `â€¢ ${duplicateCount} duplicate pair${duplicateCount > 1 ? 's' : ''}\n`;
                if (malformedCount > 0) summary += `â€¢ ${malformedCount} missing ID${malformedCount > 1 ? 's' : ''}\n`;

                summary += '\nLet\'s fix them one at a time.';

                // Show first issue
                setTimeout(() => {
                    if (window.repairQueue && window.repairQueue.length > 0) {
                        showRepairIssue(0);
                    }
                }, 500);

                return summary;
            },

            // Repair action: Rename a node
            'repair_rename': (newName) => {
                if (!window.repairQueue || window.repairIndex >= window.repairQueue.length) {
                    return 'âš ï¸ No active repair session. Use "repair tree" to start.';
                }

                const issue = window.repairQueue[window.repairIndex];
                if (!newName || newName.trim() === '') {
                    return 'âš ï¸ Please provide a name.';
                }

                issue.node.name = newName.trim();
                if (typeof saveState === 'function') saveState('Repair: Renamed node');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                const result = `âœ… Renamed to "${newName}"`;

                // Move to next issue
                window.repairIndex++;
                setTimeout(() => showRepairIssue(window.repairIndex), 300);

                return result;
            },

            // Repair action: Delete node and promote children
            'repair_delete_promote': () => {
                if (!window.repairQueue || window.repairIndex >= window.repairQueue.length) {
                    return 'âš ï¸ No active repair session. Use "repair tree" to start.';
                }

                const issue = window.repairQueue[window.repairIndex];
                const node = issue.node;
                const parent = issue.parent;

                if (!parent) {
                    return 'âŒ Cannot delete root node.';
                }

                const nodeChildren = node.children || node.items || node.subItems || [];

                // Find which array the node is in
                const arrays = ['children', 'items', 'subItems'];
                for (const arr of arrays) {
                    if (parent[arr]) {
                        const idx = parent[arr].findIndex(c => c.id === node.id);
                        if (idx >= 0) {
                            // Remove the bad node
                            parent[arr].splice(idx, 1);
                            // Insert its children at the same position
                            parent[arr].splice(idx, 0, ...nodeChildren);
                            break;
                        }
                    }
                }

                if (typeof saveState === 'function') saveState('Repair: Deleted & promoted children');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                const result = `ðŸ—‘ï¸ Deleted bad node, promoted ${nodeChildren.length} child${nodeChildren.length !== 1 ? 'ren' : ''}`;

                // Move to next issue
                window.repairIndex++;
                setTimeout(() => showRepairIssue(window.repairIndex), 300);

                return result;
            },

            // Repair action: Merge duplicates
            'repair_merge': () => {
                if (!window.repairQueue || window.repairIndex >= window.repairQueue.length) {
                    return 'âš ï¸ No active repair session. Use "repair tree" to start.';
                }

                const issue = window.repairQueue[window.repairIndex];
                if (issue.type !== 'duplicate') {
                    return 'âš ï¸ Current issue is not a duplicate.';
                }

                const keep = issue.node;
                const remove = issue.duplicate;
                const phase = issue.phase;

                // Merge children from duplicate into keeper
                const removeChildren = remove.children || remove.items || remove.subItems || [];
                if (removeChildren.length > 0) {
                    if (!keep.subItems) keep.subItems = [];
                    keep.subItems.push(...removeChildren);
                }

                // Merge description if duplicate has one and keeper doesn't
                if (remove.description && !keep.description) {
                    keep.description = remove.description;
                } else if (remove.description && keep.description) {
                    keep.description += '\n\n' + remove.description;
                }

                // Remove the duplicate from phase
                const phaseItems = phase.items || phase.children || [];
                const idx = phaseItems.findIndex(c => c.id === remove.id);
                if (idx >= 0) {
                    phaseItems.splice(idx, 1);
                }

                if (typeof saveState === 'function') saveState('Repair: Merged duplicates');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                const result = `ðŸ”— Merged "${remove.name}" into "${keep.name}"`;

                // Move to next issue
                window.repairIndex++;
                setTimeout(() => showRepairIssue(window.repairIndex), 300);

                return result;
            },

            // Repair action: Skip current issue
            'repair_skip': () => {
                if (!window.repairQueue || window.repairIndex >= window.repairQueue.length) {
                    return 'âš ï¸ No active repair session.';
                }

                window.repairIndex++;
                setTimeout(() => showRepairIssue(window.repairIndex), 100);

                return 'â­ï¸ Skipped';
            },

            // BUILD 385: Aliases for common repair commands
            'repair': function() { return COMMAND_REGISTRY['repair_tree'](); },
            'fix_tree': function() { return COMMAND_REGISTRY['repair_tree'](); },
            'health_check': function() { return COMMAND_REGISTRY['repair_tree'](); },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 255: PROMPT PLAYGROUND MODE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Improve a prompt using AI
            'improve_prompt': async (promptText) => {
                if (!promptText || promptText.trim().length < 5) {
                    return 'âš ï¸ Please provide a prompt to improve. Example: "improve prompt: write a haiku about cats"';
                }

                // Store the prompt for playground
                chatState.pendingPromptToImprove = promptText;

                // Show improving message
                addMessage('ðŸ§  Improving your prompt...', 'system');

                try {
                    // Use the existing improvePromptWithAI function
                    const result = await improvePromptWithAI(promptText, 'quick');

                    if (result && result.phases && result.phases[0] && result.phases[0].items && result.phases[0].items[0]) {
                        const improved = result.phases[0].items[0];
                        const systemPrompt = improved.systemPrompt || '';
                        const userPrompt = improved.userPromptTemplate || '';
                        const examples = improved.fewShotExamples || '';

                        // Combine into full prompt
                        const fullPrompt = [systemPrompt, userPrompt, examples].filter(Boolean).join('\n\n');

                        // Store for playground
                        chatState.improvedPrompt = {
                            system: systemPrompt,
                            user: userPrompt,
                            examples: examples,
                            full: fullPrompt,
                            name: improved.name || 'Improved Prompt',
                            model: improved.modelTarget || 'Claude Sonnet 4'
                        };

                        return null; // We'll add the message with buttons separately
                    } else {
                        return 'âŒ Could not improve prompt. Please try again.';
                    }
                } catch (error) {
                    console.error('Prompt improvement error:', error);
                    return `âŒ Error improving prompt: ${error.message}`;
                }
            },

            // Enter playground mode with a prompt
            'enter_playground': (model) => {
                if (!chatState.improvedPrompt) {
                    return 'âš ï¸ No prompt loaded. Use "improve prompt: [your prompt]" first.';
                }

                chatState.playgroundMode = true;
                chatState.playgroundSystemPrompt = chatState.improvedPrompt.system || chatState.improvedPrompt.full;
                chatState.playgroundModel = model || 'claude-sonnet';
                chatState.playgroundHistory = [];

                // Update UI to show playground mode
                updatePlaygroundUI(true);

                return `ðŸŽ® **Playground Mode Active**\n\nModel: ${getModelDisplayName(chatState.playgroundModel)}\nSystem prompt loaded. Send a test message to try it out!\n\nType "exit playground" to return to TreeBeard.`;
            },

            // Exit playground mode
            'exit_playground': () => {
                chatState.playgroundMode = false;
                chatState.playgroundSystemPrompt = '';
                chatState.playgroundHistory = [];

                // Update UI to show normal mode
                updatePlaygroundUI(false);

                return 'ðŸŒ³ Back to TreeBeard! How can I help you?';
            },

            // Copy improved prompt to clipboard
            'copy_prompt': async () => {
                if (!chatState.improvedPrompt) {
                    return 'âš ï¸ No prompt to copy. Use "improve prompt: [your prompt]" first.';
                }

                try {
                    await navigator.clipboard.writeText(chatState.improvedPrompt.full);
                    return 'ðŸ“‹ Prompt copied to clipboard!';
                } catch (e) {
                    return 'âŒ Could not copy to clipboard. Try selecting the text manually.';
                }
            },

            // Save prompt as file
            'save_prompt': () => {
                if (!chatState.improvedPrompt) {
                    return 'âš ï¸ No prompt to save. Use "improve prompt: [your prompt]" first.';
                }

                const blob = new Blob([chatState.improvedPrompt.full], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${chatState.improvedPrompt.name.replace(/[^a-z0-9]/gi, '-').toLowerCase()}.txt`;
                a.click();
                URL.revokeObjectURL(url);

                return 'ðŸ’¾ Prompt saved as text file!';
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 308/309: FIND REDUNDANCIES - with actionable merge buttons
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            'find_redundancies': async () => {
                // Collect all nodes with their names/descriptions
                const allNodes = [];
                function collectNodes(node, path = []) {
                    const currentPath = [...path, node.name || node.title || 'Unnamed'];
                    allNodes.push({
                        id: node.id,
                        name: node.name || node.title || '',
                        description: node.description || '',
                        path: currentPath.join(' â†’ ')
                    });
                    (node.children || node.items || node.subItems || []).forEach(child => {
                        collectNodes(child, currentPath);
                    });
                }
                collectNodes(capexTree);

                if (allNodes.length < 3) {
                    return 'âš ï¸ Your tree has very few nodes. Add more content first!';
                }

                // Group by similar names using fuzzy matching
                const groups = [];
                const used = new Set();

                for (let i = 0; i < allNodes.length; i++) {
                    if (used.has(i)) continue;
                    const node = allNodes[i];
                    const similar = [node];
                    const words1 = node.name.toLowerCase().split(/\s+/).filter(w => w.length > 3);

                    for (let j = i + 1; j < allNodes.length; j++) {
                        if (used.has(j)) continue;
                        const other = allNodes[j];
                        const words2 = other.name.toLowerCase().split(/\s+/).filter(w => w.length > 3);

                        // Check for word overlap (3+ chars)
                        const overlap = words1.filter(w => words2.includes(w) || other.name.toLowerCase().includes(w));
                        const overlapRatio = words1.length > 0 ? overlap.length / Math.max(words1.length, words2.length) : 0;

                        // Also check for substring match
                        const nameA = node.name.toLowerCase().replace(/[^a-z]/g, '');
                        const nameB = other.name.toLowerCase().replace(/[^a-z]/g, '');
                        const isSubstring = nameA.length > 5 && nameB.length > 5 &&
                            (nameA.includes(nameB) || nameB.includes(nameA));

                        if (overlapRatio >= 0.5 || isSubstring) {
                            similar.push(other);
                            used.add(j);
                        }
                    }

                    if (similar.length > 1) {
                        groups.push(similar);
                        used.add(i);
                    }
                }

                if (groups.length === 0) {
                    return 'âœ… No obvious redundancies found! Your tree looks well-organized.\n\nFor deeper analysis, try AI Review (ðŸ”) which can detect conceptual overlaps.';
                }

                // Store for navigation
                window.chatRedundancyGroups = groups;
                window.chatCurrentGroupIndex = 0;

                // Format first group
                const group = groups[0];
                let result = `ðŸ” **Found ${groups.length} redundancy group(s)**\n\n`;
                result += `**Group 1 of ${groups.length}:** "${group[0].name}"\n\n`;
                group.forEach((node, i) => {
                    result += `${i + 1}. **${node.name}**\n   _${node.path}_\n\n`;
                });
                result += `\nðŸ’¡ Review these nodes and keep the most detailed one.`;

                return {
                    message: result,
                    buttons: [
                        { label: 'ðŸ‘ï¸ View Group 1', action: 'view_redundancy_group:0' },
                        { label: 'âž¡ï¸ Next Group', action: 'next_redundancy_group' },
                        { label: 'ðŸ”€ Auto-Merge All', action: 'auto_merge_redundancies' }
                    ]
                };
            },

            // View a specific redundancy group
            'view_redundancy_group': (indexStr) => {
                const groups = window.chatRedundancyGroups;
                if (!groups || groups.length === 0) {
                    return 'âš ï¸ No redundancy groups found. Run "find redundancies" first.';
                }

                const index = parseInt(indexStr) || 0;
                if (index < 0 || index >= groups.length) {
                    return `âŒ Invalid group index. Valid range: 0-${groups.length - 1}`;
                }

                window.chatCurrentGroupIndex = index;
                const group = groups[index];

                // Select all nodes in this group in the canvas
                window.selectedCanvasNodes = group.map(n => {
                    // Find actual node object by ID
                    function findNode(tree, id) {
                        if (tree.id === id) return tree;
                        for (const child of (tree.children || tree.items || tree.subItems || [])) {
                            const found = findNode(child, id);
                            if (found) return found;
                        }
                        return null;
                    }
                    return findNode(capexTree, n.id);
                }).filter(Boolean);

                let result = `ðŸ“‹ **Group ${index + 1} of ${groups.length}:** "${group[0].name}"\n\n`;
                group.forEach((node, i) => {
                    const descPreview = node.description ? node.description.substring(0, 80) + '...' : '(no description)';
                    result += `${i + 1}. **${node.name}**\n   ${descPreview}\n   _${node.path}_\n\n`;
                });

                result += `\nâœ… ${group.length} nodes selected in canvas. Review and delete duplicates.`;

                const buttons = [
                    { label: `ðŸ” Find "${group[0].name}"`, action: `find_node:${group[0].name}` }
                ];
                if (index > 0) buttons.push({ label: 'â¬…ï¸ Prev', action: `view_redundancy_group:${index - 1}` });
                if (index < groups.length - 1) buttons.push({ label: 'âž¡ï¸ Next', action: `view_redundancy_group:${index + 1}` });
                buttons.push({ label: 'ðŸ—‘ï¸ Delete Others', action: `merge_keep_first:${index}` });

                return { message: result, buttons };
            },

            // Navigate to next redundancy group
            'next_redundancy_group': () => {
                const groups = window.chatRedundancyGroups;
                if (!groups || groups.length === 0) {
                    return 'âš ï¸ No redundancy groups. Run "find redundancies" first.';
                }

                const current = window.chatCurrentGroupIndex || 0;
                const next = (current + 1) % groups.length;
                return COMMAND_REGISTRY['view_redundancy_group'](next.toString());
            },

            // Merge: keep first node, delete others in group
            'merge_keep_first': (indexStr) => {
                const groups = window.chatRedundancyGroups;
                if (!groups || groups.length === 0) {
                    return 'âš ï¸ No redundancy groups. Run "find redundancies" first.';
                }

                const index = parseInt(indexStr) || 0;
                const group = groups[index];
                if (!group || group.length < 2) {
                    return 'âŒ Invalid group.';
                }

                // Keep first, delete the rest
                const keeper = group[0];
                const toDelete = group.slice(1);
                let deletedCount = 0;

                // Save state before deletion
                if (typeof saveState === 'function') {
                    saveState('Merge redundancies - keep ' + keeper.name);
                }

                toDelete.forEach(nodeInfo => {
                    // Find and delete node
                    function deleteFromTree(parent, targetId) {
                        const childArrays = ['children', 'items', 'subItems'];
                        for (const prop of childArrays) {
                            if (parent[prop]) {
                                const idx = parent[prop].findIndex(c => c.id === targetId);
                                if (idx !== -1) {
                                    parent[prop].splice(idx, 1);
                                    deletedCount++;
                                    return true;
                                }
                                for (const child of parent[prop]) {
                                    if (deleteFromTree(child, targetId)) return true;
                                }
                            }
                        }
                        return false;
                    }
                    deleteFromTree(capexTree, nodeInfo.id);
                });

                // Re-render
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                // Remove this group from the list
                groups.splice(index, 1);
                window.chatRedundancyGroups = groups;

                const result = `âœ… Merged! Kept "${keeper.name}", deleted ${deletedCount} duplicate(s).\n\n${groups.length} groups remaining.`;

                if (groups.length > 0) {
                    return {
                        message: result,
                        buttons: [
                            { label: 'âž¡ï¸ Next Group', action: 'view_redundancy_group:0' },
                            { label: 'ðŸ”€ Auto-Merge All', action: 'auto_merge_redundancies' }
                        ]
                    };
                }
                return result + '\n\nðŸŽ‰ All redundancies resolved!';
            },

            // Auto-merge all redundancy groups (keeps first in each)
            'auto_merge_redundancies': () => {
                const groups = window.chatRedundancyGroups;
                if (!groups || groups.length === 0) {
                    return 'âš ï¸ No redundancy groups. Run "find redundancies" first.';
                }

                if (typeof saveState === 'function') {
                    saveState('Auto-merge all redundancies');
                }

                let totalDeleted = 0;
                const kept = [];

                groups.forEach(group => {
                    kept.push(group[0].name);
                    group.slice(1).forEach(nodeInfo => {
                        function deleteFromTree(parent, targetId) {
                            const childArrays = ['children', 'items', 'subItems'];
                            for (const prop of childArrays) {
                                if (parent[prop]) {
                                    const idx = parent[prop].findIndex(c => c.id === targetId);
                                    if (idx !== -1) {
                                        parent[prop].splice(idx, 1);
                                        totalDeleted++;
                                        return true;
                                    }
                                    for (const child of parent[prop]) {
                                        if (deleteFromTree(child, targetId)) return true;
                                    }
                                }
                            }
                            return false;
                        }
                        deleteFromTree(capexTree, nodeInfo.id);
                    });
                });

                // Re-render
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                window.chatRedundancyGroups = [];

                return `ðŸŽ‰ **Auto-merge complete!**\n\nDeleted ${totalDeleted} duplicate nodes across ${groups.length} groups.\n\nKept: ${kept.slice(0, 5).join(', ')}${kept.length > 5 ? ` ...and ${kept.length - 5} more` : ''}\n\nðŸ’¡ Use Undo if you need to revert.`;
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 392: LIFETREE HEALTH CHECK - Proactive diagnostics
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            'lifetree_health_check': () => {
                const phases = capexTree?.children || [];
                const pattern = capexTree?.pattern?.key || 'generic';

                // Only meaningful for lifetree pattern
                if (pattern !== 'lifetree') {
                    return 'âš ï¸ Health check is optimized for LifeTree pattern. Current pattern: ' + pattern;
                }

                const issues = {
                    emptyPhases: [],
                    redundantPeriods: [],
                    dataIntegrity: [],
                    sparseItems: [],
                    chronologyIssues: []
                };

                // 1. Empty phases detection
                phases.forEach(phase => {
                    const itemCount = (phase.items || phase.children || []).length;
                    if (itemCount === 0) {
                        issues.emptyPhases.push({ phase, name: phase.name });
                    }
                });

                // 2. Redundant periods (overlapping decades/time ranges)
                const periodPatterns = [];
                phases.forEach(phase => {
                    const name = (phase.name || '').toLowerCase();
                    // Extract years from phase names
                    const yearMatches = name.match(/\d{4}/g);
                    const periodKeywords = ['legacy', 'rehabilitation', 'aftermath', 'canonization', 'memory', 'heritage'];
                    const hasLegacyKeyword = periodKeywords.some(kw => name.includes(kw));

                    if (yearMatches || hasLegacyKeyword) {
                        periodPatterns.push({
                            phase,
                            years: yearMatches || [],
                            isLegacy: hasLegacyKeyword,
                            name: phase.name
                        });
                    }
                });

                // Find overlapping legacy sections
                const legacyPhases = periodPatterns.filter(p => p.isLegacy);
                if (legacyPhases.length > 1) {
                    issues.redundantPeriods.push({
                        type: 'legacy_overlap',
                        phases: legacyPhases.map(p => p.name),
                        suggestion: 'Consolidate into single "Afterlife & Legacy" section'
                    });
                }

                // 3. Data integrity - count claimed vs actual events
                let totalEvents = 0;
                let phasesWithZeroDisplay = 0;
                phases.forEach(phase => {
                    const items = phase.items || phase.children || [];
                    totalEvents += items.length;
                    items.forEach(item => {
                        totalEvents += (item.subItems || item.children || []).length;
                    });
                });

                // 4. Sparse items (events without subtasks that should have detail)
                const significantEvents = ['battle', 'siege', 'trial', 'execution', 'coronation', 'campaign'];
                phases.forEach(phase => {
                    (phase.items || phase.children || []).forEach(item => {
                        const nameLower = (item.name || '').toLowerCase();
                        const hasSubitems = (item.subItems || item.children || []).length > 0;
                        if (!hasSubitems && significantEvents.some(evt => nameLower.includes(evt))) {
                            issues.sparseItems.push({ item, phaseName: phase.name });
                        }
                    });
                });

                // 5. Chronology issues - check for out-of-order phases
                const yearsInOrder = [];
                phases.forEach(phase => {
                    const match = (phase.name || '').match(/\d{4}/);
                    if (match) yearsInOrder.push({ year: parseInt(match[0]), name: phase.name });
                });
                for (let i = 1; i < yearsInOrder.length; i++) {
                    if (yearsInOrder[i].year < yearsInOrder[i-1].year) {
                        issues.chronologyIssues.push({
                            before: yearsInOrder[i-1].name,
                            after: yearsInOrder[i].name
                        });
                    }
                }

                // Store for cleanup actions
                window.lifetreeHealthIssues = issues;

                // Build report
                const totalIssues = issues.emptyPhases.length + issues.redundantPeriods.length +
                    issues.sparseItems.length + issues.chronologyIssues.length;

                if (totalIssues === 0) {
                    return 'âœ… **LifeTree Health: Excellent!**\n\n' +
                        `ðŸ“Š ${phases.length} phases, ${totalEvents} total events\n\n` +
                        'No structural issues detected. Your tree is well-organized!';
                }

                let report = `ðŸ©º **LifeTree Health Check**\n\n`;
                report += `ðŸ“Š ${phases.length} phases â€¢ ${totalEvents} events\n\n`;

                const priorities = [];

                // Priority 1: Redundant periods (most impactful)
                if (issues.redundantPeriods.length > 0) {
                    const rp = issues.redundantPeriods[0];
                    report += `ðŸ”´ **Pri 1: Redundant Sections** (${rp.phases.length} overlapping)\n`;
                    report += `   ${rp.phases.slice(0, 3).join(', ')}${rp.phases.length > 3 ? '...' : ''}\n`;
                    report += `   ðŸ’¡ ${rp.suggestion}\n\n`;
                    priorities.push({ label: 'ðŸ§¹ Pri 1: Consolidate Legacy', action: 'lifetree_consolidate_legacy' });
                }

                // Priority 2: Chronology issues
                if (issues.chronologyIssues.length > 0) {
                    report += `ðŸŸ  **Pri 2: Out of Order** (${issues.chronologyIssues.length} issues)\n`;
                    issues.chronologyIssues.slice(0, 2).forEach(ci => {
                        report += `   "${ci.after}" appears after "${ci.before}"\n`;
                    });
                    report += '\n';
                    priorities.push({ label: 'ðŸ”„ Pri 2: Fix Order', action: 'lifetree_fix_chronology' });
                }

                // Priority 3: Empty phases
                if (issues.emptyPhases.length > 0) {
                    report += `ðŸŸ¡ **Pri 3: Empty Sections** (${issues.emptyPhases.length})\n`;
                    issues.emptyPhases.slice(0, 3).forEach(ep => {
                        report += `   "${ep.name}" has 0 events\n`;
                    });
                    report += '\n';
                    priorities.push({ label: 'âž• Pri 3: Fill Empty', action: 'lifetree_fill_empty' });
                }

                // Priority 4: Sparse items
                if (issues.sparseItems.length > 0) {
                    report += `ðŸ”µ **Pri 4: Sparse Events** (${issues.sparseItems.length} need detail)\n`;
                    issues.sparseItems.slice(0, 3).forEach(si => {
                        report += `   "${si.item.name}" lacks subtasks\n`;
                    });
                    report += '\n';
                    priorities.push({ label: 'ðŸ“ Pri 4: Add Detail', action: 'lifetree_enrich_sparse' });
                }

                report += `\nWhich fix should I execute first?`;

                // Add "Execute All" if multiple priorities
                if (priorities.length > 1) {
                    priorities.push({ label: 'âš¡ Execute All', action: 'lifetree_execute_all_fixes' });
                }

                return { message: report, buttons: priorities };
            },

            // Consolidate legacy sections into one
            'lifetree_consolidate_legacy': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues || !issues.redundantPeriods.length) {
                    return 'âš ï¸ No redundant sections found. Run health check first.';
                }

                const rp = issues.redundantPeriods[0];
                const legacyPhaseNames = rp.phases;

                // Find all legacy phases and their items
                const allLegacyItems = [];
                const phasesToRemove = [];

                capexTree.children.forEach((phase, idx) => {
                    if (legacyPhaseNames.includes(phase.name)) {
                        (phase.items || phase.children || []).forEach(item => {
                            allLegacyItems.push({ ...item, sourcePhase: phase.name });
                        });
                        phasesToRemove.push(idx);
                    }
                });

                if (phasesToRemove.length < 2) {
                    return 'âš ï¸ Not enough legacy phases to consolidate.';
                }

                // Save state before changes
                if (typeof saveState === 'function') {
                    saveState('Consolidate legacy sections');
                }

                // Remove old phases (in reverse order to preserve indices)
                phasesToRemove.sort((a, b) => b - a).forEach(idx => {
                    capexTree.children.splice(idx, 1);
                });

                // Create consolidated phase
                const consolidatedPhase = {
                    id: 'phase-legacy-' + Date.now(),
                    name: 'Afterlife & Legacy',
                    type: 'phase',
                    icon: 'ðŸ›ï¸',
                    expanded: true,
                    description: 'Consolidated legacy, rehabilitation, and canonization events',
                    items: allLegacyItems.map(item => ({
                        ...item,
                        id: item.id || 'item-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5)
                    }))
                };

                // Add to end
                capexTree.children.push(consolidatedPhase);

                // Re-render
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return {
                    message: `âœ… **Consolidated ${phasesToRemove.length} legacy sections!**\n\n` +
                        `Created "Afterlife & Legacy" with ${allLegacyItems.length} events.\n\n` +
                        `ðŸ’¡ Use Undo to revert if needed.`,
                    buttons: [
                        { label: 'âœ… Continue to Pri 2', action: 'lifetree_health_check' },
                        { label: 'â†©ï¸ Undo', action: 'undo' }
                    ]
                };
            },

            // Fix chronological order
            'lifetree_fix_chronology': () => {
                const phases = capexTree?.children || [];

                // Extract year from each phase for sorting
                const phasesWithYears = phases.map((phase, originalIndex) => {
                    const match = (phase.name || '').match(/\d{4}/);
                    return {
                        phase,
                        year: match ? parseInt(match[0]) : 9999, // Put no-year phases at end
                        originalIndex
                    };
                });

                // Check if already sorted
                let needsSort = false;
                for (let i = 1; i < phasesWithYears.length; i++) {
                    if (phasesWithYears[i].year < phasesWithYears[i-1].year) {
                        needsSort = true;
                        break;
                    }
                }

                if (!needsSort) {
                    return 'âœ… Phases are already in chronological order!';
                }

                // Save state
                if (typeof saveState === 'function') {
                    saveState('Fix chronological order');
                }

                // Sort by year
                phasesWithYears.sort((a, b) => a.year - b.year);
                capexTree.children = phasesWithYears.map(p => p.phase);

                // Re-render
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return {
                    message: `âœ… **Phases reordered chronologically!**\n\n` +
                        `${phases.length} phases sorted from earliest to latest.\n\n` +
                        `ðŸ’¡ Use Undo to revert if needed.`,
                    buttons: [
                        { label: 'âœ… Continue Health Check', action: 'lifetree_health_check' },
                        { label: 'â†©ï¸ Undo', action: 'undo' }
                    ]
                };
            },

            // Navigate to first empty phase for filling
            'lifetree_fill_empty': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues || !issues.emptyPhases.length) {
                    return 'âœ… No empty phases found!';
                }

                const emptyPhase = issues.emptyPhases[0];

                // Navigate to the empty phase
                if (typeof window.chatFocusedNode !== 'undefined') {
                    window.chatFocusedNode = emptyPhase.phase;
                }

                return {
                    message: `ðŸ“ **Focused on: "${emptyPhase.name}"**\n\n` +
                        `This section is empty. What would you like to add?\n\n` +
                        `ðŸ’¡ Describe an event or memory for this period.`,
                    buttons: [
                        { label: 'ðŸ—‘ï¸ Delete Empty Phase', action: `delete_phase:${emptyPhase.phase.id}` },
                        { label: 'â­ï¸ Skip to Next', action: 'lifetree_fill_empty_next' },
                        { label: 'â†©ï¸ Back to Health Check', action: 'lifetree_health_check' }
                    ]
                };
            },

            // Skip to next empty phase
            'lifetree_fill_empty_next': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues || issues.emptyPhases.length <= 1) {
                    return 'âœ… No more empty phases!';
                }
                issues.emptyPhases.shift(); // Remove first
                return COMMAND_REGISTRY['lifetree_fill_empty']();
            },

            // Enrich sparse items with AI suggestions
            'lifetree_enrich_sparse': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues || !issues.sparseItems.length) {
                    return 'âœ… No sparse items found!';
                }

                const sparse = issues.sparseItems[0];

                return {
                    message: `ðŸ“ **Sparse Event: "${sparse.item.name}"**\n` +
                        `In: ${sparse.phaseName}\n\n` +
                        `This significant event has no subtasks. Would you like me to:\n\n` +
                        `â€¢ Add detailed subtasks (who, what, when, where)\n` +
                        `â€¢ Research historical context\n` +
                        `â€¢ Generate scholarly analysis`,
                    buttons: [
                        { label: 'âœ¨ AI Deep Dive', action: `deep_dive:${sparse.item.id}` },
                        { label: 'â­ï¸ Skip', action: 'lifetree_enrich_next' },
                        { label: 'â†©ï¸ Back', action: 'lifetree_health_check' }
                    ]
                };
            },

            // Skip to next sparse item
            'lifetree_enrich_next': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues || issues.sparseItems.length <= 1) {
                    return 'âœ… No more sparse items!';
                }
                issues.sparseItems.shift();
                return COMMAND_REGISTRY['lifetree_enrich_sparse']();
            },

            // Execute all fixes in sequence
            'lifetree_execute_all_fixes': () => {
                const issues = window.lifetreeHealthIssues;
                if (!issues) {
                    return 'âš ï¸ Run health check first.';
                }

                let executed = [];

                // Execute in priority order
                if (issues.redundantPeriods.length > 0) {
                    const result = COMMAND_REGISTRY['lifetree_consolidate_legacy']();
                    executed.push('Consolidated legacy sections');
                }

                // Re-run health check after fixes
                return {
                    message: `âš¡ **Executing Priority Fixes...**\n\n` +
                        (executed.length > 0 ? `âœ… ${executed.join('\nâœ… ')}\n\n` : '') +
                        `Checking for remaining issues...`,
                    buttons: [
                        { label: 'ðŸ©º Run Health Check Again', action: 'lifetree_health_check' }
                    ]
                };
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 361: HYPEREDGE QUERY COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Create hyperedge from stored query results
            'create_hyperedge_from_query': (conditionsJson) => {
                const matches = chatState.lastQueryMatches;
                const description = chatState.lastQueryDescription;

                if (!matches || matches.length < 2) {
                    return 'âš ï¸ No valid query results. Try asking again!';
                }

                if (typeof saveState === 'function') {
                    saveState('Create Hyperedge from Query');
                }

                const label = description || 'Query Result';
                const color = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');

                const hyperedge = addHyperedge(
                    'query',
                    label,
                    matches.map(m => m.id),
                    { color, description: `Query: ${description}`, source: 'treebeard' }
                );

                if (hyperedge) {
                    hyperedge.color = color;
                }

                if (typeof renderCanvas === 'function') renderCanvas();

                return `âœ… Created hyperedge **"${label}"** with ${matches.length} nodes!\n\nðŸŽ¯ Switch to Canvas view to see it visualized.`;
            },

            // Highlight query results in canvas
            'highlight_query_results': () => {
                const matches = chatState.lastQueryMatches;

                if (!matches || matches.length === 0) {
                    return 'âš ï¸ No query results to highlight.';
                }

                // Select nodes in canvas
                if (typeof window.selectedCanvasNodes !== 'undefined') {
                    window.selectedCanvasNodes = matches;
                }

                // Highlight visually
                matches.forEach(node => {
                    const nodeEl = document.querySelector(`.canvas-node[data-id="${node.id}"]`);
                    if (nodeEl) {
                        nodeEl.classList.add('selected');
                        nodeEl.style.boxShadow = '0 0 20px rgba(99, 102, 241, 0.6)';
                    }
                });

                // Switch to canvas view if not already there
                const container = document.getElementById('canvas-container');
                if (container && !container.classList.contains('active')) {
                    document.getElementById('toggle-view-mode')?.click();
                }

                return `ðŸŽ¯ Highlighted ${matches.length} matching nodes in Canvas view!`;
            },

            // Open query builder modal
            'open_query_builder': () => {
                if (typeof showQueryBuilderModal === 'function') {
                    showQueryBuilderModal();
                    return 'ðŸ” Query Builder opened!';
                }
                return 'âŒ Query Builder not available.';
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 381: LIFETREE CONTEXTUAL RESEARCH
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Research a topic for contextual enrichment (historical photos, context)
            'research': async (topic) => {
                if (!topic) {
                    return 'âš ï¸ Please specify what to research. Example: "research Grey Nuns Hospital 1960s"';
                }

                // Get focused node for context
                const node = window.chatFocusedNode;
                const nodeName = node ? (node.name || node.title || 'the current event') : 'this event';
                const nodeDate = node?.eventDate || '';
                const nodeLocation = node?.location || '';

                // Build context-aware search query
                let searchContext = topic;
                if (nodeDate && !topic.toLowerCase().includes(nodeDate.toLowerCase())) {
                    searchContext += ` ${nodeDate}`;
                }
                if (nodeLocation && !topic.toLowerCase().includes(nodeLocation.toLowerCase())) {
                    searchContext += ` ${nodeLocation}`;
                }

                // Show research in progress
                addMessage(`ðŸ” Researching: **${topic}**\n\nSearching for historical context, photos, and information...`, 'system');

                try {
                    // Use Claude to generate research summary
                    const response = await fetch('/.netlify/functions/claude-proxy', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 1000,
                            messages: [{
                                role: 'user',
                                content: `You are a historical researcher helping build a family biography.

Research topic: "${topic}"
${nodeDate ? `Time period: ${nodeDate}` : ''}
${nodeLocation ? `Location: ${nodeLocation}` : ''}

Provide a brief, engaging research summary with:
1. **Historical Context** (2-3 sentences about what was happening in that place/time)
2. **Notable Facts** (2-3 interesting details about the institution/place)
3. **Cultural Snapshot** (what life was like - music, events, culture of the era)
4. **Photo Suggestions** (describe 2-3 types of historical photos that would enrich this story - be specific about what to look for)

Format in markdown. Be warm and conversational, like helping someone discover their family history.
If this is a hospital, mention when it was founded and any historical significance.
If this is a school, mention notable alumni or historical changes.
If this is a city/neighborhood, mention the community character of that era.`
                            }]
                        })
                    });

                    const data = await response.json();
                    const research = data.content?.[0]?.text || data.choices?.[0]?.message?.content;

                    if (research) {
                        // Store research for potential attachment
                        window.lastResearchResult = {
                            topic,
                            content: research,
                            timestamp: new Date().toISOString(),
                            nodeId: node?.id
                        };

                        // Increment TreeBeard score for research (+1)
                        if (typeof chatState !== 'undefined') {
                            chatState.treeBeardScore = (chatState.treeBeardScore || 0) + 1;
                        }

                        return {
                            message: `ðŸ“š **Research: ${topic}**\n\n${research}\n\n---\nâœ¨ *+1 TreeBeard for enriching ${nodeName}!*`,
                            buttons: [
                                { label: 'ðŸ“Ž Attach to Node', action: `attach_research:${node?.id || ''}` },
                                { label: 'ðŸ” Search for Photos', action: `search_photos:${encodeURIComponent(topic)}` },
                                { label: 'âž• Add as Context', action: `add_context:${encodeURIComponent(research.substring(0, 500))}` }
                            ]
                        };
                    }
                    return 'âŒ Research failed - no response from AI.';
                } catch (err) {
                    console.error('Research error:', err);
                    return `âŒ Research failed: ${err.message}`;
                }
            },

            // Attach research to a node as historical context
            'attach_research': (nodeId) => {
                const research = window.lastResearchResult;
                if (!research) {
                    return 'âš ï¸ No research to attach. Run "research:{topic}" first.';
                }

                let node = null;
                if (nodeId) {
                    // Find by ID
                    function findNode(tree, id) {
                        if (tree.id === id) return tree;
                        for (const child of (tree.children || tree.items || tree.subItems || [])) {
                            const found = findNode(child, id);
                            if (found) return found;
                        }
                        return null;
                    }
                    node = findNode(capexTree, nodeId);
                }
                node = node || window.chatFocusedNode;

                if (!node) {
                    return 'âš ï¸ No node selected. Use "find [name]" first.';
                }

                // Add research as historical context field
                node.historicalContext = research.content;
                node.researchDate = research.timestamp;

                if (typeof saveState === 'function') saveState('Attached research');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                // +1 for attaching research
                if (typeof chatState !== 'undefined') {
                    chatState.treeBeardScore = (chatState.treeBeardScore || 0) + 1;
                }

                return `âœ… Research attached to "${node.name || node.title}"!\n\nâœ¨ *+1 TreeBeard for enriching this memory!*`;
            },

            // Search for historical photos (opens web search)
            'search_photos': (topic) => {
                if (!topic) {
                    return 'âš ï¸ Please specify what to search for.';
                }

                const decodedTopic = decodeURIComponent(topic);
                const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(decodedTopic + ' historical photos')}&tbm=isch`;

                // Open in new tab
                window.open(searchUrl, '_blank');

                return `ðŸ” Opened Google Images search for "${decodedTopic}" historical photos.\n\nðŸ’¡ Tip: When you find a good photo, right-click â†’ "Copy image address" â†’ then use the artifact panel to attach it to this node.`;
            },

            // Add research content as context field
            'add_context': (contextEncoded) => {
                const node = window.chatFocusedNode;
                if (!node) {
                    return 'âš ï¸ No node focused. Use "find [name]" first.';
                }

                const context = decodeURIComponent(contextEncoded);
                node.locationContext = context;

                if (typeof saveState === 'function') saveState('Added context');
                if (typeof render === 'function') render();
                if (typeof renderCanvas === 'function') renderCanvas();

                return `âœ… Context added to "${node.name || node.title}"!`;
            }
        };

        /**
         * BUILD 361: Detect hyperedge queries in natural language
         * Returns { matches, description, queryConditions } or null if not a query
         */
        function detectHyperedgeQuery(message) {
            const lowerMsg = message.toLowerCase();

            // Patterns for hyperedge queries
            const queryPatterns = [
                // Cost queries
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?items?\s+(?:over|above|>\s*)\s*\$?([\d,]+)k?/i, field: 'cost', operator: '>', multiplier: (m) => m.includes('k') || parseInt(m) < 1000 ? 1000 : 1 },
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?items?\s+(?:under|below|<\s*)\s*\$?([\d,]+)k?/i, field: 'cost', operator: '<', multiplier: (m) => m.includes('k') || parseInt(m) < 1000 ? 1000 : 1 },
                { pattern: /(?:expensive|high[\s-]?cost|big[\s-]?ticket)\s*items?/i, field: 'cost', operator: '>', value: 'percentile75' },

                // Status queries
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?(?:items?\s+)?(?:that\s+are\s+)?(?:in\s+progress|in-progress)/i, field: 'pmStatus', operator: 'equals', value: 'In Progress' },
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?(?:items?\s+)?(?:that\s+are\s+)?(?:done|completed|finished)/i, field: 'pmStatus', operator: 'equals', value: 'Done' },
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?(?:items?\s+)?(?:that\s+are\s+)?(?:to\s*do|pending|not\s+started)/i, field: 'pmStatus', operator: 'equals', value: 'To Do' },
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?blocked\s*items?/i, field: 'pmStatus', operator: 'equals', value: 'Blocked' },

                // Priority queries
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?(?:high[\s-]?priority|urgent|critical)\s*items?/i, field: 'pmPriority', operator: 'equals', value: 'High' },
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?low[\s-]?priority\s*items?/i, field: 'pmPriority', operator: 'equals', value: 'Low' },

                // Assignee queries
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?(?:items?\s+)?(?:assigned\s+to|owned\s+by|for)\s+(\w+)/i, field: 'pmAssignee', operator: 'contains', valueGroup: 1 },
                { pattern: /(\w+)'s\s+(?:items?|tasks?|work)/i, field: 'pmAssignee', operator: 'contains', valueGroup: 1 },

                // Description/name contains
                { pattern: /(?:show|find|get|list)\s+(?:me\s+)?(?:all\s+)?items?\s+(?:with|containing|about|mentioning)\s+["']?([^"']+)["']?/i, field: 'description', operator: 'contains', valueGroup: 1 }
            ];

            // Try each pattern
            for (const qp of queryPatterns) {
                const match = message.match(qp.pattern);
                if (match) {
                    // Determine value
                    let value = qp.value;
                    if (qp.valueGroup) {
                        value = match[qp.valueGroup];
                    } else if (match[1] && !qp.value) {
                        value = match[1].replace(/,/g, '');
                        if (qp.multiplier) {
                            value = parseInt(value) * qp.multiplier(match[0]);
                        }
                    }

                    // Handle percentile value
                    if (value === 'percentile75') {
                        const allItems = [];
                        function collect(node) {
                            if (node.cost > 0) allItems.push(node);
                            (node.items || []).forEach(collect);
                            (node.children || []).forEach(c => { collect(c); (c.items || []).forEach(collect); });
                        }
                        collect(capexTree);
                        if (allItems.length > 0) {
                            const costs = allItems.map(i => i.cost).sort((a, b) => b - a);
                            value = costs[Math.floor(costs.length * 0.25)] || costs[0] || 100000;
                        } else {
                            value = 100000;
                        }
                    }

                    const conditions = [{ field: qp.field, operator: qp.operator, value: String(value) }];
                    const description = describeQuery(conditions);

                    // Execute query
                    const matches = executeHyperedgeQuery(conditions);

                    return { matches, description, queryConditions: conditions };
                }
            }

            return null; // Not a query
        }

        /**
         * BUILD 361: Execute a hyperedge query
         */
        function executeHyperedgeQuery(conditions) {
            const allItems = [];
            function collectItems(node) {
                if (node.type === 'item' || node.type === 'subtask') {
                    allItems.push(node);
                }
                (node.items || []).forEach(collectItems);
                (node.children || []).forEach(child => {
                    collectItems(child);
                    (child.items || []).forEach(collectItems);
                });
            }
            collectItems(capexTree);

            return allItems.filter(item => {
                return conditions.every(cond => {
                    const itemValue = item[cond.field];
                    const condValue = cond.value;

                    switch (cond.operator) {
                        case 'equals':
                            return String(itemValue || '').toLowerCase() === String(condValue).toLowerCase();
                        case 'contains':
                            return String(itemValue || '').toLowerCase().includes(String(condValue).toLowerCase()) ||
                                   String(item.name || '').toLowerCase().includes(String(condValue).toLowerCase());
                        case '>':
                            return Number(itemValue || 0) > Number(condValue);
                        case '<':
                            return Number(itemValue || 0) < Number(condValue);
                        default:
                            return false;
                    }
                });
            });
        }

        /**
         * BUILD 361: Describe a query in human-readable form
         */
        function describeQuery(conditions) {
            return conditions.map(c => {
                const fieldNames = {
                    cost: 'cost',
                    pmStatus: 'status',
                    pmPriority: 'priority',
                    pmAssignee: 'assignee',
                    description: 'description',
                    name: 'name'
                };
                const opNames = { '>': 'over', '<': 'under', 'equals': '', 'contains': 'containing' };
                const field = fieldNames[c.field] || c.field;
                const op = opNames[c.operator] || c.operator;
                const val = c.field === 'cost' ? '$' + (Number(c.value) >= 1000000 ? (Number(c.value)/1000000).toFixed(1) + 'M' : (Number(c.value)/1000).toFixed(0) + 'K') : c.value;
                return `${field} ${op} ${val}`.replace(/\s+/g, ' ').trim();
            }).join(' AND ');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PLAYGROUND MODE HELPERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function getModelDisplayName(modelKey) {
            const names = {
                'claude-sonnet': 'ðŸŸ£ Claude Sonnet 4',
                'claude-opus': 'ðŸŸ£ Claude Opus 4',
                'claude-haiku': 'ðŸŸ£ Claude Haiku',
                'gpt-4o': 'ðŸŸ¢ GPT-4o',
                'gpt-4-turbo': 'ðŸŸ¢ GPT-4 Turbo',
                'gemini-pro': 'ðŸ”µ Gemini Pro',
                'gemini-flash': 'ðŸ”µ Gemini Flash'
            };
            return names[modelKey] || modelKey;
        }

        function updatePlaygroundUI(isPlayground) {
            const header = document.getElementById('chat-assistant-header');
            const title = header?.querySelector('h3');

            if (isPlayground) {
                if (title) {
                    title.innerHTML = `ðŸŽ® Prompt Playground <span style="font-size: 11px; opacity: 0.7; font-weight: normal;">(${getModelDisplayName(chatState.playgroundModel)})</span>`;
                }
                header?.style.setProperty('background', 'linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.15))');

                // Add model selector if not present
                if (!document.getElementById('playground-model-select')) {
                    const actionsDiv = header?.querySelector('.header-actions');
                    if (actionsDiv) {
                        const select = document.createElement('select');
                        select.id = 'playground-model-select';
                        select.style.cssText = 'padding: 4px 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #fff; font-size: 11px; cursor: pointer;';
                        select.innerHTML = `
                            <option value="claude-sonnet">Claude Sonnet</option>
                            <option value="claude-opus">Claude Opus</option>
                            <option value="gpt-4o">GPT-4o</option>
                            <option value="gemini-pro">Gemini Pro</option>
                        `;
                        select.value = chatState.playgroundModel;
                        select.onchange = (e) => {
                            chatState.playgroundModel = e.target.value;
                            updatePlaygroundUI(true);
                        };
                        actionsDiv.insertBefore(select, actionsDiv.firstChild);
                    }
                }

                // Add exit button if not present
                if (!document.getElementById('playground-exit-btn')) {
                    const actionsDiv = header?.querySelector('.header-actions');
                    if (actionsDiv) {
                        const exitBtn = document.createElement('button');
                        exitBtn.id = 'playground-exit-btn';
                        exitBtn.title = 'Exit Playground';
                        exitBtn.textContent = 'ðŸšª';
                        exitBtn.onclick = () => COMMAND_REGISTRY['exit_playground']().then ? COMMAND_REGISTRY['exit_playground']() : addMessage(COMMAND_REGISTRY['exit_playground'](), 'system');
                        actionsDiv.insertBefore(exitBtn, actionsDiv.firstChild);
                    }
                }
            } else {
                if (title) {
                    title.innerHTML = 'ðŸŒ³ TreeBeard';
                }
                header?.style.setProperty('background', 'linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(99, 102, 241, 0.15))');

                // Remove playground UI elements
                document.getElementById('playground-model-select')?.remove();
                document.getElementById('playground-exit-btn')?.remove();
            }
        }

	        const KAI_KERNEL = `SYSTEM (Kai Kernel):
Follow the task promptâ€™s formatting and constraints exactly.
Do not restate instructions. If instructions conflict, prefer the more specific/local requirement.
Be direct. Ask at most one clarifying question only if proceeding would likely be wrong/wasteful.
If uncertain, say so briefly and propose a quick check.`;

	        function applyKaiKernel(systemPrompt, contextTag) {
	            if (contextTag === 'quick_command_json') return systemPrompt;
	            if (systemPrompt.includes(KAI_KERNEL)) return systemPrompt;
	            return KAI_KERNEL + "\n\n" + systemPrompt;
	        }

	        async function handlePlaygroundMessage(message) {
	            // Add to playground history
	            chatState.playgroundHistory.push({ role: 'user', content: message });

	            try {
	                let response;
	                const model = chatState.playgroundModel;

                if (model.startsWith('claude')) {
                    // Use Claude API
                    const modelId = model === 'claude-opus' ? 'claude-opus-4-20250514' :
                                   model === 'claude-haiku' ? 'claude-3-haiku-20240307' :
                                   'claude-sonnet-4-20250514';

                    const apiKey = localStorage.getItem('anthropic_api_key');
                    const useServer = !apiKey;

                    const messages = chatState.playgroundHistory.map(m => ({
                        role: m.role,
                        content: m.content
                    }));

                    if (useServer) {
                        const res = await fetch('/.netlify/functions/claude-proxy', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: modelId,
                                max_tokens: 2000,
                                system: chatState.playgroundSystemPrompt,
                                messages: messages
                            })
                        });
                        const data = await res.json();
                        if (data.error) throw new Error(data.error);
                        response = data.content[0].text;
                    } else {
                        const res = await fetch('https://api.anthropic.com/v1/messages', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': apiKey,
                                'anthropic-version': '2023-06-01',
                                'anthropic-dangerous-direct-browser-access': 'true'
                            },
	                            body: JSON.stringify({
	                                model: modelId,
	                                max_tokens: 2000,
	                                system: applyKaiKernel(chatState.playgroundSystemPrompt, 'playground_anthropic'),
	                                messages: messages
	                            })
	                        });
	                        const data = await res.json();
	                        if (data.error) throw new Error(data.error.message);
                        response = data.content[0].text;
                    }
                } else if (model.startsWith('gpt')) {
                    // Use OpenAI API
                    const openaiKey = localStorage.getItem('openai_api_key');
                    if (!openaiKey) {
                        return 'ðŸ”‘ Please set your OpenAI API key in Settings to use GPT models.';
                    }

                    const modelId = model === 'gpt-4-turbo' ? 'gpt-4-turbo-preview' : 'gpt-4o';
                    const messages = [
                        { role: 'system', content: chatState.playgroundSystemPrompt },
                        ...chatState.playgroundHistory.map(m => ({ role: m.role, content: m.content }))
                    ];

                    const res = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiKey}`
                        },
                        body: JSON.stringify({
                            model: modelId,
                            max_tokens: 2000,
                            messages: messages
                        })
                    });
                    const data = await res.json();
                    if (data.error) throw new Error(data.error.message);
                    response = data.choices[0].message.content;
                } else if (model.startsWith('gemini')) {
                    // Use Gemini API
                    const geminiKey = localStorage.getItem('gemini_api_key');
                    if (!geminiKey) {
                        return 'ðŸ”‘ Please set your Gemini API key in Settings to use Gemini models.';
                    }

                    // Map model name to API model ID
                    let modelId;
                    if (model === 'gemini-flash') modelId = 'gemini-2.5-flash';
                    else if (model === 'gemini-pro') modelId = 'gemini-2.5-pro';
                    else if (model === 'gemini-3-pro') modelId = 'gemini-3-pro-preview';
                    else modelId = model; // Use as-is if already a full model ID
                    const contents = chatState.playgroundHistory.map(m => ({
                        role: m.role === 'user' ? 'user' : 'model',
                        parts: [{ text: m.content }]
                    }));

                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${geminiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            systemInstruction: { parts: [{ text: chatState.playgroundSystemPrompt }] },
                            contents: contents
                        })
                    });
                    const data = await res.json();
                    if (data.error) throw new Error(data.error.message);
                    response = data.candidates[0].content.parts[0].text;
                }

                // Add response to history
                chatState.playgroundHistory.push({ role: 'assistant', content: response });

                return response;
            } catch (error) {
                console.error('Playground error:', error);
                return `âŒ Error: ${error.message}`;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 366: LIFETREE BIOGRAPHER MODE DETECTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Detect the appropriate biographer mode based on input type
         * Modes: 'guided' (interview), 'listening' (long stories), 'scaffolding' (rapid structure), 'artifact' (photo/file)
         */
        function detectBiographerMode(message, hasAttachment = false) {
            // Only applies to LifeTree pattern
            if (typeof currentPattern === 'undefined' || currentPattern !== 'lifetree') {
                return null;
            }

            // Artifact Import: Photo or file attached
            if (hasAttachment) {
                return 'artifact';
            }

            // Open Listening: Long text (>300 chars) suggests storytelling mode
            if (message.length > 300) {
                return 'listening';
            }

            // Timeline Scaffolding: Rapid anchor point requests
            const scaffoldingPatterns = /\b(list|timeline|major|key events?|all|when did|what happened|marriages?|jobs?|moves?|births?|deaths?)\b/i;
            if (scaffoldingPatterns.test(message) && message.length < 100) {
                return 'scaffolding';
            }

            // Default: Guided Interview for short inputs
            return 'guided';
        }

        /**
         * BUILD 380: Get mode display info for the indicator - Larry King style
         */
        function getBiographerModeInfo(mode) {
            const modes = {
                'guided': { icon: 'ðŸŽ™ï¸', label: 'Larry King Mode', description: 'Simple questions, genuine curiosity, one at a time' },
                'listening': { icon: 'ðŸ“–', label: 'Story Mode', description: 'Tell me everything - I\'ll extract the gold' },
                'scaffolding': { icon: 'ðŸ—ï¸', label: 'Timeline Mode', description: 'Let\'s build the structure - major events first' },
                'artifact': { icon: 'ðŸ“¸', label: 'Photo Mode', description: 'What am I looking at? When was this?' }
            };
            return modes[mode] || { icon: 'ðŸŒ³', label: 'TreeBeard', description: 'AI assistant' };
        }

        /**
         * BUILD 380: Check and show biographer indicator based on current pattern
         */
        function checkBiographerIndicator() {
            const indicator = document.getElementById('biographer-mode-indicator');
            if (!indicator) return;

            if (typeof currentPattern !== 'undefined' && currentPattern === 'lifetree') {
                // Show Larry King mode by default for LifeTree
                if (!chatState.biographerMode) {
                    chatState.biographerMode = 'guided';
                }
                updateBiographerModeIndicator(chatState.biographerMode);
            } else {
                // Hide for non-LifeTree patterns
                indicator.style.display = 'none';
            }
        }

        /**
         * Update the biographer mode indicator in the TreeBeard panel
         */
        function updateBiographerModeIndicator(mode) {
            const indicator = document.getElementById('biographer-mode-indicator');
            if (!indicator) return;

            if (!mode) {
                indicator.style.display = 'none';
                return;
            }

            const info = getBiographerModeInfo(mode);
            indicator.innerHTML = `${info.icon} ${info.label}`;
            indicator.title = info.description + ' (click to change)';
            indicator.style.display = 'inline-flex';
            chatState.biographerMode = mode;
        }

        /**
         * Manually cycle through biographer modes (for user override)
         */
        window.cycleBiographerMode = function() {
            if (typeof currentPattern === 'undefined' || currentPattern !== 'lifetree') {
                return;
            }

            const modes = ['guided', 'listening', 'scaffolding', 'artifact'];
            const currentIndex = modes.indexOf(chatState.biographerMode);
            const nextIndex = (currentIndex + 1) % modes.length;
            const nextMode = modes[nextIndex];

            updateBiographerModeIndicator(nextMode);

            const info = getBiographerModeInfo(nextMode);
            showToast(`${info.icon} Switched to ${info.label} mode`, 'info');
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 368: CONVERSATION MODE - FULL AI INTELLIGENCE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Detect if message needs full conversation mode vs quick command mode
         * Returns: 'conversation' for deep thinking, 'command' for quick actions
         */
        function detectInteractionMode(message) {
            const msg = message.toLowerCase().trim();

            // Quick commands - use fast command mode
            const quickPatterns = [
                /^(switch|change|set|go|open|close|show|hide|toggle|zoom|undo|redo|save|load|export|import)\b/i,
                /^(canvas|tree|3d)\s*(view)?$/i,
                /^\/(help|clear|settings)/i,
                /^(yes|no|ok|sure|cancel|done|next|back)$/i
            ];

            for (const pattern of quickPatterns) {
                if (pattern.test(msg)) return 'command';
            }

            // Conversation indicators - use full AI
            const conversationIndicators = [
                msg.length > 100, // Longer messages need thoughtful response
                /\?.*\?/.test(msg), // Multiple questions
                /(tell me|explain|help me understand|what do you think|how should|why|describe)/i.test(msg),
                /(remember|you said|earlier|we talked|last time)/i.test(msg), // Memory references
                /(feel|feeling|emotion|remember when|story|memory|childhood|growing up)/i.test(msg), // Emotional/biographical
                currentPattern === 'lifetree', // Always conversation mode for LifeTree
                currentPattern === 'philosophy', // Deep thinking for philosophy
            ];

            const conversationScore = conversationIndicators.filter(Boolean).length;

            // If 2+ indicators, use conversation mode
            return conversationScore >= 2 ? 'conversation' : 'command';
        }

        /**
         * Full conversation handler - uses AI naturally without JSON constraints
         */
	        async function handleConversation(userMessage) {
	            const phases = typeof capexTree !== 'undefined' ? (capexTree.children || capexTree.phases || []) : [];
	            const pattern = typeof currentPattern !== 'undefined' ? currentPattern : 'generic';
	            const patternDef = PATTERNS[pattern] || PATTERNS.generic;

            // BUILD 383: Use rich context for LifeTree, standard for others
            const treeContext = pattern === 'lifetree'
                ? buildLifeTreeRichContext(phases)
                : buildTreeContext(phases, pattern);

            // Pattern-specific persona
            const personas = {
                lifetree: `You are a warm, curious biographer helping document a life story. You use the Birthday Method - walking through life year by year. You're proactive: you ASK questions, you LEAD the conversation, you jog memories with what you already know. When given an age, ALWAYS calculate the year (birth_year + age). After capturing a memory, immediately ask about the NEXT year.`,
                philosophy: `You are a scholarly companion well-versed in philosophy. You engage deeply with arguments, identify logical structures, reference relevant philosophers and texts, and help build rigorous dialectical analyses. You can discuss Plato, Aristotle, Kant, Hegel, Nietzsche, Heidegger, and contemporary thinkers with equal facility.`,
                capex: `You are a sharp financial analyst helping with capital expenditure planning. You understand NPV, IRR, payback periods, risk assessment, and vendor evaluation. You help structure investment proposals that would satisfy CFOs and board members.`,
                sales: `You are a seasoned sales strategist. You understand pipeline management, deal qualification, stakeholder mapping, and closing techniques. You help structure deals and identify risks and opportunities.`,
                thesis: `You are an academic writing coach. You help structure arguments, identify gaps in reasoning, suggest relevant citations, and ensure scholarly rigor. You understand academic conventions across disciplines.`,
                film: `You are a film production expert. You understand shot composition, scene structure, narrative pacing, and the technical aspects of video production including prompts for AI video tools.`,
                generic: `You are TreeBeard, a wise and helpful assistant. You're knowledgeable about project management, hierarchical thinking, and breaking down complex work into manageable pieces.`
            };

            const persona = personas[pattern] || personas.generic;

            // BUILD 378: Tiered prompt for conversation mode
            const intent = detectTreeBeardIntent(userMessage);

            let systemPrompt = `${persona}

You are embedded in TreeListy. Respond naturally (NOT JSON). Project: "${capexTree?.name || 'Unknown'}" | Pattern: ${pattern}

${treeContext}`;

            // Add commands if user wants to DO something
            if (intent.needsNavigation || intent.needsEditing) {
                systemPrompt += `

ACTIONS (end response with [ACTION: cmd:param] or [ACTION: none]):
â€¢ find_node:{query} - Search & focus node (e.g., find_node:1960s)
â€¢ add_child:{name} - Add child to focused node
â€¢ set_field:{field}:{value} - Set field value
â€¢ expand_node / collapse_node - Toggle node
â€¢ switch_to_canvas / switch_to_tree - Change view
â€¢ open_wizard / deep_dive - AI features

NATURAL LANGUAGE: "the 60s" = 1960s, "build out" = add_child, navigate FIRST then act`;
            }

            // LifeTree gets Larry King biographer
            if (pattern === 'lifetree') {
                systemPrompt += getLifeTreeBiographerPrompt(phases, { projectName: capexTree?.name, pattern, phaseCount: phases.length, itemCount: phases.reduce((s,p) => s + (p.items||p.children||[]).length, 0) }, chatState);
            }

            // Feature help if asking about capabilities
            if (intent.needsFeatureHelp) {
                systemPrompt += getFeatureGuide();
            }

	            systemPrompt += `

	Be warm, insightful, concise. Ask at most one follow-up question only if needed. End with [ACTION: x] if taking action.`;

            try {
                const aiMode = document.getElementById('unified-ai-mode-select')?.value || 'server-sonnet';
                const messages = [
                    ...chatState.conversationHistory.slice(-8).map(m => ({
                        role: m.role === 'user' ? 'user' : 'assistant',
                        content: m.content
                    })),
                    { role: 'user', content: userMessage }
                ];

                let response;
                if (aiMode.startsWith('server-')) {
                    response = await fetch('/.netlify/functions/claude-proxy', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 1500, // Much more room for thoughtful responses
                            system: systemPrompt,
                            messages: messages
                        })
                    });
                } else {
                    const anthropicKey = localStorage.getItem('anthropic_api_key');
                    if (!anthropicKey) {
                        return { message: 'ðŸ”‘ Please set your API key or switch to Server mode.', action: null };
                    }
	                    response = await fetch('https://api.anthropic.com/v1/messages', {
	                        method: 'POST',
	                        headers: {
	                            'Content-Type': 'application/json',
                            'x-api-key': anthropicKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
	                        },
	                        body: JSON.stringify({
	                            model: 'claude-sonnet-4-20250514',
	                            max_tokens: 1500,
	                            system: applyKaiKernel(systemPrompt, 'conversation_anthropic'),
	                            messages: messages
	                        })
	                    });
	                }

                const data = await response.json();
                if (data.error) throw new Error(data.error.message || data.error);

                const aiResponse = data.content[0].text;

                // BUILD 383: Extract ALL actions for real-time saves (multiple [ACTION:...] blocks)
                const actionMatches = [...aiResponse.matchAll(/\[ACTION:\s*([^\]]+)\]/gi)];
                let actions = [];
                let cleanResponse = aiResponse.replace(/\[ACTION:[^\]]+\]/gi, '').trim();

                actionMatches.forEach(match => {
                    const actionParts = match[1].split(':');
                    const action = actionParts[0].trim();
                    const actionParam = actionParts.slice(1).join(':').trim() || null;
                    if (action.toLowerCase() !== 'none') {
                        actions.push({ action, actionParam });
                    }
                });

                // For backwards compatibility, also return first action as primary
                const primaryAction = actions.length > 0 ? actions[0] : { action: null, actionParam: null };

                return {
                    message: cleanResponse,
                    action: primaryAction.action,
                    actionParam: primaryAction.actionParam,
                    actions: actions, // BUILD 383: All actions for multi-step execution
                    buttons: null
                };

            } catch (error) {
                console.error('Conversation error:', error);
                return {
                    message: `I had trouble processing that: ${error.message}. Let me try a simpler approach.`,
                    action: null
                };
            }
        }

        /**
         * Build context about current tree state for AI
         */
        function buildTreeContext(phases, pattern) {
            if (!phases || phases.length === 0) {
                return 'TREE STATE: Empty - no content yet.';
            }

            let context = `TREE STATE (${phases.length} ${PATTERNS[pattern]?.levels?.phase || 'phases'}):\n`;

            // For LifeTree, include birth year calculation
            if (pattern === 'lifetree') {
                const birthYearMatch = phases[0]?.name?.match(/(\d{4})/);
                if (birthYearMatch) {
                    const birthYear = parseInt(birthYearMatch[1]);
                    context += `BIRTH YEAR: ${birthYear} (IMPORTANT: age + ${birthYear} = event year)\n`;
                }
            }

            // List phases with their items
            phases.slice(0, 8).forEach((phase, i) => {
                const items = phase.items || phase.children || [];
                const itemNames = items.slice(0, 5).map(it => it.name).join(', ');
                const moreItems = items.length > 5 ? ` +${items.length - 5} more` : '';
                context += `â€¢ ${phase.name}: ${items.length} items${itemNames ? ` (${itemNames}${moreItems})` : ''}\n`;
            });

            if (phases.length > 8) {
                context += `... and ${phases.length - 8} more phases\n`;
            }

            return context;
        }

        /**
         * BUILD 383: Rich LifeTree context - mines ALL captured details
         * TreeBeard needs to see people, places, dates - not just item names
         */
        function buildLifeTreeRichContext(phases) {
            if (!phases || phases.length === 0) {
                return 'MEMORIES CAPTURED: None yet - let\'s get started!\n';
            }

            // Extract all unique people and places
            const allPeople = new Map(); // name -> [decades they appear in]
            const allPlaces = new Map(); // place -> [decades]
            const allMemories = [];

            phases.forEach(phase => {
                const decadeName = phase.name || 'Unknown';
                (phase.items || phase.children || []).forEach(item => {
                    // Track this memory
                    const memory = {
                        decade: decadeName,
                        name: item.name,
                        date: item.eventDate || '',
                        location: item.location || '',
                        people: item.people || '',
                        description: item.description || ''
                    };
                    allMemories.push(memory);

                    // Extract people
                    if (item.people) {
                        item.people.split(/[,;]/).forEach(p => {
                            const name = p.trim().split('(')[0].trim(); // Get name without parenthetical
                            if (name && name.length > 1) {
                                if (!allPeople.has(name)) allPeople.set(name, new Set());
                                allPeople.get(name).add(decadeName);
                            }
                        });
                    }

                    // Extract places
                    if (item.location) {
                        const place = item.location.trim();
                        if (place) {
                            if (!allPlaces.has(place)) allPlaces.set(place, new Set());
                            allPlaces.get(place).add(decadeName);
                        }
                    }
                });
            });

            // Build rich context
            let context = `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
WHAT WE'VE CAPTURED (${allMemories.length} memories)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;

            // People index (most important for avoiding redundant questions)
            if (allPeople.size > 0) {
                context += `ðŸ‘¥ PEOPLE WE KNOW ABOUT:\n`;
                allPeople.forEach((decades, name) => {
                    context += `  â€¢ ${name} (appears in: ${[...decades].join(', ')})\n`;
                });
                context += '\n';
            }

            // Places index
            if (allPlaces.size > 0) {
                context += `ðŸ“ PLACES MENTIONED:\n`;
                allPlaces.forEach((decades, place) => {
                    context += `  â€¢ ${place} (${[...decades].join(', ')})\n`;
                });
                context += '\n';
            }

            // Detailed memories by decade (last 3 decades with activity)
            const activeDecades = phases.filter(p => (p.items || p.children || []).length > 0);
            context += `ðŸ“… MEMORIES BY DECADE:\n`;
            activeDecades.slice(-5).forEach(phase => {
                const items = phase.items || phase.children || [];
                if (items.length > 0) {
                    context += `\n${phase.name}:\n`;
                    items.forEach(item => {
                        context += `  â€¢ ${item.name}`;
                        if (item.eventDate) context += ` [${item.eventDate}]`;
                        if (item.location) context += ` @ ${item.location}`;
                        if (item.people) context += ` with ${item.people}`;
                        context += '\n';
                        if (item.description) {
                            context += `    "${item.description}"\n`;
                        }
                    });
                }
            });

            return context;
        }

        /**
         * Toggle conversation mode manually
         */
        window.toggleConversationMode = function() {
            chatState.conversationMode = !chatState.conversationMode;
            updateConversationModeIndicator();
            showToast(chatState.conversationMode ? 'ðŸ§  Deep Conversation mode ON' : 'âš¡ Quick Command mode ON', 'info');
        };

        /**
         * Update conversation mode indicator in UI
         */
        function updateConversationModeIndicator() {
            const indicator = document.getElementById('conversation-mode-indicator');
            if (!indicator) return;

            if (chatState.conversationMode) {
                indicator.innerHTML = 'ðŸ§  Deep';
                indicator.title = 'ðŸ§  DEEP MODE: Full AI analysis & insights\nâ€¢ "What patterns do you see?"\nâ€¢ "Compare my 20s to 30s"\nâ€¢ Complex questions & long inputs\n\nClick to switch to Quick Mode';
                indicator.style.background = 'rgba(34, 197, 94, 0.2)';
                indicator.style.color = '#86efac';
            } else {
                indicator.innerHTML = 'âš¡ Quick';
                indicator.title = 'âš¡ QUICK MODE: Fast commands\nâ€¢ "find 1980s", "add: event name"\nâ€¢ "summarize", "health check"\nâ€¢ Navigation & simple edits\n\nClick to switch to Deep Mode';
                indicator.style.background = 'rgba(99, 102, 241, 0.2)';
                indicator.style.color = '#a5b4fc';
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LIFETREE BIOGRAPHER PROMPT BUILDER (Build 369)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 378: TIERED SKILL SYSTEM - Modular prompt loading
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Detect user intent to load appropriate context
         */
        function detectTreeBeardIntent(message) {
            const msg = message.toLowerCase();
            return {
                isGreeting: /^(hi|hello|hey|howdy|good\s+(morning|afternoon|evening))/.test(msg),
                needsNavigation: /find|go to|navigate|show|expand|collapse|focus|select/.test(msg),
                needsEditing: /add|create|edit|change|set|update|delete|remove/.test(msg),
                needsFeatureHelp: /how do i|what is|can you|does it|feature|help|wizard|hyperedge/.test(msg),
                needsPatternInfo: /pattern|switch|change to|fields|what fields/.test(msg),
                isBiographical: /born|grew up|school|married|job|lived|moved|family|sibling|parent|child|pet|friend/.test(msg),
                isComplex: msg.length > 100 || /analyze|review|deep dive|compare/.test(msg),
                needsHealthCheck: /health\s*check|check.*tree|diagnos|cleanup|fix.*structure|redundan.*phase|empty.*phase|consolidat/.test(msg)
            };
        }

        /**
         * BUILD 378: Core persona - always included (~150 tokens)
         */
        function getTreeBeardCorePersona(context, familiarityLevel) {
            return `You are TreeBeard, a wise AI assistant in TreeListy.
Project: "${context.projectName}" | Pattern: ${context.pattern} | ${context.phaseCount} phases, ${context.itemCount} items
${familiarityLevel === 'familiar' ? 'You know this user well.' : familiarityLevel === 'acquainted' ? 'You\'ve been chatting.' : 'Fresh conversation.'}
Be warm, concise (2-3 sentences), occasionally witty.`;
        }

        /**
         * BUILD 378: Command vocabulary - loaded when navigation/editing needed (~200 tokens)
         */
        function getCommandVocabulary() {
            return `
COMMANDS (return as action in JSON):
â€¢ find_node:{query} - Search & focus node
â€¢ add_child:{name} - Add child to focused node
â€¢ set_field:{field}:{value} - Set field value
â€¢ expand_node / collapse_node - Toggle node
â€¢ switch_to_canvas / switch_to_tree - Change view
â€¢ open_wizard / deep_dive / find_redundancies - AI features
â€¢ add_phase / delete_node / delete_phase:{id} / undo / redo
â€¢ lifetree_health_check - (LifeTree only) Diagnose structure issues`;
        }

        /**
         * BUILD 378: Current pattern fields - loaded when pattern help needed (~100 tokens)
         */
        function getCurrentPatternFields(pattern) {
            const patternFields = {
                generic: 'cost, leadTime, dependencies, pmStatus, pmProgress',
                philosophy: 'speaker, premises, objections, dialectics, textualReference',
                sales: 'dealValue, probability, closeDate, contacts, stage',
                lifetree: 'eventDate, age, location, people, emotion, source, confidence',
                capex: 'cost, vendor, leadTime, riskLevel, approvalStatus',
                thesis: 'wordCount, citations, keyArgument, methodology',
                film: 'camera, lighting, videoPrompt, duration',
                veo3: 'videoPrompt, duration, aspectRatio, style',
                sora2: 'videoPrompt, duration, aspectRatio, style'
            };
            return `Pattern "${pattern}" fields: ${patternFields[pattern] || patternFields.generic}`;
        }

        /**
         * BUILD 378: Feature guide - loaded when user asks about capabilities (~150 tokens)
         */
        function getFeatureGuide() {
            return `
KEY FEATURES:
â€¢ AI Wizard (open_wizard): Conversational tree building
â€¢ Deep Dive: Multi-node scholarly analysis
â€¢ Smart Suggest: AI fills fields contextually
â€¢ Hyperedges: Cross-phase connections (Canvas View â†’ multi-select â†’ Create)
â€¢ Find Redundancies: Detect duplicate nodes
â€¢ Health Check (lifetree_health_check): LifeTree diagnostics - empty phases, redundant periods, chronology
â€¢ Voice Capture: Mobile recording â†’ AI processing
â€¢ Artifacts: Attach files to nodes
â€¢ Live Sync: Real-time collaboration`;
        }

        /**
         * BUILD 403: Simplified LifeTree Utility Prompt
         * Quick memory addition and utility commands - full interview moved to Chat Builder
         */
        function getLifeTreeBiographerPrompt(phases, context, chatState) {
            const birthYear = capexTree?.birthYear || capexTree?.metadata?.birthYear ||
                (phases[0]?.name?.match(/\d{4}/) ? parseInt(phases[0].name.match(/\d{4}/)[0]) : null);
            const subjectName = capexTree?.metadata?.subjectName || context.projectName.replace("'s Life", "").replace(" Life", "").trim();
            const eventCount = phases.reduce((sum, p) => sum + (p.items || p.children || []).length, 0);

            return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
LIFETREE UTILITY MODE - BUILD 403
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

You're a quick utility assistant for ${subjectName}'s LifeTree (${eventCount} memories captured).
Birth year: ${birthYear || 'Unknown'}

YOUR ROLE: Fast, helpful memory capture and tree management. NOT interviews - use Chat Builder (ðŸ’¬) for full Larry King-style biography interviews.

WHAT YOU DO:
â€¢ Quick memory adds from voice/text
â€¢ Find memories by date, person, or place
â€¢ Summarize the life story so far
â€¢ Run health checks on the tree
â€¢ Navigate to specific decades

RESPONSE STYLE:
â€¢ Brief, friendly acknowledgments
â€¢ Save memories immediately with [ACTION:] tags
â€¢ No long interview questions - just quick utility

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
MEMORY CAPTURE FORMAT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

When user shares a memory, extract what you can and save immediately:

RICH FORMAT (extract all available details):
[ACTION: find_node:{decade}]
[ACTION: add_child:{"name":"Event Title","eventDate":"Date","age":"Age","location":"Place","people":"Who","description":"Details","emotion":"joy|pride|etc"}]

SIMPLE FORMAT (for quick entries):
[ACTION: add_child:Started kindergarten at Main Street School]

ACKNOWLEDGE SAVES: "âœ“ Added: [title] (+1)"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
AVAILABLE COMMANDS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â€¢ find_node:{term} - Navigate to decade, person, or place
â€¢ add_child:{JSON or text} - Add memory to focused location
â€¢ set_field:{field}:{value} - Update field on focused node
â€¢ health_check - Run LifeTree diagnostics
â€¢ summarize - Give overview of life story so far

EXAMPLE - User voice capture: "I graduated high school in 1978"

RESPONSE:
"âœ“ Added: High school graduation (+1)

[ACTION: find_node:1970s]
[ACTION: add_child:{"name":"High School Graduation","eventDate":"1978","age":"${birthYear ? 1978 - birthYear : '?'}","description":"Graduated high school"}]"

ðŸ’¡ TIP: For full biography interviews with guided questions, use the Chat Builder (ðŸ’¬ button) with LifeTree pattern.
`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 384: REPAIR ISSUE DISPLAY - Show issues one at a time
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function showRepairIssue(index) {
            if (!window.repairQueue || index >= window.repairQueue.length) {
                // All done
                const fixed = window.repairIndex || 0;
                const total = window.repairQueue?.length || 0;
                const skipped = total - fixed;
                addMessage(`âœ… **Repair complete!** Fixed ${fixed} issue${fixed !== 1 ? 's' : ''}${skipped > 0 ? `, skipped ${skipped}` : ''}.`, 'assistant');
                window.repairQueue = null;
                window.repairIndex = 0;
                return;
            }

            const issue = window.repairQueue[index];
            const remaining = window.repairQueue.length - index;
            let message = `\n**Issue ${index + 1}/${window.repairQueue.length}:**\n`;

            if (issue.type === 'undefined') {
                const phaseName = issue.phase?.name || 'Unknown phase';
                const children = issue.node.children || issue.node.items || issue.node.subItems || [];
                const childList = children.slice(0, 3).map(c => c.name || c.title || '?').join(', ');
                const moreChildren = children.length > 3 ? ` +${children.length - 3} more` : '';

                message += `ðŸ”´ **Undefined node** in ${phaseName}\n`;
                if (children.length > 0) {
                    message += `   â””â”€ Contains: ${childList}${moreChildren}\n`;
                }
                message += `\nðŸ’¡ Suggested name: "${issue.suggestion}"`;

                addMessage(message, 'assistant', [
                    { label: `âœ“ Rename to "${issue.suggestion}"`, action: 'repair_rename', param: issue.suggestion },
                    { label: 'ðŸ—‘ï¸ Delete & Keep Children', action: 'repair_delete_promote' },
                    { label: 'âœï¸ Custom Name...', action: 'repair_custom_name' },
                    { label: 'â­ï¸ Skip', action: 'repair_skip' }
                ]);

            } else if (issue.type === 'duplicate') {
                const phaseName = issue.phase?.name || 'Unknown phase';
                const similarity = Math.round(issue.similarity * 100);

                message += `ðŸŸ¡ **Duplicate found** in ${phaseName} (${similarity}% similar)\n`;
                message += `   â€¢ "${issue.node.name || issue.node.title}"\n`;
                message += `   â€¢ "${issue.duplicate.name || issue.duplicate.title}"`;

                addMessage(message, 'assistant', [
                    { label: 'ðŸ”— Merge Into One', action: 'repair_merge' },
                    { label: 'âœ“ Keep Both', action: 'repair_skip' },
                    { label: 'âœï¸ Rename Second', action: 'repair_rename_duplicate' }
                ]);

            } else if (issue.type === 'missing_id') {
                // Auto-fix missing IDs
                issue.node.id = 'repair_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                message += `ðŸŸ¢ **Fixed:** Added missing ID to "${issue.node.name || 'node'}"`;
                addMessage(message, 'assistant');

                // Auto-advance
                window.repairIndex++;
                setTimeout(() => showRepairIssue(window.repairIndex), 300);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AI COMMAND INTERPRETER - BUILD 378: TIERED PROMPT SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        async function interpretCommand(userMessage) {
            // Get current context
            const phases = typeof capexTree !== 'undefined' ? (capexTree.children || capexTree.phases || []) : [];
            const context = {
                projectName: typeof capexTree !== 'undefined' ? capexTree.name : 'Unknown',
                pattern: typeof currentPattern !== 'undefined' ? currentPattern : 'generic',
                itemCount: phases.reduce((sum, p) => sum + (p.items || p.children || []).length, 0),
                phaseCount: phases.length,
                viewMode: document.getElementById('canvas-container')?.classList.contains('active') ? 'canvas' : 'tree',
                selectedCount: window.selectedCanvasNodes?.length || 0
            };

            // Detect user intent
            const intent = detectTreeBeardIntent(userMessage);
            const conversationCount = chatState.conversationHistory.filter(m => m.role === 'user').length;
            const familiarityLevel = conversationCount > 5 ? 'familiar' : conversationCount > 2 ? 'acquainted' : 'new';

            // BUILD 378: Tiered prompt construction - only load what's needed
            let systemPrompt = getTreeBeardCorePersona(context, familiarityLevel);

            // Tier 1: Always include response format (~100 tokens)
            systemPrompt += `

RESPONSE FORMAT (JSON only):
{"type": "action"|"answer"|"clarify", "message": "response", "action": "cmd"|null, "actionParam": "param"|null, "buttons": [{"label":"X","action":"y"}]|null}
Return ONLY valid JSON.`;

            // Tier 2: Add commands if navigation/editing detected (~200 tokens)
            if (intent.needsNavigation || intent.needsEditing || intent.isComplex || intent.needsHealthCheck) {
                systemPrompt += getCommandVocabulary();
            }

            // BUILD 392: Direct health check execution for LifeTree
            if (intent.needsHealthCheck && context.pattern === 'lifetree') {
                // Execute directly without AI call
                const result = COMMAND_REGISTRY['lifetree_health_check']();
                return typeof result === 'object' ? result : { message: result, buttons: null };
            }

            // Tier 3: Add pattern fields if pattern questions detected (~100 tokens)
            if (intent.needsPatternInfo) {
                systemPrompt += '\n' + getCurrentPatternFields(context.pattern);
            }

            // Tier 4: Add feature guide if asking about capabilities (~150 tokens)
            if (intent.needsFeatureHelp) {
                systemPrompt += getFeatureGuide();
            }

            // Tier 5: LifeTree biographer mode - Larry King style (~400 tokens)
            if (context.pattern === 'lifetree') {
                systemPrompt += getLifeTreeBiographerPrompt(phases, context, chatState);
            }

            // Log token savings in dev
            console.log(`ðŸŒ³ TreeBeard prompt tiers: greeting=${intent.isGreeting}, nav=${intent.needsNavigation}, edit=${intent.needsEditing}, help=${intent.needsFeatureHelp}, pattern=${intent.needsPatternInfo}, lifetree=${context.pattern === 'lifetree'}, healthCheck=${intent.needsHealthCheck}`);

            // Always add minimal rules
            systemPrompt += `

RULES: Be concise (2-3 sentences). ðŸŒ³ is your signature. Show personality.`;

            try {
                // Use TreeListy's existing AI infrastructure
                const aiMode = document.getElementById('unified-ai-mode-select')?.value || 'server-sonnet';

                let response;
                if (aiMode.startsWith('server-')) {
                    // Use server proxy
                    response = await fetch('/.netlify/functions/claude-proxy', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 500,
                            messages: [
                                ...chatState.conversationHistory.slice(-6).map(m => ({
                                    role: m.role === 'user' ? 'user' : 'assistant',
                                    content: m.content
                                })),
                                { role: 'user', content: systemPrompt + '\n\nUser message: ' + userMessage }
                            ]
                        })
                    });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error);
                    return JSON.parse(data.content[0].text);
                } else if (aiMode.startsWith('user-')) {
                    // Use user's API key
                    const anthropicKey = localStorage.getItem('anthropic_api_key');
                    if (!anthropicKey) {
                        return {
                            type: 'answer',
                            message: 'ðŸ”‘ Please set your API key in Settings (ðŸ”‘ button) or switch to Server mode.',
                            action: null
                        };
                    }
                    response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': anthropicKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 500,
                            messages: [{ role: 'user', content: systemPrompt + '\n\nUser message: ' + userMessage }]
                        })
                    });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return JSON.parse(data.content[0].text);
                }
            } catch (error) {
                console.error('Chat AI error:', error);
                // Fallback to simple pattern matching
                return fallbackInterpret(userMessage);
            }
        }

        // Simple fallback when AI unavailable - also handles direct commands
        function fallbackInterpret(message) {
            const lower = message.toLowerCase();
            const original = message; // Keep original for parameters

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NODE NAVIGATION (Build 250) - Most powerful commands
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Find node: "find Being", "search for Becoming", "locate synthesis"
            const findMatch = original.match(/(?:find|search|locate|go to|show me)\s+(?:node\s+)?["']?(.+?)["']?$/i);
            if (findMatch) {
                return { type: 'action', message: `ðŸ” Searching for "${findMatch[1]}"...`, action: 'find_node', actionParam: findMatch[1] };
            }

            // Focus by ID: "focus node_123"
            const focusMatch = original.match(/focus\s+(?:on\s+)?(?:node\s+)?(\S+)/i);
            if (focusMatch && focusMatch[1].includes('_')) {
                return { type: 'action', message: `ðŸŽ¯ Focusing on ${focusMatch[1]}...`, action: 'focus_node', actionParam: focusMatch[1] };
            }

            // Expand current node
            if (lower.match(/^expand(\s+node)?(\s+it)?$/)) {
                return { type: 'action', message: 'â¬‡ï¸ Expanding focused node...', action: 'expand_node' };
            }

            // Collapse current node
            if (lower.match(/^collapse(\s+node)?(\s+it)?$/)) {
                return { type: 'action', message: 'â¬†ï¸ Collapsing focused node...', action: 'collapse_node' };
            }

            // Tree navigation
            if (lower.includes('first child') || lower.includes('go to child') || lower.includes('into')) {
                return { type: 'action', message: 'ðŸ‘¶ Moving to first child...', action: 'first_child' };
            }
            if (lower.includes('parent') || lower.includes('go up') || lower.includes('back up')) {
                return { type: 'action', message: 'â¬†ï¸ Moving to parent...', action: 'parent_node' };
            }
            if (lower.includes('next') || lower.includes('next sibling')) {
                return { type: 'action', message: 'âž¡ï¸ Moving to next sibling...', action: 'next_sibling' };
            }
            if (lower.includes('prev') || lower.includes('previous')) {
                return { type: 'action', message: 'â¬…ï¸ Moving to previous sibling...', action: 'prev_sibling' };
            }
            if (lower.includes('list child') || lower.includes('show child') || lower.includes('children')) {
                return { type: 'action', message: 'ðŸ“‹ Listing children...', action: 'list_children' };
            }
            if (lower.includes('node info') || lower.includes('current node') || lower.includes('what node')) {
                return { type: 'action', message: 'ðŸ“ Node info:', action: 'node_info' };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD 384: REPAIR TREE COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            if (lower.includes('repair') || lower.includes('fix bad') || lower.includes('fix undefined') ||
                lower.includes('find duplicate') || lower.includes('health check') || lower.includes('clean up tree')) {
                return { type: 'action', message: 'ðŸ”§ Scanning tree for issues...', action: 'repair_tree' };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIELD EDITING (Build 250)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Set title: "set title to X", "rename to X", "title: X"
            const titleMatch = original.match(/(?:set\s+title|rename|title)\s*(?:to|:)\s*["']?(.+?)["']?$/i);
            if (titleMatch) {
                return { type: 'action', message: `âœï¸ Setting title...`, action: 'set_title', actionParam: titleMatch[1] };
            }

            // Set description: "set description to X", "describe as X"
            const descMatch = original.match(/(?:set\s+description|describe|description)\s*(?:to|as|:)\s*["']?(.+?)["']?$/i);
            if (descMatch) {
                return { type: 'action', message: `ðŸ“ Setting description...`, action: 'set_description', actionParam: descMatch[1] };
            }

            // Set any field: "set thesis to X"
            const fieldMatch = original.match(/set\s+(\w+)\s+(?:to|:)\s*["']?(.+?)["']?$/i);
            if (fieldMatch && !['title', 'description', 'theme'].includes(fieldMatch[1].toLowerCase())) {
                return { type: 'action', message: `âœ… Setting ${fieldMatch[1]}...`, action: 'set_field', actionParam: `${fieldMatch[1]}:${fieldMatch[2]}` };
            }

            // Get field: "get thesis", "show description", "what is the title"
            const getMatch = original.match(/(?:get|show|what\s+is\s+(?:the\s+)?)\s*(\w+)$/i);
            if (getMatch && ['thesis', 'argument', 'description', 'source', 'status'].includes(getMatch[1].toLowerCase())) {
                return { type: 'action', message: `ðŸ“– Getting ${getMatch[1]}...`, action: 'get_field', actionParam: getMatch[1] };
            }

            // List fields
            if (lower.includes('list fields') || lower.includes('show fields') || lower.includes('what fields')) {
                return { type: 'action', message: 'ðŸ“‹ Listing fields...', action: 'list_fields' };
            }

            // Add child: "add child X", "create child X", "new child X"
            const addChildMatch = original.match(/(?:add|create|new)\s+child\s*(?:named|called)?\s*["']?(.+?)["']?$/i);
            if (addChildMatch) {
                return { type: 'action', message: `âž• Adding child "${addChildMatch[1]}"...`, action: 'add_child', actionParam: addChildMatch[1] };
            }

            // Delete node
            if (lower.includes('delete') && (lower.includes('node') || lower.includes('this') || lower.includes('it'))) {
                return { type: 'action', message: 'ðŸ—‘ï¸ Deleting focused node...', action: 'delete_node' };
            }

            // AI enhance field: "enhance description", "ai improve thesis"
            const enhanceFieldMatch = original.match(/(?:enhance|improve|ai\s+enhance|ai\s+improve)\s+(?:the\s+)?(\w+)/i);
            if (enhanceFieldMatch && ['description', 'thesis', 'argument', 'summary', 'explanation'].includes(enhanceFieldMatch[1].toLowerCase())) {
                return { type: 'action', message: `âœ¨ AI enhancing ${enhanceFieldMatch[1]}...`, action: 'ai_enhance_field', actionParam: enhanceFieldMatch[1] };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // VIEW CONTROL (Build 250)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            if (lower.includes('zoom in') || lower === 'zoom+') {
                return { type: 'action', message: 'ðŸ” Zooming in...', action: 'zoom_in' };
            }
            if (lower.includes('zoom out') || lower === 'zoom-') {
                return { type: 'action', message: 'ðŸ” Zooming out...', action: 'zoom_out' };
            }
            if (lower.includes('fit') || lower.includes('zoom fit') || lower.includes('fit all')) {
                return { type: 'action', message: 'ðŸ“ Fitting to view...', action: 'zoom_fit' };
            }
            if (lower.includes('reset') && lower.includes('zoom')) {
                return { type: 'action', message: 'ðŸ”„ Resetting zoom...', action: 'zoom_reset' };
            }
            if (lower.includes('scroll to') || lower.includes('center on')) {
                return { type: 'action', message: 'ðŸ“ Scrolling to node...', action: 'scroll_to_node' };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ORIGINAL COMMANDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // View commands
            if (lower.includes('canvas')) return { type: 'action', message: 'ðŸŽ¨ Switching to Canvas!', action: 'switch_to_canvas' };
            if (lower.includes('tree view') || lower === 'tree') return { type: 'action', message: 'ðŸŒ³ Switching to Tree!', action: 'switch_to_tree' };
            if (lower.includes('toggle')) return { type: 'action', message: 'ðŸ”„ Toggling view!', action: 'toggle_view' };

            // Layout commands
            if (lower.includes('hierarchical') || lower.includes('hierarchy')) return { type: 'action', message: 'ðŸŒ³ Hierarchical layout!', action: 'layout_hierarchical' };
            if (lower.includes('timeline')) return { type: 'action', message: 'ðŸ“… Timeline layout!', action: 'layout_timeline' };
            if (lower.includes('force') || lower.includes('cluster')) return { type: 'action', message: 'ðŸŒ€ Force layout!', action: 'layout_force' };

            // File operations
            if (lower.includes('import excel')) return { type: 'action', message: 'ðŸ“Š Opening Excel import!', action: 'import_excel' };
            if (lower.includes('export excel') || (lower.includes('excel') && !lower.includes('import'))) return { type: 'action', message: 'ðŸ“Š Exporting Excel!', action: 'export_excel' };
            if (lower.includes('import') && lower.includes('text')) return { type: 'action', message: 'ðŸ“¥ Opening text import!', action: 'import_text' };
            if (lower.includes('load') && lower.includes('json')) return { type: 'action', message: 'ðŸ“‚ Loading JSON!', action: 'load_json' };
            if (lower.includes('save') || lower.includes('export json')) return { type: 'action', message: 'ðŸ’¾ Saving JSON!', action: 'export_json' };
            if (lower.includes('share') || lower.includes('shareable')) return { type: 'action', message: 'ðŸ“¤ Generating URL!', action: 'share_url' };
            if (lower.includes('sync') || lower.includes('firebase')) return { type: 'action', message: 'ðŸ”„ Opening sync!', action: 'live_sync' };
            if (lower.includes('png') || (lower.includes('image') && lower.includes('export'))) return { type: 'action', message: 'ðŸ“· Exporting PNG!', action: 'export_canvas_image' };

            // Editing
            if (lower.includes('pattern')) return { type: 'action', message: 'ðŸ“‹ Here are the patterns:', action: 'list_patterns' };
            if (lower.includes('add phase') || lower.includes('new phase')) return { type: 'action', message: 'âž• Adding phase!', action: 'add_phase' };
            if (lower.includes('undo')) return { type: 'action', message: 'â†©ï¸ Undoing!', action: 'undo' };
            if (lower.includes('redo')) return { type: 'action', message: 'â†ªï¸ Redoing!', action: 'redo' };
            if (lower.includes('search')) return { type: 'action', message: 'ðŸ” Opening search!', action: 'search' };
            if (lower.includes('expand all')) return { type: 'action', message: 'â¬‡ï¸ Expanding all!', action: 'expand_all' };
            if (lower.includes('collapse all')) return { type: 'action', message: 'â¬†ï¸ Collapsing all!', action: 'collapse_all' };
            if (lower.includes('select all')) return { type: 'action', message: 'âœ… Selecting all!', action: 'select_all' };
            if (lower.includes('clear') && lower.includes('select')) return { type: 'action', message: 'ðŸ”² Clearing selection!', action: 'clear_selection' };

            // AI operations
            if (lower.includes('enhance') && !lower.includes('field')) return { type: 'action', message: 'âœ¨ Enhancing selected!', action: 'enhance_selected' };
            if (lower.includes('deep dive') || lower.includes('analyze')) return { type: 'action', message: 'ðŸ”¬ Deep diving!', action: 'deep_dive' };
            if (lower.includes('generate') && lower.includes('image')) return { type: 'action', message: 'ðŸŽ¨ Opening Imagen!', action: 'generate_image' };

            // Themes
            if (lower.includes('steampunk')) return { type: 'action', message: 'âš™ï¸ Steampunk theme!', action: 'set_theme_steampunk' };
            if (lower.includes('tron')) return { type: 'action', message: 'ðŸ’  Tron theme!', action: 'set_theme_tron' };
            if (lower.includes('powerpuff') || lower.includes('pink')) return { type: 'action', message: 'ðŸ’— Powerpuff theme!', action: 'set_theme_powerpuff' };
            if (lower.includes('dark') || lower.includes('default theme')) return { type: 'action', message: 'ðŸŒ™ Dark theme!', action: 'set_theme_dark' };

            // Settings & Help
            if (lower.includes('help')) return { type: 'action', message: 'ðŸ“– Opening help!', action: 'show_help' };
            if (lower.includes('wizard') || lower.includes('build')) return { type: 'action', message: 'ðŸ§™ Opening wizard!', action: 'open_wizard' };
            if (lower.includes('setting') || lower.includes('api') || lower.includes('key')) return { type: 'action', message: 'ðŸ”‘ Opening settings!', action: 'open_settings' };
            if (lower.includes('new project') || lower.includes('start fresh')) return { type: 'action', message: 'ðŸ†• New project!', action: 'new_project' };
            if (lower.includes('info') || lower.includes('status') || lower.includes('stats')) return { type: 'action', message: 'ðŸ“‹ Project info:', action: 'project_info' };

            // Default with navigation-focused buttons
            return {
                type: 'answer',
                message: "I can help with that! Try these navigation commands or quick actions:",
                buttons: [
                    { label: 'ðŸ” Find Node', action: 'search' },
                    { label: 'ðŸ“‹ Node Info', action: 'node_info' },
                    { label: 'ðŸŽ¨ Canvas', action: 'switch_to_canvas' },
                    { label: 'ðŸ§™ Wizard', action: 'open_wizard' }
                ]
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // BUILD 393: Unified toggle - opens appropriate UI based on preference
        function toggleChatPanel() {
            console.log('ðŸŽ¯ toggleChatPanel: useNewChatUI =', window.useNewChatUI);
            if (window.useNewChatUI) {
                console.log('ðŸ†• -> Opening Command Frame');
                toggleCommandFrame();
            } else {
                console.log('ðŸ“¦ -> Opening Classic Panel');
                toggleClassicPanel();
            }
        }

        // Classic panel toggle (original implementation)
        function toggleClassicPanel() {
            const panel = document.getElementById('chat-assistant-panel');
            const bubble = document.getElementById('chat-assistant-bubble');

            chatState.isOpen = !chatState.isOpen;

            if (chatState.isOpen) {
                panel.classList.add('open');
                bubble.classList.add('active');
                bubble.textContent = 'âœ•';
                document.getElementById('chat-assistant-input')?.focus();
            } else {
                panel.classList.remove('open');
                bubble.classList.remove('active');
                bubble.textContent = 'ðŸ’¬';
            }
        }

        // BUILD 393: Command Frame toggle
        function toggleCommandFrame() {
            const frame = document.getElementById('command-frame');
            const bubble = document.getElementById('chat-assistant-bubble');

            chatState.isOpen = !chatState.isOpen;

            if (chatState.isOpen) {
                frame.classList.add('open');
                frame.classList.remove('minimized');
                chatState.commandFrameMinimized = false;
                bubble.classList.add('active');
                bubble.textContent = 'âœ•';
                document.getElementById('command-input')?.focus();
            } else {
                frame.classList.remove('open');
                bubble.classList.remove('active');
                bubble.textContent = 'ðŸ’¬';
            }
        }
        window.toggleCommandFrame = toggleCommandFrame;

        // BUILD 393: Minimize Command Frame
        function minimizeCommandFrame() {
            const frame = document.getElementById('command-frame');
            chatState.commandFrameMinimized = !chatState.commandFrameMinimized;
            frame.classList.toggle('minimized', chatState.commandFrameMinimized);
        }
        window.minimizeCommandFrame = minimizeCommandFrame;

        // BUILD 393: Toggle command history section
        function toggleCommandHistory() {
            const history = document.querySelector('.command-history');
            history?.classList.toggle('collapsed');
        }
        window.toggleCommandHistory = toggleCommandHistory;

        // BUILD 393: Handle send from Command Frame
        async function handleCommandSend() {
            const input = document.getElementById('command-input');
            const message = input?.value?.trim();

            if (!message) return;

            // Add to history display
            addCommandMessage(message, 'user');
            input.value = '';

            // Process via existing handleSendMessage logic
            // This reuses the existing TreeBeard intelligence
            await processCommandInput(message);
        }
        window.handleCommandSend = handleCommandSend;

        // BUILD 393: Add message to Command Frame history
        function addCommandMessage(content, type = 'assistant') {
            const historyMessages = document.querySelector('.history-messages');
            if (!historyMessages) return;

            const msg = document.createElement('div');
            msg.className = `history-msg ${type}`;

            // Format content
            let formatted = content
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            // Truncate long messages for history
            if (formatted.length > 200) {
                formatted = formatted.substring(0, 200) + '...';
            }

            msg.innerHTML = formatted;
            historyMessages.appendChild(msg);
            historyMessages.scrollTop = historyMessages.scrollHeight;

            // Expand history if it was collapsed and we have a response
            if (type === 'assistant') {
                const history = document.querySelector('.command-history');
                history?.classList.remove('collapsed');
            }

            // Store in shared chatState
            chatState.conversationHistory.push({ role: type, content });
            saveConversationMemory();
        }

        // BUILD 393: Process input from Command Frame (routes to existing TreeBeard logic)
        async function processCommandInput(message) {
            // Show processing state
            const sendBtn = document.getElementById('command-send-btn');
            if (sendBtn) {
                sendBtn.disabled = true;
                sendBtn.textContent = 'â³';
            }

            try {
                // Route to existing handleSendMessage which has all the TreeBeard intelligence
                // We temporarily set the classic input value so handleSendMessage can process it
                const classicInput = document.getElementById('chat-assistant-input');
                const originalValue = classicInput?.value;

                if (classicInput) {
                    classicInput.value = message;
                }

                // Call the main send handler (it handles all AI routing, commands, etc.)
                await handleSendMessage();

                // Restore classic input
                if (classicInput) {
                    classicInput.value = originalValue || '';
                }

                // Get the last assistant response from chatState and show in Command Frame
                const lastResponse = chatState.conversationHistory
                    .filter(m => m.role === 'assistant')
                    .pop();

                if (lastResponse) {
                    addCommandMessage(lastResponse.content, 'assistant');
                }

            } catch (error) {
                console.error('Command processing error:', error);
                addCommandMessage('Sorry, something went wrong. Please try again.', 'assistant');
            } finally {
                if (sendBtn) {
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'âž¤';
                }
            }
        }

        // BUILD 393: Wire up Command Frame action buttons
        function initCommandFrameButtons() {
            document.querySelectorAll('#command-frame .cmd-btn[data-action]').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const action = btn.dataset.action;

                    // Handle prompt actions (prefill input)
                    if (action.startsWith('prompt_')) {
                        const input = document.getElementById('command-input');
                        const prompts = {
                            'prompt_find': 'find ',
                            'prompt_add': 'add '
                        };
                        if (input) {
                            input.value = prompts[action] || '';
                            input.focus();
                            input.setSelectionRange(input.value.length, input.value.length);
                        }
                    } else {
                        // Execute action via existing COMMAND_REGISTRY
                        await executeAction(action);
                    }
                });
            });

            // Mode pill clicks
            document.querySelectorAll('#command-frame .mode-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    document.querySelectorAll('#command-frame .mode-pill').forEach(p => p.classList.remove('active'));
                    pill.classList.add('active');

                    const mode = pill.dataset.mode;
                    if (mode === 'deep') {
                        chatState.conversationMode = true;
                        showToast('Deep Conversation mode - full AI intelligence', 'info');
                    } else {
                        chatState.conversationMode = false;
                        showToast('Quick mode - fast commands', 'info');
                    }
                });
            });

            // Enter key to send
            document.getElementById('command-input')?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleCommandSend();
                }
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 394: Context-Aware Action Button Generator
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const actionButtonGenerator = {
            // Universal buttons - always available
            universal: [
                { icon: 'ðŸ”', label: 'Find', action: 'prompt_find' },
                { icon: 'âž•', label: 'Add', action: 'prompt_add' },
                { icon: 'âœ¨', label: 'Enhance', action: 'ai_enhance' },
                { icon: 'ðŸ“–', label: 'Help', action: 'show_help' }
            ],

            // Node-focused buttons - show when a node is selected
            nodeFocused: [
                { icon: 'âœï¸', label: 'Edit', action: 'edit_node' },
                { icon: 'ðŸ§ ', label: 'Deep Dive', action: 'deep_dive' },
                { icon: 'ðŸ“Š', label: 'Expand', action: 'expand_node' },
                { icon: 'ðŸ’¡', label: 'Insight', action: 'quick_insight' }
            ],

            // Multi-select buttons - show when 2+ nodes selected
            multiSelect: [
                { icon: 'ðŸ”—', label: 'Hyperedge', action: 'create_hyperedge' },
                { icon: 'ðŸ”¬', label: 'Compare', action: 'compare_nodes' },
                { icon: 'ðŸŽ¯', label: 'Group', action: 'smart_hyperedge' }
            ],

            // Pattern-specific buttons
            patternSpecific: {
                lifetree: [
                    { icon: 'ðŸ“…', label: 'Add Event', action: 'prompt_add_event' },
                    { icon: 'ðŸŽ‚', label: 'Birthday', action: 'birthday_method' },
                    { icon: 'ðŸ©º', label: 'Health Check', action: 'lifetree_health_check' }
                ],
                philosophy: [
                    { icon: 'âš”ï¸', label: 'Refute', action: 'refute_thesis' },
                    { icon: 'ðŸ’¬', label: 'Dialogue', action: 'generate_dialogue' },
                    { icon: 'ðŸ”', label: 'Analyze', action: 'analyze_argument' }
                ],
                sales: [
                    { icon: 'ðŸ“ž', label: 'Follow-up', action: 'generate_followup' },
                    { icon: 'ðŸ’°', label: 'Qualify', action: 'qualify_lead' },
                    { icon: 'ðŸ“ˆ', label: 'Pipeline', action: 'show_pipeline' }
                ],
                capex: [
                    { icon: 'ðŸ’µ', label: 'ROI', action: 'calculate_roi' },
                    { icon: 'ðŸ“Š', label: 'Budget', action: 'show_budget' },
                    { icon: 'âš ï¸', label: 'Risks', action: 'analyze_risks' }
                ]
            },

            /**
             * Get appropriate buttons based on current context
             * @returns {Object} { primary: [], secondary: [] }
             */
            getButtonsForContext() {
                const context = this.detectContext();
                const primary = [...this.universal];
                const secondary = [];

                // Add node-focused buttons if a node is selected
                if (context.hasActiveNode) {
                    secondary.push(...this.nodeFocused);
                }

                // Add multi-select buttons if 2+ nodes selected
                if (context.multiSelectCount >= 2) {
                    secondary.push(...this.multiSelect);
                }

                // Add pattern-specific buttons
                const patternButtons = this.patternSpecific[context.pattern] || [];
                if (patternButtons.length > 0) {
                    secondary.push(...patternButtons);
                }

                return { primary, secondary, context };
            },

            /**
             * Detect current UI context
             */
            detectContext() {
                return {
                    hasActiveNode: typeof activeNode !== 'undefined' && activeNode !== null,
                    activeNodeName: activeNode?.name || null,
                    activeNodeType: activeNode?.type || null,
                    multiSelectCount: typeof selectedNodes !== 'undefined' ? selectedNodes.length : 0,
                    pattern: typeof currentPattern !== 'undefined' ? currentPattern : 'generic',
                    isCanvasView: document.getElementById('canvas-container')?.classList.contains('active') || false
                };
            }
        };

        /**
         * Refresh action buttons based on current context
         */
        function refreshActionButtons() {
            const secondaryRow = document.querySelector('#command-frame .secondary-actions');
            if (!secondaryRow) return;

            const { primary, secondary, context } = actionButtonGenerator.getButtonsForContext();

            // Clear and populate secondary row
            secondaryRow.innerHTML = '';

            if (secondary.length > 0) {
                secondary.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = 'cmd-btn';
                    button.dataset.action = btn.action;
                    button.innerHTML = `<span class="btn-icon">${btn.icon}</span><span class="btn-label">${btn.label}</span>`;
                    button.addEventListener('click', async () => {
                        if (btn.action.startsWith('prompt_')) {
                            const input = document.getElementById('command-input');
                            const prompts = {
                                'prompt_find': 'find ',
                                'prompt_add': 'add ',
                                'prompt_add_event': 'add event: '
                            };
                            if (input) {
                                input.value = prompts[btn.action] || '';
                                input.focus();
                            }
                        } else {
                            await executeAction(btn.action);
                            refreshActionButtons(); // Refresh after action
                        }
                    });
                    secondaryRow.appendChild(button);
                });
                secondaryRow.classList.remove('collapsed');
            } else {
                secondaryRow.classList.add('collapsed');
            }

            // Update context bar
            updateContextBar(context);
        }

        /**
         * Update the context bar with current node info
         */
        function updateContextBar(context) {
            const contextBar = document.querySelector('#command-frame .command-context-bar');
            if (!contextBar) return;

            const contextIcon = contextBar.querySelector('.context-icon');
            const contextText = contextBar.querySelector('.context-text');
            const infoBtn = contextBar.querySelector('.context-action');

            if (context.hasActiveNode) {
                contextBar.classList.remove('no-focus');

                // Build breadcrumb path
                let path = '';
                if (activeNode) {
                    const parent = findParentOfNode(activeNode, capexTree);
                    if (parent && parent.name) {
                        path = `${parent.name} > `;
                    }
                    path += activeNode.name || 'Unnamed';
                }

                // Set icon based on node type
                const typeIcons = {
                    'phase': 'ðŸ“',
                    'item': 'ðŸ“„',
                    'subtask': 'ðŸ“Œ',
                    'root': 'ðŸŒ³'
                };
                contextIcon.textContent = typeIcons[context.activeNodeType] || 'ðŸ“';
                contextText.textContent = path || context.activeNodeName || 'Selected node';
                contextText.title = `Type: ${context.activeNodeType || 'unknown'}`;

                if (infoBtn) {
                    infoBtn.style.display = 'inline-flex';
                }
            } else if (context.multiSelectCount >= 2) {
                contextBar.classList.remove('no-focus');
                contextIcon.textContent = 'ðŸ”¢';
                contextText.textContent = `${context.multiSelectCount} nodes selected`;
                if (infoBtn) infoBtn.style.display = 'none';
            } else {
                contextBar.classList.add('no-focus');
                contextIcon.textContent = 'ðŸ“';
                contextText.textContent = 'No node focused â€” use Find or click a node';
                if (infoBtn) infoBtn.style.display = 'none';
            }
        }

        /**
         * Helper: Find parent node of a given node
         */
        function findParentOfNode(targetNode, tree, parent = null) {
            if (!tree) return null;
            if (tree === targetNode) return parent;

            // Check children
            if (tree.children) {
                for (const child of tree.children) {
                    if (child === targetNode) return tree;
                    const found = findParentOfNode(targetNode, child, tree);
                    if (found) return found;
                }
            }

            // Check items
            if (tree.items) {
                for (const item of tree.items) {
                    if (item === targetNode) return tree;
                    const found = findParentOfNode(targetNode, item, tree);
                    if (found) return found;
                }
            }

            // Check subtasks
            if (tree.subtasks) {
                for (const subtask of tree.subtasks) {
                    if (subtask === targetNode) return tree;
                    const found = findParentOfNode(targetNode, subtask, tree);
                    if (found) return found;
                }
            }

            return null;
        }

        // Hook into node selection events to refresh buttons
        function hookNodeSelection() {
            // Override or wrap existing click handlers
            // This will be called when nodes are clicked in tree/canvas view
            const origRender = window.render;
            if (typeof origRender === 'function') {
                window.render = function(...args) {
                    origRender.apply(this, args);
                    // After render, attach click listeners that trigger refresh
                    setTimeout(() => attachNodeClickListeners(), 50);
                };
            }
        }

        function attachNodeClickListeners() {
            // Tree view nodes
            document.querySelectorAll('.tree-node').forEach(node => {
                if (!node._commandFrameHooked) {
                    node._commandFrameHooked = true;
                    node.addEventListener('click', () => {
                        setTimeout(refreshActionButtons, 10);
                    });
                }
            });

            // Canvas view nodes
            document.querySelectorAll('.canvas-node').forEach(node => {
                if (!node._commandFrameHooked) {
                    node._commandFrameHooked = true;
                    node.addEventListener('click', () => {
                        setTimeout(refreshActionButtons, 10);
                    });
                }
            });
        }

        // Initialize button refresh system
        function initActionButtonRefresh() {
            // Refresh when frame opens
            const origToggleCommandFrame = window.toggleCommandFrame;
            if (typeof origToggleCommandFrame === 'function') {
                window.toggleCommandFrame = function() {
                    origToggleCommandFrame();
                    if (chatState.isOpen) {
                        refreshActionButtons();
                    }
                };
            }

            // Initial hook
            hookNodeSelection();
            attachNodeClickListeners();

            // Periodic check for stale context (every 2 seconds when open)
            setInterval(() => {
                if (chatState.isOpen && window.useNewChatUI) {
                    refreshActionButtons();
                }
            }, 2000);
        }

        // Call during DOMContentLoaded
        document.addEventListener('DOMContentLoaded', initActionButtonRefresh);

        // Expose globally for other modules
        window.refreshActionButtons = refreshActionButtons;
        window.updateContextBar = updateContextBar;
        window.actionButtonGenerator = actionButtonGenerator;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 395: Visual Feedback System
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const visualFeedback = {
            // Feedback types with colors and icons
            types: {
                found: { color: 'rgba(34, 197, 94, 0.4)', border: '#22c55e', icon: 'ðŸ”', label: 'Found' },
                added: { color: 'rgba(59, 130, 246, 0.4)', border: '#3b82f6', icon: 'âž•', label: 'New' },
                edited: { color: 'rgba(249, 115, 22, 0.4)', border: '#f97316', icon: 'âœï¸', label: 'Edited' },
                enhanced: { color: 'rgba(168, 85, 247, 0.4)', border: '#a855f7', icon: 'âœ¨', label: 'Enhanced' },
                deleted: { color: 'rgba(239, 68, 68, 0.4)', border: '#ef4444', icon: 'ðŸ—‘ï¸', label: 'Deleted' },
                focused: { color: 'rgba(99, 102, 241, 0.4)', border: '#6366f1', icon: 'ðŸ“', label: 'Focused' }
            },

            // Active overlays (for cleanup)
            activeOverlays: [],

            /**
             * Highlight a node with visual feedback
             * @param {string} nodeId - ID of the node to highlight
             * @param {string} type - Feedback type (found, added, edited, enhanced, deleted, focused)
             * @param {number} duration - How long to show (ms), 0 = permanent until clear
             */
            highlight(nodeId, type = 'found', duration = 3000) {
                const feedback = this.types[type] || this.types.found;
                const isCanvasView = document.getElementById('canvas-container')?.classList.contains('active');

                if (isCanvasView) {
                    this.highlightCanvasNode(nodeId, feedback, duration);
                } else {
                    this.highlightTreeNode(nodeId, feedback, duration);
                }
            },

            /**
             * Highlight node in tree view
             */
            highlightTreeNode(nodeId, feedback, duration) {
                // Try multiple selectors
                const selectors = [
                    `[data-item-id="${nodeId}"]`,
                    `[data-node-id="${nodeId}"]`,
                    `[data-id="${nodeId}"]`
                ];

                let nodeEl = null;
                for (const selector of selectors) {
                    nodeEl = document.querySelector(selector);
                    if (nodeEl) break;
                }

                if (!nodeEl) return;

                // Scroll into view
                nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'vf-overlay vf-pulse';
                overlay.style.cssText = `
                    position: absolute;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: ${feedback.color};
                    border: 2px solid ${feedback.border};
                    border-radius: 8px;
                    pointer-events: none;
                    z-index: 100;
                `;

                // Create label badge
                const badge = document.createElement('div');
                badge.className = 'vf-badge';
                badge.style.cssText = `
                    position: absolute;
                    top: -8px; right: -8px;
                    background: ${feedback.border};
                    color: white;
                    padding: 2px 8px;
                    border-radius: 12px;
                    font-size: 11px;
                    font-weight: 600;
                    white-space: nowrap;
                    z-index: 101;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                `;
                badge.innerHTML = `${feedback.icon} ${feedback.label}`;

                // Ensure parent is positioned
                const originalPosition = nodeEl.style.position;
                if (!originalPosition || originalPosition === 'static') {
                    nodeEl.style.position = 'relative';
                }

                nodeEl.appendChild(overlay);
                nodeEl.appendChild(badge);
                this.activeOverlays.push({ overlay, badge, nodeEl, originalPosition });

                // Auto-remove after duration
                if (duration > 0) {
                    setTimeout(() => {
                        this.removeOverlay(overlay, badge, nodeEl, originalPosition);
                    }, duration);
                }
            },

            /**
             * Highlight node in canvas view
             */
            highlightCanvasNode(nodeId, feedback, duration) {
                const nodeEl = document.querySelector(`.canvas-node[data-node-id="${nodeId}"]`);
                if (!nodeEl) return;

                // Pan to node if needed
                const rect = nodeEl.getBoundingClientRect();
                const container = document.getElementById('canvas-container');
                if (container) {
                    const containerRect = container.getBoundingClientRect();
                    if (rect.left < containerRect.left || rect.right > containerRect.right ||
                        rect.top < containerRect.top || rect.bottom > containerRect.bottom) {
                        nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                    }
                }

                // Apply glow effect
                const originalBoxShadow = nodeEl.style.boxShadow;
                const originalBorder = nodeEl.style.border;

                nodeEl.style.boxShadow = `0 0 20px ${feedback.border}, 0 0 40px ${feedback.color}`;
                nodeEl.style.border = `3px solid ${feedback.border}`;
                nodeEl.classList.add('vf-pulse');

                // Create floating badge
                const badge = document.createElement('div');
                badge.className = 'vf-canvas-badge';
                badge.style.cssText = `
                    position: absolute;
                    top: -24px; left: 50%;
                    transform: translateX(-50%);
                    background: ${feedback.border};
                    color: white;
                    padding: 2px 10px;
                    border-radius: 12px;
                    font-size: 12px;
                    font-weight: 600;
                    white-space: nowrap;
                    z-index: 1000;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
                    animation: vfBadgeFloat 0.5s ease-out;
                `;
                badge.innerHTML = `${feedback.icon} ${feedback.label}`;
                nodeEl.style.position = 'relative';
                nodeEl.appendChild(badge);

                this.activeOverlays.push({
                    nodeEl,
                    badge,
                    originalBoxShadow,
                    originalBorder,
                    isCanvas: true
                });

                // Auto-remove after duration
                if (duration > 0) {
                    setTimeout(() => {
                        nodeEl.style.boxShadow = originalBoxShadow || '';
                        nodeEl.style.border = originalBorder || '';
                        nodeEl.classList.remove('vf-pulse');
                        badge.remove();
                    }, duration);
                }
            },

            /**
             * Highlight multiple nodes
             */
            highlightMultiple(nodeIds, type = 'found', duration = 3000, stagger = 100) {
                nodeIds.forEach((id, index) => {
                    setTimeout(() => {
                        this.highlight(id, type, duration);
                    }, index * stagger);
                });
            },

            /**
             * Show a connection line between nodes (for hyperedge visualization)
             */
            showConnection(fromId, toId, color = 'rgba(139, 92, 246, 0.6)', duration = 3000) {
                const container = document.getElementById('canvas-container');
                if (!container?.classList.contains('active')) return;

                const fromEl = document.querySelector(`.canvas-node[data-node-id="${fromId}"]`);
                const toEl = document.querySelector(`.canvas-node[data-node-id="${toId}"]`);
                if (!fromEl || !toEl) return;

                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();

                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.style.cssText = `
                    position: fixed;
                    top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none;
                    z-index: 999;
                `;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromRect.left + fromRect.width / 2);
                line.setAttribute('y1', fromRect.top + fromRect.height / 2);
                line.setAttribute('x2', toRect.left + toRect.width / 2);
                line.setAttribute('y2', toRect.top + toRect.height / 2);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', '3');
                line.setAttribute('stroke-dasharray', '8,4');
                line.style.animation = 'vfLineDash 0.5s linear infinite';

                svg.appendChild(line);
                document.body.appendChild(svg);

                if (duration > 0) {
                    setTimeout(() => svg.remove(), duration);
                }

                return svg;
            },

            /**
             * Clear all visual feedback
             */
            clearAll() {
                this.activeOverlays.forEach(item => {
                    if (item.isCanvas) {
                        item.nodeEl.style.boxShadow = item.originalBoxShadow || '';
                        item.nodeEl.style.border = item.originalBorder || '';
                        item.nodeEl.classList.remove('vf-pulse');
                        item.badge?.remove();
                    } else {
                        this.removeOverlay(item.overlay, item.badge, item.nodeEl, item.originalPosition);
                    }
                });
                this.activeOverlays = [];

                // Remove any connection lines
                document.querySelectorAll('svg[style*="pointer-events: none"]').forEach(svg => svg.remove());
            },

            /**
             * Remove a specific overlay
             */
            removeOverlay(overlay, badge, nodeEl, originalPosition) {
                overlay?.remove();
                badge?.remove();
                if (nodeEl && originalPosition !== undefined) {
                    nodeEl.style.position = originalPosition || '';
                }
            },

            /**
             * Flash feedback (quick pulse without label)
             */
            flash(nodeId, type = 'focused', count = 2) {
                const feedback = this.types[type] || this.types.focused;
                const isCanvasView = document.getElementById('canvas-container')?.classList.contains('active');

                const selectors = isCanvasView
                    ? [`.canvas-node[data-node-id="${nodeId}"]`]
                    : [`[data-item-id="${nodeId}"]`, `[data-node-id="${nodeId}"]`];

                let nodeEl = null;
                for (const selector of selectors) {
                    nodeEl = document.querySelector(selector);
                    if (nodeEl) break;
                }

                if (!nodeEl) return;

                let flashCount = 0;
                const interval = setInterval(() => {
                    nodeEl.style.boxShadow = flashCount % 2 === 0
                        ? `0 0 15px ${feedback.border}, inset 0 0 10px ${feedback.color}`
                        : '';
                    flashCount++;
                    if (flashCount >= count * 2) {
                        clearInterval(interval);
                        nodeEl.style.boxShadow = '';
                    }
                }, 200);
            }
        };

        // Expose globally
        window.visualFeedback = visualFeedback;

        function addMessage(content, type = 'assistant', buttons = null) {
            const messagesContainer = document.getElementById('chat-assistant-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${type}`;

            // Handle markdown-like formatting
            let formattedContent = content
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            messageDiv.innerHTML = formattedContent;

            // Add action buttons if provided
            if (buttons && buttons.length > 0) {
                const btnContainer = document.createElement('div');
                btnContainer.className = 'action-buttons';
                buttons.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = 'action-btn';
                    button.textContent = btn.label;
                    button.onclick = () => executeAction(btn.action, btn.param);
                    btnContainer.appendChild(button);
                });
                messageDiv.appendChild(btnContainer);
            }

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Store in history
            chatState.conversationHistory.push({ role: type, content });

            // BUILD 355: Persist conversation memory
            saveConversationMemory();
        }

        function showTypingIndicator() {
            const messagesContainer = document.getElementById('chat-assistant-messages');
            const typing = document.createElement('div');
            typing.className = 'chat-typing';
            typing.id = 'typing-indicator';
            typing.innerHTML = '<span></span><span></span><span></span>';
            messagesContainer.appendChild(typing);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideTypingIndicator() {
            document.getElementById('typing-indicator')?.remove();
        }

        async function executeAction(actionName, param = null) {
            // BUILD 255: Handle compound actions like "enter_playground:claude-sonnet"
            let commandName = actionName;
            let commandParam = param;

            if (actionName.includes(':') && !param) {
                const parts = actionName.split(':');
                commandName = parts[0];
                commandParam = parts.slice(1).join(':'); // Rejoin in case value has colons
            }

            const command = COMMAND_REGISTRY[commandName];
            if (command) {
                try {
                    const result = await command(commandParam);
                    if (result) {
                        // BUILD 309: Support commands returning {message, buttons}
                        if (typeof result === 'object' && result.message) {
                            addMessage(result.message, 'assistant', result.buttons || null);
                        } else {
                            addMessage(result, 'assistant');
                        }
                    }
                } catch (error) {
                    addMessage(`âŒ Error: ${error.message}`, 'error');
                }
            } else {
                addMessage(`âŒ Unknown action: ${commandName}`, 'error');
            }
        }

        async function handleSendMessage() {
            const input = document.getElementById('chat-assistant-input');
            const message = input.value.trim();

            if (!message || chatState.isProcessing) return;

            // Clear input
            input.value = '';
            input.style.height = 'auto';

            // BUILD 366: Detect and update biographer mode for LifeTree
            if (typeof currentPattern !== 'undefined' && currentPattern === 'lifetree') {
                const detectedMode = detectBiographerMode(message);
                updateBiographerModeIndicator(detectedMode);
            } else {
                updateBiographerModeIndicator(null);
            }

            // Add user message
            addMessage(message, 'user');

            // Show typing indicator
            chatState.isProcessing = true;
            showTypingIndicator();

            try {
                // BUILD 255: Check for Playground Mode
                if (chatState.playgroundMode) {
                    // Check for exit command
                    if (message.toLowerCase().includes('exit playground') || message.toLowerCase() === 'exit') {
                        hideTypingIndicator();
                        const exitResult = await COMMAND_REGISTRY['exit_playground']();
                        addMessage(exitResult, 'assistant');
                        chatState.isProcessing = false;
                        return;
                    }

                    // Route to playground handler
                    const response = await handlePlaygroundMessage(message);
                    hideTypingIndicator();
                    addMessage(response, 'assistant');
                    chatState.isProcessing = false;
                    return;
                }

                // Check for "improve prompt:" pattern BEFORE AI interpretation
                const improveMatch = message.match(/^(?:improve|enhance|optimize|refine)\s+(?:this\s+)?(?:prompt|my prompt)?[:\s]+(.+)$/is);
                if (improveMatch) {
                    const promptToImprove = improveMatch[1].trim();

                    try {
                        const result = await COMMAND_REGISTRY['improve_prompt'](promptToImprove);
                        hideTypingIndicator();

                        if (result) {
                            // Error message
                            addMessage(result, 'assistant');
                        } else if (chatState.improvedPrompt) {
                            // Success - show improved prompt with action buttons
                            const preview = chatState.improvedPrompt.full.length > 500
                                ? chatState.improvedPrompt.full.substring(0, 500) + '...'
                                : chatState.improvedPrompt.full;

                            const successMsg = `âœ¨ **Prompt Improved!**\n\n**${chatState.improvedPrompt.name}**\n\n\`\`\`\n${preview}\n\`\`\`\n\nWhat would you like to do?`;

                            // Add message with action buttons
                            addMessage(successMsg, 'assistant', [
                                { label: 'ðŸŸ£ Try with Claude', action: 'enter_playground:claude-sonnet' },
                                { label: 'ðŸŸ¢ Try with GPT-4', action: 'enter_playground:gpt-4o' },
                                { label: 'ðŸ”µ Try with Gemini', action: 'enter_playground:gemini-pro' },
                                { label: 'ðŸ“‹ Copy', action: 'copy_prompt' },
                                { label: 'ðŸ’¾ Save', action: 'save_prompt' }
                            ]);
                        }
                    } catch (err) {
                        hideTypingIndicator();
                        addMessage(`âŒ Failed to improve prompt: ${err.message}`, 'error');
                    }
                    chatState.isProcessing = false;
                    return;
                }

                // BUILD 361: Hyperedge query detection
                const hyperedgeQueryResult = detectHyperedgeQuery(message);
                if (hyperedgeQueryResult) {
                    hideTypingIndicator();
                    const { matches, description, queryConditions } = hyperedgeQueryResult;

                    if (matches.length === 0) {
                        addMessage(`ðŸ” No items found matching "${description}". Try a different query or use the Query Builder (ðŸ”— Hyperedges â†’ ðŸ” Query).`, 'assistant');
                    } else if (matches.length === 1) {
                        addMessage(`ðŸ” Found 1 item matching "${description}": **${matches[0].name}**\n\nNeed at least 2 items to create a hyperedge.`, 'assistant');
                    } else {
                        // Format matches for display
                        const matchList = matches.slice(0, 5).map(m => `â€¢ ${m.name}`).join('\n');
                        const moreText = matches.length > 5 ? `\n...and ${matches.length - 5} more` : '';

                        // Calculate aggregates if available
                        const totalCost = matches.reduce((sum, m) => sum + (m.cost || 0), 0);
                        const costStr = totalCost > 0
                            ? `\nðŸ’° Total: ${totalCost >= 1000000 ? '$' + (totalCost/1000000).toFixed(1) + 'M' : '$' + (totalCost/1000).toFixed(0) + 'K'}`
                            : '';

                        addMessage(
                            `ðŸ” Found **${matches.length} items** matching "${description}":${costStr}\n\n${matchList}${moreText}\n\nCreate a hyperedge to visualize them?`,
                            'assistant',
                            [
                                { label: 'âœ“ Create Hyperedge', action: `create_hyperedge_from_query:${JSON.stringify(queryConditions)}` },
                                { label: 'ðŸŽ¯ Highlight in Canvas', action: 'highlight_query_results' }
                            ]
                        );

                        // Store matches for later use
                        chatState.lastQueryMatches = matches;
                        chatState.lastQueryDescription = description;
                        chatState.lastQueryConditions = queryConditions;
                    }
                    chatState.isProcessing = false;
                    return;
                }

                // BUILD 368: Smart mode detection - conversation vs command
                const interactionMode = chatState.conversationMode ? 'conversation' : detectInteractionMode(message);

                let result;
                if (interactionMode === 'conversation') {
                    // Use full AI conversation mode
                    result = await handleConversation(message);
                } else {
                    // Use quick command interpretation
                    result = await interpretCommand(message);
                }

                hideTypingIndicator();

                // Add assistant response
                addMessage(result.message, 'assistant', result.buttons);

                // BUILD 383: Execute ALL actions for real-time saves (navigate + add in one go)
                if (result.actions && result.actions.length > 0) {
                    // Execute actions sequentially for proper ordering (navigate THEN add)
                    for (const act of result.actions) {
                        await executeAction(act.action, act.actionParam);
                    }
                } else if (result.action) {
                    // Fallback for single action (backwards compatibility)
                    await executeAction(result.action, result.actionParam);
                }
            } catch (error) {
                hideTypingIndicator();
                addMessage(`âŒ Sorry, something went wrong: ${error.message}`, 'error');
            } finally {
                chatState.isProcessing = false;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VOICE INPUT (Web Speech API) - Build 258 Fix
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initVoiceInput() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('Voice input not supported');
                document.getElementById('chat-voice-btn')?.style.setProperty('display', 'none');
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            chatState.voiceRecognition = new SpeechRecognition();
            chatState.voiceRecognition.continuous = true;  // BUILD 258: Keep listening
            chatState.voiceRecognition.interimResults = true;  // BUILD 258: Show text as speaking
            chatState.voiceRecognition.lang = 'en-US';
            chatState.voiceInterimText = '';
            chatState.voiceFinalText = '';

            chatState.voiceRecognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                // Process all results
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // Update accumulated final text
                if (finalTranscript) {
                    chatState.voiceFinalText += finalTranscript + ' ';
                }

                // Show interim results in input box
                const inputEl = document.getElementById('chat-assistant-input');
                if (inputEl) {
                    inputEl.value = chatState.voiceFinalText + interimTranscript;
                    // Show visual feedback
                    inputEl.style.borderColor = '#10b981';
                }

                console.log('Voice interim:', interimTranscript, 'Final:', finalTranscript);
            };

            chatState.voiceRecognition.onerror = (event) => {
                console.error('Voice error:', event.error);
                stopVoiceRecording();

                // BUILD 258: Better error messages
                if (event.error === 'not-allowed') {
                    addMessage('ðŸŽ¤ Microphone access denied. Please allow microphone in browser settings and try again.', 'error');
                } else if (event.error === 'no-speech') {
                    addMessage('ðŸŽ¤ No speech detected. Please speak louder or check your microphone.', 'system');
                } else if (event.error === 'network') {
                    addMessage('ðŸŽ¤ Network error. Voice recognition requires internet connection.', 'error');
                } else if (event.error !== 'aborted') {
                    addMessage(`ðŸŽ¤ Voice error: ${event.error}`, 'error');
                }
            };

            chatState.voiceRecognition.onend = () => {
                // BUILD 258: Auto-send if we have text
                const finalText = chatState.voiceFinalText.trim();
                if (finalText && chatState.isRecording) {
                    document.getElementById('chat-assistant-input').value = finalText;
                    stopVoiceRecording();
                    handleSendMessage();
                } else {
                    stopVoiceRecording();
                }
            };

            chatState.voiceRecognition.onaudiostart = () => {
                console.log('ðŸŽ¤ Audio capture started');
            };

            chatState.voiceRecognition.onspeechstart = () => {
                console.log('ðŸŽ¤ Speech detected');
            };
        }

        // BUILD 356: Track microphone permission state
        let micPermissionGranted = false;

        // BUILD 356: Check if permission was already granted (HTTPS only)
        async function checkExistingMicPermission() {
            try {
                if (navigator.permissions) {
                    const result = await navigator.permissions.query({ name: 'microphone' });
                    if (result.state === 'granted') {
                        micPermissionGranted = true;
                        console.log('ðŸŽ¤ Microphone permission already granted');
                    }
                    // Listen for permission changes
                    result.onchange = () => {
                        micPermissionGranted = result.state === 'granted';
                        console.log('ðŸŽ¤ Microphone permission changed to:', result.state);
                    };
                }
            } catch (e) {
                // Permissions API not supported or microphone query not allowed
                console.log('ðŸŽ¤ Cannot query microphone permission:', e.message);
            }
        }

        // Run permission check on load
        checkExistingMicPermission();

        async function requestMicrophonePermission() {
            // Check if we're on file:// protocol
            const isFileProtocol = window.location.protocol === 'file:';

            try {
                // Try to get microphone access
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                // Stop the stream immediately - we just needed to get permission
                stream.getTracks().forEach(track => track.stop());
                micPermissionGranted = true;

                if (isFileProtocol) {
                    console.log('ðŸŽ¤ Mic permission granted (file:// - will not persist)');
                } else {
                    console.log('ðŸŽ¤ Mic permission granted and persisted');
                }
                return true;
            } catch (err) {
                console.error('ðŸŽ¤ Mic permission denied:', err);
                if (err.name === 'NotAllowedError') {
                    addMessage('ðŸŽ¤ Microphone access denied. Click the lock icon in your browser address bar to allow microphone access.', 'error');
                } else {
                    addMessage(`ðŸŽ¤ Could not access microphone: ${err.message}`, 'error');
                }
                return false;
            }
        }

        async function startVoiceRecording() {
            if (!chatState.voiceRecognition) {
                addMessage('ðŸŽ¤ Voice input not available. Please use Chrome, Edge, or Safari.', 'error');
                return;
            }

            // Prevent double-start
            if (chatState.isRecording) return;

            // BUILD 356: Request permission first if not already granted
            if (!micPermissionGranted) {
                const granted = await requestMicrophonePermission();
                if (!granted) return;
            }

            chatState.isRecording = true;
            chatState.voiceFinalText = '';
            chatState.voiceInterimText = '';
            document.getElementById('chat-voice-btn')?.classList.add('recording');

            // Reset input styling
            const inputEl = document.getElementById('chat-assistant-input');
            if (inputEl) {
                inputEl.value = '';
                inputEl.placeholder = 'ðŸŽ¤ Listening... speak now';
            }

            try {
                chatState.voiceRecognition.start();
                console.log('ðŸŽ¤ Voice recording started');
            } catch (e) {
                console.error('Voice start error:', e);
                if (e.message.includes('already started')) {
                    // Already recording, ignore
                } else {
                    addMessage('ðŸŽ¤ Could not start voice recording. Please try again.', 'error');
                    stopVoiceRecording();
                }
            }
        }

        function stopVoiceRecording() {
            if (!chatState.isRecording) return;

            chatState.isRecording = false;
            document.getElementById('chat-voice-btn')?.classList.remove('recording');

            // Reset input styling
            const inputEl = document.getElementById('chat-assistant-input');
            if (inputEl) {
                inputEl.style.borderColor = '';
                inputEl.placeholder = 'Ask anything or give a command...';
            }

            try {
                chatState.voiceRecognition?.stop();
                console.log('ðŸŽ¤ Voice recording stopped');
            } catch (e) {
                // Ignore stop errors
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initChatAssistant() {
            // Toggle button (opens either classic panel or Command Frame based on preference)
            document.getElementById('chat-assistant-bubble')?.addEventListener('click', toggleChatPanel);

            // Classic panel: Close button
            document.getElementById('chat-close-btn')?.addEventListener('click', toggleChatPanel);

            // BUILD 393: Initialize Command Frame
            initCommandFrameButtons();

            // Clear button
            document.getElementById('chat-clear-btn')?.addEventListener('click', () => {
                const messages = document.getElementById('chat-assistant-messages');
                messages.innerHTML = `
                    <div class="chat-message assistant">
                        Chat cleared! How can I help you?
                        <div class="action-buttons" style="margin-top: 8px;">
                            <button class="action-btn" data-action="help">ðŸ“– Learn features</button>
                            <button class="action-btn" data-action="create">ðŸŒ³ Create a project</button>
                        </div>
                    </div>
                `;
                chatState.conversationHistory = [];
                // BUILD 355: Clear persisted memory too
                localStorage.removeItem('treebeardConversation');
            });

            // Send button
            document.getElementById('chat-send-btn')?.addEventListener('click', handleSendMessage);

            // Input - Enter to send, Shift+Enter for newline
            const input = document.getElementById('chat-assistant-input');
            input?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            });

            // Auto-resize textarea
            input?.addEventListener('input', () => {
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, 100) + 'px';
            });

            // Voice button - BUILD 258: Added touch support for mobile
            const voiceBtn = document.getElementById('chat-voice-btn');
            if (voiceBtn) {
                // Desktop: hold to record
                voiceBtn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    startVoiceRecording();
                });
                voiceBtn.addEventListener('mouseup', stopVoiceRecording);
                voiceBtn.addEventListener('mouseleave', stopVoiceRecording);

                // Mobile: touch hold to record
                voiceBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startVoiceRecording();
                }, { passive: false });
                voiceBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    stopVoiceRecording();
                });
                voiceBtn.addEventListener('touchcancel', stopVoiceRecording);

                // Also support single click/tap to toggle
                let clickTimeout;
                voiceBtn.addEventListener('click', (e) => {
                    // If already recording, stop
                    if (chatState.isRecording) {
                        stopVoiceRecording();
                    }
                    // Quick click also starts (will auto-stop after speech ends)
                });
            }

            // Quick action chips
            document.querySelectorAll('.quick-action-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    const prompt = chip.dataset.prompt;
                    if (prompt) {
                        document.getElementById('chat-assistant-input').value = prompt;
                        handleSendMessage();
                    }
                });
            });

            // Welcome action buttons
            document.querySelectorAll('.action-btn[data-action]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const action = btn.dataset.action;
                    if (action === 'help') {
                        executeAction('show_help');
                    } else if (action === 'create') {
                        executeAction('open_wizard');
                    } else if (action === 'enhance') {
                        addMessage('Select some items in Canvas view, then ask me to "enhance selected items"!', 'assistant');
                    } else if (action === 'query') {
                        addMessage('Try queries like:\nâ€¢ "show items over $500K"\nâ€¢ "find blocked items"\nâ€¢ "show Sarah\'s items"\n\nOr click ðŸ”— Hyperedges â†’ ðŸ” Query for the visual builder!', 'assistant');
                    }
                });
            });

            // Keyboard shortcut: Ctrl+/ to toggle
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === '/') {
                    e.preventDefault();
                    toggleChatPanel();
                }
            });

            // Initialize voice
            initVoiceInput();

            // Initialize draggable panel
            initDraggablePanel();

            // Restore saved position
            restorePanelPosition();

            // BUILD 355: Restore conversation history UI if we have previous messages
            restoreConversationUI();

            console.log('ðŸŒ³ TreeBeard initialized (Build 355 - Conversation Memory)');

            // BUILD 370: Initialize Voice Capture system
            initVoiceCaptureSystem();

            // BUILD 371: Initialize Artifact Panel
            initArtifactPanel();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 370: VOICE CAPTURE SYSTEM
        // - Voice Inbox with FAB (mobile) + TreeBeard mic entry points
        // - Live transcript recording
        // - Captures section in TreeBeard
        // - Processing flow with guided prompts
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const voiceCaptureState = {
            isRecording: false,
            recognition: null,
            finalTranscript: '',
            interimTranscript: '',
            startTime: null,
            durationTimer: null,
            warningShown: false,
            captures: [], // Per-tree captures loaded from capexTree.captures
            processingCaptureId: null
        };

        function initVoiceCaptureSystem() {
            // Load captures from tree if available
            loadCapturesFromTree();

            // FAB click handler
            const fab = document.getElementById('voice-capture-fab');
            if (fab) {
                fab.addEventListener('click', () => {
                    openTreeBeardWithVoice();
                });
            }

            // Quick action buttons in processing prompt
            document.querySelectorAll('#capture-processing-prompt .quick-action').forEach(btn => {
                btn.addEventListener('click', () => {
                    const action = btn.dataset.action;
                    handleCaptureAction(action);
                });
            });

            // Update body class when TreeBeard opens/closes
            const panel = document.getElementById('chat-assistant-panel');
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'class') {
                        if (panel.classList.contains('open')) {
                            document.body.classList.add('treebeard-open');
                            document.getElementById('chat-assistant-bubble')?.classList.add('panel-open');
                        } else {
                            document.body.classList.remove('treebeard-open');
                            document.getElementById('chat-assistant-bubble')?.classList.remove('panel-open');
                        }
                    }
                });
            });
            if (panel) {
                observer.observe(panel, { attributes: true });
            }

            // Initialize Web Speech API for voice capture
            initVoiceCaptureRecognition();

            console.log('ðŸŽ¤ Voice Capture system initialized (Build 370)');
        }

        function initVoiceCaptureRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.warn('Web Speech API not supported');
                return;
            }

            voiceCaptureState.recognition = new SpeechRecognition();
            voiceCaptureState.recognition.continuous = true;
            voiceCaptureState.recognition.interimResults = true;
            voiceCaptureState.recognition.lang = 'en-US';

            voiceCaptureState.recognition.onresult = (event) => {
                let interim = '';
                let final = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        final += transcript + ' ';
                    } else {
                        interim += transcript;
                    }
                }

                if (final) {
                    voiceCaptureState.finalTranscript += final;
                }
                voiceCaptureState.interimTranscript = interim;

                updateLiveTranscriptUI();
            };

            voiceCaptureState.recognition.onerror = (event) => {
                console.error('Voice capture error:', event.error);
                if (event.error === 'not-allowed') {
                    addMessage('ðŸŽ¤ Microphone access denied. Please allow microphone permission.', 'error');
                    cancelVoiceCapture();
                } else if (event.error === 'network') {
                    addMessage('ðŸŽ¤ Voice capture requires internet connection.', 'error');
                    cancelVoiceCapture();
                }
            };

            voiceCaptureState.recognition.onend = () => {
                // If still supposed to be recording, restart (for continuous recording)
                if (voiceCaptureState.isRecording) {
                    try {
                        voiceCaptureState.recognition.start();
                    } catch (e) {
                        // Ignore restart errors
                    }
                }
            };
        }

        function openTreeBeardWithVoice() {
            // Open TreeBeard panel
            const panel = document.getElementById('chat-assistant-panel');
            if (panel && !panel.classList.contains('open')) {
                panel.classList.add('open');
            }

            // Start voice capture
            setTimeout(() => startVoiceCapture(), 100);
        }

        window.startVoiceCapture = async function() {
            if (!voiceCaptureState.recognition) {
                addMessage('ðŸŽ¤ Voice capture not available. Please use Chrome, Edge, or Safari.', 'error');
                return;
            }

            if (voiceCaptureState.isRecording) return;

            // Check for internet connection
            if (!navigator.onLine) {
                addMessage('ðŸŽ¤ Voice capture requires internet for transcription.', 'error');
                return;
            }

            // Request microphone permission
            if (!micPermissionGranted) {
                const granted = await requestMicrophonePermission();
                if (!granted) return;
            }

            voiceCaptureState.isRecording = true;
            voiceCaptureState.finalTranscript = '';
            voiceCaptureState.interimTranscript = '';
            voiceCaptureState.startTime = Date.now();
            voiceCaptureState.warningShown = false;

            // Show recording UI
            const recordingUI = document.getElementById('voice-recording-ui');
            if (recordingUI) {
                recordingUI.classList.add('active');
            }

            // Hide captures section while recording
            const capturesSection = document.getElementById('voice-captures-section');
            if (capturesSection) {
                capturesSection.style.display = 'none';
            }

            // Update FAB if visible
            const fab = document.getElementById('voice-capture-fab');
            if (fab) {
                fab.classList.add('recording');
            }

            // Update voice button
            const voiceBtn = document.getElementById('chat-voice-btn');
            if (voiceBtn) {
                voiceBtn.classList.add('recording');
            }

            // Reset transcript display
            updateLiveTranscriptUI();

            // Start duration timer
            voiceCaptureState.durationTimer = setInterval(updateDurationDisplay, 1000);

            // Start recognition
            try {
                voiceCaptureState.recognition.start();
                console.log('ðŸŽ¤ Voice capture started');
            } catch (e) {
                console.error('Voice capture start error:', e);
                cancelVoiceCapture();
            }
        };

        window.stopVoiceCapture = function() {
            if (!voiceCaptureState.isRecording) return;

            voiceCaptureState.isRecording = false;

            // Stop recognition
            try {
                voiceCaptureState.recognition?.stop();
            } catch (e) {
                // Ignore stop errors
            }

            // Stop duration timer
            if (voiceCaptureState.durationTimer) {
                clearInterval(voiceCaptureState.durationTimer);
                voiceCaptureState.durationTimer = null;
            }

            // Hide recording UI
            const recordingUI = document.getElementById('voice-recording-ui');
            if (recordingUI) {
                recordingUI.classList.remove('active');
            }

            // Update FAB
            const fab = document.getElementById('voice-capture-fab');
            if (fab) {
                fab.classList.remove('recording');
            }

            // Update voice button
            const voiceBtn = document.getElementById('chat-voice-btn');
            if (voiceBtn) {
                voiceBtn.classList.remove('recording');
            }

            // Get final transcript
            const transcript = voiceCaptureState.finalTranscript.trim();

            if (transcript.length > 0) {
                // Create capture
                const capture = {
                    id: 'cap-' + Date.now(),
                    transcript: transcript,
                    wordCount: transcript.split(/\s+/).filter(w => w).length,
                    createdAt: new Date().toISOString(),
                    artifacts: []
                };

                // Add to captures
                voiceCaptureState.captures.push(capture);
                saveCaptureToTree();
                updateCapturesUI();

                // Show processing prompt for this capture
                showCaptureProcessingPrompt(capture);

                console.log('ðŸŽ¤ Voice capture saved:', capture.id);
            } else {
                addMessage('ðŸŽ¤ No speech detected. Please try again.', 'error');
                // Show captures section again
                updateCapturesUI();
            }
        };

        window.cancelVoiceCapture = function() {
            voiceCaptureState.isRecording = false;

            // Stop recognition
            try {
                voiceCaptureState.recognition?.stop();
            } catch (e) {
                // Ignore stop errors
            }

            // Stop duration timer
            if (voiceCaptureState.durationTimer) {
                clearInterval(voiceCaptureState.durationTimer);
                voiceCaptureState.durationTimer = null;
            }

            // Hide recording UI
            const recordingUI = document.getElementById('voice-recording-ui');
            if (recordingUI) {
                recordingUI.classList.remove('active');
            }

            // Update FAB
            const fab = document.getElementById('voice-capture-fab');
            if (fab) {
                fab.classList.remove('recording');
            }

            // Update voice button
            const voiceBtn = document.getElementById('chat-voice-btn');
            if (voiceBtn) {
                voiceBtn.classList.remove('recording');
            }

            // Show captures section again
            updateCapturesUI();

            console.log('ðŸŽ¤ Voice capture cancelled');
        };

        function updateLiveTranscriptUI() {
            const area = document.querySelector('.live-transcript-area');
            if (!area) return;

            const placeholder = area.querySelector('.live-transcript-placeholder');
            const finalSpan = area.querySelector('.final');
            const interimSpan = area.querySelector('.interim');

            const hasText = voiceCaptureState.finalTranscript || voiceCaptureState.interimTranscript;

            if (placeholder) {
                placeholder.style.display = hasText ? 'none' : 'block';
            }

            if (finalSpan) {
                finalSpan.textContent = voiceCaptureState.finalTranscript;
            }

            if (interimSpan) {
                interimSpan.textContent = voiceCaptureState.interimTranscript;
            }

            // Auto-scroll to bottom
            area.scrollTop = area.scrollHeight;
        }

        function updateDurationDisplay() {
            const elapsed = Math.floor((Date.now() - voiceCaptureState.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;

            const display = document.querySelector('.recording-duration');
            if (display) {
                display.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            // Show warning after 5 minutes
            if (elapsed >= 300 && !voiceCaptureState.warningShown) {
                voiceCaptureState.warningShown = true;
                const warning = document.querySelector('.recording-warning');
                if (warning) {
                    warning.classList.add('show');
                }
            }
        }

        function loadCapturesFromTree() {
            voiceCaptureState.captures = capexTree?.captures || [];
            updateCapturesUI();
        }

        function saveCaptureToTree() {
            if (!capexTree) return;
            capexTree.captures = voiceCaptureState.captures;
            // Save to localStorage
            if (typeof treeManager !== 'undefined') { treeManager.markAsChanged(); }
        }

        function updateCapturesUI() {
            const section = document.getElementById('voice-captures-section');
            const list = section?.querySelector('.captures-list');
            const countBadge = section?.querySelector('.capture-count');
            const fabBadge = document.querySelector('#voice-capture-fab .fab-badge');

            const captures = voiceCaptureState.captures;

            // Update count badges
            if (countBadge) {
                countBadge.textContent = captures.length;
            }
            if (fabBadge) {
                fabBadge.textContent = captures.length;
                fabBadge.style.display = captures.length > 0 ? 'flex' : 'none';
            }

            // Show/hide section
            if (section) {
                section.style.display = captures.length > 0 ? 'block' : 'none';
            }

            // Render captures list
            if (list) {
                list.innerHTML = captures.map(cap => {
                    const preview = cap.transcript.substring(0, 100) + (cap.transcript.length > 100 ? '...' : '');
                    const timeAgo = getTimeAgo(new Date(cap.createdAt));
                    return `
                        <div class="capture-item" data-id="${cap.id}" onclick="window.toggleCaptureExpand(this)">
                            <div class="capture-preview">${escapeHtml(cap.transcript)}</div>
                            <div class="capture-meta">
                                <span class="word-count">${cap.wordCount} words</span>
                                <span>${timeAgo}</span>
                            </div>
                            <div class="capture-actions">
                                <button class="capture-action-btn" onclick="event.stopPropagation(); window.processCaptureById('${cap.id}')">Process</button>
                                <button class="capture-action-btn" onclick="event.stopPropagation(); window.editCaptureById('${cap.id}')">Edit</button>
                                <button class="capture-action-btn delete" onclick="event.stopPropagation(); window.deleteCaptureById('${cap.id}')">Delete</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            // Show nudge if 3+ captures
            if (captures.length >= 3) {
                // Could show a gentle reminder in TreeBeard
            }
        }

        window.toggleCapturesSection = function() {
            const section = document.getElementById('voice-captures-section');
            if (section) {
                section.classList.toggle('collapsed');
            }
        };

        window.toggleCaptureExpand = function(element) {
            element.classList.toggle('expanded');
        };

        window.processCaptureById = function(captureId) {
            const capture = voiceCaptureState.captures.find(c => c.id === captureId);
            if (capture) {
                showCaptureProcessingPrompt(capture);
            }
        };

        window.editCaptureById = function(captureId) {
            const capture = voiceCaptureState.captures.find(c => c.id === captureId);
            if (!capture) return;

            // Simple edit via prompt
            const newText = prompt('Edit transcript:', capture.transcript);
            if (newText !== null && newText.trim()) {
                capture.transcript = newText.trim();
                capture.wordCount = newText.trim().split(/\s+/).filter(w => w).length;
                saveCaptureToTree();
                updateCapturesUI();
            }
        };

        window.deleteCaptureById = function(captureId) {
            if (!confirm('Delete this capture permanently?')) return;

            voiceCaptureState.captures = voiceCaptureState.captures.filter(c => c.id !== captureId);
            saveCaptureToTree();
            updateCapturesUI();

            // Hide processing prompt if this was the one being processed
            if (voiceCaptureState.processingCaptureId === captureId) {
                hideCaptureProcessingPrompt();
            }
        };

        function showCaptureProcessingPrompt(capture) {
            voiceCaptureState.processingCaptureId = capture.id;

            const prompt = document.getElementById('capture-processing-prompt');
            const preview = prompt?.querySelector('.transcript-preview');

            if (preview) {
                preview.textContent = capture.transcript;
            }

            if (prompt) {
                prompt.style.display = 'block';
            }

            // Focus the input for custom instruction
            const input = document.getElementById('chat-assistant-input');
            if (input) {
                input.placeholder = 'Or type custom instruction...';
                input.focus();
            }
        }

        function hideCaptureProcessingPrompt() {
            voiceCaptureState.processingCaptureId = null;

            const prompt = document.getElementById('capture-processing-prompt');
            if (prompt) {
                prompt.style.display = 'none';
            }

            const input = document.getElementById('chat-assistant-input');
            if (input) {
                input.placeholder = 'Ask anything or give a command...';
            }
        }

        function handleCaptureAction(action) {
            const captureId = voiceCaptureState.processingCaptureId;
            const capture = voiceCaptureState.captures.find(c => c.id === captureId);
            if (!capture) return;

            let instruction = '';

            switch (action) {
                case 'add-to-tree':
                    instruction = `Structure this voice capture and add it to the current tree:\n\n"${capture.transcript}"`;
                    break;
                case 'new-branch':
                    instruction = `Create a new branch/phase from this voice capture:\n\n"${capture.transcript}"`;
                    break;
                case 'save-as-note':
                    // Add as raw note directly
                    addCaptureAsRawNote(capture);
                    return;
                case 'psych-analysis':
                    // Trigger Free Speech analysis
                    instruction = `Perform psychological pattern analysis on this voice capture (like Free Speech mode):\n\n"${capture.transcript}"`;
                    break;
            }

            // Send to TreeBeard
            if (instruction) {
                const input = document.getElementById('chat-assistant-input');
                if (input) {
                    input.value = instruction;
                }
                handleSendMessage();

                // Remove the capture after processing
                removeCaptureAfterProcessing(captureId);
            }
        }

        function addCaptureAsRawNote(capture) {
            // Find or create a "Voice Notes" phase
            let notesPhase = capexTree.children.find(p => p.name === 'Voice Notes');
            if (!notesPhase) {
                notesPhase = {
                    id: 'phase-voice-notes-' + Date.now(),
                    name: 'Voice Notes',
                    type: 'phase',
                    items: []
                };
                capexTree.children.push(notesPhase);
            }

            // Add the capture as an item
            const noteItem = {
                id: 'item-' + Date.now(),
                name: capture.transcript.substring(0, 60) + (capture.transcript.length > 60 ? '...' : ''),
                type: 'item',
                description: capture.transcript,
                raw_transcript: capture.transcript,
                capture_mode: 'voice',
                createdAt: capture.createdAt
            };

            notesPhase.items = notesPhase.items || [];
            notesPhase.items.push(noteItem);

            // Save and render
            saveState('Added voice note');
            render();
            if (typeof treeManager !== 'undefined') { treeManager.markAsChanged(); }

            // Remove the capture
            removeCaptureAfterProcessing(capture.id);

            addMessage(`âœ“ Added as note in "Voice Notes" phase`, 'system');
        }

        function removeCaptureAfterProcessing(captureId) {
            voiceCaptureState.captures = voiceCaptureState.captures.filter(c => c.id !== captureId);
            saveCaptureToTree();
            updateCapturesUI();
            hideCaptureProcessingPrompt();
        }

        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 370: INDEXEDDB ARTIFACT STORAGE
        // - Local storage for artifacts during session
        // - Survives browser refresh/crash
        // - Keyed to tree ID
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const artifactDB = {
            dbName: 'TreeListyArtifacts',
            dbVersion: 1,
            storeName: 'artifacts',
            db: null
        };

        async function initArtifactDB() {
            return new Promise((resolve, reject) => {
                if (artifactDB.db) {
                    resolve(artifactDB.db);
                    return;
                }

                const request = indexedDB.open(artifactDB.dbName, artifactDB.dbVersion);

                request.onerror = () => {
                    console.error('Failed to open artifact database:', request.error);
                    reject(request.error);
                };

                request.onsuccess = () => {
                    artifactDB.db = request.result;
                    console.log('ðŸ“¦ Artifact database initialized');
                    resolve(artifactDB.db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // Create artifacts store
                    if (!db.objectStoreNames.contains(artifactDB.storeName)) {
                        const store = db.createObjectStore(artifactDB.storeName, { keyPath: 'id' });
                        store.createIndex('treeId', 'treeId', { unique: false });
                        store.createIndex('itemId', 'itemId', { unique: false });
                        console.log('ðŸ“¦ Created artifacts object store');
                    }
                };
            });
        }

        async function saveArtifact(artifact) {
            try {
                const db = await initArtifactDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([artifactDB.storeName], 'readwrite');
                    const store = transaction.objectStore(artifactDB.storeName);

                    const artifactRecord = {
                        id: artifact.id || 'art-' + Date.now(),
                        treeId: capexTree?.id || 'unknown',
                        itemId: artifact.itemId,
                        filename: artifact.filename,
                        type: artifact.type,
                        size: artifact.size,
                        data: artifact.data, // Base64 or Blob
                        addedAt: new Date().toISOString()
                    };

                    const request = store.put(artifactRecord);

                    request.onsuccess = () => {
                        console.log('ðŸ“¦ Artifact saved:', artifactRecord.id);
                        resolve(artifactRecord);
                    };

                    request.onerror = () => {
                        console.error('Failed to save artifact:', request.error);
                        reject(request.error);
                    };
                });
            } catch (e) {
                console.error('Error saving artifact:', e);
                throw e;
            }
        }

        async function getArtifact(artifactId) {
            try {
                const db = await initArtifactDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([artifactDB.storeName], 'readonly');
                    const store = transaction.objectStore(artifactDB.storeName);
                    const request = store.get(artifactId);

                    request.onsuccess = () => {
                        resolve(request.result || null);
                    };

                    request.onerror = () => {
                        console.error('Failed to get artifact:', request.error);
                        reject(request.error);
                    };
                });
            } catch (e) {
                console.error('Error getting artifact:', e);
                return null;
            }
        }

        async function getArtifactsForTree(treeId) {
            try {
                const db = await initArtifactDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([artifactDB.storeName], 'readonly');
                    const store = transaction.objectStore(artifactDB.storeName);
                    const index = store.index('treeId');
                    const request = index.getAll(treeId);

                    request.onsuccess = () => {
                        resolve(request.result || []);
                    };

                    request.onerror = () => {
                        console.error('Failed to get tree artifacts:', request.error);
                        reject(request.error);
                    };
                });
            } catch (e) {
                console.error('Error getting tree artifacts:', e);
                return [];
            }
        }

        async function getArtifactsForItem(itemId) {
            try {
                const db = await initArtifactDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([artifactDB.storeName], 'readonly');
                    const store = transaction.objectStore(artifactDB.storeName);
                    const index = store.index('itemId');
                    const request = index.getAll(itemId);

                    request.onsuccess = () => {
                        resolve(request.result || []);
                    };

                    request.onerror = () => {
                        console.error('Failed to get item artifacts:', request.error);
                        reject(request.error);
                    };
                });
            } catch (e) {
                console.error('Error getting item artifacts:', e);
                return [];
            }
        }

        async function deleteArtifact(artifactId) {
            try {
                const db = await initArtifactDB();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([artifactDB.storeName], 'readwrite');
                    const store = transaction.objectStore(artifactDB.storeName);
                    const request = store.delete(artifactId);

                    request.onsuccess = () => {
                        console.log('ðŸ“¦ Artifact deleted:', artifactId);
                        resolve(true);
                    };

                    request.onerror = () => {
                        console.error('Failed to delete artifact:', request.error);
                        reject(request.error);
                    };
                });
            } catch (e) {
                console.error('Error deleting artifact:', e);
                return false;
            }
        }

        async function deleteArtifactsForTree(treeId) {
            try {
                const artifacts = await getArtifactsForTree(treeId);
                for (const artifact of artifacts) {
                    await deleteArtifact(artifact.id);
                }
                console.log(`ðŸ“¦ Deleted ${artifacts.length} artifacts for tree:`, treeId);
                return true;
            } catch (e) {
                console.error('Error deleting tree artifacts:', e);
                return false;
            }
        }

        // File to artifact helper
        async function fileToArtifact(file, itemId) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = async () => {
                    const artifact = {
                        id: 'art-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                        itemId: itemId,
                        filename: file.name,
                        type: file.type,
                        size: file.size,
                        data: reader.result // Base64 data URL
                    };

                    try {
                        const saved = await saveArtifact(artifact);
                        resolve(saved);
                    } catch (e) {
                        reject(e);
                    }
                };

                reader.onerror = () => {
                    reject(new Error('Failed to read file'));
                };

                reader.readAsDataURL(file);
            });
        }

        // Get artifact display info
        function getArtifactDisplayInfo(artifact) {
            const isImage = artifact.type?.startsWith('image/');
            const isAudio = artifact.type?.startsWith('audio/');
            const isPDF = artifact.type === 'application/pdf';

            let icon = 'ðŸ“Ž';
            if (isImage) icon = 'ðŸ–¼ï¸';
            else if (isAudio) icon = 'ðŸŽ™ï¸';
            else if (isPDF) icon = 'ðŸ“„';

            const sizeStr = artifact.size >= 1024 * 1024
                ? (artifact.size / (1024 * 1024)).toFixed(1) + ' MB'
                : (artifact.size / 1024).toFixed(0) + ' KB';

            return {
                icon,
                isImage,
                isAudio,
                isPDF,
                canPreview: isImage || isAudio || isPDF,
                sizeStr
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 371: ARTIFACT SIDE PANEL
        // - View/manage artifacts attached to items
        // - Drag-and-drop file upload
        // - Preview images, audio, PDFs
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const artifactPanelState = {
            isOpen: false,
            currentItemId: null,
            currentItemName: ''
        };

        function initArtifactPanel() {
            const dropZone = document.getElementById('artifact-drop-zone');
            const fileInput = document.getElementById('artifact-file-input');

            if (!dropZone || !fileInput) return;

            // Click to browse
            dropZone.addEventListener('click', () => {
                fileInput.click();
            });

            // File input change
            fileInput.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                await handleArtifactFiles(files);
                fileInput.value = ''; // Reset
            });

            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');

                const files = Array.from(e.dataTransfer.files);
                await handleArtifactFiles(files);
            });

            console.log('ðŸ“Ž Artifact panel initialized');
        }

        async function handleArtifactFiles(files) {
            if (!artifactPanelState.currentItemId) {
                showToast('No item selected for attachments', 'error');
                return;
            }

            const MAX_FILE_SIZE = 25 * 1024 * 1024; // 25MB limit

            for (const file of files) {
                if (file.size > MAX_FILE_SIZE) {
                    showToast(`${file.name} is too large (max 25MB)`, 'warning');
                    continue;
                }

                try {
                    const artifact = await fileToArtifact(file, artifactPanelState.currentItemId);
                    console.log('ðŸ“Ž File attached:', artifact.filename);
                    showToast(`Attached: ${artifact.filename}`, 'success');
                } catch (e) {
                    console.error('Failed to attach file:', e);
                    showToast(`Failed to attach ${file.name}`, 'error');
                }
            }

            // Refresh artifact list
            await updateArtifactPanel();
            // Update item in tree to show badge
            render();
        }

        window.openArtifactPanel = async function(itemId, itemName) {
            artifactPanelState.currentItemId = itemId;
            artifactPanelState.currentItemName = itemName || 'Item';
            artifactPanelState.isOpen = true;

            const panel = document.getElementById('artifact-panel');
            const itemNameEl = document.getElementById('artifact-panel-item-name');

            if (itemNameEl) {
                itemNameEl.textContent = artifactPanelState.currentItemName;
            }

            if (panel) {
                panel.classList.add('open');
            }

            await updateArtifactPanel();
        };

        window.closeArtifactPanel = function() {
            artifactPanelState.isOpen = false;
            artifactPanelState.currentItemId = null;

            const panel = document.getElementById('artifact-panel');
            if (panel) {
                panel.classList.remove('open');
            }
        };

        async function updateArtifactPanel() {
            const listEl = document.getElementById('artifact-list');
            const emptyEl = document.getElementById('artifact-empty');

            if (!listEl || !artifactPanelState.currentItemId) return;

            // Get artifacts for current item
            const artifacts = await getArtifactsForItem(artifactPanelState.currentItemId);

            if (artifacts.length === 0) {
                listEl.innerHTML = '';
                if (emptyEl) emptyEl.style.display = 'block';
                return;
            }

            if (emptyEl) emptyEl.style.display = 'none';

            listEl.innerHTML = artifacts.map(artifact => {
                const info = getArtifactDisplayInfo(artifact);
                const previewHtml = info.isImage && artifact.data
                    ? `<img src="${artifact.data}" alt="${artifact.filename}">`
                    : `<span class="placeholder-icon">${info.icon}</span>`;

                return `
                    <div class="artifact-list-item" data-artifact-id="${artifact.id}">
                        <div class="artifact-preview">
                            ${previewHtml}
                        </div>
                        <div class="artifact-info">
                            <div class="artifact-name">${artifact.filename}</div>
                            <div class="artifact-meta">${info.sizeStr} â€¢ ${new Date(artifact.addedAt).toLocaleDateString()}</div>
                            <div class="artifact-actions">
                                ${info.canPreview ? `<button class="artifact-action" onclick="window.previewArtifact('${artifact.id}')">Preview</button>` : ''}
                                <button class="artifact-action" onclick="window.downloadArtifact('${artifact.id}')">Download</button>
                                <button class="artifact-action delete" onclick="window.removeArtifact('${artifact.id}')">Remove</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        window.previewArtifact = async function(artifactId) {
            const artifact = await getArtifact(artifactId);
            if (!artifact || !artifact.data) {
                showToast('Could not load artifact', 'error');
                return;
            }

            const info = getArtifactDisplayInfo(artifact);

            // Create preview modal
            const modal = document.createElement('div');
            modal.className = 'artifact-preview-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.9);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
                padding: 40px;
            `;

            let contentHtml = '';
            if (info.isImage) {
                contentHtml = `<img src="${artifact.data}" style="max-width: 100%; max-height: 80vh; border-radius: 8px;">`;
            } else if (info.isAudio) {
                contentHtml = `<audio src="${artifact.data}" controls style="width: 400px;"></audio>`;
            } else if (info.isPDF) {
                contentHtml = `<iframe src="${artifact.data}" style="width: 90vw; height: 80vh; border: none; border-radius: 8px;"></iframe>`;
            }

            modal.innerHTML = `
                <div style="text-align: center;">
                    ${contentHtml}
                    <div style="margin-top: 16px; color: #888;">${artifact.filename}</div>
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        margin-top: 16px;
                        padding: 8px 24px;
                        background: #6366f1;
                        border: none;
                        border-radius: 8px;
                        color: white;
                        cursor: pointer;
                    ">Close</button>
                </div>
            `;

            document.body.appendChild(modal);

            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });

            // Close on Escape
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        };

        window.downloadArtifact = async function(artifactId) {
            const artifact = await getArtifact(artifactId);
            if (!artifact || !artifact.data) {
                showToast('Could not load artifact', 'error');
                return;
            }

            // Create download link
            const link = document.createElement('a');
            link.href = artifact.data;
            link.download = artifact.filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showToast(`Downloaded: ${artifact.filename}`, 'success');
        };

        window.removeArtifact = async function(artifactId) {
            if (!confirm('Remove this attachment?')) return;

            try {
                await deleteArtifact(artifactId);
                showToast('Attachment removed', 'success');
                await updateArtifactPanel();
                render(); // Update badges
            } catch (e) {
                console.error('Failed to remove artifact:', e);
                showToast('Failed to remove attachment', 'error');
            }
        };

        // Get artifact count for an item (for badges)
        async function getArtifactCountForItem(itemId) {
            const artifacts = await getArtifactsForItem(itemId);
            return artifacts.length;
        }

        // Expose for tree rendering
        window.getArtifactCountForItem = getArtifactCountForItem;
        window.openArtifactPanel = window.openArtifactPanel;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUILD 372: .TREELISTY BUNDLE EXPORT/IMPORT
        // - ZIP archive containing tree.json + artifacts folder
        // - Portable format for sharing trees with attachments
        // - Import restores tree and all artifacts to IndexedDB
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Export current tree as .treelisty bundle (ZIP)
         * Contains: tree.json + artifacts/ folder with all attachments
         */
        window.exportTreelistyBundle = async function() {
            if (!window.JSZip) {
                showToast('JSZip library not loaded', 'error');
                return;
            }

            try {
                showToast('Preparing bundle...', 'info');

                const zip = new JSZip();
                const treeId = capexTree?.id || 'unknown';

                // Get all artifacts for this tree
                const artifacts = await getArtifactsForTree(treeId);

                // Build artifact manifest for tree.json
                const artifactManifest = {};
                for (const artifact of artifacts) {
                    artifactManifest[artifact.id] = {
                        filename: artifact.filename,
                        itemId: artifact.itemId,
                        type: artifact.type,
                        size: artifact.size,
                        addedAt: artifact.addedAt
                    };
                }

                // Create tree.json with artifact manifest
                const treeData = JSON.parse(JSON.stringify(capexTree));
                treeData.artifacts = artifactManifest;
                treeData.exportedAt = new Date().toISOString();
                treeData.bundleVersion = 1;

                zip.file('tree.json', JSON.stringify(treeData, null, 2));

                // Add artifacts to artifacts/ folder
                const artifactsFolder = zip.folder('artifacts');
                for (const artifact of artifacts) {
                    if (artifact.data) {
                        // Convert data URL to binary
                        const base64Data = artifact.data.split(',')[1];
                        if (base64Data) {
                            artifactsFolder.file(artifact.id + '_' + artifact.filename, base64Data, { base64: true });
                        }
                    }
                }

                // Generate the ZIP file
                const content = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });

                // Create filename from tree name
                const safeName = (capexTree?.name || 'tree')
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-|-$/g, '')
                    .substring(0, 50);
                const filename = `${safeName}.treelisty`;

                // Trigger download
                const url = URL.createObjectURL(content);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                const artifactCount = artifacts.length;
                const sizeKB = Math.round(content.size / 1024);
                showToast(`Bundle exported: ${artifactCount} artifacts, ${sizeKB} KB`, 'success');

            } catch (e) {
                console.error('Failed to export bundle:', e);
                showToast('Failed to export bundle: ' + e.message, 'error');
            }
        };

        /**
         * Import .treelisty bundle
         * Restores tree data and all artifacts to IndexedDB
         */
        window.importTreelistyBundle = async function(file) {
            if (!window.JSZip) {
                showToast('JSZip library not loaded', 'error');
                return false;
            }

            try {
                showToast('Importing bundle...', 'info');

                const zip = await JSZip.loadAsync(file);

                // Read tree.json
                const treeJsonFile = zip.file('tree.json');
                if (!treeJsonFile) {
                    throw new Error('Invalid bundle: tree.json not found');
                }

                const treeJsonText = await treeJsonFile.async('string');
                const importedTree = JSON.parse(treeJsonText);

                // Validate tree structure
                if (!importedTree.name || !importedTree.children) {
                    throw new Error('Invalid bundle: tree.json is malformed');
                }

                // Extract artifact manifest
                const artifactManifest = importedTree.artifacts || {};
                delete importedTree.artifacts; // Remove from tree data
                delete importedTree.exportedAt;
                delete importedTree.bundleVersion;

                // Generate new tree ID to avoid conflicts
                const newTreeId = 'tree-' + Date.now();
                const oldTreeId = importedTree.id;
                importedTree.id = newTreeId;

                // Import artifacts from artifacts/ folder
                const artifactsFolder = zip.folder('artifacts');
                let artifactCount = 0;

                if (artifactsFolder) {
                    const artifactFiles = [];
                    artifactsFolder.forEach((relativePath, zipEntry) => {
                        if (!zipEntry.dir) {
                            artifactFiles.push({ path: relativePath, entry: zipEntry });
                        }
                    });

                    for (const { path, entry } of artifactFiles) {
                        try {
                            // Extract original artifact ID from filename (id_originalname.ext)
                            const underscoreIndex = path.indexOf('_');
                            const originalId = underscoreIndex > 0 ? path.substring(0, underscoreIndex) : path;
                            const originalFilename = underscoreIndex > 0 ? path.substring(underscoreIndex + 1) : path;

                            // Get manifest info
                            const manifestInfo = artifactManifest[originalId] || {};

                            // Read file data as base64
                            const base64Data = await entry.async('base64');
                            const mimeType = manifestInfo.type || 'application/octet-stream';
                            const dataUrl = `data:${mimeType};base64,${base64Data}`;

                            // Create new artifact with new ID
                            const newArtifactId = 'art-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                            const artifact = {
                                id: newArtifactId,
                                treeId: newTreeId,
                                itemId: manifestInfo.itemId,
                                filename: manifestInfo.filename || originalFilename,
                                type: mimeType,
                                size: manifestInfo.size || 0,
                                data: dataUrl,
                                addedAt: manifestInfo.addedAt || new Date().toISOString()
                            };

                            await saveArtifact(artifact);
                            artifactCount++;

                        } catch (artifactError) {
                            console.error('Failed to import artifact:', path, artifactError);
                        }
                    }
                }

                // Load the tree
                capexTree = importedTree;
                saveState('Imported bundle: ' + importedTree.name);
                render();

                showToast(`Imported: "${importedTree.name}" with ${artifactCount} artifacts`, 'success');
                return true;

            } catch (e) {
                console.error('Failed to import bundle:', e);
                showToast('Failed to import bundle: ' + e.message, 'error');
                return false;
            }
        };

        /**
         * Handle file input for .treelisty import
         */
        window.handleBundleFileSelect = async function(event) {
            const file = event.target.files?.[0];
            if (!file) return;

            if (file.name.endsWith('.treelisty') || file.type === 'application/zip') {
                await window.importTreelistyBundle(file);
            } else {
                showToast('Please select a .treelisty file', 'warning');
            }

            // Reset input
            event.target.value = '';
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DRAGGABLE FLOATING PANEL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initDraggablePanel() {
            const panel = document.getElementById('chat-assistant-panel');
            const header = document.getElementById('chat-assistant-header');
            if (!panel || !header) return;

            let isDragging = false;
            let startX, startY;
            let startLeft, startTop;

            header.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on buttons
                if (e.target.tagName === 'BUTTON') return;

                isDragging = true;
                panel.classList.add('dragging');

                // Get current position
                const rect = panel.getBoundingClientRect();
                startX = e.clientX;
                startY = e.clientY;
                startLeft = rect.left;
                startTop = rect.top;

                // Switch from bottom/right to top/left positioning
                panel.style.bottom = 'auto';
                panel.style.right = 'auto';
                panel.style.left = rect.left + 'px';
                panel.style.top = rect.top + 'px';

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                let newLeft = startLeft + dx;
                let newTop = startTop + dy;

                // Keep panel within viewport bounds
                const panelRect = panel.getBoundingClientRect();
                const maxLeft = window.innerWidth - panelRect.width;
                const maxTop = window.innerHeight - panelRect.height;

                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));

                panel.style.left = newLeft + 'px';
                panel.style.top = newTop + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    panel.classList.remove('dragging');
                    savePanelPosition();
                }
            });

            // Touch support for mobile
            header.addEventListener('touchstart', (e) => {
                if (e.target.tagName === 'BUTTON') return;

                isDragging = true;
                panel.classList.add('dragging');

                const touch = e.touches[0];
                const rect = panel.getBoundingClientRect();
                startX = touch.clientX;
                startY = touch.clientY;
                startLeft = rect.left;
                startTop = rect.top;

                panel.style.bottom = 'auto';
                panel.style.right = 'auto';
                panel.style.left = rect.left + 'px';
                panel.style.top = rect.top + 'px';
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;

                const touch = e.touches[0];
                const dx = touch.clientX - startX;
                const dy = touch.clientY - startY;

                let newLeft = startLeft + dx;
                let newTop = startTop + dy;

                const panelRect = panel.getBoundingClientRect();
                const maxLeft = window.innerWidth - panelRect.width;
                const maxTop = window.innerHeight - panelRect.height;

                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));

                panel.style.left = newLeft + 'px';
                panel.style.top = newTop + 'px';
            }, { passive: true });

            document.addEventListener('touchend', () => {
                if (isDragging) {
                    isDragging = false;
                    panel.classList.remove('dragging');
                    savePanelPosition();
                }
            });
        }

        function savePanelPosition() {
            const panel = document.getElementById('chat-assistant-panel');
            if (!panel) return;

            const rect = panel.getBoundingClientRect();
            const position = {
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height
            };
            localStorage.setItem('treebeardPosition', JSON.stringify(position));
        }

        function restorePanelPosition() {
            const panel = document.getElementById('chat-assistant-panel');
            if (!panel) return;

            try {
                const saved = localStorage.getItem('treebeardPosition');
                if (saved) {
                    const position = JSON.parse(saved);

                    // Validate position is within current viewport
                    const maxLeft = window.innerWidth - 320; // min width
                    const maxTop = window.innerHeight - 300; // min height

                    if (position.left >= 0 && position.left <= maxLeft &&
                        position.top >= 0 && position.top <= maxTop) {
                        panel.style.bottom = 'auto';
                        panel.style.right = 'auto';
                        panel.style.left = Math.min(position.left, maxLeft) + 'px';
                        panel.style.top = Math.min(position.top, maxTop) + 'px';

                        if (position.width && position.width >= 320) {
                            panel.style.width = position.width + 'px';
                        }
                        if (position.height && position.height >= 300) {
                            panel.style.height = position.height + 'px';
                        }
                    }
                }
            } catch (e) {
                console.warn('Could not restore TreeBeard position:', e);
            }
        }

        // Initialize when DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initChatAssistant);
        } else {
            initChatAssistant();
        }

        // Expose for debugging
        window.chatAssistant = {
            toggle: toggleChatPanel,
            send: handleSendMessage,
            execute: executeAction,
            state: chatState
        };

    })();
    </script>

    <!-- BUILD 280: Version Check & Auto-Update Notification -->
    <script>
    (function() {
        // BUILD 328: Use global version constant as single source of truth
        const CURRENT_BUILD = window.TREELISTY_VERSION?.build || 0;
        const CHECK_INTERVAL = 30000; // Check 30 seconds after load
        const RECHECK_INTERVAL = 300000; // Then every 5 minutes

        let updateToastShown = false;

        async function checkForUpdates() {
            if (updateToastShown) return;

            try {
                // BUILD 359: Version check - different approaches for different contexts
                const isFileProtocol = window.location.protocol === 'file:';

                if (isFileProtocol) {
                    // For file:// protocol, we can't fetch cross-origin due to CORS
                    // Instead, prompt user to check manually
                    console.log('ðŸ“¦ Running locally - visit https://treelisty.netlify.app to check for updates');
                    // Still show toast if we're significantly behind (hard-coded known version)
                    // This gets updated with each release
                    const KNOWN_LATEST = 411; // Update this with each build
                    if (KNOWN_LATEST > CURRENT_BUILD) {
                        console.log(`ðŸš€ New version likely available: Build ${KNOWN_LATEST}+ (you have ${CURRENT_BUILD})`);
                        showUpdateToast(KNOWN_LATEST);
                    }
                    return;
                }

                // For HTTPS (Netlify), fetch the current page to check version
                const response = await fetch(window.location.pathname + '?_nocache=' + Date.now(), {
                    cache: 'no-store',
                    headers: { 'Cache-Control': 'no-cache' }
                });

                if (!response.ok) return;

                const html = await response.text();

                // Extract build number from header comment: "Build XXX"
                const match = html.match(/TreeListy v[\d.]+ \| Build (\d+)/);
                if (!match) return;

                const latestBuild = parseInt(match[1]);

                if (latestBuild > CURRENT_BUILD) {
                    console.log(`ðŸš€ New version available: Build ${latestBuild} (current: ${CURRENT_BUILD})`);
                    showUpdateToast(latestBuild);
                } else {
                    console.log(`âœ… Running latest version: Build ${CURRENT_BUILD}`);
                }
            } catch (e) {
                console.warn('Version check failed:', e);
            }
        }

        function showUpdateToast(newBuild) {
            updateToastShown = true;

            // Create update toast
            const toast = document.createElement('div');
            toast.id = 'update-toast';
            toast.style.cssText = `
                position: fixed;
                bottom: 80px;
                right: 20px;
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
                padding: 16px 20px;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(16, 185, 129, 0.4);
                z-index: 10001;
                font-family: inherit;
                animation: slideInRight 0.3s ease-out;
                max-width: 300px;
            `;

            toast.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <div style="font-size: 24px;">ðŸš€</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 700; font-size: 14px; margin-bottom: 4px;">
                            New Version Available!
                        </div>
                        <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">
                            Build ${newBuild} is ready (you have Build ${CURRENT_BUILD})
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="window.forceUpdateApp()" style="
                                padding: 8px 16px;
                                background: white;
                                color: #059669;
                                border: none;
                                border-radius: 6px;
                                font-weight: 700;
                                font-size: 12px;
                                cursor: pointer;
                            ">Update Now</button>
                            <button onclick="this.closest('#update-toast').remove()" style="
                                padding: 8px 12px;
                                background: rgba(255,255,255,0.2);
                                color: white;
                                border: none;
                                border-radius: 6px;
                                font-size: 12px;
                                cursor: pointer;
                            ">Later</button>
                        </div>
                    </div>
                    <button onclick="this.closest('#update-toast').remove()" style="
                        background: none;
                        border: none;
                        color: white;
                        opacity: 0.7;
                        cursor: pointer;
                        font-size: 16px;
                        padding: 0;
                    ">&times;</button>
                </div>
            `;

            // Add animation keyframes if not exists
            if (!document.getElementById('update-toast-styles')) {
                const style = document.createElement('style');
                style.id = 'update-toast-styles';
                style.textContent = `
                    @keyframes slideInRight {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(toast);
        }

        // Force update - bypass all caches while preserving tree state
        window.forceUpdateApp = function() {
            // BUILD 329: Save current tree state before refresh
            try {
                if (window.capexTree) {
                    // Capture current view state
                    const viewState = {
                        viewMode: typeof viewMode !== 'undefined' ? viewMode : 'tree',
                        treeZoom: typeof zoomLevel !== 'undefined' ? zoomLevel : 1,
                        treePanX: typeof panX !== 'undefined' ? panX : 0,
                        treePanY: typeof panY !== 'undefined' ? panY : 0,
                        canvasZoom: typeof canvasZoom !== 'undefined' ? canvasZoom : 1,
                        canvasPanX: typeof canvasPan !== 'undefined' ? canvasPan.x : 0,
                        canvasPanY: typeof canvasPan !== 'undefined' ? canvasPan.y : 0
                    };
                    window.capexTree.viewState = viewState;

                    // Save tree + state for restore after update
                    const updateState = {
                        tree: window.capexTree,
                        pattern: typeof currentPattern !== 'undefined' ? currentPattern : 'generic',
                        roomId: window.firebaseSyncState?.roomId || null,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('treelisty:pending-update', JSON.stringify(updateState));
                    console.log('ðŸ’¾ Saved tree state for update restore');
                }
            } catch (e) {
                console.warn('âš ï¸ Could not save tree state before update:', e);
            }

            // Clear service worker cache if exists
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => caches.delete(name));
                });
            }

            // Unregister service workers
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    registrations.forEach(reg => reg.unregister());
                });
            }

            // Navigate with cache-busting parameter
            const url = new URL(window.location.href);
            url.searchParams.set('_v', Date.now());
            window.location.href = url.toString();
        };

        // Manual check function (can be called from console)
        window.checkForUpdates = checkForUpdates;

        // Initial check after page loads
        setTimeout(checkForUpdates, CHECK_INTERVAL);

        // Periodic rechecks
        setInterval(checkForUpdates, RECHECK_INTERVAL);

        console.log(`ðŸ”„ Version checker active (Build ${CURRENT_BUILD})`);
    })();
    </script>

    <!-- Canvas View Container -->
    <div class="canvas-container" id="canvas-container">
        <!-- Canvas Toolbar -->
        <div class="canvas-toolbar" id="canvas-toolbar" style="position: fixed; top: 120px; left: 50%; transform: translateX(-50%); z-index: 200; display: none; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(20, 20, 30, 0.98); backdrop-filter: blur(10px); border: 2px solid rgba(99, 102, 241, 0.3); border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.4);">
            <select id="auto-layout-select" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.15); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 8px; color: #ffffff; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                <option value="" style="background: #1a1a2e; color: #ffffff;">ðŸ“ Auto-Layout</option>
                <option value="hierarchical" style="background: #1a1a2e; color: #ffffff;">ðŸŒ³ Hierarchical</option>
                <option value="timeline" style="background: #1a1a2e; color: #ffffff;">ðŸ“… Timeline</option>
                <option value="force" style="background: #1a1a2e; color: #ffffff;">ðŸŒ€ Force-Directed</option>
                <option value="radial" style="background: #1a1a2e; color: #ffffff;">â­• Radial</option>
                <option value="grid" style="background: #1a1a2e; color: #ffffff;">âŠž Grid</option>
            </select>
            <select id="cluster-by-select" style="padding: 8px 14px; background: rgba(34, 197, 94, 0.15); border: 1px solid rgba(34, 197, 94, 0.4); border-radius: 8px; color: #ffffff; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                <!-- Options populated dynamically by updateClusterByOptions() -->
            </select>
            <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
            <button id="grid-toggle" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                â—« Grid
            </button>
            <button id="reset-view" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                ðŸŽ¯ Reset
            </button>
            <button id="fit-view" class="btn" style="padding: 8px 14px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: all 0.2s;">
                âŠ¡ Fit
            </button>
            <button id="hyperedge-panel-btn" onclick="toggleHyperedgePanel()" class="btn" style="padding: 8px 14px; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 8px; color: #A78BFA; font-size: 13px; transition: all 0.2s;" title="Manage hyperedge visibility">
                ðŸ”— Edges
            </button>
            <div style="width: 1px; height: 24px; background: rgba(99, 102, 241, 0.2);"></div>
            <div style="display: flex; align-items: center; gap: 6px;">
                <button id="zoom-out" class="btn" style="padding: 6px 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: var(--text-primary); font-weight: 600; transition: all 0.2s;">âˆ’</button>
                <span id="zoom-level" style="font-size: 12px; font-weight: 600; color: var(--treeplex-primary); min-width: 50px; text-align: center;">100%</span>
                <button id="zoom-in" class="btn" style="padding: 6px 10px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 6px; color: var(--text-primary); font-weight: 600; transition: all 0.2s;">+</button>
            </div>
        </div>

        <!-- Selection Counter -->
        <div id="selection-counter" style="display: none; position: fixed; top: 200px; left: 50%; transform: translateX(-50%); background: rgba(99, 102, 241, 0.95); color: white; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: 600; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px);">
            <span id="selection-count">0</span> nodes selected
        </div>

        <div id="canvas">
            <!-- Grid Pattern -->
            <svg class="canvas-grid" id="canvas-grid" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; opacity: 0;">
                <defs>
                    <pattern id="grid-pattern" width="40" height="40" patternUnits="userSpaceOnUse">
                        <path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(99, 102, 241, 0.15)" stroke-width="1"/>
                    </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid-pattern)" />
            </svg>
            <svg class="canvas-connections" id="canvas-connections"></svg>
        </div>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         CHAT ASSISTANT BUBBLE & PANEL
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

    <!-- BUILD 370: Voice Capture FAB (Floating Action Button) - Mobile only -->
    <button id="voice-capture-fab" title="Voice Capture">
        ðŸŽ¤
        <span class="fab-badge" style="display: none;">0</span>
    </button>

    <!-- Floating Chat Bubble -->
    <button id="chat-assistant-bubble" title="TreeBeard (Ctrl+/)">
        ðŸ’¬
    </button>

    <!-- Chat Panel - Draggable Floating Frame -->
    <div id="chat-assistant-panel">
        <div id="chat-assistant-header">
            <h3>ðŸŒ³ TreeBeard</h3>
            <!-- BUILD 368: Conversation mode indicator -->
            <span id="conversation-mode-indicator" style="display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; background: rgba(99, 102, 241, 0.2); border-radius: 12px; font-size: 10px; color: #a5b4fc; cursor: pointer;" onclick="window.toggleConversationMode()" title="âš¡ QUICK MODE: Fast commands (find, add, navigate)&#10;Click to switch to Deep Mode for analysis">âš¡ Quick</span>
            <!-- BUILD 366: Biographer mode indicator for LifeTree -->
            <span id="biographer-mode-indicator" style="display: none; align-items: center; gap: 4px; padding: 3px 8px; background: rgba(99, 102, 241, 0.2); border-radius: 12px; font-size: 10px; color: #a5b4fc; cursor: pointer;" onclick="window.cycleBiographerMode()" title="Click to change mode"></span>
            <div class="header-actions">
                <button id="chat-clear-btn" title="Clear conversation">ðŸ—‘ï¸</button>
                <button id="chat-close-btn" title="Close">âœ•</button>
            </div>
        </div>

        <!-- BUILD 370: Voice Recording UI -->
        <div id="voice-recording-ui">
            <div class="recording-status">
                <div class="recording-dot"></div>
                <span class="recording-duration">0:00</span>
            </div>
            <div class="live-transcript-area">
                <span class="live-transcript-placeholder">Start speaking... your words will appear here</span>
                <span class="final"></span>
                <span class="interim"></span>
            </div>
            <div class="recording-controls">
                <button class="recording-stop-btn" onclick="window.stopVoiceCapture()">âœ“ Done</button>
                <button class="recording-cancel-btn" onclick="window.cancelVoiceCapture()">Cancel</button>
            </div>
            <div class="recording-warning">Recording for over 5 minutes. Tap "Done" when ready.</div>
        </div>

        <!-- BUILD 370: Voice Captures Section -->
        <div id="voice-captures-section" style="display: none;">
            <div class="captures-header" onclick="window.toggleCapturesSection()">
                <h4>ðŸ“Ž Captures <span class="capture-count">0</span></h4>
                <span class="toggle-icon">â–¼</span>
            </div>
            <div class="captures-list">
                <!-- Captures populated dynamically -->
            </div>
        </div>

        <!-- BUILD 370: Capture Processing Prompt (shown when processing a capture) -->
        <div id="capture-processing-prompt" class="capture-processing-prompt" style="display: none;">
            <div class="prompt-header">ðŸ“Ž Voice Capture</div>
            <div class="transcript-preview"></div>
            <div class="quick-actions">
                <button class="quick-action" data-action="add-to-tree">Add to tree</button>
                <button class="quick-action" data-action="new-branch">New branch</button>
                <button class="quick-action" data-action="save-as-note">Save as note</button>
                <button class="quick-action" data-action="psych-analysis">ðŸ§  Psychological analysis</button>
            </div>
            <div class="instruction-hint">Or type your own instruction below...</div>
        </div>

        <div id="chat-assistant-messages">
            <!-- Welcome message -->
            <div class="chat-message assistant">
                How can I help? Try:
                <div class="action-buttons" style="margin-top: 6px;">
                    <button class="action-btn" data-action="help">ðŸ“– Features</button>
                    <button class="action-btn" data-action="create">ðŸŒ³ New tree</button>
                    <button class="action-btn" data-action="enhance">âœ¨ Enhance</button>
                    <button class="action-btn" data-action="query">ðŸ” Query</button>
                </div>
            </div>
        </div>

        <div id="chat-assistant-input-area">
            <textarea id="chat-assistant-input" placeholder="Ask anything or give a command..." rows="1"></textarea>
            <button id="chat-voice-btn" title="Voice capture" onclick="window.startVoiceCapture()">ðŸŽ¤</button>
            <button id="chat-send-btn" title="Send message">âž¤</button>
        </div>
    </div>

    <!-- BUILD 393: Floating Command Frame (New Chat UI) -->
    <div id="command-frame">
        <!-- Compact Header with Mode Toggle -->
        <div class="command-frame-header">
            <span class="frame-icon">ðŸŒ³</span>
            <span class="frame-title">TreeBeard</span>
            <div class="mode-pills">
                <button class="mode-pill active" data-mode="quick" title="Quick Commands">âš¡ Quick</button>
                <button class="mode-pill" data-mode="deep" title="Deep Conversation">ðŸ§  Deep</button>
            </div>
            <button class="frame-minimize" title="Minimize" onclick="minimizeCommandFrame()">âˆ’</button>
            <button class="frame-close" title="Close" onclick="toggleCommandFrame()">âœ•</button>
        </div>

        <!-- Context Bar - Shows current selection/focus -->
        <div class="command-context-bar no-focus">
            <span class="context-icon">ðŸ“</span>
            <span class="context-text">No node focused â€” use Find or click a node</span>
            <button class="context-action" data-action="show_info" title="Show Details" style="display: none;">â„¹ï¸</button>
        </div>

        <!-- Action Button Grid - Always Visible -->
        <div class="command-actions">
            <div class="action-row primary-actions">
                <button class="cmd-btn" data-action="prompt_find"><span class="btn-icon">ðŸ”</span><span class="btn-label">Find</span></button>
                <button class="cmd-btn" data-action="prompt_add"><span class="btn-icon">âž•</span><span class="btn-label">Add</span></button>
                <button class="cmd-btn" data-action="ai_enhance"><span class="btn-icon">âœ¨</span><span class="btn-label">Enhance</span></button>
                <button class="cmd-btn" data-action="show_help"><span class="btn-icon">ðŸ“–</span><span class="btn-label">Help</span></button>
            </div>
            <div class="action-row secondary-actions collapsed">
                <!-- Populated dynamically based on context -->
            </div>
        </div>

        <!-- Input Area -->
        <div class="command-input-area">
            <input type="text" id="command-input" placeholder="Type command or question..." autocomplete="off">
            <button id="command-voice-btn" class="command-btn" title="Voice" onclick="window.startVoiceCapture()">ðŸŽ¤</button>
            <button id="command-send-btn" class="command-btn primary" title="Send" onclick="handleCommandSend()">âž¤</button>
        </div>

        <!-- Collapsible Message History -->
        <div class="command-history collapsed">
            <div class="history-toggle" onclick="toggleCommandHistory()">
                <span>ðŸ’¬ History</span>
                <span class="toggle-icon">â–¼</span>
            </div>
            <div class="history-messages">
                <!-- Messages populated dynamically -->
            </div>
        </div>
    </div>

    <!-- BUILD 393: Visual Feedback Overlay -->
    <div id="tree-feedback-overlay" class="feedback-overlay"></div>

    <!-- BUILD 405: Live Tree Agent Frame (Chat Builder Redesign) -->
    <div id="tree-agent-frame" class="tree-agent" style="display: none;">
        <div class="agent-header">
            <div class="agent-title-row">
                <span class="agent-icon">ðŸ¤–</span>
                <span class="agent-title" id="agent-title">Building Tree...</span>
            </div>
            <div class="agent-progress-row">
                <div class="agent-progress-bar">
                    <div class="agent-progress-fill" id="agent-progress-fill" style="width: 0%;"></div>
                </div>
                <span class="agent-progress-text" id="agent-progress-text">0%</span>
            </div>
            <div class="agent-header-actions">
                <button class="agent-btn" id="agent-minimize-btn" title="Minimize">âˆ’</button>
                <button class="agent-btn" id="agent-close-btn" title="Close">âœ•</button>
            </div>
        </div>
        <div class="agent-body" id="agent-body">
            <div class="agent-messages" id="agent-messages">
                <!-- Chat messages populated dynamically -->
            </div>
            <div class="agent-input-row">
                <input type="text" id="agent-input" placeholder="Type or click a choice..." autocomplete="off">
                <button class="agent-input-btn" id="agent-voice-btn" title="Voice input">ðŸŽ¤</button>
                <button class="agent-input-btn primary" id="agent-send-btn" title="Send">âž¤</button>
            </div>
            <div class="agent-footer">
                <button class="agent-action-btn" id="agent-cancel-btn">Cancel</button>
                <button class="agent-action-btn primary" id="agent-finish-btn">âœ… Finish & Apply</button>
            </div>
        </div>
    </div>

    <!-- BUILD 371: Artifact Side Panel -->
    <div id="artifact-panel">
        <div class="panel-header">
            <div>
                <h3>ðŸ“Ž Attachments</h3>
                <div class="item-name" id="artifact-panel-item-name"></div>
            </div>
            <button class="panel-close" onclick="window.closeArtifactPanel()">âœ•</button>
        </div>
        <div class="panel-content">
            <div class="artifact-drop-zone" id="artifact-drop-zone">
                <div class="drop-icon">ðŸ“</div>
                <div class="drop-text">Drop files here</div>
                <div class="drop-hint">or click to browse</div>
                <input type="file" id="artifact-file-input" multiple style="display: none;" accept="image/*,audio/*,.pdf,.doc,.docx,.txt,.md">
            </div>
            <div class="artifact-list" id="artifact-list">
                <!-- Artifacts populated dynamically -->
            </div>
            <div class="artifact-empty" id="artifact-empty" style="display: none;">
                <div class="empty-icon">ðŸ“Ž</div>
                <div>No attachments yet</div>
            </div>
        </div>
    </div>

<!-- =============================================================================
     BUILD 286: 3D VIEW - Experimental Three.js Helix Visualization (PoC)
     - Non-destructive: Isolated alongside existing 2D views
     - Uses ES Modules to load Three.js from CDN
     - Toggle with "3D View" button in toolbar
============================================================================= -->

<style>
    /* 3D Viewport Container */
    #view-3d {
        position: fixed;
        top: 60px; /* Below header */
        left: 0;
        width: 100vw;
        height: calc(100vh - 60px);
        background: radial-gradient(circle at center, #1a1d24 0%, #000000 100%);
        z-index: 50; /* Above tree, below modals */
        display: none; /* Hidden by default */
        overflow: hidden;
    }

    #view-3d.active {
        display: block;
    }

    /* 3D Floating Nodes (HTML Overlay) */
    .node-3d-label {
        font-family: 'Inter', sans-serif;
        padding: 12px 16px;
        background: rgba(20, 20, 30, 0.75);
        backdrop-filter: blur(6px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-left: 4px solid var(--node-color, #6366f1);
        border-radius: 8px;
        color: #fff;
        font-size: 12px;
        width: 220px;
        box-shadow: 0 0 15px rgba(0,0,0,0.5);
        transition: all 0.3s ease;
        pointer-events: auto; /* Allow clicking */
        cursor: pointer;
        user-select: none;
    }

    .node-3d-label:hover {
        transform: scale(1.1);
        background: rgba(40, 40, 55, 0.9);
        box-shadow: 0 0 25px var(--node-color, #6366f1);
        z-index: 100;
    }

    .node-3d-title {
        font-weight: 700;
        font-size: 14px;
        margin-bottom: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .node-3d-meta {
        font-size: 10px;
        opacity: 0.7;
        display: flex;
        justify-content: space-between;
    }

    /* 3D Toolbar Overlay */
    #controls-3d {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 12px;
        background: rgba(0,0,0,0.5);
        padding: 10px;
        border-radius: 20px;
        border: 1px solid rgba(255,255,255,0.1);
        pointer-events: auto;
    }

    /* Floating Tree Title - Screenshot Ready */
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap');

    #title-3d {
        position: absolute;
        top: 30px;
        left: 80px; /* More margin to avoid panel overlap */
        pointer-events: none;
        z-index: 100;
    }

    #title-3d-name {
        font-family: 'Orbitron', 'Inter', sans-serif;
        font-size: 48px;
        font-weight: 900;
        color: #00ffff;
        text-shadow:
            0 0 10px rgba(0, 255, 255, 0.8),
            0 0 30px rgba(0, 255, 255, 0.6),
            0 0 60px rgba(0, 255, 255, 0.4),
            0 0 100px rgba(0, 255, 255, 0.2),
            0 4px 8px rgba(0, 0, 0, 0.9);
        letter-spacing: 4px;
        text-transform: uppercase;
        margin: 0;
        line-height: 1.1;
    }

    #title-3d-pattern {
        display: none; /* Hidden for cleaner look */
    }

    /* Hover Tooltip */
    #hover-tooltip-3d {
        position: absolute;
        background: rgba(10, 15, 30, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 255, 255, 0.4);
        border-radius: 10px;
        padding: 12px 16px;
        min-width: 180px;
        max-width: 280px;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3),
                    0 8px 32px rgba(0, 0, 0, 0.6);
        z-index: 200;
        display: none;
        pointer-events: none;
        transform: translate(-50%, -100%) translateY(-15px);
    }

    #hover-tooltip-3d.visible {
        display: block;
    }

    #hover-tooltip-name {
        font-family: 'Orbitron', sans-serif;
        font-size: 14px;
        font-weight: 700;
        color: #00ffff;
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    #hover-tooltip-type {
        font-size: 10px;
        color: rgba(255, 255, 255, 0.5);
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 6px;
    }

    #hover-tooltip-desc {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
        line-height: 1.4;
        max-height: 60px;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* 3D Context Menu */
    #context-menu-3d {
        position: absolute;
        background: rgba(20, 20, 35, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 150, 255, 0.3);
        border-radius: 12px;
        padding: 8px 0;
        min-width: 200px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5),
                    0 0 20px rgba(100, 150, 255, 0.2);
        z-index: 1000;
        display: none;
        pointer-events: auto;
    }

    #context-menu-3d.visible {
        display: block;
    }

    .context-menu-3d-item {
        padding: 10px 16px;
        color: #fff;
        font-size: 13px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.15s;
    }

    .context-menu-3d-item:hover {
        background: rgba(100, 150, 255, 0.2);
    }

    .context-menu-3d-item.danger:hover {
        background: rgba(255, 100, 100, 0.2);
    }

    .context-menu-3d-divider {
        height: 1px;
        background: rgba(255, 255, 255, 0.1);
        margin: 6px 0;
    }

    .context-menu-3d-header {
        padding: 8px 16px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.4);
        text-transform: uppercase;
        letter-spacing: 1px;
    }
</style>

<div id="view-3d">
    <!-- Floating Title Overlay -->
    <div id="title-3d">
        <h1 id="title-3d-name">Project Title</h1>
        <div id="title-3d-pattern">Pattern Name</div>
    </div>

    <!-- Hover Tooltip -->
    <div id="hover-tooltip-3d">
        <div id="hover-tooltip-name"></div>
        <div id="hover-tooltip-type"></div>
        <div id="hover-tooltip-desc"></div>
    </div>

    <!-- Context Menu for Node Editing -->
    <div id="context-menu-3d">
        <div class="context-menu-3d-header">Node Actions</div>
        <div class="context-menu-3d-item" data-action="edit">âœï¸ Edit Node</div>
        <div class="context-menu-3d-item" data-action="expand">ðŸ“‚ Expand Children</div>
        <div class="context-menu-3d-item" data-action="collapse">ðŸ“ Collapse Children</div>
        <div class="context-menu-3d-divider"></div>
        <div class="context-menu-3d-item" data-action="add-child">âž• Add Child</div>
        <div class="context-menu-3d-item" data-action="add-sibling">âž• Add Sibling</div>
        <div class="context-menu-3d-divider"></div>
        <div class="context-menu-3d-header">Connections</div>
        <div class="context-menu-3d-item" data-action="add-hyperedge">ðŸ”— Create Hyperedge</div>
        <div class="context-menu-3d-item" data-action="add-dependency">â†—ï¸ Add Dependency</div>
        <div class="context-menu-3d-divider"></div>
        <div class="context-menu-3d-item danger" data-action="delete">ðŸ—‘ï¸ Delete Node</div>
    </div>

    <!-- Controls -->
    <div id="controls-3d">
        <button class="btn" id="btn-3d-reset">ðŸ  Reset</button>
        <button class="btn" id="btn-3d-spin">ðŸ”„ Spin</button>
        <button class="btn" id="btn-3d-zoom-in">âž• Zoom In</button>
        <button class="btn" id="btn-3d-zoom-out">âž– Zoom Out</button>
        <div style="width: 1px; height: 24px; background: rgba(255,255,255,0.2); margin: 0 4px;"></div>
        <button class="btn" id="btn-3d-expand-all" title="Expand all nodes">ðŸ“‚ Expand All</button>
        <button class="btn" id="btn-3d-collapse-all" title="Collapse all nodes">ðŸ“ Collapse All</button>
        <div style="color: #888; font-size: 11px; align-self: center; margin-left: 10px;">
            Click: Select | Right-Click: Menu | Drag: Rotate | Scroll: Zoom
        </div>
    </div>
</div>

<!-- Three.js via CDN (global) - using r128 for compatibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
(function() {
    'use strict';

    // Check if Three.js loaded
    if (typeof THREE === 'undefined') {
        console.error('ðŸ§Š Three.js failed to load');
        return;
    }
    console.log('ðŸ§Š Three.js r128 loaded successfully');

    // --- State ---
    let camera, scene, renderer, controls;
    let isInitialized = false;
    let autoSpin = false;
    const nodePositions = new Map(); // Store positions for drawing lines
    const nodeMeshes = []; // Store mesh references for raycasting
    const labelSprites = []; // Store label sprites for raycasting
    const nodeToLabel = new Map(); // Map mesh to its label sprite
    let raycaster, mouse;
    let selectedMesh = null;
    let selectionGlow = null;
    let hoveredMesh = null; // Currently hovered node
    let hoverScale = 1; // Animation scale for hover
    let contextMenuNode = null; // Node for context menu actions
    const expandedNodes = new Set(); // Track which nodes are expanded in 3D
    let sunCorona = null; // Animated sun corona
    let coronaTime = 0; // Animation time
    let hoverTooltip = null; // HTML tooltip element
    const hyperedgeMeshes = []; // Store hyperedge tubes for raycasting
    let selectedHyperedge = null; // Currently selected hyperedge data

    // --- Configuration ---
    const CONFIG = {
        helixRadius: 300,
        verticalSpacing: 80,
        phaseSpacingZ: 600,
        colorPalette: [0x5FA463, 0x3B8FCC, 0xD68A2E, 0x8B5CF6, 0xEC4899]
    };

    // Pattern-based nebula colors
    const NEBULA_THEMES = {
        'philosophy': { primary: 0x4a148c, secondary: 0x7b1fa2, accent: 0xce93d8 },
        'capex': { primary: 0x0d47a1, secondary: 0x1565c0, accent: 0x64b5f6 },
        'generic': { primary: 0x1a237e, secondary: 0x283593, accent: 0x7986cb },
        'sales': { primary: 0x004d40, secondary: 0x00695c, accent: 0x4db6ac },
        'dialogue': { primary: 0x311b92, secondary: 0x4527a0, accent: 0xb39ddb },
        'film': { primary: 0x880e4f, secondary: 0xad1457, accent: 0xf48fb1 },
        'default': { primary: 0x0d1b2a, secondary: 0x1b263b, accent: 0x415a77 }
    };

    // Determine 3D layout mode based on sort configuration
    function determineLayoutMode(sortConfig) {
        if (!sortConfig || !sortConfig.field) return 'helix'; // Default

        const type = sortConfig.type || 'string';
        const field = sortConfig.field.toLowerCase();

        // Check for date fields
        if (type === 'date' || field.includes('date') || field.includes('time') ||
            field === 'created' || field === 'modified' || field === 'deadline') {
            return 'timeline';
        }

        // Check for numeric fields
        if (type === 'number' || type === 'currency' || type === 'percentage' ||
            field.includes('cost') || field.includes('price') || field.includes('amount') ||
            field.includes('budget') || field.includes('value') || field.includes('score') ||
            field.includes('priority') || field.includes('rank') || field.includes('rating')) {
            return 'tower';
        }

        // Check for boolean - use cluster
        if (type === 'boolean') {
            return 'cluster';
        }

        // Default to cluster for string/category fields
        return 'cluster';
    }

    // --- 1. Initialize 3D Button (button is in HTML, we just add handler) ---
    function init3DButton() {
        const btn = document.getElementById('toggle-3d-mode');
        if (!btn || btn.dataset.initialized) return;

        btn.dataset.initialized = 'true';
        btn.addEventListener('click', toggle3DView);
        console.log('ðŸ§Š 3D View button initialized');
    }

    // --- 2. Toggle View ---
    function toggle3DView() {
        const view3D = document.getElementById('view-3d');
        const treeView = document.querySelector('.tree-view-container');
        const canvasView = document.getElementById('canvas-container');
        const btn = document.getElementById('toggle-3d-mode');

        const isActive = view3D.classList.contains('active');

        if (isActive) {
            // Close 3D - save state first
            save3DViewState();
            view3D.classList.remove('active');
            treeView.classList.remove('hidden');
            btn.style.border = '1px solid var(--border)';
            hideContextMenu();
            // BUILD 352: Update viewMode variable so view switching works correctly
            viewMode = 'tree';
            // BUILD 333: Update view dropdown to show tree view
            if (window.updateViewDropdown) window.updateViewDropdown('tree');
        } else {
            // Open 3D
            view3D.classList.add('active');
            treeView.classList.add('hidden');
            canvasView.classList.remove('active'); // Ensure 2D canvas is off
            btn.style.border = '2px solid #fff';
            // BUILD 352: Update viewMode variable so view switching works correctly
            viewMode = '3d';

            if (!isInitialized) initThreeJS();
            // Restore state before refresh
            restore3DViewState();
            // Always refresh data on open
            refresh3DData();
            updateTitle();
            // BUILD 333: Update view dropdown to show 3D view
            if (window.updateViewDropdown) window.updateViewDropdown('3d');
        }
    }

    // Update floating title from tree data - max 3 words
    function updateTitle() {
        const tree = window.capexTree;
        if (!tree) return;

        const titleEl = document.getElementById('title-3d-name');

        if (titleEl) {
            let name = tree.name || 'Untitled';
            // Truncate to 3 words max
            const words = name.split(/\s+/);
            if (words.length > 3) {
                name = words.slice(0, 3).join(' ') + 'â€¦';
            }
            titleEl.textContent = name;
        }
    }

    // --- 3. Initialize Three.js ---
    function initThreeJS() {
        console.log('ðŸ§Š Initializing Three.js...');
        const container = document.getElementById('view-3d');

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a); // Dark background
        console.log('ðŸ§Š Scene created');

        // Camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(800, 400, 800);
        camera.lookAt(0, 0, 0);
        console.log('ðŸ§Š Camera created');

        // WebGL Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        console.log('ðŸ§Š Renderer created');

        // Controls - attach to renderer.domElement
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 5000;
        controls.minDistance = 100;
        console.log('ðŸ§Š OrbitControls created');

        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const point = new THREE.PointLight(0xffffff, 1);
        point.position.set(0, 500, 0);
        scene.add(point);

        // Stars/Particles
        addStarfield();

        // Event Listeners
        window.addEventListener('resize', onWindowResize);
        document.getElementById('btn-3d-reset').addEventListener('click', () => {
            camera.position.set(800, 400, 800);
            controls.target.set(0, 0, 0);
        });
        document.getElementById('btn-3d-spin').addEventListener('click', () => {
            autoSpin = !autoSpin;
            document.getElementById('btn-3d-spin').style.background = autoSpin ? '#10b981' : '';
        });

        // Zoom controls
        document.getElementById('btn-3d-zoom-in').addEventListener('click', () => {
            camera.position.multiplyScalar(0.8);
        });
        document.getElementById('btn-3d-zoom-out').addEventListener('click', () => {
            camera.position.multiplyScalar(1.25);
        });

        // Expand/Collapse All controls
        document.getElementById('btn-3d-expand-all').addEventListener('click', () => {
            expandAllNodes();
        });
        document.getElementById('btn-3d-collapse-all').addEventListener('click', () => {
            collapseAllNodes();
        });

        // Raycaster for click detection
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Click handler for node selection
        renderer.domElement.addEventListener('click', onNodeClick);
        renderer.domElement.addEventListener('dblclick', onNodeDoubleClick);

        // Right-click context menu
        renderer.domElement.addEventListener('contextmenu', onNodeRightClick);
        document.addEventListener('click', hideContextMenu);
        initContextMenuHandlers();

        // Mousemove handler for hover effects
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseleave', onMouseLeave);

        // Get tooltip reference
        hoverTooltip = document.getElementById('hover-tooltip-3d');

        isInitialized = true;
        animate();
        console.log('ðŸ§Š Three.js initialized successfully');
    }

    // Mousemove handler for hover detection
    function onMouseMove(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Check nodes, labels, AND hyperedges
        const allClickable = [...nodeMeshes, ...labelSprites, ...hyperedgeMeshes];
        const intersects = raycaster.intersectObjects(allClickable);

        if (intersects.length > 0) {
            let targetMesh = intersects[0].object;

            // Check if it's a hyperedge - show hyperedge tooltip
            if (targetMesh.userData.isHyperedge) {
                if (targetMesh !== hoveredMesh) {
                    if (hoveredMesh) resetHoverState(hoveredMesh);
                    hoveredMesh = targetMesh;
                    applyHyperedgeHoverState(targetMesh);
                    showHyperedgeTooltip(event.clientX, event.clientY, targetMesh.userData.edgeData);
                } else {
                    updateTooltipPosition(event.clientX, event.clientY);
                }
                renderer.domElement.style.cursor = 'pointer';
                return;
            }

            // If we hit a label, find its associated mesh
            if (targetMesh.userData.parentMesh) {
                targetMesh = targetMesh.userData.parentMesh;
            }

            if (targetMesh !== hoveredMesh) {
                // Reset previous hover
                if (hoveredMesh) {
                    resetHoverState(hoveredMesh);
                }

                hoveredMesh = targetMesh;
                applyHoverState(hoveredMesh);
                showHoverTooltip(event.clientX, event.clientY, hoveredMesh.userData.nodeData);
            } else {
                // Update tooltip position
                updateTooltipPosition(event.clientX, event.clientY);
            }

            renderer.domElement.style.cursor = 'pointer';
        } else {
            // No intersection
            if (hoveredMesh) {
                resetHoverState(hoveredMesh);
                hoveredMesh = null;
            }
            hideHoverTooltip();
            renderer.domElement.style.cursor = 'default';
        }

        // Dim distant nodes based on mouse proximity (focus effect)
        applyProximityFocus();
    }

    // Mouse leave handler
    function onMouseLeave() {
        if (hoveredMesh) {
            resetHoverState(hoveredMesh);
            hoveredMesh = null;
        }
        hideHoverTooltip();
        resetProximityFocus();
    }

    // Apply hover magnification
    function applyHoverState(mesh) {
        if (!mesh) return;
        mesh.userData.originalScale = mesh.scale.clone();
        mesh.scale.multiplyScalar(1.4); // Magnify by 40%

        // Also scale up the label
        const label = nodeToLabel.get(mesh);
        if (label) {
            label.userData.originalScale = label.scale.clone();
            label.scale.multiplyScalar(1.3);
        }
    }

    // Reset hover state
    function resetHoverState(mesh) {
        if (!mesh) return;

        // Handle hyperedge hover reset
        if (mesh.userData.isHyperedge && mesh.material) {
            if (mesh.userData.originalOpacity !== undefined) {
                mesh.material.opacity = mesh.userData.originalOpacity;
            } else {
                mesh.material.opacity = 0.4;
            }
            mesh.material.emissiveIntensity = 0.2;
            return;
        }

        // Handle node hover reset
        if (!mesh.userData.originalScale) return;
        mesh.scale.copy(mesh.userData.originalScale);

        const label = nodeToLabel.get(mesh);
        if (label && label.userData.originalScale) {
            label.scale.copy(label.userData.originalScale);
        }
    }

    // Show hover tooltip
    function showHoverTooltip(x, y, nodeData) {
        if (!hoverTooltip || !nodeData) return;

        document.getElementById('hover-tooltip-name').textContent = nodeData.name || 'Unnamed';
        document.getElementById('hover-tooltip-type').textContent = nodeData.type || 'Node';

        // Get description from various possible fields
        const desc = nodeData.description || nodeData.summary || nodeData.details || '';
        document.getElementById('hover-tooltip-desc').textContent = desc ? desc.substring(0, 150) : '';

        hoverTooltip.style.left = x + 'px';
        hoverTooltip.style.top = y + 'px';
        hoverTooltip.classList.add('visible');
    }

    // Update tooltip position
    function updateTooltipPosition(x, y) {
        if (!hoverTooltip) return;
        hoverTooltip.style.left = x + 'px';
        hoverTooltip.style.top = y + 'px';
    }

    // Hide hover tooltip
    function hideHoverTooltip() {
        if (hoverTooltip) {
            hoverTooltip.classList.remove('visible');
        }
    }

    // Apply hover glow to hyperedge tube
    function applyHyperedgeHoverState(mesh) {
        if (!mesh || !mesh.material) return;
        mesh.userData.originalOpacity = mesh.material.opacity;
        mesh.material.opacity = 0.8;
        mesh.material.emissiveIntensity = 0.5;
    }

    // Show hyperedge tooltip
    function showHyperedgeTooltip(x, y, edgeData) {
        if (!hoverTooltip || !edgeData) return;

        const nameEl = document.getElementById('hover-tooltip-name');
        const typeEl = document.getElementById('hover-tooltip-type');
        const descEl = document.getElementById('hover-tooltip-desc');

        if (nameEl) nameEl.textContent = edgeData.label || 'Hyperedge';
        if (typeEl) typeEl.textContent = `ðŸ”— ${edgeData.nodeIds?.length || 0} connected nodes`;
        if (descEl) descEl.textContent = edgeData.description || 'Click to view/edit';

        hoverTooltip.style.left = x + 'px';
        hoverTooltip.style.top = y + 'px';
        hoverTooltip.classList.add('visible');
    }

    // Select a hyperedge - show info panel
    function selectHyperedge(mesh) {
        clearSelection();
        selectedHyperedge = mesh.userData.edgeData;

        // Highlight all tubes of this hyperedge
        hyperedgeMeshes.forEach(m => {
            if (m.userData.edgeData === selectedHyperedge && m.material) {
                m.material.opacity = 0.9;
                m.material.emissiveIntensity = 0.6;
            }
        });

        // Show hyperedge in info panel
        showHyperedgeInfoPanel(selectedHyperedge);
    }

    // Show hyperedge info in the 3D info panel
    function showHyperedgeInfoPanel(edgeData) {
        const panel = document.getElementById('info-panel-3d');
        if (!panel || !edgeData) return;

        // Get node names for display
        const tree = window.capexTree;
        const nodeNames = [];
        if (edgeData.nodeIds && tree) {
            edgeData.nodeIds.forEach(id => {
                const node = findNodeById(tree, id);
                if (node) nodeNames.push(node.name || 'Unnamed');
            });
        }

        panel.innerHTML = `
            <div style="padding: 16px;">
                <div style="font-size: 11px; color: rgba(255,255,255,0.5); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">
                    ðŸ”— Hyperedge
                </div>
                <h3 style="color: #fff; margin: 0 0 12px 0; font-size: 18px;">
                    ${edgeData.label || 'Unnamed Hyperedge'}
                </h3>
                <div style="font-size: 13px; color: rgba(255,255,255,0.7); margin-bottom: 12px;">
                    ${edgeData.description || 'No description'}
                </div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">
                    <strong>Connected Nodes (${nodeNames.length}):</strong>
                </div>
                <ul style="margin: 0; padding-left: 20px; font-size: 12px; color: rgba(255,255,255,0.8);">
                    ${nodeNames.map(n => `<li>${n}</li>`).join('')}
                </ul>
                <button onclick="editHyperedgeFrom3D()" style="
                    margin-top: 16px;
                    padding: 8px 16px;
                    background: rgba(78, 205, 196, 0.3);
                    color: #4ecdc4;
                    border: 1px solid rgba(78, 205, 196, 0.5);
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                    width: 100%;
                ">âœï¸ Edit Hyperedge</button>
            </div>
        `;
        panel.classList.add('visible');
    }

    // Edit hyperedge from 3D view
    window.editHyperedgeFrom3D = function() {
        if (!selectedHyperedge) return;

        // Close 3D view and open hyperedge editor
        const view3D = document.getElementById('view-3d');
        if (view3D) view3D.classList.remove('active');

        // Find and show hyperedge info
        const tree = window.capexTree;
        if (tree && tree.hyperedges) {
            const hyperedge = tree.hyperedges.find(e => e.id === selectedHyperedge.id);
            if (hyperedge && typeof window.showHyperedgeInfo === 'function') {
                window.showHyperedgeInfo(hyperedge);
            }
        }
    };

    // Helper: Find node by ID in tree
    function findNodeById(node, id) {
        if (node.id === id) return node;
        if (node.children) {
            for (const child of node.children) {
                const found = findNodeById(child, id);
                if (found) return found;
            }
        }
        if (node.items) {
            for (const item of node.items) {
                const found = findNodeById(item, id);
                if (found) return found;
            }
        }
        if (node.subItems) {
            for (const sub of node.subItems) {
                const found = findNodeById(sub, id);
                if (found) return found;
            }
        }
        return null;
    }

    // Apply proximity-based focus (dim distant nodes)
    function applyProximityFocus() {
        if (!hoveredMesh) return;

        const hoverPos = hoveredMesh.position;
        const focusRadius = 500; // Nodes within this radius stay bright

        nodeMeshes.forEach(mesh => {
            if (mesh === hoveredMesh || mesh === selectedMesh) return;

            const distance = mesh.position.distanceTo(hoverPos);
            const opacity = distance < focusRadius ? 1 : Math.max(0.3, 1 - (distance - focusRadius) / 1000);

            if (mesh.material) {
                mesh.material.opacity = opacity;
                mesh.material.transparent = true;
            }
        });
    }

    // Reset proximity focus
    function resetProximityFocus() {
        nodeMeshes.forEach(mesh => {
            if (mesh.material && mesh.material.opacity !== undefined) {
                mesh.material.opacity = 1;
            }
        });
    }

    // Right-click handler for context menu
    function onNodeRightClick(event) {
        event.preventDefault();

        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(nodeMeshes);

        if (intersects.length > 0) {
            const clickedMesh = intersects[0].object;
            contextMenuNode = clickedMesh.userData.nodeData;
            selectNode(clickedMesh);
            showContextMenu(event.clientX, event.clientY);
        } else {
            hideContextMenu();
        }
    }

    // Show context menu at position
    function showContextMenu(x, y) {
        const menu = document.getElementById('context-menu-3d');
        if (!menu) return;

        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        menu.classList.add('visible');

        // Update expand/collapse visibility based on node
        const expandItem = menu.querySelector('[data-action="expand"]');
        const collapseItem = menu.querySelector('[data-action="collapse"]');

        if (contextMenuNode) {
            const hasChildren = (contextMenuNode.children && contextMenuNode.children.length > 0) ||
                              (contextMenuNode.items && contextMenuNode.items.length > 0) ||
                              (contextMenuNode.subItems && contextMenuNode.subItems.length > 0);

            if (expandItem) expandItem.style.display = hasChildren ? 'flex' : 'none';
            if (collapseItem) collapseItem.style.display = hasChildren ? 'flex' : 'none';
        }
    }

    // Hide context menu
    function hideContextMenu() {
        const menu = document.getElementById('context-menu-3d');
        if (menu) menu.classList.remove('visible');
        contextMenuNode = null;
    }

    // Initialize context menu action handlers
    function initContextMenuHandlers() {
        const menu = document.getElementById('context-menu-3d');
        if (!menu) return;

        menu.addEventListener('click', (e) => {
            const item = e.target.closest('.context-menu-3d-item');
            if (!item || !contextMenuNode) return;

            const action = item.dataset.action;
            handleContextMenuAction(action, contextMenuNode);
            hideContextMenu();
        });
    }

    // Handle context menu action
    function handleContextMenuAction(action, node) {
        console.log('ðŸ§Š Context action:', action, 'on node:', node.name);

        switch (action) {
            case 'edit':
                // Open the info panel for editing
                if (typeof window.showInfo === 'function') {
                    window.showInfo(node);
                }
                // Also try to focus the edit modal if available
                if (typeof window.editNode === 'function') {
                    window.editNode(node.id);
                }
                break;

            case 'expand':
                expandedNodes.add(node.id);
                refresh3DData();
                break;

            case 'collapse':
                expandedNodes.delete(node.id);
                refresh3DData();
                break;

            case 'add-child':
                if (typeof window.addChild === 'function') {
                    window.addChild(node.id);
                    setTimeout(() => refresh3DData(), 100);
                }
                break;

            case 'add-sibling':
                if (typeof window.addSibling === 'function') {
                    window.addSibling(node.id);
                    setTimeout(() => refresh3DData(), 100);
                }
                break;

            case 'add-hyperedge':
                if (typeof window.showToast === 'function') {
                    window.showToast('Select another node to create hyperedge', 'info');
                }
                // Store first node for hyperedge creation
                window._hyperedgeStartNode = node.id;
                break;

            case 'add-dependency':
                if (typeof window.showToast === 'function') {
                    window.showToast('Select target node for dependency', 'info');
                }
                window._dependencyStartNode = node.id;
                break;

            case 'delete':
                if (confirm(`Delete "${node.name}"?`)) {
                    if (typeof window.deleteNode === 'function') {
                        window.deleteNode(node.id);
                        setTimeout(() => refresh3DData(), 100);
                    }
                }
                break;
        }
    }

    // Handle click on 3D node or hyperedge
    function onNodeClick(event) {
        // Calculate mouse position in normalized device coordinates
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Check nodes, labels, AND hyperedges for click
        const allClickable = [...nodeMeshes, ...labelSprites, ...hyperedgeMeshes];
        const intersects = raycaster.intersectObjects(allClickable);

        if (intersects.length > 0) {
            let clickedMesh = intersects[0].object;

            // Check if it's a hyperedge
            if (clickedMesh.userData.isHyperedge) {
                selectHyperedge(clickedMesh);
                return;
            }

            // If clicked on a label, get its parent mesh
            if (clickedMesh.userData.parentMesh) {
                clickedMesh = clickedMesh.userData.parentMesh;
            }
            selectNode(clickedMesh);
        }
    }

    // Double-click to reset to root
    function onNodeDoubleClick(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const allClickable = [...nodeMeshes, ...labelSprites];
        const intersects = raycaster.intersectObjects(allClickable);

        if (intersects.length === 0) {
            // Double-click on empty space - reset to root
            controls.target.set(0, 0, 0);
            clearSelection();
        }
    }

    // Select a node: change orbit target, highlight, show info panel
    function selectNode(mesh) {
        // Clear previous selection glow
        clearSelection();

        selectedMesh = mesh;
        const position = mesh.position.clone();
        const nodeData = mesh.userData.nodeData;

        // Set orbit controls to pivot around this node
        controls.target.copy(position);

        // Create selection glow
        const glowSize = mesh.geometry.parameters.radius * 2.5;
        const glowGeometry = new THREE.SphereGeometry(glowSize, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        selectionGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        selectionGlow.position.copy(position);
        scene.add(selectionGlow);

        // Show infographic panel for this node
        if (nodeData && typeof window.showInfo === 'function') {
            window.showInfo(nodeData);
        }

        console.log('ðŸ§Š Selected node:', nodeData?.name || 'Unknown');
    }

    // Clear selection highlight
    function clearSelection() {
        if (selectionGlow) {
            scene.remove(selectionGlow);
            selectionGlow.geometry.dispose();
            selectionGlow.material.dispose();
            selectionGlow = null;
        }
        selectedMesh = null;
    }

    // Expand all nodes - collect all node IDs
    function expandAllNodes() {
        const tree = window.capexTree;
        if (!tree) return;

        function collectNodeIds(node) {
            if (node.id) expandedNodes.add(node.id);
            if (node.children) node.children.forEach(collectNodeIds);
            if (node.items) node.items.forEach(collectNodeIds);
            if (node.subItems) node.subItems.forEach(collectNodeIds);
        }

        collectNodeIds(tree);
        refresh3DData();
        save3DViewState();
        console.log('ðŸ§Š Expanded all nodes:', expandedNodes.size);
    }

    // Collapse all nodes
    function collapseAllNodes() {
        expandedNodes.clear();
        refresh3DData();
        save3DViewState();
        console.log('ðŸ§Š Collapsed all nodes');
    }

    // Save 3D view state to tree metadata
    function save3DViewState() {
        const tree = window.capexTree;
        if (!tree || !camera || !controls) return;

        tree.view3DState = {
            camera: {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            },
            target: {
                x: controls.target.x,
                y: controls.target.y,
                z: controls.target.z
            },
            expandedNodes: Array.from(expandedNodes),
            autoSpin: autoSpin
        };

        console.log('ðŸ§Š Saved 3D view state');
    }

    // Restore 3D view state from tree metadata
    function restore3DViewState() {
        const tree = window.capexTree;
        if (!tree || !tree.view3DState || !camera || !controls) return;

        const state = tree.view3DState;

        // Restore camera position
        if (state.camera) {
            camera.position.set(state.camera.x, state.camera.y, state.camera.z);
        }

        // Restore orbit target
        if (state.target) {
            controls.target.set(state.target.x, state.target.y, state.target.z);
        }

        // Restore expanded nodes
        if (state.expandedNodes && Array.isArray(state.expandedNodes)) {
            expandedNodes.clear();
            state.expandedNodes.forEach(id => expandedNodes.add(id));
        }

        // Restore auto-spin
        if (typeof state.autoSpin === 'boolean') {
            autoSpin = state.autoSpin;
            const spinBtn = document.getElementById('btn-3d-spin');
            if (spinBtn) spinBtn.style.background = autoSpin ? '#10b981' : '';
        }

        console.log('ðŸ§Š Restored 3D view state');
    }

    function addStarfield() {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const colors = [];

        for (let i = 0; i < 3000; i++) {
            vertices.push(
                THREE.MathUtils.randFloatSpread(5000),
                THREE.MathUtils.randFloatSpread(5000),
                THREE.MathUtils.randFloatSpread(5000)
            );
            // Vary star colors slightly (white to blue-white)
            const brightness = 0.3 + Math.random() * 0.7;
            colors.push(brightness, brightness, brightness + Math.random() * 0.2);
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(geometry, material);
        stars.userData.isBackground = true;
        scene.add(stars);

        // Add nebula clouds based on pattern
        addNebulaClouds();
    }

    // Add nebula clouds for atmosphere
    function addNebulaClouds() {
        const tree = window.capexTree;
        const pattern = tree?.pattern || 'default';
        const theme = NEBULA_THEMES[pattern] || NEBULA_THEMES['default'];

        // Create multiple nebula cloud layers
        for (let i = 0; i < 5; i++) {
            const nebulaGeometry = new THREE.SphereGeometry(1500 + i * 400, 32, 32);
            const nebulaMaterial = new THREE.MeshBasicMaterial({
                color: i % 2 === 0 ? theme.primary : theme.secondary,
                transparent: true,
                opacity: 0.03 - i * 0.004,
                side: THREE.BackSide
            });
            const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            nebula.position.set(
                THREE.MathUtils.randFloatSpread(500),
                THREE.MathUtils.randFloatSpread(500),
                THREE.MathUtils.randFloatSpread(1000)
            );
            nebula.userData.isBackground = true;
            scene.add(nebula);
        }

        // Add accent glow spots
        for (let i = 0; i < 3; i++) {
            const glowGeometry = new THREE.SphereGeometry(200 + Math.random() * 300, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: theme.accent,
                transparent: true,
                opacity: 0.08
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.set(
                THREE.MathUtils.randFloatSpread(2000),
                THREE.MathUtils.randFloatSpread(1500),
                THREE.MathUtils.randFloatSpread(2000)
            );
            glow.userData.isBackground = true;
            scene.add(glow);
        }
    }

    // --- 4. The Core Logic: Data to 3D ---
    function refresh3DData() {
        // Clear existing tree objects (keep stars/lights/nebula)
        scene.children = scene.children.filter(obj => obj.type === 'Points' || obj.isLight || obj.userData?.isBackground);
        sunCorona = null; // Reset corona reference
        // Clear labels
        const labels = document.querySelectorAll('.node-3d-label');
        labels.forEach(el => el.remove()); // DOM cleanup

        // Clear tracking arrays
        nodeMeshes.length = 0;
        nodePositions.clear();
        labelSprites.length = 0;
        nodeToLabel.clear();
        hyperedgeMeshes.length = 0;
        selectedHyperedge = null;
        clearSelection();
        hoveredMesh = null;

        // Grab Global Tree
        const tree = window.capexTree;
        if (!tree) return;

        // --- Render Root ---
        createNode(tree, 0, 0, 0, 0xffffff, 'root');

        // --- Determine Layout Mode based on Sort ---
        const sortConfig = window.currentSortConfig;
        const layoutMode = determineLayoutMode(sortConfig);

        // --- Render Phases & Items based on Layout Mode ---
        if (tree.children) {
            let globalItemIndex = 0;
            let allItems = []; // Collect all items for sorted layouts

            // Collect all items with their phase info for sorted layouts
            if (layoutMode !== 'helix') {
                tree.children.forEach((phase, pIdx) => {
                    const phaseColor = CONFIG.colorPalette[pIdx % CONFIG.colorPalette.length];
                    if (phase.items) {
                        phase.items.forEach(item => {
                            allItems.push({ item, phase, pIdx, phaseColor });
                        });
                    }
                });
            }

            if (layoutMode === 'helix') {
                // DEFAULT: Original Helix Layout
                tree.children.forEach((phase, pIdx) => {
                    const phaseColor = CONFIG.colorPalette[pIdx % CONFIG.colorPalette.length];
                    const phaseZ = (pIdx + 1) * CONFIG.phaseSpacingZ;

                    createNode(phase, 0, 0, phaseZ, phaseColor, 'phase');

                    const prevPos = pIdx === 0 ? new THREE.Vector3(0,0,0) : new THREE.Vector3(0,0, pIdx * CONFIG.phaseSpacingZ);
                    createConnection(prevPos, new THREE.Vector3(0,0, phaseZ), 0x555555, 1);

                    if (phase.items) {
                        phase.items.forEach((item, iIdx) => {
                            const angle = globalItemIndex * 0.8;
                            const radius = CONFIG.helixRadius;
                            const x = Math.cos(angle) * radius;
                            const y = (iIdx * CONFIG.verticalSpacing) - ((phase.items.length * CONFIG.verticalSpacing)/2);
                            const z = phaseZ + (Math.sin(angle) * 100);

                            createNode(item, x, y, z, phaseColor, 'item');
                            createConnection(new THREE.Vector3(0,0,phaseZ), new THREE.Vector3(x,y,z), phaseColor, 0.3);

                            renderSubtasks(item, x, y, z, phaseColor);
                            globalItemIndex++;
                        });
                    }
                });

            } else if (layoutMode === 'tower') {
                // NUMERIC SORT: Tower/Skyscraper Layout - Y position = value
                const field = sortConfig.field;
                const values = allItems.map(a => parseFloat(a.item[field]) || 0);
                const maxVal = Math.max(...values, 1);
                const minVal = Math.min(...values, 0);
                const range = maxVal - minVal || 1;

                // Render phases as rings at base
                tree.children.forEach((phase, pIdx) => {
                    const phaseColor = CONFIG.colorPalette[pIdx % CONFIG.colorPalette.length];
                    const ringAngle = (pIdx / tree.children.length) * Math.PI * 2;
                    const ringRadius = 300;
                    const px = Math.cos(ringAngle) * ringRadius;
                    const pz = Math.sin(ringAngle) * ringRadius;
                    createNode(phase, px, -200, pz, phaseColor, 'phase');
                    createConnection(new THREE.Vector3(0,0,0), new THREE.Vector3(px,-200,pz), 0x555555, 0.5);
                });

                // Items arranged by value - higher value = higher position
                allItems.forEach((a, idx) => {
                    const val = parseFloat(a.item[field]) || 0;
                    const normalizedY = ((val - minVal) / range) * 800 - 200; // -200 to 600
                    const angle = (idx / allItems.length) * Math.PI * 2;
                    const radius = 200 + (normalizedY + 200) * 0.3; // Wider at top
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;

                    createNode(a.item, x, normalizedY, z, a.phaseColor, 'item');

                    // Connect to center pillar at same height
                    createConnection(new THREE.Vector3(0, normalizedY, 0), new THREE.Vector3(x, normalizedY, z), a.phaseColor, 0.2);

                    renderSubtasks(a.item, x, normalizedY, z, a.phaseColor);
                });

                // Add central pillar
                const pillarGeometry = new THREE.CylinderGeometry(5, 5, 1000, 16);
                const pillarMaterial = new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                pillar.position.set(0, 200, 0);
                scene.add(pillar);

            } else if (layoutMode === 'cluster') {
                // CATEGORY SORT: Cluster Layout - Group by value
                const field = sortConfig.field;
                const groups = {};

                allItems.forEach(a => {
                    const key = String(a.item[field] || 'Unknown');
                    if (!groups[key]) groups[key] = [];
                    groups[key].push(a);
                });

                const groupKeys = Object.keys(groups);
                const groupColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xaa96da, 0xf38181, 0x6c5ce7, 0x00b894];

                // Render phases in center ring
                tree.children.forEach((phase, pIdx) => {
                    const phaseColor = CONFIG.colorPalette[pIdx % CONFIG.colorPalette.length];
                    const angle = (pIdx / tree.children.length) * Math.PI * 2;
                    const px = Math.cos(angle) * 150;
                    const pz = Math.sin(angle) * 150;
                    createNode(phase, px, 0, pz, phaseColor, 'phase');
                    createConnection(new THREE.Vector3(0,0,0), new THREE.Vector3(px,0,pz), 0x555555, 0.5);
                });

                // Each group gets its own cluster sphere in space
                groupKeys.forEach((key, gIdx) => {
                    const groupItems = groups[key];
                    const groupAngle = (gIdx / groupKeys.length) * Math.PI * 2;
                    const groupRadius = 600;
                    const groupColor = groupColors[gIdx % groupColors.length];

                    // Group center position
                    const gx = Math.cos(groupAngle) * groupRadius;
                    const gz = Math.sin(groupAngle) * groupRadius;
                    const gy = 0;

                    // Create group marker (larger translucent sphere)
                    const groupGeometry = new THREE.SphereGeometry(80, 32, 32);
                    const groupMaterial = new THREE.MeshBasicMaterial({
                        color: groupColor,
                        transparent: true,
                        opacity: 0.15
                    });
                    const groupSphere = new THREE.Mesh(groupGeometry, groupMaterial);
                    groupSphere.position.set(gx, gy, gz);
                    scene.add(groupSphere);

                    // Add group label
                    const groupLabel = createTextSprite(key, groupColor);
                    groupLabel.position.set(gx, gy + 120, gz);
                    groupLabel.scale.set(250, 60, 1);
                    scene.add(groupLabel);

                    // Connect group to root
                    createConnection(new THREE.Vector3(0,0,0), new THREE.Vector3(gx, gy, gz), groupColor, 0.15);

                    // Arrange items within the group cluster
                    groupItems.forEach((a, iIdx) => {
                        const itemAngle = (iIdx / groupItems.length) * Math.PI * 2;
                        const itemRadius = 60 + groupItems.length * 8;
                        const ix = gx + Math.cos(itemAngle) * itemRadius;
                        const iy = gy + (Math.random() - 0.5) * 100;
                        const iz = gz + Math.sin(itemAngle) * itemRadius;

                        createNode(a.item, ix, iy, iz, a.phaseColor, 'item');
                        createConnection(new THREE.Vector3(gx, gy, gz), new THREE.Vector3(ix, iy, iz), a.phaseColor, 0.2);

                        renderSubtasks(a.item, ix, iy, iz, a.phaseColor);
                    });
                });

            } else if (layoutMode === 'timeline') {
                // DATE SORT: Timeline Layout - Z position = time
                const field = sortConfig.field;
                const dates = allItems.map(a => new Date(a.item[field] || 0).getTime());
                const minDate = Math.min(...dates);
                const maxDate = Math.max(...dates);
                const dateRange = maxDate - minDate || 1;

                // Render phases as waypoints along timeline
                tree.children.forEach((phase, pIdx) => {
                    const phaseColor = CONFIG.colorPalette[pIdx % CONFIG.colorPalette.length];
                    const phaseZ = (pIdx / tree.children.length) * 1500 - 500;
                    createNode(phase, 0, 100, phaseZ, phaseColor, 'phase');
                });

                // Items arranged along Z-axis by date
                allItems.forEach((a, idx) => {
                    const dateVal = new Date(a.item[field] || 0).getTime();
                    const normalizedZ = ((dateVal - minDate) / dateRange) * 1500 - 500;
                    const angle = idx * 0.5;
                    const radius = 250;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * 80;

                    createNode(a.item, x, y, normalizedZ, a.phaseColor, 'item');

                    // Connect to timeline axis
                    createConnection(new THREE.Vector3(0, 0, normalizedZ), new THREE.Vector3(x, y, normalizedZ), a.phaseColor, 0.2);

                    renderSubtasks(a.item, x, y, normalizedZ, a.phaseColor);
                });

                // Add timeline axis
                const axisGeometry = new THREE.CylinderGeometry(3, 3, 1600, 8);
                const axisMaterial = new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5 });
                const axis = new THREE.Mesh(axisGeometry, axisMaterial);
                axis.rotation.x = Math.PI / 2;
                axis.position.set(0, 0, 250);
                scene.add(axis);
            }
        }

        // Helper: Render subtasks for an item
        function renderSubtasks(item, x, y, z, phaseColor) {
            if (item.subItems) {
                item.subItems.forEach((sub, sIdx) => {
                    const subRadius = 120;
                    const subAngle = (sIdx / item.subItems.length) * Math.PI * 2;
                    const sx = x + Math.cos(subAngle) * subRadius;
                    const sy = y + Math.sin(subAngle) * subRadius;
                    const sz = z + 50;

                    createNode(sub, sx, sy, sz, phaseColor, 'subtask');
                    createConnection(new THREE.Vector3(x,y,z), new THREE.Vector3(sx,sy,sz), phaseColor, 0.2);
                });
            }
        }

        // --- Render Hyperedges (3D Tube Shapes) ---
        if (tree.hyperedges) {
            const hyperedgeColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da];

            tree.hyperedges.forEach((edge, edgeIndex) => {
                // Use edge color or assign from palette
                const colorHex = edge.color ? parseInt(edge.color.replace('#', ''), 16) : hyperedgeColors[edgeIndex % hyperedgeColors.length];

                if (edge.nodeIds && edge.nodeIds.length >= 2) {
                    const positions = edge.nodeIds.map(id => nodePositions.get(id)).filter(p => p);

                    if (positions.length >= 2) {
                        // For 2 nodes, draw a single curved tube
                        // For 3+ nodes, draw tubes connecting all nodes through a central hub

                        if (positions.length === 2) {
                            // Simple curve between two points
                            createHyperedgeTube(positions[0], positions[1], colorHex, edge.label, edge);
                        } else {
                            // Multi-node hyperedge: create central hub and connect all nodes to it
                            const centroid = new THREE.Vector3();
                            positions.forEach(p => centroid.add(p));
                            centroid.divideScalar(positions.length);
                            centroid.y += 150; // Lift the hub above

                            // Create central hub sphere
                            const hubGeometry = new THREE.SphereGeometry(15, 16, 16);
                            const hubMaterial = new THREE.MeshBasicMaterial({
                                color: colorHex,
                                transparent: true,
                                opacity: 0.6
                            });
                            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                            hub.position.copy(centroid);
                            hub.userData = { isHyperedge: true, edgeData: edge, colorHex: colorHex, isHub: true };
                            scene.add(hub);
                            hyperedgeMeshes.push(hub); // Hub is also clickable

                            // Connect all nodes to the hub
                            positions.forEach(pos => {
                                createHyperedgeTube(pos, centroid, colorHex, null, edge);
                            });

                            // Add label at hub if available
                            if (edge.label) {
                                const labelSprite = createTextSprite(edge.label, colorHex);
                                labelSprite.position.set(centroid.x, centroid.y + 40, centroid.z);
                                labelSprite.scale.set(150, 37, 1);
                                labelSprite.userData = { isHyperedge: true, edgeData: edge, parentHub: hub };
                                scene.add(labelSprite);
                                hyperedgeMeshes.push(labelSprite);
                            }
                        }
                    }
                }
            });
        }

        // --- Render Dependencies (Dashed Arrows) ---
        renderDependencies(tree);
    }

    // Render dependencies as dashed arrows
    function renderDependencies(tree) {
        // Collect all dependencies from nodes
        function collectDependencies(node, deps = []) {
            if (node.dependencies && Array.isArray(node.dependencies)) {
                node.dependencies.forEach(dep => {
                    deps.push({
                        from: dep.sourceId || dep.from,
                        to: node.id,
                        label: dep.label || dep.type || ''
                    });
                });
            }
            // Also check for outgoing dependencies
            if (node.dependsOn && Array.isArray(node.dependsOn)) {
                node.dependsOn.forEach(targetId => {
                    deps.push({
                        from: node.id,
                        to: targetId,
                        label: ''
                    });
                });
            }
            if (node.children) node.children.forEach(c => collectDependencies(c, deps));
            if (node.items) node.items.forEach(i => collectDependencies(i, deps));
            if (node.subItems) node.subItems.forEach(s => collectDependencies(s, deps));
            return deps;
        }

        const dependencies = collectDependencies(tree);

        dependencies.forEach(dep => {
            const fromPos = nodePositions.get(dep.from);
            const toPos = nodePositions.get(dep.to);

            if (fromPos && toPos) {
                createDependencyArrow(fromPos, toPos, dep.label);
            }
        });
    }

    // Create a dashed arrow for dependency
    function createDependencyArrow(start, end, label) {
        const direction = new THREE.Vector3().subVectors(end, start);
        const length = direction.length();

        // Create dashed line
        const points = [];
        const segments = 20;
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const point = new THREE.Vector3().lerpVectors(start, end, t);
            // Add slight arc
            point.y += Math.sin(t * Math.PI) * length * 0.1;
            points.push(point);
        }

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineDashedMaterial({
            color: 0xff9900, // Orange for dependencies
            dashSize: 15,
            gapSize: 10,
            transparent: true,
            opacity: 0.7
        });

        const line = new THREE.Line(geometry, material);
        line.computeLineDistances(); // Required for dashed lines
        scene.add(line);

        // Add arrowhead at destination
        const arrowDir = direction.clone().normalize();
        const arrowLength = 20;
        const arrowColor = 0xff9900;

        // Position arrowhead slightly before the end point
        const arrowPos = end.clone().sub(arrowDir.clone().multiplyScalar(15));

        const arrowHelper = new THREE.ArrowHelper(
            arrowDir,
            arrowPos,
            arrowLength,
            arrowColor,
            arrowLength * 0.6,
            arrowLength * 0.4
        );
        scene.add(arrowHelper);

        // Add label if provided
        if (label) {
            const midPoint = new THREE.Vector3().lerpVectors(start, end, 0.5);
            midPoint.y += length * 0.1 + 20; // Above the arc
            const labelSprite = createTextSprite(label, 0xff9900);
            labelSprite.position.copy(midPoint);
            labelSprite.scale.set(120, 30, 1);
            scene.add(labelSprite);
        }
    }

    // Helper: Create hyperedge tube between two points
    function createHyperedgeTube(start, end, colorHex, label, edgeData) {
        // Calculate a graceful arc midpoint
        const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
        const distance = start.distanceTo(end);
        mid.y += distance * 0.3; // Arc proportional to distance

        const curve = new THREE.QuadraticBezierCurve3(start, mid, end);

        // Create tube geometry along the curve
        const tubeGeometry = new THREE.TubeGeometry(curve, 32, 8, 8, false);
        const tubeMaterial = new THREE.MeshPhongMaterial({
            color: colorHex,
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide,
            emissive: colorHex,
            emissiveIntensity: 0.2
        });
        const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
        tube.userData = { isHyperedge: true, edgeData: edgeData, colorHex: colorHex };
        scene.add(tube);

        // Track for raycasting
        hyperedgeMeshes.push(tube);

        // Add label at midpoint if provided
        if (label) {
            const labelSprite = createTextSprite(label, colorHex);
            labelSprite.position.copy(mid);
            labelSprite.position.y += 30;
            labelSprite.scale.set(150, 37, 1);
            labelSprite.userData = { isHyperedge: true, edgeData: edgeData, parentTube: tube };
            scene.add(labelSprite);
            hyperedgeMeshes.push(labelSprite); // Also make label clickable
        }

        return tube;
    }

    // Helper: Create text label sprite
    function createTextSprite(text, colorHex) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 128;

        // Background
        context.fillStyle = 'rgba(0, 0, 0, 0.7)';
        context.roundRect(0, 0, canvas.width, canvas.height, 10);
        context.fill();

        // Border
        context.strokeStyle = '#' + colorHex.toString(16).padStart(6, '0');
        context.lineWidth = 4;
        context.roundRect(2, 2, canvas.width - 4, canvas.height - 4, 8);
        context.stroke();

        // Text
        context.font = 'bold 36px Arial';
        context.fillStyle = '#ffffff';
        context.textAlign = 'center';
        context.textBaseline = 'middle';

        // Truncate text if too long
        let displayText = text || 'Unnamed';
        if (displayText.length > 25) {
            displayText = displayText.substring(0, 22) + '...';
        }
        context.fillText(displayText, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(200, 50, 1);
        return sprite;
    }

    // Helper: Create Visual Node
    function createNode(data, x, y, z, colorHex, type) {
        const position = new THREE.Vector3(x, y, z);
        nodePositions.set(data.id, position);

        // Size based on type
        const size = type === 'root' ? 30 : type === 'phase' ? 20 : type === 'item' ? 12 : 8;

        // Create glowing sphere
        const geometry = new THREE.SphereGeometry(size, 32, 32);

        // Special materials for root (sun) and phases (planets)
        let material;
        if (type === 'root') {
            // Sun - bright yellow/orange with intense glow
            material = new THREE.MeshBasicMaterial({
                color: 0xffdd44,
                transparent: false
            });
        } else {
            material = new THREE.MeshPhongMaterial({
                color: colorHex,
                emissive: colorHex,
                emissiveIntensity: 0.3,
                shininess: 100
            });
        }

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(position);
        mesh.userData = { nodeData: data, type: type, colorHex: colorHex };
        scene.add(mesh);

        // Track mesh for raycasting
        nodeMeshes.push(mesh);

        // ROOT: Add animated sun corona
        if (type === 'root') {
            // Inner corona glow
            const coronaGeometry1 = new THREE.SphereGeometry(size * 1.4, 32, 32);
            const coronaMaterial1 = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.4,
                side: THREE.BackSide
            });
            const corona1 = new THREE.Mesh(coronaGeometry1, coronaMaterial1);
            corona1.position.copy(position);
            scene.add(corona1);

            // Outer corona glow (animated)
            const coronaGeometry2 = new THREE.SphereGeometry(size * 2, 32, 32);
            const coronaMaterial2 = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            sunCorona = new THREE.Mesh(coronaGeometry2, coronaMaterial2);
            sunCorona.position.copy(position);
            scene.add(sunCorona);

            // Sun flare ring
            const flareGeometry = new THREE.RingGeometry(size * 2.5, size * 3.5, 64);
            const flareMaterial = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const flare = new THREE.Mesh(flareGeometry, flareMaterial);
            flare.position.copy(position);
            flare.lookAt(camera.position);
            scene.add(flare);
        }

        // PHASE: Add planetary rings
        if (type === 'phase') {
            // Main planetary ring
            const ringGeometry = new THREE.RingGeometry(size * 1.8, size * 2.8, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(position);
            ring.rotation.x = Math.PI / 2.5; // Tilt the ring
            ring.rotation.z = Math.random() * 0.5; // Slight random tilt
            scene.add(ring);

            // Outer faint ring
            const outerRingGeometry = new THREE.RingGeometry(size * 3, size * 3.5, 64);
            const outerRingMaterial = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
            outerRing.position.copy(position);
            outerRing.rotation.x = Math.PI / 2.5;
            outerRing.rotation.z = ring.rotation.z;
            scene.add(outerRing);

            // Atmospheric glow
            const atmoGeometry = new THREE.SphereGeometry(size * 1.15, 32, 32);
            const atmoMaterial = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmoGeometry, atmoMaterial);
            atmosphere.position.copy(position);
            scene.add(atmosphere);
        }

        // Add text label sprite
        const label = createTextSprite(data.name, type === 'root' ? 0xffdd44 : colorHex);
        label.position.set(x, y + size + 40, z);
        label.userData.parentMesh = mesh; // Link label to its node mesh
        label.userData.nodeData = data; // Store node data on label too
        scene.add(label);

        // Register label for raycasting (clickable labels)
        labelSprites.push(label);
        nodeToLabel.set(mesh, label);
    }

    // Helper: Create Connection Line
    function createConnection(v1, v2, color, opacity) {
        const material = new THREE.LineBasicMaterial({
            color: color,
            opacity: opacity,
            transparent: true
        });
        const points = [v1, v2];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line);
    }

    function onWindowResize() {
        if (!camera || !renderer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        // Animate sun corona pulsing
        if (sunCorona) {
            coronaTime += 0.02;
            const pulse = 1 + Math.sin(coronaTime) * 0.15;
            sunCorona.scale.setScalar(pulse);
            sunCorona.material.opacity = 0.15 + Math.sin(coronaTime * 1.5) * 0.08;
        }

        // Auto-spin
        if (autoSpin && controls) {
            controls.autoRotate = true;
            controls.autoRotateSpeed = 2.0;
        } else if (controls) {
            controls.autoRotate = false;
        }

        if (controls) controls.update();
        if (renderer && scene && camera) {
            renderer.render(scene, camera);
        }
    }

    // Initialize 3D button handler - ensure DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init3DButton);
    } else {
        init3DButton();
    }

    // Also try after a short delay as fallback
    setTimeout(init3DButton, 500);

    // Expose refresh3DData to global scope for sort integration
    window.refresh3DData = refresh3DData;

})(); // End IIFE
</script>

</body>
</html>
<!-- Cache buster: 1764725799 -->
