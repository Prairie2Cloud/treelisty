/**
 * Comparative Ranking Test
 *
 * Instead of scoring trees independently (which leads to similar scores),
 * this test asks the evaluator to RANK all trees against each other
 * and identify the specific features that make winners better.
 */

import dotenv from 'dotenv';
import Anthropic from '@anthropic-ai/sdk';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename_temp = fileURLToPath(import.meta.url);
const __dirname_temp = path.dirname(__filename_temp);
dotenv.config({ path: path.join(__dirname_temp, '../../.env') });

let GoogleGenerativeAI;
try {
  const googleModule = await import('@google/generative-ai');
  GoogleGenerativeAI = googleModule.GoogleGenerativeAI;
} catch (e) {}

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const MOCK_AI = process.env.MOCK_AI !== 'false';
const OUTPUT_DIR = path.join(__dirname, '../../test-results/comparative-ranking');

if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Load previous results
const previousResults = JSON.parse(
  fs.readFileSync(path.join(__dirname, '../../test-results/angel-investor-test/angel-pitch-results.json'), 'utf-8')
);

const anthropic = !MOCK_AI ? new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY }) : null;
const gemini = !MOCK_AI && GoogleGenerativeAI ? new GoogleGenerativeAI(process.env.GEMINI_API_KEY) : null;

/**
 * Build comparative ranking prompt
 */
function buildRankingPrompt(trees) {
  const treeSummaries = trees.map((t, i) => `
=== TREE ${i + 1}: ${t.personaName} ===
Persona Hypothesis: ${t.hypothesis}

Tree Structure:
${JSON.stringify(t.tree, null, 2).substring(0, 3000)}...
`).join('\n\n');

  return `You are an angel investor evaluating ${trees.length} different CAPEX tree structures for the SAME project (Prairie Power Compute - $2.8M microgrid data center).

Each tree was generated by a different AI persona. Your job is to RANK them from best to worst for investor presentations and identify SPECIFIC features that make the winners better.

${treeSummaries}

EVALUATION CRITERIA (Angel Investor Perspective):
1. FUNDING STORY (30%): How clearly does the tree show what each funding phase buys?
2. RISK TRANSPARENCY (25%): Are risks surfaced honestly with credible mitigations?
3. RETURN NARRATIVE (25%): Is the path to returns clear?
4. COMPETITIVE MOAT (20%): Does the structure highlight competitive advantages?

YOUR TASK:
1. Rank all ${trees.length} trees from BEST to WORST
2. For each tree, identify 2-3 SPECIFIC features that made it better or worse
3. Extract the WINNING ELEMENTS that should be combined into an optimal prompt

OUTPUT FORMAT (JSON only):
{
  "rankings": [
    {
      "rank": 1,
      "personaName": "Name",
      "score": 0.92,
      "standoutFeatures": [
        "Specific feature that made this tree better",
        "Another specific feature"
      ],
      "weaknesses": ["What could be improved"]
    },
    {
      "rank": 2,
      ...
    }
  ],
  "winningElements": {
    "fundingStoryBest": "What the best tree did for funding story",
    "riskTransparencyBest": "What the best tree did for risk transparency",
    "returnNarrativeBest": "What the best tree did for return narrative",
    "competitiveMoatBest": "What the best tree did for competitive moat"
  },
  "optimalPromptElements": [
    "Key element to include in optimal prompt",
    "Another key element",
    "Third key element"
  ],
  "synthesizedPrompt": "A synthesized prompt combining the best elements from all winning trees (2-3 paragraphs)"
}

BE DISCRIMINATING - there must be meaningful differences in scores (at least 10% spread between best and worst).`;
}

async function runComparativeRanking() {
  console.log('\nüèÜ Comparative Ranking Analysis');
  console.log('=' .repeat(60));
  console.log('Analyzing previously generated trees...\n');

  const prompt = buildRankingPrompt(previousResults);

  let ranking;
  if (MOCK_AI) {
    console.log('[MOCK] Generating comparative ranking...');
    ranking = {
      rankings: previousResults.map((t, i) => ({
        rank: i + 1,
        personaName: t.personaName,
        score: 0.92 - (i * 0.03),
        standoutFeatures: ["Feature 1", "Feature 2"],
        weaknesses: ["Weakness 1"]
      })),
      winningElements: {
        fundingStoryBest: "Clear phase-to-series alignment",
        riskTransparencyBest: "Risks embedded in phase structure",
        returnNarrativeBest: "Revenue milestones as phase gates",
        competitiveMoatBest: "Cost advantage highlighted in item descriptions"
      },
      optimalPromptElements: [
        "Align phases with funding series",
        "Embed risks with mitigations in structure",
        "Use milestones as phase gates"
      ],
      synthesizedPrompt: "Mock synthesized prompt"
    };
  } else {
    console.log('Sending to Gemini for comparative analysis...');
    const model = gemini.getGenerativeModel({ model: 'gemini-2.0-flash' });
    const result = await model.generateContent(prompt);
    const content = result.response.text();

    try {
      const jsonMatch = content.match(/```json\n?([\s\S]*?)\n?```/) ||
                        content.match(/```\n?([\s\S]*?)\n?```/);
      const jsonStr = jsonMatch ? jsonMatch[1] : content;
      ranking = JSON.parse(jsonStr.trim());
    } catch (e) {
      console.error('Failed to parse ranking:', e.message);
      console.log('Raw response:', content.substring(0, 500));
      return;
    }
  }

  // Print results
  console.log('\nüìä COMPARATIVE RANKINGS');
  console.log('='.repeat(60));

  ranking.rankings.forEach(r => {
    const medal = r.rank === 1 ? 'ü•á' : r.rank === 2 ? 'ü•à' : r.rank === 3 ? 'ü•â' : '  ';
    console.log(`\n${medal} #${r.rank}: ${r.personaName} (${(r.score * 100).toFixed(0)}%)`);
    console.log('   Standout Features:');
    r.standoutFeatures?.forEach(f => console.log(`   ‚úì ${f}`));
    console.log('   Weaknesses:');
    r.weaknesses?.forEach(w => console.log(`   ‚ö† ${w}`));
  });

  console.log('\n' + '='.repeat(60));
  console.log('üéØ WINNING ELEMENTS TO COMBINE');
  console.log('='.repeat(60));
  Object.entries(ranking.winningElements || {}).forEach(([key, value]) => {
    console.log(`\n${key}:`);
    console.log(`  ${value}`);
  });

  console.log('\n' + '='.repeat(60));
  console.log('‚ú® OPTIMAL PROMPT ELEMENTS');
  console.log('='.repeat(60));
  ranking.optimalPromptElements?.forEach((e, i) => {
    console.log(`${i + 1}. ${e}`);
  });

  console.log('\n' + '='.repeat(60));
  console.log('üìù SYNTHESIZED OPTIMAL PROMPT');
  console.log('='.repeat(60));
  console.log(ranking.synthesizedPrompt);

  // Save results
  fs.writeFileSync(
    path.join(OUTPUT_DIR, 'comparative-ranking.json'),
    JSON.stringify(ranking, null, 2)
  );

  // Generate HTML report
  const html = generateRankingReport(ranking);
  fs.writeFileSync(path.join(OUTPUT_DIR, 'ranking-report.html'), html);

  console.log(`\nüìÅ Results: ${OUTPUT_DIR}`);
  console.log(`üìä Report: ${path.join(OUTPUT_DIR, 'ranking-report.html')}`);

  return ranking;
}

function generateRankingReport(ranking) {
  const rankCards = ranking.rankings.map(r => {
    const medal = r.rank === 1 ? 'ü•á' : r.rank === 2 ? 'ü•à' : r.rank === 3 ? 'ü•â' : `#${r.rank}`;
    const bgColor = r.rank === 1 ? 'rgba(34, 197, 94, 0.2)' : r.rank === 2 ? 'rgba(234, 179, 8, 0.2)' : r.rank === 3 ? 'rgba(249, 115, 22, 0.2)' : 'rgba(255,255,255,0.05)';

    return `
      <div class="rank-card" style="background: ${bgColor}; border-left: 4px solid ${r.rank === 1 ? '#22c55e' : r.rank === 2 ? '#eab308' : r.rank === 3 ? '#f97316' : '#64748b'};">
        <div class="rank-header">
          <span class="medal">${medal}</span>
          <span class="name">${r.personaName}</span>
          <span class="score">${(r.score * 100).toFixed(0)}%</span>
        </div>
        <div class="features">
          <h4>‚úì Standout Features:</h4>
          <ul>${(r.standoutFeatures || []).map(f => `<li>${f}</li>`).join('')}</ul>
        </div>
        <div class="weaknesses">
          <h4>‚ö† Weaknesses:</h4>
          <ul>${(r.weaknesses || []).map(w => `<li>${w}</li>`).join('')}</ul>
        </div>
      </div>
    `;
  }).join('');

  return `<!DOCTYPE html>
<html>
<head>
  <title>Comparative Ranking Results</title>
  <style>
    body { font-family: system-ui; background: #0f172a; color: #e2e8f0; padding: 40px; }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { color: #22c55e; text-align: center; }
    .rank-card { padding: 20px; margin: 16px 0; border-radius: 12px; }
    .rank-header { display: flex; align-items: center; gap: 16px; margin-bottom: 16px; }
    .medal { font-size: 2rem; }
    .name { flex: 1; font-size: 1.2rem; font-weight: 600; }
    .score { font-size: 2rem; font-weight: 700; color: #22c55e; }
    .features, .weaknesses { margin: 12px 0; }
    h4 { margin: 8px 0; font-size: 0.9rem; color: #94a3b8; }
    ul { margin: 0; padding-left: 20px; }
    li { margin: 4px 0; font-size: 0.9rem; }
    .winning-elements { background: rgba(59, 130, 246, 0.1); padding: 24px; border-radius: 12px; margin: 32px 0; }
    .optimal-prompt { background: rgba(34, 197, 94, 0.1); padding: 24px; border-radius: 12px; margin: 32px 0; border: 1px solid rgba(34, 197, 94, 0.3); }
    .optimal-prompt pre { white-space: pre-wrap; background: rgba(0,0,0,0.3); padding: 16px; border-radius: 8px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üèÜ Comparative Ranking Results</h1>

    ${rankCards}

    <div class="winning-elements">
      <h2>üéØ Winning Elements by Category</h2>
      ${Object.entries(ranking.winningElements || {}).map(([k, v]) => `
        <p><strong>${k}:</strong> ${v}</p>
      `).join('')}
    </div>

    <div class="optimal-prompt">
      <h2>‚ú® Synthesized Optimal Prompt</h2>
      <pre>${ranking.synthesizedPrompt}</pre>
    </div>
  </div>
</body>
</html>`;
}

runComparativeRanking().catch(console.error);

export { runComparativeRanking };
