/**
 * Migration System Tests
 * 
 * Tests for schema migration and node normalization.
 * These are P0 (critical) tests - data integrity depends on them.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { 
    legacyTree, 
    minimalTree, 
    complexTree,
    cloneTree 
} from '../fixtures/trees.js';

// Import from extracted module (generated by extract-testable.js)
import { 
    migrateTree, 
    normalizeNode, 
    SCHEMA_VERSION,
    createTestTree
} from '../treelisty-core.js';

describe('Migration System', () => {
    
    describe('SCHEMA_VERSION constant', () => {
        it('should be defined', () => {
            expect(SCHEMA_VERSION).toBeDefined();
        });

        it('should be a positive integer', () => {
            expect(Number.isInteger(SCHEMA_VERSION)).toBe(true);
            expect(SCHEMA_VERSION).toBeGreaterThan(0);
        });

        it('should be version 1 for current implementation', () => {
            expect(SCHEMA_VERSION).toBe(1);
        });
    });

    describe('migrateTree()', () => {
        
        describe('version handling', () => {
            it('should add schemaVersion to legacy trees (no version)', () => {
                const tree = cloneTree(legacyTree);
                expect(tree.schemaVersion).toBeUndefined();
                
                migrateTree(tree);
                
                expect(tree.schemaVersion).toBe(SCHEMA_VERSION);
            });

            it('should add schemaVersion to trees with version 0', () => {
                const tree = createTestTree({ schemaVersion: 0 });
                
                migrateTree(tree);
                
                expect(tree.schemaVersion).toBe(SCHEMA_VERSION);
            });

            it('should not modify trees already at current version', () => {
                const tree = cloneTree(minimalTree);
                const originalJson = JSON.stringify(tree);
                
                migrateTree(tree);
                
                // Tree should be unchanged (except any intentional migrations)
                expect(tree.schemaVersion).toBe(SCHEMA_VERSION);
            });

            it('should not downgrade newer schema versions', () => {
                const futureTree = createTestTree({ schemaVersion: 99 });
                
                migrateTree(futureTree);
                
                // Should keep the future version (graceful handling)
                expect(futureTree.schemaVersion).toBe(99);
            });
        });

        describe('hyperedges initialization', () => {
            it('should add empty hyperedges array if missing', () => {
                const tree = cloneTree(legacyTree);
                expect(tree.hyperedges).toBeUndefined();
                
                migrateTree(tree);
                
                expect(tree.hyperedges).toEqual([]);
            });

            it('should preserve existing hyperedges', () => {
                const tree = cloneTree(complexTree);
                const originalHyperedges = tree.hyperedges.length;
                
                migrateTree(tree);
                
                expect(tree.hyperedges.length).toBe(originalHyperedges);
            });
        });

        describe('snapshotRefs initialization', () => {
            it('should add empty snapshotRefs array if missing', () => {
                const tree = cloneTree(legacyTree);
                expect(tree.snapshotRefs).toBeUndefined();
                
                migrateTree(tree);
                
                expect(tree.snapshotRefs).toEqual([]);
            });

            it('should preserve existing snapshotRefs', () => {
                const tree = cloneTree(complexTree);
                const originalRefs = tree.snapshotRefs.length;
                
                migrateTree(tree);
                
                expect(tree.snapshotRefs.length).toBe(originalRefs);
            });
        });

        describe('node normalization', () => {
            it('should normalize all nodes in legacy tree', () => {
                const tree = cloneTree(legacyTree);
                
                migrateTree(tree);
                
                // Check root
                expect(tree.provenance).toBeDefined();
                expect(tree.phenomenology).toBeDefined();
                expect(tree.metrics).toBeDefined();
                
                // Check nested nodes
                const phase = tree.children[0];
                expect(phase.provenance).toBeDefined();
                
                const item = phase.items[0];
                expect(item.provenance).toBeDefined();
            });
        });
    });

    describe('normalizeNode()', () => {
        
        describe('provenance stamping', () => {
            it('should add provenance to nodes without it', () => {
                const node = { id: 'test', name: 'Test' };
                
                normalizeNode(node, 'user');
                
                expect(node.provenance).toBeDefined();
                expect(node.provenance.source).toBe('user');
                expect(node.provenance.timestamp).toBeDefined();
                expect(node.provenance.modelId).toBeNull();
            });

            it('should use "legacy" as default source', () => {
                const node = { id: 'test', name: 'Test' };
                
                normalizeNode(node);
                
                expect(node.provenance.source).toBe('legacy');
            });

            it('should not overwrite existing provenance', () => {
                const existingProvenance = {
                    source: 'ai-claude',
                    timestamp: '2025-01-01T00:00:00Z',
                    modelId: 'claude-sonnet-4'
                };
                const node = { id: 'test', provenance: existingProvenance };
                
                normalizeNode(node, 'user');
                
                expect(node.provenance.source).toBe('ai-claude');
                expect(node.provenance.modelId).toBe('claude-sonnet-4');
            });

            it('should create valid ISO timestamp', () => {
                const node = { id: 'test' };
                
                normalizeNode(node, 'user');
                
                const timestamp = node.provenance.timestamp;
                expect(() => new Date(timestamp)).not.toThrow();
                expect(new Date(timestamp).toISOString()).toBe(timestamp);
            });
        });

        describe('phenomenology initialization', () => {
            it('should add empty phenomenology array', () => {
                const node = { id: 'test' };
                
                normalizeNode(node);
                
                expect(node.phenomenology).toEqual([]);
            });

            it('should not overwrite existing phenomenology', () => {
                const node = { 
                    id: 'test',
                    phenomenology: [{ content: 'existing reflection' }]
                };
                
                normalizeNode(node);
                
                expect(node.phenomenology.length).toBe(1);
                expect(node.phenomenology[0].content).toBe('existing reflection');
            });
        });

        describe('metrics initialization', () => {
            it('should add metrics object with defaults', () => {
                const node = { id: 'test' };
                
                normalizeNode(node);
                
                expect(node.metrics).toBeDefined();
                expect(node.metrics.editCount).toBe(0);
                expect(node.metrics.focusTime).toBe(0);
                expect(node.metrics.lastModified).toBeDefined();
            });

            it('should not overwrite existing metrics', () => {
                const node = { 
                    id: 'test',
                    metrics: { editCount: 5, focusTime: 1000, lastModified: 123 }
                };
                
                normalizeNode(node);
                
                expect(node.metrics.editCount).toBe(5);
                expect(node.metrics.focusTime).toBe(1000);
            });
        });

        describe('recursive normalization', () => {
            it('should normalize children array', () => {
                const tree = {
                    id: 'root',
                    children: [
                        { id: 'child-1' },
                        { id: 'child-2' }
                    ]
                };
                
                normalizeNode(tree, 'user');
                
                expect(tree.children[0].provenance).toBeDefined();
                expect(tree.children[1].provenance).toBeDefined();
            });

            it('should normalize items array', () => {
                const phase = {
                    id: 'phase-0',
                    items: [
                        { id: 'item-0' },
                        { id: 'item-1' }
                    ]
                };
                
                normalizeNode(phase, 'user');
                
                expect(phase.items[0].provenance).toBeDefined();
                expect(phase.items[1].provenance).toBeDefined();
            });

            it('should normalize subItems array', () => {
                const item = {
                    id: 'item-0',
                    subItems: [
                        { id: 'sub-0' },
                        { id: 'sub-1' }
                    ]
                };
                
                normalizeNode(item, 'user');
                
                expect(item.subItems[0].provenance).toBeDefined();
                expect(item.subItems[1].provenance).toBeDefined();
            });

            it('should handle deeply nested structures', () => {
                const tree = {
                    id: 'root',
                    children: [{
                        id: 'phase',
                        items: [{
                            id: 'item',
                            subItems: [{
                                id: 'subtask',
                                subItems: [{
                                    id: 'nested-subtask'
                                }]
                            }]
                        }]
                    }]
                };
                
                normalizeNode(tree, 'legacy');
                
                const deepNode = tree.children[0].items[0].subItems[0].subItems[0];
                expect(deepNode.provenance).toBeDefined();
                expect(deepNode.provenance.source).toBe('legacy');
            });

            it('should propagate source to all descendants', () => {
                const tree = {
                    id: 'root',
                    children: [{ id: 'child', items: [{ id: 'item' }] }]
                };
                
                normalizeNode(tree, 'ai-import');
                
                expect(tree.provenance.source).toBe('ai-import');
                expect(tree.children[0].provenance.source).toBe('ai-import');
                expect(tree.children[0].items[0].provenance.source).toBe('ai-import');
            });
        });

        describe('edge cases', () => {
            it('should handle null node gracefully', () => {
                expect(() => normalizeNode(null)).not.toThrow();
            });

            it('should handle undefined node gracefully', () => {
                expect(() => normalizeNode(undefined)).not.toThrow();
            });

            it('should handle empty children arrays', () => {
                const node = {
                    id: 'test',
                    children: [],
                    items: [],
                    subItems: []
                };
                
                expect(() => normalizeNode(node)).not.toThrow();
                expect(node.provenance).toBeDefined();
            });

            it('should handle missing children arrays', () => {
                const node = { id: 'test' };
                
                expect(() => normalizeNode(node)).not.toThrow();
            });
        });
    });
});
