#!/usr/bin/env node
/**
 * Extract Testable Modules from treeplexity.html
 * 
 * This script parses the monolithic HTML file and extracts
 * JavaScript functions into a testable ES module.
 * 
 * Run: node scripts/extract-testable.js
 * Output: test/treelisty-core.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
// Path: test/treelisty-test/scripts -> test/treelisty-test -> test -> root
const SOURCE_FILE = path.join(__dirname, '..', '..', '..', 'treeplexity.html');
const OUTPUT_FILE = path.join(__dirname, '..', 'test', 'treelisty-core.js');

// Functions to extract (name -> export name)
const FUNCTIONS_TO_EXTRACT = [
    // Migration system
    'normalizeNode',
    'migrateTree',

    // Tree operations
    // 'getNodeById', // Extracted below as wrapper with tree parameter
    // 'getAllNodes', // Implemented as utility function in output
    'getAllProjectItems',
    // 'findParent', // Implemented as utility function in output
    'getItemMaxDepth',
    'getMaxDepth',

    // Pattern system
    'getPatternLabels',
    'translateNode',
    'getPatternKey',

    // AI Configuration
    'getAIConfig',
    'applyPersonaTuning',

    // Serialization helpers
    'generateId',

    // Provenance helpers (if they exist as standalone functions)
    'stampProvenance'

    // Note: Collaboration functions (getDeviceFingerprint, extractSubtree, etc.)
    // are implemented manually in the TEST UTILITIES section below
    // because they need mock LZString and test-compatible implementations
];

// Constants to extract
// Note: TRANSLATION_RULES is excluded because it contains arrow functions
// that confuse the brace-matching parser. Add a stub in the generated file instead.
const CONSTANTS_TO_EXTRACT = [
    'SCHEMA_VERSION',
    'PATTERNS'
];

// Constants that need manual stubs (too complex to extract)
const STUB_CONSTANTS = [
    'TRANSLATION_RULES'
];

function main() {
    console.log('üîß Extracting testable modules from treeplexity.html...\n');
    
    // Check if source file exists
    if (!fs.existsSync(SOURCE_FILE)) {
        console.error(`‚ùå Source file not found: ${SOURCE_FILE}`);
        console.error('   Make sure treeplexity.html is in the parent directory');
        process.exit(1);
    }
    
    // Read source file
    let sourceCode = fs.readFileSync(SOURCE_FILE, 'utf8');
    
    // Convert CRLF to LF
    sourceCode = sourceCode.replace(/\r\n/g, '\n');
    
    // Extract JavaScript from <script> tags
    const scriptMatches = sourceCode.match(/<script>([\s\S]*?)<\/script>/g);
    if (!scriptMatches) {
        console.error('‚ùå No <script> tags found in source file');
        process.exit(1);
    }
    
    // Combine all script content
    let jsCode = scriptMatches
        .map(match => match.replace(/<\/?script>/g, ''))
        .join('\n\n');
    
    console.log(`üìÑ Extracted ${jsCode.length.toLocaleString()} characters of JavaScript\n`);
    
    // Build output module
    let output = `/**
 * Treelisty Core - Extracted Testable Module
 * 
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 * Generated: ${new Date().toISOString()}
 * Source: treeplexity.html
 * 
 * This file is generated by scripts/extract-testable.js
 * Run 'npm run extract' to regenerate after source changes.
 */

// ============================================================================
// MOCK GLOBALS (for testing without DOM)
// ============================================================================

// Mock capexTree for functions that reference it
let capexTree = {
    id: 'root',
    name: 'Test Project',
    type: 'root',
    schemaVersion: 1,
    hyperedges: [],
    snapshotRefs: [],
    aiConfig: {},
    children: []
};

// Mock currentPattern
let currentPattern = 'generic';

// Setter for tests to inject tree state
export function setCapexTree(tree) {
    capexTree = tree;
}

export function getCapexTree() {
    return capexTree;
}

export function setCurrentPattern(pattern) {
    currentPattern = pattern;
}

// ============================================================================
// EXTRACTED CONSTANTS
// ============================================================================

`;

    // Extract constants
    for (const constName of CONSTANTS_TO_EXTRACT) {
        const constMatch = extractConstant(jsCode, constName);
        if (constMatch) {
            output += `export ${constMatch}\n\n`;
            console.log(`‚úÖ Extracted constant: ${constName}`);
        } else {
            console.log(`‚ö†Ô∏è  Constant not found: ${constName}`);
        }
    }

    // Add stubs for complex constants
    for (const constName of STUB_CONSTANTS) {
        output += `// ${constName} is too complex to extract (contains arrow functions)
// Stub provided for test compatibility
export const ${constName} = {};

`;
        console.log(`üìù Stub created for: ${constName}`);
    }

    output += `
// ============================================================================
// EXTRACTED FUNCTIONS
// ============================================================================

`;

    // Extract functions
    for (const funcName of FUNCTIONS_TO_EXTRACT) {
        const funcMatch = extractFunction(jsCode, funcName);
        if (funcMatch) {
            // Convert to exportable format
            const exportable = funcMatch
                .replace(/^function /, 'export function ')
                .replace(/^async function /, 'export async function ');
            output += `${exportable}\n\n`;
            console.log(`‚úÖ Extracted function: ${funcName}`);
        } else {
            // Create stub for missing functions
            output += `// TODO: Function '${funcName}' not found in source - implement or remove from extraction list
export function ${funcName}() {
    throw new Error('${funcName} not yet extracted from source');
}

`;
            console.log(`‚ö†Ô∏è  Function not found (stub created): ${funcName}`);
        }
    }

    // Add utility exports
    output += `
// ============================================================================
// TEST UTILITIES
// ============================================================================

/**
 * Create a minimal valid tree for testing
 */
export function createTestTree(overrides = {}) {
    return {
        id: 'root',
        name: 'Test Project',
        type: 'root',
        schemaVersion: 1,
        hyperedges: [],
        snapshotRefs: [],
        aiConfig: {},
        children: [],
        ...overrides
    };
}

// Counter for unique IDs
let testNodeCounter = 0;

/**
 * Create a test node with provenance
 */
export function createTestNode(type, overrides = {}) {
    testNodeCounter++;
    const base = {
        id: \`\${type}-\${Date.now()}-\${testNodeCounter}\`,
        name: \`Test \${type}\`,
        type: type,
        provenance: {
            source: 'user',
            timestamp: new Date().toISOString(),
            modelId: null
        },
        phenomenology: [],
        metrics: {
            editCount: 0,
            focusTime: 0,
            lastModified: Date.now()
        }
    };

    return { ...base, ...overrides };
}

/**
 * Deep clone a tree for testing
 */
export function cloneTree(tree) {
    return JSON.parse(JSON.stringify(tree));
}

/**
 * Get a node by ID from a tree
 * Wrapper that takes tree as parameter (source uses global capexTree)
 */
export function getNodeById(tree, nodeId) {
    if (!tree || !nodeId) return null;
    if (tree.id === nodeId) return tree;

    function searchNode(node) {
        if (!node) return null;
        if (node.id === nodeId) return node;

        // Search children (phases)
        if (node.children) {
            for (const child of node.children) {
                const found = searchNode(child);
                if (found) return found;
            }
        }

        // Search items
        if (node.items) {
            for (const item of node.items) {
                const found = searchNode(item);
                if (found) return found;
            }
        }

        // Search subItems
        if (node.subItems) {
            for (const sub of node.subItems) {
                const found = searchNode(sub);
                if (found) return found;
            }
        }

        return null;
    }

    return searchNode(tree);
}

/**
 * Get all nodes in a tree (flattened)
 * This is a utility function for testing - not extracted from source
 */
export function getAllNodes(tree) {
    const nodes = [];

    function walk(node) {
        if (!node) return;
        nodes.push(node);

        // Check all possible child arrays
        const children = node.children || [];
        const items = node.items || [];
        const subItems = node.subItems || [];

        [...children, ...items, ...subItems].forEach(walk);
    }

    walk(tree);
    return nodes;
}

/**
 * Find the parent of a node by id
 * This is a utility function for testing - not extracted from source
 */
export function findParent(tree, nodeId) {
    if (!tree || !nodeId) return null;

    function search(node) {
        if (!node) return null;

        const children = node.children || [];
        const items = node.items || [];
        const subItems = node.subItems || [];
        const allChildren = [...children, ...items, ...subItems];

        for (const child of allChildren) {
            if (child.id === nodeId) {
                return node;
            }
            const found = search(child);
            if (found) return found;
        }

        return null;
    }

    return search(tree);
}

// ============================================================================
// COLLABORATION UTILITIES (Build 199+)
// ============================================================================

/**
 * Mock LZString for testing (simplified - real impl uses library)
 */
const LZString = {
    compressToEncodedURIComponent: (str) => {
        // Simple base64 encoding for tests (real impl uses LZ compression)
        return btoa(encodeURIComponent(str));
    },
    decompressFromEncodedURIComponent: (str) => {
        try {
            return decodeURIComponent(atob(str));
        } catch (e) {
            return null;
        }
    }
};

/**
 * Get device fingerprint (test stub returns consistent value)
 */
export function getDeviceFingerprint() {
    return 'device-test-fingerprint-12345';
}

/**
 * Count nodes in a subtree
 */
export function countSubtreeNodes(node) {
    if (!node) return 0;
    let count = 1;
    const items = node.items || [];
    const subItems = node.subItems || [];
    const children = node.children || [];
    [...items, ...subItems, ...children].forEach(child => {
        count += countSubtreeNodes(child);
    });
    return count;
}

/**
 * Get ancestry path to a node
 * @param {object} tree - Root tree
 * @param {string} nodeId - Target node ID
 * @returns {Array} Array of ancestor objects {id, name, icon}
 */
export function getAncestryPath(tree, nodeId) {
    const path = [];

    function search(node, ancestors) {
        if (node.id === nodeId) {
            path.push(...ancestors);
            return true;
        }

        const currentAncestor = { id: node.id, name: node.name, icon: node.icon || 'üìÑ' };
        const children = node.children || [];
        const items = node.items || [];
        const subItems = node.subItems || [];

        for (const child of [...children, ...items, ...subItems]) {
            if (search(child, [...ancestors, currentAncestor])) {
                return true;
            }
        }
        return false;
    }

    search(tree, []);
    return path;
}

/**
 * Extract subtree for collaboration sharing
 * @param {object} tree - Source tree
 * @param {string[]} nodeIds - IDs of nodes to extract
 * @param {string|null} hyperedgeId - Optional hyperedge
 * @returns {object} Branch token
 */
export function extractSubtree(tree, nodeIds, hyperedgeId = null) {
    if (!nodeIds || nodeIds.length === 0) {
        return { error: 'No nodes selected for sharing' };
    }

    const ancestry = getAncestryPath(tree, nodeIds[0]);
    const nodes = [];
    let totalNodeCount = 0;

    for (const id of nodeIds) {
        const node = getNodeById(tree, id);
        if (node) {
            const cloned = JSON.parse(JSON.stringify(node));
            nodes.push(cloned);
            totalNodeCount += countSubtreeNodes(cloned);
        }
    }

    if (nodes.length === 0) {
        return { error: 'No valid nodes found to share' };
    }

    return {
        branchId: \`branch-\${Date.now()}-\${Math.random().toString(36).substr(2, 9)}\`,
        sourceProjectId: tree.id,
        sourceProjectName: tree.name,
        sourcePattern: 'generic',
        createdAt: new Date().toISOString(),
        createdBy: getDeviceFingerprint(),
        ancestry,
        hyperedgeId,
        selectedNodeIds: nodeIds,
        nodes,
        schemaVersion: 2,
        _meta: {
            nodeCount: totalNodeCount,
            estimatedURLSize: JSON.stringify(nodes).length * 0.6
        }
    };
}

/**
 * Generate shareable URL from branch
 */
export function generateBranchURL(branch) {
    const branchToEncode = { ...branch };
    delete branchToEncode._meta;
    const json = JSON.stringify(branchToEncode);
    const compressed = LZString.compressToEncodedURIComponent(json);
    return \`https://treelisty.netlify.app/?branch=\${compressed}\`;
}

/**
 * Parse branch from URL parameter
 */
export function parseBranchFromURL(compressedBranch) {
    if (!compressedBranch) return null;
    try {
        const json = LZString.decompressFromEncodedURIComponent(compressedBranch);
        if (!json) return null;
        return JSON.parse(json);
    } catch (e) {
        return null;
    }
}

/**
 * Perform branch merge into tree
 * @param {object} tree - Target tree (modified in place)
 * @param {object} branch - Branch to merge
 */
export function performBranchMerge(tree, branch) {
    if (!branch || !branch.nodes || branch.nodes.length === 0) {
        return;
    }

    for (const incomingNode of branch.nodes) {
        const existingNode = getNodeById(tree, incomingNode.id);

        if (existingNode) {
            // Deep merge: replace all properties
            for (const key of Object.keys(existingNode)) {
                if (key !== 'id') {
                    delete existingNode[key];
                }
            }
            for (const key of Object.keys(incomingNode)) {
                existingNode[key] = JSON.parse(JSON.stringify(incomingNode[key]));
            }
        } else {
            // Add as new node - find insertion point
            const ancestry = branch.ancestry || [];
            let parent = tree;
            for (const ancestor of ancestry) {
                const found = getNodeById(tree, ancestor.id);
                if (found) parent = found;
            }

            if (incomingNode.type === 'phase') {
                parent.children = parent.children || [];
                parent.children.push(incomingNode);
            } else if (incomingNode.type === 'item') {
                const phase = parent.children?.[0] || parent;
                phase.items = phase.items || [];
                phase.items.push(incomingNode);
            } else {
                // Subtask
                if (parent.items?.[0]) {
                    parent.items[0].subItems = parent.items[0].subItems || [];
                    parent.items[0].subItems.push(incomingNode);
                }
            }
        }
    }
}
`;

    // Ensure output directory exists
    const outputDir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Write output file
    fs.writeFileSync(OUTPUT_FILE, output);
    
    console.log(`\n‚úÖ Generated: ${OUTPUT_FILE}`);
    console.log(`   Size: ${(output.length / 1024).toFixed(1)} KB`);
}

/**
 * Extract a function definition from source code
 * Uses robust brace-matching that handles strings/templates
 */
function extractFunction(code, funcName) {
    // Use brace-matching approach directly (more reliable)
    return extractFunctionByBraceMatching(code, funcName);
}

/**
 * Extract function using brace matching (handles strings and template literals)
 */
function extractFunctionByBraceMatching(code, funcName) {
    const startPatterns = [
        `function ${funcName}(`,
        `function ${funcName} (`,
        `async function ${funcName}(`
    ];

    let startIndex = -1;

    for (const pattern of startPatterns) {
        const idx = code.indexOf(pattern);
        if (idx !== -1) {
            startIndex = idx;
            break;
        }
    }

    if (startIndex === -1) return null;

    // Find the opening brace
    let braceStart = code.indexOf('{', startIndex);
    if (braceStart === -1) return null;

    // Match braces, accounting for strings
    let depth = 0;
    let endIndex = braceStart;
    let inString = false;
    let stringChar = '';
    let inTemplate = false;
    let escapeNext = false;

    for (let i = braceStart; i < code.length; i++) {
        const char = code[i];
        const prevChar = i > 0 ? code[i-1] : '';

        // Handle escape sequences
        if (escapeNext) {
            escapeNext = false;
            continue;
        }
        if (char === '\\') {
            escapeNext = true;
            continue;
        }

        // Handle template literals
        if (char === '`') {
            inTemplate = !inTemplate;
            continue;
        }

        // Handle strings
        if ((char === '"' || char === "'") && !inTemplate) {
            if (!inString) {
                inString = true;
                stringChar = char;
            } else if (char === stringChar) {
                inString = false;
            }
            continue;
        }

        // Only count braces outside strings
        if (!inString && !inTemplate) {
            if (char === '{') depth++;
            if (char === '}') depth--;
            if (depth === 0) {
                endIndex = i + 1;
                break;
            }
        }
    }

    return code.slice(startIndex, endIndex);
}

/**
 * Extract a constant definition from source code
 */
function extractConstant(code, constName) {
    // Try const declaration
    let pattern = new RegExp(`(const ${constName}\\s*=\\s*[\\s\\S]*?);(?=\\s*\\/\\/|\\s*const|\\s*let|\\s*var|\\s*function|\\s*$)`, 'm');
    let match = code.match(pattern);
    
    if (match) {
        return match[1] + ';';
    }
    
    // Try for object constant (PATTERNS, TRANSLATION_RULES)
    if (constName === 'PATTERNS' || constName === 'TRANSLATION_RULES') {
        return extractObjectConstant(code, constName);
    }
    
    // Try simple constant
    pattern = new RegExp(`const ${constName}\\s*=\\s*([^;]+);`);
    match = code.match(pattern);
    if (match) {
        return `const ${constName} = ${match[1]};`;
    }
    
    return null;
}

/**
 * Extract large object constants using brace matching (handles strings)
 */
function extractObjectConstant(code, constName) {
    const startPattern = `const ${constName} = {`;
    const startIndex = code.indexOf(startPattern);

    if (startIndex === -1) return null;

    const braceStart = code.indexOf('{', startIndex);
    if (braceStart === -1) return null;

    // Match braces, accounting for strings
    let depth = 0;
    let endIndex = braceStart;
    let inString = false;
    let stringChar = '';
    let inTemplate = false;
    let escapeNext = false;

    for (let i = braceStart; i < code.length; i++) {
        const char = code[i];

        // Handle escape sequences
        if (escapeNext) {
            escapeNext = false;
            continue;
        }
        if (char === '\\') {
            escapeNext = true;
            continue;
        }

        // Handle template literals
        if (char === '`') {
            inTemplate = !inTemplate;
            continue;
        }

        // Handle strings
        if ((char === '"' || char === "'") && !inTemplate) {
            if (!inString) {
                inString = true;
                stringChar = char;
            } else if (char === stringChar) {
                inString = false;
            }
            continue;
        }

        // Only count braces outside strings
        if (!inString && !inTemplate) {
            if (char === '{') depth++;
            if (char === '}') depth--;
            if (depth === 0) {
                endIndex = i + 1;
                break;
            }
        }
    }

    // Find the semicolon after closing brace
    const semiIndex = code.indexOf(';', endIndex);
    if (semiIndex !== -1 && semiIndex < endIndex + 5) {
        endIndex = semiIndex + 1;
    }

    return code.slice(startIndex, endIndex);
}

// Run extraction
main();
