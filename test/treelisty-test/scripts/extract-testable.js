#!/usr/bin/env node
/**
 * Extract Testable Modules from treeplexity.html
 * 
 * This script parses the monolithic HTML file and extracts
 * JavaScript functions into a testable ES module.
 * 
 * Run: node scripts/extract-testable.js
 * Output: test/treelisty-core.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
// Path: test/treelisty-test/scripts -> test/treelisty-test -> test -> root
const SOURCE_FILE = path.join(__dirname, '..', '..', '..', 'treeplexity.html');
const OUTPUT_FILE = path.join(__dirname, '..', 'test', 'treelisty-core.js');

// Functions to extract (name -> export name)
const FUNCTIONS_TO_EXTRACT = [
    // Migration system
    'normalizeNode',
    'migrateTree',
    
    // Tree operations
    // 'getNodeById', // Extracted below as wrapper with tree parameter
    // 'getAllNodes', // Implemented as utility function in output
    'getAllProjectItems',
    // 'findParent', // Implemented as utility function in output
    'getItemMaxDepth',
    'getMaxDepth',
    
    // Pattern system
    'getPatternLabels',
    'translateNode',
    'getPatternKey',
    
    // AI Configuration
    'getAIConfig',
    'applyPersonaTuning',
    
    // Serialization helpers
    'generateId',
    
    // Provenance helpers (if they exist as standalone functions)
    'stampProvenance'
];

// Constants to extract
// Note: TRANSLATION_RULES is excluded because it contains arrow functions
// that confuse the brace-matching parser. Add a stub in the generated file instead.
const CONSTANTS_TO_EXTRACT = [
    'SCHEMA_VERSION',
    'PATTERNS'
];

// Constants that need manual stubs (too complex to extract)
const STUB_CONSTANTS = [
    'TRANSLATION_RULES'
];

function main() {
    console.log('üîß Extracting testable modules from treeplexity.html...\n');
    
    // Check if source file exists
    if (!fs.existsSync(SOURCE_FILE)) {
        console.error(`‚ùå Source file not found: ${SOURCE_FILE}`);
        console.error('   Make sure treeplexity.html is in the parent directory');
        process.exit(1);
    }
    
    // Read source file
    let sourceCode = fs.readFileSync(SOURCE_FILE, 'utf8');
    
    // Convert CRLF to LF
    sourceCode = sourceCode.replace(/\r\n/g, '\n');
    
    // Extract JavaScript from <script> tags
    const scriptMatches = sourceCode.match(/<script>([\s\S]*?)<\/script>/g);
    if (!scriptMatches) {
        console.error('‚ùå No <script> tags found in source file');
        process.exit(1);
    }
    
    // Combine all script content
    let jsCode = scriptMatches
        .map(match => match.replace(/<\/?script>/g, ''))
        .join('\n\n');
    
    console.log(`üìÑ Extracted ${jsCode.length.toLocaleString()} characters of JavaScript\n`);
    
    // Build output module
    let output = `/**
 * Treelisty Core - Extracted Testable Module
 * 
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 * Generated: ${new Date().toISOString()}
 * Source: treeplexity.html
 * 
 * This file is generated by scripts/extract-testable.js
 * Run 'npm run extract' to regenerate after source changes.
 */

// ============================================================================
// MOCK GLOBALS (for testing without DOM)
// ============================================================================

// Mock capexTree for functions that reference it
let capexTree = {
    id: 'root',
    name: 'Test Project',
    type: 'root',
    schemaVersion: 1,
    hyperedges: [],
    snapshotRefs: [],
    aiConfig: {},
    children: []
};

// Mock currentPattern
let currentPattern = 'generic';

// Setter for tests to inject tree state
export function setCapexTree(tree) {
    capexTree = tree;
}

export function getCapexTree() {
    return capexTree;
}

export function setCurrentPattern(pattern) {
    currentPattern = pattern;
}

// ============================================================================
// EXTRACTED CONSTANTS
// ============================================================================

`;

    // Extract constants
    for (const constName of CONSTANTS_TO_EXTRACT) {
        const constMatch = extractConstant(jsCode, constName);
        if (constMatch) {
            output += `export ${constMatch}\n\n`;
            console.log(`‚úÖ Extracted constant: ${constName}`);
        } else {
            console.log(`‚ö†Ô∏è  Constant not found: ${constName}`);
        }
    }

    // Add stubs for complex constants
    for (const constName of STUB_CONSTANTS) {
        output += `// ${constName} is too complex to extract (contains arrow functions)
// Stub provided for test compatibility
export const ${constName} = {};

`;
        console.log(`üìù Stub created for: ${constName}`);
    }

    output += `
// ============================================================================
// EXTRACTED FUNCTIONS
// ============================================================================

`;

    // Extract functions
    for (const funcName of FUNCTIONS_TO_EXTRACT) {
        const funcMatch = extractFunction(jsCode, funcName);
        if (funcMatch) {
            // Convert to exportable format
            const exportable = funcMatch
                .replace(/^function /, 'export function ')
                .replace(/^async function /, 'export async function ');
            output += `${exportable}\n\n`;
            console.log(`‚úÖ Extracted function: ${funcName}`);
        } else {
            // Create stub for missing functions
            output += `// TODO: Function '${funcName}' not found in source - implement or remove from extraction list
export function ${funcName}() {
    throw new Error('${funcName} not yet extracted from source');
}

`;
            console.log(`‚ö†Ô∏è  Function not found (stub created): ${funcName}`);
        }
    }

    // Add utility exports
    output += `
// ============================================================================
// TEST UTILITIES
// ============================================================================

/**
 * Create a minimal valid tree for testing
 */
export function createTestTree(overrides = {}) {
    return {
        id: 'root',
        name: 'Test Project',
        type: 'root',
        schemaVersion: 1,
        hyperedges: [],
        snapshotRefs: [],
        aiConfig: {},
        children: [],
        ...overrides
    };
}

// Counter for unique IDs
let testNodeCounter = 0;

/**
 * Create a test node with provenance
 */
export function createTestNode(type, overrides = {}) {
    testNodeCounter++;
    const base = {
        id: \`\${type}-\${Date.now()}-\${testNodeCounter}\`,
        name: \`Test \${type}\`,
        type: type,
        provenance: {
            source: 'user',
            timestamp: new Date().toISOString(),
            modelId: null
        },
        phenomenology: [],
        metrics: {
            editCount: 0,
            focusTime: 0,
            lastModified: Date.now()
        }
    };

    return { ...base, ...overrides };
}

/**
 * Deep clone a tree for testing
 */
export function cloneTree(tree) {
    return JSON.parse(JSON.stringify(tree));
}

/**
 * Get a node by ID from a tree
 * Wrapper that takes tree as parameter (source uses global capexTree)
 */
export function getNodeById(tree, nodeId) {
    if (!tree || !nodeId) return null;
    if (tree.id === nodeId) return tree;

    function searchNode(node) {
        if (!node) return null;
        if (node.id === nodeId) return node;

        // Search children (phases)
        if (node.children) {
            for (const child of node.children) {
                const found = searchNode(child);
                if (found) return found;
            }
        }

        // Search items
        if (node.items) {
            for (const item of node.items) {
                const found = searchNode(item);
                if (found) return found;
            }
        }

        // Search subItems
        if (node.subItems) {
            for (const sub of node.subItems) {
                const found = searchNode(sub);
                if (found) return found;
            }
        }

        return null;
    }

    return searchNode(tree);
}

/**
 * Get all nodes in a tree (flattened)
 * This is a utility function for testing - not extracted from source
 */
export function getAllNodes(tree) {
    const nodes = [];

    function walk(node) {
        if (!node) return;
        nodes.push(node);

        // Check all possible child arrays
        const children = node.children || [];
        const items = node.items || [];
        const subItems = node.subItems || [];

        [...children, ...items, ...subItems].forEach(walk);
    }

    walk(tree);
    return nodes;
}

/**
 * Find the parent of a node by id
 * This is a utility function for testing - not extracted from source
 */
export function findParent(tree, nodeId) {
    if (!tree || !nodeId) return null;

    function search(node) {
        if (!node) return null;

        const children = node.children || [];
        const items = node.items || [];
        const subItems = node.subItems || [];
        const allChildren = [...children, ...items, ...subItems];

        for (const child of allChildren) {
            if (child.id === nodeId) {
                return node;
            }
            const found = search(child);
            if (found) return found;
        }

        return null;
    }

    return search(tree);
}
`;

    // Ensure output directory exists
    const outputDir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Write output file
    fs.writeFileSync(OUTPUT_FILE, output);
    
    console.log(`\n‚úÖ Generated: ${OUTPUT_FILE}`);
    console.log(`   Size: ${(output.length / 1024).toFixed(1)} KB`);
}

/**
 * Extract a function definition from source code
 * Uses robust brace-matching that handles strings/templates
 */
function extractFunction(code, funcName) {
    // Use brace-matching approach directly (more reliable)
    return extractFunctionByBraceMatching(code, funcName);
}

/**
 * Extract function using brace matching (handles strings and template literals)
 */
function extractFunctionByBraceMatching(code, funcName) {
    const startPatterns = [
        `function ${funcName}(`,
        `function ${funcName} (`,
        `async function ${funcName}(`
    ];

    let startIndex = -1;

    for (const pattern of startPatterns) {
        const idx = code.indexOf(pattern);
        if (idx !== -1) {
            startIndex = idx;
            break;
        }
    }

    if (startIndex === -1) return null;

    // Find the opening brace
    let braceStart = code.indexOf('{', startIndex);
    if (braceStart === -1) return null;

    // Match braces, accounting for strings
    let depth = 0;
    let endIndex = braceStart;
    let inString = false;
    let stringChar = '';
    let inTemplate = false;
    let escapeNext = false;

    for (let i = braceStart; i < code.length; i++) {
        const char = code[i];
        const prevChar = i > 0 ? code[i-1] : '';

        // Handle escape sequences
        if (escapeNext) {
            escapeNext = false;
            continue;
        }
        if (char === '\\') {
            escapeNext = true;
            continue;
        }

        // Handle template literals
        if (char === '`') {
            inTemplate = !inTemplate;
            continue;
        }

        // Handle strings
        if ((char === '"' || char === "'") && !inTemplate) {
            if (!inString) {
                inString = true;
                stringChar = char;
            } else if (char === stringChar) {
                inString = false;
            }
            continue;
        }

        // Only count braces outside strings
        if (!inString && !inTemplate) {
            if (char === '{') depth++;
            if (char === '}') depth--;
            if (depth === 0) {
                endIndex = i + 1;
                break;
            }
        }
    }

    return code.slice(startIndex, endIndex);
}

/**
 * Extract a constant definition from source code
 */
function extractConstant(code, constName) {
    // Try const declaration
    let pattern = new RegExp(`(const ${constName}\\s*=\\s*[\\s\\S]*?);(?=\\s*\\/\\/|\\s*const|\\s*let|\\s*var|\\s*function|\\s*$)`, 'm');
    let match = code.match(pattern);
    
    if (match) {
        return match[1] + ';';
    }
    
    // Try for object constant (PATTERNS, TRANSLATION_RULES)
    if (constName === 'PATTERNS' || constName === 'TRANSLATION_RULES') {
        return extractObjectConstant(code, constName);
    }
    
    // Try simple constant
    pattern = new RegExp(`const ${constName}\\s*=\\s*([^;]+);`);
    match = code.match(pattern);
    if (match) {
        return `const ${constName} = ${match[1]};`;
    }
    
    return null;
}

/**
 * Extract large object constants using brace matching (handles strings)
 */
function extractObjectConstant(code, constName) {
    const startPattern = `const ${constName} = {`;
    const startIndex = code.indexOf(startPattern);

    if (startIndex === -1) return null;

    const braceStart = code.indexOf('{', startIndex);
    if (braceStart === -1) return null;

    // Match braces, accounting for strings
    let depth = 0;
    let endIndex = braceStart;
    let inString = false;
    let stringChar = '';
    let inTemplate = false;
    let escapeNext = false;

    for (let i = braceStart; i < code.length; i++) {
        const char = code[i];

        // Handle escape sequences
        if (escapeNext) {
            escapeNext = false;
            continue;
        }
        if (char === '\\') {
            escapeNext = true;
            continue;
        }

        // Handle template literals
        if (char === '`') {
            inTemplate = !inTemplate;
            continue;
        }

        // Handle strings
        if ((char === '"' || char === "'") && !inTemplate) {
            if (!inString) {
                inString = true;
                stringChar = char;
            } else if (char === stringChar) {
                inString = false;
            }
            continue;
        }

        // Only count braces outside strings
        if (!inString && !inTemplate) {
            if (char === '{') depth++;
            if (char === '}') depth--;
            if (depth === 0) {
                endIndex = i + 1;
                break;
            }
        }
    }

    // Find the semicolon after closing brace
    const semiIndex = code.indexOf(';', endIndex);
    if (semiIndex !== -1 && semiIndex < endIndex + 5) {
        endIndex = semiIndex + 1;
    }

    return code.slice(startIndex, endIndex);
}

// Run extraction
main();
